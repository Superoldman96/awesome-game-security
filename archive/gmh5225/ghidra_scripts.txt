Project Path: arc_gmh5225_ghidra_scripts_frmf79xb

Source Tree:

```txt
arc_gmh5225_ghidra_scripts_frmf79xb
├── ArmRopDouble.py
├── ArmRopFind.py
├── ArmRopMovR0.py
├── ArmRopRegisterControl.py
├── ArmRopRegisterMove.py
├── ArmRopStackFinder.py
├── ArmRopSummary.py
├── ArmRopSystem.py
├── ArmToThumb.py
├── CallChain.py
├── CodatifyFixupCode.py
├── CodatifyFixupData.py
├── Fluorescence.py
├── FunctionProfiler.py
├── LeafBlowerFormatString.py
├── LeafBlowerLeafFunctions.py
├── LocalXRefs.py
├── MipsRopDouble.py
├── MipsRopEpilogue.py
├── MipsRopFind.py
├── MipsRopIret.py
├── MipsRopLia0.py
├── MipsRopPrologue.py
├── MipsRopShellcode.py
├── MipsRopStackFinder.py
├── MipsRopSummary.py
├── MipsRopSystem.py
├── MipsRopSystemChain.py
├── Operator.py
├── README.md
├── RenameVariables.py
├── RizzoApply.py
├── RizzoSave.py
├── readmes
│   ├── armrop.md
│   ├── callchain.md
│   ├── codatify.md
│   ├── fluorescence.md
│   ├── func_profiler.md
│   ├── img
│   │   ├── after_code.png
│   │   ├── after_data.png
│   │   ├── after_xref.png
│   │   ├── arm_dis.png
│   │   ├── arm_rop_double.png
│   │   ├── arm_rop_mov_r0.png
│   │   ├── armrop_find.png
│   │   ├── armrop_registercontrol.png
│   │   ├── armrop_registermove.png
│   │   ├── armrop_stackfinder.png
│   │   ├── armrop_summary.png
│   │   ├── armrop_system.png
│   │   ├── before_code.png
│   │   ├── before_data.png
│   │   ├── before_xref.png
│   │   ├── bookmark.png
│   │   ├── call_chain_graph.png
│   │   ├── call_chain_text.png
│   │   ├── double.png
│   │   ├── epilogue.png
│   │   ├── epilogue_input.png
│   │   ├── find.png
│   │   ├── find_dialog.png
│   │   ├── fluorescence.png
│   │   ├── format.png
│   │   ├── function_profiler.png
│   │   ├── iret.png
│   │   ├── leaf.png
│   │   ├── lia0.png
│   │   ├── local_xrefs.png
│   │   ├── operator.png
│   │   ├── prologue.png
│   │   ├── rename_variables.png
│   │   ├── rizzo_apply.png
│   │   ├── rizzo_save.png
│   │   ├── shellcode_chain.png
│   │   ├── shellcode_options.png
│   │   ├── stack_finder.png
│   │   ├── summary.png
│   │   ├── system_chain.png
│   │   ├── system_gadget.png
│   │   ├── thumb_dis.png
│   │   └── thumb_gadget.png
│   ├── leafblower.md
│   ├── local_cross_ref.md
│   ├── mips_rop.md
│   ├── operator.md
│   ├── rename_variables.md
│   └── rizzo.md
└── utils
    ├── __init__.py
    ├── armrop.py
    ├── functiontable.py
    ├── graphviz
    │   ├── __init__.py
    │   ├── _compat.py
    │   ├── backend.py
    │   ├── dot.py
    │   ├── files.py
    │   ├── lang.py
    │   └── tools.py
    ├── leafblower.py
    ├── mipsrop.py
    ├── mipsropchain.py
    ├── rizzo.py
    └── utils.py

```

`ArmRopDouble.py`:

```py
# Find ARM ROP gadgets that perform two controllable jumps.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Double Jumps


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

arm_rop = armrop.ArmRop(currentProgram)
doubles = arm_rop.find_doubles()

doubles.pretty_print()

```

`ArmRopFind.py`:

```py
# Find ARM ROP gadgets that contain a user specified instruction.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Find


import re
from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

op1 = None
op2 = None
op3 = None

search = askString(
    'ARM ROP Find', 'What instruction do you want to search for?')
try:
    search = re.sub(' +', ' ', search)
    mnem, operands = search.split(' ', 1)
    operands = operands.replace(' ', '')
    operands = operands.split(',')
    op1, op2, op3 = operands + [None] * (3 - len(operands))
except ValueError:
    mnem = search

if not mnem.startswith('.*'):
    mnem = '.*' + mnem

print 'Searching for %s' % search
search_ins = armrop.ArmInstruction(mnem, op1, op2, op3)

arm_rop = armrop.ArmRop(currentProgram)
results = arm_rop.find_instructions([search_ins])

results.pretty_print()

```

`ArmRopMovR0.py`:

```py
# Find ARM ROP gadgets that load a small value into r0. Useful for calling sleep.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Mov r0


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

move_r0 = armrop.ArmInstruction('mov$', 'r0', '#0x[1-9].*')

arm_rop = armrop.ArmRop(currentProgram)
small_value_to_r0 = arm_rop.find_instructions([move_r0])

small_value_to_r0.pretty_print()

```

`ArmRopRegisterControl.py`:

```py
# Find ARM ROP gadgets that give control of registers by popping them off the stack.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Register Control


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

reg = askChoice('Source Register',
                'What register do you want to control?',
                ['Any', 'r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7', 'r8',
                 'r9', 'r10', 'r11', 'r12'],
                'Any')

if reg == 'Any':
    print 'Searching for gadgets that give control of any register.'
    reg = '.*(r[01]?\d).*'
else:
    print 'Searching for gadgets that give control of %s.' % reg

reg = '.*' + reg + ' .*'

reg_control = armrop.ArmInstruction('ldmia', 'sp!', reg)

arm_rop = armrop.ArmRop(currentProgram)
control = arm_rop.find_instructions([reg_control], controllable_calls=False)

control.pretty_print()

```

`ArmRopRegisterMove.py`:

```py
# Find ARM ROP gadgets that move values between registers.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Register Movement


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

src_reg = askChoice('Source Register',
                    'What source register do you want to move?',
                    ['Any', 'r0', 'r1', 'r2', 'r3', 'r4', 'r5',
                        'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12'],
                    'Any')

dest_reg = askChoice('Destination Register',
                     'Where do you want the source to be moved?',
                     ['Any', 'r0', 'r1', 'r2', 'r3', 'r4', 'r5',
                         'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12'],
                     'Any')

print "Searching for gadgets that move %s to %s" % (src_reg, dest_reg)

if src_reg == 'Any':
    src_reg = '^(r[01]?\d)'
else:
    src_reg += '$'

if dest_reg == 'Any':
    dest_reg = '^(r[01]?\d)'
else:
    dest_reg += '$'


cpy_reg = armrop.ArmInstruction('cpy', dest_reg, src_reg)
move_reg = armrop.ArmInstruction('mov', dest_reg, src_reg)

arm_rop = armrop.ArmRop(currentProgram)
stack_finders = arm_rop.find_instructions([cpy_reg, move_reg])

stack_finders.pretty_print()

```

`ArmRopStackFinder.py`:

```py
# Find ARM ROP gadgets that put a stack address in a register. Useful for calling functions with a user controlled string.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Stack Finder


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

sf_saved_reg = armrop.ArmInstruction('add', '^(r[01]?\d)', 'sp')

arm_rop = armrop.ArmRop(currentProgram)
stack_finders = arm_rop.find_instructions([sf_saved_reg])

stack_finders.pretty_print()

```

`ArmRopSummary.py`:

```py
# Print a summary of ROP gadgets that are bookmarked with ropX.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Summary


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

arm_rop = armrop.ArmRop(currentProgram)
arm_rop.summary()

```

`ArmRopSystem.py`:

```py
# Find ARM ROP gadgets for calling system with a user controlled argument.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.System Calls


from utils import armrop, utils

utils.allowed_processors(currentProgram, 'ARM')

set_a0 = armrop.ArmInstruction('add', 'r0', 'sp')

arm_rop = armrop.ArmRop(currentProgram)
system_rops = arm_rop.find_instructions([set_a0], 'a0')

system_rops.pretty_print()

```

`ArmToThumb.py`:

```py
# Convert executable sections to Thumb instructions to find new gadgets.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Arm Rop.Convert To Thumb

from utils import utils

from ghidra.util.task import CancelledListener
from ghidra.app.services import ConsoleService
from ghidra.app.cmd.disassemble import ArmDisassembleCommand


utils.allowed_processors(currentProgram, 'ARM')


def find_code():
    """
    Find executable code sections and return an address set representing the 
    range.
    """
    code_sections = []

    addr_factory = currentProgram.getAddressFactory()
    memory_manager = currentProgram.getMemory()
    addr_view = memory_manager.getExecuteSet()

    for section in addr_view:
        new_view = addr_factory.getAddressSet(section.getMinAddress(),
                                              section.getMaxAddress())
        code_sections.append(new_view)

    return code_sections


class CancelListener(CancelledListener):
    def __init__(self, transaction):
        super(CancelledListener, self).__init__()
        self.transaction = transaction

    def cancelled(self):
        if self.transaction:
            print('User cancelled, cleaning up Thumb disassembly.')
            currentProgram.endTransaction(self.transaction, False)
            self.transaction = None


code_manager = currentProgram.getCodeManager()
addr_factory = currentProgram.getAddressFactory()
code_sections = find_code()

try:
    transaction = currentProgram.startTransaction('thumb')
    commit_changes = True

    # Create a cancel listener so we can cleanup if the user cancels the
    # operation
    cancel = CancelListener(transaction)
    monitor = getMonitor()
    monitor.addCancelledListener(cancel)

    for section in code_sections:
        print 'Converting operations to Thumb in section %s' % section
        clearListing(section)
        undefined = code_manager.getFirstUndefinedData(section, monitor)
        while undefined and undefined.getAddress() < section.getMaxAddress():
            curr_address = undefined.getAddress()

            # Create an address set on a single instruction. If more than one
            # instruction is performed at a time it will follow jumps and
            # disassemble code elsewhere, likely as ARM instructions.
            single_ins = addr_factory.getAddressSet(curr_address, curr_address)
            disassm = ArmDisassembleCommand(single_ins, single_ins, True)
            disassm.enableCodeAnalysis(False)
            disassm.applyTo(currentProgram)
            undefined = code_manager.getFirstUndefinedDataAfter(
                curr_address, monitor)
except Exception as e:
    print str(e)
    commit_changes = False
finally:
    currentProgram.endTransaction(transaction, commit_changes)
    monitor.removeCancelledListener(cancel)

```

`CallChain.py`:

```py
# Display call chain graph between two functions and output to the console.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Call Chain

import os
import sys
import tempfile
from utils import graphviz

from ghidra.util.graph import DirectedGraph, Vertex, Edge
from ghidra.graph.viewer import GraphComponent
from ghidra.app.services import GraphService

found_call_chain = False


def get_references(caller, callee):
    """
    Find reference addresses between a caller function and callee function.

    :param caller: Caller function.
    :param callee: Callee function.

    :return: List of addresses where the caller calls the callee.
    :rtype: list
    """
    function_manager = currentProgram.getFunctionManager()

    ref_list = []
    callee_symbol = callee.getSymbol()
    callee_references = callee_symbol.getReferences()

    for ref in callee_references:
        addr = ref.getFromAddress()
        func = function_manager.getFunctionContaining(addr)
        if func == caller:
            ref_list.append(addr)

    return ref_list


def sanitize_dot(func):
    """
    Return a sanitized function name string compatible with DOT representation.

    :param func: Function object
    """
    return str(func).replace("::", "\\")


def print_call_chain(call_chain, dot):
    """
    Print successful call chains to the console and add to the graph.

    :param call_chain: Successful call chain.
    :param dot: Call graph.
    """
    previous_function = None
    function_references = {}
    function_chain = []

    for function in call_chain:
        references = []

        function_name = sanitize_dot(function)

        if function == call_chain[0]:
            dot.node(function_name, str(function), style='filled',
                     color='blue', fontcolor='white')
        elif function == call_chain[-1]:
            dot.node(function_name, str(function), style='filled',
                     color='red', fontcolor='white')
        else:
            dot.node(function_name, str(function))
        if previous_function:
            previous_function_name = sanitize_dot(previous_function)
            dot.edge(previous_function_name, function_name)
            function_references[str(previous_function)] = get_references(
                previous_function, function)

        previous_function = function
        function_chain.append(str(function))

    for function in function_chain:
        print function,
        if function in function_references:
            print function_references[function],
            print ' -> ',
    print ''


def call_chain_recurse(call_chain, complete_call, dot):
    """
    Recurse from call_chain to complete_call, if found.

    :param call_chain: Current call chain.
    :param complete_call: Call that indicates a successfully completed chain.
    :param dot: Call graph
    """
    global found_call_chain

    function_list = call_chain[0].getCallingFunctions(monitor)
    for func in function_list:
        if func == complete_call:
            print_call_chain([func] + call_chain, dot)
            found_call_chain = True
            continue

        if func in call_chain:
            continue
        call_chain_recurse([func] + call_chain, complete_call, dot)


def discover_call_chain(from_function, to_function):
    """
    Discover call chains between two functions.

    :param from_function: Function start looking for path to next function.
    :param to_function: Function that, when/if found, indicates a chain.
    """
    dot = graphviz.Digraph('Function Paths', format='png', strict=True)
    call_chain_recurse([to_function], from_function, dot)

    if found_call_chain:
        tmp_file = tempfile.mktemp()
        dot.render(tmp_file, view=True)


func_man = currentProgram.getFunctionManager()
function_list = [function for function in func_man.getFunctions(True)]
function_list.sort(key=lambda func: str(func))

from_function = askChoice('Select function',
                          'Select the starting function',
                          function_list,
                          function_list[0])

function_list.remove(from_function)
to_function = askChoice('Select function',
                        'Select the ending function',
                        function_list,
                        function_list[0])

print 'Finding x-refs from %s to %s\n' % (from_function, to_function)

discover_call_chain(from_function, to_function)

```

`CodatifyFixupCode.py`:

```py
# Fixup .text section by defining all undefined code and converting it to a function if applicable.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Codatify.Fixup Code

import time
import string

from ghidra.program.flatapi import FlatProgramAPI
from ghidra.program.model.symbol import FlowType

# Adjust to your own preference.
FUNCTION_PREFIX = 'CFUN_%s'


def find_code():
    """
    Find executable code sections and return an address set representing the 
    range.
    """
    code_sections = []

    addr_factory = currentProgram.getAddressFactory()
    memory_manager = currentProgram.getMemory()
    addr_view = memory_manager.getExecuteSet()

    for section in addr_view:
        new_view = addr_factory.getAddressSet(section.getMinAddress(),
                                              section.getMaxAddress())
        code_sections.append(new_view)

    return code_sections

def is_aligned_instruction_address(inst_address):
    """
    Checks if the address is aligned according to the instruction alignment
    defined by the currentProgram's language
    
    :param inst_address: Address of a potential instruction
    :type inst_address: ghidra.program.model.listing.Address

    :returns: True if inst_address is properly aligned, False otherwise. 
    """
    alignment = currentProgram.getLanguage().getInstructionAlignment()
    return inst_address.offset % alignment == 0


def is_valid_function_end(last_instruction):
    """
    Rudimentary valid function checker. Simply checks the last instruction for a 
    terminating instruction, taking into account delay slots.

    :param last_instruction: Last instruction in a function.
    :type last_instruction: ghidra.program.model.listing.Instruction

    :returns: True if valid function, False otherwise. 
    """
    if last_instruction is None:
        return False

    if last_instruction.isInDelaySlot():
        last_instruction = getInstructionAt(last_instruction.getFallFrom())

    if last_instruction.getFlowType() == FlowType.TERMINATOR:
        return True
    return False


def find_function_end(function, max_address, instruction_length):
    """
    Find the last instruction in a newly created function up to a maximum 
    address to prevent overrun into previously defined code.

    :param function: Newly created function to find end address.
    :type function: ghidra.program.model.listing.Function

    :param max_address: Max address to return.
    :type max_address: ghidra.program.model.listing.Address

    :param instruction_length: Instruction length to account for the functions
                               max address functionality returning a value that 
                               representing the last byte of the last instruction.
    :type instruction_length: int

    :returns: Last instruction in the function.
    :rtype: ghidra.program.model.listing.Instruction
    """
    if not function:
        raise Exception('Invalid function provided.')
    if not max_address:
        raise('Invalid max address provided.')

    # Fix-up function max address to be aligned on the instruction length
    # boundary. MIPS at least returns the last byte of the last instruction
    # which is not on the required 4 byte boundary.
    function_max = function.getBody().getMaxAddress()
    function_max = function_max.subtract(
        function_max.getOffset() % instruction_length)

    comparison = function_max.compareTo(max_address.getAddress())
    if comparison == 1:
        return max_address
    return getInstructionAt(function_max)


def clear_listing(addr_list, symbols=False, function=False, register=False):
    """
    Remove symbols, function, or registers from the list of addresses. 
    Attempting to remove multiple entries concurrently may lead to an 
    exception.

    :param addr_list: List of addresses to clear listings from.
    :type addr_list: list(ghidra.program.model.listing.Address)

    :param symbols: Remove symbol listing.
    :type symbols: bool

    :param function: Remove function listing.
    :type function: bool

    :param register: Remove register listing.
    :type register: bool
    """
    addr_factory = getAddressFactory()
    if not addr_factory:
        raise Exception("Failed to get address factory.")

    for addr in addr_list:
        addr_set = addr_factory.getAddressSet(addr, addr)
        clearListing(addr_set, False, symbols, False, False, function, register,
                     False, False, False, False, False, False)


def is_string(addr):
    """
    Check if address contains a 3 byte minimum string.
    """
    curr_bytes = getBytes(addr, 4)
    try:
        result = map(chr, curr_bytes.tolist())
        if '\x00' in result[:3]:
            return False
        for character in result:
            if character == '\x00':
                continue
            if character not in string.printable:
                return False
        return True
    except ValueError:
        return False


def define_code_and_functions(start_addr, end_addr):
    """
    Convert undefined code in the section provided to defined code and a 
    function if applicable.

    :param section: Section to search for undefined code.
    :type section: ghidra.program.model.listing.ProgramFragment
    """
    function_count = 0
    code_block_count = 0
    invalid_functions = []

    undefined_code = getUndefinedDataAt(start_addr)
    if undefined_code is None:
        undefined_code = getUndefinedDataAfter(start_addr)

    # Loop through all undefined code in the provided section.
    while undefined_code is not None and undefined_code.getAddress() < end_addr:
        undefined_addr = undefined_code.getAddress()
        next_valid_ins = getInstructionAfter(undefined_addr)

        try:
            if is_string(undefined_addr):
                # Sometimes strings hang out in the executable code section.
                # This can introduce false positives though.
                createAsciiString(undefined_addr)
                continue

            if not is_aligned_instruction_address(undefined_addr):
                continue
            disassemble(undefined_addr)

            instruction_length = getInstructionAt(undefined_addr).getLength()
            last_invalid_ins = getInstructionBefore(
                next_valid_ins.getAddress())

            # Create a function around the code and check for validity.
            new_func = createFunction(
                undefined_addr, FUNCTION_PREFIX % undefined_addr)

            if new_func is None:
                continue

            last_instruction = find_function_end(
                new_func, last_invalid_ins, instruction_length)

            if is_valid_function_end(last_instruction):
                function_count += 1
            else:
                invalid_functions.append(undefined_addr)
                code_block_count += 1
        except:
            continue
        finally:
            undefined_code = getUndefinedDataAfter(undefined_addr)

    # If the functions are removed immediately it will cause some race condition
    # exceptions to be raised with Call Fix-up routine. If all listings are
    # removed in one go it raises an exception, sometimes.
    clear_listing(invalid_functions, symbols=True)
    time.sleep(1)
    clear_listing(invalid_functions, function=True)
    time.sleep(1)
    clear_listing(invalid_functions, register=True)

    print 'Converted {} undefined code block and created {} new functions in range {} -> {}.'.format(
        code_block_count, function_count, start_addr, end_addr)


# define_code_and_functions()
for executable_section in find_code():
    define_code_and_functions(executable_section.getMinAddress(),
                              executable_section.getMaxAddress())

```

`CodatifyFixupData.py`:

```py
# Fixup .data and .rodata sections by defining strings and forcing remaining undefined data to be a DWORD.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Codatify.Fixup Data


from utils import functiontable

from ghidra.program.model.data import PointerDataType


def find_data_sections():
    """
    Search for non-executable sections in the memory map.
    """
    data_sections = []

    # Find all memory sections and remove the executable sections.
    addr_factory = currentProgram.getAddressFactory()
    memory_manager = currentProgram.getMemory()
    address_ranges = memory_manager.getLoadedAndInitializedAddressSet()
    executable_set = memory_manager.getExecuteSet()

    addr_view = address_ranges.xor(executable_set)

    for section in addr_view:
        new_view = addr_factory.getAddressSet(section.getMinAddress(),
                                              section.getMaxAddress())
        data_sections.append(new_view)

    return data_sections


def define_strings(section):
    """
    Convert undefined strings in the section provided to ascii.

    :param section: Section to search for undefined strings.
    :type section: ghidra.program.model.listing.ProgramFragment
    """
    if section is None:
        return

    strings = findStrings(section, 1, 1, True, True)

    string_count = 0
    for string in strings:
        if getUndefinedDataAt(string.getAddress()):
            try:
                createAsciiString(string.getAddress())
                string_count += 1
            except:
                continue

    print 'Strings - {}'.format(string_count)


def get_pointer_type():
    """
    Get the correct pointer size for the current architecture.
    """
    return PointerDataType(None, currentProgram.getDefaultPointerSize())


def define_pointers(section):
    """
    Convert undefined data to valid pointers. 

    :param section: The section to convert pointers in.
    :type section: ghidra.program.model.listing.ProgramFragment
    """
    if section is None:
        return

    start_addr = section.getMinAddress()
    end_addr = section.getMaxAddress()

    undefined_data = getUndefinedDataAt(start_addr)
    if undefined_data is None:
        undefined_data = getUndefinedDataAfter(start_addr)

    pointer_count = 0
    pointer_type = get_pointer_type()
    memory_manager = currentProgram.getMemory()

    while undefined_data is not None and undefined_data.getAddress() < end_addr:
        undefined_addr = undefined_data.getAddress()
        try:
            # At each undefined byte, convert it to a pointer and see if it
            # has any valid references. If it does validate the reference goes
            # to a valid memory address using the memory manager.
            createData(undefined_addr, pointer_type)
            references = getReferencesFrom(undefined_addr)
            if len(references):
                if memory_manager.contains(references[0].getToAddress()):
                    pointer_count += 1
                else:
                    removeDataAt(undefined_addr)
            else:
                removeDataAt(undefined_addr)
        except:
            pass
        finally:
            undefined_data = getUndefinedDataAfter(undefined_addr)

    print 'Pointers - {}'.format(pointer_count)


def define_data(section):
    """
    Convert undefined data to a DWORD.

    :param section: Section to search for undefined data in.
    :type section: hidra.program.model.listing.ProgramFragment
    """
    if section is None:
        return

    start_addr = section.getMinAddress()
    end_addr = section.getMaxAddress()

    undefined_data = getUndefinedDataAt(start_addr)
    if undefined_data is None:
        undefined_data = getUndefinedDataAfter(start_addr)

    data_count = 0
    while undefined_data is not None and undefined_data.getAddress() < end_addr:
        undefined_addr = undefined_data.getAddress()
        undefined_data = getUndefinedDataAfter(undefined_addr)
        try:
            createDWord(undefined_addr)
            data_count += 1
        except:
            continue

    print 'DWORDS - {}'.format(data_count)


def fixup_section(section):
    """
    Fixup the section by defining strings and converting undefined data to 
    DWORDs.

    :param section: Section to fixup.
    :type section: str
    """
    print 'Section {} - {}'.format(section.getMinAddress(),
                                   section.getMaxAddress())
    print '-' * 30

    define_pointers(section)
    define_strings(section)
    define_data(section)

    ft_finder = functiontable.Finder(currentProgram, section)
    ft_finder.find_function_table()
    ft_finder.rename_functions()

    print '\n'


# Base address of 0 can really mess things up when fixing up pointers.
# Make sure the user really wants this.
base_addr = currentProgram.getMinAddress()
if base_addr.toString() == u'00000000' and \
    not askYesNo('Base Address Zero', 'The base address is set to 0 which can '
                 'introduce a large amount of false positives when fixing up '
                 'the data section. \nDo you want to continue?'):
    exit(0)

data_sections = find_data_sections()

print 'Fixing up data...\n'
for section in data_sections:
    fixup_section(section)

```

`Fluorescence.py`:

```py
#Highlight or un-highlight function calls.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Un/Highlight Function Calls


from java.awt import Color
from ghidra.program.model.symbol import RefType

answer = askChoice('Highlight?',
                   'Highlight or un-highlight function calls?',
                   ['highlight', 'un-highlight'],
                   'highlight')

# Dull yellow color.
highlight_color = Color(250, 250, 125)

code_manager = currentProgram.getCodeManager()
image_base = currentProgram.getImageBase()

instructions = code_manager.getInstructions(image_base, True)

for ins in instructions:
    if ins.getFlowType().isCall():
        if answer == 'highlight':
            setBackgroundColor(ins.getAddress(), highlight_color)
        else:
            clearBackgroundColor(ins.getAddress())

```

`FunctionProfiler.py`:

```py
# Find all cross references in the current function.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Function Profiler

from utils import utils
from ghidra.program.model.symbol import RefType,SymbolType


class CrossRef(object):
    def __init__(self, reference):
        to_addr = reference.getToAddress()
        symbol = getSymbolAt(to_addr)

        self.from_addr = reference.getFromAddress()
        self.symbol_type = str(symbol.getSymbolType())

        symbol_object = symbol.getObject()
        try:
            if symbol_object.hasStringValue():
                symbol_name = str(symbol.getObject())
                if symbol_name.startswith('ds '):
                    self.symbol_name = symbol_name[3:]
                self.symbol_type = 'String'
            else:
                self.symbol_name = symbol.getName() 
        except AttributeError:
            self.symbol_name = symbol.getName() 
            
    def __str__(self):
        return '{:12} {}'.format(self.from_addr, self.symbol_name)


class FunctionCrossReferences(object):
    def __init__(self, function):
        self.function = function
        self.cross_references = []
        
    def append(self, cross_ref):
        self.cross_references.append(cross_ref)
        
    def _loop_print(self, label):
        print '\n{}\n{}'.format(label, '-' * len(label))
        for cr in self.cross_references:
            if cr.symbol_type == label:
                print cr
        
    def pretty_print(self):
        print '\nCross References in {}\n{}'.format(function, '-' * 30)
        self._loop_print('String')
        self._loop_print('Function')
        self._loop_print('Label')
        print

code_manager = currentProgram.getCodeManager()
function_manager = currentProgram.getFunctionManager()
function = utils.get_function(function_manager, currentLocation.address)

if function is None:
    print 'Current selection is not a function.'
    exit()


cross_references = FunctionCrossReferences(function)

instructions = utils.get_instruction_list(code_manager, function)
for instruction in instructions:
    for reference in instruction.getReferencesFrom():
        ref_type = reference.getReferenceType()
        if reference.isMemoryReference() and \
        ref_type != RefType.CONDITIONAL_JUMP and \
        ref_type != RefType.UNCONDITIONAL_JUMP:
            cross_references.append(CrossRef(reference))
            
cross_references.pretty_print()

```

`LeafBlowerFormatString.py`:

```py
# Identify potential POSIX functions in the current program such as sprintf, fprintf, sscanf, etc.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Leaf Blower.Find format string functions


from utils import leafblower

print 'Searching for format string functions...'
format_string_finder = leafblower.FormatStringFunctionFinder(currentProgram)
format_string_finder.find_functions()
format_string_finder.display()

```

`LeafBlowerLeafFunctions.py`:

```py
# Identify potential POSIX functions in the current program such as strcpy, strcat, memcpy, atoi, strlen, etc.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Leaf Blower.Find leaf functions


from utils import leafblower

print 'Searching for potential POSIX leaf functions...'
leaf_finder = leafblower.LeafFunctionFinder(currentProgram)
leaf_finder.find_leaves()
leaf_finder.display()

```

`LocalXRefs.py`:

```py
#Find local references to selected registers and local variables in the current function.
#@author fuzzywalls
#@category TNS
#@keybinding 
#@menupath TNS.Local X-Refs


import re
from ghidra.program.model.listing import CodeUnit

class InstructionMatch(object):
    def __init__(self, address, direction, ref_type, instruction):
        self.address = address
        self.direction = direction
        self.ref_type = ref_type
        self.instruction = instruction

    def __str__(self):
        return '{:7} {:10} {:12} {}'.format(self.direction, 
                                            self.ref_type, 
                                            self.address, 
                                            self.instruction) 


def get_function(address):
    """
    Return the function that contains the address. 
    
    :param address: Address within function.
    
    :returns: Function that contains the provided address.
    """
    function_manager = currentProgram.getFunctionManager()
    return function_manager.getFunctionContaining(address)


def get_instruction_list(function):
    """
    Get list of instructions in the function.
    
    :param function: Function to parse for instruction list.
    
    :returns: List of instructions.
    """
    code_manager = currentProgram.getCodeManager()
    function_bounds = function.getBody()
    function_instructions = code_manager.getInstructions(function_bounds, True)
    return function_instructions


def get_sub_operation(selection):
    """
    Get sub operation within operation. Usually a register offset. 
    
    :param selection: Current mouse selection.
    
    :returns: Sub operation within current operation.
    """
    sub_index = currentLocation.getSubOperandIndex()
    split_selection = re.findall(r"[\w']+", selection)
    index = 0 if sub_index == 0 else 1
    try:
        sub_operation = split_selection[index]
    except IndexError:
        sub_operation = split_selection[0]
        
    return sub_operation


def process_function_call(operation, offset):
    """
    Process function calls to determine if the register or function is selected.
    
    :param operation: Full operation to process.
    :param offset: Offset of mouse in the operation.
    
    :returns: Selected item in the operation.
    """
    equal_index = operation.index('=>')
    items = operation.split('=>')
    if offset < equal_index:
        return items[0]
    return items[1]


def get_selection(current_function, force_address=False):
    """
    Get the current selection.

    :param function: Function that contains the selection.
    :param force_address: Force the use of the raw address, used to process 
                          labels.

    :returns: String representing the current selection.
    """
    # If the selection is a label this will not throw an exception.
    try:
        selection = currentLocation.getName()
        print '\nXrefs to {} in {}:'.format(selection, current_function)
    except AttributeError:
        try:
            is_variable = currentLocation.getVariableOffset()
            if is_variable is not None:
                variable = currentLocation.getRefAddress()
                stack = current_function.getStackFrame()
                stack_size = stack.getFrameSize()
                stack_variable = stack_size + variable.getOffset()
                selection = hex(stack_variable)[:-1]
                print '\nXrefs to {}({}) in {}:'.format(selection, 
                                                          is_variable,
                                                          current_function)
            elif force_address:
                address = currentLocation.getRefAddress().getOffset()
                selection = str.format('0x{:08x}', address)
                print '\nXrefs to {} in {}:'.format(selection, current_function)
            else:
                selection = currentLocation.getOperandRepresentation()
                if '=>' in selection:
                    selection = process_function_call(
                        selection, currentLocation.getCharOffset())
                selection = get_sub_operation(selection) 
                print '\nXrefs to {} in {}:'.format(selection, current_function)

        except AttributeError:
            print 'No value selected.'
            exit() 

    print '-' * 60
    return selection


def check_flows(instruction, target):
    """
    Search instruction flows to see if they match the target.
    
    :param instruction: Current instruction.
    :param target: Target instruction.
    
    :returns: True if a flow matches the target, False otherwise.
    """
    flows = instruction.getFlows()
    for flow in flows:
        if flow.toString() in target:
            return True
    return False

def create_match(instruction, index=0):
    """
    Create instruction match class from instruction and the operand index.
    """
    ins_addr = instruction.getAddress()
    if ins_addr > currentLocation.address:
        direction = 'DOWN'
    elif ins_addr < currentLocation.address:
        direction = 'UP'
    else:
        direction = '-'
    ref_type = instruction.getOperandRefType(index)

    match = InstructionMatch(
        ins_addr, direction, ref_type, instruction)

    return match

def find_instruction_matches(function, target):
    """
    Find instructions that contain the target value.
    
    :param function: Function to search.
    :param target: Target to search for in each operation.
    
    :returns: List of instruction matches.
    """
    instruction_matches = []
    function_instructions = get_instruction_list(function) 
    for instruction in function_instructions:
        # Labels don't show up so check the flow, if its a call see if it
        # contains the target.
        if check_flows(instruction, target):
            match = create_match(instruction)
            instruction_matches.append(match)
            continue

        # Check each operand of the instruction for the target.
        operand_count = instruction.getNumOperands() 
        for index in range(0, operand_count):
            operand = instruction.getDefaultOperandRepresentation(index)
            if target in operand:
                match = create_match(instruction, index)
                instruction_matches.append(match)
                break

    return instruction_matches


function = get_function(currentLocation.address)
selection = get_selection(function)
matches = find_instruction_matches(function, selection)

# If no matches were found search again using the raw address of the selection.
if not matches:
    print 'No matches found for %s, searching again with the raw address.' % \
        selection
    selection = get_selection(function, True)
    matches = find_instruction_matches(function, selection)

if matches:

    for match in matches:
        print match
else:
    print 'No matches found for {} in {}.'.format(selection, function)
```

`MipsRopDouble.py`:

```py
# Find MIPS ROP gadgets that perform two controllable jumps.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Double Jumps


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

mips_rop = mipsrop.MipsRop(currentProgram)
doubles = mips_rop.find_doubles()

doubles.pretty_print()

```

`MipsRopEpilogue.py`:

```py
# Find MIPS ROP gadgets for gaining control of more registers through function epilogues.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Epilogue


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

registers = ['s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8']


min_reg = askChoice('Minimum Register',
                    'What is the lowest register you want to control?',
                    ['Any'] + registers,
                    'Any')
if min_reg == 'Any':
    min_reg = None

if min_reg:
    print 'Searching for function epilogues that grant control of registers up to %s...' % min_reg

epilogue = mipsrop.MipsInstruction('.*lw', 'ra')

mips_rop = mipsrop.MipsRop(currentProgram)
function_epilogue = mips_rop.find_instructions(
    [epilogue], overwrite_register=registers[:registers.index(min_reg) + 1],
    controllable_calls=False)

function_epilogue.pretty_print()

```

`MipsRopFind.py`:

```py
# Find MIPS ROP gadgets that contain a user specified instruction.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Find


import re
from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

op1 = None
op2 = None
op3 = None

search = askString(
    'MIPS ROP Find', 'What instruction do you want to search for?')
try:
    search = re.sub(' +', ' ', search)
    mnem, operands = search.split(' ', 1)
    operands = operands.replace(' ', '')
    operands = operands.split(',')
    op1, op2, op3 = operands + [None] * (3 - len(operands))
except ValueError:
    mnem = search

if not mnem.startswith('.*'):
    mnem = '.*' + mnem

search_ins = mipsrop.MipsInstruction(mnem, op1, op2, op3)

mips_rop = mipsrop.MipsRop(currentProgram)
results = mips_rop.find_instructions([search_ins])

results.pretty_print()

```

`MipsRopIret.py`:

```py
# Find MIPS ROP gadgets that perform an indirect return. (Call t9, return to ra.)
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Indirect Return


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

move_t9 = mipsrop.MipsInstruction('move', 't9', '[sav][012345678]')

mips_rop = mipsrop.MipsRop(currentProgram)
indirect_returns = mips_rop.find_instructions(
    [move_t9], controllable_calls=False, overwrite_register=['ra'])

indirect_returns.pretty_print()

```

`MipsRopLia0.py`:

```py
# Find MIPS ROP gadgets that load a small value into a0. Useful for calling sleep.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Li a0


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

li_a0 = mipsrop.MipsInstruction('.*li', 'a0', '0x.*')

mips_rop = mipsrop.MipsRop(currentProgram)
sleep_calls = mips_rop.find_instructions([li_a0])

sleep_calls.pretty_print()

```

`MipsRopPrologue.py`:

```py
# Find MIPS ROP gadgets near the beginning of functions that allow for stack pointer movement.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Prologue


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

prologue = mipsrop.MipsInstruction('.*addiu', 'sp', 'sp', '-.*')

mips_rop = mipsrop.MipsRop(currentProgram)
function_prologue = mips_rop.find_instructions([prologue])

function_prologue.pretty_print()

```

`MipsRopShellcode.py`:

```py
# Build a ROP chain that can be used to call shellcode.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.ROP Chains.Shellcode

from utils import mipsropchain, mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')


def find_lia0_calls(rop_finder, vebose):
    """
    Find calls the load a value smaller than 16 into $a0.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadget)
    """
    li_a0 = mipsrop.MipsInstruction('.*li', 'a0', '0x[0-9a-f]')
    small_value = rop_finder.find_instructions([li_a0])
    if verbose:
        print 'Found %d gadgets to load a small value into a0' % \
            len(small_value.gadgets)
    return small_value.gadgets


def find_stack_finders(rop_finder, verbose):
    """
    Find gadgets that move a stack pointer to a register.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadget)
    """
    sf_saved_reg = mipsrop.MipsInstruction('.*addiu', '[sva][012345678]', 'sp')
    stack_finder_gadgets = rop_finder.find_instructions(
        [sf_saved_reg], terminating_calls=False)
    if verbose:
        print 'Found %d gadgets to find shellcode on the stack.' % \
            len(stack_finder_gadgets.gadgets)
    return stack_finder_gadgets.gadgets


def find_double_jumps(rop_finder, allow_double=True, allow_iret=True,
                      verbose=False):
    """
    Find gadgets that call a function and maintain control to jump to the next
    gadget.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadget + mipsrop.DoubleGadget)
    """
    gadgets = []
    if allow_double:
        doubles = rop_finder.find_doubles()
        gadgets.extend(doubles.gadgets)
    if allow_iret:
        move_t9 = mipsrop.MipsInstruction('move', 't9', '[sav][012345678]')
        irets = rop_finder.find_instructions(
            [move_t9], controllable_calls=False, overwrite_register=['ra'])
        gadgets.extend(irets.gadgets)
    if verbose:
        print 'Found %d gadgets to call sleep and maintain control' % len(gadgets)
    return gadgets


def custom_shellcode_find(link, controlled_registers, curr_chain):
    """
    Custom find to search for gadgets that call a register based on where
    the previous gadget stored it.
    """
    shell_code_location = curr_chain[-1].get_action_destination()[0]
    for jump in link.jump_register:
        if jump != shell_code_location:
            return False
    return True


def find_shellcode_jump(rop_finder, verbose):
    """
    Find gadgets that call a register.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadget)
    """
    move_t9 = mipsrop.MipsInstruction('mov', 't9')
    call_register = rop_finder.find_instructions(
        [move_t9])
    if verbose:
        print 'Found %d gadgets to call shellcode.' % len(call_register.gadgets)
    return call_register.gadgets


def find_epilogue(rop_finder, controlled_registers):
    """
    Find epilogues that grant control of each register. Will only return 
    epilogues that grant control over more registers than originally used.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :param controlled_registers: Registers controlled.
    :type controlled_registers: list(str)

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadgets)
    """
    epilogue = mipsrop.MipsInstruction('.*lw', 'ra')
    function_epilogue = []

    for i in range(0, len(mipsropchain.REGISTERS)):
        control_registers = mipsropchain.REGISTERS[:i + 1]
        if all(reg in controlled_registers for reg in control_registers):
            continue
        epilogue_gadget = rop_finder.find_instructions(
            [epilogue], controllable_calls=False,
            overwrite_register=control_registers,
            preserve_register=mipsropchain.REGISTERS[i + 1:])
        if epilogue_gadget.gadgets:
            function_epilogue.append(epilogue_gadget.gadgets[0])
    return function_epilogue


mips_rop = mipsrop.MipsRop(currentProgram)

# User request for currently controlled registers.
registers_controlled = askChoices(
    'Registers Controlled', 'Which registers do you control, excluding ra?',
    ['s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8'])

# User request for how many chains they want returned.
chain_count = askInt('Chains', 'How many chains to you want to find?')

# User request for special options.
special_options = askChoices(
    'Options', 'Any special requests?',
    ['iret', 'double', 'control', 'reuse', 'verbose'],
    ['Avoid indirect returns', 'Avoid double jumps',
     'Avoid gadgets that require a control jump.', 'Do not reuse gadgets.',
     'Verbose output.'])
allow_control = 'control' not in special_options
allow_reuse = 'reuse' not in special_options
allow_double = 'double' not in special_options
allow_iret = 'iret' not in special_options
verbose = 'verbose' in special_options

if verbose:
    print 'You control registers: %s' % ', '.join(registers_controlled)
    print 'Searching for required gadgets...'

# Find all required gadgets.
lia0 = find_lia0_calls(mips_rop, verbose)
stack_finders = find_stack_finders(mips_rop, verbose)
doubles = find_double_jumps(mips_rop, allow_double, allow_iret, verbose)
shellcode = find_shellcode_jump(mips_rop, verbose)

# Set up the chain build with the order the gadgets should be called.
chain_builder = mipsropchain.ChainBuilder(mips_rop, registers_controlled,
                                          chain_count, allow_reuse, verbose)
chain_builder.add_gadgets('Load Immediate to a0', lia0, allow_control)
chain_builder.add_gadgets('Call sleep and maintain control', doubles,
                          allow_control)
chain_builder.add_gadgets('Shellcode finder', stack_finders, allow_control)
chain_builder.add_gadgets('Call shellcode', shellcode,
                          False, find_fn=custom_shellcode_find)
chain_builder.generate_chain()

# If no chains were found or not enough add epilogues and keep searching.
if not chain_builder.chains or len(chain_builder.chains) < chain_count:
    if verbose:
        print 'Adding epilogues to control more registers.'
    epilogues = find_epilogue(mips_rop, registers_controlled)
    chain_builder.add_gadgets('Control More Registers', epilogues,
                              check_control=False, index=0)
    chain_builder.generate_chain()

print 'Found %d chains' % len(chain_builder.chains)

chain_builder.display_chains(verbose)

```

`MipsRopStackFinder.py`:

```py
# Find MIPS ROP gadgets that put a stack address in a register.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.Stack Finder


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

sf_saved_reg = mipsrop.MipsInstruction('.*addiu', '[sva][012345678]', 'sp')

mips_rop = mipsrop.MipsRop(currentProgram)
stack_finders = mips_rop.find_instructions([sf_saved_reg])

stack_finders.pretty_print()

```

`MipsRopSummary.py`:

```py
# Print a summary of ROP gadgets that are bookmarked with ropX.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Summary


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

mips_rop = mipsrop.MipsRop(currentProgram)
mips_rop.summary()

```

`MipsRopSystem.py`:

```py
# Find MIPS ROP gadgets for calling system with a user controlled argument.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.Gadgets.System Calls


from utils import mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')

set_a0 = mipsrop.MipsInstruction('.*addiu', 'a0', 'sp')

mips_rop = mipsrop.MipsRop(currentProgram)
system_rops = mips_rop.find_instructions([set_a0], 'a0',
                                         terminating_calls=False)

system_rops.pretty_print()

```

`MipsRopSystemChain.py`:

```py
# Build a ROP chain that can be used to call system with a controllable command.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Mips Rops.ROP Chains.System

from utils import mipsropchain, mipsrop, utils

utils.allowed_processors(currentProgram, 'MIPS')


def find_system_calls(rop_finder, terminating, controllable, verbose):
    """
    Find single gadget chains to call system with a controllable string in
    a0.

    :param rop_finder: MIPS rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :param terminating: Return tail gadgets.
    :type terminating: bool

    :param controllable: Return controllable calls.
    :type controllable: bool

    :param verbose: Enable verbose output.
    :type verbose: bool

    :returns: Discovered gadgets
    :rtype: list(mipsrop.RopGadgets)
    """
    system_call = mipsrop.MipsInstruction('.*addiu', 'a0', 'sp')
    stack_finders = rop_finder.find_instructions(
        [system_call], terminating_calls=terminating,
        controllable_calls=controllable)
    if verbose:
        print 'Found %d gadgets to call system.' % \
            len(stack_finders.gadgets)
    return stack_finders.gadgets


def find_stack_finders(rop_finder, terminating, controllable, verbose):
    """
    Find gadgets that move a stack pointer to a register. Movement to a0 is
    specifically ignored because the system gadget finder does that.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :param terminating: Return tail gadgets.
    :type terminating: bool

    :param controllable: Return controllable calls.
    :type controllable: bool

    :param verbose: Enable verbose output.
    :type verbose: bool

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadget)
    """
    sf_saved_reg = mipsrop.MipsInstruction(
        '.*addiu', '[sva][012345678]', 'sp')
    stack_finders = rop_finder.find_instructions(
        [sf_saved_reg], terminating_calls=terminating,
        controllable_calls=controllable)
    if verbose:
        print 'Found %d gadgets to find shellcode on the stack.' % \
            len(stack_finders.gadgets)
    return stack_finders.gadgets


def find_move_a0(rop_finder, verbose):
    """
    Find gadget that moves a register to a0.

    :param rop_finder: MIPS rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :param verbose: Enable verbose output.
    :type verbose: bool

    :returns: Discovered gadgets
    :rtype: list(mipsrop.RopGadgets)
    """
    move_a0_ins = mipsrop.MipsInstruction('.*move', 'a0', '[sva][012345678]')
    # System cannot be called from an epilogue. $gp is calculated based on the
    # call occurring from $t9.
    move_a0 = rop_finder.find_instructions([move_a0_ins],
                                           terminating_calls=False)
    if verbose:
        print 'Found %d gadgets to move a register to $a0.' % \
            len(move_a0.gadgets)
    return move_a0.gadgets


def find_epilogue(rop_finder, controlled_registers):
    """
    Find epilogues that grant control of each register. Ideal will return nine
    gadgets one that gives control of s0, one that gives control of s0 and s1,
    one that gives control of s0/s1/s2, etc.

    :param rop_finder: Mips rop finder class.
    :type rop_finder: mipsrop.MipsRop

    :returns: Gadgets found.
    :rtype: list(mipsrop.RopGadgets)
    """
    epilogue = mipsrop.MipsInstruction('.*lw', 'ra')
    function_epilogue = []

    for i in range(0, len(mipsropchain.REGISTERS)):
        control_registers = mipsropchain.REGISTERS[:i + 1]
        if all(reg in controlled_registers for reg in control_registers):
            continue
        epilogue_gadget = rop_finder.find_instructions(
            [epilogue], controllable_calls=False,
            overwrite_register=control_registers,
            preserve_register=mipsropchain.REGISTERS[i + 1:])
        if epilogue_gadget.gadgets:
            function_epilogue.append(epilogue_gadget.gadgets[0])
    return function_epilogue


def system_single_simple_jump(chain_builder, mips_rop):
    """
    Find traditional system gadgets that move a stack string to a0 then call
    a controllable register. Applied gadgets will be cleared from the chain
    builder when the function is complete.

    :param chain_builder: Initialized chain builder class.
    :type chain_builder: mipsropchain.ChainBuilder

    :param mips_rop: Mips rop finder class.
    :type mips_rop: mipsrop.MipsRop
    """
    system_calls = find_system_calls(mips_rop, False, True, verbose)
    chain_builder.add_gadgets('Call system.', system_calls)

    chain_builder.generate_chain()
    chain_builder.gadgets = []


def single_system_custom_find(link, controlled_registers, current_chain):
    """
    Custom find command that searches for a single gadget that moves a stack
    pointer to a register and moves that resister to a0.

    :param link: Current link to process.
    :type link: mipsropchain.ChainLink
    """
    if not mipsropchain.default_gadget_search(
            link, controlled_registers, current_chain):
        return False

    if 'a0' in link.overwritten:
        a0_ins = getInstructionAt(link.overwritten['a0'][0])
        a0_src = str(a0_ins.getOpObjects(1)[0])
        action_dest = link.get_action_destination()[0]
        if a0_src == action_dest and \
                link.overwritten['a0'] > link.overwritten[action_dest]:
            return True
    return False


def system_single_extended_jump(chain_builder, mips_rop):
    """
    Find extended single gadgets that move a stack string to a registers and 
    then move that register to a0. A custom find function is used to support
    this search.

    :param chain_builder: Initialized chain builder class.
    :type chain_builder: mipsropchain.ChainBuilder

    :param mips_rop: Mips rop finder class.
    :type mips_rop: mipsrop.MipsRop
    """
    stack_finders = find_stack_finders(mips_rop, False, True, verbose)
    chain_builder.add_gadgets('Find command on the stack', stack_finders,
                              find_fn=single_system_custom_find)
    chain_builder.generate_chain()
    chain_builder.gadgets = []


def system_tail_two_jump(chain_builder, mips_rop):
    """
    Search for chain that moves a stack string to a0 in a tail call.

    :param chain_builder: Initialized chain builder class.
    :type chain_builder: mipsropchain.ChainBuilder

    :param mips_rop: Mips rop finder class.
    :type mips_rop: mipsrop.MipsRop
    """
    stack_finders = find_system_calls(mips_rop, True, False, verbose)
    chain_builder.add_gadgets(
        'Find command on the stack from tail call', stack_finders)

    move_t9 = mipsrop.MipsInstruction('mov', 't9')
    call_register = mips_rop.find_instructions(
        [move_t9], preserve_register='a0', terminating_calls=False)
    chain_builder.add_gadgets('Call system.', call_register.gadgets)
    chain_builder.generate_chain()
    chain_builder.gadgets = []


def system_two_jump_custom_find(link, controlled_registers, current_chain):
    """
    Custom find to search for gadget that moves a register from a previous 
    jump to a0.
    """
    if not mipsropchain.default_gadget_search(
            link, controlled_registers, current_chain):
        return False

    actions = link.get_action_source()
    last_link_actions = current_chain[-1].get_action_destination()
    for action in last_link_actions:
        if action not in actions:
            return False
    return True


def system_two_jump(chain_builder, mips_rop):
    """
    Find chains that move a stack string to a register and move that register
    to a0 in the next gadget.

    :param chain_builder: Initialized chain builder class.
    :type chain_builder: mipsropchain.ChainBuilder

    :param mips_rop: Mips rop finder class.
    :type mips_rop: mipsrop.MipsRop
    """
    stack_finders = find_stack_finders(mips_rop, False, True, verbose)
    chain_builder.add_gadgets('Find command on the stack', stack_finders)

    move_a0 = find_move_a0(mips_rop, verbose)
    chain_builder.add_gadgets(
        'Move command to $a0', move_a0, find_fn=system_two_jump_custom_find)
    chain_builder.generate_chain()
    chain_builder.gadgets = []


mips_rop = mipsrop.MipsRop(currentProgram)

# User request for currently controlled registers.
registers_controlled = askChoices(
    'Registers Controlled', 'Which registers do you control, excluding ra?',
    ['s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8'])

# User request for how many chains they want returned.
chain_count = askInt('Chains', 'How many chains to you want to find?')

# User request for special options.
special_options = askChoices(
    'Options', 'Any special requests?',
    ['control', 'reuse', 'verbose'],
    ['Avoid gadgets that require a control jump.', 'Do not reuse gadgets.',
     'Verbose output.'])
allow_control = 'control' not in special_options
allow_reuse = 'reuse' not in special_options
verbose = 'verbose' in special_options

if verbose:
    print 'You control registers: %s' % ', '.join(registers_controlled)
    print 'Searching for required gadgets...'

chain_builder = mipsropchain.ChainBuilder(mips_rop, registers_controlled,
                                          chain_count, allow_reuse, verbose)

system_single_simple_jump(chain_builder, mips_rop)
system_single_extended_jump(chain_builder, mips_rop)
system_two_jump(chain_builder, mips_rop)
system_tail_two_jump(chain_builder, mips_rop)

# If no chains were found or not enough add epilogues and keep searching.
if not chain_builder.chains or len(chain_builder.chains) < chain_count:
    if verbose:
        print 'Adding epilogues to control more registers.'
#
    epilogues = find_epilogue(mips_rop, registers_controlled)
    for system_find in [system_single_simple_jump, system_single_extended_jump,
                        system_two_jump, system_tail_two_jump]:
        chain_builder.add_gadgets('Control More Registers', epilogues,
                                  check_control=False)

        system_find(chain_builder, mips_rop)

print 'Found %d chains' % len(chain_builder.chains)

chain_builder.display_chains(verbose)

```

`Operator.py`:

```py
# Find calls to a function and display source of parameters.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Operator

from utils import utils

from ghidra.program.model.symbol import RefType
from ghidra.program.flatapi import FlatProgramAPI
from ghidra.program.model.block import BasicBlockModel
from ghidra.app.decompiler.flatapi import FlatDecompilerAPI


def get_argument_registers():
    """
    Get argument registers based on programs processor.
    """
    arch = utils.get_processor(currentProgram)

    if arch == 'MIPS':
        return ['a0', 'a1', 'a2', 'a3']
    elif arch == 'ARM':
        return ['r0', 'r1', 'r2', 'r3']
    return []


def get_return_registers():
    """
    Get return registers for the current processor.

    :returns: List of return registers.
    :rtype: list(str)
    """
    arch = utils.get_processor(currentProgram)

    if arch == 'MIPS':
        return ['v0', 'v1']
    elif arch == 'ARM':
        return ['r0']
    return []


def get_destination(instruction):
    """
    Find destination register for the current instruction.

    :param instruction: Instruction to find destination register for.
    :type instruction: ghidra.program.model.listing.Instruction

    :returns: List of destination registers if found, empty list if not found.
    :rtype: list(str)
    """
    if not instruction:
        return None

    result = instruction.getResultObjects()
    if not result:
        return []
    return [res.toString() for res in result]


def find_call(address):
    """
    Find the first call above the address provided taking into account if
    the address is a delay slot operation.

    :param address: Address to look above.
    :type address: ghidra.program.model.listing.Address

    :returns: Function name with () after it to resemble a function call or None
              if not found.
    :rtype: str
    """
    containing_function = getFunctionContaining(address)
    if not containing_function:
        return argument

    entry_point = containing_function.getEntryPoint()

    curr_addr = address
    curr_ins = getInstructionAt(curr_addr)

    # If the instruction is in the delay slot of a call skip above it.
    # This is not the call you are looking for.
    if curr_ins.isInDelaySlot() and utils.is_call_instruction(curr_ins.previous):
        curr_ins = curr_ins.previous.previous
        curr_addr = curr_ins.getAddress()

    while curr_addr and curr_addr > entry_point:
        if utils.is_call_instruction(curr_ins):
            ref = curr_ins.getReferencesFrom()
            if len(ref):
                function = getFunctionAt(ref[0].toAddress)
                if function:
                    return '%s()' % function.name

        curr_ins = curr_ins.previous

        if curr_ins:
            curr_addr = curr_ins.getAddress()
        else:
            break
    return None


def get_source(instruction):
    """
    Find source for the current instruction. Limited to strings and single
    registers currently.

    :param instruction: Instruction to find source data for.
    :type instruction: ghidra.program.model.listing.Instruction

    :returns: String representing the source entry or None
    :rtype: str
    """
    if not instruction:
        return None

    references = getReferencesFrom(instruction.getAddress())
    if references:
        for reference in references:
            data = getDataAt(reference.toAddress)
            if data:
                return '"%s"' % str(data.getValue()).encode('string_escape')

    input_objs = instruction.getInputObjects()
    if len(input_objs) == 1:
        input = input_objs[0].toString()
        if input in get_return_registers():
            return find_call(instruction.getAddress())
        return get_argument_source(instruction.getAddress(), input)
    else:
        return instruction.toString()

    return None


def get_argument_source(address, argument):
    """
    Find source of argument register.

    :param address: Address to start search.
    :type address: ghidra.program.model.listing.Address

    :param argument: Argument to search for.
    :type argument: str 

    :returns: Source for argument either as register string or full operation 
              string.
    :rtype: str
    """
    src = None
    containing_function = getFunctionContaining(address)
    if not containing_function:
        return argument

    entry_point = containing_function.getEntryPoint()

    curr_addr = address
    curr_ins = getInstructionAt(curr_addr)
    while curr_addr and curr_addr > entry_point:
        if curr_ins.getDelaySlotDepth() > 0:
            delay_slot = curr_ins.next
            destinations = get_destination(delay_slot)
            if destinations and argument in destinations:
                src = get_source(delay_slot)
                if src is None:
                    src = argument
                return src

        destinations = get_destination(curr_ins)
        if destinations and argument in destinations:
            src = get_source(curr_ins)
            break

        # This can cause false positives because of jumps and branches.
        # Should eventually convert this to use code blocks.
        curr_ins = curr_ins.previous

        if curr_ins:
            curr_addr = curr_ins.getAddress()
        else:
            break

    if src is None:
        src = argument

    return src


class FunctionPrototype(object):
    def __init__(self, function):
        self.function = function
        self.name = function.name
        self.entry_point = function.getEntryPoint()
        self.arg_count = 1
        self.has_var_args = function.hasVarArgs()

        if function.isExternal() or function.isThunk():
            self.arg_count = function.getAutoParameterCount()
        else:
            self.arg_count = self._get_argument_count()

    def _get_argument_count_manual(self):
        """
        Manual argument identification for function based on used argument
        registers in the function prior to setting them.

        :returns: Number of arguments used.
        :rtype: int
        """
        used_args = []
        arch_args = get_argument_registers()

        min_addr = self.function.body.minAddress
        max_addr = self.function.body.maxAddress

        curr_ins = getInstructionAt(min_addr)

        while curr_ins and curr_ins.getAddress() < max_addr:
            for op_index in range(0, curr_ins.getNumOperands()):
                ref_type = curr_ins.getOperandRefType(op_index)
                # We only care about looking at reads and writes. Reads that
                # include and index into a register show as 'data' so look
                # for those as well.
                if ref_type not in [RefType.WRITE, RefType.READ, RefType.DATA]:
                    continue

                # Check to see if the argument is an argument register. Remove
                # that register from the arch_args list so it can be ignored
                # from now on. If reading from the register add it to the
                # used_args list so we know its a used parameter.
                operands = curr_ins.getOpObjects(op_index)
                for operand in operands:
                    op_string = operand.toString()
                    if op_string in arch_args:
                        arch_args.remove(op_string)
                        if ref_type in [RefType.READ, RefType.DATA]:
                            used_args.append(op_string)
            curr_ins = curr_ins.next

        return len(used_args)

    def _get_argument_count(self):
        """
        Get argument count through decompiler if possible otherwise try to
        determine the argument count manually. Manual approach can miss
        arguments if they are used in the first function call of the function.
        """
        flat_api = FlatProgramAPI(currentProgram)
        decompiler_api = FlatDecompilerAPI(flat_api)

        # Must call decompile first or the decompiler will not be initialized.
        decompiler_api.decompile(self.function)
        decompiler = decompiler_api.getDecompiler()

        if decompiler:
            decompiled_fn = decompiler.decompileFunction(self.function,
                                                         10,
                                                         getMonitor())
            if decompiled_fn:
                high_level_fn = decompiled_fn.getHighFunction()
                if high_level_fn:
                    prototype = high_level_fn.getFunctionPrototype()
                    if prototype:
                        return prototype.getNumParams()

        return self._get_argument_count_manual()


class Call(object):
    def __init__(self, addr, containing_fn, function):
        self.address = addr
        self.containing_function = containing_fn
        self.function_call = function
        self.arguments = []

    def add_argument(self, argument):
        self.arguments.append(argument)

    def to_list(self):
        return [self.address.toString(), self.containing_function.name,
                self.function_call.name] + self.arguments


class Operator(object):
    def __init__(self):
        func_man = currentProgram.getFunctionManager()
        self._ref_man = currentProgram.getReferenceManager()

        self.function = None
        self.function_calls = []
        self._function_list = [func for func in func_man.getFunctions(True)]

    def get_callee(self):
        """
        Request user defined functions and identify when that function is 
        called.
        """
        self._function_list.sort(key=lambda func: func.name)

        function = askChoice('Select function',
                             'Select the starting function',
                             self._function_list,
                             self._function_list[0])

        self.function = FunctionPrototype(function)
        self._get_function_calls()

    def list_calls(self):
        """
        Display all times the identified function is called and the approximate
        registers / strings passed to the function.
        """
        if not len(self.function_calls):
            print 'No function calls to %s found.' % self.function.name
            return

        arg_registers = get_argument_registers()

        title = ['Address', 'Containing Function', 'Function']
        title.extend(arg_registers)

        calls = []
        for call in self.function_calls:
            containing_fn = getFunctionContaining(call)
            if not containing_fn:
                continue
            curr_call = Call(call, containing_fn, operator.function)
            arguments = arg_registers[:operator.function.arg_count]
            sources = []
            for arg in arguments:
                source = get_argument_source(call, arg)
                curr_call.add_argument(source)

            # Check for variable length arguments and format strings. Add
            # arguments if they are found.
            if operator.function.has_var_args:
                format_string_count = source.count('%') - source.count('\%')
                arg_count = operator.function.arg_count

                # Find additional arguments taking into account the number
                # of available argument registers.
                additional_arguments = arg_registers[
                    arg_count:
                    min(len(arg_registers),
                        format_string_count + operator.function.arg_count)]

                for arg in additional_arguments:
                    source = get_argument_source(call, arg)
                    curr_call.add_argument(source)

            curr_call_list = curr_call.to_list()
            calls.append(curr_call_list)

        calls.sort(key=lambda call: call[0])
        utils.table_pretty_print(title, calls)

    def _get_function_calls(self):
        """
        Find all calls to function specified by the user.
        """
        for ref in self._ref_man.getReferencesTo(self.function.entry_point):
            ref_type = ref.getReferenceType()
            if ref_type.isCall() or ref_type.isConditional():
                self.function_calls.append(ref.fromAddress)


utils.allowed_processors(currentProgram, ['MIPS', 'ARM'])

operator = Operator()
operator.get_callee()

print 'Identifying calls to %s...' % operator.function.name

operator.list_calls()

```

`README.md`:

```md
Ghidra scripts to support IOT exploitation. Some of the scripts are a port 
of [devttyS0](https://github.com/devttys0/ida) IDA plugins and others are 
new scripts that I found a need for. To install, clone and add the script 
directory via Ghidra's Script Manager. If you check the 'In Tool' checkbox they 
will appear under a 'TNS' tag. 

## Scripts
Below is a simple overview of the available scripts. If the scripts are broken up into multiple parts then bullets are given with high level overviews. Click on the link for each to see a more in-depth explanation with screenshots. 

# [ARM ROP Finder](readmes/armrop.md) 
Script to find and support finding ARM ROP gadgets. 

- Gadgets
    - Find double jumps.
    - Move small value to r0.
    - Get control of more or different registers.
    - Move values between registers.
    - Find strings or shellcode on the stack.
    - Find custom gadgets based on regular expressions.
    - Gadgets to call system with a string argument in r0.

- Support
    - Convert entire program to Thumb instructions. 
    - List summary of saved gadgets.

# [Call Chain](readmes/callchain.md)
Find call chains between two user specified functions. Results are displayed in a png.

# [Codatify](readmes/codatify.md) 
- Fixup code - defines all undefined data in the .text section as code and creates a function if it can.
- Fixup data - define uninitialized strings and pointers. Searches for function tables and renames functions based on their discovery. 

# [Fluorescence](readmes/fluorescence.md)
Highlight function calls.

# [Function Profiler](readmes/func_profiler.md)
Display cross refs from the current function.

# [Leaf Blower](readmes/leafblower.md)
- Format Strings - Find functions that accept format strings as parameters.
- Leaf Functions - Identify potential leaf functions such as strcpy, strlen, etc.

# [Local Cross References](readmes/local_cross_ref.md)
Find references to items in the current function.

# [MIPS ROP Finder](readmes/mips_rop.md)
Scripts to find and support finding MIPS ROP gadgets.

- Gadgets
    - Double Jumps
    - Epilogue
    - Find custom gadgets
    - Indirect Return
    - li a0
    - Prologue
    - System Gadgets

- Chain Builder
    - Build ROP chain to call shellcode
    - Build ROP chain to call system with controllable string. 

- Support
    - Summary

# [Operator](readmes/operator.md)
Display all calls to a function and identify the source of the parameters it is called with taking variadic arguments into account if they are present.

# [Rename Variables](readmes/rename_variables.md)
Rename saved stack variables. (MIPS only)

# [Rizzo](readmes/rizzo.md)
Create fuzzy function signatures that can be applied to other projects.


```

`RenameVariables.py`:

```py
# Rename saved stack variables in MIPS programs.
#@author fuzzywalls
#@category TNS
#@keybinding
#@menupath TNS.Rename Variables

from utils import utils
from ghidra.program.model.symbol import SourceType


utils.allowed_processors(currentProgram, 'MIPS')

func_man = currentProgram.getFunctionManager()
code_man = currentProgram.getCodeManager()

func_list = func_man.getFunctions(True)


for func in func_list:
    # Order of this list is important.
    savable_registers = ['gp', 's0', 's1', 's2',
                         's3', 's4', 's5', 's6', 's7', 's8', 'ra']

    variables = func.getAllVariables()
    for var in variables:
        if len(savable_registers) == 0:
            break

        symbol = var.getSymbol()
        if not symbol:
            continue

        references = symbol.getReferences()

        for ref in references:
            ins = code_man.getInstructionAt(ref.getFromAddress())

            if 'sw ' in str(ins) or 'sd ' in str(ins):
                saved_register = ins.getRegister(0)
                if saved_register:
                    saved_register = saved_register.toString()
                    if saved_register in savable_registers:
                        var.setName('saved_%s' % saved_register,
                                    SourceType.USER_DEFINED)

                        # Remove the saved register to avoid renaming registers
                        # saved later.
                        savable_registers.remove(saved_register)

```

`RizzoApply.py`:

```py
# Apply "fuzzy" function signatures from a different Ghidra project.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Rizzo.Apply Signatures


from utils import rizzo

file_path = askFile('Load signature file', 'OK').path

print 'Applying Rizzo signatures, this may take a few minutes...'

rizz = rizzo.Rizzo(currentProgram)
signatures = rizz.load(file_path)
rizz.apply(signatures)

```

`RizzoSave.py`:

```py
# Create "fuzzy" function signatures that can be shared an applied amongst different Ghidra projects.
#@author fuzzywalls
#@category TNS
#@menupath TNS.Rizzo.Save Signatures


from utils import rizzo

file_path = askFile('Save signature file as', 'OK').path
if not file_path.endswith('.riz'):
    file_path += '.riz'

print 'Building Rizzo signatures, this may take a few minutes...'

rizz = rizzo.Rizzo(currentProgram)
rizz.save(file_path)

```

`readmes/armrop.md`:

```md
# ARM Rop Finder
Find ROP gadgets in ARM disassembly.

## Double Jump
Find back to back controllable gadgets in the form of a register jump near
an epiloge. 

![ARM Rop Double Jumps](./img/arm_rop_double.png)

## ArmToThumb
Convert all executable disassembly to Thumb instructions to search for ROP gadgets.
The output of ROP gadets will account for Thumb instructions and display the jump 
address as `ADDRESS + 1 = WHERE_YOU_SHOULD_JUMP`. The operation can be undone 
when finished looking for gadgets.

### Before
ARM disassembly before running the Arm to Thumb plugin.

![Disassembly Before](./img/arm_dis.png)

### After
Disassembly after the conversion.

![Disassembly After](./img/thumb_dis.png)

### Thumb Gadget
Thumb gadgets are shown with their actual address, but when jumping to it from 
a ROP gadget you must jump to the address + 1 to switch to Thumb mode.

![Disassembly After](./img/thumb_gadget.png)

## Find
Find controllable gadgets that contain custom ARM instructions. Regular 
expressions are supported. To search for a move to r0 from anything, simply 
search for 
"`mov r0,.*`".

![ARM ROP Find](./img/armrop_find.png)

## Move r0
Find ARM ROP gadgets that move a small value into r0. Useful for calling sleep
prior to executing shellcode to flush the buffer to main memory.

![ARM ROP Move r0](./img/arm_rop_mov_r0.png)

## Register Control
Find ARM ROP gadgets that give control of registers by popping them off the stack.

![ARM ROP Register Control](./img/armrop_registercontrol.png)

## Register Move
Find ARM ROP gadgets that move values between registers.

![ARM ROP Register Move](./img/armrop_registermove.png)

## Stack Finder
Find ARM ROP gadgets that put a stack address in a register. Useful for finding shell code and strings on the stack.

![ARM ROP Stack Finder](./img/armrop_stackfinder.png)

## Summary
Print a summary of gadgets that have been book marked with the string `ropX` 
where `X` is the gadgets position in the rop chain. Don't mix ARM And Thumb 
gadgets with the summary, it won't work. I will fix this.

![Creating a Book mark](./img/bookmark.png)

![ARM Gadget Summary](./img/armrop_summary.png)

## System
Find ARM ROP gadgets for calling system with a user controlled argument.

![ARM ROP System Gadget](./img/armrop_system.png)


<a name=call_chain></a>

```

`readmes/callchain.md`:

```md
# Call Chain
Display the call chain, if it exists, between two functions. The output will 
be display using a modified graphviz library as well as Ghidra's console.

![Call Chain Graph](./img/call_chain_graph.png)

![Call Chain Text](./img/call_chain_text.png)
```

`readmes/codatify.md`:

```md
# Codatify

## Fixup Code 
Define all undefined data in the .text section as code and covert it to a 
function if applicable.

### Before

![Code Before](./img/before_code.png)

### After

![Code After](./img/after_code.png)

## Fixup Data
Define uninitialized strings and pointers in the code. All other uninitialized
data is converted to a DWORD. Finally, search for function tables and rename
functions based off the discovered tables.

### Before 

**Data Section**

![Data Before](./img/before_data.png)

**Cross Reference**

![Xref Before](./img/before_xref.png)

### After

**Data Section**

![Data After](./img/after_data.png)

**Cross Reference**

![Xref Before](./img/after_xref.png)

```

`readmes/fluorescence.md`:

```md
# Fluorescence
Highlight or un-highlight all function calls in the current binary.

![Highlighted function calls](./img/fluorescence.png)
```

`readmes/func_profiler.md`:

```md
# Function Profiler
Display all cross references from the current function. Will display all 
strings, functions, and labels. Depending on the size of the function, the 
console output size may need to be adjusted to view all the text.

![Function Profiler Output](./img/function_profiler.png)
```

`readmes/leafblower.md`:

```md
# Leaf Blower 
Identify common POSIX functions such as printf, sprintf, memcmp, strcpy, etc

## Identify Leaf Functions
Identify leaf functions such as strcpy, strlen, atoi, etc.

![Leaf Functions Output](./img/leaf.png)


## Identify Format Parameter Functions
Identify funtions that accept format parameters to identify sprintf, printf, fscanf, etc.


![Leaf Functions Output](./img/format.png)
```

`readmes/local_cross_ref.md`:

```md
# Local Cross References
Find references to the selected item in the current function.

![Local Cross References](./img/local_xrefs.png)
```

`readmes/mips_rop.md`:

```md
# MIPS ROP Gadget Finder
Find ROP gadgets in MIPS disassembly. 

## Double Jumps
Search for gadgets that contain double jumps.

![Double Jump](./img/double.png)

## Epilogue
Find gadgets that give control of saved registers.

![User Input](./img/epilogue_input.png)

![Epilogue Result](./img/epilogue.png)

## Find
Find gadgets that contain custom MIPS instructions. Regular expressions are 
supported. To search for a move to a0 from anything, simply search for 
"`move a0,.*`".

![Find Dialog Box](./img/find_dialog.png)

![Find Result](./img/find.png)

## Indirect Return
Find indirect return gadgets. Call t9 and then return to ra.

![Indirect Return](./img/iret.png)

## Li a0
Find gadgets that load a small value into a0. Useful for calling sleep.

![Li a0](./img/lia0.png)

## Prologue
Find controllable gadgets at the beginning of functions that provide stack pointer movement.

![Prologue Result](./img/prologue.png)


## Shellcode ROP Chain
Build rop chain to call shellcode. Chain is built off user intput and attempts
to build the shortest chain. Multiple chains can be requested if the first
is not suitable. If not enough registers are controlled a gadget to gain control
of more register will be used first in the chain.

![Shellcode Options](./img/shellcode_options.png)

- Avoid indirect returns
    - Avoid using gadgets that perform jumps to t9 in an epilogue but return to t9. Avoids stack movement.
- Avoid double jumps
    - Avoid gadgets that perform back to back jumps.
- Avoid gadgets that require a control jump
    - If a gadget jumps by controlling an 'a' or 'v' register a gadget will be added to get control of this register. Click this to avoid those types of gadgets.
- Do not reuse gadgets
    - Prevents some gadget reuse. Spices up the results a little bit, but you may not get the shortest chain.
- Verbose Output
    - Print all the outputs.

![Shellcode Chain](./img/shellcode_chain.png)


## System ROP Chain
Build rop chain to call system with a controllable string. Chain is built from
user input and attempts to build the shortest chain using multiple techniques.
Multiple chains can be requested. If not enough registers are controlled 
a gadget to gain control of more register will be used first in the chain.

![System Chain](./img/system_chain.png)


## Stack Finder
Find gadgets that place a stack address in a register.

![Stack Finders](./img/stack_finder.png)

## Summary
Print a summary of gadgets that have been book marked with the string `ropX` 
where `X` is the gadgets position in the rop chain. Double jumps can be displayed
by appending `_d` to the `ropX` bookmark name: `ropX_d`.

![Creating a Book mark](./img/bookmark.png)

![Summary](./img/summary.png)

## System Gadgets
Find gadgets suitable for calling system with user controlled arguments.

![System Gadgets](./img/system_gadget.png)
```

`readmes/operator.md`:

```md
# Operator
Identify calls and the parameters provided to the function when called. The 
script will take into account variadic arguments if they can be identified, 
however, passing argument via the stack will not.

![Function Calls](./img/operator.png)
```

`readmes/rename_variables.md`:

```md
# Rename Variables
Rename saved stack variables for easier tracking. Only valid in MIPS.

![Rename stack variables](./img/rename_variables.png)
```

`readmes/rizzo.md`:

```md
# Rizzo

Create function signatures that can be shared amongst different projects. There
are multiple sets of signatures that are generated:

- Formal:# Rizzo

Create function signatures that can be shared amongst different projects. There
are multiple sets of signatures that are generated:

- Formal: Function matches entirely
- Fuzzy: Functions resemble each other in terms of data/call references.
- String: Functions contain same string references.
- Immediate: Functions match based on large immediate value references.

Formal signatures are applied first, followed by string, immediate, and fuzzy.
If a function is considered a match internal calls are also considered for 
renaming. 

## Apply
Apply Rizzo signatures from another project.

![Apply Rizzo Signatures](./img/rizzo_apply.png)

## Save
Save Rizzo signatures from the current project.

![Save Rizzo Signatures](./img/rizzo_save.png)
 Function matches entirely
- Fuzzy: Functions resemble each other in terms of data/call references.
- String: Functions contain same string references.
- Immediate: Functions match based on large immediate value references.

Formal signatures are applied first, followed by string, immediate, and fuzzy.
If a function is considered a match internal calls are also considered for 
renaming. 

## Apply
Apply Rizzo signatures from another project.

![Apply Rizzo Signatures](./img/rizzo_apply.png)

## Save
Save Rizzo signatures from the current project.

![Save Rizzo Signatures](./img/rizzo_save.png)

```

`utils/armrop.py`:

```py
import re
from . import utils
from ghidra.program.flatapi import FlatProgramAPI
from ghidra.program.model.symbol import DataRefType


format_string = '| {:12} | {:12} | {:30} | {:12} | {:30} |'
format_double_string = '| {:12} | {:30} | {:12} | {:30} | {:12} | {:30} | {:12} | {:30} |'
summary_format = '| {:15} | {:14} | {:30} |'


class ArmInstruction(object):
    """
    Class to represent an ARM Instruction.
    """

    def __init__(self, mnem, op1=None, op2=None, op3=None):
        self.mnem = mnem
        self.op1 = op1
        self.op2 = op2
        self.op3 = op3


class ArmRop(object):
    def __init__(self, program):
        self._flat_api = FlatProgramAPI(program)
        self._currentProgram = program
        self.controllable_calls = []
        self.controllable_terminating_calls = []
        self._find_controllable_calls()

    def find_instructions(self, instructions, preserve_register=None,
                          controllable_calls=True, terminating_calls=True,
                          overwrite_register=None):
        """
        Search for gadgets that contain user defined instructions.

        :param instructions: List of instructions to search for.
        :type instructions: list(MipsInstruction)

        :param preserve_register: Registers to preserve.
        :type preserve_register: str

        :param controllable_calls: Search within controllable jumps.
        :type controllable_calls: bool

        :param terminating_calls: Search within controllable function epilogues.
        :type terminating_calls: bool

        :param overwrite_register: Register to ensure is overwritten.
        :param overwrite_register: str

        :returns: List of rop gadgets that contain the provided instructions.
        :rtype: list(RopGadgets)
        """
        gadgets = RopGadgets()

        search_calls = []
        if controllable_calls:
            search_calls.extend(self.controllable_calls)
        if terminating_calls:
            search_calls.extend(self.controllable_terminating_calls)

        for call in search_calls:
            rop = self._find_instruction(
                call, instructions, preserve_register, overwrite_register)
            if rop and self._is_valid_action(call, rop):
                gadgets.append(RopGadget(rop, call))

        return gadgets

    def find_doubles(self):
        """
        Find double jumps.

        :returns: List of double jump gadgets.
        :rtype: DoubleGadgets
        """
        controllable = self.controllable_calls
        terminating = self.controllable_terminating_calls

        gadgets = DoubleGadgets()
        for call in controllable:
            for second_call in terminating:
                second_call_addr = second_call.control_instruction.getAddress()
                distance = second_call_addr.subtract(call.call.getAddress())

                # Search for a distance of no more than 25 instructions.
                if 0 < distance <= 100:
                    # If the jumps are in different functions do not return
                    # them
                    func1 = self._flat_api.getFunctionContaining(
                        second_call.call.getAddress())
                    func2 = self._flat_api.getFunctionContaining(
                        call.call.getAddress())
                    if func1 != func2:
                        continue

                    if not self._contains_bad_calls(call, second_call):
                        gadgets.append(DoubleGadget(call, second_call))

        return gadgets

    def summary(self):
        """
        Search for book marks that start with 'rop' and print a summary of the 
        ROP gadgets. Case of 'rop' is not important. 
        """
        bookmark_manager = self._currentProgram.getBookmarkManager()
        bookmarks = bookmark_manager.getBookmarksIterator()

        saved_bookmarks = []

        for bookmark in bookmarks:
            comment = bookmark.getComment().lower()
            if comment.startswith('rop'):
                for saved in saved_bookmarks:
                    if saved.getComment().lower() == comment:
                        print 'Duplicate bookmark found: {} at {} and {}'.format(
                            comment, saved.getAddress(), bookmark.getAddress())
                        return
                saved_bookmarks.append(bookmark)

        saved_bookmarks = sorted(saved_bookmarks,
                                 key=lambda x: x.comment.lower())

        rop_gadgets = RopGadgets()

        # Go through each bookmark, find the closest controllable jump, and
        # create a gadget.
        for bookmark in saved_bookmarks:
            closest_jmp = self._find_closest_controllable_jump(
                bookmark.getAddress())

            if closest_jmp:
                curr_addr = bookmark.getAddress()
                curr_ins = self._flat_api.getInstructionAt(curr_addr)
                rop_gadgets.append(RopGadget(curr_ins, closest_jmp,
                                             bookmark.getComment()))
        rop_gadgets.print_summary()

    def _find_closest_controllable_jump(self, address):
        """
        Find closest controllable jump to the address provided.

        :param address: Address to find closest jump to.
        :type address: ghidra.program.model.address.Address

        :returns: Closest controllable jump, if it exists.
        :rtype: ControllableCall or None
        """
        controllable = self.controllable_calls + \
            self.controllable_terminating_calls

        function = self._flat_api.getFunctionContaining(address)

        closest = None

        for jump in controllable:
            jump_function = self._flat_api.getFunctionContaining(
                jump.call.getAddress())
            if function != jump_function:
                continue

            if address > jump.control_instruction.getAddress():
                continue

            if jump.call.getAddress() == address:
                return jump

            if not closest or \
                    jump.control_instruction.getAddress() <= \
                    address <= jump.call.getAddress():
                closest = jump
            else:
                control_addr = jump.control_instruction.getAddress()
                closest_distances = closest.control_instruction.getAddress()
                if control_addr.subtract(address) < \
                        closest_distances.subtract(address):
                    closest = jump
        return closest

    def _find_controllable_calls(self):
        """
        Find calls that can be controlled through saved registers.
        """
        program_base = self._currentProgram.getImageBase()

        code_manager = self._currentProgram.getCodeManager()
        instructions = code_manager.getInstructions(program_base, True)

        # Loop through each instruction in the current program.
        for ins in instructions:
            flow_type = ins.getFlowType()

            if flow_type.isCall() or flow_type.isTerminal() or \
                    (flow_type.isJump() and flow_type.isComputed()):
                current_instruction = self._flat_api.getInstructionAt(
                    ins.getAddress())
                controllable = self._find_controllable_call(
                    current_instruction)

                # Sort the controllable jump by type. Makes finding indirect
                # function calls easier.
                if controllable:
                    if flow_type.isCall() and not flow_type.isTerminal():
                        self.controllable_calls.append(controllable)
                    elif flow_type.isTerminal() or \
                            (flow_type.isJump() and flow_type.isComputed()):
                        self.controllable_terminating_calls.append(
                            controllable)

    def _find_controllable_call(self, call_instruction):
        """
        Search for how the jump register is set. If it comes from a potentially
        controllable register then return it.

        :param call_instruction: Instruction that contains a call.
        :type instruction: ghidra.program.mdel.listing.Instruction

        :returns: Controllable call object if controllable, None if not.
        :rtype: ControllableCall or None
        """
        branch_link = ArmInstruction('blx', '[r][0123456789]')
        branch_exchange = ArmInstruction('bx', '[r][0123456789]')
        end = ArmInstruction('ldmia', 'sp*')

        if instruction_matches(call_instruction, [branch_link, branch_exchange, end]):
            return ControllableCall(call_instruction, call_instruction)
        return None

    def _get_previous_instruction(self, instruction):
        """
        Get the previous instruction. Check the "flow" first, if not found
        just return the previous memory instruction.

        :param instruction: Instruction to retrieve previous instruction from.
        :type instruction: ghidra.program.model.listing.Instruction
        """
        fall_from = instruction.getFallFrom()
        if fall_from is None:
            previous_ins = instruction.getPrevious()
        else:
            previous_ins = self._flat_api.getInstructionAt(fall_from)

        return previous_ins

    def _find_instruction(self, controllable_call, search_instructions,
                          preserve_reg=None, overwrite_reg=None):
        """
        Search for an instruction within a controllable call. 

        :param controllable_call: Controllable call to search within.
        :type controllable_call: ControllableCall

        :param search_instructions: Instruction list to search for.
        :type search_instructions: list(MipsInstruction)

        :param preserve_reg: Register to preserve, if overwritten the 
                             instruction will not be returned.
        :type preserve_reg: str

        :param overwrite_reg: Enforce a register was overwritten.
        :type overwrite_reg: str

        :returns: The matching instruction if found, None otherwise.
        :rtype: ghidra.program.model.listing.Instruction
        """
        overwritten = False

        if instruction_matches(controllable_call.call, search_instructions):
            return controllable_call.call

        previous_ins = self._get_previous_instruction(controllable_call.call)
        function = self._flat_api.getFunctionContaining(
            controllable_call.call.getAddress())

        while previous_ins:
            # Break if we hit a call or jump.
            if utils.is_call_instruction(previous_ins) or \
                    utils.is_jump_instruction(previous_ins):
                return None

            # Break if we entered a different function.
            if function != self._flat_api.getFunctionContaining(previous_ins.getAddress()):
                return None

            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            if instruction_matches(previous_ins, search_instructions):
                if overwrite_reg and not overwritten:
                    return None
                return previous_ins

            if preserve_reg and \
                    register_overwritten(previous_ins, preserve_reg):
                return None

            if overwrite_reg and register_overwritten(previous_ins,
                                                      overwrite_reg):
                overwritten = True

            # TODO: Need to see if we passed the point of caring.
            if register_overwritten(previous_ins,
                                    controllable_call.get_control_item()):
                return None

            previous_ins = self._get_previous_instruction(previous_ins)

        return None

    def _is_valid_action(self, controllable_call, action):
        """
        Determine if an action is valid for the controllable call. 

        :param controllable_call: Controllable call to search within.
        :type controllable_call: ControllableCall

        :param action: Action to validate.
        :type action: ghidra.program.model.listing.Instruction

        :returns: The matching instruction if found, None otherwise.
        :rtype: ghidra.program.model.listing.Instruction
        """
        if controllable_call.call == action:
            return True

        previous_ins = controllable_call.call
        preserve_reg = action.getOpObjects(0)
        if preserve_reg:
            preserve_reg = str(preserve_reg[0])

        while previous_ins and previous_ins != action:
            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            if register_overwritten(previous_ins, preserve_reg):
                return False

            previous_ins = self._get_previous_instruction(previous_ins)

        return True

    def _contains_bad_calls(self, first, second):
        """
        Search for bad calls between two controllable jumps.

        :param first: Controllable call that comes first in memory.
        :type first: ControllableCall

        :param second: Controllable call that comes second in memory.
        :type second ControllableCall

        :returns: True if bad calls are found, False otherwise.
        :rtype: bool
        """
        branch = ArmInstruction('b.*')

        end_ins = first.call

        previous_ins = self._get_previous_instruction(
            second.control_instruction)

        while previous_ins.getAddress() > end_ins.getAddress():
            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            if instruction_matches(previous_ins, [branch]):
                return True

            previous_ins = self._get_previous_instruction(previous_ins)

        return False


class ControllableCall(object):
    """
    Class to store controllable calls and the instruction that controls it.
    """

    def __init__(self, instruction, control_instruction):
        self.call = instruction
        self.control_instruction = control_instruction

    def get_source_register(self):
        """
        Get the controlling source register.
        """
        try:
            return str(self.control_instruction.getOpObjects(1)[-1])
        except:
            return None

    def get_control_item(self):
        """
        Get string source of the control item. 
        """
        return self.control_instruction.getDefaultOperandRepresentation(0)

    def control_jump(self):
        """
#        Return string representing the jump. Instead of 'jalr t9' it might 
#        return 'jalr s4' to represent the controlling register.
        """
        return '{:10} {}'.format(self.call.getMnemonicString(),
                                 self.get_control_item())

    def __str__(self):
        return '{} {} -> {} {}'.format(self.control_instruction.getAddress(),
                                       self.control_instruction,
                                       self.call.getAddress(),
                                       self.call)


class RopGadget(object):
    """
    Class to represent discovered gadgets.
    """

    def __init__(self, action, jump, name=None):
        self.action = action
        self.jump = jump
        self.name = name

    def __str__(self):
        control_addr = self.jump.control_instruction.getAddress()
        action_addr = self.action.getAddress()

        start = self.jump.control_instruction \
            if control_addr < action_addr else self.action

        return format_string.format(start,
                                    self.action.getAddress(),
                                    self.action,
                                    self.jump.call.getAddress(),
                                    self.jump.control_jump())

    def get_start(self):
        control_addr = self.jump.control_instruction.getAddress()
        action_addr = self.action.getAddress()

        start = self.jump.control_instruction \
            if control_addr < action_addr else self.action

        if len(start.getBytes()) == 4:
            return start.getAddress()
        else:
            return '%s + 1 = %s' % (start.getAddress(), start.getAddress().add(1))

    def get_instructions(self):
        """
        Get a list of instructions between the first instruction in the rop
        and the call.
        """
        instructions = []

        # Find the higher call, the action or the control instruction.
        start_ins = self.action if self.action.getAddress() \
            < self.jump.control_instruction.getAddress() else \
            self.jump.control_instruction

        instructions.append(start_ins)
        curr_ins = start_ins
        while curr_ins.getAddress() < self.jump.call.getAddress():
            curr_ins = curr_ins.getNext()
            instructions.append(curr_ins)

        return instructions


class RopGadgets(object):
    """
    Class to contain discovered gadgets.
    """

    def __init__(self):
        self.gadgets = []

    def append(self, gadget):
        """
        Add a gadget to the list.
        """
        self.gadgets.append(gadget)

    def pretty_print(self):
        """
        Print the gadgets in a nice table.
        """
        title = ['Gadget Start', 'Action Addr', 'Action', 'Jump Addr', 'Jump']
        gadgets = []
        for gadget in self.gadgets:
            start = gadget.get_start()
            data = [start, gadget.action.getAddress(),
                    gadget.action, gadget.jump.call.getAddress(),
                    gadget.jump.control_jump()]
            data = map(str, data)
            gadgets.append(data)

        if gadgets:
            utils.table_pretty_print(title, gadgets)
        print 'Found %d matching gadgets.' % len(gadgets)

    def print_summary(self):
        """
        Print ROP chain summary.
        """
        if len(self.gadgets):
            title = summary_format.format(
                'Gadget Name', 'Gadget Offset', 'Summary')
            line_len = len(title)
            print '-' * line_len
            print title
            print '-' * line_len
            for gadget in self.gadgets:
                instructions = gadget.get_instructions()
                print summary_format.format(gadget.name,
                                            instructions[0].getAddress(),
                                            instructions[0])
                for instruction in instructions[1:]:
                    print summary_format.format('', '', instruction)
                print '-' * line_len
        else:
            print 'No bookmarks with "rop" found.'


class DoubleGadget(object):
    """
    Class to contain double jump gadget.
    """

    def __init__(self, first, second, name=None):
        self.first = first
        self.second = second
        self.name = name
        self.instructions = []

    def __str__(self):
        return format_double_string.format(
            self.first.control_instruction.getAddress(),
            self.first.control_instruction,
            self.first.call.getAddress(), self.first.control_jump(),
            self.second.control_instruction.getAddress(),
            self.second.control_instruction,
            self.second.call.getAddress(),
            self.second.control_jump())

    def __len__(self):
        return len(self.get_instructions())

    def print_instructions(self):
        """
        Print instructions in the gadget.
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            print '%s : %s' % (instruction.getAddress(), instruction)

    def overwrites_register(self, register):
        """
        Determine if a register is overwritten in the gadget.

        :returns True if the register is overwritten, False otherwise.
        :rtype: bool
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            if register_overwritten(instruction, register):
                return True
        return False

    def get_instructions(self):
        """
        Get a list of instructions between the first instruction in the rop
        and the call.
        """
        if self.instructions:
            return self.instructions

        # Find the higher call, the action or the control instruction.
        start_ins = self.first.control_instruction if self.first.control_instruction.getAddress() \
            < self.first.call.getAddress() else self.first.call

        self.instructions.append(start_ins)
        curr_ins = start_ins
        while curr_ins.getAddress() <= self.second.call.getAddress():
            curr_ins = curr_ins.getNext()
            self.instructions.append(curr_ins)

        return self.instructions

    def get_action_destination_register(self):
        """
        Get the action destination register.

        :returns: Destination register as a list of strings.
        :rtype: list(str)
        """
        dest = []
        try:
            dest.append(str(self.first.control_instruction.getOpObjects(0)[0]))
            dest.append(
                str(self.second.control_instruction.getOpObjects(0)[0]))
        except:
            return []
        return dest

    def get_action_source_register(self):
        """
        Get the action source register.

        :returns: Source registers as a list of strings.
        :rtype: list(str)
        """
        src = []
        try:
            src.append(str(self.first.control_instruction.getOpObjects(1)[0]))
            src.append(str(self.second.control_instruction.getOpObjects(1)[0]))
        except:
            return []
        return src


class DoubleGadgets(RopGadgets):
    """
    Class to contain double jump gadget.
    """

    def __init__(self):
        self.gadgets = []
        super(DoubleGadgets, self).__init__()

    def pretty_print(self):
        """
        Print gadgets in a nice table.
        """
        gadgets = []
        if len(self.gadgets):
            title = ['1st Jump', 'Address', '2nd Jump', 'Address']
            for gadget in self.gadgets:
                gadgets.append([
                    str(gadget.first.call.getAddress()
                        ), gadget.first.control_jump(),
                    str(gadget.second.call.getAddress()), gadget.second.control_jump()])
            utils.table_pretty_print(title, gadgets)

        print 'Found {} matching gadgets.\n'.format(len(self.gadgets))


def instruction_matches(ins, matches):
    """
    Does instruction match any from a list of given instructions.

    :param ins: Instruction to compare.
    :type ins: ghidra.program.model.listing.Instruction

    :param matches: List of instructions to compare against. Regex supported.
    :type matches: list(MipsInstruction)

    :returns: True if an instruction match was found, False otherwise.
    :rtype: bool
    """
    for match in matches:
        if not re.match(match.mnem, ins.getMnemonicString()):
            continue
        try:
            _, ops = str(ins).split(' ', 1)
            if match.op1:
                if ',' in ops:
                    first_op, ops = ops.split(',', 1)
                else:
                    first_op = ops
                if not re.match(match.op1, first_op.strip()):
                    continue

                if match.op2:
                    if ',' in ops:
                        second_op, ops = ops.split(',', 1)
                    else:
                        second_op = ops
                    if not re.match(match.op2, second_op.strip()):
                        continue

                    if match.op3 and \
                            not re.match(match.op3, ops.strip()):
                        continue
            return True
        except ValueError as e:
            continue
        return False


def register_overwritten(ins, register):
    """
    Check if a register is overwritten in an instruction.

    :param ins: Instruction to inspect.
    :type ins: ghidra.program.model.listing.Instruction

    :param register: Register to search for.
    :type register: str

    :returns: True if overwritten, False otherwise.
    :rtype: bool
    """
    objects = ins.getOpObjects(0)
    ref_type = ins.getOperandRefType(0)
    if objects and str(objects[0]) == register:
        if ref_type and ref_type in [DataRefType.WRITE, DataRefType.READ_WRITE]:
            return True
    elif not ref_type:
        # Some ldmia do not report operand ref type so see if the register
        # in question appears in the results objects.
        result_objects = ins.getResultObjects()
        results = [str(result) for result in result_objects]
        if register in results:
            return True
    return False

```

`utils/functiontable.py`:

```py
import string

from ghidra.program.model.symbol import SourceType
from ghidra.program.flatapi import FlatProgramAPI


def is_valid_function_name(function_name):
    """
    Determine if a function name is valid.

    :param function_name: Function name to inspect.
    :type function_name: unicode

    :returns: True if valid function name, false otherwise.
    :rtype: bool
    """
    if not isinstance(function_name, unicode):
        return False

    if function_name[0] not in string.ascii_letters + '_':
        return False
    for letter in function_name[1:]:
        if letter not in string.ascii_letters + '_' + string.digits:
            return False
    return True


class Element(object):
    """
    Single element in a structure.
    """

    def __init__(self, program, address):
        self._program = program
        self._flat_api = FlatProgramAPI(self._program)
        self._data = self._flat_api.getDataAt(address)

        self.address = address
        self.type = None
        self.value = None

        if not self._data:
            return

        # Determine the data's type and set the type/value accordingly.
        if self._data.isPointer():
            reference = self._data.getPrimaryReference(0)
            if not reference:
                return

            to_addr = reference.toAddress
            func = self._flat_api.getFunctionAt(to_addr)
            if func:
                self.type = 'function'
                self.value = func
            else:
                value = self._flat_api.getDataAt(to_addr)
                if value:
                    self.type = 'data'
                    self.value = value
        else:
            self.type = self._data.dataType
            self.value = self._data


class Structure(object):
    """
    Declared structure
    """

    def __init__(self, program, address, element_count, length=0):
        self._program = program
        self._element_size = self._program.getDefaultPointerSize()

        self.address = address
        self.elements = []
        self.length = length

        curr_addr = self.address
        for i in range(0, element_count):
            element = Element(self._program, curr_addr)
            self.elements.append(element)
            curr_addr = curr_addr.add(self._element_size)
            if not curr_addr:
                break

    def get_pattern(self):
        """
        Get the element pattern for this structure.

        :returns: List of element types.
        :rtype: list(objects)
        """
        return [element.type for element in self.elements]

    def get_function(self):
        """
        Each valid structure *should* contains one function. Find and return it.

        :returns: Function, if found, None otherwise.
        :rtype: ghidra.program.model.listing.Function or None
        """
        for element in self.elements:
            if element.type == 'function':
                return element.value
        return None

    def get_string(self):
        """
        Each valid structure *should* contains one string. Find and return it.

        :returns: String, if found, None otherwise.
        :rtype: str or None
        """
        for element in self.elements:
            if element.type == 'data':
                return element.value.getValue()
        return None

    def next(self):
        """
        Get the next structure in the structure array.

        :returns: Next structure or None if at the end of the array.
        :rtype: Structure or None
        """
        if self.length <= 0:
            return None

        next_addr = self.address.add(len(self.elements) * self._element_size)

        return Structure(self._program, next_addr, len(self.elements),
                         self.length - 1)


class StructureFinder(object):
    """
    Search for structures that appear to represent a function table at the 
    specified address.
    """

    def __init__(self, program, address):
        self._program = program
        self.address = address
        self.pattern_length = 0
        self.length = 1
        self._element_size = self._program.getDefaultPointerSize()
        self.structure = Structure(program, address, 16)

    def has_pattern(self):
        """
        Determine if there is a structure pattern within 16 elements of the
        provided start address.

        :returns: True if a pattern was found, False otherwise.
        :rtype: bool
        """
        for i in range(2, len(self.structure.elements) / 2):
            blk_one = self.structure.elements[:i]
            pattern_one = [element.type for element in blk_one]

            blk_two = self.structure.elements[i:i + i]
            pattern_two = [element.type for element in blk_two]

            # Valid patterns can only have one function and one data element.
            if 'function' not in pattern_one or 'data' not in pattern_one:
                continue

            if 1 != pattern_one.count('function'):
                continue
            if 1 != pattern_one.count('data'):
                continue

            if pattern_one == pattern_two:
                self.pattern_length = len(pattern_one)
                return True
        return False

    def _get_next_struct(self, address):
        """
        Get the next apparent structure in the structure array.

        :returns: Next structure in the array.
        :rtype: Structure
        """
        next_addr = address.add(
            self.pattern_length * self._element_size)
        return Structure(self._program, next_addr, self.pattern_length)

    def find_length(self):
        """
        Determine the length of the structure array by casting the next entry
        until the pattern no longer matches.

        :returns: Length of structure array.
        :rtype: int
        """
        if self.pattern_length == 0:
            return 0

        first_entry = Structure(
            self._program, self.address, self.pattern_length)
        pattern = first_entry.get_pattern()

        next_entry = self._get_next_struct(self.address)

        while next_entry and next_entry.get_pattern() == pattern:
            self.length += 1
            next_entry = self._get_next_struct(next_entry.address)

        return self.length

    def get_next_search(self):
        """
        Get the next structure search.

        :returns: Structure finder object after this one.
        :rtype: StructureFinder
        """
        curr_addr = self.address
        next_addr = self.length * self._element_size

        if self.pattern_length:
            next_addr *= self.pattern_length
        next_struct = curr_addr.add(next_addr)
        return StructureFinder(self._program, next_struct)


class Finder(object):
    """
    Find function tables in the current program and rename them.
    """

    def __init__(self, program, section):
        self._program = program
        self._min_address = section.getMinAddress()
        self._max_address = section.getMaxAddress()
        self._element_size = self._program.getDefaultPointerSize()

        self.structs = []

    def find_function_table(self):
        """
        Find suspected function tables within the current section.
        """
        struct = StructureFinder(self._program, self._min_address)
        while struct and struct.address < self._max_address:
            if struct.has_pattern():
                length = struct.find_length()
                new_struct = Structure(self._program,
                                       struct.address,
                                       struct.pattern_length,
                                       length)

                self.structs.append(new_struct)
            struct = struct.get_next_search()

    def rename_functions(self):
        """
        Rename unnamed functions from suspected function tables.
        """
        renames = 0
        for struct in self.structs:
            curr_struct = struct
            while curr_struct:
                function = curr_struct.get_function()
                if function:
                    curr_name = function.getName()
                    if curr_name.startswith('FUN_'):
                        new_name = curr_struct.get_string()
                        if new_name and is_valid_function_name(new_name):
                            function.setName(new_name, SourceType.USER_DEFINED)
                            renames += 1

                curr_struct = curr_struct.next()

        print 'Function Names - %d' % renames

```

`utils/graphviz/__init__.py`:

```py
# graphviz - create dot, save, render, view

"""Assemble DOT source code and render it with Graphviz.

>>> dot = Digraph(comment='The Round Table')

>>> dot.node('A', 'King Arthur')
>>> dot.node('B', 'Sir Bedevere the Wise')
>>> dot.node('L', 'Sir Lancelot the Brave')

>>> dot.edges(['AB', 'AL'])

>>> dot.edge('B', 'L', constraint='false')

>>> print(dot)  #doctest: +NORMALIZE_WHITESPACE
// The Round Table
digraph {
    A [label="King Arthur"]
    B [label="Sir Bedevere the Wise"]
    L [label="Sir Lancelot the Brave"]
    A -> B
    A -> L
    B -> L [constraint=false]
}
"""

from .dot import Graph, Digraph
from .files import Source
from .lang import nohtml
from .backend import (render, pipe, version, view,
                      ENGINES, FORMATS, RENDERERS, FORMATTERS,
                      ExecutableNotFound, RequiredArgumentError)

__all__ = [
    'Graph', 'Digraph',
    'Source',
    'nohtml',
    'render', 'pipe', 'version', 'view',
    'ENGINES', 'FORMATS', 'RENDERERS', 'FORMATTERS',
    'ExecutableNotFound', 'RequiredArgumentError',
]

__title__ = 'graphviz'
__version__ = '0.12'
__author__ = 'Sebastian Bank <sebastian.bank@uni-leipzig.de>'
__license__ = 'MIT, see LICENSE.txt'
__copyright__ = 'Copyright (c) 2013-2019 Sebastian Bank'

#: Set of known layout commands used for rendering (``'dot'``, ``'neato'``, ...)
ENGINES = ENGINES

#: Set of known output formats for rendering (``'pdf'``, ``'png'``, ...)
FORMATS = FORMATS

#: Set of known output formatters for rendering (``'cairo'``, ``'gd'``, ...)
FORMATTERS = FORMATTERS

#: Set of known output renderers for rendering (``'cairo'``, ``'gd'``, ...)
RENDERERS = RENDERERS

ExecutableNotFound = ExecutableNotFound

RequiredArgumentError = RequiredArgumentError

```

`utils/graphviz/_compat.py`:

```py
# _compat.py - Python 2/3 compatibility

import os
import sys
import operator
import subprocess

PY2 = (sys.version_info.major == 2)


if PY2:
    string_classes = (str, unicode)  # needed individually for sublassing
    text_type = unicode

    iteritems = operator.methodcaller('iteritems')

    def makedirs(name, mode=0o777, exist_ok=False):
        try:
            os.makedirs(name, mode)
        except OSError:
            if not exist_ok or not os.path.isdir(name):
                raise

    def stderr_write_bytes(data, flush=False):
        """Write data str to sys.stderr (flush if requested)."""
        sys.stderr.write(data)
        if flush:
            sys.stderr.flush()

    def Popen_stderr_devnull(*args, **kwargs):  # noqa: N802
        with open(os.devnull, 'w') as f:
            return subprocess.Popen(*args, stderr=f, **kwargs)

    class CalledProcessError(subprocess.CalledProcessError):

        def __init__(self, returncode, cmd, output=None, stderr=None):
            super(CalledProcessError, self).__init__(returncode, cmd, output)
            self.stderr = stderr

        @property
        def stdout(self):
            return self.output

        @stdout.setter
        def stdout(self, value):  # pragma: no cover
            self.output = value


else:
    string_classes = (str,)
    text_type = str

    def iteritems(d):
        return iter(d.items())

    def makedirs(name, mode=0o777, exist_ok=False):  # allow os.makedirs mocking
        return os.makedirs(name, mode, exist_ok=exist_ok)

    def stderr_write_bytes(data, flush=False):
        """Encode data str and write to sys.stderr (flush if requested)."""
        encoding = sys.stderr.encoding or sys.getdefaultencoding()
        sys.stderr.write(data.decode(encoding))
        if flush:
            sys.stderr.flush()

    def Popen_stderr_devnull(*args, **kwargs):  # noqa: N802
        return subprocess.Popen(*args, stderr=subprocess.DEVNULL, **kwargs)

    CalledProcessError = subprocess.CalledProcessError

```

`utils/graphviz/backend.py`:

```py
# backend.py - execute rendering, open files in viewer

import os
import re
import sys
import errno
import logging
import platform
import subprocess

from . import _compat

from . import tools

__all__ = [
    'render', 'pipe', 'version', 'view',
    'ENGINES', 'FORMATS', 'RENDERERS', 'FORMATTERS',
    'ExecutableNotFound', 'RequiredArgumentError',
]

ENGINES = {  # http://www.graphviz.org/pdf/dot.1.pdf
    'dot', 'neato', 'twopi', 'circo', 'fdp', 'sfdp', 'patchwork', 'osage',
}

FORMATS = {  # http://www.graphviz.org/doc/info/output.html
    'bmp',
    'canon', 'dot', 'gv', 'xdot', 'xdot1.2', 'xdot1.4',
    'cgimage',
    'cmap',
    'eps',
    'exr',
    'fig',
    'gd', 'gd2',
    'gif',
    'gtk',
    'ico',
    'imap', 'cmapx',
    'imap_np', 'cmapx_np',
    'ismap',
    'jp2',
    'jpg', 'jpeg', 'jpe',
    'json', 'json0', 'dot_json', 'xdot_json',  # Graphviz 2.40
    'pct', 'pict',
    'pdf',
    'pic',
    'plain', 'plain-ext',
    'png',
    'pov',
    'ps',
    'ps2',
    'psd',
    'sgi',
    'svg', 'svgz',
    'tga',
    'tif', 'tiff',
    'tk',
    'vml', 'vmlz',
    'vrml',
    'wbmp',
    'webp',
    'xlib',
    'x11',
}

RENDERERS = {  # $ dot -T:
    'cairo',
    'dot',
    'fig',
    'gd',
    'gdiplus',
    'map',
    'pic',
    'pov',
    'ps',
    'svg',
    'tk',
    'vml',
    'vrml',
    'xdot',
}

FORMATTERS = {'cairo', 'core', 'gd', 'gdiplus', 'gdwbmp', 'xlib'}

PLATFORM = sys.platform.lower()
if 'java' in PLATFORM:
    import java.lang
    PLATFORM = java.lang.System.getProperty('os.name').lower()

log = logging.getLogger(__name__)


class ExecutableNotFound(RuntimeError):
    """Exception raised if the Graphviz executable is not found."""

    _msg = ('failed to execute %r, '
            'make sure the Graphviz executables are on your systems\' PATH')

    def __init__(self, args):
        super(ExecutableNotFound, self).__init__(self._msg % args)


class RequiredArgumentError(Exception):
    """Exception raised if a required argument is missing."""


class CalledProcessError(_compat.CalledProcessError):

    def __str__(self):
        s = super(CalledProcessError, self).__str__()
        return '%s [stderr: %r]' % (s, self.stderr)


def command(engine, format_, filepath=None, renderer=None, formatter=None):
    """Return args list for ``subprocess.Popen`` and name of the rendered file."""
    if formatter is not None and renderer is None:
        raise RequiredArgumentError('formatter given without renderer')

    if engine not in ENGINES:
        raise ValueError('unknown engine: %r' % engine)
    if format_ not in FORMATS:
        raise ValueError('unknown format: %r' % format_)
    if renderer is not None and renderer not in RENDERERS:
        raise ValueError('unknown renderer: %r' % renderer)
    if formatter is not None and formatter not in FORMATTERS:
        raise ValueError('unknown formatter: %r' % formatter)

    output_format = [f for f in (format_, renderer, formatter) if f is not None]
    cmd = [engine, '-T%s' % ':'.join(output_format)]
    rendered = None

    if filepath is not None:
        cmd.extend(['-O', filepath])
        suffix = '.'.join(reversed(output_format))
        rendered = '%s.%s' % (filepath, suffix)

    return cmd, rendered


if PLATFORM == 'windows':  # pragma: no cover
    def get_startupinfo():
        """Return subprocess.STARTUPINFO instance hiding the console window."""
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE
        return startupinfo
else:
    def get_startupinfo():
        """Return None for startupinfo argument of ``subprocess.Popen``."""
        return None


def run(cmd, input=None, capture_output=False, check=False, quiet=False, **kwargs):
    """Run the command described by cmd and return its (stdout, stderr) tuple."""
    log.debug('run %r', cmd)
    if input is not None:
        kwargs['stdin'] = subprocess.PIPE
    if capture_output:
        kwargs['stdout'] = kwargs['stderr'] = subprocess.PIPE

    try:
        proc = subprocess.Popen(cmd, startupinfo=get_startupinfo(), **kwargs)
    except OSError as e:
        if e.errno == errno.ENOENT:
            raise ExecutableNotFound(cmd)
        else:
            raise

    out, err = proc.communicate(input)

    if not quiet and err:
        _compat.stderr_write_bytes(err, flush=True)
    if check and proc.returncode:
        raise CalledProcessError(proc.returncode, cmd,
                                 output=out, stderr=err)

    return out, err


def render(engine, format, filepath, renderer=None, formatter=None, quiet=False):
    """Render file with Graphviz ``engine`` into ``format``,  return result filename.

    Args:
        engine: The layout commmand used for rendering (``'dot'``, ``'neato'``, ...).
        format: The output format used for rendering (``'pdf'``, ``'png'``, ...).
        filepath: Path to the DOT source file to render.
        renderer: The output renderer used for rendering (``'cairo'``, ``'gd'``, ...).
        formatter: The output formatter used for rendering (``'cairo'``, ``'gd'``, ...).
        quiet (bool): Suppress ``stderr`` output from the layout subprocess.
    Returns:
        The (possibly relative) path of the rendered file.
    Raises:
        ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter`` are not known.
        graphviz.RequiredArgumentError: If ``formatter`` is given but ``renderer`` is None.
        graphviz.ExecutableNotFound: If the Graphviz executable is not found.
        subprocess.CalledProcessError: If the exit status is non-zero.

    The layout command is started from the directory of ``filepath``, so that
    references to external files (e.g. ``[image=...]``) can be given as paths
    relative to the DOT source file.
    """
    dirname, filename = os.path.split(filepath)
    cmd, rendered = command(engine, format, filename, renderer, formatter)
    if dirname:
        cwd = dirname
        rendered = os.path.join(dirname, rendered)
    else:
        cwd = None
    run(cmd, capture_output=True, cwd=cwd, check=True, quiet=quiet)
    return rendered


def pipe(engine, format, data, renderer=None, formatter=None, quiet=False):
    """Return ``data`` piped through Graphviz ``engine`` into ``format``.

    Args:
        engine: The layout commmand used for rendering (``'dot'``, ``'neato'``, ...).
        format: The output format used for rendering (``'pdf'``, ``'png'``, ...).
        data: The binary (encoded) DOT source string to render.
        renderer: The output renderer used for rendering (``'cairo'``, ``'gd'``, ...).
        formatter: The output formatter used for rendering (``'cairo'``, ``'gd'``, ...).
        quiet (bool): Suppress ``stderr`` output from the layout subprocess.
    Returns:
        Binary (encoded) stdout of the layout command.
    Raises:
        ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter`` are not known.
        graphviz.RequiredArgumentError: If ``formatter`` is given but ``renderer`` is None.
        graphviz.ExecutableNotFound: If the Graphviz executable is not found.
        subprocess.CalledProcessError: If the exit status is non-zero.
    """
    cmd, _ = command(engine, format, None, renderer, formatter)
    out, _ = run(cmd, input=data, capture_output=True, check=True, quiet=quiet)
    return out


def version():
    """Return the version number tuple from the ``stderr`` output of ``dot -V``.

    Returns:
        Two or three ``int`` version ``tuple``.
    Raises:
        graphviz.ExecutableNotFound: If the Graphviz executable is not found.
        subprocess.CalledProcessError: If the exit status is non-zero.
        RuntimmeError: If the output cannot be parsed into a version number.
    """
    cmd = ['dot', '-V']
    out, _ = run(cmd, check=True,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.STDOUT)

    info = out.decode('ascii')
    ma = re.search(r'graphviz version (\d+\.\d+(?:\.\d+)?) ', info)
    if ma is None:
        raise RuntimeError('cannot parse %r output: %r' % (cmd, info))
    return tuple(int(d) for d in ma.group(1).split('.'))


def view(filepath, quiet=False):
    """Open filepath with its default viewing application (platform-specific).

    Args:
        filepath: Path to the file to open in viewer.
        quiet (bool): Suppress ``stderr`` output from the viewer process
                      (ineffective on Windows).
    Raises:
        RuntimeError: If the current platform is not supported.
    """
    try:
        view_func = getattr(view, PLATFORM)
    except AttributeError:
        raise RuntimeError('platform %r not supported' % PLATFORM)
    view_func(filepath, quiet)


@tools.attach(view, 'darwin')
def view_darwin(filepath, quiet):
    """Open filepath with its default application (mac)."""
    cmd = ['open', filepath]
    log.debug('view: %r', cmd)
    popen_func = _compat.Popen_stderr_devnull if quiet else subprocess.Popen
    popen_func(cmd)


@tools.attach(view, 'linux')
@tools.attach(view, 'freebsd')
def view_unixoid(filepath, quiet):
    """Open filepath in the user's preferred application (linux, freebsd)."""
    cmd = ['xdg-open', filepath]
    log.debug('view: %r', cmd)
    popen_func = _compat.Popen_stderr_devnull if quiet else subprocess.Popen
    popen_func(cmd)


@tools.attach(view, 'windows')
def view_windows(filepath, quiet):
    """Start filepath with its associated application (windows)."""
    # TODO: implement quiet=True
    filepath = os.path.normpath(filepath)
    log.debug('view: %r', filepath) 
    os.startfile(filepath)

```

`utils/graphviz/dot.py`:

```py
# dot.py - create dot code

r"""Assemble DOT source code objects.

>>> dot = Graph(comment=u'M\xf8nti Pyth\xf8n ik den H\xf8lie Grailen')

>>> dot.node(u'M\xf8\xf8se')
>>> dot.node('trained_by', u'trained by')
>>> dot.node('tutte', u'TUTTE HERMSGERVORDENBROTBORDA')

>>> dot.edge(u'M\xf8\xf8se', 'trained_by')
>>> dot.edge('trained_by', 'tutte')

>>> dot.node_attr['shape'] = 'rectangle'

>>> print(dot.source.replace(u'\xf8', '0'))  #doctest: +NORMALIZE_WHITESPACE
// M0nti Pyth0n ik den H0lie Grailen
graph {
    node [shape=rectangle]
    "M00se"
    trained_by [label="trained by"]
    tutte [label="TUTTE HERMSGERVORDENBROTBORDA"]
    "M00se" -- trained_by
    trained_by -- tutte
}

>>> dot.view('test-output/m00se.gv')  # doctest: +SKIP
'test-output/m00se.gv.pdf'
"""

from . import lang
from . import files

__all__ = ['Graph', 'Digraph']


class Dot(files.File):
    """Assemble, save, and render DOT source code, open result in viewer."""

    _comment = '// %s'
    _subgraph = 'subgraph %s{'
    _subgraph_plain = '%s{'
    _node = _attr = '\t%s%s'
    _attr_plain = _attr % ('%s', '')
    _tail = '}'

    _quote = staticmethod(lang.quote)
    _quote_edge = staticmethod(lang.quote_edge)

    _a_list = staticmethod(lang.a_list)
    _attr_list = staticmethod(lang.attr_list)

    def __init__(self, name=None, comment=None,
                 filename=None, directory=None,
                 format=None, engine=None, encoding=files.ENCODING,
                 graph_attr=None, node_attr=None, edge_attr=None, body=None,
                 strict=False):
        self.name = name
        self.comment = comment

        super(Dot, self).__init__(filename, directory, format, engine, encoding)

        self.graph_attr = dict(graph_attr) if graph_attr is not None else {}
        self.node_attr = dict(node_attr) if node_attr is not None else {}
        self.edge_attr = dict(edge_attr) if edge_attr is not None else {}

        self.body = list(body) if body is not None else []

        self.strict = strict

    def _kwargs(self):
        result = super(Dot, self)._kwargs()
        result.update(name=self.name,
                      comment=self.comment,
                      graph_attr=dict(self.graph_attr),
                      node_attr=dict(self.node_attr),
                      edge_attr=dict(self.edge_attr),
                      body=list(self.body),
                      strict=self.strict)
        return result

    def clear(self, keep_attrs=False):
        """Reset content to an empty body, clear graph/node/egde_attr mappings.

        Args:
            keep_attrs (bool): preserve graph/node/egde_attr mappings
        """
        if not keep_attrs:
            for a in (self.graph_attr, self.node_attr, self.edge_attr):
                a.clear()
        del self.body[:]

    def __iter__(self, subgraph=False):
        """Yield the DOT source code line by line (as graph or subgraph)."""
        if self.comment:
            yield self._comment % self.comment

        if subgraph:
            if self.strict:
                raise ValueError('subgraphs cannot be strict')
            head = self._subgraph if self.name else self._subgraph_plain
        else:
            head = self._head_strict if self.strict else self._head
        yield head % (self._quote(self.name) + ' ' if self.name else '')

        for kw in ('graph', 'node', 'edge'):
            attrs = getattr(self, '%s_attr' % kw)
            if attrs:
                yield self._attr % (kw, self._attr_list(None, attrs))

        for line in self.body:
            yield line

        yield self._tail

    def __str__(self):
        """The DOT source code as string."""
        return '\n'.join(self)

    source = property(__str__, doc=__str__.__doc__)

    def node(self, name, label=None, _attributes=None, **attrs):
        """Create a node.

        Args:
            name: Unique identifier for the node inside the source.
            label: Caption to be displayed (defaults to the node ``name``).
            attrs: Any additional node attributes (must be strings).
        """
        name = self._quote(name)
        attr_list = self._attr_list(label, attrs, _attributes)
        line = self._node % (name, attr_list)
        self.body.append(line)

    def edge(self, tail_name, head_name, label=None, _attributes=None, **attrs):
        """Create an edge between two nodes.

        Args:
            tail_name: Start node identifier.
            head_name: End node identifier.
            label: Caption to be displayed near the edge.
            attrs: Any additional edge attributes (must be strings).
        """
        tail_name = self._quote_edge(tail_name)
        head_name = self._quote_edge(head_name)
        attr_list = self._attr_list(label, attrs, _attributes)
        line = self._edge % (tail_name, head_name, attr_list)
        self.body.append(line)

    def edges(self, tail_head_iter):
        """Create a bunch of edges.

        Args:
            tail_head_iter: Iterable of ``(tail_name, head_name)`` pairs.
        """
        edge = self._edge_plain
        quote = self._quote_edge
        lines = (edge % (quote(t), quote(h)) for t, h in tail_head_iter)
        self.body.extend(lines)

    def attr(self, kw=None, _attributes=None, **attrs):
        """Add a general or graph/node/edge attribute statement.

        Args:
            kw: Attributes target (``None`` or ``'graph'``, ``'node'``, ``'edge'``).
            attrs: Attributes to be set (must be strings, may be empty).

        See the :ref:`usage examples in the User Guide <attributes>`.
        """
        if kw is not None and kw.lower() not in ('graph', 'node', 'edge'):
            raise ValueError('attr statement must target graph, node, or edge: '
                '%r' % kw)
        if attrs or _attributes:
            if kw is None:
                a_list = self._a_list(None, attrs, _attributes)
                line = self._attr_plain % a_list
            else:
                attr_list = self._attr_list(None, attrs, _attributes)
                line = self._attr % (kw, attr_list)
            self.body.append(line)

    def subgraph(self, graph=None, name=None, comment=None,
                 graph_attr=None, node_attr=None, edge_attr=None, body=None):
        """Add the current content of the given sole ``graph`` argument as subgraph \
           or return a context manager returning a new graph instance created \
           with the given (``name``, ``comment``, etc.) arguments whose content is \
           added as subgraph when leaving the context manager's ``with``-block.

        Args:
            graph: An instance of the same kind (:class:`.Graph`, :class:`.Digraph`)
                   as the current graph (sole argument in non-with-block use).
            name: Subgraph name (``with``-block use).
            comment: Subgraph comment (``with``-block use).
            graph_attr: Subgraph-level attribute-value mapping (``with``-block use).
            node_attr: Node-level attribute-value mapping (``with``-block use).
            edge_attr: Edge-level attribute-value mapping (``with``-block use).
            body: Verbatim lines to add to the subgraph ``body`` (``with``-block use).

        See the :ref:`usage examples in the User Guide <subgraphs>`.

        .. note::
            If the ``name`` of the subgraph begins with ``'cluster'`` (all lowercase)
            the layout engine will treat it as a special cluster subgraph.
        """
        if graph is None:
            return SubgraphContext(self, {'name': name,
                                          'comment': comment,
                                          'graph_attr': graph_attr,
                                          'node_attr': node_attr,
                                          'edge_attr': edge_attr,
                                          'body': body})

        args = [name, comment, graph_attr, node_attr, edge_attr, body]
        if not all(a is None for a in args):
            raise ValueError('graph must be sole argument of subgraph()')

        if graph.directed != self.directed:
            raise ValueError('%r cannot add subgraph of different kind:'
                             ' %r' % (self, graph))

        lines = ['\t' + line for line in graph.__iter__(subgraph=True)]
        self.body.extend(lines)


class SubgraphContext(object):
    """Return a blank instance of the parent and add as subgraph on exit."""

    def __init__(self, parent, kwargs):
        self.parent = parent
        self.graph = parent.__class__(**kwargs)

    def __enter__(self):
        return self.graph

    def __exit__(self, type_, value, traceback):
        if type_ is None:
            self.parent.subgraph(self.graph)


class Graph(Dot):
    """Graph source code in the DOT language.

    Args:
        name: Graph name used in the source code.
        comment: Comment added to the first line of the source.
        filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``).
        directory: (Sub)directory for source saving and rendering.
        format: Rendering output format (``'pdf'``, ``'png'``, ...).
        engine: Layout command used (``'dot'``, ``'neato'``, ...).
        encoding: Encoding for saving the source.
        graph_attr: Mapping of ``(attribute, value)`` pairs for the graph.
        node_attr: Mapping of ``(attribute, value)`` pairs set for all nodes.
        edge_attr: Mapping of ``(attribute, value)`` pairs set for all edges.
        body: Iterable of verbatim lines to add to the graph ``body``.
        strict (bool): Rendering should merge multi-edges.

    Note:
        All parameters are optional and can be changed under their
        corresponding attribute name after instance creation.
    """

    _head = 'graph %s{'
    _head_strict = 'strict %s' % _head
    _edge = '\t%s -- %s%s'
    _edge_plain = _edge % ('%s', '%s', '')

    @property
    def directed(self):
        """``False``"""
        return False


class Digraph(Dot):
    """Directed graph source code in the DOT language."""

    if Graph.__doc__ is not None:
        __doc__ += Graph.__doc__.partition('.')[2]

    _head = 'digraph %s{'
    _head_strict = 'strict %s' % _head
    _edge = '\t%s -> %s%s'
    _edge_plain = _edge % ('%s', '%s', '')

    @property
    def directed(self):
        """``True``"""
        return True

```

`utils/graphviz/files.py`:

```py
# files.py - save, render, view

"""Save DOT code objects, render with Graphviz dot, and open in viewer."""

import os
import io
import codecs
import locale
import logging

from ._compat import text_type

from . import backend
from . import tools

__all__ = ['File', 'Source']

ENCODING = 'utf-8'


log = logging.getLogger(__name__)


class Base(object):

    _format = 'pdf'
    _engine = 'dot'
    _encoding = ENCODING

    @property
    def format(self):
        """The output format used for rendering (``'pdf'``, ``'png'``, ...)."""
        return self._format

    @format.setter
    def format(self, format):
        format = format.lower()
        if format not in backend.FORMATS:
            raise ValueError('unknown format: %r' % format)
        self._format = format

    @property
    def engine(self):
        """The layout commmand used for rendering (``'dot'``, ``'neato'``, ...)."""
        return self._engine

    @engine.setter
    def engine(self, engine):
        engine = engine.lower()
        if engine not in backend.ENGINES:
            raise ValueError('unknown engine: %r' % engine)
        self._engine = engine

    @property
    def encoding(self):
        """The encoding for the saved source file."""
        return self._encoding

    @encoding.setter
    def encoding(self, encoding):
        if encoding is None:
            encoding = locale.getpreferredencoding()
        codecs.lookup(encoding)  # raise early
        self._encoding = encoding

    def copy(self):
        """Return a copied instance of the object.

        Returns:
            An independent copy of the current object.
        """
        kwargs = self._kwargs()
        return self.__class__(**kwargs)

    def _kwargs(self):
        ns = self.__dict__
        return {a[1:]: ns[a] for a in ('_format', '_engine', '_encoding')
                if a in ns}


class File(Base):

    directory = ''

    _default_extension = 'gv'

    def __init__(self, filename=None, directory=None,
                 format=None, engine=None, encoding=ENCODING):
        if filename is None:
            name = getattr(self, 'name', None) or self.__class__.__name__
            filename = '%s.%s' % (name, self._default_extension)
        self.filename = filename

        if directory is not None:
            self.directory = directory

        if format is not None:
            self.format = format

        if engine is not None:
            self.engine = engine

        self.encoding = encoding

    def _kwargs(self):
        result = super(File, self)._kwargs()
        result['filename'] = self.filename
        if 'directory' in self.__dict__:
            result['directory'] = self.directory
        return result

    def _repr_svg_(self):
        return self.pipe(format='svg').decode(self._encoding)

    def pipe(self, format=None, renderer=None, formatter=None, quiet=False):
        """Return the source piped through the Graphviz layout command.

        Args:
            format: The output format used for rendering (``'pdf'``, ``'png'``, etc.).
            renderer: The output renderer used for rendering (``'cairo'``, ``'gd'``, ...).
            formatter: The output formatter used for rendering (``'cairo'``, ``'gd'``, ...).
            quiet (bool): Suppress ``stderr`` output from the layout subprocess.
        Returns:
            Binary (encoded) stdout of the layout command.
        Raises:
            ValueError: If ``format``, ``renderer``, or ``formatter`` are not known.
            graphviz.RequiredArgumentError: If ``formatter`` is given but ``renderer`` is None.
            graphviz.ExecutableNotFound: If the Graphviz executable is not found.
            subprocess.CalledProcessError: If the exit status is non-zero.
        """
        if format is None:
            format = self._format

        data = text_type(self.source).encode(self._encoding)

        out = backend.pipe(self._engine, format, data,
                           renderer=renderer, formatter=formatter,
                           quiet=quiet)

        return out

    @property
    def filepath(self):
        return os.path.join(self.directory, self.filename)

    def save(self, filename=None, directory=None):
        """Save the DOT source to file. Ensure the file ends with a newline.

        Args:
            filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)
            directory: (Sub)directory for source saving and rendering.
        Returns:
            The (possibly relative) path of the saved source file.
        """
        if filename is not None:
            self.filename = filename
        if directory is not None:
            self.directory = directory

        filepath = self.filepath
        tools.mkdirs(filepath)

        data = text_type(self.source)

        log.debug('write %d bytes to %r', len(data), filepath)
        with io.open(filepath, 'w', encoding=self.encoding) as fd:
            fd.write(data)
            if not data.endswith(u'\n'):
                fd.write(u'\n')

        return filepath

    def render(self, filename=None, directory=None, view=False, cleanup=False,
               format=None, renderer=None, formatter=None,
               quiet=False, quiet_view=False):
        """Save the source to file and render with the Graphviz engine.

        Args:
            filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)
            directory: (Sub)directory for source saving and rendering.
            view (bool): Open the rendered result with the default application.
            cleanup (bool): Delete the source file after rendering.
            format: The output format used for rendering (``'pdf'``, ``'png'``, etc.).
            renderer: The output renderer used for rendering (``'cairo'``, ``'gd'``, ...).
            formatter: The output formatter used for rendering (``'cairo'``, ``'gd'``, ...).
            quiet (bool): Suppress ``stderr`` output from the layout subprocess.
            quiet_view (bool): Suppress ``stderr`` output from the viewer process
                               (implies ``view=True``, ineffective on Windows).
        Returns:
            The (possibly relative) path of the rendered file.
        Raises:
            ValueError: If ``format``, ``renderer``, or ``formatter`` are not known.
            graphviz.RequiredArgumentError: If ``formatter`` is given but ``renderer`` is None.
            graphviz.ExecutableNotFound: If the Graphviz executable is not found.
            subprocess.CalledProcessError: If the exit status is non-zero.
            RuntimeError: If viewer opening is requested but not supported.

        The layout command is started from the directory of ``filepath``, so that
        references to external files (e.g. ``[image=...]``) can be given as paths
        relative to the DOT source file.
        """
        filepath = self.save(filename, directory)

        if format is None:
            format = self._format

        rendered = backend.render(self._engine, format, filepath,
                                  renderer=renderer, formatter=formatter,
                                  quiet=quiet)

        if cleanup:
            log.debug('delete %r', filepath)
            os.remove(filepath)

        if quiet_view or view:
            self._view(rendered, self._format, quiet_view)

        return rendered

    def view(self, filename=None, directory=None, cleanup=False,
             quiet=False, quiet_view=False):
        """Save the source to file, open the rendered result in a viewer.

        Args:
            filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)
            directory: (Sub)directory for source saving and rendering.
            cleanup (bool): Delete the source file after rendering.
            quiet (bool): Suppress ``stderr`` output from the layout subprocess.
            quiet_view (bool): Suppress ``stderr`` output from the viewer process
                               (ineffective on Windows).
        Returns:
            The (possibly relative) path of the rendered file.
        Raises:
            graphviz.ExecutableNotFound: If the Graphviz executable is not found.
            subprocess.CalledProcessError: If the exit status is non-zero.
            RuntimeError: If opening the viewer is not supported.

        Short-cut method for calling :meth:`.render` with ``view=True``.
        """
        return self.render(filename=filename, directory=directory,
                           view=True, cleanup=cleanup,
                           quiet=quiet, quiet_view=quiet_view)

    def _view(self, filepath, format, quiet):
        """Start the right viewer based on file format and platform."""
        methodnames = [
            '_view_%s_%s' % (format, backend.PLATFORM),
            '_view_%s' % backend.PLATFORM,
        ]
        for name in methodnames:
            view_method = getattr(self, name, None)
            if view_method is not None:
                break
        else:
            raise RuntimeError('%r has no built-in viewer support for %r'
                               ' on %r platform' % (self.__class__, format,
                                                    backend.PLATFORM))
        view_method(filepath, quiet)

    _view_darwin = staticmethod(backend.view.darwin)
    _view_freebsd = staticmethod(backend.view.freebsd)
    _view_linux = staticmethod(backend.view.linux)
    _view_windows = staticmethod(backend.view.windows)


class Source(File):
    """Verbatim DOT source code string to be rendered by Graphviz.

    Args:
        source: The verbatim DOT source code string.
        filename: Filename for saving the source (defaults to ``'Source.gv'``).
        directory: (Sub)directory for source saving and rendering.
        format: Rendering output format (``'pdf'``, ``'png'``, ...).
        engine: Layout command used (``'dot'``, ``'neato'``, ...).
        encoding: Encoding for saving the source.

    Note:
        All parameters except ``source`` are optional. All of them can be changed
        under their corresponding attribute name after instance creation.
    """

    @classmethod
    def from_file(cls, filename, directory=None,
                  format=None, engine=None, encoding=ENCODING):
        """Return an instance with the source string read from the given file.

        Args:
            filename: Filename for loading/saving the source.
            directory: (Sub)directory for source loading/saving and rendering.
            format: Rendering output format (``'pdf'``, ``'png'``, ...).
            engine: Layout command used (``'dot'``, ``'neato'``, ...).
            encoding: Encoding for loading/saving the source.
        """
        filepath = os.path.join(directory or '', filename)
        if encoding is None:
            encoding = locale.getpreferredencoding()
        log.debug('read %r with encoding %r', filepath, encoding)
        with io.open(filepath, encoding=encoding) as fd:
            source = fd.read()
        return cls(source, filename, directory, format, engine, encoding)

    def __init__(self, source, filename=None, directory=None,
                 format=None, engine=None, encoding=ENCODING):
        super(Source, self).__init__(filename, directory,
                                     format, engine, encoding)
        self.source = source  #: The verbatim DOT source code string.

    def _kwargs(self):
        result = super(Source, self)._kwargs()
        result['source'] = self.source
        return result

```

`utils/graphviz/lang.py`:

```py
# lang.py - dot language creation helpers

"""Quote strings to be valid DOT identifiers, assemble attribute lists."""

import re
import collections

from . import _compat

from . import tools

__all__ = ['quote', 'quote_edge', 'a_list', 'attr_list']

# http://www.graphviz.org/doc/info/lang.html

HTML_STRING = re.compile(r'<.*>$', re.DOTALL)

ID = re.compile(r'([a-zA-Z_][a-zA-Z0-9_]*|-?(\.\d+|\d+(\.\d*)?))$')

KEYWORDS = {'node', 'edge', 'graph', 'digraph', 'subgraph', 'strict'}

COMPASS = {'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw', 'c', '_'}  # TODO


def quote(identifier,
          html=HTML_STRING.match, valid_id=ID.match, dot_keywords=KEYWORDS):
    r"""Return DOT identifier from string, quote if needed.

    >>> quote('')
    '""'

    >>> quote('spam')
    'spam'

    >>> quote('spam spam')
    '"spam spam"'

    >>> quote('-4.2')
    '-4.2'

    >>> quote('.42')
    '.42'

    >>> quote('<<b>spam</b>>')
    '<<b>spam</b>>'

    >>> quote(nohtml('<>'))
    '"<>"'

    >>> print(quote('"'))
    "\""

    >>> print(quote('\\"'))
    "\\\""
    """
    if html(identifier) and not isinstance(identifier, NoHtml):
        pass
    elif not valid_id(identifier) or identifier.lower() in dot_keywords:
        return '"%s"' % identifier.replace('\\', '\\\\').replace('"', '\\"')
    return identifier


def quote_edge(identifier):
    """Return DOT edge statement node_id from string, quote if needed.

    >>> quote_edge('spam')
    'spam'

    >>> quote_edge('spam spam:eggs eggs')
    '"spam spam":"eggs eggs"'

    >>> quote_edge('spam:eggs:s')
    'spam:eggs:s'
    """
    node, _, rest = identifier.partition(':')
    parts = [quote(node)]
    if rest:
        port, _, compass = rest.partition(':')
        parts.append(quote(port))
        if compass:
            parts.append(compass)
    return ':'.join(parts)


def a_list(label=None, kwargs=None, attributes=None):
    """Return assembled DOT a_list string.

    >>> a_list('spam', {'spam': None, 'ham': 'ham ham', 'eggs': ''})
    'label=spam eggs="" ham="ham ham"'
    """
    result = ['label=%s' % quote(label)] if label is not None else []
    if kwargs:
        items = ['%s=%s' % (quote(k), quote(v))
                 for k, v in tools.mapping_items(kwargs) if v is not None]
        result.extend(items)
    if attributes:
        if hasattr(attributes, 'items'):
            attributes = tools.mapping_items(attributes)
        items = ['%s=%s' % (quote(k), quote(v))
                 for k, v in attributes if v is not None]
        result.extend(items)
    return ' '.join(result)


def attr_list(label=None, kwargs=None, attributes=None):
    """Return assembled DOT attribute list string.

    Sorts ``kwargs`` and ``attributes`` if they are plain dicts (to avoid
    unpredictable order from hash randomization in Python 3 versions).

    >>> attr_list()
    ''

    >>> attr_list('spam spam', kwargs={'eggs': 'eggs', 'ham': 'ham ham'})
    ' [label="spam spam" eggs=eggs ham="ham ham"]'

    >>> attr_list(kwargs={'spam': None, 'eggs': ''})
    ' [eggs=""]'
    """
    content = a_list(label, kwargs, attributes)
    if not content:
        return ''
    return ' [%s]' % content


class NoHtml(object):
    """Mixin for string subclasses disabling fall-through of ``'<...>'``."""

    __slots__ = ()

    _doc = "%s subclass that does not treat ``'<...>'`` as DOT HTML string."

    @classmethod
    def _subcls(cls, other):
        name = '%s_%s' % (cls.__name__, other.__name__)
        bases = (other, cls)
        ns = {'__doc__': cls._doc % other.__name__}
        return type(name, bases, ns)


NOHTML = collections.OrderedDict((c, NoHtml._subcls(c)) for c in _compat.string_classes)


def nohtml(s):
    """Return copy of ``s`` that will not treat ``'<...>'`` as DOT HTML string in quoting.

    Args:
        s: String in which leading ``'<'`` and trailing ``'>'`` should be treated as literal.
    Raises:
        TypeError: If ``s`` is not a ``str`` on Python 3, or a ``str``/``unicode`` on Python 2.

    >>> quote('<>-*-<>')
    '<>-*-<>'

    >>> quote(nohtml('<>-*-<>'))
    '"<>-*-<>"'
    """
    try:
        subcls = NOHTML[type(s)]
    except KeyError:
        raise TypeError('%r does not have one of the required types:'
                        ' %r' % (s, list(NOHTML)))
    return subcls(s)

```

`utils/graphviz/tools.py`:

```py
# tools.py - generic helpers

import os

from . import _compat

__all__ = ['attach', 'mkdirs', 'mapping_items']


def attach(object, name):
    """Return a decorator doing ``setattr(object, name)`` with its argument.

    >>> spam = type('Spam', (object,), {})()
    >>> @attach(spam, 'eggs')
    ... def func():
    ...     pass
    >>> spam.eggs  # doctest: +ELLIPSIS
    <function func at 0x...>
    """
    def decorator(func):
        setattr(object, name, func)
        return func
    return decorator


def mkdirs(filename, mode=0o777):
    """Recursively create directories up to the path of ``filename`` as needed."""
    dirname = os.path.dirname(filename)
    if not dirname:
        return
    _compat.makedirs(dirname, mode=mode, exist_ok=True)


def mapping_items(mapping):
    """Return an iterator over the ``mapping`` items, sort if it's a plain dict.

    >>> list(mapping_items({'spam': 0, 'ham': 1, 'eggs': 2}))
    [('eggs', 2), ('ham', 1), ('spam', 0)]

    >>> from collections import OrderedDict
    >>> list(mapping_items(OrderedDict(enumerate(['spam', 'ham', 'eggs']))))
    [(0, 'spam'), (1, 'ham'), (2, 'eggs')]
    """
    result = _compat.iteritems(mapping)
    if type(mapping) is dict:
        result = iter(sorted(result))
    return result

```

`utils/leafblower.py`:

```py
from . import utils

from ghidra.program.flatapi import FlatProgramAPI
from ghidra.program.model.symbol import RefType
from ghidra.program.model.block import BasicBlockModel


def get_argument_registers(current_program):
    """
    Get argument registers based on processor type.

    :param current_program: Ghidra program object.
    :type current_program: ghidra.program.model.listing.Program

    :returns: List of argument registers.
    :rtype: list(str)
    """
    arch = utils.get_processor(current_program)

    if arch == 'MIPS':
        return ['a0', 'a1', 'a2', 'a3']
    elif arch == 'ARM':
        return ['r0', 'r1', 'r2', 'r3']
    return []


class Function(object):
    CANDIDATES = {}

    def __init__(self, function, candidate_attr, has_loop=None,
                 argument_count=-1, format_arg_index=-1):

        self.name = function.getName()
        self.xref_count = function.getSymbol().getReferenceCount()
        self.has_loop = has_loop
        self.argument_count = argument_count
        self.format_arg_index = format_arg_index
        self.candidates = []
        if candidate_attr in self.CANDIDATES:
            self.candidates = self.CANDIDATES[candidate_attr]


class LeafFunction(Function):
    """
    Class to hold leaf function candidates.
    """

    CANDIDATES = {
        1: ['atoi', 'atol', 'strlen'],
        2: ['strcpy', 'strcat', 'strcmp', 'strstr', 'strchr', 'strrchr',
            'bzero'],
        3: ['strtol', 'strncpy', 'strncat', 'strncmp', 'memcpy', 'memmove',
            'bcopy', 'memcmp', 'memset']
    }

    def __init__(self, function, has_loop, argument_count):
        super(LeafFunction, self).__init__(
            function, argument_count, has_loop, argument_count)

    def to_list(self):
        return [self.name, str(self.xref_count), str(self.argument_count),
                ','.join(self.candidates)]

    @classmethod
    def is_candidate(cls, function, has_loop, argument_count):
        """
        Determine is a function is a candidate for a leaf function. Leaf 
        functions must have loops, make no external calls, require 1-3 
        arguments, and have a reference count greater than 25. 
        """
        if not has_loop:
            return False

        if argument_count > 3 or argument_count == 0:
            return False

        if function.getSymbol().getReferenceCount() < 25:
            return False

        return True


class FormatFunction(Function):
    """
    Class to hold format string function candidates.
    """

    CANDIDATES = {
        0: ['printf'],
        1: ['sprintf', 'fprintf', 'fscanf', 'sscanf'],
        2: ['snprintf']
    }

    def __init__(self, function, format_arg_index):
        super(FormatFunction, self).__init__(
            function, format_arg_index, format_arg_index=format_arg_index)

    def to_list(self):
        return [self.name, str(self.xref_count), str(self.format_arg_index),
                ','.join(self.candidates)]


class FinderBase(object):
    def __init__(self, program):
        self._program = program
        self._flat_api = FlatProgramAPI(program)
        self._monitor = self._flat_api.getMonitor()
        self._basic_blocks = BasicBlockModel(self._program)

    def _display(self, title, entries):
        """
        Print a simple table to the terminal.

        :param title: Title of the table.
        :type title: list

        :param entries: Entries to print in the table.
        :type entries: list(list(str))
        """
        lines = [title] + entries

        # Find the largest entry in each column so it can be used later
        # for the format string.
        max_line_len = []
        for i in range(0, len(title)):
            column_lengths = [len(line[i]) for line in lines]
            max_line_len.append(max(column_lengths))

        # Account for largest entry, spaces, and '|' characters on each line.
        separator = '=' * (sum(max_line_len) +
                           (len(title) * (len(title) - 1))
                           + 1)
        spacer = '|'
        format_specifier = '{:<{width}}'

        # First block prints the title and '=' characters to make a title
        # border
        print separator
        print spacer,
        for width, column in zip(max_line_len, title):
            print format_specifier.format(column, width=width),
            print spacer,
        print ''
        print separator

        # Print the actual entries.
        for entry in entries:
            print spacer,
            for width, column in zip(max_line_len, entry):
                print format_specifier.format(column, width=width),
                print spacer,
            print ''
        print separator


class LeafFunctionFinder(FinderBase):
    """
    Leaf function finder class. 
    """

    def __init__(self, program):
        super(LeafFunctionFinder, self).__init__(program)
        self.leaf_functions = []

    def find_leaves(self):
        """
        Find leaf functions. Leaf functions are functions that have loops,
        make no external calls, require 1-3 arguments, and have a reference 
        count greater than 25.
        """
        function_manager = self._program.getFunctionManager()

        for function in function_manager.getFunctions(True):
            if not self._function_makes_call(function):
                loops = self._function_has_loops(function)
                argc = self._get_argument_count(function)

                if LeafFunction.is_candidate(function, loops, argc):
                    self.leaf_functions.append(LeafFunction(function,
                                                            loops,
                                                            argc))

        self.leaf_functions.sort(key=lambda x: x.xref_count, reverse=True)

    def display(self):
        """
        Print leaf function candidates to the terminal.
        """
        title = ['Function', 'XRefs', 'Args', 'Potential Function']
        leaf_list = [leaf.to_list() for leaf in self.leaf_functions]

        self._display(title, leaf_list)

    def _function_makes_call(self, function):
        """
        Determine if a function makes external calls.

        :param function: Function to inspect.
        :type function: ghidra.program.model.listing.Function

        :returns: True if the function makes external calls, False otherwise.
        :rtype: bool
        """
        function_body = function.getBody()
        min_addr = function_body.minAddress
        max_addr = function_body.maxAddress

        curr_addr = min_addr
        while curr_addr <= max_addr:
            instruction = self._flat_api.getInstructionAt(curr_addr)
            if utils.is_call_instruction(instruction):
                return True
            curr_addr = curr_addr.next()
        return False

    def _function_has_loops(self, function):
        """
        Determine if a function has internal loops.

        :param function: Function to inspect.
        :type function: ghidra.program.model.listing.Function

        :returns: True if the function has loops, False otherwise.
        :rtype: bool
        """

        function_blocks = self._basic_blocks.getCodeBlocksContaining(
            function.body, self._monitor)

        while function_blocks.hasNext():
            block = function_blocks.next()
            destinations = block.getDestinations(self._monitor)

            # Determine if the current block can result in jumping to a block
            # above the end address and in the same function. This indicates
            # an internal loop.
            while destinations.hasNext():
                destination = destinations.next()
                dest_addr = destination.getDestinationAddress()
                destination_function = self._flat_api.getFunctionContaining(
                    dest_addr)
                if destination_function == function and \
                        dest_addr <= block.minAddress:
                    return True
        return False

    def _get_argument_count(self, function):
        """
        Determine the argument count to the function. This is determined by 
        inspecting argument registers to see if they are read from prior to 
        being written to.

        :param function: Function to inspect.
        :type function: ghidra.program.model.listing.Function

        :returns: Argument count.
        :rtype: int
        """
        used_args = []
        arch_args = get_argument_registers(self._program)

        min_addr = function.body.minAddress
        max_addr = function.body.maxAddress

        curr_ins = self._flat_api.getInstructionAt(min_addr)

        while curr_ins and curr_ins.getAddress() < max_addr:
            for op_index in range(0, curr_ins.getNumOperands()):
                ref_type = curr_ins.getOperandRefType(op_index)
                # We only care about looking at reads and writes. Reads that
                # include and index into a register show as 'data' so look
                # for those as well.
                if ref_type not in [RefType.WRITE, RefType.READ, RefType.DATA]:
                    continue

                # Check to see if the argument is an argument register. Remove
                # that register from the arch_args list so it can be ignored
                # from now on. If reading from the register add it to the
                # used_args list so we know its a used parameter.
                operands = curr_ins.getOpObjects(op_index)
                for operand in operands:
                    op_string = operand.toString()
                    if op_string in arch_args:
                        arch_args.remove(op_string)
                        if ref_type in [RefType.READ, RefType.DATA]:
                            used_args.append(op_string)
            curr_ins = curr_ins.next

        return len(used_args)


class FormatStringFunctionFinder(FinderBase):
    def __init__(self, program):
        super(FormatStringFunctionFinder, self).__init__(program)
        self._memory_map = self._program.getMemory()
        self.format_strings = self._find_format_strings()
        self.format_functions = []

    def _find_format_strings(self):
        """
        Find strings that contain format parameters.

        :returns: List of addresses that represent format string parameters.
        :rtype: list(ghidra.program.model.listing.Address
        """
        format_strings = []
        memory = self._memory_map.getAllInitializedAddressSet()
        strings = self._flat_api.findStrings(memory, 2, 1, True, True)

        for string in strings:
            curr_string = string.getString(self._memory_map)
            if '%' in curr_string:
                format_strings.append(string.getAddress())
        return format_strings

    def _find_function_by_instruction(self, instruction):
        """
        Find function associated with the instruction provided. Used to find
        function calls associated with parameters. Only searches in the 
        code block of the provided instruction.

        :param instruction: Instruction to begin search from.
        :type instruction: ghidra.program.model.listing.Instruction

        :returns: Function if found, None otherwise.
        :rtype: ghidra.program.model.listing.Function
        """
        containing_block = self._basic_blocks.getCodeBlocksContaining(
            instruction.getAddress(), self._monitor)[0]

        # Check if the current instruction is in the delay slot, back up one
        # instruction if true in case its a call.
        if instruction.isInDelaySlot():
            curr_ins = instruction.previous
        else:
            curr_ins = instruction

        while curr_ins and curr_ins.getAddress() < containing_block.maxAddress:
            if utils.is_call_instruction(curr_ins):
                function_flow = curr_ins.getFlows()
                if function_flow:
                    # The call instruction should only have one flow so
                    # grabbing the first flow is fine.
                    return self._flat_api.getFunctionAt(function_flow[0])
            curr_ins = curr_ins.next

        return None

    def display(self):
        """
        Print format function candidates to the terminal.
        """
        title = ['Function', 'XRefs', 'Fmt Index', 'Potential Function']
        format_list = [format.to_list() for format in self.format_functions]

        self._display(title, format_list)

    def find_functions(self):
        """
        Find functions that take format strings as an argument.
        """
        processed_functions = []
        registers = get_argument_registers(self._program)

        for string in self.format_strings:
            references = self._flat_api.getReferencesTo(string)
            for reference in references:
                if not reference.getReferenceType() == RefType.PARAM:
                    continue

                # Get the instruction that references the format string.
                instruction = self._flat_api.getInstructionAt(
                    reference.fromAddress)

                function = self._find_function_by_instruction(instruction)
                if not function:
                    continue

                function_name = function.getName()

                if function_name in processed_functions:
                    continue

                register_used = instruction.getOpObjects(
                    reference.getOperandIndex())
                register_index = registers.index(register_used[0].toString())

                self.format_functions.append(FormatFunction(function,
                                                            register_index))

                processed_functions.append(function_name)

        # Sort the functions by cross reference count
        self.format_functions.sort(key=lambda fmt_fn: fmt_fn.xref_count,
                                   reverse=True)

```

`utils/mipsrop.py`:

```py
import re
from ghidra.program.flatapi import FlatProgramAPI


format_string = '| {:12} | {:12} | {:30} | {:12} | {:30} |'
format_double_string = '| {:12} | {:30} | {:12} | {:30} | {:12} | {:30} | {:12} | {:30} |'
summary_format = '| {:15} | {:14} | {:30} |'


class MipsInstruction(object):
    """
    Class to represent a MIPS Instruction.
    """

    def __init__(self, mnem, op1=None, op2=None, op3=None):
        self.mnem = mnem
        self.op1 = op1
        self.op2 = op2
        self.op3 = op3


class MipsRop(object):
    def __init__(self, program):
        self._flat_api = FlatProgramAPI(program)
        self._currentProgram = program
        self.controllable_calls = []
        self.controllable_terminating_calls = []
        self._find_controllable_calls()

    def find_instructions(self, instructions, preserve_register=None,
                          controllable_calls=True, terminating_calls=True,
                          overwrite_register=None):
        """
        Search for gadgets that contain user defined instructions.

        :param instructions: List of instructions to search for.
        :type instructions: list(MipsInstruction)

        :param preserve_register: Registers to preserve.
        :type preserve_register: str

        :param controllable_calls: Search within controllable jumps.
        :type controllable_calls: bool

        :param terminating_calls: Search within controllable function epilogues.
        :type terminating_calls: bool

        :param overwrite_register: Register to ensure is overwritten.
        :type overwrite_register: str or list(str)

        :returns: List of rop gadgets that contain the provided instructions.
        :rtype: list(RopGadgets)
        """
        gadgets = RopGadgets()

        search_calls = []
        if controllable_calls:
            search_calls.extend(self.controllable_calls)
        if terminating_calls:
            search_calls.extend(self.controllable_terminating_calls)

        for call in search_calls:
            rop = self._find_instruction(
                call, instructions, preserve_register, overwrite_register)
            if rop:
                gadgets.append(RopGadget(rop, call))

        return gadgets

    def find_doubles(self):
        """
        Find double jumps.

        :returns: List of double jump gadgets.
        :rtype: DoubleGadgets
        """
        controllable = self.controllable_calls + \
            self.controllable_terminating_calls

        gadgets = DoubleGadgets()
        for i, call in enumerate(controllable):
            for j in range(i + 1, len(controllable)):
                second_call = controllable[j]
                second_call_addr = second_call.control_instruction.getAddress()
                distance = second_call_addr.subtract(call.call.getAddress())

                # Search for a distance of no more than 25 instructions.
                if 0 < distance <= 100:
                    # If the jumps are in different functions do not return
                    # them
                    func1 = self._flat_api.getFunctionContaining(
                        second_call.call.getAddress())
                    func2 = self._flat_api.getFunctionContaining(
                        call.call.getAddress())
                    if func1 != func2:
                        continue

                    if call.get_source_register() == \
                            second_call.get_source_register():
                        continue

                    if call in self.controllable_terminating_calls and \
                            second_call in self.controllable_terminating_calls:
                        continue

                    if not self._contains_bad_calls(call, second_call):
                        gadgets.append(DoubleGadget(call, second_call))

        return gadgets

    def summary(self):
        """
        Search for book marks that start with 'rop' and print a summary of the 
        ROP gadgets. Case of 'rop' is not important. 
        """
        bookmark_manager = self._currentProgram.getBookmarkManager()
        bookmarks = bookmark_manager.getBookmarksIterator()

        saved_bookmarks = []

        for bookmark in bookmarks:
            comment = bookmark.getComment().lower()
            if comment.startswith('rop'):
                for saved in saved_bookmarks:
                    if saved.getComment().lower() == comment:
                        print 'Duplicate bookmark found: {} at {} and {}'.format(
                            comment, saved.getAddress(), bookmark.getAddress())
                        return
                saved_bookmarks.append(bookmark)

        saved_bookmarks = sorted(saved_bookmarks,
                                 key=lambda x: x.comment.lower())

        rop_gadgets = RopGadgets()

        # Go through each bookmark, find the closest controllable jump, and
        # create a gadget.
        for bookmark in saved_bookmarks:
            closest_jmp = self._find_closest_controllable_jump(
                bookmark.getAddress())

            if bookmark.getComment().lower().endswith('_d'):
                next_closest = self._find_closest_controllable_jump(
                    closest_jmp.call.getAddress())
                if closest_jmp and next_closest:
                    # Hack to change the "control" instruction in case the
                    # bookmark was placed at a different location.
                    updated_ctrl = self._flat_api.getInstructionAt(
                        bookmark.getAddress())
                    closest_jmp.control_instruction = updated_ctrl

                    rop_gadgets.append(DoubleGadget(closest_jmp, next_closest,
                                                    bookmark.getComment()))
            elif closest_jmp:
                curr_addr = bookmark.getAddress()
                curr_ins = self._flat_api.getInstructionAt(curr_addr)
                rop_gadgets.append(RopGadget(curr_ins, closest_jmp,
                                             bookmark.getComment()))
        rop_gadgets.print_summary()

    def _find_closest_controllable_jump(self, address):
        """
        Find closest controllable jump to the address provided.

        :param address: Address to find closest jump to.
        :type address: ghidra.program.model.address.Address

        :returns: Closest controllable jump, if it exists.
        :rtype: ControllableCall or None
        """
        controllable = self.controllable_calls + \
            self.controllable_terminating_calls

        function = self._flat_api.getFunctionContaining(address)

        closest = None

        for jump in controllable[1:]:
            jump_function = self._flat_api.getFunctionContaining(
                jump.call.getAddress())
            if function != jump_function:
                continue

            if address > jump.control_instruction.getAddress():
                continue

            # If the address is a jump do not consider it for the closest jump.
            if jump.call.getAddress() == address:
                continue

            if not closest or \
                    jump.control_instruction.getAddress() <= \
                    address <= jump.call.getAddress():
                closest = jump
            else:
                control_addr = jump.control_instruction.getAddress()
                closest_distances = closest.control_instruction.getAddress()
                if control_addr.subtract(closest_distances) > \
                        control_addr.subtract(address):
                    closest = jump
        return closest

    def _find_controllable_calls(self):
        """
        Find calls that can be controlled through saved registers.
        """
        program_base = self._currentProgram.getImageBase()

        code_manager = self._currentProgram.getCodeManager()
        instructions = code_manager.getInstructions(program_base, True)

        # Loop through each instruction in the current program.
        for ins in instructions:
            flow_type = ins.getFlowType()

            # jalr t9 and some jr t9 are isCall()
            # jr ra is isTerminal()
            # some jr t9 are isJump() && isComputed().
            if flow_type.isCall() or flow_type.isTerminal() or \
                    (flow_type.isJump() and flow_type.isComputed()):
                current_instruction = self._flat_api.getInstructionAt(
                    ins.getAddress())
                controllable = self._find_controllable_call(
                    current_instruction)

                # Sort the controllable jump by type. Makes finding indirect
                # function calls easier.
                if controllable:
                    if flow_type.isCall() and not flow_type.isTerminal():
                        self.controllable_calls.append(controllable)
                    elif flow_type.isTerminal() or \
                            (flow_type.isJump() and flow_type.isComputed()):
                        self.controllable_terminating_calls.append(
                            controllable)

    def _find_controllable_call(self, call_instruction):
        """
        Search for how the jump register is set. If it comes from a potentially
        controllable register then return it.

        :param call_instruction: Instruction that contains a call.
        :type instruction: ghidra.program.mdel.listing.Instruction

        :returns: Controllable call object if controllable, None if not.
        :rtype: ControllableCall or None
        """
        t9_move = MipsInstruction('.*move', 't9', '[sva][012345678]')
        ra_load = MipsInstruction('.*lw', 'ra')

        call_from = call_instruction.getOpObjects(0)[0]

        # No need to check the delay slot so start working back up.
        controllable = None
        previous_ins = self._get_previous_instruction(call_instruction)

        while previous_ins:
            # NOPs are handled weirdly, they have no "flow" so just skip it.
            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            first_op = previous_ins.getOpObjects(0)
            if len(first_op):
                dest_reg = first_op[0]
                if str(dest_reg) == str(call_from):
                    if instruction_matches(previous_ins,
                                           [t9_move, ra_load]):
                        return ControllableCall(call_instruction, previous_ins)
                    return None

            previous_ins = self._get_previous_instruction(previous_ins)

    def _get_previous_instruction(self, instruction):
        """
        Get the previous instruction. Check the "flow" first, if not found
        just return the previous memory instruction.

        :param instruction: Instruction to retrieve previous instruction from.
        :type instruction: ghidra.program.model.listing.Instruction
        """
        fall_from = instruction.getFallFrom()
        if fall_from is None:
            previous_ins = instruction.getPrevious()
        else:
            previous_ins = self._flat_api.getInstructionAt(fall_from)

        return previous_ins

    def _find_instruction(self, controllable_call, search_instructions,
                          preserve_reg=None, overwrite_reg=None):
        """
        Search for an instruction within a controllable call. 

        :param controllable_call: Controllable call to search within.
        :type controllable_call: ControllableCall

        :param search_instructions: Instruction list to search for.
        :type search_instructions: list(MipsInstruction)

        :param preserve_reg: Register to preserve, if overwritten the 
                             instruction will not be returned.
        :type preserve_reg: str

        :param overwrite_reg: Enforce a register was overwritten.
        :type overwrite_reg: str or list(str)

        :returns: The matching instruction if found, None otherwise.
        :rtype: ghidra.program.model.listing.Instruction
        """
        registers_to_overwrite = overwrite_reg[:] if overwrite_reg else []

        delay_slot = controllable_call.call.getNext()
        if instruction_matches(delay_slot, search_instructions):
            return delay_slot

        if preserve_reg and \
                register_overwritten(delay_slot, preserve_reg):
            return None

        previous_ins = self._get_previous_instruction(controllable_call.call)

        while previous_ins:
            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            if instruction_matches(previous_ins, search_instructions):
                if overwrite_reg and registers_to_overwrite:
                    return None
                return previous_ins

            if preserve_reg and \
                    register_overwritten(previous_ins, preserve_reg):
                return None

            if overwrite_reg:
                overwritten = register_overwritten(previous_ins,
                                                   overwrite_reg)
                if overwritten:
                    try:
                        registers_to_overwrite.remove(overwritten)
                    except ValueError:  # Don't care if it's not in the list
                        pass

            # TODO: Need to see if we passed the point of caring.
            # Commented out b/c it kills IRETs. Investigate more later.
#            if register_overwritten(previous_ins,
#                                    controllable_call.get_source_register()):
#                return None

            if is_jump(previous_ins):
                return check_delay_slot(previous_ins, search_instructions)

            previous_ins = self._get_previous_instruction(previous_ins)

        return None

    def _contains_bad_calls(self, first, second):
        """
        Search for bad calls between two controllable jumps.

        :param first: Controllable call that comes first in memory.
        :type first: ControllableCall

        :param second: Controllable call that comes second in memory.
        :type second ControllableCall

        :returns: True if bad calls are found, False otherwise.
        :rtype: bool
        """
        jump = MipsInstruction('j.*')
        branch = MipsInstruction('b.*')

        preserve_reg = str(second.control_instruction.getOpObjects(1)[-1])
        end_ins = first.call

        previous_ins = self._get_previous_instruction(
            second.control_instruction)

        while previous_ins.getAddress() > end_ins.getAddress():
            if 'nop' in str(previous_ins):
                previous_ins = previous_ins.getPrevious()

            if instruction_matches(previous_ins, [jump, branch]):
                return True

            if register_overwritten(previous_ins, preserve_reg):
                return True

            previous_ins = self._get_previous_instruction(previous_ins)

        return False


class ControllableCall(object):
    """
    Class to store controllable calls and the instruction that controls it.
    """

    def __init__(self, instruction, control_instruction):
        self.call = instruction
        self.control_instruction = control_instruction

    def get_source_register(self):
        """
        Get the controlling source register.
        """
        try:
            return str(self.control_instruction.getOpObjects(1)[-1])
        except:
            return None

    def get_control_item(self):
        """
        Get string source of the control item. 
        """
        return self.control_instruction.getDefaultOperandRepresentation(1)

    def control_jump(self):
        """
        Return string representing the jump. Instead of 'jalr t9' it might 
        return 'jalr s4' to represent the controlling register.
        """
        return '{:10} {}'.format(self.call.getMnemonicString(),
                                 self.get_control_item())

    def __str__(self):
        return '{} {} -> {} {}'.format(self.control_instruction.getAddress(),
                                       self.control_instruction,
                                       self.call.getAddress(),
                                       self.call)


class RopGadget(object):
    """
    Class to represent discovered gadgets.
    """

    def __init__(self, action, jump, name=None):
        self.action = action
        self.jump = jump
        self.name = name
        self.instructions = []

    def __str__(self):
        control_addr = self.jump.control_instruction.getAddress()
        action_addr = self.action.getAddress()

        start = self.jump.control_instruction \
            if control_addr < action_addr else self.action

        return format_string.format(start.getAddress(),
                                    self.action.getAddress(),
                                    self.action,
                                    self.jump.call.getAddress(),
                                    self.jump.control_jump())

    def __len__(self):
        return len(self.get_instructions())

    def get_action_destination_register(self):
        """
        Get the action destination register.

        :returns: Destination register as a list of strings.
        :rtype: list(str)
        """
        try:
            return [str(self.action.getOpObjects(0)[0])]
        except:
            return []

    def get_action_source_register(self):
        """
        Get the action source register.

        :returns: Source register as a list of strings.
        :rtype: list(str)
        """
        try:
            return [str(self.action.getOpObjects(1)[0])]
        except:
            return []

    def print_instructions(self):
        """
        Print instructions in the register.
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            print '%s : %s' % (instruction.getAddress(), instruction)

    def overwrites_register(self, register):
        """
        Determine if the gadget overwrites a register.

        :param register: Register to check.
        :type register: str 

        :returns: True if register is overwritten, False otherwise.
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            if register_overwritten(instruction, register):
                return True
        return False

    def get_instructions(self):
        """
        Get a list of instructions between the first instruction in the rop
        and the call.
        """
        if self.instructions:
            return self.instructions

        # Find the higher call, the action or the control instruction.
        start_ins = self.action if self.action.getAddress() \
            < self.jump.control_instruction.getAddress() else \
            self.jump.control_instruction

        self.instructions.append(start_ins)
        curr_ins = start_ins
        while curr_ins.getAddress() <= self.jump.call.getAddress():
            curr_ins = curr_ins.getNext()
            self.instructions.append(curr_ins)

        return self.instructions


class RopGadgets(object):
    """
    Class to contain discovered gadgets.
    """

    def __init__(self):
        self.gadgets = []

    def append(self, gadget):
        """
        Add a gadget to the list.
        """
        self.gadgets.append(gadget)

    def pretty_print(self):
        """
        Print the gadgets in a nice table.
        """
        if len(self.gadgets):
            line_len = len(str(self.gadgets[0]))
            print '-' * line_len
            print format_string.format(
                'Gadget Start', 'Action Addr', 'Action', 'Jump Addr', 'Jump')
            print '-' * line_len
            for gadget in self.gadgets:
                print gadget
            print '-' * line_len
        print 'Found {} matching gadgets.\n'.format(len(self.gadgets))

    def print_summary(self):
        """
        Print ROP chain summary.
        """
        if len(self.gadgets):
            title = summary_format.format(
                'Gadget Name', 'Gadget Offset', 'Summary')
            line_len = len(title)
            print '-' * line_len
            print title
            print '-' * line_len
            for gadget in self.gadgets:
                instructions = gadget.get_instructions()
                print summary_format.format(gadget.name,
                                            instructions[0].getAddress(),
                                            instructions[0])
                for instruction in instructions[1:]:
                    print summary_format.format('', '', instruction)
                print '-' * line_len
        else:
            print 'No bookmarks with "rop" found.'


class DoubleGadget(object):
    """
    Class to contain double jump gadget.
    """

    def __init__(self, first, second, name=None):
        self.first = first
        self.second = second
        self.name = name
        self.instructions = []

    def __str__(self):
        return format_double_string.format(
            self.first.control_instruction.getAddress(),
            self.first.control_instruction,
            self.first.call.getAddress(), self.first.control_jump(),
            self.second.control_instruction.getAddress(),
            self.second.control_instruction,
            self.second.call.getAddress(),
            self.second.control_jump())

    def __len__(self):
        return len(self.get_instructions())

    def print_instructions(self):
        """
        Print instructions in the gadget.
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            print '%s : %s' % (instruction.getAddress(), instruction)

    def overwrites_register(self, register):
        """
        Determine if a register is overwritten in the gadget.

        :returns True if the register is overwritten, False otherwise.
        :rtype: bool
        """
        instruction_list = self.get_instructions()
        for instruction in instruction_list:
            if register_overwritten(instruction, register):
                return True
        return False

    def get_instructions(self):
        """
        Get a list of instructions between the first instruction in the rop
        and the call.
        """
        if self.instructions:
            return self.instructions

        # Find the higher call, the action or the control instruction.
        start_ins = self.first.control_instruction if self.first.control_instruction.getAddress() \
            < self.first.call.getAddress() else self.first.call

        self.instructions.append(start_ins)
        curr_ins = start_ins
        while curr_ins.getAddress() <= self.second.call.getAddress():
            curr_ins = curr_ins.getNext()
            self.instructions.append(curr_ins)

        return self.instructions

    def get_action_destination_register(self):
        """
        Get the action destination register.

        :returns: Destination register as a list of strings.
        :rtype: list(str)
        """
        dest = []
        try:
            dest.append(str(self.first.control_instruction.getOpObjects(0)[0]))
            dest.append(
                str(self.second.control_instruction.getOpObjects(0)[0]))
        except:
            return []
        return dest

    def get_action_source_register(self):
        """
        Get the action source register.

        :returns: Source registers as a list of strings.
        :rtype: list(str)
        """
        src = []
        try:
            src.append(str(self.first.control_instruction.getOpObjects(1)[0]))
            src.append(str(self.second.control_instruction.getOpObjects(1)[0]))
        except:
            return []
        return src


class DoubleGadgets(RopGadgets):
    """
    Class to contain double jump gadget.
    """

    def __init__(self):
        self.gadgets = []
        super(DoubleGadgets, self).__init__()

    def pretty_print(self):
        """
        Print gadgets in a nice table.
        """
        if len(self.gadgets):
            line_len = len(str(self.gadgets[0]))
            print '-' * line_len
            print format_double_string.format(
                'Gadget Start', '1st Action', 'Address', '1st Jump', 'Address',
                '2nd Action', 'Address', '2nd Jump')
            print '-' * line_len
            for gadget in self.gadgets:
                print gadget
            print '-' * line_len
        print 'Found {} matching gadgets.\n'.format(len(self.gadgets))


def instruction_matches(ins, matches):
    """
    Does instruction match any from a list of given instructions.

    :param ins: Instruction to compare.
    :type ins: ghidra.program.model.listing.Instruction

    :param matches: List of instructions to compare against. Regex supported.
    :type matches: list(MipsInstruction)

    :returns: True if an instruction match was found, False otherwise.
    :rtype: bool
    """
    for match in matches:
        if not re.match(match.mnem, ins.getMnemonicString()):
            continue
        try:
            if match.op1 and \
                    not re.match(match.op1, str(ins.getOpObjects(0)[0])):
                continue

            if match.op2 and \
                    not re.match(match.op2, str(ins.getOpObjects(1)[0])):
                continue

            if match.op3 and \
                    not re.match(match.op3, str(ins.getOpObjects(2)[0])):
                continue
            return True
        except IndexError:
            continue
        return False


def register_overwritten(ins, registers):
    """
    Check if a register is overwritten in an instruction.

    :param ins: Instruction to inspect.
    :type ins: ghidra.program.model.listing.Instruction

    :param registers: Register or list of registers to search for.
    :type registers: str or list(str)

    :returns: Register that is overwritten or None
    :rtype: str or None
    """
    if not isinstance(registers, list):
        registers = [registers]

    index = 0
    if 'sw' in str(ins):
        index = 1
    objects = ins.getOpObjects(index)
    if objects:
        for register in registers:
            if str(objects[0]) == register:
                return register
    return None


def get_overwritten_register(ins):
    """
    Return registers overwritten in the instruction.

    :param ins: Instruction to search 
    :type ins: ghidra.program.model.listing.Instruction

    :returns: Overwritten register or None.
    :rtype: str or None
    """
    index = 0
    if 'sw' in str(ins):
        index = 1
    objects = ins.getOpObjects(index)
    if objects:
        return str(objects[index])
    return None


def is_jump(ins):
    """
    Is instruction a jump (or call).

    :param ins: Instruction to inspect.
    :type ins: ghidra.program.model.listing.Instruction

    :returns: True if instruction is a jump, False otherwise.
    """
    flow = ins.getFlowType()
    return flow.isCall() or flow.isJump() or flow.isTerminal()


def check_delay_slot(ins, matches):
    """
    Check delay slot of an instruction that matches the provided instructions. 

    :param ins: Instruction to inspect delay slot for.
    :type ins: ghidra.program.model.listing

    :param matches: List of instructions to search.
    :ins matches: list(MipsInstruction)
    """
    next_ins = ins.getNext()
    if instruction_matches(next_ins, matches):
        return next_ins
    return None

```

`utils/mipsropchain.py`:

```py
from . import mipsrop, utils
import time

REGISTERS = ['s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8']


def update_available_registers(registers, gadget):
    """
    Update available registers list based on what gadget does.

    :param registers: List of currently controlled registers.
    :type registers: list(str)

    :param gadget: Current gadget.
    :type gadget: GadgetChain

    :returns: New list of available registers.
    :rtype: list(str)
    """
    new_registers = registers[:]

    try:
        for jump in gadget.jump_register:
            if 'sp' not in jump:
                new_registers.remove(jump)
    except ValueError:
        return []

    for reg in gadget.overwritten:
        try:
            new_registers.remove(reg)
        except ValueError:
            pass

    for reg in gadget.control_gained:
        if reg not in registers:
            new_registers.append(reg)
    return new_registers


def get_chain_length(chain):
    """
    Get instruction length of a chain.

    :param chain: Gadget chain.
    :type chain: list(GadgetLinks)
    """
    return sum(map(len, chain))


def default_gadget_search(link, controlled_registers, current_chain):
    """
    Default search for finding gadgets in a chain. Chooses based on jump
    being controlled by registers that are controlled.
    """
    for jump in link.jump_register:
        if 'sp' in jump:
            continue

        if jump not in controlled_registers:
            return False
    return True


class ChainLink(object):
    def __init__(self, name, gadget, control_gadget=None):
        self.name = name
        self._gadget = gadget
        self._control_gadget = control_gadget
        self.chain = []
        self.control_gained = {}
        self.overwritten = {}
        self.jump_register = {}
        self.action_register = {}

        # Double jumps need to be handled different from single jump gadgets.
        if isinstance(gadget, mipsrop.DoubleGadget):
            # Ignoring control gadgets for double jumps. Makes everything
            # more complicated. Might come back to this.
            if control_gadget:
                pass
            else:
                jump_one = gadget.first.get_source_register()
                jump_two = gadget.second.get_source_register()
                action_one = gadget.first.get_source_register()
                action_two = gadget.second.get_source_register()

                self.jump_register[jump_one] = \
                    gadget.first.call.getAddress()
                self.jump_register[jump_two] = \
                    gadget.second.call.getAddress()
                self.action_register[action_one] = \
                    gadget.first.control_instruction.getAddress()
                self.action_register[action_two] = \
                    gadget.second.control_instruction.getAddress()
        else:
            if control_gadget:
                control_reg = control_gadget.get_action_source_register()[0]
                action_reg = gadget.get_action_destination_register()[0]
                control_jump = control_gadget.get_action_source_register()[0]
                gadget_jump = control_gadget.jump.get_control_item()

                self.action_register[control_reg] = \
                    control_gadget.action.getAddress()

                self.action_register[action_reg] = gadget.action.getAddress()

                self.jump_register[control_jump] = \
                    control_gadget.action.getAddress()

                self.jump_register[gadget_jump] = \
                    control_gadget.jump.control_instruction.getAddress()

                self.chain.append(control_gadget)
            else:
                gadget_jump = gadget.jump.get_control_item()
                action = gadget.get_action_source_register()[0]
                self.jump_register[gadget_jump] = \
                    gadget.jump.control_instruction.getAddress()
                self.action_register[action] = gadget.action.getAddress()

        self.chain.append(gadget)
        self._get_registers_overwritten(gadget)
        self._validate_jumps()

    def __len__(self):
        length = len(self._gadget)
        if self._control_gadget:
            length += len(self._control_gadget)
        return length

    def __eq__(self, gadget):
        if type(gadget._gadget) is not type(self._gadget):
            return False
        elif isinstance(self._gadget, mipsrop.DoubleGadget):
            pass
        else:
            return self._gadget.action.getAddress() == gadget._gadget.action.getAddress()

    def _validate_jumps(self):
        """
        Validate the gadget doesn't overwrite registers it needs to jump.

        :raises: ValueError if gadget is invalid.
        """
        for register in self.overwritten.keys():
            if register in self.jump_register.keys():
                for overwritten in self.overwritten[register]:
                    if self.jump_register > overwritten:
                        raise ValueError

            # Make sure the action isn't overwritten in the gadget.
            action_dest = self.get_action_destination()
            if register in action_dest:
                for overwritten in self.overwritten[register]:
                    action_addr = self.action_register.values()
                    for addr in action_addr:
                        if addr != overwritten:
                            raise ValueError

    def _get_registers_overwritten(self, gadget):
        """
        Record registers that are overwritten and which ones are controlled.
        """
        instructions = gadget.get_instructions()
        for instruction in instructions:
            reg = mipsrop.get_overwritten_register(instruction)
            if reg and reg in REGISTERS + ['a0', 'a1', 'a2', 'a3', 'sp', 'v0', 'v1']:
                address = instruction.getAddress()
                if reg not in self.overwritten:
                    self.overwritten[reg] = [address]
                else:
                    self.overwritten[reg].append(address)
                if reg in self.control_gained:
                    self.control_gained.pop(reg)
                if 'lw' in str(instruction) and 'sp' in str(instruction):
                    self.control_gained[reg] = instruction.getAddress()

    def get_action_destination(self):
        """
        Return the gadgets action destination register. Uses the gadget and not
        the control gadget because the whole purpose of the control gadget is 
        calling the actual gadget.

        :returns: Action destination register. 
        """
        return self._gadget.get_action_destination_register()

    def get_action_source(self):
        """
        Get the action source register.
        """
        if self._control_gadget:
            return self._control_gadget.get_action_source_register()
        return self._gadget.get_action_source_register()

    def print_gadget(self, extended=False):
        """
        Print the gadget
        """
        title = self.name
        if self._control_gadget:
            title += ' (Control Gadget Required)'
            print title
            print '-' * len(title)
            print 'Control Gadget:'
            self._control_gadget.print_instructions()
            print '\n'
            print 'Gadget:'
        else:
            print title
            print '-' * len(title)

        self._gadget.print_instructions()
        if extended:
            print '\nControl Gained\n-------------'
            print self.control_gained
            print '\nOvewritten Registers\n-----------'
            print self.overwritten
            print '\nJump Register\n-------------'
            print self.jump_register
            print '\nAction Source\n-------------'
            print self.action_register
            try:
                print '\nAction Destination\n-------------'
                print self.get_action_destination()
            except:
                pass
        print '\n'


class GadgetLinks(object):
    def __init__(self, name, rop_finder, gadgets, check_control=True,
                 find_fn=default_gadget_search):
        self.name = name
        self._rop_finder = rop_finder
        self._links = gadgets
        self._find_fn = find_fn
        self.chains = []

        for gadget in self._links:
            try:
                gadget_chain = ChainLink(name, gadget)
            except ValueError:
                continue

            jump_reg = gadget_chain.jump_register.keys()[0]
            if not isinstance(gadget, mipsrop.DoubleGadget) and \
                    check_control and jump_reg not in REGISTERS and \
                    'sp' not in jump_reg:
                control_links = self._find_control_jump(jump_reg[0])
                for control in control_links:
                    try:
                        gadget_chain = ChainLink(name, gadget, control)
                        self.chains.append(gadget_chain)
                    except ValueError:
                        continue
            else:
                self.chains.append(gadget_chain)

    def _find_control_jump(self, jump_register):
        """
        Find gadget that, when called, grants control of the current gadget.

        :param jump_register: Register control required to use this gadget. 
        :type jump_register: str 

        :returns: Gadgets that grant control of the jump register
        """
        ins = mipsrop.MipsInstruction('.*mov', jump_register, '.*s')
        control = self._rop_finder.find_instructions([ins])
        return control.gadgets

    def find_gadget(self, controlled_registers, current_chain):
        """
        Find usable gadgets based on defined find function. 

        :param controlled_registers: List of currently controlled registers.
        :type controlled_registers: list(str)

        :returns: List of gadgets that can be used based on the controlled 
                  registers.
        """
        gadgets = []
        for gadget in self.chains:
            if self._find_fn(gadget, controlled_registers, current_chain):
                gadgets.append(gadget)
        return gadgets


class ChainBuilder(object):
    def __init__(self, rop_finder, registers_controlled, chain_limit,
                 allow_reuse, verbose):
        self._rop_finder = rop_finder
        self._registers = registers_controlled
        self._allow_reuse = allow_reuse
        self._verbose = verbose
        self.gadgets = []
        self.chains = []
        self.chain_len = 0
        self.chain_limit = chain_limit
        self.max_chain = 0

    def add_gadgets(self, name, gadget, check_control=True,
                    find_fn=default_gadget_search, index=None):
        """
        Add new gadget to the chain builder.

        :param name: Name of the gadget. Only used for printing purposes.
        :type name: str

        :param gadget: List of available gadgets.
        :type gadget: list(mipsrop.RopGadget or mipsrop.DoubleGadget)

        :param check_control: If the gadget jump is not controllable by a saved
                             register then search for a gadget to gain control.
        :type check_control: bool

        :param find_fn: Custom find function to use in place of searching by 
                        currently controlled registers. Function must have 
                        prototype 
                        `def function_name(link, controlled_regs, current_chain)` 
                        and return True is the gadget is usable, False if not. 
                        See MipsRopSystemChain for example use.
        :type find_fn: function

        :param index: Index to insert gadget. Index dictates it position in the 
                      generated chain.
        :type index: int
        """
        gadget_links = GadgetLinks(
            name, self._rop_finder, gadget, check_control, find_fn)
        if index is not None:
            self.gadgets.insert(index, gadget_links)
        else:
            self.gadgets.append(gadget_links)

    def replace_gadgets(self, name, gadget, index, check_control=True,
                        find_fn=default_gadget_search):
        """
        Replace a previously added gadget in the chain builder.

        :param name: Name of the gadget. Only used for printing purposes.
        :type name: str

        :param gadget: List of available gadgets.
        :type gadget: list(mipsrop.RopGadget or mipsrop.DoubleGadget)

        :param check_control: If the gadget jump is not controllable by a saved
                             register then search for a gadget to gain control.
        :type check_control: bool

        :param find_fn: Custom find function to use in place of searching by 
                        currently controlled registers. Function must have 
                        prototype 
                        `def function_name(link, controlled_regs, current_chain)` 
                        and return True is the gadget is usable, False if not. 
                        See MipsRopSystemChain for example use.
        :type find_fn: function

        :param index: Index to insert gadget. Index dictates it position in the 
                      generated chain.
        :type index: int
        """
        gadget_links = GadgetLinks(
            name, self._rop_finder, gadget, check_control, find_fn)
        self.gadgets[index] = gadget_links

    def generate_chain(self):
        """
        Generate a ROP chain based on the provided gadgets.
        """
        self._process_links(
            self.gadgets[0], self._registers, self.gadgets[1:], [])
        if not self.chains and self._verbose:
            print 'ERROR: Looks like no chains were found. Failed to find ' + \
                'working gadget for "%s"' % self.gadgets[self.max_chain].name

    def display_chains(self, verbose):
        """
        Pretty print the discovered chains.
        """
        for i in range(len(self.chains)):
            title = 'Chain %d of %d (%d instructions)' % \
                (i + 1, len(self.chains), get_chain_length(self.chains[i]))
            print '\n'
            print '*' * len(title)
            print title
            print '*' * len(title)
            for gadget in self.chains[i]:
                gadget.print_gadget(verbose)

    def _add_new_chain(self, new_chain):
        """
        Add a new chain to the saved list and drop longer chains that are above
        the search limit.

        :param new_chain: Chain to add to the list.
        :type new_chain: list(GadgetChain)
        """
        chain_length = get_chain_length(new_chain)
        if self._verbose:
            print 'Found new chain of length %d' % chain_length
        self.chains.append(new_chain)
        self.chains.sort(key=lambda chain: get_chain_length(chain))
        self.chains = self.chains[:self.chain_limit]

    def _above_max_len(self, length):
        """
        Check if length is above the longest chain saved. Automatically passes
        if the chain limit has not been reached.

        :return: True if above the limit, else False.
        :rtype: bool
        """
        if len(self.chains) < self.chain_limit:
            return False
        if length < get_chain_length(self.chains[-1]):
            return False
        return True

    def _gadget_is_used(self, gadget):
        """
        Check if gadget is used in a saved chain.

        :param gadget: Gadget to search for.
        :type gadget: GadgetChain

        :returns: True if gadget is used in a saved chain, False otherwise.
        :rtype: bool
        """
        for chain in self.chains:
            for used_gadget in chain:
                if gadget == used_gadget:
                    return True
        return False

    def _process_links(self, links, registers, remaining_links, chain):
        """
        Recursively search through gadgets to build a chain.

        :param links: Current links to search for next gadget.
        :type links: GadgetLinks

        :param registers: Currently controlled registers.
        :type registers: list(str)

        :param remaining_links: Links left to use.
        :type remaining_links: list(GadgetLinks)

        :param chain: Current chain.
        :type chain: list(GadgetLink)
        """
        if self._above_max_len(get_chain_length(chain)):
            return

        self.max_chain = max([self.max_chain, len(chain)])

        available_links = links.find_gadget(registers, chain)

        current_chain = chain[:]
        for gadget in available_links:
            # Not a perfect solution, but provides a little variety to chains
            # if multiple are requested. Might not find the shortest because of
            # that.
            if not self._allow_reuse and self._gadget_is_used(gadget):
                continue

            current_chain.append(gadget)
            if remaining_links:
                register_control = update_available_registers(registers,
                                                              gadget)
                self._process_links(
                    remaining_links[0], register_control, remaining_links[1:],
                    current_chain)
            else:  # No remaining links mean the chain is complete.
                self._add_new_chain(current_chain[:])
                if not self._allow_reuse:
                    return
            current_chain.pop()

```

`utils/rizzo.py`:

```py
import os
import time
import pickle

from . import utils

from ghidra.program.model.block import BasicBlockModel
from ghidra.program.model.symbol import SourceType
from ghidra.program.flatapi import FlatProgramAPI
from ghidra.program.model.symbol import RefType


def is_code_ref(reference):
    """
    Determine if the reference is code reference.

    :param reference: Reference to inspect.
    :type reference: ghidra.program.model.symbol.Reference

    :returns: True if reference is a code reference, False otherwise.
    :rtype: bool
    """
    ref_type = reference.getReferenceType()
    if ref_type:
        return ref_type.isCall() or ref_type.isConditional() or ref_type.isJump()
    return False


def is_data_ref(reference):
    """
    Determine if the reference is a data reference.

    :param reference: Reference to inspect.
    :type reference: ghidra.program.model.symbol.Reference

    :returns: True if reference is a data reference, False otherwise.
    :rtype: bool
    """
    ref_type = reference.getReferenceType()
    if ref_type:
        return ref_type.isRead() or ref_type.isData()
    return False


def is_call_instruction(instruction):
    """
    Determine if the reference is a function call.

    :param reference: Reference to inspect.
    :type reference: ghidra.program.model.symbol.Reference

    :returns: True if reference is function call, False otherwise.
    :rtype: bool
    """
    flow_type = instruction.getFlowType()
    if flow_type:
        return flow_type.isCall()
    return False


def find_signature_matches(new_signature, curr_signature, new_functions,
                           curr_functions, signature_type, filter_fn=None):
    """
    Search for signature matches between current file signatures and signatures
    loaded from the user provided file.

    :param new_signature: Loaded signature dictionary.
    :type new_signature: dict

    :param curr_signature: Current program signatures to compare against.
    :type curr_signature: dict

    :param new_functions: Function dict from loaded file.
    :type new_functions: dict

    :param curr_functions: Function dict from current program.
    :type curr_functions: dict

    :param signature_type: String representing the signature type.
    :type signature_type: str

    :param filter_fn: Filter function used to ignore matches under given 
                      cirumstances.
    :type filter_fn: function

    :returns: Dictionary of signatures. Key is function in current program, 
              value is the loaded function.
    :rtype: dict
    """
    signature_match = {}

    start = time.time()

    for signature, function in new_signature.iteritems():
        if signature in curr_signature:
            curr_func = RizzoFunctionDescriptor(curr_signature,
                                                curr_functions,
                                                signature)

            new_func = RizzoFunctionDescriptor(new_signature,
                                               new_functions,
                                               signature)

            if not filter_fn or filter_fn(curr_func, new_func):
                signature_match[curr_func] = new_func

    end = time.time()

    print 'Found %d %s matches in %.2f seconds.' % (len(signature_match),
                                                    signature_type,
                                                    end - start)
    return signature_match


class RizzoBlockDescriptor(object):
    """
    Break signature blocks out to classes to easily reference. Stored in this
    format to limit pickle storage space.
    """

    def __init__(self, block):
        self.formal = block[0]
        self.fuzzy = block[1]
        self.immediates = block[2]
        self.functions = block[3]

    def __eq__(self, block):
        """
        Compare this block to another to check for a match.

        :param block: Block to compare against.
        :type block: RizzoBlockDescriptor

        :returns: True if they match, false otherwise.
        :rtype: bool
        """
        return self.formal == block.formal and \
            len(self.immediates) == len(block.immediates) and \
            len(self.functions) == len(block.functions)


class RizzoFunctionDescriptor(object):
    """
    Break function descriptor out to class to easily reference. 
    """

    def __init__(self, signatures, functions, key):
        self.address = signatures[key]
        self.name = functions[self.address][0]
        self.blocks = functions[self.address][1]


class RizzoSignature(object):
    """
    Store discovered function signatures.
    """

    def __init__(self):
        self.formal = {}
        self.fuzzy = {}
        self.strings = {}
        self.functions = {}
        self.immediates = {}

        self.fuzzydups = set()
        self.formaldups = set()
        self.stringdups = set()
        self.immediatedups = set()

    def _add(self, dictionary, dictionary_dups, key, value):
        """
        Add a signature to a dictionary or the duplicate dictionary if it 
        already exists.

        :param dictionary: Default dictionary to add entry to.
        :type dictionary: dict

        :param dictionary_dups: Duplicate dictionary to move to if already 
                                present in `dictionary`.
        :type dictionary_dups: dict

        :param key: Key to insert in dictionary.
        :type key: variable

        :parrm value: Value to set for key.
        :type: value: variable
        """
        if dictionary.has_key(key):
            del dictionary[key]
            dictionary_dups.add(key)
        elif key not in dictionary_dups:
            dictionary[key] = value

    def add_formal(self, signature, address):
        """
        Add formal function signature.

        :param signature: Signature to be added to formal signatures.
        :type signature: int

        :param address: Address of function representing the signature.
        :type address: int
        """
        self._add(self.formal, self.formaldups, signature, address)

    def add_fuzzy(self, signature, address):
        """
        Add fuzzy function signature.

        :param signature: Signature to be added to fuzzy signatures.
        :type signature: int

        :param address: Address of function representing the signature.
        :type address: int
        """
        self._add(self.fuzzy, self.fuzzydups, signature, address)

    def add_string(self, signature, address):
        """
        Add string function signature.

        :param signature: Signature to be added to string signatures.
        :type signature: int

        :param address: Address of function representing the signature.
        :type address: int
        """
        self._add(self.strings, self.stringdups, signature, address)

    def add_function(self, signature, address):
        """
        Add function call signature.

        :param signature: Signature to be added to function call signatures.
        :type signature: int

        :param address: Address of function representing the signature.
        :type address: int
        """
        self._add(self.functions, self.functiondups, signature, address)

    def add_immediate(self, signature, address):
        """
        Add immediate function signature.

        :param signature: Signature to be added to immediate signatures.
        :type signature: int

        :param address: Address of function representing the signature.
        :type address: int
        """
        self._add(self.immediates, self.immediatedups, signature, address)

    def reset_dups(self):
        """
        Reset duplicate signature sets.
        """
        self.fuzzydups = set()
        self.formaldups = set()
        self.stringdups = set()
        self.immediatedups = set()


class RizzoString(object):
    """
    Represents a found string with references to it.
    """

    def __init__(self, addr, value, references):
        self.address = addr
        self.value = value
        self.xrefs = references


class Rizzo(object):
    def __init__(self, program):
        self._program = program
        self._flat_api = FlatProgramAPI(self._program)
        self._memory_map = self._program.getMemory()
        self._simple_blk = BasicBlockModel(self._program)
        self._monitor = self._flat_api.getMonitor()
        self._function_manager = self._program.getFunctionManager()
        self._address_factory = self._program.getAddressFactory()

        self.signatures = None
        self._strings = {}
        self._find_strings()

        start = time.time()
        self._signatures = self._generate()
        end = time.time()

        print 'Generated %d formal signatures and %d fuzzy signatures for %d '\
            'functions in %.2f seconds.' % (len(self._signatures.formal),
                                            len(self._signatures.fuzzy),
                                            len(self._signatures.functions),
                                            end - start)

    def save(self, signature_file):
        """
        Save Rizzo signatures to the supplied signature file.

        :param signature_file: Full path to save signatures.
        :type signature_file: str
        """
        print 'Saving signature to %s...' % signature_file
        with open(signature_file, 'wb') as rizz_file:
            pickle.dump(self._signatures, rizz_file)
        print 'done.'

    def load(self, signature_file):
        """
        Load Rizzo signatures from a file.

        :param signature_file: Full path to load signatures from.
        :type signature_file: str

        :returns: Loaded signatures
        :rtype: RizzoSignatures
        """
        if not os.path.exists(signature_file):
            raise Exception('Signature file %s does not exist' %
                            signature_file)

        print 'Loading signatures from %s...' % signature_file
        with open(signature_file, 'rb') as rizz_file:
            try:
                signatures = pickle.load(rizz_file)
            except:
                print 'This does not appear to be a Rizzo signature file.'
                exit(1)
        print 'done.'
        return signatures

    def apply(self, signatures):
        """
        Apply signatures to the current program.

        :param signatures: Signatures to apply to current program.
        :type signatures: RizzoSignatures
        """
        rename_count = 0
        signature_matches = self._find_match(signatures)
        renamed = []

        for matches in signature_matches:
            for curr_func, new_func in matches.iteritems():
                addr_hex = hex(curr_func.address)
                if addr_hex.endswith('L'):
                    addr_hex = addr_hex[:-1]
                curr_addr = self._address_factory.getAddress(addr_hex)

                function = self._flat_api.getFunctionAt(curr_addr)
                if function and new_func.name not in renamed:
                    renamed.append(new_func.name)
                    if self._rename_functions(function, new_func.name):
                        rename_count += 1

                duplicates = []
                block_match = {}
                for block in new_func.blocks:
                    new_block = RizzoBlockDescriptor(block)
                    for curr_block in curr_func.blocks:
                        curr_block = RizzoBlockDescriptor(curr_block)

                        if curr_block == new_block:
                            if curr_block in block_match:
                                del block_match[curr_block]
                                duplicates.append(curr_block)
                            elif curr_block not in duplicates:
                                block_match[curr_block] = new_block

                for curr_block, new_block in block_match.iteritems():
                    for curr_function, new_function in \
                            zip(curr_block.functions, new_block.functions):
                        functions = utils.find_function(
                            self._program, curr_function)
                        if len(functions) == 1:
                            if new_function not in renamed:
                                renamed.append(new_function)
                                if self._rename_functions(functions[0],
                                                          new_function):
                                    rename_count += 1

        print 'Renamed %d functions.' % rename_count

    def _find_match(self, signatures):
        """
        Find matches to signatures in the current program.

        :param signatures: Signatures to find in current program.
        :type signatures: RizzoSignatures

        :returns: Tuple of matched signatures: (formal, string, immediate, fuzzy)
        :rtype: tuple
        """
        formal_signatures = find_signature_matches(
            signatures.formal, self._signatures.formal, signatures.functions,
            self._signatures.functions, 'formal signatures')

        string_signatures = find_signature_matches(
            signatures.strings, self._signatures.strings, signatures.functions,
            self._signatures.functions, 'string signatures')

        immediate_signatures = find_signature_matches(
            signatures.immediates, self._signatures.immediates,
            signatures.functions, self._signatures.functions,
            'immediate signatures')

        fuzzy_signatures = find_signature_matches(
            signatures.fuzzy, self._signatures.fuzzy, signatures.functions,
            self._signatures.functions, 'fuzzy signatures',
            lambda x, y: len(x.blocks) == len(y.blocks))

        return (formal_signatures, string_signatures, immediate_signatures,
                fuzzy_signatures)

    def _rename_functions(self, function, name):
        """
        Rename a function if the function has not be renamed and new name
        is a valid new function name. Previous renamed are determined by 
        searching for 'FUN_' in the function.

        :param function: Function to be renamed.
        :type function: ghidra.program.model.listing.Function

        :param name: New name to give function.
        :type name: unicode

        :returns: True if function renamed, False for no rename.
        :rtype: bool
        """
        if not function or not name:
            return False

        if 'FUN_' in function.name and 'FUN_' not in name:
            if function:
                print 'Renaming %s to %s' % (function.name, name)
                function.setName(name, SourceType.USER_DEFINED)
                return True
        elif 'FUN_' not in function.name and 'FUN_' not in name and \
                function.name != name:
            print 'Found match with %s to %s but did not rename.' % \
                (function.name, name)
        return False

    def _signature_hash(self, value):
        """
        Simple hash function used to create a signature.

        :param value: Value to hash.
        :type value: variable

        :returns: Signature hash
        :rtype: int
        """
        return hash(str(value)) & 0xFFFFFFFF

    def _find_strings(self):
        """
        Find strings in the current program and create signatures for them.
        """
        memory = self._memory_map.getAllInitializedAddressSet()
        strings = self._flat_api.findStrings(memory, 2, 1, True, True)

        for string in strings:
            addr = string.getAddress()
            value = string.getString(self._memory_map)
            xref = self._flat_api.getReferencesTo(addr)
            self._strings[addr.hashCode()] = RizzoString(addr, value, xref)

    def _get_function_blocks(self, function):
        """
        Get all code blocks in the provided function.

        :param function: Function to get code blocks from.
        :type function: ghidra.program.model.listing.Function

        :returns: List of code blocks.
        :rtype: ghidra.program.model.block.CodeBlock
        """
        blocks = []
        code_blocks = self._simple_blk.getCodeBlocksContaining(function.body,
                                                               self._monitor)

        while code_blocks.hasNext():
            blocks.append(code_blocks.next())

        return blocks

    def _hash_block(self, block):
        """
        Create signatures for the provided code block.

        :returns: Tuple of formal, fuzzy, function, and immediate signatures)
        """
        formal = []
        fuzzy = []
        functions = []
        immediates = []

        min_addr = block.minAddress
        max_addr = block.maxAddress

        curr_ins = self._flat_api.getInstructionAt(min_addr)

        while curr_ins and curr_ins.getAddress() < max_addr:
            code_ref = []
            data_ref = []

            # Create code and data reference signatures.
            references = curr_ins.getReferencesFrom()
            for reference in references:
                # Don't care about tracking stack references.
                if reference.isStackReference():
                    continue

                if is_code_ref(reference):
                    code_ref.append(reference)

                # Get data reads only if they are to valid memory.
                elif is_data_ref(reference) and \
                        self._memory_map.contains(reference.toAddress):
                    data_ref.append(reference)

            # Append the mnemonic string to the formal signature.
            formal.append(curr_ins.getMnemonicString())

            # If its a call instruction add the function call to the functions
            # signature and make note of the call in the fuzzy signature.
            if is_call_instruction(curr_ins):
                for cref in code_ref:
                    func = self._flat_api.getFunctionAt(cref.toAddress)
                    if func:
                        functions.append(func.getName())
                        fuzzy.append('funcref')
            # Make not of any data references.
            elif data_ref:
                for dref in data_ref:
                    addr_hash = dref.toAddress.hashCode()

                    if self._strings.has_key(addr_hash):
                        string_value = self._strings[addr_hash].value
                    else:
                        string_value = 'dataref'

                    formal.append(string_value)
                    fuzzy.append(string_value)
            # If not data or code then add everything to the formal signature.
            elif not data_ref and not code_ref:
                for i in range(0, curr_ins.getNumOperands()):
                    operand = curr_ins.getDefaultOperandRepresentation(i)
                    formal.append(operand)

                    op_type = curr_ins.getOperandRefType(i)
                    if op_type and op_type.isData():
                        # Indeterminate return values. Just put a try/except
                        # around it so the getValue AttributeError can be
                        # ignored. Not worth checking for types since those
                        # may come and go.
                        try:
                            op_value = curr_ins.getOpObjects(i)[0].getValue()
                            if op_value > 0xFFFF:
                                fuzzy.append(str(op_value))
                                immediates.append(op_value)
                        except (AttributeError, IndexError):
                            pass

            curr_ins = curr_ins.getNext()

        formal_sig = self._signature_hash(''.join(formal))
        fuzzy_sig = self._signature_hash(''.join(fuzzy))

        return (formal_sig, fuzzy_sig, immediates, functions)

    def _hash_function(self, function):
        """
        Create a block by block signature for the provided function.

        :param function: Function to create signature hash for.
        :type function: ghidra.program.model.listing.Function

        :returns: List of signatures per block found.
        """
        block_hash = []

        func_blocks = self._get_function_blocks(function)
        for block in func_blocks:
            block_hash.append(self._hash_block(block))

        return block_hash

    def _generate(self):
        """
        Create signatures for the current program.
        """
        signatures = RizzoSignature()

        # String based signatures
        for (str_hash, curr_string) in self._strings.iteritems():
            # Only create signatures on reasonably long strings with one ref.
            if len(curr_string.value) >= 8 and len(curr_string.xrefs) == 1:
                function = self._flat_api.getFunctionContaining(
                    curr_string.xrefs[0].fromAddress)
                if function:
                    string_hash = self._signature_hash(curr_string.value)
                    entry = utils.address_to_int(function.getEntryPoint())
                    signatures.add_string(string_hash, entry)

        # Formal, fuzzy, and immediate-based function signatures
        for function in self._function_manager.getFunctions(True):
            hashed_function_blocks = self._hash_function(function)

            formal = self._signature_hash(
                ''.join([str(e) for (e, _, _, _) in hashed_function_blocks]))
            fuzzy = self._signature_hash(
                ''.join([str(f) for (_, f, _, _) in hashed_function_blocks]))
            immediate = [str(i) for (_, _, i, _) in hashed_function_blocks]

            function_entry = utils.address_to_int(function.getEntryPoint())
            signatures.functions[function_entry] = (
                function.getName(), hashed_function_blocks)

            signatures.add_formal(formal, function_entry)
            signatures.add_fuzzy(fuzzy, function_entry)

            for value in immediate:
                signatures.add_immediate(value, function_entry)

        signatures.reset_dups()

        return signatures

```

`utils/utils.py`:

```py
def get_instruction_list(code_manager, function):
    """
    Get list of instructions in the function.

    :param function: Function to parse for instruction list.

    :returns: List of instructions.
    """
    if function is None:
        return []
    function_bounds = function.getBody()
    function_instructions = code_manager.getInstructions(function_bounds, True)
    return function_instructions


def get_function(function_manager, address):
    """
    Return the function that contains the address. 

    :param address: Address within function.

    :returns: Function that contains the provided address.
    """
    return function_manager.getFunctionContaining(address)


def is_call_instruction(instruction):
    """
    Determine if an instruction calls a function.

    :param instruction: Instruction to inspect.
    :type instruction: ghidra.program.model.listing.Instruction

    :returns: True if the instruction is a call, false otherwise.
    :rtype: bool
    """
    if not instruction:
        return False

    flow_type = instruction.getFlowType()
    return flow_type.isCall()


def is_jump_instruction(instruction):
    """
    Determine if instruction is a jump.

    :param instruction: Instruction to inspect.
    :type instruction: ghidra.program.model.listing.Instruction

    :returns: True if the instruction is a jump, false otherwise.
    :rtype: bool
    """
    if not instruction:
        return False

    flow_type = instruction.getFlowType()
    return flow_type.isJump()


def get_processor(current_program):
    """
    Get string representing the current programs processor.

    :param current_program: Current program loaded in Ghidra.
    :type current_program: ghidra.program.model.listing.Program.
    """
    language = current_program.getLanguage()
    return language.getProcessor().toString()


def find_function(current_program, function_name):
    """
    Find a function, by name, in the current program.

    :param current_program: Current program loaded in Ghidra.
    :type current_program: ghidra.program.model.listing.Program

    :param function_name: Function to search for.
    :type function_name: str
    """
    listing = current_program.getListing()
    if listing:
        return listing.getGlobalFunctions(function_name)
    return []


def address_to_int(address):
    """
    Convert Ghidra address to integer.

    :param address: Address to convert to integer.
    :type address: ghidra.program.model.address.Address

    :returns: Integer representation of the address.
    :rtype: int
    """
    return int(address.toString(), 16)


def allowed_processors(current_program, processor_list):
    """
    Function to prevent scripts from running against unsupported processors.

    :param current_program: Current program loaded in Ghidra.
    :type current_program: ghidra.program.model.listing.Program

    :param processor_list: List of supported processors.
    :type processor_list: list(str)
    """
    curr_processor = get_processor(current_program)

    if curr_processor not in processor_list:
        print '%s is not a valid processor for this script. Supported ' \
            'processors are: %s' % (curr_processor, processor_list)
        exit(1)


def table_pretty_print(title, entries):
    """
    Print a simple table to the terminal.

    :param title: Title of the table.
    :type title: list

    :param entries: Entries to print in the table.
    :type entries: list(list(str))
    """
    # Pad entries to be the same length
    entries = [entry + ([''] * (len(title) - len(entry))) for entry in entries]
    lines = [title] + entries

    # Find the largest entry in each column so it can be used later
    # for the format string. Drop title entries if an entire column is empty.
    max_line_len = []
    for i in range(0, len(title)):
        column_lengths = [len(line[i]) for line in lines]
        if sum(column_lengths[1:]) == 0:
            title = title[:i]
            break
        max_line_len.append(max(column_lengths))

    # Account for largest entry, spaces, and '|' characters on each line.
    separator = '=' * (sum(max_line_len) + (len(title) * 3) + 1)
    spacer = '|'
    format_specifier = '{:<{width}}'

    # First block prints the title and '=' characters to make a title
    # border
    print separator
    print spacer,
    for width, column in zip(max_line_len, title):
        print format_specifier.format(column, width=width),
        print spacer,
    print ''
    print separator

    # Print the actual entries.
    for entry in entries:
        print spacer,
        for width, column in zip(max_line_len, entry):
            print format_specifier.format(column, width=width),
            print spacer,
        print ''
    print separator

```