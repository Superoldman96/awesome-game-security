Project Path: arc_gmh5225_CSGO-Cheats_2p85rzc_

Source Tree:

```txt
arc_gmh5225_CSGO-Cheats_2p85rzc_
├── CSGO-Aimbot
│   └── Source.cpp
├── CSGO-Bunnyhop
│   └── Source.cpp
├── CSGO-FOV
│   └── Source.cpp
├── CSGO-GDI-ESP
│   └── Source.cpp
├── CSGO-Glow
│   └── Source.cpp
├── CSGO-Radar
│   └── Source.cpp
├── CSGO-Triggerbot
│   └── Source.cpp
├── LICENSE
├── README.md
└── faq.md

```

`CSGO-Aimbot/Source.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include "Offsets.h"

#define dwLocalPlayer 0xD30B94
#define dwEntityList 0x4D44A24
#define m_dwBoneMatrix 0x26A8
#define m_iTeamNum 0xF4
#define m_iHealth 0x100
#define m_vecOrigin 0x138
#define m_bDormant 0xED

const int SCREEN_WIDTH = GetSystemMetrics(SM_CXSCREEN); const int xhairx = SCREEN_WIDTH / 2;
const int SCREEN_HEIGHT = GetSystemMetrics(SM_CYSCREEN); const int xhairy = SCREEN_HEIGHT / 2;

HWND hwnd;
DWORD procId; 
HANDLE hProcess; 
uintptr_t moduleBase; 
HDC hdc;
int closest; //Used in a thread to save CPU usage.

uintptr_t GetModuleBaseAddress(const char* modName) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return (uintptr_t)modEntry.modBaseAddr;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

class Vector3 {
public:
	float x, y, z;
	Vector3() : x(0.f), y(0.f), z(0.f) {}
	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}
};


int getTeam(uintptr_t player) { 
	return RPM<int>(player + m_iTeamNum);
}

uintptr_t GetLocalPlayer() {
	return RPM< uintptr_t>(moduleBase + dwLocalPlayer);
}

uintptr_t GetPlayer(int index) {  //Each player has an index. 1-64
	return RPM< uintptr_t>(moduleBase + dwEntityList + index * 0x10); //We multiply the index by 0x10 to select the player we want in the entity list.
}

int GetPlayerHealth(uintptr_t player) { 
	return RPM<int>(player + m_iHealth);
}

Vector3 PlayerLocation(uintptr_t player) { //Stores XYZ coordinates in a Vector3.
	return RPM<Vector3>(player + m_vecOrigin);
}

bool DormantCheck(uintptr_t player) {
	return RPM<int>(player + m_bDormant);
}

Vector3 get_head(uintptr_t player) { 
	struct boneMatrix_t {
		byte pad3[12];
		float x;
		byte pad1[12];
		float y;
		byte pad2[12];
		float z;
	};
	uintptr_t boneBase = RPM<uintptr_t>(player + m_dwBoneMatrix);
	boneMatrix_t boneMatrix = RPM<boneMatrix_t>(boneBase + (sizeof(boneMatrix) * 8 /*8 is the boneid for head*/));
	return Vector3(boneMatrix.x, boneMatrix.y, boneMatrix.z);
}

struct view_matrix_t {
	float matrix[16]; 
} vm;

struct Vector3 WorldToScreen(const struct Vector3 pos, struct view_matrix_t matrix) { //This turns 3D coordinates (ex: XYZ) int 2D coordinates (ex: XY).
	struct Vector3 out;
	float _x = matrix.matrix[0] * pos.x + matrix.matrix[1] * pos.y + matrix.matrix[2] * pos.z + matrix.matrix[3];
	float _y = matrix.matrix[4] * pos.x + matrix.matrix[5] * pos.y + matrix.matrix[6] * pos.z + matrix.matrix[7];
	out.z = matrix.matrix[12] * pos.x + matrix.matrix[13] * pos.y + matrix.matrix[14] * pos.z + matrix.matrix[15];

	_x *= 1.f / out.z;
	_y *= 1.f / out.z;

	out.x = SCREEN_WIDTH * .5f; 
	out.y = SCREEN_HEIGHT * .5f;

	out.x += 0.5f * _x * SCREEN_WIDTH + 0.5f;
	out.y -= 0.5f * _y * SCREEN_HEIGHT + 0.5f;

	return out;
}

float pythag(int x1, int y1, int x2, int y2) {
	return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}

int FindClosestEnemy() {
	float Finish;
	int ClosestEntity = 1;
	Vector3 Calc = { 0, 0, 0 };
	float Closest = FLT_MAX;
	int localTeam = getTeam(GetLocalPlayer()); 
	for (int i = 1; i < 64; i++) { //Loops through all the entitys in the index 1-64.
		DWORD Entity = GetPlayer(i); 
		int EnmTeam = getTeam(Entity); if (EnmTeam == localTeam) continue; 
		int EnmHealth = GetPlayerHealth(Entity); if (EnmHealth < 1 || EnmHealth > 100) continue;
		int Dormant = DormantCheck(Entity); if (Dormant) continue; 
		Vector3 headBone = WorldToScreen(get_head(Entity), vm); 
		Finish = pythag(headBone.x, headBone.y, xhairx, xhairy);
		if (Finish < Closest) {
			Closest = Finish;
			ClosestEntity = i; 
		}
	}

	return ClosestEntity;
}

void DrawLine(float StartX, float StartY, float EndX, float EndY) { //This function is optional for debugging.
	int a, b = 0;
	HPEN hOPen;
	HPEN hNPen = CreatePen(PS_SOLID, 2, 0x0000FF /*red*/);
	hOPen = (HPEN)SelectObject(hdc, hNPen);
	MoveToEx(hdc, StartX, StartY, NULL); //start of line
	a = LineTo(hdc, EndX, EndY); //end of line
	DeleteObject(SelectObject(hdc, hOPen));
} 

void FindClosestEnemyThread() { 
	while (1) {
		closest = FindClosestEnemy();
	}
}

int main() {
	hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive");
	GetWindowThreadProcessId(hwnd, &procId); 
	moduleBase = GetModuleBaseAddress("client.dll"); 
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId); 
	hdc = GetDC(hwnd);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)FindClosestEnemyThread, NULL, NULL, NULL); 

	while (!GetAsyncKeyState(VK_END)) { //press the "end" key to end the hack
		vm = RPM<view_matrix_t>(moduleBase + dwViewMatrix);
		Vector3 closestw2shead = WorldToScreen(get_head(GetPlayer(closest)), vm); 
		DrawLine(xhairx, xhairy, closestw2shead.x, closestw2shead.y); //optinal for debugging

		if (GetAsyncKeyState(VK_MENU /*alt key*/) && closestw2shead.z >= 0.001f /*onscreen check*/)
			SetCursorPos(closestw2shead.x, closestw2shead.y); //turn off "raw input" in CSGO settings
	}
}

```

`CSGO-Bunnyhop/Source.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

#define dwEntityList 0x4D3C7BC
#define dwForceJump 0x51E0004
#define m_fFlags 0x104

uintptr_t moduleBase;
DWORD procId;
HWND hwnd;
HANDLE hProcess;

uintptr_t GetModuleBaseAddress(const char* modName) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return (uintptr_t)modEntry.modBaseAddr;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer) {
	WriteProcessMemory(hProcess, (LPVOID)address, &buffer, sizeof(buffer), NULL);
}

int main() {
	hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive");
	GetWindowThreadProcessId(hwnd, &procId);
	moduleBase = GetModuleBaseAddress("client.dll");
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId);
	uintptr_t buffer;

	while (!GetAsyncKeyState(VK_END))
	{
		uintptr_t localPlayer = RPM<uintptr_t>(moduleBase + dwEntityList);
		int flags = RPM<int>(localPlayer + m_fFlags);
		if (flags & 1) {
			buffer = 5;
		}
		else {
			buffer = 4;
		}

		if (GetAsyncKeyState(VK_SPACE) & 0x8000) {
			WPM(moduleBase + dwForceJump, buffer);
		}
	}
}

```

`CSGO-FOV/Source.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

#define dwEntityList 0x4D42A34
#define m_iDefaultFOV  0x332C

uintptr_t moduleBase;
DWORD procId;
HWND hwnd;
HANDLE hProcess;

uintptr_t GetModuleBaseAddress(const char* modName) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return (uintptr_t)modEntry.modBaseAddr;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer) {
	WriteProcessMemory(hProcess, (LPVOID)address, &buffer, sizeof(buffer), NULL);
}

void main() {
	hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive");
	GetWindowThreadProcessId(hwnd, &procId);
	moduleBase = GetModuleBaseAddress("client.dll");
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId);
	int fov = 90;

	while (!GetAsyncKeyState(VK_END))
	{
		uintptr_t localPlayer = RPM<uintptr_t>(moduleBase + dwEntityList);
		int iFOV = RPM<int>(localPlayer + m_iDefaultFOV);
		std::cout << "FOV: " << iFOV << std::endl;

		if (GetAsyncKeyState(0x76 /*F7*/) & 1)
		{
			//minus
			fov = fov - 1;
			WPM<int>(localPlayer + m_iDefaultFOV, fov);
		}

		if (GetAsyncKeyState(0x77 /*F8*/) & 1)
		{
			//add
			fov = fov + 1;
			WPM<int>(localPlayer + m_iDefaultFOV, fov);
		}

		if (GetAsyncKeyState(0x78 /*F9*/) & 1)
		{
			//resets
			fov = 90;
			WPM<int>(localPlayer + m_iDefaultFOV, fov);
		}
	}
}

```

`CSGO-GDI-ESP/Source.cpp`:

```cpp
#include <Windows.h>
#include <TlHelp32.h>
 
#define dwEntityList 0x4D3C5FC
#define dwViewMatrix 0x4D2E014
#define m_iTeamNum 0xF4
#define m_iHealth 0x100
#define m_vecOrigin 0x138
 
uintptr_t moduleBase;
HANDLE TargetProcess;
HPEN BoxPen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
RECT WBounds;
HWND EspHWND;
 
template<typename T> T RPM(SIZE_T address) {
    T buffer;
    ReadProcessMemory(TargetProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
    return buffer;
}
 
uintptr_t GetModuleBaseAddress(DWORD dwPid, const char* moduleName) {
    uintptr_t dwBase = 0;
    do {
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, dwPid);
        if (hSnapshot == INVALID_HANDLE_VALUE) { continue; }
        MODULEENTRY32 ModuleEntry32;
        ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
        if (Module32First(hSnapshot, &ModuleEntry32)) {
            do {
                if (!strcmp(ModuleEntry32.szModule, (LPSTR)moduleName)) {
                    dwBase = (DWORD)ModuleEntry32.modBaseAddr;
                    break;
                }
            } while (Module32Next(hSnapshot, &ModuleEntry32));
        }
        CloseHandle(hSnapshot);
    } while (!dwBase);
    return dwBase;
}
 
struct Vector3 {
    float x, y, z;
};
 
struct view_matrix_t {
    float matrix[16];
};
 
struct Vector3 WorldToScreen(const struct Vector3 pos, struct view_matrix_t matrix) {
    struct Vector3 out;
    float _x = matrix.matrix[0] * pos.x + matrix.matrix[1] * pos.y + matrix.matrix[2] * pos.z + matrix.matrix[3];
    float _y = matrix.matrix[4] * pos.x + matrix.matrix[5] * pos.y + matrix.matrix[6] * pos.z + matrix.matrix[7];
    out.z = matrix.matrix[12] * pos.x + matrix.matrix[13] * pos.y + matrix.matrix[14] * pos.z + matrix.matrix[15];
 
    _x *= 1.f / out.z;
    _y *= 1.f / out.z;
 
    int width = WBounds.right - WBounds.left;
    int height = WBounds.bottom + WBounds.left;
 
    out.x = width * .5f;
    out.y = height * .5f;
 
    out.x += 0.5f * _x * width + 0.5f;
    out.y -= 0.5f * _y * height + 0.5f;
 
    return out;
}
 
void Draw(HDC hdc, Vector3 foot, Vector3 head) {
    float height = head.y - foot.y;
    float width = height / 2.4f;
    SelectObject(hdc, BoxPen);
    Rectangle(hdc, foot.x - (width / 2), foot.y, head.x + (width / 2), head.y);
}
 
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC Memhdc;
        HDC hdc;
        HBITMAP Membitmap;
 
        int win_width = WBounds.right - WBounds.left;
        int win_height = WBounds.bottom + WBounds.left;
 
        hdc = BeginPaint(hwnd, &ps);
        Memhdc = CreateCompatibleDC(hdc);
        Membitmap = CreateCompatibleBitmap(hdc, win_width, win_height);
        SelectObject(Memhdc, Membitmap);
        FillRect(Memhdc, &WBounds, WHITE_BRUSH);
 
        view_matrix_t vm = RPM<view_matrix_t>(moduleBase + dwViewMatrix);
        int localteam = RPM<int>(RPM<DWORD>(moduleBase + dwEntityList) + m_iTeamNum);
 
        for (int i = 1; i < 64; i++) {
            uintptr_t pEnt = RPM<DWORD>(moduleBase + dwEntityList + (i * 0x10));
            int team = RPM<int>(pEnt + m_iTeamNum);
 
            if (team != localteam) {
                int health = RPM<int>(pEnt + m_iHealth);
                Vector3 pos = RPM<Vector3>(pEnt + m_vecOrigin);
                Vector3 head; head.x = pos.x; head.y = pos.y; head.z = pos.z + 72.f;
                Vector3 screenpos = WorldToScreen(pos, vm);
                Vector3 screenhead = WorldToScreen(head, vm);
                float height = screenhead.y - screenpos.y;
                float width = height / 2.4f;
 
                if (screenpos.z >= 0.01f && health > 0 && health < 101) {
                    Draw(Memhdc, screenpos, screenhead);
                }
            }
        }
        BitBlt(hdc, 0, 0, win_width, win_height, Memhdc, 0, 0, SRCCOPY);
        DeleteObject(Membitmap);
        DeleteDC(Memhdc);
        DeleteDC(hdc);
        EndPaint(hwnd, &ps);
        ValidateRect(hwnd, &WBounds);
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}
 
DWORD WorkLoop() {
    while (1) {
        InvalidateRect(EspHWND, &WBounds, true);
        Sleep(16); //16 ms * 60 fps ~ 1000 ms
    }
}
 
int main() {
    HWND GameHWND = FindWindowA(0, "Counter-Strike: Global Offensive");
    GetClientRect(GameHWND, &WBounds);
    DWORD dwPid; GetWindowThreadProcessId(GameHWND, &dwPid);
    TargetProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, dwPid);
    moduleBase = GetModuleBaseAddress(dwPid, "client_panorama.dll");
 
    WNDCLASSEX WClass;
    MSG Msg;
    WClass.cbSize = sizeof(WNDCLASSEX);
    WClass.style = NULL;
    WClass.lpfnWndProc = WndProc;
    WClass.cbClsExtra = NULL;
    WClass.cbWndExtra = NULL;
    WClass.hInstance = reinterpret_cast<HINSTANCE>(GetWindowLongA(GameHWND, GWL_HINSTANCE));
    WClass.hIcon = NULL;
    WClass.hCursor = NULL;
    WClass.hbrBackground = WHITE_BRUSH;
    WClass.lpszMenuName = " ";
    WClass.lpszClassName = " ";
    WClass.hIconSm = NULL;
    RegisterClassExA(&WClass);
 
    HINSTANCE Hinstance = NULL;
    EspHWND = CreateWindowExA(WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED, " ", " ", WS_POPUP, WBounds.left, WBounds.top, WBounds.right - WBounds.left, WBounds.bottom + WBounds.left, NULL, NULL, Hinstance, NULL);
 
    SetLayeredWindowAttributes(EspHWND, RGB(255, 255, 255), 255, LWA_COLORKEY);
    ShowWindow(EspHWND, 1);
    CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)&WorkLoop, NULL, NULL, NULL);
    while (GetMessageA(&Msg, NULL, NULL, NULL) > 0) {
        TranslateMessage(&Msg);
        DispatchMessageA(&Msg);
        Sleep(1);
    }
    ExitThread(0);
    return 0;
}
```

`CSGO-Glow/Source.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include "Offsets.h"

#define dwLocalPlayer 0xD30B94
#define dwGlowObjectManager 0x528C8D8
#define dwEntityList 0x4D44A24
#define m_iGlowIndex 0xA428
#define m_iTeamNum 0xF4
#define m_iHealth 0x100
#define m_bDormant 0xED
 
uintptr_t moduleBase;
DWORD procId;
HWND hwnd;
HANDLE hProcess;

uintptr_t GetModuleBaseAddress(const char* modName) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return (uintptr_t)modEntry.modBaseAddr;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer) {
	WriteProcessMemory(hProcess, (LPVOID)address, &buffer, sizeof(buffer), NULL);
}

struct glowStructEnemy {
	float red = 1.f;
	float green = 0.f;
	float blue = 0.f;
	float alpha = 1.f;
	uint8_t padding[8];
	float unknown = 1.f;
	uint8_t padding2[4];
	BYTE renderOccluded = true;
	BYTE renderUnoccluded = false;
	BYTE fullBloom = false;
}glowEnm;

struct glowStructLocal {
	float red = 0.f;
	float green = 1.f;
	float blue = 0.f;
	float alpha = 1.f;
	uint8_t padding[8];
	float unknown = 1.f;
	uint8_t padding2[4];
	BYTE renderOccluded = true;
	BYTE renderUnoccluded = false;
	BYTE fullBloom = false;
}glowLocal;

uintptr_t getLocalPlayer() {
	return RPM<uintptr_t>(moduleBase + dwLocalPlayer);
}

int main() {
	hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive");
	GetWindowThreadProcessId(hwnd, &procId);
	moduleBase = GetModuleBaseAddress("client.dll");
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId);

	while (!GetAsyncKeyState(VK_END))
	{
		uintptr_t dwGlowManager = RPM<uintptr_t>(moduleBase + dwGlowObjectManager);
		int LocalTeam = RPM<int>(getLocalPlayer() + m_iTeamNum);
		for (int i = 1; i < 32; i++) {
			uintptr_t dwEntity = RPM<uintptr_t>(moduleBase + dwEntityList + i * 0x10);
			int iGlowIndx = RPM<int>(dwEntity + m_iGlowIndex);
			int EnmHealth = RPM<int>(dwEntity + m_iHealth); if (EnmHealth < 1 || EnmHealth > 100) continue;
			int Dormant = RPM<int>(dwEntity + m_bDormant); if (Dormant) continue;
			int EntityTeam = RPM<int>(dwEntity + m_iTeamNum);
			
			if (LocalTeam == EntityTeam)
			{
				WPM<glowStructLocal>(dwGlowManager + (iGlowIndx * 0x38) + 0x4, glowLocal);
			}
			else if (LocalTeam != EntityTeam)
			{
				WPM<glowStructEnemy>(dwGlowManager + (iGlowIndx * 0x38) + 0x4, glowEnm);
			}
		}
	}
}

```

`CSGO-Radar/Source.cpp`:

```cpp
#include <Windows.h>
#include <TlHelp32.h>
 
#define dwEntityList 0x4D44A04
#define m_bSpotted 0x93D
 
DWORD dwPid;
HANDLE hProcess;
DWORD client;
 
uintptr_t GetModule(const char* modName, DWORD procId) {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
    if (hSnap != INVALID_HANDLE_VALUE) {
        MODULEENTRY32 modEntry;
        modEntry.dwSize = sizeof(modEntry);
        if (Module32First(hSnap, &modEntry)) {
            do {
                if (!strcmp(modEntry.szModule, modName)) {
                    CloseHandle(hSnap);
                    return (uintptr_t)modEntry.modBaseAddr;
                }
            } while (Module32Next(hSnap, &modEntry));
        }
    }
}
 
template<typename T> T RPM(SIZE_T address) {
    T buffer; ReadProcessMemory(hProcess, (void*)address, &buffer, sizeof(T), nullptr);
    return buffer;
}
 
template<typename T> void WPM(SIZE_T address, T buffer) {
    WriteProcessMemory(hProcess, (void*)address, &buffer, sizeof(T), nullptr);
}
 
void main() {
    GetWindowThreadProcessId(FindWindowA(0, "Counter-Strike: Global Offensive"), &dwPid);
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, dwPid);
    client = GetModule("client.dll", dwPid);
 
    while (true) {
        for (int i = 1; i < 64; i++) {
            DWORD dwCurrentEntity = RPM<DWORD>(client + dwEntityList + i * 0x10);
            if (dwCurrentEntity) {
                WPM<bool>(dwCurrentEntity + m_bSpotted, true);
            }
        }
        Sleep(50);
    }
}

```

`CSGO-Triggerbot/Source.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

#define m_iTeamNum 0xF4
#define dwLocalPlayer 0xD29B0C
#define dwEntityList 0x4D3D6AC
#define m_iCrosshairId 0xB3D4

uintptr_t moduleBase;
DWORD procId;
HWND hwnd;
HANDLE hProcess;

uintptr_t GetModuleBaseAddress(const char* modName) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry)) {
			do {
				if (!strcmp(modEntry.szModule, modName)) {
					CloseHandle(hSnap);
					return (uintptr_t)modEntry.modBaseAddr;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
}

template<typename T> T RPM(SIZE_T address) {
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

uintptr_t getLocalPlayer() { //This will get the address to localplayer. 
	return RPM< uintptr_t>(moduleBase + dwLocalPlayer);
}

uintptr_t getPlayer(int index) {  //Each player in the game has an index.
	return RPM< uintptr_t>(moduleBase + dwEntityList + index * 0x10); //We use index times 0x10 because the distance between each player 0x10.
}

int getTeam(uintptr_t player) { 
	return RPM<int>(player + m_iTeamNum);
}

int getCrosshairID(uintptr_t player) {
	return RPM<int>(player + m_iCrosshairId);
}

int main() {
	hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive"); 
	GetWindowThreadProcessId(hwnd, &procId);
	moduleBase = GetModuleBaseAddress("client.dll");
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId); 

	while (!GetAsyncKeyState(VK_END)) {
		int CrosshairID = getCrosshairID(getLocalPlayer());
		int CrosshairTeam = getTeam(getPlayer(CrosshairID - 1));
		int LocalTeam = getTeam(getLocalPlayer());
		if (CrosshairID > 0 && CrosshairID < 32 && LocalTeam != CrosshairTeam)
		{
			if (GetAsyncKeyState(VK_MENU /*alt key*/))
			{
				mouse_event(MOUSEEVENTF_LEFTDOWN, NULL, NULL, 0, 0);
				mouse_event(MOUSEEVENTF_LEFTUP, NULL, NULL, 0, 0);
				Sleep(100); //Optional
			}
		}
	}

}

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Heath Howren

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# CS:GO Cheat Library

## Introduction

This is a collection of cheats for the video-game Counter-Strike: Global Offensive.<br />
These cheats were coded as part of a [YouTube series](https://www.youtube.com/watch?v=1y63M4BvG9A&list=PLzBukBmD3GxuBpWT7xV-pCN-Uu7WwtK7O).

## Code Samples

**Gaining access to the CSGO application**<br />
The window is stored ```HWND hwnd = FindWindowA(NULL, "Counter-Strike: Global Offensive");```<br />
The process ID is retrieved ```GetWindowThreadProcessId(hwnd, &procId);```<br />
A handle is is created  ```HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId);```

**How to read and write process memory** <br />
How to read process memory: ```RPM<variable type>(address +  offsets);``` <br />
Example: ```RPM<int>(0xD30B94 + 0x4);``` <br />

How to write process memory: ```WPM<variable type>(address +  offsets, newValue);``` <br />
Example: ```int value = 999; WPM<int>(0xD30B94 + 0x4, value);```

## Installation
Update the addresses and offsets. I reccomend using [Hazedumper](https://github.com/frk1/hazedumper) for this. <br />
Set the character set to Multi-Byte.<br />
Build the application as **x86** and run as an administrator.<br />
**Error trouble shooting**<br />
If you are having issues compiling check out the [faq](https://github.com/HeathHowren/CSGO-Cheats/blob/master/faq.md) for common issues I've seen!<br />


## Contributions
* [HeathHowren](https://github.com/HeathHowren)
* [beans42](https://github.com/beans42)

```

`faq.md`:

```md
# Frequently asked questions and issues

## Issues

**The wrong character set being used**<br />
I see this issue a lot, you muse set the character set to muli-byte. If you do not you will see an error like [this](https://i.gyazo.com/9407cb6bbb2f2bae25ea5615cc4166bb.png). <br />
Go into the project properties and follow change the character set to multi-byte. <br />
[Fix for VS Community IDE 2017](https://i.gyazo.com/47efe57114ecbfb2dbbbb630cb07ffe7.png)<br />
[Fix for VS Community IDE 2019](https://i.gyazo.com/b427de2ada6066819bb20e9a9684f689.png)<br />

**Cannot open source file "pch.h" or "stafdx.h"** <br />
This issue comes from not creating an empty project file. This is very easy to fix, and the error will look like [this](https://gyazo.com/fb4f6fa466ed438e31236af444dc5d96).<br />
First delete the line that says ```#include "pch.h"``` or ```#include "stafdx.h"``` <br />
Go into the project properties and [turn off using pre-compiled headers](https://i.gyazo.com/cd5056afcd785e168b737aa36efa1f97.png). <br />

```