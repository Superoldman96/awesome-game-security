Project Path: arc_gmh5225_kptnhook_455wkpng

Source Tree:

```txt
arc_gmh5225_kptnhook_455wkpng
├── CMakeLists.txt
├── LICENSE
├── compile-shellcode.ps1
├── create_cert.ps1
├── deps
│   ├── CMakeLists.txt
│   ├── findwdk
│   ├── phnt
│   └── zydis
├── include
│   └── kptnhook
│       ├── CMakeLists.txt
│       ├── arch.h
│       ├── drvglobal.h
│       ├── handler.h
│       ├── hook.h
│       ├── known_dlls.h
│       ├── log.h
│       ├── main.h
│       ├── path.h
│       ├── pointers.h
│       ├── raii.hpp
│       ├── tibpeb.h
│       ├── tibpebwow64.h
│       └── undocumented.h
└── src
    ├── CMakeLists.txt
    ├── arch.cpp
    ├── drvglobal.cpp
    ├── handler.cpp
    ├── hook.cpp
    ├── known_dlls.cpp
    ├── main.cpp
    ├── path.cpp
    └── shellcode
        ├── shellcode32.asm
        ├── shellcode64.asm
        └── structs.asm

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.23.0)
project(kptnhook VERSION 0.1.0)

#include(CTest)
#enable_testing()

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/deps/findwdk/cmake")
find_package(WDK REQUIRED)

set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS src/shellcode/shellcode32.asm)
set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS src/shellcode/shellcode64.asm)
set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS src/shellcode/structs.asm)

exec_program(powershell "${CMAKE_CURRENT_LIST_DIR}"
             ARGS -ExecutionPolicy Bypass -File ${CMAKE_CURRENT_LIST_DIR}\\compile-shellcode.ps1 ${CMAKE_CURRENT_LIST_DIR}\\src\\shellcode\\shellcode32.asm
             OUTPUT_VARIABLE SHELLCODE_BYTES32)

message("compiled 32bit shellcode: ${SHELLCODE_BYTES32}")

exec_program(powershell "${CMAKE_CURRENT_LIST_DIR}"
             ARGS -ExecutionPolicy Bypass -File ${CMAKE_CURRENT_LIST_DIR}\\compile-shellcode.ps1 ${CMAKE_CURRENT_LIST_DIR}\\src\\shellcode\\shellcode64.asm
             OUTPUT_VARIABLE SHELLCODE_BYTES64)

message("compiled 64bit shellcode: ${SHELLCODE_BYTES64}")

wdk_add_driver(kptnhook src/main.cpp)

target_compile_definitions(kptnhook PUBLIC ARR_SHELLCODE32=${SHELLCODE_BYTES32})
target_compile_definitions(kptnhook PUBLIC ARR_SHELLCODE64=${SHELLCODE_BYTES64})
add_custom_command(TARGET kptnhook POST_BUILD
    COMMAND ${WDK_ROOT}/bin/${WDK_VERSION}/x64/signtool.exe sign /v /n kptnhook $<TARGET_FILE:kptnhook>
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    COMMENT "signing kernel driver"
)

add_subdirectory(src)
add_subdirectory(include/kptnhook)
#add_subdirectory(deps)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)

message(${WDK_ROOT}/bin/${WDK_VERSION}/x64/signtool.exe )
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Σcatnip

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`compile-shellcode.ps1`:

```ps1
<#
    compiles an asm file into a c-style byte array
#>
param (
    # path to asm file
    [parameter(mandatory=$true)]
    [string]$path
)

$nasm = "$env:LOCALAPPDATA\bin\NASM\nasm.exe"

if (-not (test-path $nasm)) {
    write-error "nasm.exe not found in appdata. install nasm for local user to continue."
    exit 1
}

$tempfile = "$env:TEMP\shellcode.bin"
& $nasm $path -f bin -o $tempfile
'{ ' + ((format-hex $tempfile | select -expand bytes | % { '0x{0:x2}' -f $_ }) -join ', ') + ' }'
```

`create_cert.ps1`:

```ps1
New-SelfSignedCertificate -Subject "kptnhook" -Type CodeSigningCert -CertStoreLocation cert:\CurrentUser\My -NotAfter (Get-Date).AddYears(99)
```

`include/kptnhook/CMakeLists.txt`:

```txt
target_include_directories(kptnhook PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

`include/kptnhook/arch.h`:

```h
#pragma once
#include <ntifs.h>

enum bit { x64, x32 };
enum compat { native, wow };
struct arch {
    bit b;
    compat com;
};

/// figure out the architecture of a peprocess
arch proc_arch(PEPROCESS p);
```

`include/kptnhook/drvglobal.h`:

```h
#pragma once

#include <ntifs.h>

struct driverctx {
    PDRIVER_OBJECT obj;
    PUNICODE_STRING registry_path; 
};

extern driverctx GLOBAL;
```

`include/kptnhook/handler.h`:

```h
#pragma once
#include <ntifs.h>

constexpr UNICODE_STRING KNOWN_DLLS[] = {
	RTL_CONSTANT_STRING(L"gi_agent.dll")
};

void on_image_load(PUNICODE_STRING img_name, HANDLE proc, PIMAGE_INFO info);
void on_create_proc(HANDLE parent_pid, HANDLE pid, BOOLEAN create);
```

`include/kptnhook/hook.h`:

```h
#pragma once
#include <ntifs.h>

constexpr UINT8 stub64[] = { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00 };
constexpr auto STUB_SIZE64 = sizeof(stub64) + sizeof(UINT64);

constexpr UINT8 stub32[] = { 0xe9 };
constexpr auto STUB_SIZE32 = sizeof(stub32) + sizeof(UINT32);

#ifdef ARR_SHELLCODE32
#else
#define ARR_SHELLCODE32 { 0 }
#error shellcode not defined, use the cmake build as it defined this
#endif

#ifdef ARR_SHELLCODE64
#else
#define ARR_SHELLCODE64 { 0 }
#error shellcode not defined, use the cmake build as it defined this
#endif

void hook64(void* func, void* target);
void hook32(void* func, void* target);
```

`include/kptnhook/known_dlls.h`:

```h
#pragma once
#include <ntifs.h>
#include <arch.h>

NTSTATUS remove_known_dll(const UNICODE_STRING* filename, bool native_arch);
NTSTATUS add_known_dll(const UNICODE_STRING* filename, arch a);
```

`include/kptnhook/log.h`:

```h
#pragma once

#include <ntifs.h>

constexpr auto LOG_LEVEL_DBG   = 4;
constexpr auto LOG_LEVEL_TRACE = 3;
constexpr auto LOG_LEVEL_INFO  = 2;
constexpr auto LOG_LEVEL_WARN  = 1;
constexpr auto LOG_LEVEL_ERR   = 0;

#define log_debug(s, ...) DbgPrintEx(DPFLTR_DEFAULT_ID, LOG_LEVEL_DBG,   "[kptnhook2][debug] " s "\n", __VA_ARGS__)
#define log_trace(s, ...) DbgPrintEx(DPFLTR_DEFAULT_ID, LOG_LEVEL_TRACE, "[kptnhook2][trace] " s "\n", __VA_ARGS__)
#define log_info(s, ...)  DbgPrintEx(DPFLTR_DEFAULT_ID, LOG_LEVEL_INFO,  "[kptnhook2][info]  " s "\n", __VA_ARGS__)
#define log_warn(s, ...)  DbgPrintEx(DPFLTR_DEFAULT_ID, LOG_LEVEL_WARN,  "[kptnhook2][warn]  " s "\n", __VA_ARGS__)
#define log_error(s, ...) DbgPrintEx(DPFLTR_DEFAULT_ID, LOG_LEVEL_ERR,   "[kptnhook2][error] " s "\n", __VA_ARGS__)

#define guard_log(cond, code, msg, ...) if(cond) { log_error(msg, __VA_ARGS__); return code; }
#define guard_nts(status, msg, ...) guard_log(!NT_SUCCESS(status), status, msg, __VA_ARGS__);
```

`include/kptnhook/main.h`:

```h
#pragma once
#include <ntifs.h>

extern "C" NTSTATUS NTAPI DriverEntry(PDRIVER_OBJECT drv, PUNICODE_STRING reg_path);
void NTAPI unload(PDRIVER_OBJECT drv);
```

`include/kptnhook/path.h`:

```h
#pragma once
#include <ntifs.h>

bool match_filename(PUNICODE_STRING path, PUNICODE_STRING filename);
bool match_filename_ascii(char* path, char* filename);
```

`include/kptnhook/pointers.h`:

```h
#pragma once

#define addroffset(type, addr, off) reinterpret_cast<type*>(reinterpret_cast<uintptr_t>(addr) + off)
#define addr_relative_to(a1, a2) reinterpret_cast<size_t>(a1) - reinterpret_cast<size_t>(a2)
#define towow64(ptr) static_cast<UINT32>(reinterpret_cast<UINT_PTR>(ptr))
```

`include/kptnhook/raii.hpp`:

```hpp
#pragma once
#include <ntifs.h>

#define _CONCAT(x,y) x ## y
#define CONCAT(x,y) _CONCAT(x,y)

template<class T>
class raiiwrap {
public:
	raiiwrap(T inner) : m_inner(inner) {}
protected:
	T m_inner;
};

#define bind_peprocess(p) auto CONCAT(anonymous, __LINE__) = peprocess_res(p);
class peprocess_res : public raiiwrap<PEPROCESS> {
public:
	peprocess_res(PEPROCESS p) : raiiwrap(p) {};
	~peprocess_res() { ObDereferenceObject(m_inner); }
};

#define bind_handle(h) auto CONCAT(anonymous, __LINE__) = handle_res(h);
class handle_res : public raiiwrap<HANDLE> {
public: 
	handle_res(HANDLE p) : raiiwrap(p) {};
	~handle_res() { ZwClose(m_inner); }
};

#define bind_kapc_state(p) auto CONCAT(anonymous, __LINE__) = kapc_state_res(p);
class kapc_state_res : public raiiwrap<PKAPC_STATE> {
public:
	kapc_state_res(PKAPC_STATE p) : raiiwrap(p) {};
	~kapc_state_res() { KeUnstackDetachProcess(m_inner); }
};

#define bind_alloc(p) auto CONCAT(anonymous, __LINE__) = alloc_res(p);
class alloc_res : public raiiwrap<PVOID> {
public:
	alloc_res(PVOID p) : raiiwrap(p) {};
	~alloc_res() { if(m_inner) ExFreePool(m_inner); }
};

```

`include/kptnhook/tibpebwow64.h`:

```h
#include <ntifs.h>

// stolen definitions from https://github.com/processhacker/phnt

#define WOW64_POINTER(Type) ULONG

#define GDI_HANDLE_BUFFER_SIZE32 34
typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];

#define GDI_BATCH_BUFFER_SIZE 310
typedef struct _GDI_TEB_BATCH32
{
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

typedef struct _CLIENT_ID32
{
    ULONG UniqueProcess;
    ULONG UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _TEB32
{
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) ReservedForDebuggerInstrumentation[16];
    WOW64_POINTER(PVOID) SystemReserved1[36];
    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackSp;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousPc;
    WOW64_POINTER(ULONG_PTR) InstrumentationCallbackPreviousSp;
    BOOLEAN InstrumentationCallbackDisabled;
    UCHAR SpareBytes[23];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;

    WOW64_POINTER(PVOID) Vdm;
    WOW64_POINTER(PVOID) ReservedForNtRpc;
    WOW64_POINTER(PVOID) DbgSsReserved[2];

    ULONG HardErrorMode;
    WOW64_POINTER(PVOID) Instrumentation[9];
    GUID ActivityId;

    WOW64_POINTER(PVOID) SubProcessTag;
    WOW64_POINTER(PVOID) PerflibData;
    WOW64_POINTER(PVOID) EtwTraceData;
    WOW64_POINTER(PVOID) WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    WOW64_POINTER(PVOID) ReservedForPerf;
    WOW64_POINTER(PVOID) ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WOW64_POINTER(PVOID) SavedPriorityState;
    WOW64_POINTER(ULONG_PTR) ReservedForCodeCoverage;
    WOW64_POINTER(PVOID) ThreadPoolData;
    WOW64_POINTER(PVOID *) TlsExpansionSlots;

    ULONG MuiGeneration;
    ULONG IsImpersonating;
    WOW64_POINTER(PVOID) NlsCache;
    WOW64_POINTER(PVOID) pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    WOW64_POINTER(HANDLE) CurrentTransactionHandle;
    WOW64_POINTER(PTEB_ACTIVE_FRAME) ActiveFrame;
    WOW64_POINTER(PVOID) FlsData;

    WOW64_POINTER(PVOID) PreferredLanguages;
    WOW64_POINTER(PVOID) UserPrefLanguages;
    WOW64_POINTER(PVOID) MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SpareSameTebBits : 2;
        };
    };

    WOW64_POINTER(PVOID) TxnScopeEnterCallback;
    WOW64_POINTER(PVOID) TxnScopeExitCallback;
    WOW64_POINTER(PVOID) TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    WOW64_POINTER(PVOID) ResourceRetValue;
    WOW64_POINTER(PVOID) ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB32, *PTEB32;

typedef struct _PEB32
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ReservedBits0 : 27;
        };
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PVOID *) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PVOID *) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    WOW64_POINTER(PVOID) pShimData;
    WOW64_POINTER(PVOID) AppCompatInfo;

    UNICODE_STRING32 CSDVersion;

    WOW64_POINTER(PVOID) ActivationContextData;
    WOW64_POINTER(PVOID) ProcessAssemblyStorageMap;
    WOW64_POINTER(PVOID) SystemDefaultActivationContextData;
    WOW64_POINTER(PVOID) SystemAssemblyStorageMap;

    WOW64_POINTER(SIZE_T) MinimumStackCommit;

    WOW64_POINTER(PVOID) SparePointers[4];
    ULONG SpareUlongs[5];
    //WOW64_POINTER(PVOID *) FlsCallback;
    //LIST_ENTRY32 FlsListHead;
    //WOW64_POINTER(PVOID) FlsBitmap;
    //ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    //ULONG FlsHighIndex;

    WOW64_POINTER(PVOID) WerRegistrationData;
    WOW64_POINTER(PVOID) WerShipAssertPtr;
    WOW64_POINTER(PVOID) pContextData;
    WOW64_POINTER(PVOID) pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) TppWorkerpListLock;
    LIST_ENTRY32 TppWorkerpList;
    WOW64_POINTER(PVOID) WaitOnAddressHashTable[128];
    WOW64_POINTER(PVOID) TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags; // REDSTONE4
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _RTL_BALANCED_NODE32
{
    union
    {
        WOW64_POINTER(struct _RTL_BALANCED_NODE *) Children[2];
        struct
        {
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Left;
            WOW64_POINTER(struct _RTL_BALANCED_NODE *) Right;
        };
    };
    union
    {
        WOW64_POINTER(UCHAR) Red : 1;
        WOW64_POINTER(UCHAR) Balance : 2;
        WOW64_POINTER(ULONG_PTR) ParentValue;
    };
} RTL_BALANCED_NODE32, *PRTL_BALANCED_NODE32;

typedef enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary, // since REDSTONE3
    LoadReasonEnclaveDependency,
    LoadReasonPatchImage, // since WIN11
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    union
    {
        LIST_ENTRY32 InInitializationOrderLinks;
        LIST_ENTRY32 InProgressLinks;
    };
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ReservedFlags5 : 2;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
    WOW64_POINTER(struct _ACTIVATION_CONTEXT *) EntryPointActivationContext;
    WOW64_POINTER(PVOID) Lock;
    WOW64_POINTER(PLDR_DDAG_NODE) DdagNode;
    LIST_ENTRY32 NodeModuleLink;
    WOW64_POINTER(struct _LDRP_LOAD_CONTEXT *) LoadContext;
    WOW64_POINTER(PVOID) ParentDllBase;
    WOW64_POINTER(PVOID) SwitchBackContext;
    RTL_BALANCED_NODE32 BaseAddressIndexNode;
    RTL_BALANCED_NODE32 MappingInfoIndexNode;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // since REDSTONE2
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;
```

`include/kptnhook/undocumented.h`:

```h
#pragma once
#include <ntifs.h>

extern "C" {
	NTKERNELAPI NTSTATUS RtlSetSaclSecurityDescriptor(
		IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
		IN  BOOLEAN SaclPresent,
		IN  PACL Sacl OPTIONAL,
		IN  BOOLEAN SaclDefaulted OPTIONAL
	);
	NTKERNELAPI const char* PsGetProcessImageFileName(PEPROCESS proc);
	NTKERNELAPI NTSTATUS ZwProtectVirtualMemory(IN HANDLE ProcessHandle, IN PVOID* BaseAddress, IN SIZE_T* NumberOfBytesToProtect, IN ULONG NewAccessProtection, OUT PULONG OldAccessProtection);
	NTKERNELAPI PPEB NTAPI PsGetProcessPeb(PEPROCESS Process);
	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
	__declspec(dllimport) NTSTATUS ZwQueryInformationProcess
	(
		_In_      HANDLE           ProcessHandle,
		_In_      PROCESSINFOCLASS ProcessInformationClass,
		_Out_     PVOID            ProcessInformation,
		_In_      ULONG            ProcessInformationLength,
		_Out_opt_ PULONG           ReturnLength
	);
}

typedef struct _LDR_DATA_TABLE_ENTRY {
	PVOID          Reserved1[2];
	LIST_ENTRY     InMemoryOrderLinks;
	PVOID          Reserved2[2];
	PVOID          DllBase;
	PVOID          EntryPoint;
	PVOID          Reserved3;
	UNICODE_STRING FullDllName;
	UINT8          Reserved4[8];
	PVOID          Reserved5[3];
	union {
		ULONG CheckSum;
		PVOID Reserved6;
	};
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	UINT8          Reserved1[16];
	PVOID          Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

// https://www.vergiliusproject.com

#ifdef _WIN64
// x64 offsets

#if WINDOWS_REVISION >= 2004
constexpr auto MITIGATION_OFFSET = 0x9d0;
#elif WINDOWS_REVISION >= 1903
constexpr auto MITIGATION_OFFSETT = 0x850;
#elif WINDOWS_REVISION >= 1809
constexpr auto MITIGATION_OFFSETT = 0x820;
#elif WINDOWS_REVISION >= 1709
constexpr auto MITIGATION_OFFSETT = 0x828;
#else
constexpr auto MITIGATION_OFFSET = 0x9d0;
#endif

#else
// x86 offsets

#if WINDOWS_REVISION >= 2004
constexpr auto MITIGATION_OFFSETT 0x490
#elif WINDOWS_REVISION >= 1903
constexpr auto MITIGATION_OFFSETT 0x450
#elif WINDOWS_REVISION >= 1803
constexpr auto MITIGATION_OFFSETT 0x3e0
#elif WINDOWS_REVISION >= 1709
constexpr auto MITIGATION_OFFSETT 0x3d8
#else
constexpr auto MITIGATION_OFFSETT 0x490
#endif

#endif

struct mitigation_flags1
{
	ULONG ControlFlowGuardEnabled : 1;                                //0x9d0
	ULONG ControlFlowGuardExportSuppressionEnabled : 1;               //0x9d0
	ULONG ControlFlowGuardStrict : 1;                                 //0x9d0
	ULONG DisallowStrippedImages : 1;                                 //0x9d0
	ULONG ForceRelocateImages : 1;                                    //0x9d0
	ULONG HighEntropyASLREnabled : 1;                                 //0x9d0
	ULONG StackRandomizationDisabled : 1;                             //0x9d0
	ULONG ExtensionPointDisable : 1;                                  //0x9d0
	ULONG DisableDynamicCode : 1;                                     //0x9d0
	ULONG DisableDynamicCodeAllowOptOut : 1;                          //0x9d0
	ULONG DisableDynamicCodeAllowRemoteDowngrade : 1;                 //0x9d0
	ULONG AuditDisableDynamicCode : 1;                                //0x9d0
	ULONG DisallowWin32kSystemCalls : 1;                              //0x9d0
	ULONG AuditDisallowWin32kSystemCalls : 1;                         //0x9d0
	ULONG EnableFilteredWin32kAPIs : 1;                               //0x9d0
	ULONG AuditFilteredWin32kAPIs : 1;                                //0x9d0
	ULONG DisableNonSystemFonts : 1;                                  //0x9d0
	ULONG AuditNonSystemFontLoading : 1;                              //0x9d0
	ULONG PreferSystem32Images : 1;                                   //0x9d0
	ULONG ProhibitRemoteImageMap : 1;                                 //0x9d0
	ULONG AuditProhibitRemoteImageMap : 1;                            //0x9d0
	ULONG ProhibitLowILImageMap : 1;                                  //0x9d0
	ULONG AuditProhibitLowILImageMap : 1;                             //0x9d0
	ULONG SignatureMitigationOptIn : 1;                               //0x9d0
	ULONG AuditBlockNonMicrosoftBinaries : 1;                         //0x9d0
	ULONG AuditBlockNonMicrosoftBinariesAllowStore : 1;               //0x9d0
	ULONG LoaderIntegrityContinuityEnabled : 1;                       //0x9d0
	ULONG AuditLoaderIntegrityContinuity : 1;                         //0x9d0
	ULONG EnableModuleTamperingProtection : 1;                        //0x9d0
	ULONG EnableModuleTamperingProtectionNoInherit : 1;               //0x9d0
	ULONG RestrictIndirectBranchPrediction : 1;                       //0x9d0
	ULONG IsolateSecurityDomain : 1;                                  //0x9d0
};

struct mitigation_flags2
{
	ULONG EnableExportAddressFilter : 1;                              //0x9d4
	ULONG AuditExportAddressFilter : 1;                               //0x9d4
	ULONG EnableExportAddressFilterPlus : 1;                          //0x9d4
	ULONG AuditExportAddressFilterPlus : 1;                           //0x9d4
	ULONG EnableRopStackPivot : 1;                                    //0x9d4
	ULONG AuditRopStackPivot : 1;                                     //0x9d4
	ULONG EnableRopCallerCheck : 1;                                   //0x9d4
	ULONG AuditRopCallerCheck : 1;                                    //0x9d4
	ULONG EnableRopSimExec : 1;                                       //0x9d4
	ULONG AuditRopSimExec : 1;                                        //0x9d4
	ULONG EnableImportAddressFilter : 1;                              //0x9d4
	ULONG AuditImportAddressFilter : 1;                               //0x9d4
	ULONG DisablePageCombine : 1;                                     //0x9d4
	ULONG SpeculativeStoreBypassDisable : 1;                          //0x9d4
	ULONG CetUserShadowStacks : 1;                                    //0x9d4
	ULONG AuditCetUserShadowStacks : 1;                               //0x9d4
	ULONG AuditCetUserShadowStacksLogged : 1;                         //0x9d4
	ULONG UserCetSetContextIpValidation : 1;                          //0x9d4
	ULONG AuditUserCetSetContextIpValidation : 1;                     //0x9d4
	ULONG AuditUserCetSetContextIpValidationLogged : 1;               //0x9d4
	ULONG CetUserShadowStacksStrictMode : 1;                          //0x9d4
	ULONG BlockNonCetBinaries : 1;                                    //0x9d4
	ULONG BlockNonCetBinariesNonEhcont : 1;                           //0x9d4
	ULONG AuditBlockNonCetBinaries : 1;                               //0x9d4
	ULONG AuditBlockNonCetBinariesLogged : 1;                         //0x9d4
	ULONG Reserved1 : 1;                                              //0x9d4
	ULONG Reserved2 : 1;                                              //0x9d4
	ULONG Reserved3 : 1;                                              //0x9d4
	ULONG Reserved4 : 1;                                              //0x9d4
	ULONG Reserved5 : 1;                                              //0x9d4
	ULONG CetDynamicApisOutOfProcOnly : 1;                            //0x9d4
	ULONG UserCetSetContextIpValidationRelaxedMode : 1;               //0x9d4
};

```

`src/CMakeLists.txt`:

```txt
target_sources(kptnhook PRIVATE
    ${CMAKE_CURRENT_LIST_DIR}/drvglobal.cpp
    ${CMAKE_CURRENT_LIST_DIR}/main.cpp
    ${CMAKE_CURRENT_LIST_DIR}/handler.cpp
    ${CMAKE_CURRENT_LIST_DIR}/path.cpp
    ${CMAKE_CURRENT_LIST_DIR}/known_dlls.cpp
    ${CMAKE_CURRENT_LIST_DIR}/hook.cpp
    ${CMAKE_CURRENT_LIST_DIR}/arch.cpp
    )
```

`src/arch.cpp`:

```cpp
#include "arch.h"
#include "raii.hpp"

/// figure out the architecture of a peprocess
arch proc_arch(PEPROCESS p) {
	KAPC_STATE state;
	KeStackAttachProcess(p, &state);
	bind_kapc_state(&state);

	arch a;

	#ifdef _WIN64
	if (IoIs32bitProcess(NULL)) {
		a.b = bit::x32;
		a.com = compat::wow;
	}
	else {
		a.b = bit::x64;
		a.com = compat::native;
	}
	#else
	a.b = bit::x32;
	a.com = compat::native;
	#endif

	return a;
}
```

`src/drvglobal.cpp`:

```cpp
#include "drvglobal.h"

driverctx GLOBAL = { 0 };
```

`src/handler.cpp`:

```cpp
#include "handler.h"
#include "log.h"
#include "raii.hpp"
#include "undocumented.h"
#include "path.h"
#include "hook.h"
#include "known_dlls.h"
#include "pointers.h"
#include "drvglobal.h"
#include "arch.h"

#include <ntimage.h>

RTL_RUN_ONCE init_native;
RTL_RUN_ONCE init_wow64;

ULONG init_lazy(PRTL_RUN_ONCE run_once, PVOID a, PVOID* ctx) {
	UNREFERENCED_PARAMETER(run_once);
	UNREFERENCED_PARAMETER(ctx);
	NTSTATUS status = STATUS_SUCCESS;

	log_debug("reg path: %wZ", GLOBAL.registry_path);
	log_debug("drv object: %p", GLOBAL.obj);

	// init known dlls
	for (const UNICODE_STRING& filename : KNOWN_DLLS)
		if (!NT_SUCCESS(add_known_dll(&filename, *reinterpret_cast<arch*>(a)))) break;

	return NT_SUCCESS(status);
}

NTSTATUS on_image_load_status(PUNICODE_STRING path, HANDLE pid, PIMAGE_INFO info) {
	NTSTATUS status = STATUS_SUCCESS;

	// only userland images
	if (info->SystemModeImage) return status;
	// we don't care about remotely loaded images
	if (PsGetCurrentProcessId() != pid) return status;
	// trigger on first k32dll load
	UNICODE_STRING k32_filename = RTL_CONSTANT_STRING(L"kernel32.dll");
	if (! match_filename(path, &k32_filename)) return status;

	PEPROCESS p;
	status = PsLookupProcessByProcessId(pid, &p);
	guard_nts(status, "failed getting PEPROCESS for pid %p; status: %lx", pid, status);
	bind_peprocess(p);

	auto a = proc_arch(p);
	switch(a.com) {
		case compat::native:
			RtlRunOnceExecuteOnce(&init_native, init_lazy, &a, nullptr);
			break;
		case compat::wow:
			RtlRunOnceExecuteOnce(&init_wow64, init_lazy, &a, nullptr);
			break;
	}

	return status;
}

NTSTATUS on_create_proc_status(HANDLE parent_pid, HANDLE pid, BOOLEAN create) {
	NTSTATUS status = STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(parent_pid);

	if (!create) return status;

	PEPROCESS p;
	status = PsLookupProcessByProcessId(pid, &p);
	guard_nts(status, "failed getting PEPROCESS for pid %p; status: %lx", pid, status);
	bind_peprocess(p);

	arch a = proc_arch(p);

	// attach to target process address space
	KAPC_STATE state;
	KeStackAttachProcess(p, &state);
	bind_kapc_state(&state);

	auto base = reinterpret_cast<IMAGE_DOS_HEADER*>(PsGetProcessSectionBaseAddress(p));
	void* entrypoint = nullptr;

	// get entrypoint va
	if (a.b == bit::x32) {
		auto nt = addroffset(IMAGE_NT_HEADERS32, base, base->e_lfanew);
		entrypoint = addroffset(void, base, nt->OptionalHeader.AddressOfEntryPoint);
	}
	else {
		auto nt = addroffset(IMAGE_NT_HEADERS64, base, base->e_lfanew);
		entrypoint = addroffset(void, base, nt->OptionalHeader.AddressOfEntryPoint);
	}

	const char* procname = PsGetProcessImageFileName(p);
	log_debug("got image name for process: %s", procname);
	//if(strcmp(procname, "notepad.exe")) return status;

	mitigation_flags1* flags1 = addroffset(mitigation_flags1, p, MITIGATION_OFFSET);
	//mitigation_flags2* flags2 = addroffset(mitigation_flags2, p, MITIGATION_OFFSET + sizeof(ULONG));
	
	flags1->DisableDynamicCode = false;
	
	log_debug("disabled dynamic code mitigation policy");

	HANDLE hproc;
	status = ObOpenObjectByPointer(p, OBJ_KERNEL_HANDLE, NULL, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, &hproc);
	guard_nts(status, "ObOpenObjectByPointer(target process) failed with %lx in process %s", status, procname);
	bind_handle(hproc);

	void* shellcode_mem = nullptr;
	SIZE_T shellcode_mem_sz = 1000;
	status = ZwAllocateVirtualMemory(hproc, &shellcode_mem, NULL, &shellcode_mem_sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	guard_nts(status, "ZwAllocateVirtualMemory shellcode allocation failed with status: %lx; in proc %s", status, procname)
	log_debug("shellcode allocated @ %p", shellcode_mem);

	SIZE_T protect_sz = 1000;
	ULONG old_page_protection;
	void* protect_addr = entrypoint;
	status = ZwProtectVirtualMemory(hproc, &protect_addr, &protect_sz, PAGE_READWRITE, &old_page_protection);
	guard_nts(status, "ZwProtectVirtualMemory failed setting entrypoint protection to PAGE_READWRITE; "
		"status: %lx; "
		"addr: %p; ",
		status, protect_addr);

	if (a.b == bit::x64) hook64(entrypoint, shellcode_mem);
	else hook32(entrypoint, shellcode_mem);

	status = ZwProtectVirtualMemory(hproc, &protect_addr, &protect_sz, old_page_protection, &old_page_protection);
	guard_nts(status, "ZwProtectVirtualMemory failed restoring entrypoint protection; "
		"status: %lx; "
		"addr: %p; ",
		status, protect_addr);

	protect_addr = shellcode_mem;
	protect_sz = 1000;
	status = ZwProtectVirtualMemory(hproc, &protect_addr, &protect_sz, PAGE_EXECUTE_READ, &old_page_protection);
	guard_nts(status, "ZwProtectVirtualMemory failed setting shellcode protection to PAGE_EXECUTE_READ; "
		"status: %lx; "
		"addr: %p; ",
		status, protect_addr);

	return status;
}

void on_create_proc(HANDLE parent_pid, HANDLE pid, BOOLEAN create) {
	NTSTATUS status = on_create_proc_status(parent_pid, pid, create);
	if (!NT_SUCCESS(status)) log_error("PsSetCreateProcessNotifyRoutine callback failed with status: %lx", status);
}

void on_image_load(PUNICODE_STRING path, HANDLE pid, PIMAGE_INFO info) {
	NTSTATUS status = on_image_load_status(path, pid, info);
	if (!NT_SUCCESS(status)) log_error("PloadImageNotifyRoutine callback failed with status: %lx", status);
}
```

`src/hook.cpp`:

```cpp
#include "hook.h"
#include "undocumented.h"
#include "tibpebwow64.h"
#include "pointers.h"
#include "log.h"

#include <stddef.h>
#include <ntimage.h>

template <int N>
void write_bytes(void** target, const UINT8 (&bytes)[N]) {
	memcpy(*target, bytes, sizeof(bytes));
	*reinterpret_cast<UINT8**>(target) += sizeof(bytes);
}

template <int N>
void write_str(void** target, const char(&bytes)[N]) {
	memcpy(*target, bytes, sizeof(bytes));
	*reinterpret_cast<UINT8**>(target) += sizeof(bytes);
}

template <int N>
void write_wstr(void** target, const wchar_t(&bytes)[N]) {
	memcpy(*target, bytes, sizeof(bytes));
	*reinterpret_cast<UINT8**>(target) += sizeof(bytes);
}

template <class T>
void write_type(void** target, T value) {
	**reinterpret_cast<T**>(target) = value;
	*reinterpret_cast<UINT8**>(target) += sizeof(T);
}

/// <summary>
/// hooks function to call target
/// </summary>
/// <param name="func">function to hook</param>
/// <param name="target">where to jump to</param>
void hook32(void* func, void* target) {
	void* func_start = func;

	// data "segment"

	// save original code
	void* original = target;
	memcpy(target, func, STUB_SIZE32);
	target = addroffset(void, target, STUB_SIZE32);

	void* module_file = target;
	const wchar_t module_file_str[] = L"gi_agent.dll";
	write_wstr(&target, module_file_str);

	// write UNICODE_STRING for module_file
	void* module_file_unicode = target;
	UNICODE_STRING32 module_file_unicode_str;
	// length (not including null terminator)
	module_file_unicode_str.Length = sizeof(module_file_str) - sizeof(module_file_str[0]);
	// maximum length (including null terminator)
	module_file_unicode_str.MaximumLength = sizeof(module_file_str);
	// buffer; ptr to actual wstr
	module_file_unicode_str.Buffer = towow64(module_file);
	write_type<UNICODE_STRING32>(&target, module_file_unicode_str);

	// overwrite original code
	// jmp shellcode
	write_bytes(&func, { 0xe9 });
	write_type<INT32>(&func, static_cast<INT32>(addr_relative_to(target, func)) - sizeof(INT32));

	// push parameters
	write_bytes(&target, { 0x68 }); // push
	write_type<UINT32>(&target, towow64(original));

	write_bytes(&target, { 0x68 }); // push
	write_type<UINT32>(&target, STUB_SIZE32);

	write_bytes(&target, { 0x68 }); // push
	write_type<UINT32>(&target, towow64(module_file_unicode));

	// not needed anymore but im keeping it so i dont have to change the shellcode :p
	write_bytes(&target, { 0x68 }); // push
	write_type<UINT32>(&target, sizeof(module_file_str));

	write_bytes(&target, { 0x68 }); // push
	write_type<UINT32>(&target, towow64(func_start));

	write_bytes(&target, ARR_SHELLCODE32);
}

void hook64(void* func, void* target) {
	void* func_start = func;

	void* shellcode = target;
	write_bytes(&target, ARR_SHELLCODE64);

	// data "segment"

	// save original code
	void* original = target;
	memcpy(target, func, STUB_SIZE64);
	target = addroffset(void, target, STUB_SIZE64);

	void* module_file = target;
	const wchar_t module_file_str[] = L"gi_agent.dll";
	write_wstr(&target, module_file_str);

	// write UNICODE_STRING for module_file
	void* module_file_unicode = target;
	UNICODE_STRING64 module_file_unicode_str;
	// length (not including null terminator)
	module_file_unicode_str.Length = sizeof(module_file_str) - sizeof(module_file_str[0]);
	// maximum length (including null terminator)
	module_file_unicode_str.MaximumLength = sizeof(module_file_str);
	// buffer; ptr to actual wstr
	module_file_unicode_str.Buffer = reinterpret_cast<ULONGLONG>(module_file);
	write_type<UNICODE_STRING64>(&target, module_file_unicode_str);

	// shellcode stub
	void* shellcode_stub = target;

	// save volatile registers
	write_bytes(&target, { 0x50 }); // push rax
	write_bytes(&target, { 0x51 }); // push rcx
	write_bytes(&target, { 0x52 }); // push rdx
	write_bytes(&target, { 0x41, 0x50 }); // push r8
	write_bytes(&target, { 0x41, 0x51 }); // push r9
	write_bytes(&target, { 0x41, 0x52 }); // push r10
	write_bytes(&target, { 0x41, 0x53 }); // push r11

	// set parameters
	write_bytes(&target, { 0x48, 0xb9 }); // rcx = original_func*
	write_type<void*>(&target, func_start);

	write_bytes(&target, { 0x48, 0xba }); // rdx = dllname*
	write_type<void*>(&target, module_file_unicode);

	write_bytes(&target, { 0x41, 0xb8 }); // r8 = original_code_sz
	write_type<UINT32>(&target, STUB_SIZE64);

	write_bytes(&target, { 0x49, 0xb9 }); // r9 = original_code*
	write_type<void*>(&target, original);

	write_bytes(&target, { 0xe8 }); // call shellcode
	write_type<UINT32>(&target, addr_relative_to(shellcode, target) - sizeof(UINT32));

	write_bytes(&target, { 0x41, 0x5b }); // pop r11
	write_bytes(&target, { 0x41, 0x5a }); // pop r10
	write_bytes(&target, { 0x41, 0x59 }); // pop r9
	write_bytes(&target, { 0x41, 0x58 }); // pop r8
	write_bytes(&target, { 0x5a }); // pop rdx
	write_bytes(&target, { 0x59 }); // pop rcx
	write_bytes(&target, { 0x58 }); // pop rax

	// jmp back
	write_bytes(&target, stub64);
	write_type<void*>(&target, func_start);

	// overwrite original code
	// jmp shellcode
	write_bytes(&func, stub64);
	write_type<void*>(&func, shellcode_stub);
}
```

`src/known_dlls.cpp`:

```cpp
#include "known_dlls.h"
#include "raii.hpp"
#include "log.h"
#include "drvglobal.h"
#include "undocumented.h"

#include <minwindef.h>

constexpr auto SEC_IMAGE = 0x01000000;

NTSTATUS known_dll_exists(const UNICODE_STRING* filename, bool native_arch, bool* exists) {
	NTSTATUS status = STATUS_SUCCESS;

	// initialize attributes for agent knowndll object
	OBJECT_ATTRIBUTES obj_attr;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING obj_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING obj_path_known_dlls;
		if (native_arch) obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls\\");
		else             obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls32\\");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, &obj_path_known_dlls);
		guard_nts(status, "knowndlls path exceeds max path length: %d", obj_path_agent.MaximumLength);
		status = RtlAppendUnicodeStringToString(&obj_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&obj_attr, &obj_path_agent, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, NULL);
	}

	HANDLE obj_handle;
	status = ZwOpenSection(&obj_handle, SECTION_MAP_EXECUTE | SECTION_QUERY, &obj_attr);
	if(status == STATUS_OBJECT_NAME_NOT_FOUND) {
		*exists = false;
		status = STATUS_SUCCESS;
	} else { *exists = true; }
	guard_nts(status, "ZwOpenSection(agent) failed with: %x", status);
	bind_handle(obj_handle);

	return status;
}

NTSTATUS remove_known_dll(const UNICODE_STRING* filename, bool native_arch) {
	NTSTATUS status = STATUS_SUCCESS;
	bool exists;
	status = known_dll_exists(filename, native_arch, &exists);
	guard_nts(status, "failed checking if known dll already exists while removing it", status);
	if (! exists) return status;

	// initialize attributes for agent knowndll object
	OBJECT_ATTRIBUTES obj_attr;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING obj_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING obj_path_known_dlls;
		if (native_arch) obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls\\");
		else             obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls32\\");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, &obj_path_known_dlls);
		guard_nts(status, "knowndlls path exceeds max path length: %d", obj_path_agent.MaximumLength);
		status = RtlAppendUnicodeStringToString(&obj_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&obj_attr, &obj_path_agent, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, NULL);
	}

	HANDLE obj_handle;
	status = ZwOpenSection(&obj_handle, SECTION_MAP_EXECUTE | SECTION_QUERY, &obj_attr);
	guard_nts(status, "ZwOpenSection(agent) failed with: %x", status);
	bind_handle(obj_handle);

	ZwMakeTemporaryObject(obj_handle);

	return status;
}

template <int N>
NTSTATUS alloc_sid(SID** sid, ULONG tag, PSID_IDENTIFIER_AUTHORITY auth_id, const ULONG (&subauthorities)[N]) {
	NTSTATUS status = STATUS_SUCCESS;

	// allocate sid (dynamic array)
	// prolly allocates an extra ULONG but better safe than sorry
	*sid = reinterpret_cast<SID*>(ExAllocatePoolWithTag(PagedPool, sizeof(SID) + sizeof(subauthorities), tag));
	if (! *sid) return STATUS_MEMORY_NOT_ALLOCATED;

	// initialize sid
	status = RtlInitializeSid(*sid, auth_id, sizeof(subauthorities) / sizeof(subauthorities[0]));
	guard_nts(status, "RtlInitializeSid failed with %x", status);

	// copy each subauthority
	for(size_t i = 0; i < sizeof(subauthorities) / sizeof(subauthorities[0]); i++) {
		PULONG subauth = RtlSubAuthoritySid(*sid, i);
		if (! subauth) return STATUS_INVALID_SID;
		*subauth = subauthorities[i];
	}

	if (! RtlValidSid(*sid)) {
		log_error("created invalid security descrriptor");
		return STATUS_INVALID_SID;
	}

	return status;
}

NTSTATUS create_known_dlls(bool native_arch) {
	NTSTATUS status = STATUS_SUCCESS;

	SECURITY_DESCRIPTOR* desc = reinterpret_cast<SECURITY_DESCRIPTOR*>(
		ExAllocatePoolWithTag(PagedPool, sizeof(SECURITY_DESCRIPTOR), 'csed'));

	bind_alloc(desc);
	status = RtlCreateSecurityDescriptor(desc, SECURITY_DESCRIPTOR_REVISION);
	guard_nts(status, "RtlCreateSecurityDescriptor failed with: %x", status);
	//desc->Control |= SE_SACL_AUTO_INHERITED;

	SID* sid_admins = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_authnt = SECURITY_NT_AUTHORITY;
	status = alloc_sid(&sid_admins, 'disa', &ident_authnt, { SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_admins);
	guard_nts(status, "alloc_sid failed with %x", status);

	status = RtlSetOwnerSecurityDescriptor(desc, sid_admins, false);
	guard_nts(status, "RtlSetOwnerSecurityDescriptor(sid_admins) failed with %x", status);

	ULONG dacl_len = sizeof(ACL);

	// create ace sids

	// everyone sid for ace
	SID* sid_everyone = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_world = SECURITY_WORLD_SID_AUTHORITY;
	status = alloc_sid(&sid_everyone, 'dise', &ident_world, { SECURITY_WORLD_RID });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_everyone);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_everyone) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "all application packages" sid for ace
	SID* sid_all_apps = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_apps = SECURITY_APP_PACKAGE_AUTHORITY;
	status = alloc_sid(&sid_all_apps, 'disp', &ident_apps, { SECURITY_APP_PACKAGE_BASE_RID, SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_all_apps);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_all_apps) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "restricted application packages" sid for ace
	SID* sid_restricted_apps = nullptr;
	status = alloc_sid(
		&sid_restricted_apps,
		'disp',
		&ident_apps,
		{ SECURITY_APP_PACKAGE_BASE_RID, SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE });

	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_restricted_apps);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_restricted_apps) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "restricted" sid for ace
	SID* sid_restricted = nullptr;
	status = alloc_sid(&sid_restricted, 'disr', &ident_authnt, { SECURITY_RESTRICTED_CODE_RID });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_restricted);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_restricted) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "administrator" sid for ace
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_admins) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	ACL* dacl = reinterpret_cast<ACL*>(ExAllocatePoolWithTag(PagedPool, dacl_len, 'lcad'));
	if (! dacl) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(dacl);

	status = RtlCreateAcl(dacl, dacl_len, ACL_REVISION);
	guard_nts(status, "RtlCreateAcl(dacl) failed with %x", status);

	ACCESS_MASK mask_section_rw = SECTION_QUERY | SECTION_MAP_WRITE;

	// access allowed administrators ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, sid_admins);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed everyone ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rw, sid_everyone);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed all application packages ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rw, sid_all_apps);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed restricted application packages ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rw, sid_restricted_apps);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed restricted ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rw, sid_restricted);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	ULONG sacl_len = sizeof(ACL);

	// "trust label" sid for ace
	SID* sid_trust_label = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_trust = SECURITY_PROCESS_TRUST_AUTHORITY;
	status = alloc_sid(
		&sid_trust_label,
		'dist',
		&ident_trust,
		{ SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID, SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID });

	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_trust_label);
	guard_nts(status, "alloc_sid failed with %x", status);
	ULONG ace_trust_len = 
		sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE)
		+ RtlLengthSid(sid_trust_label)
		- sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE::SidStart);
	sacl_len += ace_trust_len;

	ACL* sacl = reinterpret_cast<ACL*>(ExAllocatePoolWithTag(PagedPool, sacl_len, 'lcas'));
	if (! sacl) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(sacl);

	status = RtlCreateAcl(sacl, sacl_len, ACL_REVISION);
	guard_nts(status, "RtlCreateAcl(sacl) failed with %x", status);

	// allocate trust label ace
	SYSTEM_PROCESS_TRUST_LABEL_ACE* ace_trust = reinterpret_cast<SYSTEM_PROCESS_TRUST_LABEL_ACE*>(
		ExAllocatePoolWithTag(PagedPool, ace_trust_len, 'ecat'));

	if (! ace_trust) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(ace_trust);

	// initialize ace
	memset(ace_trust, 0, ace_trust_len);
	ace_trust->Header.AceSize = ace_trust_len;
	ace_trust->Header.AceType = SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE;
	ace_trust->Mask = READ_CONTROL | mask_section_rw;
	// [GlobalInject][error] ZwCreateSection(agent) failed with: c0000022
	status = RtlCopySid(
			ace_trust_len
			- sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE)
			+ sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE::SidStart),
		reinterpret_cast<PSID>(&ace_trust->SidStart),
		sid_trust_label);

	guard_nts(status, "RtlCopySid(trust_level_sid) failed with %x", status);

	// add ace
	status = RtlAddAce(sacl, ACL_REVISION, MAXULONG, ace_trust, ace_trust_len);
	guard_nts(status, "RtlAddAce(sacl, trust_label_ace) failed with %x", status);

	status = RtlSetDaclSecurityDescriptor(desc, true, dacl, false);
	guard_nts(status, "RtlSetDaclSecurityDescriptor failed with %x", status);

	status = RtlSetSaclSecurityDescriptor(desc, true, sacl, false);
	guard_nts(status, "RtlSetSaclSecurityDescriptor failed with %x", status);

	if (! RtlValidSecurityDescriptor(desc)) {
		log_error("invalid security descriptor for agent section");
		return STATUS_INVALID_SECURITY_DESCR;
	}

	// initialize attributes for agent knowndll object
	OBJECT_ATTRIBUTES known_dlls_attr;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING obj_path_known_dlls;
		if (native_arch) obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls_2\\");
		else             obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls32_2\\");

		InitializeObjectAttributes(&known_dlls_attr, &obj_path_known_dlls, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, desc);
	}

	// TODO: if this doesn't work, let's make a new onimageload hook only for knowndll initializing
	// should've done this in the first place lol

	HANDLE known_dlls_hwnd;
	status = ZwCreateDirectoryObject(&known_dlls_hwnd, DIRECTORY_CREATE_OBJECT, &known_dlls_attr);
	guard_nts(status, "error creating knowndlls directory: %x", status);

	return status;
}

/// <summary>
/// adds a knowndll to the obj storage
/// </summary>
/// <returns></returns>
NTSTATUS add_known_dll(const UNICODE_STRING* filename, arch a) {
	NTSTATUS status = STATUS_SUCCESS;
	log_debug("adding known dll %wZ", filename);

	// attach to wintcb signed system process
	KAPC_STATE state;
	KeStackAttachProcess(PsInitialSystemProcess, &state);
	bind_kapc_state(&state);

	// object attributes for kernel32 section
	// were gonna copy the kernel32 security descriptor
	// first i made my own but trust me this is much more stable
	OBJECT_ATTRIBUTES obj_attr_k32;
	{
		UNICODE_STRING obj_path_k32;
		if (a.com == compat::native) obj_path_k32 = RTL_CONSTANT_STRING(L"\\KnownDlls\\kernel32.dll");
		else                         obj_path_k32 = RTL_CONSTANT_STRING(L"\\KnownDlls32\\kernel32.dll");

		InitializeObjectAttributes(&obj_attr_k32, &obj_path_k32, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, NULL);
	}

	HANDLE hk32;
	status = ZwOpenSection(&hk32, READ_CONTROL, &obj_attr_k32);
	guard_nts(status, "failed to open k32 section obj handle: %x", status);

	ULONG sd_size = 0;
	SECURITY_INFORMATION sd_info =
		PROCESS_TRUST_LABEL_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		LABEL_SECURITY_INFORMATION |
		OWNER_SECURITY_INFORMATION;

	status = ZwQuerySecurityObject(hk32, sd_info, nullptr, sd_size, &sd_size);
	if (status != STATUS_BUFFER_TOO_SMALL) {
		log_error("getting k32 sd size failed with: %x", status);
		return status;
	}

	SECURITY_DESCRIPTOR* k32_sd = reinterpret_cast<SECURITY_DESCRIPTOR*>(
		ExAllocatePoolWithTag(PagedPool, sd_size, 'd23k'));
	bind_alloc(k32_sd);

	status = ZwQuerySecurityObject(hk32, sd_info, k32_sd, sd_size, &sd_size);
	guard_nts(status, "getting k32 sd failed with: %x", status);
	if (! RtlValidSecurityDescriptor(k32_sd)) {
		log_error("invalid k32 security descriptor");
		return STATUS_INVALID_SECURITY_DESCR;
	}

	// initialize attributes for agent knowndll object
	OBJECT_ATTRIBUTES obj_attr_agent;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING obj_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING obj_path_known;
		if (a.com == compat::native) obj_path_known = RTL_CONSTANT_STRING(L"\\KnownDlls\\");
		else                         obj_path_known = RTL_CONSTANT_STRING(L"\\KnownDlls32\\");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, &obj_path_known);
		guard_nts(status, "knowndlls path exceeds max path length");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&obj_attr_agent, &obj_path_agent, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, k32_sd);
	}

	// initialize attributes for agent disk image
	OBJECT_ATTRIBUTES disk_attr_agent;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING disk_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING disk_path_system;
		if (a.com == compat::native) disk_path_system = RTL_CONSTANT_STRING(L"\\systemroot\\system32\\");
		else             	         disk_path_system = RTL_CONSTANT_STRING(L"\\systemroot\\syswow64\\");
		status = RtlAppendUnicodeStringToString(&disk_path_agent, &disk_path_system);
		guard_nts(status, "system path exceeds max path length");
		status = RtlAppendUnicodeStringToString(&disk_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&disk_attr_agent, &disk_path_agent, OBJ_CASE_INSENSITIVE, NULL, NULL);
	}

	HANDLE disk_handle_agent;
	IO_STATUS_BLOCK disk_iosb_agent;

	// create agent.dll knowndlls segment

	status = ZwOpenFile(
		&disk_handle_agent,
		FILE_GENERIC_READ | FILE_EXECUTE,
		&disk_attr_agent,
		&disk_iosb_agent,
		FILE_SHARE_READ,
		FILE_SYNCHRONOUS_IO_NONALERT);

	guard_nts(status, "ZwOpenFile(agent) failed with: %x", status);
	bind_handle(disk_handle_agent);

	HANDLE handle_section_agent;
	status = ZwCreateSection(
		&handle_section_agent,
		SECTION_MAP_EXECUTE | SECTION_QUERY,
		&obj_attr_agent,
		0,
		PAGE_EXECUTE,
		SEC_IMAGE,
		disk_handle_agent);

	guard_nts(status, "ZwCreateSection(agent) failed with: %x", status);
	bind_handle(handle_section_agent);

	//status = ObReferenceObjectByHandleWithTag(handle_section_agent, 0, NULL, KernelMode, 'esga', section, NULL);
	//guard_nts(status, "ObReferenceObjectByHandleWithTag(handle_section_agent) failed with: %x", status);

	return status;
}

/// <summary>
/// adds a knowndll to the obj storage
/// </summary>
/// <returns></returns>
/*
NTSTATUS add_known_dll(const UNICODE_STRING* filename, bool native_arch) {
	NTSTATUS status = STATUS_SUCCESS;
	log_debug("adding known dll %wZ | is_native: %d", filename, native_arch);

	status = create_known_dlls(native_arch);
	guard_nts(status, "error creating knowndlls: %x", status);

	bool exists;
	status = known_dll_exists(filename, native_arch, &exists);
	guard_nts(status, "failed checking if known dll already exists while adding it", status);
	if (exists) return status;

	// escalate to system process
	KAPC_STATE state;
	KeStackAttachProcess(PsInitialSystemProcess, &state);
	bind_kapc_state(&state);
	log_debug("attached to system process");

	// initialize empty security descriptor

	SECURITY_DESCRIPTOR* desc = reinterpret_cast<SECURITY_DESCRIPTOR*>(
		ExAllocatePoolWithTag(PagedPool, sizeof(SECURITY_DESCRIPTOR), 'csed'));
	bind_alloc(desc);
	status = RtlCreateSecurityDescriptor(desc, SECURITY_DESCRIPTOR_REVISION);
	guard_nts(status, "RtlCreateSecurityDescriptor failed with: %x", status);
	//desc->Control |= SE_SACL_AUTO_INHERITED;

	SID* sid_admins = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_authnt = SECURITY_NT_AUTHORITY;
	status = alloc_sid(&sid_admins, 'disa', &ident_authnt, { SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_admins);
	guard_nts(status, "alloc_sid failed with %x", status);

	status = RtlSetOwnerSecurityDescriptor(desc, sid_admins, false);
	guard_nts(status, "RtlSetOwnerSecurityDescriptor(sid_admins) failed with %x", status);

	ULONG dacl_len = sizeof(ACL);

	// create ace sids

	// everyone sid for ace
	SID* sid_everyone = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_world = SECURITY_WORLD_SID_AUTHORITY;
	status = alloc_sid(&sid_everyone, 'dise', &ident_world, { SECURITY_WORLD_RID });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_everyone);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_everyone) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "all application packages" sid for ace
	SID* sid_all_apps = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_apps = SECURITY_APP_PACKAGE_AUTHORITY;
	status = alloc_sid(&sid_all_apps, 'disp', &ident_apps, { SECURITY_APP_PACKAGE_BASE_RID, SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_all_apps);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_all_apps) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "restricted application packages" sid for ace
	SID* sid_restricted_apps = nullptr;
	status = alloc_sid(
		&sid_restricted_apps,
		'disp',
		&ident_apps,
		{ SECURITY_APP_PACKAGE_BASE_RID, SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE });

	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_restricted_apps);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_restricted_apps) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "restricted" sid for ace
	SID* sid_restricted = nullptr;
	status = alloc_sid(&sid_restricted, 'disr', &ident_authnt, { SECURITY_RESTRICTED_CODE_RID });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_restricted);
	guard_nts(status, "alloc_sid failed with %x", status);
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_restricted) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	// "administrator" sid for ace
	dacl_len += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_admins) - sizeof(ACCESS_ALLOWED_ACE::SidStart);

	ACL* dacl = reinterpret_cast<ACL*>(ExAllocatePoolWithTag(PagedPool, dacl_len, 'lcad'));
	if (! dacl) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(dacl);

	status = RtlCreateAcl(dacl, dacl_len, ACL_REVISION);
	guard_nts(status, "RtlCreateAcl(dacl) failed with %x", status);

	ACCESS_MASK mask_section_rwx = SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE;

	// access allowed everyone ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rwx, sid_everyone);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed all application packages ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rwx, sid_all_apps);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed restricted application packages ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rwx, sid_restricted_apps);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed restricted ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, READ_CONTROL | mask_section_rwx, sid_restricted);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	// access allowed administrators ace
	status = RtlAddAccessAllowedAce(dacl, ACL_REVISION, STANDARD_RIGHTS_REQUIRED | mask_section_rwx | SECTION_EXTEND_SIZE, sid_admins);
	guard_nts(status, "RtlAddAccessAllowedAce(sid_everyone) failed with %x", status);

	ULONG sacl_len = sizeof(ACL);

	// "low manditory label" sid for ace
	SID* sid_low_manditory = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_manditory = SECURITY_MANDATORY_LABEL_AUTHORITY;
	status = alloc_sid(&sid_low_manditory, 'dism', &ident_manditory, { SECURITY_MANDATORY_LOW_RID });
	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_low_manditory);
	guard_nts(status, "alloc_sid failed with %x", status);
	ULONG ace_manditory_len =
		sizeof(SYSTEM_MANDATORY_LABEL_ACE)
		+ RtlLengthSid(sid_low_manditory)
		- sizeof(SYSTEM_MANDATORY_LABEL_ACE::SidStart);
	sacl_len += ace_manditory_len;

	// "trust label" sid for ace
	SID* sid_trust_label = nullptr;
	SID_IDENTIFIER_AUTHORITY ident_trust = SECURITY_PROCESS_TRUST_AUTHORITY;
	status = alloc_sid(
		&sid_trust_label,
		'dist',
		&ident_trust,
		{ SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID, SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID });

	// alloc_res should protect us from a double free here but im just gonna make sure
	if(status == STATUS_MEMORY_NOT_ALLOCATED) return status;
	bind_alloc(sid_trust_label);
	guard_nts(status, "alloc_sid failed with %x", status);
	ULONG ace_trust_len = 
		sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE)
		+ RtlLengthSid(sid_trust_label)
		- sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE::SidStart);
	sacl_len += ace_trust_len;

	ACL* sacl = reinterpret_cast<ACL*>(ExAllocatePoolWithTag(PagedPool, sacl_len, 'lcas'));
	if (! sacl) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(sacl);

	status = RtlCreateAcl(sacl, sacl_len, ACL_REVISION);
	guard_nts(status, "RtlCreateAcl(sacl) failed with %x", status);

	// create and add aces to the sacl

	// allocate manditory ace
	SYSTEM_MANDATORY_LABEL_ACE* ace_manditory = reinterpret_cast<SYSTEM_MANDATORY_LABEL_ACE*>(
		ExAllocatePoolWithTag(PagedPool, ace_manditory_len, 'ecam'));
	if (! ace_manditory) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(ace_manditory);

	// initialize ace
	memset(ace_manditory, 0, ace_manditory_len);
	ace_manditory->Header.AceSize = ace_manditory_len;
	ace_manditory->Header.AceType = SYSTEM_MANDATORY_LABEL_ACE_TYPE;
	ace_manditory->Mask = SYSTEM_MANDATORY_LABEL_NO_WRITE_UP;
	status = RtlCopySid(
			ace_manditory_len
			- sizeof(SYSTEM_MANDATORY_LABEL_ACE)
			+ sizeof(SYSTEM_MANDATORY_LABEL_ACE::SidStart),
		reinterpret_cast<PSID>(&ace_manditory->SidStart),
		sid_low_manditory);

	guard_nts(status, "RtlCopySid(low_mandatory_level_sid) failed with %x", status);

	// add ace
	status = RtlAddAce(sacl, ACL_REVISION, MAXULONG, ace_manditory, ace_manditory_len);
	guard_nts(status, "RtlAddAce(sacl, mandatory_label_ace) failed with %x", status);

	// allocate trust label ace
	SYSTEM_PROCESS_TRUST_LABEL_ACE* ace_trust = reinterpret_cast<SYSTEM_PROCESS_TRUST_LABEL_ACE*>(
		ExAllocatePoolWithTag(PagedPool, ace_trust_len, 'ecat'));

	if (! ace_trust) return STATUS_MEMORY_NOT_ALLOCATED;
	bind_alloc(ace_trust);

	// initialize ace
	memset(ace_trust, 0, ace_trust_len);
	ace_trust->Header.AceSize = ace_trust_len;
	ace_trust->Header.AceType = SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE;
	ace_trust->Mask = READ_CONTROL | mask_section_rwx;
	// [GlobalInject][error] ZwCreateSection(agent) failed with: c0000022
	status = RtlCopySid(
			ace_trust_len
			- sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE)
			+ sizeof(SYSTEM_PROCESS_TRUST_LABEL_ACE::SidStart),
		reinterpret_cast<PSID>(&ace_trust->SidStart),
		sid_trust_label);

	guard_nts(status, "RtlCopySid(trust_level_sid) failed with %x", status);

	// add ace
	status = RtlAddAce(sacl, ACL_REVISION, MAXULONG, ace_trust, ace_trust_len);
	guard_nts(status, "RtlAddAce(sacl, trust_label_ace) failed with %x", status);

	status = RtlSetDaclSecurityDescriptor(desc, true, dacl, false);
	guard_nts(status, "RtlSetDaclSecurityDescriptor failed with %x", status);

	status = RtlSetSaclSecurityDescriptor(desc, true, sacl, false);
	guard_nts(status, "RtlSetSaclSecurityDescriptor failed with %x", status);

	if (! RtlValidSecurityDescriptor(desc)) {
		log_error("invalid security descriptor for agent section");
		return STATUS_INVALID_SECURITY_DESCR;
	}

	// initialize attributes for agent knowndll object
	OBJECT_ATTRIBUTES obj_attr_agent;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING obj_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING obj_path_known_dlls;
		if (native_arch) obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls\\");
		else             obj_path_known_dlls = RTL_CONSTANT_STRING(L"\\KnownDlls32\\");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, &obj_path_known_dlls);
		guard_nts(status, "knowndlls path exceeds max path length");
		status = RtlAppendUnicodeStringToString(&obj_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&obj_attr_agent, &obj_path_agent, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, desc);
	}

	// initialize attributes for agent disk image
	OBJECT_ATTRIBUTES disk_attr_agent;
	{
		wchar_t pathbuf[MAX_PATH] = { 0 };
		UNICODE_STRING disk_path_agent = { 0, sizeof(pathbuf), pathbuf };
		UNICODE_STRING disk_path_system;
		if (native_arch) disk_path_system = RTL_CONSTANT_STRING(L"\\systemroot\\system32\\");
		else             disk_path_system = RTL_CONSTANT_STRING(L"\\systemroot\\syswow64\\");
		status = RtlAppendUnicodeStringToString(&disk_path_agent, &disk_path_system);
		guard_nts(status, "system path exceeds max path length");
		status = RtlAppendUnicodeStringToString(&disk_path_agent, filename);
		guard_nts(status, "agent filename exceeds max path length");

		InitializeObjectAttributes(&disk_attr_agent, &disk_path_agent, OBJ_CASE_INSENSITIVE, NULL, NULL);
	}

	HANDLE disk_handle_agent;
	IO_STATUS_BLOCK disk_iosb_agent;

	// create agent.dll knowndlls segment

	status = ZwOpenFile(
		&disk_handle_agent,
		FILE_GENERIC_READ | FILE_EXECUTE,
		&disk_attr_agent,
		&disk_iosb_agent,
		FILE_SHARE_READ,
		FILE_SYNCHRONOUS_IO_NONALERT);

	guard_nts(status, "ZwOpenFile(agent) failed with: %x ; native: %d", status, native_arch);
	bind_handle(disk_handle_agent);

	HANDLE handle_section_agent;
	status = ZwCreateSection(
		&handle_section_agent,
		SECTION_MAP_EXECUTE | SECTION_QUERY,
		&obj_attr_agent,
		0,
		PAGE_EXECUTE,
		SEC_IMAGE,
		disk_handle_agent);

	guard_nts(status, "ZwCreateSection(agent) failed with: %x ; native: %d", status, native_arch);
	bind_handle(handle_section_agent);

	//status = ObReferenceObjectByHandleWithTag(handle_section_agent, 0, NULL, KernelMode, 'esga', section, NULL);
	//guard_nts(status, "ObReferenceObjectByHandleWithTag(handle_section_agent) failed with: %x", status);

	return status;
}
*/
```

`src/main.cpp`:

```cpp
#include "main.h"
#include "log.h"
#include "handler.h"
#include "known_dlls.h"

#include "undocumented.h"
#include "pointers.h"
#include "raii.hpp"
#include "drvglobal.h"

#include <ntimage.h>
#include <ntstrsafe.h>

extern "C" NTSTATUS NTAPI DriverEntry(PDRIVER_OBJECT drv, PUNICODE_STRING reg_path) {
	NTSTATUS status = STATUS_SUCCESS;

	log_debug("reg path: %wZ", reg_path);

	//RtlUnicodeStringCopy()

	GLOBAL.obj = drv;
	// TODO: ill need to copy the string if i actually need the registry path
	//GLOBAL.registry_path = reg_path;
	log_debug("driver entry");

	drv->DriverUnload = unload;

/*
	log_debug("adding native dlls");
	for (const UNICODE_STRING& filename : KNOWN_DLLS) {
		status = add_known_dll(&filename, true);
		if (! NT_SUCCESS(status)) break;
	}
	guard_nts(status, "error adding native known dlls: %x", status);

	log_debug("adding non-native dlls");
	for (const UNICODE_STRING& filename : KNOWN_DLLS) {
		status = add_known_dll(&filename, false);
		if (! NT_SUCCESS(status)) break;
	}
	guard_nts(status, "error adding non-native known dlls: %x", status);
	*/

	//status = PsSetLoadImageNotifyRoutine(on_image_load);
	status = PsSetLoadImageNotifyRoutine(on_image_load);
	guard_nts(status, "PsSetLoadImageNotifyRoutine failed with code: 0x%x", status);
	
	status = PsSetCreateProcessNotifyRoutine(on_create_proc, false);
	//status = PsSetLoadImageNotifyRoutine(on_image_load);
	guard_nts(status, "PsSetLoadImageNotifyRoutine failed with code: 0x%x", status);

	return status;
}

void NTAPI unload(PDRIVER_OBJECT drv) {
	UNREFERENCED_PARAMETER(drv);

	if (GLOBAL.registry_path) ExFreePool(GLOBAL.registry_path);
	GLOBAL.registry_path = nullptr;

	// this only fails if the function was not registered in the first case
	// so im ignoring any errors
	//PsRemoveLoadImageNotifyRoutine(on_image_load);
	PsSetCreateProcessNotifyRoutine(on_create_proc, true);
	PsRemoveLoadImageNotifyRoutine(on_image_load);

	for (const UNICODE_STRING& filename : KNOWN_DLLS) remove_known_dll(&filename, true);
#ifdef _WIN64
	for (const UNICODE_STRING& filename : KNOWN_DLLS) remove_known_dll(&filename, false);
#endif

	log_debug("driver exiting");
}
```

`src/path.cpp`:

```cpp
#include "path.h"

/// <summary>
/// checks if the filename segment of a filepath matches a given filename
/// </summary>
/// <param name="path"></param>
/// <param name="filename"></param>
/// <returns></returns>
bool match_filename(PUNICODE_STRING path, PUNICODE_STRING filename) {
	auto path_end = path->Buffer + (path->Length / sizeof(WCHAR));
	auto fn_end = filename->Buffer + (filename->Length / sizeof(WCHAR));

	auto path_curr = path_end;
	auto fn_curr = fn_end;

	while (path_curr != path->Buffer && fn_curr != filename->Buffer && *path_curr != L'\\') {
		if (towlower(*(fn_curr--)) != towlower(*(path_curr--))) return false;
	}

	return fn_curr == filename->Buffer;
}

bool match_filename_ascii(char* path, char* filename) {
	auto path_end = path + strlen(path);
	auto fn_end = filename + strlen(filename);

	auto path_curr = path_end;
	auto fn_curr = fn_end;

	while (path_curr != path && fn_curr != filename && *path_curr != '\\') {
		if (tolower(*(fn_curr--)) != tolower(*(path_curr--))) return false;
	}

	return fn_curr == filename;
}
```

`src/shellcode/shellcode32.asm`:

```asm
bits 32
default rel

%include "src/shellcode/structs.asm" 

; TODO:
; dll is not loaded?
; loadlibrary says dll not found??
; dll seems to not be in knowndlls
; init lazy is not called??

; calling convention (stdcall'ish TM):
; callee cleans up stack params
; params pushed in order
; eax, ecx and edx are volatile

; shellcode(original_code*, sz_original_code, dllname*, sz_dllname, original_func*)
; stack layout:
;   original_func*
;   sz_dllname
;   dllname*
;   sz_original_code
;   original_code*
start:
push        ebp
mov         ebp, esp ; frame pointer points to start of args
add         ebp, ptrsz
pushad ; we dont know what the target exe might expect from the windows loader environment
; so just save the entire environment

; traverse the teb/peb to get the kernel32 base address

mov         ebx, fs:[teb.peb]  ; PEB from TEB
mov         ebx, [ebx + peb.ldr] ; LDR from PEB
; the address of the pointer to the first entry
; last entry will point to this so we can check if the list is exhausted
lea         ecx, [ebx + ldr.modules + listentry.flink] ; addressof modules pointer
mov         ebx, [ecx] ; first entry is the exe image itself
mov         ebx, [ebx + listentry.flink] ; next entry is ntdll
cmp         ebx, ecx ; found end of list?
je          .exit
; mov         ebx, [ebx + listentry.flink] ; and now kernel32
; cmp         ebx, ecx ; end of list?
; je          .exit

; difference between dllbase field and flink (where we land)
; so ebx now holds the ntdll base address
mov         ebx, [ebx + ldrentry.base - ldrentry.links]

; eip relative access on x86-32asm
call        .push_ip_vprotect
.push_ip_vprotect:
add         dword [esp], vprotect_str - $
push        sz_vprotect_str
push        ebx
call        resolve_export

push        eax ; save virtualprotect addr for second call

; save original func ptr (modified in vprotect call)
push        dword [ebp]
; save original code size
push        dword [ebp + ptrsz * 3]

; make original func writable
push        0 ; space for old protect
push        esp ; old protect ptr
push        4 ; PAGE_READWRITE
lea         edx, [ebp + ptrsz * 3] ; original code size * 
push        edx
push        ebp ; original func *
push        -1 ; current process pseudo-handle
call        eax

test        eax, eax
pop         edx ; old protect
; restore original code size
pop         eax
mov         dword [ebp + ptrsz * 3], eax
; restore original func ptr
pop         eax
mov         dword [ebp], eax
pop         eax ; saved virtual protect addr

jnz          .exit

; restore original code (memcpy)
mov         ecx, [ebp + ptrsz * 3] ; original code size (param)
mov         esi, [ebp + ptrsz * 4] ; original code (param)
mov         edi, [ebp] ; original func

rep         movsb ; memcpy

; restore previous protection

; save original func ptr (modified in vprotect call)
push        dword [ebp]
; save original code size
push        dword [ebp + ptrsz * 3]

push        0 ; space for old protect
push        esp ; old protect ptr
push        edx ; new protect (previous value)
lea         edx, [ebp + ptrsz * 3] ; original code size * 
push        edx
push        ebp ; original func *
push        -1 ; current process pseudo-handle
call        eax

add         esp, ptrsz ; remove old page protection

test        eax, eax

; restore original code size
pop         eax
mov         dword [ebp + ptrsz * 3], eax
; restore original func ptr
pop         eax
mov         dword [ebp], eax

jnz          .exit

; check if k32 is loaded
; if not: exit
mov         edx, fs:[teb.peb]  ; PEB from TEB
mov         edx, [edx + peb.ldr] ; LDR from PEB
; the address of the pointer to the first entry
; last entry will point to this so we can check if the list is exhausted
lea         ecx, [edx + ldr.modules + listentry.flink] ; addressof modules pointer
mov         edx, [ecx] ; first entry is the exe image itself
mov         edx, [edx + listentry.flink] ; next entry is ntdll
cmp         edx, ecx ; found end of list?
je          .exit
mov         edx, [edx + listentry.flink] ; and now kernel32
cmp         edx, ecx ; end of list?
je          .exit

; load library

call        .push_ip_load_lib
.push_ip_load_lib:
add         dword [esp], load_lib_str - $

push        sz_load_lib_str

push        ebx
call        resolve_export

mov         ecx, [ebp + ptrsz * 2]
push        0
push        esp ; return base address
push        ecx ; dllname
push        0 ; characteristics
push        0 ; search path
call        eax ; loadlibrarya

pop         eax ; dump return base addr

.exit:
popad
pop         ebp
ret         4 * ptrsz

; resolve_export(name*, sz_name, base*)
; stack layout:
;   return*
;   base*
;   sz_name
;   name*
resolve_export:
push        esp
push        ebp
push        ebx
push        esi
push        edi

; skip saved registers and return addr
; esp now points to the start of the parameters
add         esp, ptrsz * 6

; parse kernel32s pe header and find the export tables
mov         ebp, [esp] ; module base in ebp
mov         ebx, [ebp + dosheader.lfanew] ; rva pe header in ebx
add         ebx, ebp ; va of pe header
; export directory is the first data directory
mov         ebx, [ebx + peheader.optional + optionalheader.dirs]
add         ebx, ebp ; export directory rva to va

mov         edx, [ebx + exportdir.addrnames] ; edx = address of names rva
add         edx, ebp ; address of names va

mov         eax, -1 ; eax as counter
.compare_next_string:
inc         eax

mov         ecx, [esp + ptrsz] ; sz_name
mov         edi, [esp + ptrsz * 2]
mov         esi, [edx + eax * 4] ; current name rva in esi
add         esi, ebp ; name va in esi

repe        cmpsb ; compare strings
jne         .compare_next_string

mov         edx, [ebx + exportdir.addrord] ; edx = address of ordinals rva
add         edx, ebp ; address of ordinals va
mov         ax, [edx + eax * 2] ; ordinal in ax

mov         edx, [ebx + exportdir.addrfuncs] ; ebx = address of funcs rva
add         edx, ebp ; address of funcs va
mov         eax, [edx + eax * 4] ; rva of function
add         eax, ebp

sub         esp, ptrsz * 6

pop         edi
pop         esi
pop         ebx
pop         ebp
pop         esp
ret         3 * ptrsz ; cleanup arguments

; static data "segment"
load_lib_str        db      "LdrLoadDll", 0
sz_load_lib_str     equ     $ - load_lib_str

vprotect_str        db      "NtProtectVirtualMemory", 0
sz_vprotect_str     equ     $ - vprotect_str
```

`src/shellcode/shellcode64.asm`:

```asm
bits 64
default rel

%include "src/shellcode/structs.asm" 

; using fastcall convention
; remember shadowspace setup and 16byte alignment before function calls
; stack is misaligned on entry (because of the ret addr)
; RAX, RCX, RDX, R8, R9, R10, R11 are volatile
; RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15 are non-volatile
; but ill restore every register i use because were hooking the entrypoint which wont abide by calling convention rules

; shellcode is using ntdll-only
; this is because it will be injected even into native processes (without kernel32)
; i dont care about those for now so i just exit if k32 is not loaded yet.
; after restoring the original entrypoint ofc.
; to support the native processes aswell you gotta write a native dll to inject and remove my check in here.

; shellcode(original_code*, sz_original_code, dllname*, original_func*)
; original_func* @ rcx
; dllname* @ rdx
; sz_original_code @ r8
; original_code* @ r9

start:

; push parameters as locals
push        r9 ; + 3
push        r8 ; + 2
push        rdx ; + 1
push        rcx ; + 0

; stack frame
push        rbp
lea         rbp, [rsp + ptrsz] ; skip old rbp

; save used non-volatile registers
push        rbx
push        rdi
push        rsi
push        r12

; lets find the ntdll base addr from the teb/peb
; itll be used the whole time so lets store it non-volatile
mov         rbx, gs:[teb.peb]  ; PEB from TEB
test        rbx, rbx
jz          .exit

mov         rbx, [rbx + peb.ldr] ; ldr from peb
test        rbx, rbx
jz          .exit

; linked list is circular so last entry points to first
; we save the fist to check if were done
lea         rcx, [rbx + ldr.modules + listentry.flink] ; &modules
mov         rbx, [rcx + listentry.flink] ; exe image in rbx
cmp         rbx, rcx ; end of list?
je          .exit
mov         rbx, [rbx + listentry.flink] ; ntdll
cmp         rbx, rcx ; end of list?
je          .exit

mov         rbx, [rbx + ldrentry.base - ldrentry.links] ; ntdll base

mov         rcx, sz_vprotect_str
lea         rdx, [vprotect_str]
mov         r8, rbx ; base addr
call        resolve_export
mov         r12, rax

; vprotect to make original entrypoint writable and restore overwritten bytes
mov         rcx, -1 ; current process pseudo-handle
push        qword [rbp] ; original func ptr
mov         rdx, rsp ; original function ptr*
push        qword [rbp + ptrsz * 2] ; original code size
mov         r8, rsp ; original code size*
mov         r9, 4 ; PAGE_READWRITE
push        0 ; space for old protection
push        rsp ; pointer to old protection

; stack is already aligned
; shadow space x32
sub         rsp, 4 * ptrsz
call        r12

add         rsp, 5 * ptrsz ; remove shadow space and old protection ptr
pop         r9 ; pop old protection into new protection
add         rsp, 2 * ptrsz ; pop base addr and region size return values
test        rax, rax
jnz          .exit

mov         rcx, [rbp + ptrsz * 2] ; original code size
mov         rsi, [rbp + ptrsz * 3] ; original code
mov         rdi, [rbp] ; original function

rep         movsb ; memcpy

; restore previous protection
mov         rcx, -1 ; current process pseudo-handle
push        qword [rbp] ; original func ptr
mov         rdx, rsp ; original function ptr*
push        qword [rbp + ptrsz * 2] ; original code size
mov         r8, rsp ; original code size*
; r9 already has the new (old) protection
push        0 ; space for old protection again
push        rsp ; ptr to old protection

; stack is already aligned
; shadow space
sub         rsp, 4 * ptrsz
call        r12
add         rsp, 8 * ptrsz ; remove shadow space, locals and old protection ptr argument

test        rax, rax
jnz          .exit

; check if k32 is loaded
; if not: exit
mov         rdx, gs:[teb.peb]  ; PEB from TEB
test        rdx, rdx
jz          .exit

mov         rdx, [rdx + peb.ldr] ; ldr from peb
test        rdx, rdx
jz          .exit

; linked list is circular so last entry points to first
; we save the fist to check if were done

lea         rcx, [rdx + ldr.modules + listentry.flink] ; &modules
mov         rdx, [rcx + listentry.flink] ; exe image in rdx
cmp         rdx, rcx ; end of list?
je          .exit
mov         rdx, [rdx + listentry.flink] ; ntdll
cmp         rdx, rcx ; end of list?
je          .exit
mov         rdx, [rdx + listentry.flink] ; kernel32
cmp         rdx, rcx ; end of list?
je          .exit

; load library

mov         rcx, sz_load_lib_str
lea         rdx, [load_lib_str]
mov         r8, rbx ; base addr
call        resolve_export

xor         rcx, rcx ; null search path
xor         rdx, rdx ; null characteristics
mov         r8, [rbp + ptrsz * 1] ; dllname
push        0 ; space for return base address
mov         r9, rsp ; return base address*

; shadow space + stack alignment
sub         rsp, 5 * ptrsz
call        rax
add         rsp, 6 * ptrsz ; remove shadow space + alignemnt + base address local

.exit:

pop         r12
pop         rsi
pop         rdi
pop         rbx
pop         rbp

add         rsp, 4 * ptrsz

ret

; resolve_export(sz_name, name*, base*)
; sz_name @ rcx
; name* @ rdx
; base* @ r8
resolve_export:

; getting the name pointer table into r9 (volatile)
mov         r9d, [r8 + dosheader.lfanew] ; rva of pe header
add         r9, r8 ; va of pe header
; get first data directory (export directory)
mov         r9d, [r9 + peheader.optional + optionalheader.dirs]
add         r9, r8 ; export directory va (needed later)

mov         r10d, [r9 + exportdir.addrnames] ; name pointer table rva
add         r10, r8 ; name pointer table va

mov         rax, -1 ; rax as counter
.compare_next_string:
inc         rax

push        rcx ; save name_sz
mov         rdi, rdx ; name
mov         esi, [r10 + rax * 4] ; current name rva
add         rsi, r8 ; current name va

repe        cmpsb ; strcmp
pop         rcx
jne         .compare_next_string

; resolve function addr from the index in rax

mov         r10d, [r9 + exportdir.addrord] ; ordinal table rva
add         r10, r8 ; ordinal table va
mov         ax, [r10 + rax * 2] ; ordinal in ax

mov         r10d, [r9 + exportdir.addrfuncs] ; function address table rva
add         r10, r8 ; function address table va
mov         eax, [r10 + rax * 4] ; rva of function
add         rax, r8 ; va of function

ret

; static data
load_lib_str        db      "LdrLoadDll", 0
sz_load_lib_str     equ     $ - load_lib_str

vprotect_str        db      "NtProtectVirtualMemory", 0
sz_vprotect_str     equ     $ - vprotect_str
```

`src/shellcode/structs.asm`:

```asm
%if __BITS__ = 64
    %define resp resq
    %define ptrsz 8
%endif

%if __BITS__ = 32
    %define resp resd
    %define ptrsz 4
%endif

struc teb
    .reserved1   resp    12
    .peb         resp    1
    .reserved2   resp    399
    .reserved3   resb    1952
    .tlsslots    resp    64
    .reserved4   resb    8
    .reserved5   resp    26
    .ole         resp    1
    .reserved6   resp    4
    .tlsexpand   resp    1
endstruc

struc peb
    .reserved1   resb   2
    .debugged    resb   1
    .reserved2   resb   1
    %if __BITS__ = 64
        .padding    resb    4
    %endif
    .reserved3   resp   2
    .ldr         resp   1
    .params      resp   1
    .reserved4   resp   3
    .atl         resp   1
    .reserved5   resp   1
    .reserved6   resd   1
    .reserved7   resp   1
    .reserved8   resd   1
    .atl32       resd   1
    .reserved9   resp   45
    .reserved10  resb   96
    .ppi         resp   1
    .reserved11  resb   128
    .reserved12  resp   1
    .sid         resd   1
endstruc

struc listentry
    .flink       resp   1
    .blink       resp   1
endstruc

struc ldr
    .reserved1   resb   8
    .reserved2   resp   3
    .modules     resb   listentry_size
endstruc

struc unicode_string
    .len         resw   1
    .maxlen      resw   1
    .buffer      resp   1
endstruc

struc ldrentry
    .reserved1   resp   2
    .links       resb   listentry_size
    .reserved2   resp   2
    .base        resp   1
    .entrypoint  resp   1
    .reserved3   resp   1
    .fullname    resb   unicode_string_size
    .reserved4   resb   8
    .reserved5   resp   3
    .reserved6   resp   1
    .datetime    resd   1
endstruc

struc dosheader
    .magic       resw   1
    .cblp        resw   1
    .cp          resw   1
    .crlc        resw   1
    .cparhdr     resw   1
    .minalloc    resw   1
    .maxalloc    resw   1
    .ss          resw   1
    .sp          resw   1
    .csum        resw   1
    .ip          resw   1
    .cs          resw   1
    .lfarlc      resw   1
    .ovno        resw   1
    .res         resw   4
    .oemid       resw   1
    .oeminfo     resw   1
    .res2        resw   10
    .lfanew      resd   1
endstruc

struc fileheader
    .machine     resw   1
    .numsections resw   1
    .datetime    resd   1
    .symbols     resd   1
    .numsymbols  resd   1
    .szoptional  resw   1
    .char        resw   1
endstruc

struc datadirectory
    .va          resd   1
    .size        resd   1
endstruc

struc optionalheader
    .magic       resw   1
    .lnkmajor    resb   1
    .lnkminor    resb   1
    .szcode      resd   1
    .szinit      resd   1
    .szuninit    resd   1
    .entrypoint  resd   1
    .base_code   resd   1
    %if __BITS__ = 32
        .base_data   resd   1
    %endif
    .imgbase     resp   1
    .sec_align   resd   1
    .file_align  resd   1
    .osmajor     resw   1
    .osminor     resw   1
    .imgmajor    resw   1
    .imgminor    resw   1
    .submajor    resw   1
    .subminor    resw   1
    .w32ver      resd   1
    .szimg       resd   1
    .szheaders   resd   1
    .checksum    resd   1
    .subsystem   resw   1
    .dllchar     resw   1
    .szstackres  resp   1
    .szstackcom  resp   1
    .szheapres   resp   1
    .szheapcom   resp   1
    .ldrflags    resd   1
    .numrva      resd   1
    .dirs        resb   datadirectory_size * 16
endstruc

struc peheader
    .signature   resd   1
    .file        resb   fileheader_size
    .optional    resb   optionalheader_size
endstruc

struc exportdir
    .char        resd   1
    .datetime    resd   1
    .vermajor    resw   1
    .verminor    resw   1
    .name        resd   1
    .base        resd   1
    .numfuncs    resd   1
    .numnames    resd   1
    .addrfuncs   resd   1
    .addrnames   resd   1
    .addrord     resd   1
endstruc
```