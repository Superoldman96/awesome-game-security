Project Path: arc_gmh5225_Ow-Anti-Flag_rsch69xh

Source Tree:

```txt
arc_gmh5225_Ow-Anti-Flag_rsch69xh
├── Anti-Flag
│   ├── Anti-Flag.cpp
│   ├── Anti-Flag.vcxproj
│   ├── Anti-Flag.vcxproj.filters
│   ├── Anti-Flag.vcxproj.user
│   ├── Console.hpp
│   ├── Cookies.hpp
│   ├── Executer.hpp
│   ├── Extensions.hpp
│   ├── Help.hpp
│   ├── Net.hpp
│   ├── Overwatch.hpp
│   ├── Patch.hpp
│   ├── Processes.hpp
│   ├── System.hpp
│   ├── WinColor.hpp
│   ├── WinRename.hpp
│   └── xor.h
├── Anti-Flag-Adv.sln
└── README.md

```

`Anti-Flag-Adv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31507.150
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Anti-Flag", "Anti-Flag\Anti-Flag.vcxproj", "{E39F87CF-2FE2-4D78-8641-12DD003AC76F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Debug|x64.ActiveCfg = Debug|x64
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Debug|x64.Build.0 = Debug|x64
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Debug|x86.ActiveCfg = Debug|Win32
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Debug|x86.Build.0 = Debug|Win32
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Release|x64.ActiveCfg = Release|x64
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Release|x64.Build.0 = Release|x64
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Release|x86.ActiveCfg = Release|Win32
		{E39F87CF-2FE2-4D78-8641-12DD003AC76F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AFE9A468-3881-49D1-9C9E-814C78B89FB9}
	EndGlobalSection
EndGlobal

```

`Anti-Flag/Anti-Flag.cpp`:

```cpp
/*
    Successor of Anti-Flag and Anti-Flag-V2.

    Developers:
    - DWORD64
    - Sixmax
*/

#if !_WIN32
#include <iostream>
int main()
{
    printf("You can only compile this on and for Windows.\n");
    return 0;
}
#else 
#include "Executer.hpp"
int main()
{
    return Exe::run();
}
#endif

/*
			system(_xor_("taskkill /f /im EpicGamesLauncher.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im FortniteClient-Win64-Shipping.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im OneDrive.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im RustClient.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im Origin.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im r5apex.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im Battle.net.exe >nul 2>&1").c_str());
			system(_xor_("taskkill /f /im Agent.exe >nul 2>&1").c_str());

			KillProcess("Launcher");
			KillProcess("FortniteClient-Win64-Shipping");
			KillProcess("EasyAntiCheat");
			KillProcess("OneDrive");
			KillProcess("dnf");
			KillProcess("DNF");
			KillProcess("CrossProxy");
			KillProcess("tensafe_1");
			KillProcess("TenSafe_1");
			KillProcess("tensafe_2");
			KillProcess("tencentdl");
			KillProcess("TenioDL");
			KillProcess("uishell");
			KillProcess("BackgroundDownloader");
			KillProcess("conime");
			KillProcess("QQDL");
			KillProcess("qqlogin");
			KillProcess("dnfchina");
			KillProcess("dnfchinatest");
			KillProcess("dnf");
			KillProcess("txplatform");
			KillProcess("TXPlatform");
			KillProcess("OriginWebHelperService");
			KillProcess("Origin");
			KillProcess("OriginClientService");
			KillProcess("OriginER");
			KillProcess("OriginThinSetupInternal");
			KillProcess("OriginLegacyCLI");
			KillProcess("OriginLegacyCLI");
			KillProcess("Agent");
			KillProcess("Client");*/

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Anti-Flag.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e39f87cf-2fe2-4d78-8641-12dd003ac76f}</ProjectGuid>
    <RootNamespace>AntiFlag</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <ShowIncludes>true</ShowIncludes>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MinimalRebuild>true</MinimalRebuild>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>xcopy /y "$(ProjectDir)watermark.txt"  "$(OutDir)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <AdditionalManifestDependencies>%(AdditionalManifestDependencies)</AdditionalManifestDependencies>
      <AllowIsolation />
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalManifestDependencies>%(AdditionalManifestDependencies)</AdditionalManifestDependencies>
      <AllowIsolation />
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Anti-Flag.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Console.hpp" />
    <ClInclude Include="Cookies.hpp" />
    <ClInclude Include="Executer.hpp" />
    <ClInclude Include="Extensions.hpp" />
    <ClInclude Include="Help.hpp" />
    <ClInclude Include="Net.hpp" />
    <ClInclude Include="Overwatch.hpp" />
    <ClInclude Include="Patch.hpp" />
    <ClInclude Include="Processes.hpp" />
    <ClInclude Include="System.hpp" />
    <ClInclude Include="WinColor.hpp" />
    <ClInclude Include="WinRename.hpp" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Anti-Flag/Anti-Flag.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source Files\Patches">
      <UniqueIdentifier>{419674e1-75e5-4a83-83d8-8b1b6f3b3b23}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Security">
      <UniqueIdentifier>{5c7a0fac-5638-4372-8df5-62386fca78b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Misc">
      <UniqueIdentifier>{99806d9d-2745-47f5-aaa8-314b9e7d4999}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Patches\Games">
      <UniqueIdentifier>{99bc065a-ac40-4b52-810e-6bbc5057c1bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Patches\Others">
      <UniqueIdentifier>{e1e4e6a4-4d0c-4593-a028-be43e6633b2c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Anti-Flag.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Console.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Help.hpp">
      <Filter>Source Files\Misc</Filter>
    </ClInclude>
    <ClInclude Include="WinColor.hpp">
      <Filter>Source Files\Misc</Filter>
    </ClInclude>
    <ClInclude Include="System.hpp">
      <Filter>Source Files\Misc</Filter>
    </ClInclude>
    <ClInclude Include="xor.h">
      <Filter>Source Files\Security</Filter>
    </ClInclude>
    <ClInclude Include="Extensions.hpp">
      <Filter>Source Files\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Processes.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Patch.hpp">
      <Filter>Source Files\Patches</Filter>
    </ClInclude>
    <ClInclude Include="Executer.hpp" />
    <ClInclude Include="Overwatch.hpp">
      <Filter>Source Files\Patches\Games</Filter>
    </ClInclude>
    <ClInclude Include="Net.hpp">
      <Filter>Source Files\Patches\Others</Filter>
    </ClInclude>
    <ClInclude Include="WinRename.hpp">
      <Filter>Source Files\Patches\Others</Filter>
    </ClInclude>
    <ClInclude Include="Cookies.hpp">
      <Filter>Source Files\Patches\Others</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Anti-Flag/Anti-Flag.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Anti-Flag/Console.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once

class Console;

#include <Windows.h>
#include <cstdio>
#include <string>

#include "WinColor.hpp"
#include "Help.hpp"

namespace
{
	using namespace std;
	using namespace colorwin;

	enum class LogType
	{
		Success,
		Warning,
		Error,
		Info
	};

	class Console
	{
	public:
		static void Log(const char* message, LogType type = LogType::Success)
		{
			unsigned char symbol;
			CW_COLORS col;

			switch (type)
			{
			case LogType::Success:
			default:
				symbol = (unsigned char)'+';
				col = green;
				break;

			case LogType::Warning:
				symbol = (unsigned char)'!';
				col = yellow;
				break;

			case LogType::Error:
				symbol = (unsigned char)'-';
				col = red;
				break;

			case LogType::Info:
				symbol = (unsigned char)'#';
				col = blue;
				break;
			}

			HWND handle = getHandle();

			{ // print time n shit 
				withcolor timeColor(dark_gray);

				SYSTEMTIME st;
				GetSystemTime(&st);
				printf("[%02d:%02d:%02d] ", st.wHour, st.wMinute, st.wSecond);
			}

			withcolor defaultWhite(white);

			cout << "[" << color(col) << symbol << color(white) << "] " << color(grey) << message << endl;
		}

		static HWND getHandle()
		{
			return GetConsoleWindow();
		}

		static RECT getRect()
		{
			RECT r;
			GetWindowRect(getHandle(), &r);
			return r;
		}

		static void CentralizeConsole()
		{
			HWND handle = getHandle();

			DWORD style = GetWindowLong(handle, GWL_STYLE);
			style &= ~WS_MAXIMIZEBOX & ~WS_SIZEBOX;
			SetWindowLong(handle, GWL_STYLE, style);
			
			RECT rc = getRect();
			int xPos = (GetSystemMetrics(SM_CXSCREEN) - rc.right) / 2;
			int yPos = (GetSystemMetrics(SM_CYSCREEN) - rc.bottom) / 2;
			
			SetWindowPos(handle, 0, xPos, yPos, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		}

		static void setTitle(const char* name)
		{
			SetConsoleTitleA(name);
		}

		static void randomizeTitle(int length = 20)
		{
			string name;

			for (int i = 0; i < length; i++)
				name += (char)Help::randomAsciiChar();
			
			setTitle(name.c_str());
		}

		static void Clear()
		{
			COORD topLeft = { 0, 0 };
			HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
			CONSOLE_SCREEN_BUFFER_INFO screen;
			DWORD written;

			GetConsoleScreenBufferInfo(console, &screen);
			FillConsoleOutputCharacterA(console, ' ', screen.dwSize.X * screen.dwSize.Y, topLeft, &written);
			FillConsoleOutputAttribute(console, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE, screen.dwSize.X * screen.dwSize.Y, topLeft, &written);
			SetConsoleCursorPosition(console, topLeft);
		}
	};
}

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

```

`Anti-Flag/Cookies.hpp`:

```hpp
#pragma once 

#include "Patch.hpp"

namespace
{
	using namespace std;
	namespace fs = std::filesystem;

	class Cookies : public IPatch
	{
	public:
		std::string GetID()
		{
			return "Browser Cookies";
		}

		list<string>* GetProcesses()
		{
			return new list<string>
			{
				"msedge",
				"firefox",
				"chrome",
				"brave",
				"opera"
			};
		}

		bool DoPatch(char drive)
		{
			// Brave Cookies
			DELFILE(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Cookies"));

			// chrome Cookies
			DELFILE(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies"));

			// opera Cookies
			DELFILE(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Opera Software\\Opera Stable\\Cookies"));

			// firefox cookies
			{
				std::string path = drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Mozilla\\Firefox\\Profiles\\");

				if (fs::exists(path) == true)
				{
					for (const auto& entry : fs::directory_iterator(path))
					{
						if (entry.is_directory() == false)
							continue;

						std::string path = entry.path().u8string();

						if (ends_with(path, "\\") == false)
							path += "\\";

						path += "cookies.sqlite";

						if (fs::exists(path) == true)
							DELFILE(path);
					}
				}
			}

			return true;
		}
	};
}
```

`Anti-Flag/Executer.hpp`:

```hpp
/*
I put this in its own class/file because "using namespace ..." was being weird in the global scope.
So I decided to put it into a new file/class to put it in an anonymous namespace and evade these issues :)
*/

/*
    Successor of Anti-Flag and Anti-Flag-V2.

    Developers:
    - DWORD64
    - Sixmax
*/

#pragma once 

#include <Windows.h>
#include <iostream>
#include <algorithm>

#include "Console.hpp"
#include "WinColor.hpp"

#include "System.hpp"
#include "Processes.hpp"

#include "Extensions.hpp"

#include "Patch.hpp"

#include "Overwatch.hpp"
#include "WinRename.hpp"
#include "Net.hpp"
#include "Cookies.hpp"

#define NEWLINE cout << endl;

namespace
{
    using namespace std;
    using namespace colorwin;

    void PrintWatermark(CW_COLORS color = red)
    {
        withcolor watermarkColor(color);

        std::string antiflag = R"(_______       __________      _______________               
___    |________  /___(_)     ___  ____/__  /_____ _______ _
__  /| |_  __ \  __/_  /________  /_   __  /_  __ `/_  __ `/
_  ___ |  / / / /_ _  /_/_____/  __/   _  / / /_/ /_  /_/ / 
/_/  |_/_/ /_/\__/ /_/        /_/      /_/  \__,_/ _\__, /  
                                                   /____/   
)";
        std::cout << antiflag << std::endl;

        withcolor byColor(white);
        std::cout << "By" << std::endl;

        withcolor avalonColor(blue);
        std::string avalon = R"(
   ___            __            _____                 
  / _ |_  _____ _/ /__  ___    / ___/______  __ _____ 
 / __ | |/ / _ `/ / _ \/ _ \  / (_ / __/ _ \/ // / _ \
/_/ |_|___/\_,_/_/\___/_//_/  \___/_/  \___/\_,_/ .__/
                                               /_/    )";

        std::cout << avalon << std::endl;

        std::cout << std::endl << std::endl << std::endl;

        std::cout << colorwin::color(red) << "WARNING:" << std::endl;
        std::cout << colorwin::color(yellow) << "all instances of 'Overwatch' and 'Battle.Net' will be closed." << std::endl;
        std::cout << colorwin::color(yellow) << "Also your Browser Cookies will be cleared, so make sure you have all your Login's saved." << std::endl;

        std::cout << std::endl;

        withcolor reset(white);
    }

    class Exe
    {
    public:
        static int run()
        {
            std::srand((unsigned)time(NULL));

            Console::CentralizeConsole();
            Console::randomizeTitle();

            PrintWatermark();

#if !_DEBUG
            Console::Log("Are you sure you want to run this program? [Y/N]", LogType::Info);
            if (tolower(cin.get()) != 'y')
            {
                Console::Log("Done.");
                return 0;
            }
#endif

            list<IPatch*>* patches = new list<IPatch*>
            {
                new Overwatch,
                new Cookies
            };


            NEWLINE;


#pragma region Process Killer
            Console::Log("Killing Processes...", LogType::Warning);

            for_each(patches->begin(), patches->end(), [](IPatch* patch)
                {
                    list<string>* procs = patch->GetProcesses();

                    for (string proc : *procs)
                    {
                        if (ProcessHandler::killByName(proc))
                        {
                            Console::Log(string("Killed '" + proc + "'.").c_str(), LogType::Success);
                        }
                    }

                    delete procs;
                });

            Console::Log("Done killing.", LogType::Info);
#pragma endregion


            NEWLINE;


#pragma region Patching
            Console::Log("Patching...", LogType::Warning);

            for_each(patches->begin(), patches->end(), [](IPatch* patch)
                {
                    Help::EnumDrives([=](char drive)
                        {
                            Console::Log(string("Running Patch: '" + patch->GetID() + "' for Drive '" + drive + "'").c_str(), LogType::Info);

                            patch->DoPatch(drive);

                            Console::Log(string("Finished Patch: " + patch->GetID()).c_str(), LogType::Success);

                            NEWLINE;
                        });
                });

            Console::Log("Done patching.", LogType::Info);
#pragma endregion

            NEWLINE;

            Console::Log("Renaming Windows...", LogType::Info);

            winre::WinRename::DoRename(Help::randomAsciiString(10));

            Console::Log("Windows has been renamed.", LogType::Success);

            NEWLINE;

            Console::Log("Reseeting Network Sockets", LogType::Info);

            Networking::Patch('c'); // networking doesnt need to get patched for every drive as its systemwide, so we do it once for C:\

            Console::Log("Network Sockets have been reset.", LogType::Success);

            NEWLINE;

#pragma region Cleanup
            for (IPatch* patch : *patches)
                delete patch;

            patches->clear();

            delete patches;
#pragma endregion

            Console::Log("Finished.", LogType::Info);

            NEWLINE;

            Console::Log("You can RESTART your Computer now to finish the cleaning.", LogType::Info);

#if _DEBUG
            Cmd::Run("pause");
#else 
            Cmd::RunSilent("pause");
#endif 

            return 0;
        }
    };
}

#undef NEWLINE

/*
    Successor of Anti-Flag and Anti-Flag-V2.

    Developers:
    - DWORD64
    - Sixmax
*/

```

`Anti-Flag/Extensions.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once

#include <string>

#define LENGTH(a) (sizeof(a) / sizeof(a[0]))

namespace
{
	bool ends_with(std::string const& value, std::string const& ending)
	{
		if (ending.size() > value.size()) return false;
		return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
	}

	std::string toLowerStr(std::string str)
	{
		if (str.empty())
			return str;

		for (unsigned int i = 0; i < str.length(); i++)
			str[i] = tolower(str.c_str()[i]);

		return str;
	}
}

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Help.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once

#pragma comment(lib, "Shlwapi.lib")
#include <Shlwapi.h>

#include <fstream>
#include <iostream>
#include <sstream> 
#include <functional>
#include <Windows.h>
#include <locale>
#include <codecvt>
#include <filesystem>

#include "WinColor.hpp"
#include "System.hpp"

#pragma warning(disable : 4996)

#ifndef _WIN32
typedef struct _GUID {
	uint32_t Data1;
	uint16_t Data2;
	uint16_t Data3;
	uint8_t Data4[8];
} GUID;
#endif

namespace
{
	using namespace colorwin;

	class Help
	{
		
	public:
		static GUID getGuid()
		{
			GUID gidReference;
			HRESULT hCreateGuid = CoCreateGuid(&gidReference);
			return gidReference;
		}

		static std::string GuidToString(GUID guid)
		{
			char guid_cstr[39];

			snprintf(guid_cstr, sizeof(guid_cstr),
				"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
				guid.Data1, guid.Data2, guid.Data3,
				guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
				guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

			return std::string(guid_cstr);
		}

		static float random01()
		{
			return (float)rand() / RAND_MAX;
		}

		static char randomAsciiChar()
		{
			const char charset[] = "0123456789" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz";
			int entry = static_cast<int>(floor(random01() * LENGTH(charset)));
			return (char)charset[entry];
		}

		static std::string randomAsciiString(int length)
		{
			length = max(length, 1);

			std::string result;

			for (int i = 0; i < length; i++)
				result += randomAsciiChar();

			return result;
		}

		static std::string CurUser()
		{
			wchar_t un[256 + 1];
			DWORD unLen = 256 + 1;
			GetUserNameW(un, &unLen);
			return ws2s(un);
		}

		static LPCWSTR StringToWStr(std::string s)
		{
			std::wstring stemp = std::wstring(s.begin(), s.end());
			LPCWSTR sw = stemp.c_str();
			return sw;
		}

		static std::wstring s2ws(const std::string& str)
		{
			using convert_typeX = std::codecvt_utf8<wchar_t>;
			std::wstring_convert<convert_typeX, wchar_t> converterX;

			return converterX.from_bytes(str);
		}

		static std::string ws2s(const std::wstring& wstr)
		{
			using convert_typeX = std::codecvt_utf8<wchar_t>;
			std::wstring_convert<convert_typeX, wchar_t> converterX;

			return converterX.to_bytes(wstr);
		}

		static std::string* readFile(const char* path)
		{
			std::ifstream ifs(path);

			if (!ifs)
				return nullptr;

			return new std::string((std::istreambuf_iterator<char>(ifs)),(std::istreambuf_iterator<char>()));
		}

		static std::vector<std::string> split(const std::string& s, char seperator)
		{
			std::vector<std::string> output;

			std::string::size_type prev_pos = 0, pos = 0;

			while ((pos = s.find(seperator, pos)) != std::string::npos)
			{
				std::string substring(s.substr(prev_pos, pos - prev_pos));

				output.push_back(substring);

				prev_pos = ++pos;
			}

			output.push_back(s.substr(prev_pos, pos - prev_pos)); // Last word

			return output;
		}

		static void EnumDrives(std::function<void(char)> callback)
		{
			const char drives[] = "CDEFGHIJKLMNOPQRSTUVWXYZ";

			for (char drive : drives)
			{
				std::string cs = std::string(drive + std::string(":\\"));
				
				if (FolderExists(cs.c_str()) == false)
					break;
				
				callback(drive);

			}
		}

		static void RegDel(const char* key)
		{
#if _DEBUG 
			Cmd::Run(std::string(std::string("reg delete \"") + key + std::string("\" /f")).c_str());
#else 
			Cmd::RunSilent(std::string(std::string("reg delete \"") + key + std::string("\" /f")).c_str());
#endif 
		}

		static bool FolderExists(const char* dir)
		{
			return PathIsDirectoryA(dir);
		}

		static bool FileExists(const char* dir)
		{
			std::filesystem::path p = std::string(dir);

			return std::filesystem::exists(p);
		}

		static bool DelFile(std::string dir)
		{
			if (dir.empty())
				return false;

			if (FileExists(dir.c_str()) == false)
				return false;

			return DeleteFileW(s2ws(dir).c_str());
		}

		static void RemDir(std::string dir)
		{
			if (dir.empty())
				return;

			if (FolderExists(dir.c_str()) == false)
				return;

			if (ends_with(dir, "\\"))
				dir = dir.substr(0, dir.length() - 1);

#if _DEBUG 
			std::cout << dir << std::endl;

			Cmd::Run(std::string(std::string("rd /s /q \"") + dir + std::string("\"")).c_str());
#else 
			Cmd::RunSilent(std::string(std::string("rd /s /q \"") + dir + std::string("\"")).c_str());
#endif 
			/*
			auto hash = std::hash<std::string>{}(dir);
			std::cout << color(dark_gray) << "Patched: " << color(green) << hash << std::endl;
			withcolor reset(white);
			*/
		}
	};
}

#define USER Help::CurUser()
#define FILEEXIST(path) Help::FileExists(path)
#define DIREXIST(path) Help::FolderExists(path)
#define DELFILE(path) Help::DelFile(path)
#define DELDIR(path) Help::RemDir(path)
#define REGDEL(path) Help::RegDel(path)
#define S(str) std::string(str)


/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Net.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once

#include "Patch.hpp"
#include "Console.hpp"

namespace
{
	using namespace std;

	class Networking
	{
	public:
		static void Patch(char drive)
		{
			if (drive != 'C')
				return;

			Cmd::RunSilent("netsh winsock reset");
			Cmd::RunSilent("netsh winsock reset catalog");
			Cmd::RunSilent("netsh int ip reset");
			Cmd::RunSilent("netsh advfirewall reset");
			Cmd::RunSilent("netsh int reset all");
			Cmd::RunSilent("netsh int ipv4 reset");
			Cmd::RunSilent("netsh int ipv6 reset");
			Cmd::RunSilent("ipconfig / release");
			Cmd::RunSilent("ipconfig / renew");
			Cmd::RunSilent("ipconfig / flushdns");
		}
	};
}

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Overwatch.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once 

#include "Patch.hpp"
#include "Help.hpp"

#include <iostream>
#include <filesystem>

namespace
{
	using namespace std;

	namespace fs = std::filesystem;

	class Overwatch : public IPatch
	{
	public:
		std::string GetID()
		{
			return "Overwatch";
		}

		list<string>* GetProcesses()
		{
			return new list<string>{
				"battle.net",
				"agent",
				"overwatch",
			};
		}

		/*
			Please Note:

			Not everything we are deleting here is related to Blizzard Device Flags, we are also clearing Cache etc simply to 
			*clean* your installation.
		*/
		bool DoPatch(char drive)
		{
#pragma region Blizz Device Flags / Installation Cleanup
			DELDIR(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Battle.net\\"));
			DELDIR(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Blizzard\\"));
			DELDIR(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Blizzard Entertainment\\"));
			DELDIR(drive + S(":\\Users\\") + USER + S("\\AppData\\Roaming\\Battle.net\\"));
			DELDIR(drive + S(":\\Users\\") + USER + S("\\Documents\\Overwatch\\Logs\\"));
		
			DELDIR(drive + S(":\\ProgramData\\Battle.net\\Setup\\"));
			DELDIR(drive + S(":\\ProgramData\\Battle.net\\Agent\\data\\"));
			DELDIR(drive + S(":\\ProgramData\\Battle.net\\Agent\\Logs\\"));
			DELDIR(drive + S(":\\ProgramData\\Blizzard Entertainment\\"));

			DELDIR(drive + S(":\\Program Files (x86)\\Overwatch\\_retail_\\cache\\"));
			DELDIR(drive + S(":\\Program Files (x86)\\Overwatch\\_retail_\\GPUCache\\"));

			// delete old bnet agents. the one with the greatest number is the latest one all other can be deleted
			{
				string agentsPath = S(drive + S(":\\ProgramData\\Battle.net\\Agent\\"));

				if (fs::exists(agentsPath))
				{
					string latestAgent = "";
					int greatest = 0;

					for (const auto& entry : fs::directory_iterator(agentsPath))
					{
						if (entry.is_directory() == false)
							continue;

						auto path = entry.path().u8string();
						auto args = Help::split(path, '\\');
						auto folder = args[args.size() - 1];

						if (folder._Starts_with("Agent") == false)
							continue;

						int agentID = stoi(Help::split(folder, '.')[1]);

						if (agentID > greatest)
						{
							greatest = agentID;
							latestAgent = path;
						}
					}

					for (const auto& entry : fs::directory_iterator(agentsPath))
					{
						if (entry.is_directory() == false)
							continue;

						auto path = entry.path().u8string();
						auto args = Help::split(path, '\\');
						auto folder = args[args.size() - 1];

						if (folder._Starts_with("Agent") == false)
							continue;

						if (path != latestAgent)
						{
							DELDIR(path);
						}
					}
				}
			}

			REGDEL("HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Blizzard Entertainment");
			REGDEL("HKEY_CURRENT_USER\\SOFTWARE\\Blizzard Entertainment");
			REGDEL("HKEY_CURRENT_USER\\SOFTWARE\\Activision");
			REGDEL("HKEY_CLASSES_ROOT\\Applications\\Overwatch.exe");
			REGDEL("HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\CapabilityAccessManager\\ConsentStore\\microphone\\NonPackaged\\C:#Program Files (x86)#Overwatch#_retail_#Overwatch.exe");
			REGDEL("HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\RADAR\\HeapLeakDetection\\DiagnosedApplications\\Overwatch.exe");
			REGDEL("HKEY_CURRENT_USER\\VirtualStore\\MACHINE\\SOFTWARE\\WOW6432Node\\Activision");
			REGDEL("HKEY_CURRENT_USER\\SOFTWARE\\Classes\\VirtualStore\\MACHINE\\SOFTWARE\\WOW6432Node\\Activision");
#pragma endregion 



#pragma region Cheats 
			/* Start of Ow-Cheat Orion*/
			DELDIR(drive + S(":\\ProgramData\\Orion\\"));
			/* END of Ow-Cheat Orion*/
			
			/* START of Ow-Cheat Critical Hit */
			REGDEL("HKLM\\SOFTWARE\\00330-80000-00000-AA302");
			/* END of Ow-Cheat Critical Hit */

			/* START of Ow-Cheat Noble/hyperFlick */
			DELDIR(drive + S(":\\Users\\") + USER + S("\\AppData\\Local\\Temp\\")); //due some User reports, we found out that they save/leave traces on your Pc inside the Temp folder! Credits you know
			/* END of Ow-Cheat Noble/hyperFlick */


#pragma endregion

			return true;
		}
	};
}

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Patch.hpp`:

```hpp
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once 

#include <list>
#include <string>

#include "Console.hpp"
#include "Processes.hpp"

namespace
{
	using namespace std;
	
	class IPatch
	{
	public:
		virtual bool DoPatch(char drive) = 0;
		virtual list<string>* GetProcesses() = 0;
		virtual string GetID() = 0;

		bool PatchAll(char drive)
		{
			list<string>* procs = GetProcesses();

			for (string proc : *procs)
			{
				if (ProcessHandler::killByName(proc))
				{
					Console::Log(string("Killed " + proc + ".").c_str(), LogType::Success);
				}
			}

			delete procs;

			return DoPatch(drive);
		}
	};
}
/*
// TEMPLATE // 

#pragma once

#include "Patch.hpp"

namespace
{
	using namespace std;

	class Rainbow6 : public IPatch
	{
	public:
		list<string>* GetProcesses()
		{
			return new list<string>{
			};
		}

		bool DoPatch(char drive)
		{


			return true;
		}
	};
}
*/

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/Processes.hpp`:

```hpp
/*
	killing and handling of processes 

*/


/*
    Successor of Anti-Flag and Anti-Flag-V2.

    Developers:
    - DWORD64
    - Sixmax
*/

#pragma once

#include <windows.h>
#include <process.h>
#include <Tlhelp32.h>
#include <winbase.h>
#include <list>
#include <string>
#include <comdef.h>

#include "System.hpp"
#include "Extensions.hpp"

namespace
{
    using namespace std;

    class ProcessHandler
    {
    public:
        static bool killByName(string processName)
        {
            if (processName.empty())
                return false;

            if (ends_with(processName, ".exe") == false)
                processName += ".exe";

            HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);

            if (!snap)
                return false;

            bool procKilled = false;

            PROCESSENTRY32 entry;
            entry.dwSize = sizeof(entry);

            BOOL hasProcess = Process32First(snap, &entry);

            while (hasProcess)
            {
                _bstr_t xf = entry.szExeFile;

                if (toLowerStr(string(xf)) != toLowerStr(processName))
                {
                    hasProcess = Process32Next(snap, &entry);
                    continue;
                }

                HANDLE procHandle = OpenProcess(PROCESS_TERMINATE, false, (DWORD)entry.th32ProcessID);

                if (procHandle == NULL)
                {
                    hasProcess = Process32Next(snap, &entry);
                    continue;
                }

                procKilled = TerminateProcess(procHandle, 1);

                // if it fails to close like that, take a hammer and bash its head in.
                if (procKilled == false)
                {
                    string cmd;

                    cmd += "taskkill /f /t /pid ";
                    cmd += to_string(long long(entry.th32ProcessID));

                    Cmd::RunSilent(cmd.c_str());
                }

                CloseHandle(procHandle);

                hasProcess = Process32Next(snap, &entry);
            }

            CloseHandle(snap);

            return procKilled;
        }
    };
}
/*
    Successor of Anti-Flag and Anti-Flag-V2.

    Developers:
    - DWORD64
    - Sixmax
*/
```

`Anti-Flag/System.hpp`:

```hpp
/*
	Simple Class to wrap System calls and automatically xor them :)
*/

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#pragma once

#include <Windows.h>
#include <string>

#include "xor.h"
#include "Extensions.hpp"

namespace 
{
	class Cmd
	{
	private:
		static void WrapXoR(std::string &cmd)
		{
			try
			{
				char c_cmd[2048];
				strcpy_s(c_cmd, sizeof(c_cmd), cmd.c_str());
				system(_xor_(c_cmd).c_str());
			}
#pragma warning(disable:4101)
			catch (std::exception& e)
			{
#if _DEBUG
				std::cout << e.what() << std::endl;
#endif 
				system(cmd.c_str());
			}
		}

	public:
		static void Run(const char* command)
		{
			std::string cmd;
			cmd.append(command);
			WrapXoR(cmd);
		}

		static void RunSilent(const char* command)
		{
			std::string cmd;
			cmd.append(command);
			
			if (ends_with(cmd, ">nul 2>nul") == false)
				cmd += ">nul 2>nul";
			
			WrapXoR(cmd);
		}
	};
}

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`Anti-Flag/WinColor.hpp`:

```hpp
// The MIT License(MIT)
// Copyright(c) 2016  Jeff Rebacz
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files(the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef COLORWIN_HPP_INCLUDED
#define COLORWIN_HPP_INCLUDED

#include <Windows.h>
#include <iostream>
#include <stack>

namespace colorwin
{
    // mix colors from wincon.h
    //#define FOREGROUND_BLUE      0x0001 // text color contains blue.
    //#define FOREGROUND_GREEN     0x0002 // text color contains green.
    //#define FOREGROUND_RED       0x0004 // text color contains red.
    //#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
    enum CW_COLORS
    {
        red = FOREGROUND_RED | FOREGROUND_INTENSITY,
        yellow = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY,
        green = FOREGROUND_GREEN | FOREGROUND_INTENSITY,
        cyan = FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY,
        blue = FOREGROUND_BLUE | FOREGROUND_INTENSITY,
        magenta = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_INTENSITY,
        white = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY,
        gray = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
        grey = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,

        dark_gray = FOREGROUND_INTENSITY,
        dark_grey = FOREGROUND_INTENSITY,

        /* The following dark colors are unreadable, but comment them in and use them if you want. */
        /*
        dark_red = FOREGROUND_RED,
        dark_yellow = FOREGROUND_RED | FOREGROUND_GREEN,
        dark_green = FOREGROUND_GREEN,
        dark_cyan = FOREGROUND_GREEN | FOREGROUND_BLUE,
        dark_blue = FOREGROUND_BLUE,
        dark_magenta = FOREGROUND_BLUE | FOREGROUND_RED,
        */
    };

    // Example usage: std::cout << color(yellow) << "This is a warning color!\n";
    class color
    {
    public:
#pragma warning(disable:26812)
        color(CW_COLORS color) : m_color(color), m_console_handle(INVALID_HANDLE_VALUE)
        {
            CONSOLE_SCREEN_BUFFER_INFO console_info;
            m_console_handle = GetStdHandle(STD_OUTPUT_HANDLE);
            if (!GetConsoleScreenBufferInfo(m_console_handle, &console_info))
            {
                m_console_handle = GetStdHandle(STD_ERROR_HANDLE);
                if (!GetConsoleScreenBufferInfo(m_console_handle, &console_info)) // maybe standard output device has been redirected, try the standard error device
                {
                    m_console_handle = INVALID_HANDLE_VALUE;
                }
            }
        }

        ~color()
        {
            if (m_console_handle != INVALID_HANDLE_VALUE)
            {
                // Restore the previous color.
                SetConsoleTextAttribute(m_console_handle, get_color_stack().top());
                get_color_stack().pop();
            }
        }

    private:
        void change_color() const
        {
            if (m_console_handle == INVALID_HANDLE_VALUE)
                return; // Can't get console info, can't change color.
            CONSOLE_SCREEN_BUFFER_INFO console_info;
            GetConsoleScreenBufferInfo(m_console_handle, &console_info);
            // save the current attributes for restoration on destruction.
            get_color_stack().push(console_info.wAttributes);
            SetConsoleTextAttribute(m_console_handle, 0x0F & m_color | 0xf0 & console_info.wAttributes);    // save the background color
        }

        color(color&);
        color& operator=(color);

        static std::stack<WORD>& get_color_stack()
        {
            // Use this instead of static member to avoid multiply defined symbols.
            static std::stack<WORD> color_stack;
            return color_stack;
        }

        HANDLE m_console_handle;
        const CW_COLORS m_color;

        friend class withcolor;
        template<typename charT, typename traits> friend std::basic_ostream<charT, traits>& operator<<(std::basic_ostream<charT, traits>& lhs, colorwin::color const& rhs);
    };

    // Example usage : 
    //  {
    //      withcolor scoped(yellow);
    //      cout << "This is a yellow warning!\n";
    //      cout << "This is a second yellow warning!\n";
    //  }
    //  --  or  --
    //      withcolor(yellow).printf("This will be yellow\n");
    class withcolor
    {
    public:
        withcolor(CW_COLORS color) : m_color(color)
        {
            m_color.change_color();
        }

        int printf(const char* format, ...)
        {
            va_list vlist;
            va_start(vlist, format);
            int ret = vprintf(format, vlist);
            va_end(vlist);
            return ret;
        }

#if _MSC_VER >= 1400    // printf_s offered in Visual Studio 2005
        int printf_s(const char* format, ...)
        {
            va_list vlist;
            va_start(vlist, format);
            int ret = vprintf_s(format, vlist);
            va_end(vlist);
            return ret;
        }
#endif

    private:
        withcolor(withcolor&);
        withcolor& operator=(withcolor);

        color m_color;
    };

    // cout << color(red) -> operator<<(cout, colorwin::color(red))
    template<typename charT, typename traits> std::basic_ostream<charT, traits>& operator<<(std::basic_ostream<charT, traits>& lhs, colorwin::color const& rhs)
    {
        rhs.change_color();
        return lhs;
    }
}

#endif // COLORWIN_HPP_INCLUDED



// from: https://github.com/jrebacz/colorwin/blob/master/src/colorwin.hpp
```

`Anti-Flag/WinRename.hpp`:

```hpp
#ifndef WINRENAME_HPP
#define WINRENAME_HPP

#include <string>
#include "Console.hpp"
#include "Help.hpp"
#include "Patch.hpp"

#pragma comment(lib, "Netapi32.lib")
#include <LM.h>

namespace winre
{
    class WinRename
    {
    private:
        static std::string setupPsFile(std::string& name)
        {
            std::string tempDir = std::filesystem::temp_directory_path().string();

            if (ends_with(tempDir, "\\") == false)
                tempDir += "\\";

            std::string psFilePath = tempDir + Help::GuidToString(Help::getGuid()) + std::string(".ps1");

            std::ofstream psFile(psFilePath);
            psFile << "Rename-Computer -NewName \"" << name << "\"";
            psFile.close();

            return psFilePath;
        }

    public:
        static void DoRename(std::string name = "")
        {
            if (name.empty() == true)
                name = Help::randomAsciiString(10);

            //uncomment that line for debugging purpose!
            //std:cout << name;
            //Sleep(5000);

            std::string path = setupPsFile(name);
            system(std::string("powershell.exe -executionpolicy bypass -file \"" + path + std::string("\" >nul 2>nul")).c_str());
            std::remove(path.c_str());

            std::wstring newNameW = Help::s2ws(name);

            SetComputerNameExA(ComputerNameNetBIOS, name.c_str());
            SetComputerNameExA(ComputerNameDnsHostname, name.c_str());
            SetComputerNameExA(ComputerNameDnsDomain, name.c_str());
            SetComputerNameExA(ComputerNameDnsFullyQualified, name.c_str());
            SetComputerNameExA(ComputerNamePhysicalNetBIOS, name.c_str());
            SetComputerNameExA(ComputerNamePhysicalDnsHostname, name.c_str());
            SetComputerNameExA(ComputerNamePhysicalDnsDomain, name.c_str());

            WCHAR szClusterNetBIOSName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD nSize = ARRAYSIZE(szClusterNetBIOSName);
            DnsHostnameToComputerNameW(newNameW.c_str(), szClusterNetBIOSName, &nSize);

            NetRenameMachineInDomain(0, newNameW.c_str(), 0, 0, NETSETUP_ACCT_CREATE);
        }
    };
}

#endif 
```

`Anti-Flag/xor.h`:

```h
/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/

#ifndef Basic_XoR
#define Basic_XoR

#include <string>
#include <utility>

namespace
{
	constexpr int const_atoi(char c)
	{
		return c - '0';
	}
}

#ifdef _MSC_VER
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

template<typename _string_type, size_t _length>
class _Basic_XorStr
{
	using value_type = typename _string_type::value_type;
	static constexpr auto _length_minus_one = _length - 1;

public:
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length])
		: _Basic_XorStr(str, std::make_index_sequence<_length_minus_one>())
	{

	}

	inline auto c_str() const
	{
		decrypt();

		return data;
	}

	inline auto str() const
	{
		decrypt();

		return _string_type(data, data + _length_minus_one);
	}

	inline operator _string_type() const
	{
		return str();
	}

private:
	template<size_t... indices>
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length], std::index_sequence<indices...>)
		: data{ crypt(str[indices], indices)..., '\0' },
		encrypted(true)
	{

	}

	static constexpr auto XOR_KEY = static_cast<value_type>(
		const_atoi(__TIME__[7]) +
		const_atoi(__TIME__[6]) * 10 +
		const_atoi(__TIME__[4]) * 60 +
		const_atoi(__TIME__[3]) * 600 +
		const_atoi(__TIME__[1]) * 3600 +
		const_atoi(__TIME__[0]) * 36000
		);

	static ALWAYS_INLINE constexpr auto crypt(value_type c, size_t i)
	{
		return static_cast<value_type>(c ^ (XOR_KEY + i));
	}

	inline void decrypt() const
	{
		if (encrypted)
		{
			for (size_t t = 0; t < _length_minus_one; t++)
			{
				data[t] = crypt(data[t], t);
			}
			encrypted = false;
		}
	}

	mutable value_type data[_length];
	mutable bool encrypted;
};
//---------------------------------------------------------------------------
template<size_t _length>
using XorStrA = _Basic_XorStr<std::string, _length>;
template<size_t _length>
using XorStrW = _Basic_XorStr<std::wstring, _length>;
template<size_t _length>
using XorStrU16 = _Basic_XorStr<std::u16string, _length>;
template<size_t _length>
using XorStrU32 = _Basic_XorStr<std::u32string, _length>;
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator==(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	static_assert(_length == _length2, "XorStr== different length");

	return _length == _length2 && lhs.str() == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator==(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs.size() == _length && lhs == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _stream_type, typename _string_type, size_t _length>
inline auto& operator<<(_stream_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	lhs << rhs.c_str();

	return lhs;
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator+(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	return lhs.str() + rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator+(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs + rhs.str();
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char const (&str)[_length])
{
	return XorStrA<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(wchar_t const (&str)[_length])
{
	return XorStrW<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char16_t const (&str)[_length])
{
	return XorStrU16<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char32_t const (&str)[_length])
{
	return XorStrU32<_length>(str);
}
//---------------------------------------------------------------------------

#endif 

/*
	Successor of Anti-Flag and Anti-Flag-V2.

	Developers:
	- DWORD64
	- Sixmax
*/
```

`README.md`:

```md


# Anti-Flag for Overwatch

**Anti-Flag** is a simply Console Application written in modern C++. It prevents Chainban's by clearing common Directories and Registry Keys, which Blizzard and Cheat Developers use to *Flag* your Device if you either were a Bad Boy >:( or downloaded malware disguised as Overwatch Cheats.

## Why ?

As Blizzard keeps getting more aggressive with Bans, we have decide to make this Public in an effort to stop them from blindly flailing a shotgun around and taking out every Account that may just show the *slightest* signs of being either Cheated on or being Botted by a Levelling Script. 

## Please Note !

After reverse engineering parts of Overwatch (*including the "Device-Identification"-Function*), these are the things that affect Blizzards Device Fingerprints:
- [ACP](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getacp)
- [User Default Language ID](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getuserdefaultlangid)
- [System Default Language ID](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getsystemdefaultlangid)
- [Computer Name](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew) (*Anti-Flag changes this*)
- [Username](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamew)
- [Timezone Information](https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-gettimezoneinformation)
- [CPU ID](https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex?view=msvc-160)
- [RTL Version](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlgetversion)

Generally you are fine with just using Anti-Flag, as Blizzard generates one large "string" by chaining all the above listed calls together, so even the smallest change (*in our case the Device Name*) **will** change this Fingerprint/Device-Hash.
 


## How to Use ?

Just run it, thats it really. 

## How to Build ?

Simple, **Clone the Repository** and **open the Solution**, *you may need some SDK's as we are using C++ Version 17*.
To actually *Build* the Project all you have to do is select the **Release Configuration** and... well... *build it*.

## Credits

- **Jayy** from Kaizen BST for originally coming up with the Idea. 
- **Dword and Sixmax** for doing more research on the topic and adding more stuff to the original Idea.

## License

We have decided to put this Project under **Public Domain**!

### Other Versions
[Anti-Flag C# Version](https://github.com/AVISIX/Anti-Flag)

```