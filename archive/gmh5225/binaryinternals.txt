Project Path: arc_gmh5225_binaryinternals_kvmxgjk3

Source Tree:

```txt
arc_gmh5225_binaryinternals_kvmxgjk3
├── BinaryInternalsViewer
│   ├── pom.xml
│   └── src
│       ├── assembly
│       │   └── bin.xml
│       └── main
│           └── java
│               ├── module-info.java
│               └── org
│                   └── binaryinternals
│                       ├── app
│                       │   ├── JDialogAbout.java
│                       │   ├── JDialogIcons.java
│                       │   ├── JDialogPlugins.java
│                       │   ├── JLabelHyperLink.java
│                       │   ├── JPanelForTree.java
│                       │   ├── JSplitPaneFile.java
│                       │   └── Main.java
│                       ├── binaryviewer
│                       │   ├── DataViewer.java
│                       │   ├── JAsciiDataViewer.java
│                       │   ├── JBinaryViewer.java
│                       │   ├── JRawDataViewer.java
│                       │   └── JRowViewer.java
│                       └── plugin
│                           ├── DefaultFileFormat.java
│                           └── PluginManager.java
├── CommonLib
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   └── org
│           │       └── binaryinternals
│           │           └── commonlib
│           │               ├── core
│           │               │   ├── BytesTool.java
│           │               │   ├── DataInputEx.java
│           │               │   ├── DefaultFileComponent.java
│           │               │   ├── FileComponenPlaceHolder.java
│           │               │   ├── FileComponent.java
│           │               │   ├── FileFormat.java
│           │               │   ├── FileFormatException.java
│           │               │   ├── PluginDescriptor.java
│           │               │   ├── PosByteArrayInputStream.java
│           │               │   └── PosDataInputStream.java
│           │               └── ui
│           │                   ├── GenerateTreeNode.java
│           │                   ├── GenerateTreeNodeFileFormat.java
│           │                   ├── HTMLKit.java
│           │                   ├── Icons.java
│           │                   ├── JTreeNodeFileComponent.java
│           │                   └── JXMLViewer.java
│           └── resources
│               └── image
│                   ├── README.md
│                   ├── icons8-abacus-16.png
│                   ├── icons8-apk-20.png
│                   ├── icons8-approval-16.png
│                   ├── icons8-binary-file-20.png
│                   ├── icons8-blockchain-technology-16.png
│                   ├── icons8-bookmark-16.png
│                   ├── icons8-calendar-16.png
│                   ├── icons8-category-16.png
│                   ├── icons8-check-mark-16.png
│                   ├── icons8-empty-battery-16.png
│                   ├── icons8-filter-16.png
│                   ├── icons8-flash-on-16.png
│                   ├── icons8-information-16.png
│                   ├── icons8-java-16.png
│                   ├── icons8-java-20.png
│                   ├── icons8-length-16.png
│                   ├── icons8-magic-wand-16.png
│                   ├── icons8-map-pin-16.png
│                   ├── icons8-maxcdn-16.png
│                   ├── icons8-mechanistic-analysis-16.png
│                   ├── icons8-module-16.png
│                   ├── icons8-name-tag-16.png
│                   ├── icons8-no-edit-16.png
│                   ├── icons8-one-finger-16.png
│                   ├── icons8-package-16.png
│                   ├── icons8-page-size-16.png
│                   ├── icons8-play-property-16.png
│                   ├── icons8-return-16.png
│                   ├── icons8-row-16.png
│                   ├── icons8-shortcut-16.png
│                   ├── icons8-signature-16.png
│                   ├── icons8-stack-16.png
│                   ├── icons8-tag-16.png
│                   ├── icons8-time-16.png
│                   ├── icons8-up-down-arrow-16.png
│                   ├── icons8-verified-account-16.png
│                   ├── icons8-versions-16.png
│                   ├── icons8-view-array-16.png
│                   └── icons8-zip-16.png
├── FormatBMP
│   ├── pom.xml
│   └── src
│       └── main
│           └── java
│               ├── module-info.java
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── bmp
│                               ├── BMPFile.java
│                               ├── BitmapFileHeader.java
│                               ├── ColorTable.java
│                               ├── DIBHeader.java
│                               ├── PixelArray.java
│                               ├── PixelBGR.java
│                               ├── PixelRGBA.java
│                               └── PluginDescriptorBMP.java
├── FormatCLASS
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   ├── org
│           │   │   └── binaryinternals
│           │   │       └── format
│           │   │           └── classfile
│           │   │               ├── AccessFlag.java
│           │   │               ├── ClassFile.java
│           │   │               ├── GenerateTreeNodeClassFile.java
│           │   │               ├── JTreeClassFile.java
│           │   │               ├── JavaLangSpec.java
│           │   │               ├── JavaSEVersion.java
│           │   │               ├── Opcode.java
│           │   │               ├── PluginDescriptorClass.java
│           │   │               ├── SignatureConvertor.java
│           │   │               ├── U2ClassComponent.java
│           │   │               ├── attribute
│           │   │               │   ├── Annotation.java
│           │   │               │   ├── AnnotationDefault_attribute.java
│           │   │               │   ├── BootstrapMethods_attribute.java
│           │   │               │   ├── Bridge_attribute.java
│           │   │               │   ├── ClassesCount.java
│           │   │               │   ├── Code_attribute.java
│           │   │               │   ├── ConstantValue_attribute.java
│           │   │               │   ├── Deprecated_attribute.java
│           │   │               │   ├── EnclosingMethod_attribute.java
│           │   │               │   ├── Exceptions_attribute.java
│           │   │               │   ├── InnerClasses_attribute.java
│           │   │               │   ├── LineNumberTable_attribute.java
│           │   │               │   ├── LocalVariableTable_attribute.java
│           │   │               │   ├── LocalVariableTypeTable_attribute.java
│           │   │               │   ├── MethodParameters_attribute.java
│           │   │               │   ├── ModuleHashes_attribute.java
│           │   │               │   ├── ModuleMainClass_attribute.java
│           │   │               │   ├── ModulePackages_attribute.java
│           │   │               │   ├── ModuleResolution_attribute.java
│           │   │               │   ├── ModuleTarget_attribute.java
│           │   │               │   ├── Module_attribute.java
│           │   │               │   ├── NestHost_attribute.java
│           │   │               │   ├── NestMembers_attribute.java
│           │   │               │   ├── PermittedSubclasses_attribute.java
│           │   │               │   ├── Record_attribute.java
│           │   │               │   ├── RuntimeAnnotations.java
│           │   │               │   ├── RuntimeInvisibleAnnotations_attribute.java
│           │   │               │   ├── RuntimeInvisibleParameterAnnotations_attribute.java
│           │   │               │   ├── RuntimeInvisibleTypeAnnotations_attribute.java
│           │   │               │   ├── RuntimeParameterAnnotations.java
│           │   │               │   ├── RuntimeTypeAnnotations.java
│           │   │               │   ├── RuntimeVisibleAnnotations_attribute.java
│           │   │               │   ├── RuntimeVisibleParameterAnnotations_attribute.java
│           │   │               │   ├── RuntimeVisibleTypeAnnotations_attribute.java
│           │   │               │   ├── Signature_attribute.java
│           │   │               │   ├── SourceDebugExtension_attribute.java
│           │   │               │   ├── SourceFile_attribute.java
│           │   │               │   ├── StackMapTable_attribute.java
│           │   │               │   ├── Synthetic_attribute.java
│           │   │               │   ├── Unrecognized_attribute.java
│           │   │               │   ├── aspectj
│           │   │               │   │   ├── AjSynthetic_attribute.java
│           │   │               │   │   ├── MethodDeclarationLineNumber_attribute.java
│           │   │               │   │   └── WeaverVersion_attribute.java
│           │   │               │   ├── attribute_info.java
│           │   │               │   └── scala
│           │   │               │       ├── ScalaSig_attribute.java
│           │   │               │       └── Scala_attribute.java
│           │   │               ├── constant
│           │   │               │   ├── CONSTANT_Class_info.java
│           │   │               │   ├── CONSTANT_Double_info.java
│           │   │               │   ├── CONSTANT_Dynamic.java
│           │   │               │   ├── CONSTANT_Dynamic_info.java
│           │   │               │   ├── CONSTANT_Fieldref_info.java
│           │   │               │   ├── CONSTANT_Float_info.java
│           │   │               │   ├── CONSTANT_Integer_info.java
│           │   │               │   ├── CONSTANT_InterfaceMethodref_info.java
│           │   │               │   ├── CONSTANT_InvokeDynamic_info.java
│           │   │               │   ├── CONSTANT_Long_info.java
│           │   │               │   ├── CONSTANT_MethodHandle_info.java
│           │   │               │   ├── CONSTANT_MethodType_info.java
│           │   │               │   ├── CONSTANT_Methodref_info.java
│           │   │               │   ├── CONSTANT_Module_info.java
│           │   │               │   ├── CONSTANT_NameAndType_info.java
│           │   │               │   ├── CONSTANT_Package_info.java
│           │   │               │   ├── CONSTANT_Ref.java
│           │   │               │   ├── CONSTANT_String_info.java
│           │   │               │   ├── CONSTANT_Utf8_info.java
│           │   │               │   └── cp_info.java
│           │   │               ├── field_info.java
│           │   │               ├── method_info.java
│           │   │               ├── package.html
│           │   │               ├── u1.java
│           │   │               ├── u2.java
│           │   │               └── u4.java
│           │   └── overview.html
│           └── resources
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── classfile
│                               └── MessagesBundle.properties
├── FormatDEX
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   └── org
│           │       └── binaryinternals
│           │           └── format
│           │               └── dex
│           │                   ├── DexFile.java
│           │                   ├── GenerateTreeNodeDexFile.java
│           │                   ├── JTreeDexFile.java
│           │                   ├── PluginDescriptorDEX.java
│           │                   ├── PosDataInputStreamDex.java
│           │                   ├── Type_byte.java
│           │                   ├── Type_int.java
│           │                   ├── Type_long.java
│           │                   ├── Type_short.java
│           │                   ├── Type_sleb128.java
│           │                   ├── Type_ubyte.java
│           │                   ├── Type_uint.java
│           │                   ├── Type_uleb128.java
│           │                   ├── Type_uleb128p1.java
│           │                   ├── Type_ulong.java
│           │                   ├── Type_ushort.java
│           │                   ├── access_flag.java
│           │                   ├── annotation_set_item.java
│           │                   ├── annotation_set_ref_list.java
│           │                   ├── annotations_directory_item.java
│           │                   ├── class_data_item.java
│           │                   ├── class_def_item.java
│           │                   ├── code_item.java
│           │                   ├── debug_info_item.java
│           │                   ├── encoded_annotation.java
│           │                   ├── encoded_array.java
│           │                   ├── encoded_array_item.java
│           │                   ├── encoded_value.java
│           │                   ├── field_id_item.java
│           │                   ├── header_item.java
│           │                   ├── map_list.java
│           │                   ├── method_handle_item.java
│           │                   ├── method_id_item.java
│           │                   ├── proto_id_item.java
│           │                   ├── string_data_item.java
│           │                   ├── string_id_item.java
│           │                   ├── type_id_item.java
│           │                   └── type_list.java
│           └── resources
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── dex
│                               └── MessagesBundle.properties
├── FormatELF
│   ├── pom.xml
│   └── src
│       └── main
│           └── java
│               ├── module-info.java
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── elf
│                               ├── Elf64Type.java
│                               ├── Elf64_Ehdr.java
│                               ├── ElfFile.java
│                               ├── Identification.java
│                               ├── PluginDescriptorELF.java
│                               └── PosDataInputStreamElf.java
├── FormatJPEG
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   └── org
│           │       └── binaryinternals
│           │           └── format
│           │               └── jpeg
│           │                   ├── FileData.java
│           │                   ├── JPEGFile.java
│           │                   ├── Marker.java
│           │                   ├── MarkerCode.java
│           │                   ├── MarkerParse.java
│           │                   ├── Marker_APP00.java
│           │                   ├── Marker_APP01.java
│           │                   ├── Marker_APP02.java
│           │                   ├── Marker_APP03.java
│           │                   ├── Marker_APP04.java
│           │                   ├── Marker_APP05.java
│           │                   ├── Marker_APP06.java
│           │                   ├── Marker_APP08.java
│           │                   ├── Marker_APP10.java
│           │                   ├── Marker_APP12.java
│           │                   ├── Marker_APP13.java
│           │                   ├── Marker_APP14.java
│           │                   ├── Marker_APP15.java
│           │                   ├── Marker_COM.java
│           │                   ├── Marker_DAC.java
│           │                   ├── Marker_DHP.java
│           │                   ├── Marker_DHT.java
│           │                   ├── Marker_DNL.java
│           │                   ├── Marker_DQT.java
│           │                   ├── Marker_DRI.java
│           │                   ├── Marker_EOI.java
│           │                   ├── Marker_EXP.java
│           │                   ├── Marker_RSTm.java
│           │                   ├── Marker_SOFnn.java
│           │                   ├── Marker_SOI.java
│           │                   ├── Marker_SOS.java
│           │                   ├── Marker_TEM.java
│           │                   ├── PluginDescriptorJPEG.java
│           │                   ├── icc
│           │                   │   ├── Header.java
│           │                   │   ├── ICCProfile.java
│           │                   │   ├── Tag.java
│           │                   │   ├── TagData.java
│           │                   │   ├── TagData_XYZType.java
│           │                   │   ├── TagData_curveType.java
│           │                   │   ├── TagData_measurementType.java
│           │                   │   ├── TagData_signatureType.java
│           │                   │   ├── TagData_textType.java
│           │                   │   ├── TagData_viewingConditionsType.java
│           │                   │   ├── TagType.java
│           │                   │   ├── XYZNumber.java
│           │                   │   ├── dateTimeNumber.java
│           │                   │   └── s15Fixed16Number.java
│           │                   ├── ps
│           │                   │   ├── IRB_8BIM.java
│           │                   │   └── PhotoshopImageResource.java
│           │                   ├── tiff
│           │                   │   ├── IFD.java
│           │                   │   ├── IFDGroup.java
│           │                   │   ├── IFDMessage.java
│           │                   │   ├── IFDParse.java
│           │                   │   ├── IFDTag.java
│           │                   │   ├── IFDType.java
│           │                   │   ├── IFD_0000_GPSVersionID.java
│           │                   │   ├── IFD_0001_InteroperabilityIndex.java
│           │                   │   ├── IFD_0002_InteroperabilityVersion.java
│           │                   │   ├── IFD_0106_PhotometricInterpretation.java
│           │                   │   ├── IFD_010E_ImageDescription.java
│           │                   │   ├── IFD_010F_Make.java
│           │                   │   ├── IFD_0110_Model.java
│           │                   │   ├── IFD_0112_Orientation.java
│           │                   │   ├── IFD_011A_XResolution.java
│           │                   │   ├── IFD_011B_YResolution.java
│           │                   │   ├── IFD_0128_ResolutionUnit.java
│           │                   │   ├── IFD_0131_Software.java
│           │                   │   ├── IFD_0132_DateTime.java
│           │                   │   ├── IFD_013E_WhitePoint.java
│           │                   │   ├── IFD_013F_PrimaryChromaticities.java
│           │                   │   ├── IFD_0201_JPEGInterchangeFormat.java
│           │                   │   ├── IFD_0202_JPEGInterchangeFormatLength.java
│           │                   │   ├── IFD_0211_YCbCrCoefficients.java
│           │                   │   ├── IFD_0213_YCbCrPositioning.java
│           │                   │   ├── IFD_0214_ReferenceBlackWhite.java
│           │                   │   ├── IFD_829A_ExposureTime.java
│           │                   │   ├── IFD_829D_FNumber.java
│           │                   │   ├── IFD_8769_Exif.java
│           │                   │   ├── IFD_8822_ExposureProgram.java
│           │                   │   ├── IFD_8825_GPS.java
│           │                   │   ├── IFD_8827_PhotographicSensitivity.java
│           │                   │   ├── IFD_9000_ExifVersion.java
│           │                   │   ├── IFD_9003_DateTimeOriginal.java
│           │                   │   ├── IFD_9004_DateTimeDigitized.java
│           │                   │   ├── IFD_9101_ComponentsConfiguration.java
│           │                   │   ├── IFD_9102_CompressedBitsPerPixel.java
│           │                   │   ├── IFD_9201_ShutterSpeedValue.java
│           │                   │   ├── IFD_9202_ApertureValue.java
│           │                   │   ├── IFD_9204_ExposureBiasValue.java
│           │                   │   ├── IFD_9205_MaxApertureValue.java
│           │                   │   ├── IFD_9207_MeteringMode.java
│           │                   │   ├── IFD_9208_LightSource.java
│           │                   │   ├── IFD_9209_Flash.java
│           │                   │   ├── IFD_920A_FocalLength.java
│           │                   │   ├── IFD_927C_MakerNode.java
│           │                   │   ├── IFD_9286_UserComment.java
│           │                   │   ├── IFD_9290_SubsecTime.java
│           │                   │   ├── IFD_9291_SubsecTimeOriginal.java
│           │                   │   ├── IFD_9292_SubsecTimeDigitized.java
│           │                   │   ├── IFD_A000_FlashpixVersion.java
│           │                   │   ├── IFD_A001_ColorSpace.java
│           │                   │   ├── IFD_A002_PixelXDimension.java
│           │                   │   ├── IFD_A003_PixelYDimension.java
│           │                   │   ├── IFD_A005_Interoperability.java
│           │                   │   ├── IFD_A20E_FocalPlaneXResolution.java
│           │                   │   ├── IFD_A20F_FocalPlaneYResolution.java
│           │                   │   ├── IFD_A210_FocalPlaneResolutionUnit.java
│           │                   │   ├── IFD_A215_ExposureIndex.java
│           │                   │   ├── IFD_A217_SensingMethod.java
│           │                   │   ├── IFD_A300_FileSource.java
│           │                   │   ├── IFD_A301_SceneType.java
│           │                   │   ├── IFD_A302_CFAPattern.java
│           │                   │   ├── IFD_A401_CustomRendered.java
│           │                   │   ├── IFD_A402_ExposureMode.java
│           │                   │   ├── IFD_A403_WhiteBalance.java
│           │                   │   ├── IFD_A404_DigitalZoomRatio.java
│           │                   │   ├── IFD_A405_FocalLengthIn35mmFilm.java
│           │                   │   ├── IFD_A406_SceneCaptureType.java
│           │                   │   ├── IFD_A407_GainControl.java
│           │                   │   ├── IFD_A408_Contrast.java
│           │                   │   ├── IFD_A409_Saturation.java
│           │                   │   ├── IFD_A40A_Sharpness.java
│           │                   │   ├── IFD_A40C_SubjectDistanceRange.java
│           │                   │   ├── IFD_A500_Gamma.java
│           │                   │   ├── IFD_ASCII.java
│           │                   │   ├── IFD_BYTE.java
│           │                   │   ├── IFD_DOUBLE.java
│           │                   │   ├── IFD_FLOAT.java
│           │                   │   ├── IFD_LONG.java
│           │                   │   ├── IFD_LONG_COUNT1.java
│           │                   │   ├── IFD_LONG_Pointer.java
│           │                   │   ├── IFD_RATIONAL.java
│           │                   │   ├── IFD_RATIONAL_COUNT1.java
│           │                   │   ├── IFD_SBYTE.java
│           │                   │   ├── IFD_SHORT.java
│           │                   │   ├── IFD_SHORT_COUNT1.java
│           │                   │   ├── IFD_SLONG.java
│           │                   │   ├── IFD_SRATIONAL.java
│           │                   │   ├── IFD_SRATIONAL_COUNT1.java
│           │                   │   ├── IFD_SSHORT.java
│           │                   │   ├── IFD_UNDEFINED.java
│           │                   │   ├── RefItem.java
│           │                   │   ├── ShortText.java
│           │                   │   ├── TIFF.java
│           │                   │   └── TIFFHeader.java
│           │                   └── xmp
│           │                       └── XMP.java
│           └── resources
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── jpeg
│                               └── tiff
│                                   ├── IFDMessage.properties
│                                   ├── IFDTag.properties
│                                   └── ShortText.properties
├── FormatPDF
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   └── org
│           │       └── binaryinternals
│           │           └── format
│           │               └── pdf
│           │                   ├── Comment.java
│           │                   ├── CrossReferenceTable.java
│           │                   ├── EmptyLine.java
│           │                   ├── EndOfFile.java
│           │                   ├── Header.java
│           │                   ├── IndirectObject.java
│           │                   ├── PDFFile.java
│           │                   ├── PDFStatics.java
│           │                   ├── PluginDescriptorPDF.java
│           │                   ├── StartXRef.java
│           │                   ├── Texts.java
│           │                   ├── Trailer.java
│           │                   ├── basicobj
│           │                   │   ├── Analysis.java
│           │                   │   ├── Array.java
│           │                   │   ├── Boolean.java
│           │                   │   ├── Dictionary.java
│           │                   │   ├── Name.java
│           │                   │   ├── Null.java
│           │                   │   ├── Numeric.java
│           │                   │   ├── Reference.java
│           │                   │   ├── Stream.java
│           │                   │   ├── StringHexadecimal.java
│           │                   │   ├── StringLiteral.java
│           │                   │   └── package.html
│           │                   └── filter
│           │                       └── package.html
│           └── resources
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── pdf
│                               └── MessagesBundle.properties
├── FormatPNG
│   ├── pom.xml
│   └── src
│       └── main
│           └── java
│               ├── module-info.java
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── png
│                               ├── Chunk.java
│                               ├── Chunk_IDAT.java
│                               ├── Chunk_IEND.java
│                               ├── Chunk_IHDR.java
│                               ├── Chunk_PLTE.java
│                               ├── Chunk_bKGD.java
│                               ├── Chunk_cHRM.java
│                               ├── Chunk_gAMA.java
│                               ├── Chunk_hIST.java
│                               ├── Chunk_iTXt.java
│                               ├── Chunk_pHYs.java
│                               ├── Chunk_sBIT.java
│                               ├── Chunk_sPLT.java
│                               ├── Chunk_tEXt.java
│                               ├── Chunk_tIME.java
│                               ├── Chunk_tRNS.java
│                               ├── Chunk_zTXt.java
│                               ├── PNGFile.java
│                               └── PluginDescriptorPNG.java
├── FormatZIP
│   ├── pom.xml
│   └── src
│       └── main
│           ├── java
│           │   ├── module-info.java
│           │   └── org
│           │       └── binaryinternals
│           │           └── format
│           │               └── zip
│           │                   ├── CentralDirectoryStructure.java
│           │                   ├── EndOfCentralDirectoryRecord.java
│           │                   ├── LocalFileHeader.java
│           │                   ├── MSDosDate.java
│           │                   ├── MSDosTime.java
│           │                   ├── PluginDescriptorZIP.java
│           │                   └── ZIPFile.java
│           └── resources
│               └── org
│                   └── binaryinternals
│                       └── format
│                           └── zip
│                               └── MessagesBundle.properties
├── LICENSE
├── README.md
├── build.cmd
├── build.sh
├── docs
│   ├── dependency-graph.dot
│   ├── dependency-graph.png
│   └── sample-class-string.png
├── format-class-masstest.sh
├── format-class.sh
├── format-dex.sh
├── format-elf.sh
├── format-pdf.sh
├── format-zip.sh
└── pom.xml

```

`BinaryInternalsViewer/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>BinaryInternalsViewer</artifactId>
    <packaging>jar</packaging>

    <name>binaryinternals :: BinaryInternalsViewer</name>

    <properties>
        <maven.build.timestamp.format>yyyyMMdd.HHmmss</maven.build.timestamp.format>
    </properties>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.class</artifactId>
            <version>21.0</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.bmp</artifactId>
            <version>1.1</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.jpeg</artifactId>
            <version>2.1</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.zip</artifactId>
            <version>0.8</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.pdf</artifactId>
            <version>0.6</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.dex</artifactId>
            <version>0.8</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.elf</artifactId>
            <version>0.3</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.png</artifactId>
            <version>1.1</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>${project.artifactId}-${project.version}-${maven.build.timestamp}</finalName>

        <plugins>

            <!-- Copy dependencies libraries to Target folder -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <version>${maven-dependency-plugin.version}</version>
                <executions>
                    <execution>
                        <id>copy-dependencies</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>copy-dependencies</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>
                                ${project.build.directory}/libs
                            </outputDirectory>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <!-- Add manifest -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>libs/</classpathPrefix>
                            <mainClass>org.binaryinternals.app.Main</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>

            <!-- Package -->
            <!-- https://maven.apache.org/plugins/maven-assembly-plugin/usage.html -->
            <!-- https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>${maven-assembly-plugin.version}</version>
                <configuration>
                    <descriptors>
                        <descriptor>src/assembly/bin.xml</descriptor>
                    </descriptors>
                    <outputDirectory>${project.parent.basedir}${file.separator}dist</outputDirectory>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

        </plugins>
    </build>
</project>

```

`BinaryInternalsViewer/src/assembly/bin.xml`:

```xml
<assembly
    xmlns="http://maven.apache.org/ASSEMBLY/2.1.1"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.1.1 https://maven.apache.org/xsd/assembly-2.1.1.xsd">
    <id>bin</id>
    <formats>
        <format>tar.gz</format>
        <format>zip</format>
    </formats>
    <fileSets>
        <fileSet>
            <directory>${project.basedir}</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>README*</include>
                <include>LICENSE*</include>
                <include>NOTICE*</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>*.jar</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}/libs</directory>
            <outputDirectory>libs</outputDirectory>
            <includes>
                <include>*.jar</include>
            </includes>
        </fileSet>
    </fileSets>
</assembly>

```

`BinaryInternalsViewer/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.app {
    requires static com.github.spotbugs.annotations;
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.app;
    exports org.binaryinternals.binaryviewer;
    exports org.binaryinternals.plugin;
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JDialogAbout.java`:

```java
/*
 * JDialogAbout.java    Apr 12, 2011, 10:50
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.WindowConstants;

/**
 *
 * @author Amos Shi
 */
class JDialogAbout extends JDialog {

    private static final long serialVersionUID = 4876543219876500000L;

    JDialogAbout(final Frame owner, final String title) {
        super(owner, title);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.setModal(true);

        this.initComponents();
        this.pack();
        this.setResizable(false);
    }

    private void buttonOKClicked() {
        this.setVisible(false);
    }

    private JTextField getLine(String label){
        JTextField field = new JTextField(label);
        field.setEditable(false);
        field.setBorder(BorderFactory.createEmptyBorder());
        return field;
    }

    private void initComponents() {
        this.setLayout(new FlowLayout());

        final JButton buttonClose = new JButton("Close");
        buttonClose.addActionListener((final ActionEvent e) -> buttonOKClicked());

        // Lay out the labels from top to bottom.
        final JPanel listPane = new JPanel();
        listPane.setLayout(new BoxLayout(listPane, BoxLayout.PAGE_AXIS));

        final JLabel label = new JLabel("Binary Internals Viewer");
        label.setFont(new Font(Font.DIALOG, Font.BOLD, 20));
        listPane.add(label);

        listPane.add(Box.createRigidArea(new Dimension(0, 5)));
        listPane.add(new JLabelHyperLink(
                "https://github.com/amosshi/binaryinternals",
                "https://github.com/amosshi/binaryinternals"));

        listPane.add(Box.createRigidArea(new Dimension(0, 20)));
        listPane.add(this.getLine("Watch binary file internals visually & interactively for the meaning of every bit"));
        listPane.add(Box.createRigidArea(new Dimension(0, 5)));
        listPane.add(this.getLine("Version: 3.6"));
        listPane.add(Box.createRigidArea(new Dimension(0, 5)));
        listPane.add(this.getLine("Author: Amos Shi"));

        listPane.add(Box.createRigidArea(new Dimension(0, 20)));
        listPane.add(this.getLine("System Properties:"));
        listPane.add(Box.createRigidArea(new Dimension(0, 5)));
        JTextArea sysinfo = new JTextArea(8, 40);
        System.getProperties().forEach((key, value) -> sysinfo.append(key + ": " + value + System.lineSeparator()));
        sysinfo.setCaretPosition(0);
        sysinfo.setEditable(false);
        sysinfo.setLineWrap(true);
        listPane.add(new JScrollPane(sysinfo));

        listPane.add(Box.createRigidArea(new Dimension(0, 20)));
        listPane.add(this.getLine("Icons are freely provided by https://icons8.com/"));

        listPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Lay out the buttons from left to right.
        final JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
        buttonPane.add(Box.createHorizontalGlue());
        buttonPane.add(buttonClose);

        // Put everything together, using the content pane's BorderLayout.
        final Container contentPane = this.getContentPane();
        contentPane.add(listPane, BorderLayout.CENTER);
        contentPane.add(buttonPane, BorderLayout.PAGE_END);

    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JDialogIcons.java`:

```java
/*
 * JDialogIcons.java    Sep 21, 2021
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.WindowConstants;
import javax.swing.table.DefaultTableModel;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 */
class JDialogIcons extends JDialog {

    private static final long serialVersionUID = 4876543219876500000L;

    JDialogIcons(final Frame owner, final String title) {
        super(owner, title);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.setModal(true);

        this.initComponents();
        this.pack();
        this.setResizable(true);
    }

    private void closeButtonOKClicked() {
        this.setVisible(false);
    }

    /**
     * Prepare data model for table.
     *
     * @see <a href="https://stackoverflow.com/questions/4941372/">How to Insert Image into JTable Cell</a>
     */
    private DefaultTableModel getIconsTableModel(){

        String[] columnNames = {"Icon", "Name"};
        return new DefaultTableModel(columnNames, Icons.values().length) {
            /**
             * Returning the Class of each column will allow different renderers to be used based on Class.
             */
            @Override
            public Class getColumnClass(int column) {
                switch (column) {
                    case 0:
                        return Icon.class;
                    case 1:
                        return String.class;
                    default:
                        throw new IllegalArgumentException(String.format("The column=%d do not exist", column));
                }
            }

            @Override
            public Object getValueAt(int row, int column) {
                Icons item = Icons.values()[row];
                switch (column) {
                    case 0:
                        return item.getIcon();
                    case 1:
                        return item.name();
                    default:
                        throw new IllegalArgumentException(String.format("The row=%d column=%d do not exist", row, column));
                }
            }

        };
    }

    private void initComponents() {
        this.setLayout(new BorderLayout());

        final JButton buttonClose = new JButton("Close");
        buttonClose.addActionListener((final ActionEvent e) -> closeButtonOKClicked());

        // Lay out the labels from top to bottom.
        final JTable table = new JTable(this.getIconsTableModel());
        JDialogPlugins.resizeColumnWidth(table);
        table.setPreferredScrollableViewportSize(table.getPreferredSize());
        table.setFillsViewportHeight(true);
        JScrollPane scrollPane = new JScrollPane(table);
        final JPanel treePane = new JPanel();
        treePane.setLayout(new BorderLayout());
        treePane.add(scrollPane, BorderLayout.CENTER);
        treePane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Lay out the buttons from left to right.
        final JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
        buttonPane.add(Box.createHorizontalGlue());
        buttonPane.add(buttonClose);

        // Put everything together, using the content pane's BorderLayout.
        final Container contentPane = this.getContentPane();
        contentPane.add(treePane, BorderLayout.CENTER);
        contentPane.add(buttonPane, BorderLayout.PAGE_END);
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JDialogPlugins.java`:

```java
/*
 * JDialogAbout.java    Apr 12, 2011, 10:50
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.WindowConstants;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import org.binaryinternals.commonlib.core.PluginDescriptor;
import org.binaryinternals.plugin.PluginManager;

/**
 *
 * @author Amos Shi
 */
class JDialogPlugins extends JDialog {

    private static final long serialVersionUID = 4876543219876500000L;

    JDialogPlugins(final Frame owner, final String title) {
        super(owner, title);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.setModal(true);

        this.initComponents();
        this.pack();
        this.setResizable(true);
    }

    private void initComponents() {
        this.setLayout(new BorderLayout());

        final JButton buttonClose = new JButton("Close");
        buttonClose.addActionListener((final ActionEvent e) -> buttonOKClicked());

        // Lay out the labels from top to bottom.
        final JTable table = new JTable(new PluginsModel());
        resizeColumnWidth(table);
        table.setPreferredScrollableViewportSize(table.getPreferredSize());
        table.setFillsViewportHeight(true);
        JScrollPane scrollPane = new JScrollPane(table);
        final JPanel treePane = new JPanel();
        treePane.setLayout(new BorderLayout());
        treePane.add(scrollPane, BorderLayout.CENTER);
        treePane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Lay out the buttons from left to right.
        final JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
        buttonPane.add(Box.createHorizontalGlue());
        buttonPane.add(buttonClose);

        // Put everything together, using the content pane's BorderLayout.
        final Container contentPane = this.getContentPane();
        contentPane.add(treePane, BorderLayout.CENTER);
        contentPane.add(buttonPane, BorderLayout.PAGE_END);
    }

    private void buttonOKClicked() {
        this.setVisible(false);
    }

    protected static void resizeColumnWidth(JTable table) {
        final TableColumnModel columnModel = table.getColumnModel();
        for (int column = 0; column < table.getColumnCount(); column++) {
            int width = 50; // Min width
            for (int row = 0; row < table.getRowCount(); row++) {
                TableCellRenderer renderer = table.getCellRenderer(row, column);
                Component comp = table.prepareRenderer(renderer, row, column);
                width = Math.max(comp.getPreferredSize().width, width);
            }
            columnModel.getColumn(column).setPreferredWidth(width + 10);
        }
    }

    public static class PluginsModel extends AbstractTableModel {

        transient List<String> columnNames = new LinkedList<>();
        transient List<List<String>> rowData = new LinkedList<>();

        PluginsModel() {
            Map<String, PluginDescriptor> plugins = PluginManager.getPlugins();

            // Column Names
            this.columnNames.add("Jar file");
            this.columnNames.add("Format Class");
            this.columnNames.add("Extension Description");

            // Row Data
            for (Map.Entry<String, PluginDescriptor> pair : plugins.entrySet()) {
                PluginDescriptor value = (PluginDescriptor) pair.getValue();
                List<String> row = new LinkedList<>();
                row.add(pair.getKey());
                row.add(value.getFileFormatClass().getName());
                row.add(value.getExtensionDescription());
                this.rowData.add(row);
            }
        }

        @Override
        public int getRowCount() {
            return this.rowData.size() + 1;
        }

        @Override
        public int getColumnCount() {
            return this.columnNames.size();
        }

        @Override
        public String getColumnName(int column) {
            return this.columnNames.get(column);
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            if (rowIndex < this.rowData.size()) {
                return this.rowData.get(rowIndex).get(columnIndex);
            } else {
                return "";
            }
        }
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JLabelHyperLink.java`:

```java
/*
 * JLabelHyperLink.java    August 21, 2010, 10:32
 *
 * Copyright 2009, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.app;

import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JLabel;

/**
 * Hyper Link enabled JLabel.
 *
 * @author Amos Shi
 */
public class JLabelHyperLink extends JLabel {

    private static final long serialVersionUID = 4876543219876500000L;

    /**
     * Text of the label.
     */
    private final String text;
    /**
     * Target URL of the label.
     */
    private final String url;
    /**
     * Flag indicates whether current JVM support browser or not.
     */
    private boolean isSupported;

    /**
     * Create a new Hyper Link enabled JLabel.
     *
     * @param txt Text of the label
     * @param link Target Link URL
     */
    public JLabelHyperLink(final String txt, final String link) {
        this.text = txt;
        this.url = link;

        try {
            this.isSupported = Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE);
        } catch (Exception e) {
            this.isSupported = false;
        }

        this.setText(false);
        this.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseEntered(final MouseEvent e) {
                setText(isSupported);
                if (isSupported) {
                    setCursor(new Cursor(Cursor.HAND_CURSOR));
                }
            }

            @Override
            public void mouseExited(final MouseEvent e) {
                setText(false);
            }

            @Override
            public void mouseClicked(final MouseEvent e) {
                try {
                    Desktop.getDesktop().browse(new URI(JLabelHyperLink.this.url));
                } catch (IOException | URISyntaxException ex) {
                    Logger.getLogger(JLabelHyperLink.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    private void setText(final boolean b) {
        if (!b) {
            setText("<html><font color=blue><u>" + text);
        } else {
            setText("<html><font color=red><u>" + text);
        }
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JPanelForTree.java`:

```java
/*
 * JPanelForTree.java    April 05, 2009, 22:58
 *
 * Copyright 2009, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JToolBar;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * A panel containing a {@code JTree} object.
 *
 * @author Amos Shi
 */
public final class JPanelForTree extends JPanel {

    private static final long serialVersionUID = 4876543219876500000L;
    /**
     * Default editor size.
     */
    private static final Dimension EDITOR_DEFAULT_SIZE = new Dimension(100, 120);
    /**
     * Top level window.
     */
    private final JFrame topLevelFrame;
    /**
     * Details panel.
     */
    private JPanel detailsPanel;
    /**
     * Title for details pane.
     */
    private String detailsTitle;
    /**
     * Tree component for the file components.
     */
    private final JTree tree;
    /**
     * Toolbar on the tree.
     */
    private final JToolBar toolbar;
    /**
     * Toolbar button for details.
     */
    private final JButton toolbarbtnDetails;
    /**
     * Editor pane at the right.
     */
    private JEditorPane editorPaneDescription;

    /**
     * Create a panel tool bar to contain a {@code JTree} object.
     *
     * @param jTree The tree to be contained
     * @param frame The parent window
     */
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "We need it")
    public JPanelForTree(final JTree jTree, final JFrame frame) {
        if (jTree == null) {
            throw new IllegalArgumentException("[tree] cannot be null.");
        }

        this.tree = jTree;
        this.topLevelFrame = frame;
        this.tree.addTreeSelectionListener(this::treeSelectionChanged);

        this.toolbar = new JToolBar();
        this.toolbarbtnDetails = new JButton("Details");
        this.initToolbar();

        this.layoutComponents();
    }

    private void layoutComponents() {
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        final JPanel panelToolbar = new JPanel();
        panelToolbar.setLayout(new BoxLayout(panelToolbar, BoxLayout.X_AXIS));
        panelToolbar.add(this.toolbar);

        final Component glue = Box.createGlue();
        glue.setMaximumSize(new Dimension(Short.MAX_VALUE, this.toolbar.getHeight()));
        panelToolbar.add(glue);

        final JPanel panelToolbarTree = new JPanel();
        panelToolbarTree.setLayout(new BoxLayout(panelToolbarTree, BoxLayout.Y_AXIS));
        panelToolbarTree.add(panelToolbar);
        panelToolbarTree.add(new JScrollPane(this.tree));

        this.editorPaneDescription = new JEditorPane();
        this.editorPaneDescription.setContentType("text/html");
        this.editorPaneDescription.setEditable(false);
        this.editorPaneDescription.setPreferredSize(EDITOR_DEFAULT_SIZE);

        final JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setTopComponent(panelToolbarTree);
        splitPane.setBottomComponent(new JScrollPane(this.editorPaneDescription));
        splitPane.setResizeWeight(1.0);
        this.add(splitPane, BorderLayout.CENTER);
    }

    private void initToolbar() {
        this.toolbar.setRollover(true);

        // Button: Expand All
        final JButton buttonExpandAll = new JButton("Expand All");
        buttonExpandAll.addActionListener((final ActionEvent e) -> toolbarExpandAll());
        this.toolbar.add(buttonExpandAll);

        // Button: Collapse All
        final JButton buttonCollapseAll = new JButton("Collapse All");
        buttonCollapseAll.addActionListener((final ActionEvent e) -> toolbarCollapseAll());
        this.toolbar.add(buttonCollapseAll);

        // Button: Details
        this.toolbarbtnDetails.setVisible(false);
        this.toolbarbtnDetails.addActionListener((final ActionEvent e) -> toolbarShowDetails());
        this.toolbar.add(this.toolbarbtnDetails);
    }

    private void toolbarExpandAll() {
        if (this.tree == null) {
            return;
        }

        int old = 0;
        int now = 0;
        do {
            old = this.tree.getRowCount();
            for (int i = 0; i < old; i++) {
                this.tree.expandRow(i);
            }
            now = this.tree.getRowCount();
        } while (now > old);
    }

    private void toolbarCollapseAll() {
        if (this.tree == null) {
            return;
        }

        this.tree.collapseRow(0);
    }

    private void toolbarShowDetails() {
        Main.showPopup(this.topLevelFrame, this.detailsPanel, this.detailsTitle);
    }

    private void treeSelectionChanged(final TreeSelectionEvent e) {

        this.editorPaneDescription.setText("");
        this.toolbarbtnDetails.setVisible(false);
        this.detailsPanel = null;
        this.detailsTitle = null;

        Object obj = e.getPath().getLastPathComponent();
        if (obj instanceof DefaultMutableTreeNode) {
            final DefaultMutableTreeNode objDmtn = (DefaultMutableTreeNode) obj;
            obj = objDmtn.getUserObject();
            if (obj instanceof JTreeNodeFileComponent) {
                JTreeNodeFileComponent fileComp = (JTreeNodeFileComponent) obj;
                String s = fileComp.getDescription();
                if (s != null && s.length() > 0) {
                    this.editorPaneDescription.setText(s);
                }
                if (fileComp.isDetailAvailable()) {
                    this.toolbarbtnDetails.setVisible(true);
                    this.detailsPanel = fileComp.getDetailPanel();
                    this.detailsTitle = fileComp.getText();
                }
            }
        }
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/JSplitPaneFile.java`:

```java
/*
 * JSplitPaneFile.java    Apr 12, 2011, 10:50
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import javax.swing.Icon;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import org.binaryinternals.binaryviewer.JBinaryViewer;
import org.binaryinternals.plugin.PluginManager;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * A split panel created from a class file byte array.
 *
 * @author Amos Shi
 */
public class JSplitPaneFile extends JSplitPane {

    private static final long serialVersionUID = 4876543219876500000L;
    private final JFrame topLevelFrame;
    private final FileFormat file;
    private final JTabbedPane tabbedPane = new JTabbedPane();
    private final JBinaryViewer binaryViewer = new JBinaryViewer();

    /**
     * Creates a split panel from a Java class file byte array.
     *
     * @param file File name
     * @param frame Parent frame
     * @throws FileFormatException File Format Exception
     * @throws NoSuchMethodException Plugin Exception
     * @throws InstantiationException Plugin Exception
     * @throws IllegalAccessException Plugin Exception
     * @throws InvocationTargetException Plugin Exception
     */
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "We need it")
    public JSplitPaneFile(final File file, final JFrame frame) throws FileFormatException, NoSuchMethodException, SecurityException, InstantiationException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        this.file = PluginManager.getFile(file);
        this.topLevelFrame = frame;
        this.createAndShowGUI();
    }

    /**
     * Getter {@link #file} name.
     *
     * @return {@link #file} name
     */
    public String getFileFormatName(){
        return this.file.getClass().getSimpleName();
    }
    
    private int calcDividerLocation(){
        final double width = this.topLevelFrame.getWidth() * 0.4;
        if (width < 260) {
            return 260;
        } else if (width > 1200) {
            return 1200;
        } else {
            return (int) Math.floor(width);
        }
    }

    @SuppressWarnings("java:S3776") // Cognitive Complexity of methods should not be too high
    private void createAndShowGUI() {

        final DefaultMutableTreeNode root = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                0,
                this.file.fileByteArray.length,
                this.file.fileName,
                this.file.getIcon(),
                this.file.filePath));
        this.file.generateTreeNode(root);
        final JTree tree = new JTree(new DefaultTreeModel(root));

        tree.setCellRenderer(new DefaultTreeCellRenderer() {

            @Override
            public Component getTreeCellRendererComponent(final JTree tree, final Object value,
                    final boolean sel, final boolean expanded, final boolean leaf, final int row,
                    final boolean hasFocus) {

                super.getTreeCellRendererComponent(tree, value,
                        sel, expanded, leaf, row,
                        hasFocus);

                if (value instanceof DefaultMutableTreeNode && ((DefaultMutableTreeNode) value).getUserObject() instanceof JTreeNodeFileComponent) {
                    JTreeNodeFileComponent fileComp = (JTreeNodeFileComponent) ((DefaultMutableTreeNode) value).getUserObject();
                    final Icon icon = fileComp.getIcon();
                    if (icon != null) {
                        this.setIcon(icon);
                    }

                    if (fileComp.isDetailAvailable()) {
                        this.setText("<html><font color=blue><u>" + fileComp.getText());
                    } else {
                        this.setText(fileComp.getText());
                    }
                }

                return this;
            }
        });

        tree.addTreeSelectionListener(this::treeSelectionChanged);
        tree.addMouseListener(new MouseAdapter() {

            @Override
            public void mousePressed(MouseEvent e) {
                TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
                if (selPath != null) {
                    Object obj = selPath.getLastPathComponent();
                    if (obj instanceof DefaultMutableTreeNode) {
                        final DefaultMutableTreeNode objDmtn = (DefaultMutableTreeNode) obj;
                        if (objDmtn.getUserObject() instanceof JTreeNodeFileComponent) {
                            JTreeNodeFileComponent fileComp = (JTreeNodeFileComponent) objDmtn.getUserObject();
                            if (fileComp.isDetailAvailable() && e.getClickCount() == 2) {
                                treeDoubleClickPopup(fileComp.getDetailPanel(), fileComp.getText());
                            }
                        }
                    }
                }
            }
        });

        final JPanelForTree panel = new JPanelForTree(tree, this.topLevelFrame);

        this.binaryViewer.setData(this.file.fileByteArray);
        JScrollPane binaryViewerView = new JScrollPane(this.binaryViewer);
        binaryViewerView.getVerticalScrollBar().setValue(0);
        this.tabbedPane.add(this.file.getContentTabName(), binaryViewerView);

        this.setOrientation(JSplitPane.HORIZONTAL_SPLIT);
        this.setDividerSize(5);
        this.setDividerLocation(this.calcDividerLocation());
        this.setLeftComponent(panel);
        this.setRightComponent(tabbedPane);

        binaryViewerView.getVerticalScrollBar().setValue(0);
    }

    private void treeSelectionChanged(final TreeSelectionEvent evt) {
        Object obj = evt.getPath().getLastPathComponent();
        if (obj instanceof DefaultMutableTreeNode) {
            final DefaultMutableTreeNode objDmtn = (DefaultMutableTreeNode) obj;
            obj = objDmtn.getUserObject();
            if (obj instanceof JTreeNodeFileComponent) {
                final JTreeNodeFileComponent objTnfc = (JTreeNodeFileComponent) obj;
                this.binaryViewer.setSelection(objTnfc.getStartPos(), objTnfc.getLength());
                this.file.treeSelectionChanged(objTnfc, this.tabbedPane);
            }
        }
    }

    private void treeDoubleClickPopup(JPanel panel, String title) {
        Main.showPopup(this.topLevelFrame, panel, title);
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/app/Main.java`:

```java
/*
 * Main.java    Apr 12, 2011, 10:50
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.app;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.StringJoiner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractAction;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.WindowConstants;
import org.binaryinternals.plugin.PluginManager;

/**
 *
 *
 * @author Amos Shi
 */
public class Main extends JFrame {

    private static final long serialVersionUID = 4876543219876500000L;
    private static final Logger LOGGER = Logger.getLogger(Main.class.getName());
    /**
     * Size ratio of the pop-up window and its parent.
     */
    private static final float POPUP_RATIO = 0.8f;
    private static final String URI_HOMEPAGE = "https://github.com/amosshi/binaryinternals";
    private static final String TITLE = "Binary Internals Viewer ";
    private static final String MASS_TEST_MODE_PROPERTY = "org.binaryinternals.masstestmode";

    private final JPanel filedropPanel = new JPanel();
    private final Set<File> recentFiles = new HashSet<>();
    private final JMenu menuFileRecentFile = new JMenu("Recent Files");
    private JSplitPaneFile contentPane = null;

    @SuppressWarnings("LeakingThisInConstructor")
    @SuppressFBWarnings(value = "DM_EXIT", justification = "This is desigend for mass test mode")
    private Main(final String[] args) {
        this.setTitle(TITLE + PluginManager.getPlugedExtensions());
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        this.centerJFrame();
        this.createMenu();
        this.filedropPanel.setBackground(Color.WHITE);
        this.filedropPanel.setLayout(new BorderLayout());
        this.add(this.filedropPanel, BorderLayout.CENTER);

        this.enalbeFileDrop(this.filedropPanel);
        this.enalbeFileDrop(this.getJMenuBar());
        this.setVisible(true);

        // Accept file name at command line
        if (args.length > 0) {
            final String fileName = args[0];
            final File file = new File(fileName);
            if (file.exists()) {
                try {
                    this.openFile(file);
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, String.format("Failed to open the file. filename=%s", fileName), e);
                }
            } else {
                LOGGER.log(Level.WARNING, "The provided file does not exist: filename={0}", fileName);
            }

            // Exit immediately for mass test mode
            if (Boolean.TRUE.equals(Boolean.valueOf(System.getProperty(Main.MASS_TEST_MODE_PROPERTY, "false")))) {
                System.exit(0);
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new Main(args).setVisible(true));
    }

    /**
     * Set a {@code JFrame} window to screen center.
     */
    private void centerJFrame() {
        // Set main window size
        final Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
        this.setSize(
                (int) (d.getWidth() * POPUP_RATIO),
                (int) (d.getHeight() * POPUP_RATIO));

        // Center the main window
        this.setLocationRelativeTo(null);
    }

    private void createMenu() {
        final JMenuBar menuBar = new JMenuBar();
        this.setJMenuBar(menuBar);

        // File
        final JMenu menuFile = new JMenu("File");
        menuFile.setMnemonic(KeyEvent.VK_F);
        menuBar.add(menuFile);

        // File --> Open
        final JMenuItem menuItemFileOpen = new JMenuItem("Open...", UIManager.getIcon("FileView.directoryIcon"));
        menuItemFileOpen.setMnemonic(KeyEvent.VK_O);
        menuItemFileOpen.setAccelerator(KeyStroke.getKeyStroke(
                KeyEvent.VK_O,
                ActionEvent.CTRL_MASK));
        menuItemFileOpen.addActionListener((final ActionEvent e) -> menuFileOpen());
        menuFile.add(menuItemFileOpen);

        // File --> Close
        final JMenuItem menuItemFileClose = new JMenuItem("Close", UIManager.getIcon("InternalFrame.iconifyIcon"));
        menuItemFileClose.setMnemonic(KeyEvent.VK_C);
        menuItemFileClose.addActionListener((final ActionEvent e) -> closeFile());
        menuFile.add(menuItemFileClose);

        menuFile.addSeparator();
        // File --> Recent Files
        this.menuFileRecentFile.setMnemonic(KeyEvent.VK_R);
        menuFile.add(this.menuFileRecentFile);
        //
        menuFile.addSeparator();

        // File --> Exit
        final JMenuItem menuItemFileExit = new JMenuItem("Exit", UIManager.getIcon("Table.ascendingSortIcon"));
        menuItemFileExit.setMnemonic(KeyEvent.VK_E);
        menuItemFileExit.setAccelerator(KeyStroke.getKeyStroke(
                KeyEvent.VK_E,
                ActionEvent.CTRL_MASK));
        menuItemFileExit.addActionListener((final ActionEvent e)
                -> Main.this.dispatchEvent((new WindowEvent(Main.this, WindowEvent.WINDOW_CLOSING)))
        );
        menuFile.add(menuItemFileExit);

        // Help
        final JMenu menuHelp = new JMenu("Help");
        menuFile.setMnemonic(KeyEvent.VK_H);
        menuBar.add(menuHelp);

        // Help --> Homepage
        final JMenuItem menuItemHelpHomepage = new JMenuItem("Homepage", UIManager.getIcon("FileView.computerIcon"));
        menuItemHelpHomepage.setMnemonic(KeyEvent.VK_H);
        menuItemHelpHomepage.addActionListener((final ActionEvent e) -> menuHelpHomepage());
        menuHelp.add(menuItemHelpHomepage);

        // Help --> Plugins
        final JMenuItem menuItemHelpPlugins = new JMenuItem("Plug-ins");
        menuItemHelpPlugins.setMnemonic(KeyEvent.VK_P);
        menuItemHelpPlugins.addActionListener((final ActionEvent e) -> menuHelpPlugins());
        menuHelp.add(menuItemHelpPlugins);

        // Help --> Plugins
        final JMenuItem menuItemHelpIcons = new JMenuItem("Icons");
        menuItemHelpIcons.setMnemonic(KeyEvent.VK_P);
        menuItemHelpIcons.addActionListener((final ActionEvent e) -> menuHelpIcons());
        menuHelp.add(menuItemHelpIcons);

        // Help --> About
        final JMenuItem menuItemHelpAbout = new JMenuItem("About");
        menuItemHelpAbout.setMnemonic(KeyEvent.VK_A);
        menuItemHelpAbout.addActionListener((final ActionEvent e) -> menuHelpAbout());
        menuHelp.add(menuItemHelpAbout);
    }

    /**
     * Support drag and drop. Only the 1st file are handled, if more than 1 file
     * are dropped.
     */
    private void enalbeFileDrop(Component c) {
        c.setDropTarget(new DropTarget() {
            @Override
            public synchronized void drop(DropTargetDropEvent evt) {
                try {
                    evt.acceptDrop(DnDConstants.ACTION_COPY);
                    Object drops = evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);
                    if (drops instanceof List) {
                        openFile(((List<File>) drops).get(0));
                    }
                } catch (UnsupportedFlavorException | IOException e) {
                    LOGGER.warning(e.getMessage());
                }
            }
        });
    }

    private void menuFileOpen() {
        final JFileChooser chooser = new JFileChooser();
        PluginManager.initChooseFilters(chooser);

        final int returnVal = chooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            this.openFile(chooser.getSelectedFile());
        }
    }

    /**
     * <pre>
     * java:S1181 - Throwable and Error should not be caught  --- We need to cache all exception here
     * </pre>
     */
    @SuppressWarnings("java:S1181")
    private void openFile(final File file) {
        // Close any open file first if exists
        this.closeFile();

        // Update Recent files menu item
        this.menuFileRecentFile.removeAll();
        this.recentFiles.add(file);
        this.recentFiles.forEach(recent
                -> this.menuFileRecentFile.add(new JMenuItem(new AbstractAction(recent.getAbsolutePath()) {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        openFile(recent);
                    }
                }))
        );

        // Add the file to UI
        try {
            this.contentPane = new JSplitPaneFile(file, this);
        } catch (Throwable ex) {
            String message = ex.getMessage();
            if (message == null || message.trim().length() < 1) {
                message = ex.getCause() != null ? ex.getCause().getMessage() : "";
            }
            LOGGER.log(Level.SEVERE, message, ex);
            JOptionPane.showMessageDialog(
                    this,
                    message,
                    this.getTitle(),
                    JOptionPane.ERROR_MESSAGE);
        }

        StringJoiner joiner = new StringJoiner(" - ");
        joiner.add(file.getName()).add(file.getAbsolutePath()).add(this.contentPane.getFileFormatName()).add(TITLE);
        this.setTitle(joiner.toString());
        this.filedropPanel.add(this.contentPane, BorderLayout.CENTER);

        // Resize after adding new content
        this.setSize(this.getWidth() + 2, this.getHeight());
        this.setSize(this.getWidth() - 2, this.getHeight());
    }

    private void closeFile() {
        this.setTitle(TITLE + PluginManager.getPlugedExtensions());
        // Clear Content
        if (this.contentPane != null) {
            this.filedropPanel.remove(this.contentPane);
            this.validate();
        }
        this.contentPane = null;

        // Refersh the view
        this.setSize(this.getWidth() - 1, this.getHeight());
    }

    private void menuHelpAbout() {
        final JDialogAbout about = new JDialogAbout(this, "About");
        about.setLocationRelativeTo(this);
        about.setVisible(true);
    }

    private void menuHelpHomepage() {
        try {
            Desktop.getDesktop().browse(new URI(URI_HOMEPAGE));
        } catch (URISyntaxException | IOException ex) {
            JOptionPane.showMessageDialog(
                    this,
                    ex.getMessage(),
                    this.getTitle(),
                    JOptionPane.WARNING_MESSAGE);
        }
    }

    private void menuHelpIcons() {
        final JDialogIcons icons = new JDialogIcons(this, "Icons");
        icons.setLocationRelativeTo(this);
        icons.setVisible(true);
    }

    private void menuHelpPlugins() {
        final JDialogPlugins plugins = new JDialogPlugins(this, "Plug-ins");
        plugins.setLocationRelativeTo(this);
        plugins.setVisible(true);
    }

    /**
     * Show a popup window with given message.
     *
     * @param frame Parent window
     * @param panel Content in panel
     * @param title Popup window title
     */
    static void showPopup(final JFrame frame, final JPanel panel, final String title) {
        if (frame == null || panel == null) {
            return;
        }

        final JDialog popup = new JDialog(frame, title);
        popup.setSize(
                (int) Math.floor(frame.getWidth() * POPUP_RATIO),
                (int) Math.floor(frame.getHeight() * POPUP_RATIO));
        popup.setLayout(new BorderLayout());
        popup.add(panel, BorderLayout.CENTER);
        popup.setLocationRelativeTo(frame);
        popup.setVisible(true);
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/binaryviewer/DataViewer.java`:

```java
/*
 * JAsciiDataViewer.java    September 08, 2019, 19:17 PM
 *
 * Copyright  2019, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.binaryviewer;

import javax.swing.JTextPane;

/**
 * Display binary data.
 *
 * @author Amos Shi
 */
public abstract class DataViewer extends JTextPane {

    /**
     * Binary data will be displayed.
     */
    private byte[] data = null;
    /**
     * Start index to be high-lighted.
     */
    private int selectedStartIndex = 0;
    /**
     * Length to be high-lighted.
     */
    private int selectedLength = 0;

    /**
     * Constructor.
     */
    DataViewer() {
        super();
        this.setEditable(false);
        this.setBorder(null);
        this.setContentType("text/html");
    }

    /**
     * Set the binary data to be displayed.
     *
     * @param bin Binary data.
     */
    public void setData(final byte[] bin) {
        if (bin == null) {
            this.data = null;
        } else {
            this.data = bin.clone();
        }

        this.updateContent();
    }

    /**
     * Set the selection part to be high-lighted.
     *
     * @param startIndex Start index to be high-lighted
     * @param length Length to be high-lighted
     */
    public void setSelection(final int startIndex, final int length) {
        this.selectedStartIndex = startIndex;
        this.selectedLength = length;
        this.updateContent();
    }

    /**
     * Return value of {@link #data}.
     *
     * @return Value of {@link #data}
     */
    protected byte[] getData() {
        return this.data;
    }

    /**
     * Return value of {@link #selectedStartIndex}.
     *
     * @return Value of {@link #selectedStartIndex}
     */
    protected int getSelectedStartIndex() {
        return this.selectedStartIndex;
    }

    /**
     * Return value of {@link #selectedLength}.
     *
     * @return Value of {@link #selectedLength}
     */
    protected int getSelectedLength() {
        return this.selectedLength;
    }

    protected abstract void updateContent();
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/binaryviewer/JAsciiDataViewer.java`:

```java
/*
 * JAsciiDataViewer.java    September 12, 2007, 2:15 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.binaryviewer;

import org.binaryinternals.commonlib.ui.HTMLKit;

/**
 * Display binary data as ASCII text.
 *
 * @author Amos Shi
 */
final class JAsciiDataViewer extends DataViewer {

    private static final long serialVersionUID = 4876543219876500004L;
    /**
     * Width of the ASCII data viewer section.
     */
    public static final int WIDTH_VALUE = 231;

    @Override
    protected void updateContent() {
        this.setText(null);
        byte[] data = super.getData();
        if (data == null) {
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(HTMLKit.START);

        final int dataLength = data.length;
        int breakCounter = 0;
        for (int i = 0; i < dataLength; i++) {
            if (this.getSelectedLength() > 0
                    && i >= this.getSelectedStartIndex()
                    && i < this.getSelectedStartIndex() + this.getSelectedLength()) {
                sb.append(HTMLKit.span(HTMLKit.getByteText(data[i]), HTMLKit.FONT_COLOR_YELLOW));
            } else {
                sb.append(HTMLKit.span(HTMLKit.getByteText(data[i])));
            }
            breakCounter++;

            if (breakCounter > JBinaryViewer.ROW_ITEM_MAX_INDEX) {
                sb.append(HTMLKit.NEW_LINE);
                breakCounter = 0;
            }
        }

        sb.append(HTMLKit.END);
        this.setText(sb.toString());
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/binaryviewer/JBinaryViewer.java`:

```java
/*
 * JBinaryViewer.java    September 3, 2007, 12:07 AM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.binaryviewer;

import java.awt.BorderLayout;
import java.awt.event.AdjustmentEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.SpringLayout;

/**
 * Viewer for binary data. It contains three columns: row numbers, data in HEX,
 * data in ASCII.
 *
 * @author Amos Shi
 */
public final class JBinaryViewer extends JPanel {

    private static final long serialVersionUID = 4876543219876500005L;

    /**
     * Height for each row.
     */
    public static final int ITEM_HEIGHT = 22;

    /**
     * Number of bytes to be shown in one row.
     */
    public static final int ROW_ITEM_MAX = 16;

    /**
     * 0-based row item index.
     */
    public static final int ROW_ITEM_MAX_INDEX = ROW_ITEM_MAX - 1;

    /**
     * Spare space in bottom.
     */
    private static final int ROW_EMPTYROW_COUNT = 10;

    /**
     * Constant value for <code>-4</code>.
     */
    private static final int MINUS_4 = -4;

    /**
     * Column 1: row viewer.
     */
    private final JRowViewer rowViewer;

    /**
     * Column 2: Data viewer in HEX format.
     */
    private final JRawDataViewer rawViewer;

    /**
     * Column 3: Data viewer in ASCII format.
     */
    private final JAsciiDataViewer asciiViewer;

    /**
     * Binary data to be shown.
     */
    private byte[] data = null;

    /**
     * Vertical scroll bar for paging.
     */
    private final JScrollBar vBar;

    /**
     * Max number of rows will be shown, due to the {@link #data} size.
     */
    private int rowMax;

    /**
     * Start index to be high-lighted.
     *
     * @see DataViewer#selectedStartIndex
     */
    private int selectedStartIndex = 0;

    /**
     * Length to be high-lighted.
     *
     * @see DataViewer#selectedLength
     */
    private int selectedLength = 0;

    /**
     * Constructor.
     */
    public JBinaryViewer() {
        this.setLayout(new BorderLayout());
        this.addComponentListener(new ComponentResizedAdapter());
        this.addMouseWheelListener(new MouseWheelAdapter());

        // Vertical Bar
        this.vBar = new JScrollBar();
        this.vBar.addAdjustmentListener((final AdjustmentEvent e) -> updateViewContent());
        this.vBar.setVisible(false);

        this.add(this.vBar, BorderLayout.EAST);

        // Content Panel
        final JPanel panel = new JPanel();
        final SpringLayout panelLayout = new SpringLayout();
        int left;
        int right;

        panel.setLayout(panelLayout);

        this.rowViewer = new JRowViewer();
        this.rawViewer = new JRawDataViewer();
        this.rawViewer.addKeyListener(new KeyboardAdapter());
        this.asciiViewer = new JAsciiDataViewer();
        this.asciiViewer.addKeyListener(new KeyboardAdapter());

        panel.add(this.rowViewer);
        panel.add(this.rawViewer);
        panel.add(this.asciiViewer);

        panelLayout.putConstraint(SpringLayout.WEST, this.rowViewer, 2, SpringLayout.WEST, panel);
        panelLayout.putConstraint(SpringLayout.NORTH, this.rowViewer, 2, SpringLayout.NORTH, panel);
        panelLayout.putConstraint(SpringLayout.SOUTH, this.rowViewer, MINUS_4, SpringLayout.SOUTH, panel);
        panelLayout.putConstraint(SpringLayout.EAST, this.rowViewer, JRowViewer.WIDTH_VALUE, SpringLayout.WEST, panel);

        left = 2 + JRowViewer.WIDTH_VALUE + 2;
        right = left + JRawDataViewer.WIDTH_VALUE;
        panelLayout.putConstraint(SpringLayout.WEST, this.rawViewer, left, SpringLayout.WEST, panel);
        panelLayout.putConstraint(SpringLayout.NORTH, this.rawViewer, 2, SpringLayout.NORTH, panel);
        panelLayout.putConstraint(SpringLayout.SOUTH, this.rawViewer, MINUS_4, SpringLayout.SOUTH, panel);
        panelLayout.putConstraint(SpringLayout.EAST, this.rawViewer, right, SpringLayout.WEST, panel);

        left = right + 2;
        right = left + JAsciiDataViewer.WIDTH_VALUE;
        panelLayout.putConstraint(SpringLayout.WEST, this.asciiViewer, left, SpringLayout.WEST, panel);
        panelLayout.putConstraint(SpringLayout.NORTH, this.asciiViewer, 2, SpringLayout.NORTH, panel);
        panelLayout.putConstraint(SpringLayout.SOUTH, this.asciiViewer, MINUS_4, SpringLayout.SOUTH, panel);
        panelLayout.putConstraint(SpringLayout.EAST, this.asciiViewer, right, SpringLayout.WEST, panel);

        this.add(panel, BorderLayout.CENTER);
    }

    /**
     * Set the binary data to be displayed.
     *
     * @param bytes Binary data to be displayed
     */
    public void setData(final byte[] bytes) {
        if (bytes == null) {
            return;
        }

        this.data = bytes.clone();

        // Calc the max row count
        this.rowMax = this.getRowMax();
        this.vBar.setMaximum(this.rowMax + JBinaryViewer.ROW_EMPTYROW_COUNT);
        this.vBar.setValue(0);

        this.updateViewContent();
    }

    private int getRowMax() {
        return (this.data != null)
                ? this.getRowCount(this.data.length)
                : 0;
    }

    /**
     * Return 1-based row count number.
     *
     * @param number to explain
     * @return 1-based row number
     */
    private int getRowCount(final int number) {
        int count = 0;
        int max = number;
        while (max > 0) {
            count++;
            max -= ROW_ITEM_MAX;
        }
        return count;
    }

    private int getExtent() {
        return (int) Math.ceil(this.getSize().getHeight() / ITEM_HEIGHT);
    }

    private void updateViewContent() {
        // Update Extent
        int extent = this.getExtent();
        if (extent <= 0) {
            return;                                                             // The window Hight is (nearly) zero
        }
        this.vBar.setVisibleAmount(extent);

        if ((extent + this.vBar.getValue()) > (this.rowMax + JBinaryViewer.ROW_EMPTYROW_COUNT)) {
            int diff = (this.rowMax + JBinaryViewer.ROW_EMPTYROW_COUNT) - extent;
            diff = (diff > 0) ? diff : 0;
            this.vBar.setValue(diff);
        }
        this.vBar.setVisible(extent < this.rowMax + JBinaryViewer.ROW_EMPTYROW_COUNT);

        // Revise row viewer, raw data viewer, ASCII data viewer
        this.rowViewer.setData(this.vBar.getValue(), extent, this.rowMax);
        if (this.data != null && this.data.length > 0) {
            // Calc the buffer data
            int startPos = this.vBar.getValue() * JBinaryViewer.ROW_ITEM_MAX;
            int dataSize = extent * JBinaryViewer.ROW_ITEM_MAX;

            dataSize = Math.min(dataSize, this.data.length - startPos);
            if (dataSize > 0) {
                byte[] buf = new byte[dataSize];
                System.arraycopy(this.data, startPos, buf, 0, dataSize);

                // Set the buffer
                this.rawViewer.setData(buf);
                this.asciiViewer.setData(buf);
            }
        }

        // Revise selection
        this.updateSelection();
    }

    /**
     * Selects the bytes between the specified start position and length.
     *
     * @param selectionStart the start position of the bytes
     * @param length the length of the bytes
     */
    public void setSelection(final int selectionStart, final int length) {
        if ((this.data == null) || (selectionStart < 0)) {
            return;
        }
        if (this.data.length < (selectionStart + length - 1)) {
            return;
        }

        this.selectedStartIndex = selectionStart;
        this.selectedLength = length;

        this.ensureVisible(selectionStart);
        this.updateSelection();
    }

    private void updateSelection() {
        final int startPos = this.selectedStartIndex - this.vBar.getValue() * JBinaryViewer.ROW_ITEM_MAX;
        final int lengtgMax = this.getExtent() * JBinaryViewer.ROW_ITEM_MAX;
        int length;

        if (startPos > 0) {
            length = Math.min(this.selectedLength, lengtgMax);                  // Improve Performance
            this.rawViewer.setSelection(startPos, length);
            this.asciiViewer.setSelection(startPos, length);
        } else if ((startPos + this.selectedLength) > 0) {
            length = Math.min(startPos + this.selectedLength, lengtgMax);       // Improve Performance
            this.rawViewer.setSelection(0, length);
            this.asciiViewer.setSelection(0, length);
        } else {
            this.rawViewer.setSelection(0, 0);
            this.asciiViewer.setSelection(0, 0);
        }
    }

    /**
     * Ensure the byte at <code>startPos</code> is visible.
     *
     * @param startPos the start position of the byte(s) to be visible
     */
    private void ensureVisible(final int startPos) {
        if ((this.data == null) || (startPos < 0) || (this.data.length < (startPos - 1))) {
            return;
        }

        int rowId = this.getRowCount(startPos) - 1;
        int low = this.vBar.getValue();
        int high = low + this.getExtent() - 1;
        if (rowId < low || rowId > high) {
            this.vBar.setValue(rowId);
        }
    }

    @SuppressWarnings("PackageVisibleInnerClass")
    class ComponentResizedAdapter extends ComponentAdapter {

        @Override
        public void componentResized(final ComponentEvent e) {
            super.componentResized(e);
            updateViewContent();
        }
    }

    @SuppressWarnings("PackageVisibleInnerClass")
    class MouseWheelAdapter implements MouseWheelListener {

        @Override
        public void mouseWheelMoved(final MouseWheelEvent e) {
            switch (e.getScrollType()) {
                case MouseWheelEvent.WHEEL_UNIT_SCROLL:
                    JBinaryViewer.this.vBar.setValue(
                            JBinaryViewer.this.vBar.getValue()
                            + e.getUnitsToScroll());
                    break;
                case MouseWheelEvent.WHEEL_BLOCK_SCROLL:
                    break;
                default:
                    break;
            }
        }
    }

    @SuppressWarnings("PackageVisibleInnerClass")
    class KeyboardAdapter implements KeyListener {

        @Override
        @SuppressWarnings("java:S1186")  // Methods should not be empty --- Ignore this rule
        public void keyTyped(final KeyEvent e) {
        }

        @Override
        public void keyPressed(final KeyEvent e) {

            switch (e.getKeyCode()) {
                case KeyEvent.VK_HOME:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getMinimum());
                    break;

                case KeyEvent.VK_END:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getMaximum());
                    break;

                case KeyEvent.VK_UP:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getValue() - 1);
                    break;
                case KeyEvent.VK_DOWN:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getValue() + 1);
                    break;

                case KeyEvent.VK_LEFT:
                case KeyEvent.VK_PAGE_UP:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getValue() - JBinaryViewer.this.vBar.getVisibleAmount());
                    break;

                case KeyEvent.VK_RIGHT:
                case KeyEvent.VK_PAGE_DOWN:
                    JBinaryViewer.this.vBar.setValue(JBinaryViewer.this.vBar.getValue() + JBinaryViewer.this.vBar.getVisibleAmount());
                    break;

                default:
                    break;
            }
        }

        @Override
        @SuppressWarnings("java:S1186")  // Methods should not be empty --- Ignore this rule
        public void keyReleased(final KeyEvent e) {
        }
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/binaryviewer/JRawDataViewer.java`:

```java
/*
 * JRawDataViewer.java    September 12, 2007, 2:12 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.binaryviewer;

import org.binaryinternals.commonlib.ui.HTMLKit;

/**
 * Display binary data as HEX text.
 *
 * @author Amos Shi
 */
final class JRawDataViewer extends DataViewer {

    private static final long serialVersionUID = 4876543219876500000L;
    /**
     * Width of the raw data viewer section.
     */
    public static final int WIDTH_VALUE = 460;

    @Override
    protected void updateContent() {
        this.setText(null);

        byte[] data = super.getData();
        if (data == null) {
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(HTMLKit.START);

        final int dataLength = data.length;
        int breakCounter = 0;
        for (int i = 0; i < dataLength; i++) {
            sb.append(HTMLKit.SPACE);
            if (this.getSelectedLength() > 0
                    && i >= this.getSelectedStartIndex()
                    && i < this.getSelectedStartIndex() + this.getSelectedLength()) {
                sb.append(HTMLKit.span(String.format("%02X", data[i]), HTMLKit.FONT_COLOR_ORANGE));
            } else {
                sb.append(HTMLKit.span(String.format("%02X", data[i])));
            }
            breakCounter++;

            if (breakCounter > JBinaryViewer.ROW_ITEM_MAX_INDEX) {
                sb.append(HTMLKit.NEW_LINE);
                breakCounter = 0;
            }
        }

        sb.append(HTMLKit.END);
        this.setText(sb.toString());
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/binaryviewer/JRowViewer.java`:

```java
/*
 * JRowViewer.java    September 12, 2007, 2:28 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.binaryviewer;

import org.binaryinternals.commonlib.ui.HTMLKit;
import java.awt.Component;
import javax.swing.JTextPane;

/**
 * Display rows of binary data.
 *
 * @author Amos Shi
 */
class JRowViewer extends JTextPane {

    private static final long serialVersionUID = 4876543219876500000L;
    /**
     * Width of the row viewer.
     */
    public static final int WIDTH_VALUE = 110;

    /**
     * Constructor.
     */
    public JRowViewer() {
        super();
        this.setAlignmentX(Component.LEFT_ALIGNMENT);
        this.setEditable(false);
        this.setBorder(null);
        this.setContentType("text/html");
    }

    /**
     * Set revised Binary data.
     *
     * @param rowStart  Start row to be displayed
     * @param rowCount  Number of rows to be displayed
     * @param rowMax    Max row
     */
    public void setData(final int rowStart, final int rowCount, final int rowMax) {

        // Update contents
        this.setText(null);
        if (rowCount <= 0) {
            return;
        }
        if (rowStart >= rowMax) {
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(HTMLKit.START);

        int rowValue = rowStart * JBinaryViewer.ROW_ITEM_MAX;
        for (int i = 0; i < rowCount; i++) {
            if ((rowStart + i) < rowMax) {
                sb.append(HTMLKit.span(String.format("%08Xh", rowValue)));
                sb.append(HTMLKit.NEW_LINE);
                rowValue += JBinaryViewer.ROW_ITEM_MAX;
            }
        }

        sb.append(HTMLKit.END);
        this.setText(sb.toString());
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/plugin/DefaultFileFormat.java`:

```java
/*
 * FileFormatDefault.java    Apr 14, 2011, 23:55
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.plugin;

import org.binaryinternals.commonlib.core.FileFormat;
import java.io.File;
import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 */
public class DefaultFileFormat extends FileFormat{


    public DefaultFileFormat(final File file) throws IOException, FileFormatException {
        super(file);
    }


    @Override
    @SuppressWarnings("java:S1186")  // Methods should not be empty --- Ignore this rule
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
    }
    @Override
    public String getContentTabName() {
       return "Binary Data";
    }

    @Override
    public Icons getIcon() {
        return Icons.BinaryFile;
    }
}

```

`BinaryInternalsViewer/src/main/java/org/binaryinternals/plugin/PluginManager.java`:

```java
/*
 * Plugin.java    Apr 12, 2011, 13:04
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.plugin;

import org.binaryinternals.commonlib.core.PluginDescriptor;
import org.binaryinternals.commonlib.core.FileFormat;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.Map;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class PluginManager {

    public static final String MANIFEST_ATTR_NAME = "biv-plugin";
    public static final String PLUGIN_DIR = System.getProperty("user.dir")
            + System.getProperty("file.separator")
            + "libs";
    /**
     * Jar file name and the plug-in descriptor.
     */
    static final Map<String, PluginDescriptor> PLUGINS = new HashMap<>(10);

    static {
        loadPlugins();
    }

    private PluginManager() {
    }

    /**
     * <pre>
     * java:S135 - Loops should not contain more than a single "break" or "continue" statement --- multiple "continue" make code more readable
     * java:S3776 - Cognitive Complexity of methods should not be too high
     * </pre>
     */
    @SuppressWarnings({"java:S135", "java:S3776"}) 
    private static void loadPlugins() {
        File pluginFolder = new File(PLUGIN_DIR);
        String pluginDescClassName;

        if (!pluginFolder.exists()) {
            // The plugin folder does not exist
            return;
        }

        File[] pluginFiles = pluginFolder.listFiles();
        if (pluginFiles == null) {
            return;
        }

        for (File plguinFile : pluginFiles) {
            if (plguinFile.isFile() && plguinFile.getName().toLowerCase().endsWith(".jar")) {
                try (JarFile jar = new JarFile(plguinFile)) {
                    Manifest mf = jar.getManifest();
                    if (mf == null) {
                        continue;
                    }

                    pluginDescClassName = mf.getMainAttributes().getValue(MANIFEST_ATTR_NAME);
                    if (pluginDescClassName == null || pluginDescClassName.length() == 0) {
                        continue;
                    }

                    loadPlugin(plguinFile, pluginDescClassName);
                } catch (Exception ex) {
                    Logger.getLogger(PluginManager.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }

    private static void loadPlugin(File pluginFile, String pluginDescClassName) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        URL url = pluginFile.toURI().toURL();
        try (URLClassLoader loader = new URLClassLoader(new URL[]{url})) {
            Class<?> cls = loader.loadClass(pluginDescClassName);
            if (cls == null) {
                return;
            }

            PLUGINS.put(pluginFile.getName(), (PluginDescriptor) cls.getDeclaredConstructor().newInstance());
        }
    }

    public static String getPlugedExtensions() {
        StringBuilder builder = new StringBuilder(16);
        if (!PLUGINS.isEmpty()) {
            builder.append(" - ");
            PLUGINS.values().stream().map(plugin -> plugin.getExtensions()).forEachOrdered(exts -> {
                for (String ext : exts) {
                    builder.append(ext);
                    builder.append(", ");
                }
            });
            builder.append(" ...");
        }

        return builder.toString();
    }

    public static void initChooseFilters(JFileChooser chooser) {
        FileNameExtensionFilter filter;
        for (PluginDescriptor plugin : PLUGINS.values()) {
            filter = new FileNameExtensionFilter(
                    plugin.getExtensionDescription(),
                    plugin.getExtensions());
            chooser.addChoosableFileFilter(filter);
        }
    }

    public static FileFormat getFile(final File file) throws FileFormatException, NoSuchMethodException,
            SecurityException, IllegalArgumentException, InstantiationException, IllegalAccessException,
            InvocationTargetException {
        Class<? extends FileFormat> fileFormatClass = null;
        String ext = file.getName().substring(file.getName().lastIndexOf('.') + 1);

        for (PluginDescriptor plugin : PLUGINS.values()) {
            if (isContain(plugin.getExtensions(), ext)) {
                fileFormatClass = plugin.getFileFormatClass();
            }
        }
        if (fileFormatClass == null) {
            fileFormatClass = DefaultFileFormat.class;
        }

        Constructor<? extends FileFormat> c = fileFormatClass.getConstructor(File.class);
        return c.newInstance(file);
    }

    static boolean isContain(String[] exts, String ext) {
        boolean result = false;
        if (exts != null && exts.length != 0) {
            for (String item : exts) {
                if (item.equalsIgnoreCase(ext)) {
                    result = true;
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Return the loaded {@link #PLUGINS}.
     *
     * @return Loaded plug-ins
     */
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = "MS_EXPOSE_REP", justification = "We need it")
    public static Map<String, PluginDescriptor> getPlugins() {
        return PLUGINS;
    }
}

```

`CommonLib/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.commonlib</artifactId>
    <packaging>jar</packaging>

    <name>binaryinternals :: CommonLib</name>
    <description>Common library for Binary File Format parsers</description>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <Automatic-Module-Name>org.binaryinternals.commonlib</Automatic-Module-Name>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

```

`CommonLib/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author Amos SHI
 */
module org.binaryinternals.commonlib {
    requires java.base;
    requires transitive java.desktop;
    requires transitive java.logging;
    requires static com.github.spotbugs.annotations;

    exports org.binaryinternals.commonlib.core;
    exports org.binaryinternals.commonlib.ui;
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/BytesTool.java`:

```java
/*
 * Tool.java    August 21, 2010, 23:07 AM
 *
 * Copyright 2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * Utility Class for bytes array (binary data).
 *
 * @author Amos Shi
 */
public final class BytesTool {

    private BytesTool() {
    }

    /**
     * Get binary string with leading zero.
     *
     * @param i Integer value to convert
     * @return  Binary string with leading zero
     */
    public static String getBinaryString(int i){
        return String.format("%16s", Integer.toBinaryString(i)).replace(' ', '0');
    }

    /**
     * Get binary string with leading zero.
     *
     * @param l Long value to convert
     * @return  Binary string with leading zero
     */
    public static String getBinaryString(long l){
        return String.format("%32s", Long.toBinaryString(l)).replace(' ', '0');
    }

    /**
     * Get a string for the {@code hex} view of byte array {@code data}.
     *
     * @param data Byte array
     * @return A string representing the {@code hex} version of {@code data}
     */
    public static String getByteDataHexView(final byte[] data) {
        if (data == null) {
            return "";
        }
        if (data.length < 1) {
            return "";
        }

        final StringBuilder sb = new StringBuilder(data.length * 5);
        final int length = data.length;
        int i;
        int lineBreakCounter = 0;
        for (i = 0; i < length; i++) {
            sb.append(String.format(" %02X", data[i]));
            lineBreakCounter++;
            if (lineBreakCounter == 16) {
                sb.append('\n');
                lineBreakCounter = 0;
            }
        }
        sb.append('\n');

        return sb.toString();
    }

    public static boolean isByteArrayEmpty(final byte[] buff, final int startPos, final int length) {
        boolean result = false;

        if (buff[startPos] == 0x00 || buff[startPos] == ((byte) 0xFF)) {
            result = true;
            for (int i = 1; i <= length; i++) {
                if (buff[startPos + i] != buff[startPos]) {
                    result = false;
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Compares if the contents of two byte array are the same.
     * <p>
     * When either <code>bin1</code> or <code>bin2</code> is <code>null</code>,
     * <code>false</code> will be returned. When either <code>bin1</code> or
     * <code>bin2</code> is empty, <code>false</code> will be returned.
     * </p>
     *
     * @param bin1 The first byte array
     * @param bin2 The second byte array
     * @return  <code>true</code> if the content are the same, else false
     */
    public static boolean isByteArraySame(final byte[] bin1, final byte[] bin2) {
        if (bin1 == null || bin2 == null) {
            return false;
        }
        if (bin1.length == 0 || bin2.length == 0) {
            return false;
        }
        if (bin1.length != bin2.length) {
            return false;
        }

        boolean same = true;
        for (int i = 0; i < bin1.length; i++) {
            if (bin1[i] != bin2[i]) {
                same = false;
                break;
            }
        }

        return same;
    }

    /**
     * Checks if the byte array <code>bigBin</code> starts from
     * <code>start</code> is the same as <code>sampleBin</code>.
     *
     * @param bin1 The first byte array
     * @param bin2 The second byte array
     * @param start The start position for compare
     * @return  <code>true</code> if the content are the same, else false
     */
    public static boolean isByteArraySame(final byte[] bin1, final byte[] bin2, final int start) {
        if (bin1 == null || bin2 == null) {
            return false;
        }
        if (bin1.length == 0 || bin2.length == 0) {
            return false;
        }
        if (start < 0) {
            return false;
        }
        if (start + bin1.length > bin2.length) {
            return false;
        }

        boolean same = true;
        for (int i = 0; i < bin1.length; i++) {
            if (bin1[i] != bin2[start + i]) {
                same = false;
                break;
            }
        }

        return same;
    }

    /**
     * Returns byte array from the {@code file}
     *
     * @param file The file
     * @return Byte array of the {@code file}, or {@code null} if error
     * happened.
     */
    public static byte[] readFileAsBytes(final File file) {
        byte[] fileBytes = null;
        try {
            fileBytes = Files.readAllBytes(Paths.get(file.getAbsolutePath()));
        } catch (IOException ex) {
            Logger.getLogger(BytesTool.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }

        return fileBytes;
    }

    /**
     * Read byte array from {@code zipFile} of entry {@code zipEntry}
     *
     * @param zipFile The {@code jar} or {@code zip} file
     * @param zipEntry The entry to be read
     * @return Byte array of the class file, or {@code null} if error happened.
     * @throws IOException Error happened when reading the zip file
     */
    public static byte[] readZipEntryAsBytes(final ZipFile zipFile, final ZipEntry zipEntry) throws IOException {
        if (zipFile == null) {
            throw new IllegalArgumentException("Parameter 'zipFile' is null.");
        }
        if (zipEntry == null) {
            throw new IllegalArgumentException("Parameter 'zipEntry' is null.");
        }

        final long fileSize = zipEntry.getSize();
        final byte[] contents = new byte[(int) fileSize];
        ByteBuffer byteBuf = ByteBuffer.allocate(contents.length);
        InputStream is;
        int bytesRead;
        int bytesAll = 0;

        is = zipFile.getInputStream(zipEntry);
        while (true) {
            bytesRead = is.read(contents);
            if (bytesRead != -1) {
                byteBuf.put(contents, 0, bytesRead);
                bytesAll += bytesRead;
            } else {
                break;
            }
        }

        if (bytesAll == fileSize) {
            return byteBuf.array();
        } else {
            throw new IOException(String.format(
                    "File read error: expected = %d bytes, result = %d bytes. zipFile = %s, zipEntry = %s",
                    fileSize,
                    byteBuf.array().length,
                    zipFile.getName(),
                    zipEntry.getName()));
        }
    }

    public static void skip(final InputStream is, final long skip) throws IOException {
        long skippedBytes = is.skip(skip);
        if (skippedBytes != skip) {
            throw new IOException(String.format("Failed to skip %d bytes, actual bytes skipped %d", skip, skippedBytes));
        }
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/DataInputEx.java`:

```java
/*
 * DataInputEx.java    01:47, Sep 06, 2010
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.io.IOException;
import java.math.BigInteger;

/**
 * The <code>DataInputEx</code> interface provides for reading bytes from a
 * binary stream as <code>little-endian</code> byte order and reconstructing the
 * data into Java primitive types.
 *
 * Example about <code>big-endian</code> and little-<code>endian</code>:
 * <pre>int i = 0x05060708;</pre> In <code>big-endian</code>:
 * <pre>  0  1  2  3</pre>
 * <pre> 05 06 07 08</pre> In <code>little-endian</code>:
 * <pre>  0  1  2  3</pre>
 * <pre> 08 07 06 05</pre>
 *
 * In <code>Java</code>, multi-byte data items are always stored in
 * <code>big-endian</code> order, where the high bytes come first.
 *
 * @author Amos Shi
 * @see <a href="http://en.wikipedia.org/wiki/Endianness"> Wikipedia:
 * Endianness</a>
 */
public interface DataInputEx {

    /**
     * Reads two input bytes and returns an <code>int</code> value in the range
     * <code>-32768</code> through <code>32767</code>, inclusive. Let
     * <code>a</code> be the first byte read and <code>b</code> be the second
     * byte. The value returned is:
     *
     * <pre><code>(((b &amp; 0xff) &lt;&lt; 8) | (a &amp; 0xff))
     * </code></pre>
     *
     * @return the signed 16-bit value read.
     * @throws IOException I/O Error
     */
    short readShortInLittleEndian() throws IOException;

    /**
     * Reads two input bytes and returns an <code>int</code> value in the range
     * <code>0</code> through <code>65535</code>. Let <code>a</code> be the
     * first byte read and <code>b</code> be the second byte. The value returned
     * is:
     * <pre>
     * <code>(((b &amp; 0xff) &lt;&lt; 8) | (a &amp; 0xff))</code>
     * </pre>
     *
     * @return the unsigned 16-bit value read.
     * @throws IOException I/O Error
     */
    int readUnsignedShortInLittleEndian() throws IOException;

    /**
     * Reads four input bytes and returns an <code>int</code> value. Let
     * <code>a-d</code> be the first through fourth bytes read. The value
     * returned is:
     *
     * <pre>
     * <code>
     * (((d &amp; 0xff) &lt;&lt; 24) | ((c &amp; 0xff) &lt;&lt; 16) |
     * &#32;((b &amp; 0xff) &lt;&lt; 8) | (a &amp; 0xff))
     * </code></pre>
     *
     * @return the <code>int</code> value read.
     * @exception IOException if an I/O error occurs.
     */
    int readIntInLittleEndian() throws IOException;

    /**
     * Reads four input bytes as unsigned integer and returns a
     * <code>long</code> value.
     *
     * @return the <code>long</code> value read.
     * @throws IOException I/O Error
     */
    long readUnsignedInt() throws IOException;

    /**
     * Reads four input bytes as unsigned integer and returns a
     * <code>long</code> value.
     *
     * @return the <code>long</code> value read.
     * @throws IOException I/O Error
     */
    long readUnsignedIntInLittleEndian() throws IOException;

    /**
     * Reads eight input bytes and returns a {@code long} value.
     *
     * @return the <code>long</code> value read.
     * @throws IOException I/O Error
     */
    long readLongInLittleEndian() throws IOException;

    /**
     * Reads eight input bytes and returns a {@code unsigned long} value.
     *
     * @return the <code>unsigned long</code> value read
     * @throws IOException I/O Error
     */
    BigInteger readUnsignedLong() throws IOException;

    /**
     * Reads eight input bytes and returns a {@code unsigned long} value.
     *
     * @return the <code>unsigned long</code> value read
     * @throws IOException I/O Error
     */
    BigInteger readUnsignedLongInLittleEndian() throws IOException;

    /**
     * Reads length input bytes as an ASCII string.
     *
     * @param length Then number of bytes to read
     * @return the <code>String</code> value read.
     * @throws IOException I/O Error
     */
    String readASCII(int length) throws IOException;

    /**
     * Reads until a null terminator, or the end of the buffer as an ASCII
     * String.
     *
     * @return the <code>String</code> value read.
     * @throws IOException I/O Error
     */
    String readASCII() throws IOException;

    /**
     * Reads until <code>b</code>, or the end of the buffer as an ASCII String.
     *
     * @param end Ending character
     * @return the <code>String</code> value read.
     * @throws IOException I/O Error
     */
    String readASCIIUntil(byte end) throws IOException;

    /**
     * Read until a null terminator, or the end of the buffer as binary.
     *
     * @return Binary byte array data
     * @throws IOException I/O Error
     */
    byte[] readBinary() throws IOException;

    /**
     * Skip to the end of the buffer.
     *
     * @throws IOException I/O Error
     */
    void skipToEnd() throws IOException;

    /**
     * Go back for <code>i</code> bytes.
     * <p>
     * The position will be back to <code>zero</code> when <code>i</code> is
     * bigger than the current position.
     * </p>
     *
     * @param i the positions backwards, specified in byte
     * @return the new position
     */
    int backward(int i);

    /**
     * Backward from current position until encountering the byte <code>b</code>
     * for the first time.
     *
     * For example:
     * <pre>
     *   byte array index:  0   1   2   3   4   5   6   7   8   9  10  11  12
     *   byte array data : 50  47  34  6A  1B  0A  0D  20  98  7D  54  20  0D
     *   current position: *
     * </pre> When passing into <code>0D</code>, the return value is
     * <code>6</code>.
     *
     * @param b target byte
     * @return the position, or <code>-1</code> if not found until the first
     * byte
     */
    int backwardTo(byte b);

    /**
     * Backward from current position until encountering the byte array
     * <code>b</code> for the first time.
     *
     * For example:
     * <pre>
     *   byte array index:  0   1   2   3   4   5   6   7   8   9  10  11  12
     *   byte array data : 50  47  34  6A  1B  20  0D  0A  98  7D  54  20  0D
     *   current position: *
     * </pre> When passing into <code>0D 0A</code>, the return value is
     * <code>6</code>.
     *
     * @param b target bytes
     * @return the position, or <code>-1</code> if not found until the beginning
     */
    int backwardTo(byte[] b);

    /**
     * Fly to the specified <code>position</code>.
     *
     * @param position target position
     */
    void flyTo(int position);
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/DefaultFileComponent.java`:

```java
package org.binaryinternals.commonlib.core;

import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * Default implementation for {@link FileComponent}.
 *
 * @author Amos Shi
 */
public class DefaultFileComponent extends FileComponent implements GenerateTreeNode {

    private String treeNodeText = "Default File Component";

    /**
     * Generates the {@link DefaultFileComponent}.
     *
     * @param start Start Position of the File component
     * @param len Length of the File component
     */
    public DefaultFileComponent(final int start, final int len) {
        super.startPos = start;
        super.length = len;
    }

    /**
     * Generates the {@link DefaultFileComponent}.
     *
     * @param start Start Position of the File component
     * @param len Length of the File component
     * @param text Text of the Tree Node
     */
    public DefaultFileComponent(final int start, final int len, final String text) {
        this(start, len);
        this.treeNodeText = text;
    }

    @Override
    public void generateTreeNode(final DefaultMutableTreeNode parentNode) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                this.treeNodeText)));
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/FileComponenPlaceHolder.java`:

```java
/*
 * FileComponenPlaceHolder.java    10:32 PM, August 9, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.io.IOException;

/**
 * Super class for all simple components which have only one 16-bit (@link FileComponentU2) field in a {@code class} file.
 *
 * @author Amos Shi
 */
public class FileComponenPlaceHolder extends FileComponent {

    FileComponenPlaceHolder() {
        super();
    }

    public FileComponenPlaceHolder(final PosDataInputStream posDataInputStream, int length) throws IOException {
        this();
        super.startPos = posDataInputStream.getPos();

        if (length > 0) {
            this.length = length;
            BytesTool.skip(posDataInputStream, length);
        } else {
            this.length = 0;
        }
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/FileComponent.java`:

```java
/*
 * ClassComponent.java    8:51 PM, August 7, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

/**
 * Super class for all components in a class file. This class has two fields:
 * {@code startPos} indicates the start index in the class file byte array
 * of current component; {@code length} is
 *
 *
 * @author Amos Shi
 */
public class FileComponent {

    /**
     * Start position in the class file byte array of current component.
     */
    @SuppressWarnings("ProtectedField")
    protected int startPos;
    /**
     * Length of current component.
     */
    @SuppressWarnings("ProtectedField")
    protected int length;

    public FileComponent() {
        this.startPos = 0;
        this.length = 0;
    }

    /**
     * Get the start position of current component.
     *
     * @return The start position
     */
    public int getStartPos() {
        return this.startPos;
    }

    /**
     * Get the length of current component.
     *
     * @return The length
     */
    public int getLength() {
        return this.length;
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/FileFormat.java`:

```java
/*
 * FileFormat.java    Apr 12, 2011, 13:02
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.awt.Component;
import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.SortedMap;
import java.util.TreeMap;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextPane;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public abstract class FileFormat {

    /**
     * The file name.
     */
    public final String fileName;
    /**
     * The file name.
     */
    public final String filePath;
    /**
     * Raw byte array of the file.
     */
    public final byte[] fileByteArray;

    /**
     * The parsed file components.
     */
    protected final SortedMap<Long, FileComponent> components = new TreeMap<>();

    /**
     * Parse the content from a {@link File} object.
     *
     * @param file {@link File} object
     * @throws IOException Failed to Read file
     * @throws FileFormatException The file is empty
     */
    protected FileFormat(final File file) throws IOException, FileFormatException {
        this.fileName = file.getName();
        this.filePath = file.getCanonicalPath();

        if (file.length() == 0) {
            throw new FileFormatException(
                    String.format("The file content is empty. name = %s", file.getPath()));
        }
        this.fileByteArray = BytesTool.readFileAsBytes(file);
    }

    /**
     * Parse a byte array (in memory) as a file.
     *
     * @param bytes Contents in bytes
     * @param fileName File name
     * @param filePath File path
     */
    protected FileFormat(final byte[] bytes, final String fileName, final String filePath) {
        final String inMemory = "In Memory Bytes data";
        this.fileName = (fileName == null) ? inMemory : fileName;
        this.filePath = (filePath == null) ? inMemory : filePath;
        this.fileByteArray = bytes;
    }

    /**
     * Add the <code>comp</code> to the {@link #components}.
     *
     * @param comp The {@link FileComponent} to be added
     */
    protected void addFileComponent(FileComponent comp) {
        this.components.put(Long.valueOf(comp.getStartPos()), comp);
    }

    /**
     * Get the content tab name for UI.
     *
     * @return A string for the tab name
     */
    public abstract String getContentTabName();

    /**
     * Generate the Tree node for the file.
     *
     * @param parentNode The root tree node
     */
    public abstract void generateTreeNode(final DefaultMutableTreeNode parentNode);

    /**
     * Get part of the file byte array. The array begins at the specified
     * {@code startIndex} and extends to the byte at
     * {@code startIndex}+{@code length}.
     *
     * @param startIndex The start index
     * @param length The length of the array
     * @return Part of the class byte array
     */
    public byte[] getFileByteArray(final int startIndex, final int length) {
        if ((startIndex < 0) || (length < 1)) {
            throw new IllegalArgumentException("startIndex or length is not valid. startIndex = " + startIndex + ", length = " + length);
        }
        if (startIndex + length - 1 > this.fileByteArray.length) {
            throw new ArrayIndexOutOfBoundsException("The last item index is bigger than class byte array size.");
        }

        byte[] data = new byte[length];
        System.arraycopy(this.fileByteArray, startIndex, data, 0, length);
        return data;
    }

    /**
     * Return the file components list.
     *
     * @return file component list
     */
    public Collection<FileComponent> getFileComponents() {
        return Collections.unmodifiableCollection(this.components.values());
    }

    /**
     * The child class may choose to provide an icon for the file format. This
     * method should be change to abstract if all children has provided an icon.
     *
     * @return <code>null</code> to use default icon, else use supplied icon
     */
    public Icons getIcon() {
        return null;
    }

    /**
     * Response to the tree node selection change event. Example: when choosing
     * method code node, the JVM Class file want to add a tab to display decoded
     * byte codes.
     *
     * @param userObj User Object on the Tree node
     * @param tabs Content tabs
     */
    public void treeSelectionChanged(final JTreeNodeFileComponent userObj, final JTabbedPane tabs) {
        // Remove the additional tab(s) first
        while (tabs.getTabCount() > 1) {
            tabs.remove(1);
        }
    }

    /**
     * Add a JTextPane to the tabs.
     *
     * @param tabs JTabbedPane control
     * @param title Title of the new tab
     * @return The new created JTextPane
     */
    protected JTextPane tabAddTextPane(final JTabbedPane tabs, final String title) {
        // Add detailed info pane for additional info
        JTextPane pane = new JTextPane();
        pane.setAlignmentX(Component.LEFT_ALIGNMENT);
        pane.setEditable(false);
        pane.setBorder(null);
        pane.setContentType("text/html");
        tabs.add(title, new JScrollPane(pane));
        return pane;
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/FileFormatException.java`:

```java
/**
 * FileFormatException.java    Apr 12, 2011, 10:59
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

/**
 *
 * @author Amos Shi
 */
public class FileFormatException extends Exception {

    private static final long serialVersionUID = 4876543219876500000L;

    /**
     * Constructs an instance of <code>FileFormatException</code> with the
     * specified detail message.
     * @param msg the detail message.
     */
    public FileFormatException(final String msg) {
        super(msg);
    }

    public FileFormatException(final String msg, final Throwable cause) {
        super(msg, cause);
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/PluginDescriptor.java`:

```java
/*
 * PluginDescriptor.java    Apr 16, 2011, 15:34
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import org.binaryinternals.commonlib.core.FileFormat;

/**
 *
 * @author Amos Shi
 */
public interface PluginDescriptor {

    String getExtensionDescription();

    String[] getExtensions();

    Class<? extends FileFormat> getFileFormatClass();
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/PosByteArrayInputStream.java`:

```java
/*
 * PosByteArrayInputStream.java    August 8, 2007, 12:44 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.io.ByteArrayInputStream;

/**
 *
 * @author Amos Shi
 */
public final class PosByteArrayInputStream extends ByteArrayInputStream {

    /**
     * Creates a new instance of PosByteArrayInputStream
     * @param buf Buffer pool
     */
    public PosByteArrayInputStream(final byte[] buf) {
        super(buf);
    }

    void setPos(int i) {
        this.pos = i;
    }

    public int getPos() {
        return this.pos;
    }

    byte[] getBuf() {
        return this.buf;
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/core/PosDataInputStream.java`:

```java
/*
 * PosDataInputStream.java    August 8, 2007, 12:48 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.core;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.math.BigInteger;

/**
 *
 * @author Amos Shi
 */
public class PosDataInputStream extends DataInputStream implements DataInputEx {

    public static final int USHORT_LENGTH = 2;
    public static final byte[] EMPTY_BYTE_ARRAY = {};

    /**
     * Number in bytes for Java <code>byte</code> type.
     */
    public static final int LENGTH_BYTE = 1;
    /**
     * Number in bytes for Java <code>short</code> type.
     */
    public static final int LENGTH_SHORT = 2;
    /**
     * Number in bytes for Java <code>int</code> type.
     */
    public static final int LENGTH_INT = 4;
    /**
     * Number in bytes for Java <code>long</code> type.
     */
    public static final int LENGTH_LONG = 8;

    /**
     * Shift Operators, offset with 8.
     */
    protected static final int SHIFT_8 = 8;
    /**
     * Shift Operators, offset with 16.
     */
    protected static final int SHIFT_16 = 16;
    /**
     * Shift Operators, offset with 24.
     */
    protected static final int SHIFT_24 = 24;
    /**
     * Shift Operators, offset with 32.
     */
    protected static final int SHIFT_32 = 32;
    /**
     * Shift Operators, offset with 40.
     */
    protected static final int SHIFT_40 = 40;
    /**
     * Shift Operators, offset with 48.
     */
    protected static final int SHIFT_48 = 48;
    /**
     * Shift Operators, offset with 56.
     */
    protected static final int SHIFT_56 = 56;
    /**
     * Half Byte length: 4.
     */
    protected static final int BYTE_LENGTH_4 = 4;
    /**
     * Full Byte length: 8.
     */
    protected static final int BYTE_LENGTH_8 = 8;

    /** Byte offset 0. */
    protected static final int BYTE_OFFSET_0 = 0;
    /** Byte offset 1. */
    protected static final int BYTE_OFFSET_1 = 1;
    /** Byte offset 2. */
    protected static final int BYTE_OFFSET_2 = 2;
    /** Byte offset 3. */
    protected static final int BYTE_OFFSET_3 = 3;
    /** Byte offset 4. */
    protected static final int BYTE_OFFSET_4 = 4;
    /** Byte offset 5. */
    protected static final int BYTE_OFFSET_5 = 5;
    /** Byte offset 6. */
    protected static final int BYTE_OFFSET_6 = 6;
    /** Byte offset 7. */
    protected static final int BYTE_OFFSET_7 = 7;
    /**
     * Byte max value: 255.
     */
    protected static final int BYTE_MAX_255 = 255;

    /**
     * New line character: LINE FEED (LF).
     */
    public static final byte NEWLINE_LF = 0x0A;
    /**
     * New line character: CARRIAGE RETURN (CR).
     */
    public static final byte NEWLINE_CR = 0x0D;

    /**
     * Offset of the 1st byte.
     */
    protected int offset = 0;

    /**
     * Creates a new instance of PosDataInputStream.
     *
     * @param in Binary data input stream
     */
    public PosDataInputStream(final PosByteArrayInputStream in) {
        super(in);
    }

    /**
     * Create a sub {@link PosDataInputStream}, which starts from
     * <code>offset</code>.
     *
     * @param in Binary data input stream
     * @param offset Offset of the stream
     */
    public PosDataInputStream(final PosByteArrayInputStream in, int offset) {
        super(in);
        this.offset = offset;
    }

    /**
     * Get a partial {@link PosDataInputStream}, which starts from
     * <code>startPos</code> of original stream, with length
     * <code>length</code>.
     *
     * @param startPos Start position
     * @param length Length
     * @return A partial {@link PosDataInputStream} object
     */
    public PosDataInputStream getPartialStream(final int startPos, final int length) {
        return new PosDataInputStream(
                new PosByteArrayInputStream(this.getBuf(startPos, length)),
                startPos);
    }

    /**
     * Get the absolute position of the starting point of the buffer.
     *
     * @return buffer absolute position
     */
    public int getOffset() {
        return this.offset;
    }

    /**
     * Get current absolute position of the file.
     *
     * @return The index of the next character to read from the input stream
     * buffer, or <code>-1</code> if there is internal error, the input stream
     * is not <code>PosByteArrayInputStream</code>.
     */
    public int getPos() {
        int pos = -1;
        if (this.in instanceof PosByteArrayInputStream) {
            pos = ((PosByteArrayInputStream) this.in).getPos() + this.offset;
        }

        return pos;
    }

    /**
     * Get the byte array buffer of the input stream.
     *
     * @return the byte array
     */
    public byte[] getBuf() {
        if (this.in instanceof PosByteArrayInputStream) {
            return ((PosByteArrayInputStream) this.in).getBuf();
        } else {
            throw new UnsupportedOperationException("This method is called in incorrect context");
        }
    }

    /**
     * Return a part of the byte array.
     *
     * @param startPos Start Position of the original byte array
     * @param length Length of data to be read
     * @return the partial byte array
     */
    public byte[] getBuf(final int startPos, final int length) {
        if ((startPos < 0) || (length < 1)) {
            throw new IllegalArgumentException("startIndex or length is not valid. startIndex = " + startPos + ", length = " + length);
        }

        byte[] bufFull = this.getBuf();
        if (startPos + length - 1 > bufFull.length) {
            throw new ArrayIndexOutOfBoundsException("The last item index is bigger than class byte array size.");
        }

        final byte[] bufPart = new byte[length];
        System.arraycopy(bufFull, startPos, bufPart, 0, length);
        return bufPart;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods
    @Override
    public short readShortInLittleEndian() throws IOException {
        int ch1 = this.in.read();
        int ch2 = this.in.read();
        if ((ch1 | ch2) < 0) {
            throw new EOFException();
        }
        return (short) ((ch2 << SHIFT_8) + (ch1));
    }

    @Override
    public int readUnsignedShortInLittleEndian() throws IOException {
        int ch1 = this.in.read();
        int ch2 = this.in.read();
        if ((ch1 | ch2) < 0) {
            throw new EOFException();
        }
        return (ch2 << SHIFT_8) + (ch1);
    }

    /**
     * @throws IOException
     *
     * <pre>
     * java:S1110 - Redundant parenthesis --- Redundant parenthesis is needed for readability
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S1110")
    public int readIntInLittleEndian() throws IOException {
        int ch1 = this.in.read();
        int ch2 = this.in.read();
        int ch3 = this.in.read();
        int ch4 = this.in.read();
        if ((ch1 | ch2 | ch3 | ch4) < 0) {
            throw new EOFException();
        }
        return (((ch4 << SHIFT_24) + (ch3 << SHIFT_16) + (ch2 << SHIFT_8) + (ch1)));
    }

    /**
     * @throws IOException
     *
     * <pre>
     * java:S1110 - Redundant parenthesis --- Redundant parenthesis is needed for readability
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S1110")
    public long readUnsignedInt() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];

        super.readFully(readBuffer, BYTE_LENGTH_4, BYTE_LENGTH_4);
        readBuffer[BYTE_OFFSET_0] = 0;
        readBuffer[BYTE_OFFSET_1] = 0;
        readBuffer[BYTE_OFFSET_2] = 0;
        readBuffer[BYTE_OFFSET_3] = 0;

        return (((long) readBuffer[BYTE_OFFSET_0] << SHIFT_56)
                + ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_48)
                + ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_40)
                + ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_32)
                + ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_24)
                + ((readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_16)
                + ((readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_8)
                + ((readBuffer[BYTE_OFFSET_7] & BYTE_MAX_255)));
    }

    /**
     * @throws IOException
     *
     * <pre>
     * java:S1110 - Redundant parenthesis --- Redundant parenthesis is needed for readability
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S1110")
    public long readUnsignedIntInLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];

        super.readFully(readBuffer, 0, BYTE_LENGTH_4);
        readBuffer[BYTE_OFFSET_7] = readBuffer[BYTE_OFFSET_0];
        readBuffer[BYTE_OFFSET_6] = readBuffer[BYTE_OFFSET_1];
        readBuffer[BYTE_OFFSET_5] = readBuffer[BYTE_OFFSET_2];
        readBuffer[BYTE_OFFSET_4] = readBuffer[BYTE_OFFSET_3];
        readBuffer[BYTE_OFFSET_0] = 0;
        readBuffer[BYTE_OFFSET_1] = 0;
        readBuffer[BYTE_OFFSET_2] = 0;
        readBuffer[BYTE_OFFSET_3] = 0;

        return (((long) readBuffer[BYTE_OFFSET_0] << SHIFT_56)
                + ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_48)
                + ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_40)
                + ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_32)
                + ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_24)
                + ((readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_16)
                + ((readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_8)
                + ((readBuffer[BYTE_OFFSET_7] & BYTE_MAX_255)));
    }

    /**
     * @throws IOException
     *
     * <pre>
     * java:S1110 - Redundant parenthesis --- Redundant parenthesis is needed for readability
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S1110")
    public long readLongInLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];
        super.readFully(readBuffer, 0, 8);
        return (((long) readBuffer[BYTE_OFFSET_7] << SHIFT_56)
                + ((long) (readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_48)
                + ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_40)
                + ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                + ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                + ((readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                + ((readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                + ((readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
    }

    /**
     * @see
     * <a href="http://technologicaloddity.com/2010/09/22/biginteger-as-unsigned-long-in-java/">
     * BigInteger as unsigned long in Java</a>
     */
    @Override
    public BigInteger readUnsignedLong() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];
        super.readFully(readBuffer, 0, BYTE_LENGTH_8);
        return new BigInteger(1, readBuffer);
    }

    @Override
    public BigInteger readUnsignedLongInLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];
        final byte[] readBufferLE = new byte[BYTE_LENGTH_8];
        super.readFully(readBuffer, 0, BYTE_LENGTH_8);
        for (int i = 0; i < BYTE_LENGTH_8; i++) {
            readBufferLE[i] = readBuffer[BYTE_LENGTH_8 - 1 - i];
        }

        return new BigInteger(1, readBufferLE);
    }

    @Override
    public String readASCII(final int length) throws IOException {
        if (length <= 0) {
            throw new IllegalArgumentException(
                    String.format("Parameter length should be greater than 0. (length = %d)", length));
        }

        StringBuilder sb = new StringBuilder(length + 1);
        for (int i = 0; i < length; i++) {
            sb.append((char) this.readByte());
        }
        return sb.toString();
    }

    @Override
    public String readASCII() throws IOException {
        return this.readASCIIUntil((byte) 0);
    }

    /**
     * Read current byte array as ASCII string until <code>byte</code>
     * <code>end</code>.
     *
     * <pre>
     * java:S135 - Loops should not contain more than a single "break" or "continue" statement --- We need it in this method
     * </pre>
     *
     * @param end End character
     * @throws IOException Read failed
     */
    @Override
    @SuppressWarnings("java:S135")
    public String readASCIIUntil(final byte end) throws IOException {
        byte b;
        StringBuilder sb = new StringBuilder();

        do {
            try {
                b = this.readByte();
                if (b == end) {
                    break;
                }
                sb.append((char) b);
            } catch (EOFException eof) {
                break;
            }
        } while (true);

        return sb.toString();
    }

    /**
     * Read current byte array as ASCII string until any <code>byte</code> in
     * array <code>end</code>.
     *
     * @param end End value for the ASCII string
     * @return ASCII as string
     * @throws IOException Read failed
     *
     * <pre>
     * java:S135 - Loops should not contain more than a single "break" or "continue" statement --- We need it in this method
     * </pre>
     */
    @SuppressWarnings("java:S135")
    public String readASCIIUntil(byte... end) throws IOException {
        if (end == null || end.length < 1) {
            throw new IllegalArgumentException("Inalid parameter 'end'.");
        }

        byte b;
        StringBuilder sb = new StringBuilder(100);

        do {
            try {
                b = this.readByte();
                if (this.contains(b, end)) {
                    break;
                }
                sb.append((char) b);
            } catch (EOFException eof) {
                break;
            }
        } while (true);

        return sb.toString();
    }

    /**
     * Read current byte array as ASCII string until a {@link #NEWLINE_CR} /
     * {@link #NEWLINE_LF} flag found.
     *
     * @return ASCII Line
     * @throws IOException Read failed
     */
    public ASCIILine readASCIILine() throws IOException {
        int nlLen = 1;
        String line = this.readASCIIUntil(NEWLINE_CR, NEWLINE_LF);
        if (this.hasNext()) {
            byte next = this.readByte();
            if (next != NEWLINE_LF && next != NEWLINE_CR) {
                this.backward(1);
            } else {
                nlLen += 1;
            }
        }

        return new ASCIILine(line, nlLen);
    }

    private boolean contains(final byte v, final byte[] list) {
        boolean result = false;
        for (int i = 0; i < list.length; i++) {
            if (list[i] == v) {
                result = true;
                break;
            }
        }
        return result;
    }

    /**
     * <pre>
     * java:S135 - Loops should not contain more than a single "break" or "continue" statement --- We need it in this method
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S135")
    public byte[] readBinary() throws IOException {
        int size = this.getBuf().length - this.getPos() + this.offset + 1;
        byte[] big = new byte[size];
        int bigCounter = 0;
        byte b;

        do {
            try {
                b = this.readByte();
                if (b == 0) {
                    break;
                }
                big[bigCounter] = b;
                bigCounter++;
            } catch (EOFException eof) {
                break;
            }
        } while (true);

        if (bigCounter > 0) {
            byte[] result = new byte[bigCounter];
            System.arraycopy(big, 0, result, 0, bigCounter);
            return result;
        } else {
            return EMPTY_BYTE_ARRAY;
        }
    }

    /**
     * Set the current position back for <code>i</code> positions.
     *
     * This method supports {@link PosByteArrayInputStream} only, nothing will
     * do for other input stream types.
     *
     * @see PosByteArrayInputStream
     */
    @Override
    public int backward(final int i) {
        int result = -1;

        if (this.in instanceof PosByteArrayInputStream) {
            PosByteArrayInputStream posIn = ((PosByteArrayInputStream) this.in);
            int currentPos = posIn.getPos();
            result = ((currentPos - i) > 0) ? (currentPos - i) : 0;
            ((PosByteArrayInputStream) this.in).setPos(result);
        }

        return result;
    }

    /**
     * Backward current position until the byte value <code>b</code>.
     *
     * This method supports {@link PosByteArrayInputStream} only as input stream
     * only, otherwise <code>-1</code> is returned.
     *
     * @see PosByteArrayInputStream
     * @return the new position, or -1 if <code>b</code> not found
     */
    @Override
    public int backwardTo(final byte b) {
        int result = -1;

        if (this.in instanceof PosByteArrayInputStream) {
            PosByteArrayInputStream posIn = ((PosByteArrayInputStream) this.in);
            byte[] buf = posIn.getBuf();
            for (int i = posIn.getPos(); i > -1; i--) {
                if (buf[i] == b) {
                    result = i;
                    break;
                }
            }

            if (result != -1) {
                posIn.setPos(result);
            }
        }

        return result;
    }

    /**
     * Forward current position until the byte value <code>b</code>.
     *
     * This method supports {@link PosByteArrayInputStream} only as input stream
     * only, otherwise <code>-1</code> is returned.
     *
     * @param b Target byte
     * @see PosByteArrayInputStream
     * @return the new position, or -1 if <code>b</code> not found
     */
    public int forwardTo(final byte b) {
        int result = -1;

        if (this.in instanceof PosByteArrayInputStream) {
            PosByteArrayInputStream posIn = ((PosByteArrayInputStream) this.in);
            byte[] buf = posIn.getBuf();
            for (int i = posIn.getPos(); i < buf.length; i++) {
                if (buf[i] == b) {
                    result = i;
                    break;
                }
            }

            if (result != -1) {
                posIn.setPos(result);
            }
        }

        return result;
    }

    /**
     * Backward current position until the byte array value <code>b</code>.
     *
     * This method supports {@link PosByteArrayInputStream} only as input stream
     * only, otherwise <code>-1</code> is returned.
     *
     * @see PosByteArrayInputStream
     */
    @Override
    public int backwardTo(final byte[] b) {
        int result = -1;

        if ((b == null) || (b.length == 0)) {
            throw new IllegalArgumentException("Parameter b is null or empty.");
        }

        if (this.in instanceof PosByteArrayInputStream) {
            PosByteArrayInputStream posIn = ((PosByteArrayInputStream) this.in);
            byte[] buf = posIn.getBuf();
            for (int i = posIn.getPos() - b.length; i > -1; i--) {
                if (BytesTool.isByteArraySame(b, buf, i)) {
                    result = i;
                    break;
                }
            }

            if (result != -1) {
                posIn.setPos(result);
            }
        }

        return result;
    }

    /**
     * Go to the end of the stream.
     *
     * This method supports {@link PosByteArrayInputStream} only, nothing will
     * do for other input stream types.
     *
     * @see PosByteArrayInputStream
     */
    @Override
    public void skipToEnd() throws IOException {
        if (this.in instanceof PosByteArrayInputStream) {
            PosByteArrayInputStream posIn = ((PosByteArrayInputStream) this.in);
            posIn.setPos(0);
            posIn.skip(posIn.getBuf().length);
        }
    }

    /**
     * Fly to the specific <code>position</code>.
     *
     * This method supports {@link PosByteArrayInputStream} only, nothing will
     * do for other input stream types.
     *
     * @see PosByteArrayInputStream
     */
    @Override
    public void flyTo(final int position) {
        if (this.in instanceof PosByteArrayInputStream) {
            ((PosByteArrayInputStream) this.in).setPos(position);
        }
    }

    /**
     * Whether current location is the end or not.
     *
     * @return true Still has next byte to be read; false Current location is
     * the end
     */
    public boolean hasNext() {
        return this.getPos() - this.offset <= (this.getBuf().length - 1);
    }

    public static class ASCIILine {

        /**
         * New Line length, could be 1 (0x0D) or 2 (0x0D0A), or 0.
         */
        public final int newLineLength;
        public final String line;

        public ASCIILine(String line, int nlLen) {
            this.line = line;
            this.newLineLength = nlLen;
        }

        /**
         * Length of the line, including the {@link #NEWLINE_CR} /
         * {@link #NEWLINE_LF}.
         *
         * @return {@link ASCIILine} length
         */
        public int length() {
            return this.line.length() + newLineLength;
        }

        @Override
        public String toString() {
            return this.line;
        }
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/GenerateTreeNode.java`:

```java
/*
 * GenerateTreeNode.java    September 01, 2010, 23:57
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.ui;

import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;

/**
 * Interface for generating children tree nodes.
 *
 * @author Amos Shi
 */
public interface GenerateTreeNode {

    /**
     * Generate children nodes for current file component.
     *
     * @param parentNode Parent tree node
     */
    void generateTreeNode(final DefaultMutableTreeNode parentNode);

    /**
     * Generate tree node for difference with Raw Data.
     *
     * @param parentNode Parent tree node
     * @param lastEnd Last end
     * @param diff Difference
     * @param buff Byte array data
     * @param buffStartPos Buffer start position
     */
    default void generateTreeNodeDiff(
            final DefaultMutableTreeNode parentNode,
            final int lastEnd,
            final int diff,
            final byte[] buff, final int buffStartPos) {
        String diffStr;

        if (BytesTool.isByteArrayEmpty(buff, lastEnd - buffStartPos, diff - 1)) {
            diffStr = String.format("Empty [0x%04X, 0x%04X] length = %d", lastEnd, lastEnd + diff - 1, diff);
        } else {
            diffStr = String.format("Unknown [0x%04X, 0x%04X] length = %d", lastEnd, lastEnd + diff - 1, diff);
        }
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastEnd,
                diff,
                diffStr)));
    }

    /**
     * Generate tree node for Gap.
     *
     * @param parentNode Parent tree node
     * @param startPos Start position of the gap
     * @param legnth Length of the gap
     */
    default void generateTreeNodeGap(final DefaultMutableTreeNode parentNode, final int startPos, final int legnth) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                legnth,
                String.format("Gap [%08X, %08X] length = %d", startPos, startPos + legnth, legnth))));
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/GenerateTreeNodeFileFormat.java`:

```java
/*
 * GenerateTreeNodeFileFormat.java    August 29, 2021, 23:44
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.ui;

import java.util.ResourceBundle;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;

/**
 * Interface for generating children tree nodes.
 *
 * @author Amos Shi
 */
public interface GenerateTreeNodeFileFormat {

    static final String FORMAT_STRING_STRING = "%s - %s";

    /**
     * Max length for tree node string.
     *
     * @see #left(String)
     */
    static final int TREENODE_STRING_MAXLEN = 64;

    /**
     * Generate JTree nodes for the current file component.
     *
     * @param parentNode The parent JTree node
     * @param fileFormat The current {@link FileFormat} object
     */
    void generateTreeNode(final DefaultMutableTreeNode parentNode, FileFormat fileFormat);

    /**
     * Get the messages resource of current file format.
     *
     * @return {@link ResourceBundle} for messages, or <code>null</code> if not
     * exist
     */
    ResourceBundle getMessages();

    /**
     * Add a child node.
     *
     * @param parentNode Parent tree node
     * @param startPos Start position
     * @param len Length
     * @param fieldName Field name
     * @param value Node value
     * @param msgkey Display message key
     * @param icon Node icon
     * @return The new added tree node
     */
    default DefaultMutableTreeNode addNode(DefaultMutableTreeNode parentNode, int startPos, int len, String fieldName, Object value, String msgkey, Icons icon) {
        JTreeNodeFileComponent fileComp = new JTreeNodeFileComponent(
                startPos,
                len,
                fieldName + ": " + value.toString()
        );
        if (msgkey != null) {
            fileComp.setDescription(getMessages().getString(msgkey));
        }
        if (icon != null) {
            fileComp.setIcon(icon.getIcon());
        }

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(fileComp);
        parentNode.add(node);
        return node;
    }

    /**
     * Get left part of string for tree node.
     *
     * @param s The String to get left part
     * @return Left part of string
     */
    default String left(String s) {
        return left(s, TREENODE_STRING_MAXLEN);
    }

    /**
     * Get left part of string.
     *
     * @param s The String to get left part
     * @param length Length to get
     * @return Left part of string
     */
    default String left(String s, int length) {
        if (s == null) {
            return s;
        } else if (s.length() < length) {
            return s;
        } else {
            return s.substring(0, length - 1) + " ...";
        }
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/HTMLKit.java`:

```java
package org.binaryinternals.commonlib.ui;

import java.awt.Font;

/**
 * HTML Kit for the <code>JTextPane</code> control.
 *
 * @author Amos
 */
public final class HTMLKit {

    /**
     * Default font.
     */
    public static final Font FONT = new Font(Font.DIALOG_INPUT, Font.PLAIN, 14);

    /**
     * Font color yellow.
     */
    public static final String FONT_COLOR_YELLOW = "yellow";

    /**
     * Font color orange.
     */
    public static final String FONT_COLOR_ORANGE = "#FFA500";

    /**
     * ASCII code 32.
     */
    private static final int ASCII_32 = 32;
    /**
     * ASCII code 127.
     */
    private static final int ASCII_127 = 127;
    /**
     * ASCII code 160.
     */
    private static final int ASCII_160 = 160;
    /**
     * ASCII code 255.
     */
    private static final int ASCII_255 = 255;

    private HTMLKit() {
    }

    /**
     * HTML start tags.
     */
    public static final String START = "<!DOCTYPE html><html><head></head><body>";

    /**
     * HTML end tags.
     */
    public static final String END = "\n</body>\n</html>";

    /**
     * HTML new line.
     */
    public static final String NEW_LINE = "<br />";

    /**
     * HTML space.
     */
    public static final String SPACE = "&nbsp;";

    /**
     * Get HTML format for text with new line.
     *
     * @param text Text inside the span
     * @return HTML code of span
     */
    public static String span(final String text) {
        return String.format("<span style=\"font-size:%dpx; font-family:%s;\">%s</span>",
                FONT.getSize() - 2,
                FONT.getFamily(),
                text);
    }

    /**
     * Get HTML format for text with new line and specified color.
     *
     * @param text Text inside the span
     * @param color Color of the text
     * @return HTML code of span
     */
    public static String span(final String text, final String color) {
        return String.format("<span style=\"background-color:%s; font-size:%dpx; font-family:%s;\">%s</span>",
                color,
                FONT.getSize() - 2,
                FONT.getFamily(),
                text);
    }

    /**
     * Get HTML marks for the byte.
     *
     * @param b Byte value
     * @return HTML mark for the byte value
     * @see <a href="http://ascii.cl/htmlcodes.htm">HTML Codes - Characters and
     * symbols</a>
     */
    public static String getByteText(final byte b) {
        String s = ".";

        int i = (b & 0xFF);
        if (((i > ASCII_32) && (i < ASCII_127))
                || ((i > ASCII_160) && (i <= ASCII_255))) {
            s = String.format("&#%d;", i);
        }

        return s;
    }

    /**
     * Escape HTML special character &lt; and &gt;.
     *
     * @param text Input text to process
     * @return Escaped result
     */
    public static String escapeFilter(final String text) {
        String result = null;
        if (text != null) {
            result = text.replace("<", "&lt;");
            result = result.replace(">", "&gt;");
        }

        return result;
    }
}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/Icons.java`:

```java
/*
 * Icons.java    Sep 21, 2021
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.ui;

import java.util.HashMap;
import java.util.Map;
import javax.swing.Icon;
import javax.swing.ImageIcon;

/**
 * Icons.
 *
 * @author amosshi
 */
@SuppressWarnings({"java:S115"})
public enum Icons {

    /**
     * Icon for access flags.
     *
     * @see <a href="https://icons8.com/icon/En14xvMmiGjB/approval">Approval</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    AccessFlag("icons8-approval-16.png"),
    /**
     * Icon for annotations.
     */
    Annotations("icons8-bookmark-16.png"),
    /**
     * Icon for array.
     *
     * @see <a href="https://icons8.com/icon/78816/view-array">View Array</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Array("icons8-view-array-16.png"),
    /**
     * Icon for binary file.
     *
     * @see <a href="https://icons8.com/icon/38992/binary-file">Binary File</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    BinaryFile("icons8-binary-file-20.png"),
    /**
     * Icon for Calendar / Date.
     *
     * @see <a href="https://icons8.com/icon/84997/calendar">Calendar</a> icon
     * by <a href="https://icons8.com">Icons8</a>
     */
    Calendar("icons8-calendar-16.png"),
    /**
     * Icon for checksum.
     *
     * @see <a href="https://icons8.com/icon/sz8cPVwzLrMP/check-mark">Check
     * Mark</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Checksum("icons8-check-mark-16.png"),

    /**
     * Icon for Java Class.
     */
    Class("icons8-java-16.png"),
    /**
     * Icon for Constant value.
     *
     * @see <a href="https://icons8.com/icon/22285/no-edit">No Edit</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Constant("icons8-no-edit-16.png"),
    /**
     * Icon for counter.
     *
     * @see <a href="https://icons8.com/icon/2U6ROkjIrXIA/abacus">Abacus</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Counter("icons8-abacus-16.png"),
    /**
     * Icon for raw Data.
     *
     * @see
     * <a href="https://icons8.com/icon/84736/blockchain-technology">Blockchain
     * Technology</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Data("icons8-blockchain-technology-16.png"),
    /**
     * Icon for Descriptor.
     *
     * @see <a href="https://icons8.com/icon/20843/information">Information</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Descriptor("icons8-information-16.png"),
    /**
     * Icon for DEX file.
     *
     * @see <a href="https://icons8.com/icon/38933/apk">APK</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Dex("icons8-apk-20.png"),
    /**
     * Icon for Empty.
     *
     * @see <a href="https://icons8.com/icon/96204/empty-battery">Empty Battery</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Empty("icons8-empty-battery-16.png"),
    /**
     * Icon for Exception.
     *
     * @see <a href="https://icons8.com/icon/110759/flash-on">Flash On</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Exception("icons8-flash-on-16.png"),
    /**
     * Icon for endian.
     *
     * @see <a href="https://icons8.com/icon/Xf1Gx1HbxVsm/up-down-arrow">Up Down
     * Arrow</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Endian("icons8-up-down-arrow-16.png"),
    /**
     * Icon for field.
     *
     * @see <a href="https://icons8.com/icon/45099/play-property">Play
     * Property</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Field("icons8-play-property-16.png"),
    /**
     * Icon for length.
     *
     * @see <a href="https://icons8.com/icon/44699/length">Length</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Length("icons8-length-16.png"),
    /**
     * Icon for Index.
     *
     * @see <a href="https://icons8.com/icon/79485/one-finger">One Finger</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Index("icons8-one-finger-16.png"),
    /**
     * Icon for Java.
     */
    Java("icons8-java-20.png"),
    /**
     * Icon for Kind / Type.
     *
     * @see <a href="https://icons8.com/icon/54136/category">Category</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Kind("icons8-category-16.png"),
    /**
     * Icon for Method.
     *
     * @see
     * <a href="https://icons8.com/icon/e5uh9CTQUVii/mechanistic-analysis">Mechanistic
     * Analysis</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Method("icons8-mechanistic-analysis-16.png"),
    /**
     * Icon for Module.
     *
     * @see <a href="https://icons8.com/icon/6OXjREBZeUan/module">Module</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Module("icons8-module-16.png"),
    /**
     * Icon for Name.
     *
     * @see <a href="https://icons8.com/icon/zbNHwSyrej7I/name-tag">Name Tag</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Name("icons8-name-tag-16.png"),
    /**
     * Icon for Offset / Location.
     *
     * @see <a href="https://icons8.com/icon/2gsR2g07AQvu/map-pin">Map Pin</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Offset("icons8-map-pin-16.png"),
    /**
     * Icon for package.
     *
     * @see <a href="https://icons8.com/icon/t81YhQKj04X8/package">Package</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Package("icons8-package-16.png"),
    /**
     * Icon for parameter, of a method.
     *
     * @see <a href="https://icons8.com/icon/Pohj4RQVOJYd/filter">Filter</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Parameter("icons8-filter-16.png"),
    /**
     * Icon for magic number.
     *
     * @see <a href="https://icons8.com/icon/q8t3iE9rg6YF/magic-wand">Magic
     * Wand</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Magic("icons8-magic-wand-16.png"),
    /**
     * Icon for Max.
     */
    Max("icons8-maxcdn-16.png"),
    /**
     * Icon for return type, of a method.
     *
     * @see <a href="https://icons8.com/icon/13107/return">Return</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Return("icons8-return-16.png"),
    /**
     * Icon for row / line.
     *
     * @see <a href="https://icons8.com/icon/3ZQ7JYqlkFtC/row">Row</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Row("icons8-row-16.png"),
    /**
     * Icon for shortcut.
     *
     * @see <a href="https://icons8.com/icon/i1z7pQ2orcJk/shortcut">Shortcut</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Shortcut("icons8-shortcut-16.png"),
    /**
     * Icon for signature.
     *
     * @see
     * <a href="https://icons8.com/icon/bmicUxC0XDNt/signature">Signature</a>
     * icon by <a href="https://icons8.com">Icons8</a>
     */
    Signature("icons8-signature-16.png"),
    /**
     * Icon for Size.
     *
     * @see <a href="https://icons8.com/icon/d8VomliGByyY/page-size">Page
     * Size</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Size("icons8-page-size-16.png"),
    /**
     * Icon for Stack / Call stack entry.
     *
     * @see <a href="https://icons8.com/icon/43878/stack">Stack</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Stack("icons8-stack-16.png"),
    /**
     * Icon for Tag or Type.
     *
     * @see <a href="https://icons8.com/icon/pmzH4rF8Lrv9/tag">Tag</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Tag("icons8-tag-16.png"),
    /**
     * Icon for time.
     *
     * @see <a href="https://icons8.com/icon/HIiMyiiPLluy/time">Time</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    Time("icons8-time-16.png"),
    /**
     * Icon for verification.
     *
     * @see <a href="https://icons8.com/icon/85086/verified-account">Verified Account</a> icon by <a href="https://icons8.com">Icons8</a>
     */
    Verification("icons8-verified-account-16.png"),
    /**
     * Icon for version.
     *
     * @see <a href="https://icons8.com/icon/59954/versions">Versions</a> icon
     * by <a href="https://icons8.com">Icons8</a>
     */
    Versions("icons8-versions-16.png"),
    /**
     * Icon for zip file.
     *
     * @see <a href="https://icons8.com/icon/49013/zip">ZIP</a> icon by
     * <a href="https://icons8.com">Icons8</a>
     */
    ZIP("icons8-zip-16.png");

    private static final Map<String, Icon> iconCache = new HashMap<>();

    private final String filename;

    private Icons(String filename) {
        this.filename = filename;
    }

    public Icon getIcon() {
        return icon(this.filename);
    }

    private static Icon icon(String url) {
        return iconCache.computeIfAbsent(url, k -> new ImageIcon(Icons.class.getResource("/image/" + url)));
    }

}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/JTreeNodeFileComponent.java`:

```java
/*
 * JTreeNodeClassComponent.java    23:58, August 14, 2007
 *
 * Copyright 2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.ui;

import javax.swing.Icon;
import javax.swing.JPanel;

/**
 * Tree node for a file component.
 *
 * @author Amos Shi
 */
public final class JTreeNodeFileComponent {

    /**
     * Binary data start position for current tree node.
     */
    private final int startPos;
    /**
     * Binary data length for current tree node.
     */
    private final int length;
    /**
     * Tree node text.
     */
    private final String text;

    /**
     * Icon for current tree node.
     */
    private Icon icon;
    /**
     * Description text for current tree node. 
     * It will be shown on the left bottom window on the screen.
     * It supports HTML.
     */
    private String description;
    /**
     * Detailed panel for current tree node.
     */
    private JPanel panelDetail = null;

    /**
     * Constructor.
     *
     * @param nodeStartPos Value for {@link #startPos}
     * @param nodeLength Value for {@link #length}
     * @param nodeText Value for {@link #text}
     */
    public JTreeNodeFileComponent(final int nodeStartPos, final int nodeLength, final String nodeText) {
        if (nodeStartPos < 0) {
            throw new IllegalArgumentException("Start position cannot be less than zero; it is '" + nodeStartPos + "'.");
        }

        if (nodeLength < 0) {
            throw new IllegalArgumentException("Length cannot be less than zero; it is '" + nodeLength + "'.");
        }

        if ((nodeText == null) || (nodeText.length() == 0)) {
            throw new IllegalArgumentException("Text cannot be null or empty.");
        }

        this.startPos = nodeStartPos;
        this.length = nodeLength;
        this.text = nodeText;
    }

    /**
     * Constructor.
     *
     * @param nodeStartPos Value for {@link #startPos}
     * @param nodeLength Value for {@link #length}
     * @param nodeText Value for {@link #text}
     * @param desc Value for {@link #description}, could be null
     */
    public JTreeNodeFileComponent(final int nodeStartPos, final int nodeLength, final String nodeText, final String desc) {
        this(nodeStartPos, nodeLength, nodeText);
        this.description = desc;
    }

    /**
     * Constructor.
     *
     * @param nodeStartPos Value for {@link #startPos}
     * @param nodeLength Value for {@link #length}
     * @param nodeText Value for {@link #text}
     * @param nodeIcon Value for {@link #icon}, could be null
     */
    public JTreeNodeFileComponent(final int nodeStartPos, final int nodeLength, final String nodeText, final Icons nodeIcon) {
        this(nodeStartPos, nodeLength, nodeText);
        if (nodeIcon != null) {
            this.setIcon(nodeIcon.getIcon());
        }
    }

    /**
     * Constructor.
     *
     * @param nodeStartPos Value for {@link #startPos}
     * @param nodeLength Value for {@link #length}
     * @param nodeText Value for {@link #text}
     * @param nodeIcon Value for {@link #icon}, could be null
     * @param desc Value for {@link #description}, could be null
     */
    public JTreeNodeFileComponent(final int nodeStartPos, final int nodeLength, final String nodeText, final Icons nodeIcon, final String desc) {
        this(nodeStartPos, nodeLength, nodeText);
        if (nodeIcon != null) {
            this.setIcon(nodeIcon.getIcon());
        }
        this.description = desc;
    }

    @Override
    public String toString() {
        return this.text;
    }

    /**
     * Getter for {@link #startPos}.
     *
     * @return {@link #startPos} value
     */
    public int getStartPos() {
        return this.startPos;
    }

    /**
     * Getter for {@link #length}.
     *
     * @return {@link #length} value
     */
    public int getLength() {
        return this.length;
    }

    /**
     * Get the last position of current node plus 1, which equals to the first
     * position of the next node. The value is
     * ({@link #startPos} + {@link #length}).
     *
     * @return Last position plus 1
     */
    public int getLastPosPlus1() {
        return this.startPos + this.length;
    }

    /**
     * Getter for {@link #text}.
     *
     * @return {@link #text} value
     */
    public String getText() {
        return this.text;
    }

    /**
     * Getter for {@link #icon}.
     *
     * @return {@link #icon} value
     */
    public Icon getIcon() {
        return this.icon;
    }
    
    /**
     * Setter for {@link #icon}.
     *
     * @param icon value for {@link #icon}
     */
    public void setIcon(Icon icon) {
        this.icon = icon;
    }

    /**
     * Setter for {@link #description}.
     *
     * @param d Value for {@link #description}
     */
    public void setDescription(final String d) {
        this.description = d;
    }

    /**
     * Getter for {@link #description}.
     *
     * @return {@link #description} value
     */
    public String getDescription() {
        return this.description;
    }

    /**
     * Setter for {@link #panelDetail}.
     *
     * @param p Value for {@link #panelDetail}
     */
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value="EI_EXPOSE_REP2", justification="We need it")
    public void setDetailPanel(final JPanel p) {
        this.panelDetail = p;
    }
    
    /**
     * Indicates whether we have a detailed panel {@link #panelDetail}.
     *
     * @return true if {@link #panelDetail} is not null, else false
     */
    public boolean isDetailAvailable() {
        return this.panelDetail != null;
    }

    /**
     * Getter for {@link #panelDetail}.
     *
     * @return {@link #panelDetail} value
     */
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value="EI_EXPOSE_REP", justification="We need it")
    public JPanel getDetailPanel() {
        return this.panelDetail;
    }

}

```

`CommonLib/src/main/java/org/binaryinternals/commonlib/ui/JXMLViewer.java`:

```java
/*
 * JPanelForTree.java    Nov 07, 2009, 08:41
 *
 * Copyright 2009, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.commonlib.ui;

import java.awt.BorderLayout;
import java.io.InputStream;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * Panel based XML data viewer.
 *
 * @author Amos Shi
 */
public class JXMLViewer extends JPanel {

    private static final long serialVersionUID = 4876543219876500005L;
    /**
     * Tabbed Pane for "XML View" and "XML Plain Text".
     */
    private final JTabbedPane tabbedPane;

    /**
     * Constructor.
     *
     * @param xml XML data to be displayed
     */
    public JXMLViewer(final InputStream xml) {
        this.tabbedPane = new JTabbedPane();
        if (xml instanceof PosDataInputStream) {
            byte[] buf = ((PosDataInputStream) xml).getBuf();
            StringBuilder sb = new StringBuilder(buf.length + 1);
            for (byte b : buf) {
                sb.append((char) b);
            }

            JTextArea textPlainText = new JTextArea(sb.toString());
            textPlainText.setLineWrap(true);
            textPlainText.setEditable(false);
            tabbedPane.addTab("XML Plain Text", new JScrollPane(textPlainText));
        }

        this.setLayout(new BorderLayout());
        this.add(this.tabbedPane, BorderLayout.CENTER);
    }
}

```

`CommonLib/src/main/resources/image/README.md`:

```md
Icons from [Icons8](https://icons8.com/)

* Free version is avaible if [linking](https://icons8.com/pricing) is added

```

`FormatBMP/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.bmp</artifactId>
    <version>1.1</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatBMP</name>
    <description>Bitmap image, or Device Independent Bitmap (DIB) file format</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.bmp.PluginDescriptorBMP</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

```

`FormatBMP/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatbmp {
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.bmp;
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/BMPFile.java`:

```java
/**
 * BMPFile.java    Nov 28, 2010, 21:00
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.File;
import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class BMPFile extends FileFormat{

    public final BitmapFileHeader bitmapFileHeader;
    public final DIBHeader dibHeader;
    public final ColorTable colorTable;
    public final PixelArray pixelArray;

    public BMPFile(final File file) throws IOException, FileFormatException {
        super(file);

        // Parse
        PosDataInputStream input = new PosDataInputStream(
                new PosByteArrayInputStream(this.fileByteArray));
        this.bitmapFileHeader = new BitmapFileHeader(input);
        this.dibHeader = new DIBHeader(input);

        if (input.getPos() < this.bitmapFileHeader.offset) {
            this.colorTable = new ColorTable(input, this);
        } else {
            this.colorTable = null;
        }

        this.pixelArray = new PixelArray(this);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int lastPos = 0;
        int distance;

        this.bitmapFileHeader.generateTreeNode(parentNode);
        lastPos = lastPos + BitmapFileHeader.LENGTH;

        this.dibHeader.generateTreeNode(parentNode);
        lastPos = lastPos + this.dibHeader.size;

        if (this.colorTable != null) {
            this.colorTable.generateTreeNode(parentNode);
            lastPos = lastPos + this.colorTable.getLength();
        }

        distance = (this.pixelArray.getStartPos() - lastPos);
        if (distance > 0) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos,
                    distance,
                    String.format("GAP1 [0x%08X, %d]", lastPos, distance))));
        }

        this.pixelArray.generateTreeNode(parentNode);
    }

    @Override
    public String getContentTabName() {
        return "BMP File";
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/BitmapFileHeader.java`:

```java
/**
 * BitmapFileHeader.java    Nov 28, 2010, 21:00
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class BitmapFileHeader extends FileComponent implements GenerateTreeNode {

    public static final int LENGTH = 14;

    /**
     * The magic number used to identify the BMP file, usually 0x42 0x4D in hex,
     * same as BM in ASCII.
     *
     * The following entries are possible:
     * <ul>
     * <li> <strong>BM</strong> – Windows 3.1x, 95, NT, ... etc. </li>
     * <li> <strong>BA</strong> – OS/2 Bitmap Array</li>
     * <li> <strong>CI</strong> – OS/2 Color Icon</li>
     * <li> <strong>CP</strong> – OS/2 Color Pointer</li>
     * <li> <strong>IC</strong> – OS/2 Icon</li>
     * <li> <strong>PT</strong> – OS/2 Pointer</li>
     * </ul>
     */
    public final String magic;
    /** The fileSize of the BMP file in bytes */
    public final long fileSize;
    /** Reserved; actual value depends on the application that creates the image */
    public final byte[] creator1 = new byte[2];
    /** Reserved; actual value depends on the application that creates the image */
    public final byte[] creator2 = new byte[2];
    /** The offset, i.e. starting address, of the byte where the bitmap data can be found. */
    public final long offset;

    BitmapFileHeader(final PosDataInputStream input) throws IOException{
        this.startPos = input.getPos();
        this.length = LENGTH;

        this.magic = input.readASCII(2);
        this.fileSize = input.readUnsignedIntInLittleEndian();
        input.readFully(this.creator1);
        input.readFully(this.creator2);
        this.offset = input.readUnsignedIntInLittleEndian();

        if (this.fileSize != input.getBuf().length) {
            // File size exception
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("Bitmap File Header [0x%08X, %d]", this.startPos, this.length));
        comp.setDescription("This block of bytes is at the start of the file and is used to identify the file. A typical application reads this block first to ensure that the file is actually a BMP file and that it is not damaged.");
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos,
                2,
                String.format("magic number = %s", this.magic));
        comp.setDescription("The magic number used to identify the BMP file, usually <code>0x42</code> <code>0x4D</code> in hex, same as <strong>BM</strong> in ASCII. ");
        node.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 2,
                4,
                String.format("file size = %d (0x%04X)", this.fileSize, this.fileSize));
        comp.setDescription("The size of the BMP file in bytes.");
        node.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 6,
                2,
                "reserved 1");
        comp.setDescription("Reserved; actual value depends on the application that creates the image.");
        node.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 8,
                2,
                "reserved 2");
        comp.setDescription("Reserved; actual value depends on the application that creates the image.");
        node.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 10,
                4,
                String.format("offset = %d (0x%08X)", this.offset, this.offset));
        comp.setDescription("The offset, i.e. starting address, of the byte where the bitmap data can be found.");
        node.add(new DefaultMutableTreeNode(comp));
    }



}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/ColorTable.java`:

```java
/**
 * ColorTable.java    Dec 01, 2010, 22:59
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class ColorTable extends FileComponent implements GenerateTreeNode {

    public final Object[] palette;

    ColorTable(final PosDataInputStream input, final BMPFile bmpFile) throws IOException {

        int bpp = bmpFile.dibHeader.getBitCount();

        if ((bpp < 0) || (bpp > 8)) {
            this.palette = null;
            return;
        }

        this.startPos = input.getPos();
        int size = 2 << (bpp - 1);

        if (bmpFile.dibHeader.data instanceof DIBHeader.BITMAPCOREHEADER) {
            this.length = size * PixelBGR.LENGTH;
            this.palette = new PixelBGR[size];
            for (int i = 0; i < size; i++) {
                this.palette[i] = new PixelBGR(input);
            }

            // TODO - Should we have another if branch?
        } else {
            this.length = size * PixelRGBA.LENGTH;
            this.palette = new PixelRGBA[size];
            for (int i = 0; i < size; i++) {
                this.palette[i] = new PixelRGBA(input);
            }
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.palette == null) {
            return;
        }

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;
        DefaultMutableTreeNode nodePixel;
        String pixelTypeName;
        int pixelLength;

        comp = new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("Color Table [0x%08X, %d]", this.startPos, this.length));
        comp.setDescription("The Color Table is a block of bytes (a table) listing the colors used by the image.");
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        pixelTypeName = this.palette[0].getClass().getSimpleName();
        pixelLength = ((FileComponent) this.palette[0]).getLength();

        for (int i = 0; i < this.palette.length; i++) {
            node.add(nodePixel = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + pixelLength * i,
                    pixelLength,
                    String.format("%s [%d]", pixelTypeName, i))));
            ((GenerateTreeNode) this.palette[i]).generateTreeNode(nodePixel);
        }
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/DIBHeader.java`:

```java
/**
 * DIBHeader.java    Nov 29, 2010, 12:28
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class DIBHeader extends FileComponent implements GenerateTreeNode {

    /** The size of this header in bytes. */
    public final int size;
    public final Object data;

    DIBHeader(final PosDataInputStream input) throws IOException {
        this.startPos = input.getPos();

        this.size = input.readIntInLittleEndian();
        this.length = this.size;
        switch (this.size) {
            case 12:
                this.data = new BITMAPCOREHEADER(input);
                break;
            case 40:
                this.data = new BITMAPINFOHEADER(input);
                break;
            case 52:
                this.data = new BITMAPV2INFOHEADER(input);
                break;
            case 56:
                this.data = new BITMAPV3INFOHEADER(input);
                break;
            case 64:
                this.data = new BITMAPCOREHEADER2(input);
                break;
            case 108:
                this.data = new BITMAPV4HEADER(input);
                break;
            case 124:
                this.data = new BITMAPV5HEADER(input);
                break;
            default:
                this.data = null;
                throw new IllegalArgumentException(String.format(
                        "Un-recognized DIB Header length encountered (%d).", this.length));
        }
    }

    /**
     * Get the number of bits-per-pixel.
     *
     * @return the bits-per-pixel value
     */
    public int getBitCount() {
        if (this.data instanceof BITMAPCOREHEADER) {
            return ((BITMAPCOREHEADER) this.data).BitCount;
        } else if (this.data instanceof BITMAPINFOHEADER) {
            return ((BITMAPINFOHEADER) this.data).BitCount;
        } else {
            return -1;
        }
    }

    ;

    /**
     * The size of the image in bytes.
     * If it is BITMAPINFOHEADER, we return the <code>SizeImage</code> value;
     * if it is BITMAPCOREHEADER, we calculate the value on the fly.
     *
     * @return the image size in bytes
     * @see <a href="http://doxygen.reactos.org/d6/dea/bmpdecode_8c_source.html">BMP Decode source code from www.reactos.org </a>
     */
    public long calcImageSize() {
        if (this.data instanceof BITMAPCOREHEADER) {
            // The <code>ceil</code> method needs a double paramter, int parameter will cause error because it is not float.
            BITMAPCOREHEADER core = (BITMAPCOREHEADER) this.data;
            return ((long)(Math.ceil(((double)core.Width) * core.BitCount / 32) * 4)) * core.Height;
        } else if (this.data instanceof BITMAPCOREHEADER2) {
            // Attention: BITMAPCOREHEADER2 is based on BITMAPINFOHEADER, instead of BITMAPCOREHEADER.
            BITMAPCOREHEADER2 core2 = (BITMAPCOREHEADER2) this.data;
            return ((long)(Math.ceil(((double)core2.Width) * core2.BitCount / 32) * 4)) * core2.Height;
        } else if (this.data instanceof BITMAPINFOHEADER) {
            return ((BITMAPINFOHEADER) this.data).SizeImage;
        } else {
            return -1;
        }
    }

    public int getWidth() {
        if (this.data instanceof BITMAPCOREHEADER) {
            return ((BITMAPCOREHEADER) this.data).Width;
        } else if (this.data instanceof BITMAPINFOHEADER) {
            return ((BITMAPINFOHEADER) this.data).Width;
        } else {
            return -1;
        }
    }

    public int getHeight() {
        if (this.data instanceof BITMAPCOREHEADER) {
            return ((BITMAPCOREHEADER) this.data).Height;
        } else if (this.data instanceof BITMAPINFOHEADER) {
            return ((BITMAPINFOHEADER) this.data).Height;
        } else {
            return -1;
        }
    }

    public int getCompressionMethod() {
        if (this.data instanceof BITMAPINFOHEADER) {
            return ((BITMAPINFOHEADER) this.data).Compression;
        } else {
            // If it is BITMAPCOREHEADER, it is the same as not compressed.
            return CompressionMethod.BI_RGB.value;
        }
    }

    public long getICCProfileData() {
        if (this.data instanceof BITMAPV5HEADER) {
            return ((BITMAPV5HEADER) this.data).ICCProfileData;
        } else {
            return -1;
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("DIB Header (%s) [0x%08X, %d]", this.data.getClass().getSimpleName(), this.startPos, this.length));
        comp.setDescription("Bitmap Information Header.");
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        if (this.data instanceof GenerateTreeNode) {
            ((GenerateTreeNode) this.data).generateTreeNode(node);
        }
    }

    /**
     * Or named <code>OS21XBITMAPHEADER</code>.
     *
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd183372%28VS.85%29.aspx">BITMAPCOREHEADER Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPCOREHEADER extends FileComponent implements GenerateTreeNode {

        public static final int SIZE = 12;
        public final int Width;
        public final int Height;
        public final int Planes;
        public final int BitCount;

        BITMAPCOREHEADER(final PosDataInputStream input) throws IOException {
            this.startPos = input.getPos() - 4;
            this.length = SIZE;

            this.Width = input.readUnsignedShortInLittleEndian();
            this.Height = input.readUnsignedShortInLittleEndian();
            this.Planes = input.readUnsignedShortInLittleEndian();
            this.BitCount = input.readUnsignedShortInLittleEndian();
        }

        public void generateTreeNode(DefaultMutableTreeNode node) {
            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos,
                    4,
                    String.format("size = %d", SIZE));
            comp.setDescription("The size of this header in bytes.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 4,
                    2,
                    String.format("width = %d", this.Width));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 6,
                    2,
                    String.format("height = %d", this.Height));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    2,
                    String.format("planes = %d", this.Planes));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 10,
                    2,
                    String.format("bits per pixel = %d", this.BitCount));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    };

    /**
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd183376%28VS.85%29.aspx">BITMAPINFOHEADER Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPINFOHEADER extends FileComponent implements GenerateTreeNode {

        /** The number of bytes required by the structure. */
        public static final int SIZE = 40;
        /** The width of the bitmap, in pixels. */
        public final int Width;
        /** The height of the bitmap, in pixels. */
        public final int Height;
        /** The number of planes for the target device. This value must be set to 1. */
        public final int Planes;
        /** The number of bits-per-pixel. */
        public final int BitCount;
        /** The type of compression for a compressed bottom-up bitmap (top-down DIBs cannot be compressed). */
        public final int Compression;
        /** The size, in bytes, of the image. */
        public final long SizeImage;
        /** The horizontal resolution, in pixels-per-meter, of the target device for the bitmap. */
        public final int XPelsPerMeter;
        /** The vertical resolution, in pixels-per-meter, of the target device for the bitmap. */
        public final int YPelsPerMeter;
        /** The number of color indexes in the color table that are actually used by the bitmap. */
        public final long ColorsUsed;
        /** The number of color indexes that are required for displaying the bitmap. */
        public final long ColorsImportant;

        BITMAPINFOHEADER(final PosDataInputStream input) throws IOException {
            this.startPos = input.getPos() - 4;
            this.length = SIZE;

            this.Width = input.readIntInLittleEndian();
            this.Height = input.readIntInLittleEndian();
            this.Planes = input.readUnsignedShortInLittleEndian();
            this.BitCount = input.readUnsignedShortInLittleEndian();
            this.Compression = input.readIntInLittleEndian();
            this.SizeImage = input.readUnsignedIntInLittleEndian();
            this.XPelsPerMeter = input.readIntInLittleEndian();
            this.YPelsPerMeter = input.readIntInLittleEndian();
            this.ColorsUsed = input.readUnsignedIntInLittleEndian();
            this.ColorsImportant = input.readUnsignedIntInLittleEndian();
        }

        public void generateTreeNode(DefaultMutableTreeNode node) {
            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos,
                    4,
                    String.format("size = %d", this.length));
            comp.setDescription("The size of this header in bytes.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 4,
                    4,
                    String.format("bitmap width = %d", this.Width));
            comp.setDescription("The bitmap width in pixels (signed integer).");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("bitmap height = %d", this.Height));
            comp.setDescription("The bitmap width in pixels (signed integer).");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 12,
                    2,
                    String.format("color planes = %d", this.Planes));
            comp.setDescription("The number of color planes being used. Must be set to 1.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 14,
                    2,
                    String.format("bits per pixel = %d", this.BitCount));
            comp.setDescription("The number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 16,
                    4,
                    String.format("compression method = %d", this.Compression));
            comp.setDescription("The compression method being used. See the next table for a list of possible values.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 20,
                    4,
                    String.format("image size = %d", this.SizeImage));
            comp.setDescription("The image size. This is the size of the raw bitmap data (see below), and should not be confused with the file size.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 24,
                    4,
                    String.format("horizontal resolution = %d", this.XPelsPerMeter));
            comp.setDescription("The horizontal resolution of the image. (pixel per meter, signed integer).");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 28,
                    4,
                    String.format("vertical resolution = %d", this.YPelsPerMeter));
            comp.setDescription("The vertical resolution of the image. (pixel per meter, signed integer).");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 32,
                    4,
                    String.format("colors = %d", this.ColorsUsed));
            comp.setDescription("The number of colors in the color palette, or 0 to default to 2<sup>n</sup>.");
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 36,
                    4,
                    String.format("important colors = %d", this.ColorsImportant));
            comp.setDescription("The number of important colors used, or 0 when every color is important; generally ignored.");
            node.add(new DefaultMutableTreeNode(comp));
        }
    }

    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPV2INFOHEADER extends BITMAPINFOHEADER {

        @SuppressWarnings("FieldNameHidesFieldInSuperclass")
        public static final int SIZE = 52;

        BITMAPV2INFOHEADER(final PosDataInputStream input) throws IOException {
            super(input);
            this.length = BITMAPV2INFOHEADER.SIZE;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode node) {
            super.generateTreeNode(node);

            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE,
                    SIZE - BITMAPINFOHEADER.SIZE,
                    "BITMAPV2INFOHEADER - Added data");
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    };

    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPV3INFOHEADER extends BITMAPINFOHEADER {

        @SuppressWarnings("FieldNameHidesFieldInSuperclass")
        public static final int SIZE = 56;

        BITMAPV3INFOHEADER(final PosDataInputStream input) throws IOException {
            super(input);
            this.length = BITMAPV3INFOHEADER.SIZE;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode node) {
            super.generateTreeNode(node);

            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE,
                    SIZE - BITMAPINFOHEADER.SIZE,
                    "BITMAPV2INFOHEADER - Added data");
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    };

    /**
     * @see <a href="http://doxygen.reactos.org/d7/d02/structBITMAPCOREHEADER2.html">BITMAPCOREHEADER2 Structure Reference</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPCOREHEADER2 extends BITMAPINFOHEADER {

        @SuppressWarnings("FieldNameHidesFieldInSuperclass")
        public static final int SIZE = 64;
        public final int ResUnit;
        public final int Reserved;
        public final int Orientation;
        public final int Halftoning;
        public final long HalftoneSize1;
        public final long HalftoneSize2;
        public final long ColorSpace;
        public final long AppData;

        BITMAPCOREHEADER2(final PosDataInputStream input) throws IOException {
            super(input);
            this.length = BITMAPCOREHEADER2.SIZE;

            this.ResUnit = input.readUnsignedShortInLittleEndian();
            this.Reserved = input.readUnsignedShortInLittleEndian();
            this.Orientation = input.readUnsignedShortInLittleEndian();
            this.Halftoning = input.readUnsignedShortInLittleEndian();
            this.HalftoneSize1 = input.readUnsignedIntInLittleEndian();
            this.HalftoneSize2 = input.readUnsignedIntInLittleEndian();
            this.ColorSpace = input.readUnsignedIntInLittleEndian();
            this.AppData = input.readUnsignedIntInLittleEndian();
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode node) {
            super.generateTreeNode(node);

            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE,
                    2,
                    String.format("ResUnit = %d", ResUnit));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 2,
                    2,
                    String.format("Reserved = %d", Reserved));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 4,
                    2,
                    String.format("Orientation = %d", Orientation));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 6,
                    2,
                    String.format("Halftoning = %d", Halftoning));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 8,
                    4,
                    String.format("HalftoneSize1 = %d", HalftoneSize1));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 12,
                    4,
                    String.format("HalftoneSize2 = %d", HalftoneSize2));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 16,
                    4,
                    String.format("ColorSpace = %d", ColorSpace));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 20,
                    4,
                    String.format("AppData = %d", AppData));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    };

    /**
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd183380%28VS.85%29.aspx">BITMAPV4HEADER Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPV4HEADER extends BITMAPINFOHEADER {

        @SuppressWarnings("FieldNameHidesFieldInSuperclass")
        public static final int SIZE = 108;
        /** Color mask that specifies the red component of each pixel, valid only if <code>Compression</code> is set to <code>BI_BITFIELDS</code>. */
        public final long RedMask;
        /** Color mask that specifies the green component of each pixel, valid only if <code>Compression</code> is set to <code>BI_BITFIELDS</code>. */
        public final long GreenMask;
        /** Color mask that specifies the blue component of each pixel, valid only if <code>Compression</code> is set to <code>BI_BITFIELDS</code>. */
        public final long BlueMask;
        /** Color mask that specifies the alpha component of each pixel. */
        public final long AlphaMask;
        /** The color space of the DIB. */
        public final int ColorSpaceType;
        /** Specifies the x, y, and z coordinates of the three colors that correspond to the red, green, and blue endpoints for the logical color space associated with the bitmap. */
        public final CIEXYZTRIPLE Endpoints;
        /** Tone response curve for red. */
        public final long GammaRed;
        /** Tone response curve for green. */
        public final long GammaGreen;
        /** Tone response curve for blue. */
        public final long GammaBlue;

        BITMAPV4HEADER(final PosDataInputStream input) throws IOException {
            super(input);
            this.length = BITMAPV4HEADER.SIZE;

            this.RedMask = input.readUnsignedIntInLittleEndian();
            this.GreenMask = input.readUnsignedIntInLittleEndian();
            this.BlueMask = input.readUnsignedIntInLittleEndian();
            this.AlphaMask = input.readUnsignedIntInLittleEndian();
            this.ColorSpaceType = input.readIntInLittleEndian();
            this.Endpoints = new CIEXYZTRIPLE(input);
            this.GammaRed = input.readUnsignedIntInLittleEndian();
            this.GammaGreen = input.readUnsignedIntInLittleEndian();
            this.GammaBlue = input.readUnsignedIntInLittleEndian();
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void generateTreeNode(DefaultMutableTreeNode node) {
            super.generateTreeNode(node);

            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE,
                    4,
                    String.format("RedMask = %d", RedMask));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 4,
                    4,
                    String.format("GreenMask = %d", GreenMask));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 8,
                    4,
                    String.format("BlueMask = %d", BlueMask));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 12,
                    4,
                    String.format("AlphaMask = %d", AlphaMask));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 16,
                    4,
                    String.format("ColorSpaceType = %d", ColorSpaceType));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 20,
                    CIEXYZTRIPLE.SIZE,
                    "Endpoints");
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 20 + CIEXYZTRIPLE.SIZE,
                    4,
                    String.format("GammaRed = %d", GammaRed));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 20 + CIEXYZTRIPLE.SIZE + 4,
                    4,
                    String.format("GammaGreen = %d", GammaGreen));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPINFOHEADER.SIZE + 20 + CIEXYZTRIPLE.SIZE + 8,
                    4,
                    String.format("GammaBlue = %d", GammaBlue));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    }

    /**
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd183381%28VS.85%29.aspx">BITMAPV5HEADER Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class BITMAPV5HEADER extends BITMAPV4HEADER {

        @SuppressWarnings("FieldNameHidesFieldInSuperclass")
        public static final int SIZE = 124;
        /** Rendering intent for bitmap. */
        public final long Intent;
        /** The offset, in bytes, from the beginning of the BITMAPV5HEADER structure to the start of the profile data. */
        public final long ICCProfileData;
        /** Size, in bytes, of embedded profile data. */
        public final long ICCProfileSize;
        /** This member has been reserved. */
        public final long Reserved;

        BITMAPV5HEADER(final PosDataInputStream input) throws IOException {
            super(input);
            this.length = SIZE;

            this.Intent = input.readUnsignedIntInLittleEndian();
            this.ICCProfileData = input.readUnsignedIntInLittleEndian();
            this.ICCProfileSize = input.readUnsignedIntInLittleEndian();
            this.Reserved = input.readUnsignedIntInLittleEndian();
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode node) {
            super.generateTreeNode(node);

            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPV4HEADER.SIZE,
                    4,
                    String.format("Intent = %d", Intent));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPV4HEADER.SIZE + 4,
                    4,
                    String.format("ICC Profile Data = %d", ICCProfileData));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPV4HEADER.SIZE + 8,
                    4,
                    String.format("ICC Profile Size = %d", ICCProfileSize));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + BITMAPV4HEADER.SIZE + 12,
                    4,
                    String.format("Reserved = %d", Reserved));
            comp.setDescription(null);
            node.add(new DefaultMutableTreeNode(comp));
        }
    }

    /**
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd371828%28v=VS.85%29.aspx">CIEXYZ Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class CIEXYZ {

        /** The x coordinate in fix point. */
        public final long x;
        /** The y coordinate in fix point. */
        public final long y;
        /** The z coordinate in fix point. */
        public final long z;

        CIEXYZ(final PosDataInputStream input) throws IOException {
            this.x = input.readUnsignedIntInLittleEndian();
            this.y = input.readUnsignedIntInLittleEndian();
            this.z = input.readUnsignedIntInLittleEndian();
        }
    }

    /**
     * @see <a href="http://msdn.microsoft.com/en-us/library/dd371833%28v=VS.85%29.aspx">CIEXYZTRIPLE Structure</a>
     */
    @SuppressWarnings("PublicInnerClass")
    public static class CIEXYZTRIPLE {

        public static final int SIZE = 36;
        /** The xyz coordinates of red endpoint. */
        public final CIEXYZ Red;
        /** The xyz coordinates of green endpoint. */
        public final CIEXYZ Green;
        /** The xyz coordinates of blue endpoint. */
        public final CIEXYZ Blue;

        CIEXYZTRIPLE(final PosDataInputStream input) throws IOException {
            this.Red = new CIEXYZ(input);
            this.Green = new CIEXYZ(input);
            this.Blue = new CIEXYZ(input);
        }
    }

    @SuppressWarnings("PublicInnerClass")
    public enum CompressionMethod {

        /** No compress method used. This is the most common case. */
        BI_RGB(0),
        /** RLE 8-bit/pixel. Can be used only with 8-bit/pixel bitmaps. */
        BI_RLE8(1),
        /** RLE 4-bit/pixel. Can be used only with 4-bit/pixel bitmaps. */
        BI_RLE4(2),
        /** Bit field or Huffman 1D compression for BITMAPCOREHEADER2.
         *  Pixel format defined by bit masks or Huffman 1D compressed bitmap
         *  for BITMAPCOREHEADER2
         */
        BI_BITFIELDS(3),
        /** JPEG or RLE-24 compression for BITMAPCOREHEADER2.
         *  The bitmap contains a JPEG image or RLE-24 compressed bitmap for
         *  BITMAPCOREHEADER2
         */
        BI_JPEG(4),
        /** The bitmap contains a PNG image. */
        BI_PNG(5);
        /** Value of a compression method. */
        public final int value;

        CompressionMethod(int i) {
            this.value = i;
        }
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/PixelArray.java`:

```java
/**
 * PixelArray.java    Dec 03, 2010, 22:19
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.bmp.DIBHeader.CompressionMethod;

/**
 *
 * @author Amos Shi
 */
public class PixelArray extends FileComponent implements GenerateTreeNode {

    private final BMPFile bmpFile;

    PixelArray(final BMPFile bmpFile) throws IOException {
        this.bmpFile = bmpFile;
        this.startPos = (int) bmpFile.bitmapFileHeader.offset;
        this.length = (int) bmpFile.dibHeader.calcImageSize();
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("Pixel Array [0x%08X, %d]", this.startPos, this.length));
        comp.setDescription("The pixel format is defined by the DIB Header. <br/>Each row in the Pixel Array is padded to a multiple of 4 bytes in size.");
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        if (this.bmpFile.dibHeader.getCompressionMethod() == CompressionMethod.BI_RGB.value) {
            switch (this.bmpFile.dibHeader.getBitCount()) {
                case 1:
                    this.generateTreeNode_bpp_1(node);
                    break;
                case 4:
                    this.generateTreeNode_bpp_4(node);
                    break;
                case 8:
                    this.generateTreeNode_bpp_8(node);
                    break;
                case 16:
                    this.generateTreeNode_bpp_16(node);
                    break;
                case 24:
                    this.generateTreeNode_bpp_24(node);
                    break;
                case 32:
                    this.generateTreeNode_bpp_32(node);
                    break;
                default:
            }
        } else {
            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos,
                    this.length,
                    "Compressed Data")));
        }
    }

    /** Generate tree nodes for 1-bit per pixel (1 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_1(DefaultMutableTreeNode parentNode) {
        int rowSize = ((this.bmpFile.dibHeader.getWidth() + 31) >> 5) << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }

    /** Generate tree nodes for 4-bit per pixel (4 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_4(DefaultMutableTreeNode parentNode) {
        int rowSize = ((this.bmpFile.dibHeader.getWidth() + 7) >> 3) << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }

    /** Generate tree nodes for 8-bit per pixel (8 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_8(DefaultMutableTreeNode parentNode) {
        int rowSize = ((this.bmpFile.dibHeader.getWidth() + 3) >> 2) << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }

    /** Generate tree nodes for 16-bit per pixel (16 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_16(DefaultMutableTreeNode parentNode) {
        int rowSize = (((this.bmpFile.dibHeader.getWidth() << 1) + 3) >> 2) << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }

    /** Generate tree nodes for 24-bit per pixel (24 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_24(DefaultMutableTreeNode parentNode) {
        int rowSize = (((this.bmpFile.dibHeader.getWidth() << 1) + this.bmpFile.dibHeader.getWidth() + 3) >> 2) << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }

    /** Generate tree nodes for 32-bit per pixel (32 <code>bpp</code>) format. */
    private void generateTreeNode_bpp_32(DefaultMutableTreeNode parentNode) {
        int rowSize = this.bmpFile.dibHeader.getWidth() << 2;
        for (int i = 0; i < this.bmpFile.dibHeader.getHeight(); i++) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + rowSize * i,
                    rowSize,
                    String.format("row [%d]", i))));
        }
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/PixelBGR.java`:

```java
/**
 * PixelBGR.java    Apr 05, 2011, 18:38
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The OS2 1x Palette Element.
 *
 * @author Amos Shi
 * @see <a href="http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm"> OS/2 Bitmap </a>
 */
public class PixelBGR extends FileComponent implements GenerateTreeNode {

    public static final int LENGTH = 3;
    public final int Blue;
    public final int Green;
    public final int Red;

    PixelBGR(final PosDataInputStream input) throws IOException {
        this.startPos = input.getPos();
        this.length = PixelBGR.LENGTH;

        this.Blue = input.readUnsignedByte();
        this.Green = input.readUnsignedByte();
        this.Red = input.readUnsignedByte();
    }

    public void generateTreeNode(DefaultMutableTreeNode parent) {
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos,
                1,
                String.format("Blue = %d", this.Blue))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + 1,
                1,
                String.format("Green = %d", this.Green))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + 2,
                1,
                String.format("Red = %d", this.Red))));
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/PixelRGBA.java`:

```java
/**
 * PixelRGBA.java    Dec 03, 2010, 21:55
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.bmp;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class PixelRGBA extends FileComponent implements GenerateTreeNode {

    public static final int LENGTH = 4;
    public final int Red;
    public final int Green;
    public final int Blue;
    public final int Alpha;

    PixelRGBA(final PosDataInputStream input) throws IOException {
        this.startPos = input.getPos();
        this.length = PixelRGBA.LENGTH;

        this.Red = input.readUnsignedByte();
        this.Green = input.readUnsignedByte();
        this.Blue = input.readUnsignedByte();
        this.Alpha = input.readUnsignedByte();
    }

    public void generateTreeNode(DefaultMutableTreeNode parent) {
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos,
                1,
                String.format("Red = %d", this.Red))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + 1,
                1,
                String.format("Green = %d", this.Green))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + 2,
                1,
                String.format("Blue = %d", this.Blue))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + 3,
                1,
                String.format("Alpha = %d", this.Alpha))));
    }
}

```

`FormatBMP/src/main/java/org/binaryinternals/format/bmp/PluginDescriptorBMP.java`:

```java
/*
 * PluginDescriptorBMP.java    Apr 16, 2011, 20:14
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.bmp;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorBMP implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "Bitmap Images (*.bmp)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"bmp"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return BMPFile.class;
    }

}

```

`FormatCLASS/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.class</artifactId>
    <version>21.0</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatCLASS</name>
    <description>The Java Virtual Machine Specification - The class File Format</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.classfile.PluginDescriptorClass</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

```

`FormatCLASS/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatclass {
    requires static com.github.spotbugs.annotations;
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.classfile;
    exports org.binaryinternals.format.classfile.attribute;
    exports org.binaryinternals.format.classfile.attribute.aspectj;
    exports org.binaryinternals.format.classfile.attribute.scala;
    exports org.binaryinternals.format.classfile.constant;
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/AccessFlag.java`:

```java
/*
 * AccessFlag.java    11:11, June 20, 2015
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.format.classfile.attribute.InnerClasses_attribute;
import org.binaryinternals.format.classfile.attribute.MethodParameters_attribute;
import org.binaryinternals.format.classfile.attribute.Module_attribute;

/**
 * Access flags are mask of flags used to denote access permissions to and
 * properties of this class file.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S2386 - Mutable fields should not be "public static" --- We keep the simplied public variable
 * </pre>
 */
@SuppressWarnings("java:S2386")
public enum AccessFlag {

    /**
     * Declared <code>public</code>; may be accessed from outside its package.
     */
    ACC_PUBLIC(0x0001, JavaLangSpec.Keyword.PUBLIC.text),
    /**
     * Declared <code>private</code>; usable only within the defining class.
     */
    ACC_PRIVATE(0x0002, JavaLangSpec.Keyword.PRIVATE.text),
    /**
     * Declared <code>protected</code>; may be accessed within subclasses.
     */
    ACC_PROTECTED(0x0004, JavaLangSpec.Keyword.PROTECTED.text),
    /**
     * Declared <code>static</code>.
     */
    ACC_STATIC(0x0008, JavaLangSpec.Keyword.STATIC.text),
    /**
     * Declared <code>final</code>; no subclasses allowed.
     */
    ACC_FINAL(0x0010, JavaLangSpec.Keyword.FINAL.text),
    /**
     * Indicates that this module ({@link Module_attribute}) is open.
     */
    ACC_OPEN(0x0010, JavaLangSpec.ContextualKeyword.OPEN.keyword),
    /**
     * Treat superclass methods specially when invoked by the
     * <code>invokespecial</code> instruction.
     */
    ACC_SUPER(0x0020, JavaLangSpec.Keyword.SUPER.text),
    /**
     * Declared <code>synchronized</code>; invocation is wrapped by a monitor
     * use.
     */
    ACC_SYNCHRONIZED(0x0020, JavaLangSpec.Keyword.SYNCHRONIZED.text),
    /**
     * Indicates that any module which depends on the current module, implicitly
     * declares a dependence on the module indicated by this entry.
     */
    ACC_TRANSITIVE(0x0020, JavaLangSpec.ContextualKeyword.TRANSITIVE.keyword),
    /**
     * Declared <code>volatile</code>; cannot be cached.
     */
    ACC_VOLATILE(0x0040, JavaLangSpec.Keyword.VOLATILE.text),
    /**
     * A bridge method, generated by the compiler.
     */
    ACC_BRIDGE(0x0040, "ACC_BRIDGE"),
    /**
     * Indicates that this dependence is mandatory in the static phase, i.e., at
     * compile time, but is optional in the dynamic phase, i.e., at run time.
     */
    ACC_STATIC_PHASE(0x0040, "ACC_STATIC_PHASE"),
    /**
     * Declared <code>transient</code>; not written or read by a persistent
     * object manager.
     */
    ACC_TRANSIENT(0x0080, JavaLangSpec.Keyword.TRANSIENT.text),
    /**
     * Declared with variable number of arguments.
     */
    ACC_VARARGS(0x0080, "ACC_VARARGS"),
    /**
     * Declared <code>native</code>; implemented in a language other than Java.
     */
    ACC_NATIVE(0x0100, JavaLangSpec.Keyword.NATIVE.text),
    /**
     * Is an interface, not a class.
     */
    ACC_INTERFACE(0x0200, JavaLangSpec.Keyword.INTERFACE.text),
    /**
     * Declared <code>abstract</code>; must not be instantiated.
     */
    ACC_ABSTRACT(0x0400, JavaLangSpec.Keyword.ABSTRACT.text),
    /**
     * Declared <code>strictfp</code>; floating-point mode is FP-strict.
     */
    ACC_STRICT(0x0800, JavaLangSpec.Keyword.STRICTFP.text),
    /**
     * Declared <code>synthetic</code>; not present in the source code.
     *
     * Indicates that this module ({@link Module_attribute}) was not explicitly
     * or implicitly declared.
     *
     * Indicates that this dependence was not explicitly or implicitly declared
     * in the source of the module declaration.
     *
     * Indicates that this export was not explicitly or implicitly declared in
     * the source of the module declaration.
     *
     * Indicates that this opening was not explicitly or implicitly declared in
     * the source of the module declaration.
     */
    ACC_SYNTHETIC(0x1000, "ACC_SYNTHETIC"),
    /**
     * Declared as an annotation type.
     */
    ACC_ANNOTATION(0x2000, "@interface"),
    /**
     * Declared as an <code>enum</code> type.
     */
    ACC_ENUM(0x4000, JavaLangSpec.Keyword.ENUM.text),
    /**
     * Is a module, not a class or interface.
     */
    ACC_MODULE(0x8000, JavaLangSpec.ContextualKeyword.MODULE.keyword),
    /**
     * Indicates that the formal parameter was implicitly declared in source
     * code, according to the specification of the language in which the source
     * code was written (JLS §13.1). (The formal parameter is mandated by a
     * language specification, so all compilers for the language must emit it.)
     *
     * Indicates that this module was implicitly declared.
     *
     * Indicates that this dependence was implicitly declared in the source of
     * the module declaration.
     *
     * Indicates that this export was implicitly declared in the source of the
     * module declaration.
     *
     * Indicates that this opening was implicitly declared in the source of the
     * module declaration.
     */
    ACC_MANDATED(    0x8000, "ACC_MANDATED"),
    /**
     * Constructor method (class or instance initializer).
     * Used by Android dex.
     */
    ACC_CONSTRUCTOR(0x10000, "ACC_CONSTRUCTOR"),
    /**
     * Declared <code>synchronized</code>.
     * Used by Android dex.
     */
    ACC_DECLARED_SYNCHRONIZED(0x20000, "ACC_DECLARED_SYNCHRONIZED");

    /**
     * Binary value in the {@link ClassFile}.
     */
    public final long value;

    /**
     * Modifier in the java source file. Some modifier does not exist in the
     * source file but generated by compiler.
     */
    public final String modifier;

    /**
     * Modifiers for {@link ClassFile}.
     */
    public static final List<AccessFlag> ForClass = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * Modifiers for {@link field_info}.
     */
    public static final List<AccessFlag> ForField = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * Modifiers for {@link InnerClasses_attribute}.
     */
    public static final List<AccessFlag> ForInnerClass = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * Modifiers for {@link method_info}.
     */
    public static final List<AccessFlag> ForMethod = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * Modifiers for {@link MethodParameters_attribute}.
     */
    public static final List<AccessFlag> ForMethodParameters = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * {@link Module_attribute#module_flags} for {@link Module_attribute}.
     */
    public static final List<AccessFlag> ForModule = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * {@link Module_attribute.Exports#exports_flags} for
     * {@link Module_attribute.Exports}.
     */
    public static final List<AccessFlag> ForModuleExports = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * {@link Module_attribute.Opens#opens_flags} for
     * {@link Module_attribute.Opens}.
     */
    public static final List<AccessFlag> ForModuleOpens = Collections.synchronizedList(new ArrayList<AccessFlag>());
    /**
     * {@link Module_attribute.Requires#requires_flags} for
     * {@link Module_attribute.Requires}.
     */
    public static final List<AccessFlag> ForModuleRequires = Collections.synchronizedList(new ArrayList<AccessFlag>());

    static {
        // Access flags for a Class File
        AccessFlag.ForClass.add(ACC_PUBLIC);
        AccessFlag.ForClass.add(ACC_FINAL);
        AccessFlag.ForClass.add(ACC_SUPER);
        AccessFlag.ForClass.add(ACC_INTERFACE);
        AccessFlag.ForClass.add(ACC_ABSTRACT);
        AccessFlag.ForClass.add(ACC_SYNTHETIC);
        AccessFlag.ForClass.add(ACC_ANNOTATION);
        AccessFlag.ForClass.add(ACC_ENUM);
        AccessFlag.ForClass.add(ACC_MODULE);

        // Access flags for a Field
        AccessFlag.ForField.add(ACC_PUBLIC);
        AccessFlag.ForField.add(ACC_PRIVATE);
        AccessFlag.ForField.add(ACC_PROTECTED);
        AccessFlag.ForField.add(ACC_STATIC);
        AccessFlag.ForField.add(ACC_FINAL);
        AccessFlag.ForField.add(ACC_VOLATILE);
        AccessFlag.ForField.add(ACC_TRANSIENT);
        AccessFlag.ForField.add(ACC_SYNTHETIC);
        AccessFlag.ForField.add(ACC_ENUM);

        // Access flags for a Method
        AccessFlag.ForMethod.add(ACC_PUBLIC);
        AccessFlag.ForMethod.add(ACC_PRIVATE);
        AccessFlag.ForMethod.add(ACC_PROTECTED);
        AccessFlag.ForMethod.add(ACC_STATIC);
        AccessFlag.ForMethod.add(ACC_FINAL);
        AccessFlag.ForMethod.add(ACC_SYNCHRONIZED);
        AccessFlag.ForMethod.add(ACC_BRIDGE);
        AccessFlag.ForMethod.add(ACC_VARARGS);
        AccessFlag.ForMethod.add(ACC_NATIVE);
        AccessFlag.ForMethod.add(ACC_ABSTRACT);
        AccessFlag.ForMethod.add(ACC_STRICT);
        AccessFlag.ForMethod.add(ACC_SYNTHETIC);

        // Access flags for an Inner Class
        AccessFlag.ForInnerClass.add(ACC_PUBLIC);
        AccessFlag.ForInnerClass.add(ACC_PRIVATE);
        AccessFlag.ForInnerClass.add(ACC_PROTECTED);
        AccessFlag.ForInnerClass.add(ACC_STATIC);
        AccessFlag.ForInnerClass.add(ACC_FINAL);
        AccessFlag.ForInnerClass.add(ACC_INTERFACE);
        AccessFlag.ForInnerClass.add(ACC_ABSTRACT);
        AccessFlag.ForInnerClass.add(ACC_SYNTHETIC);
        AccessFlag.ForInnerClass.add(ACC_ANNOTATION);
        AccessFlag.ForInnerClass.add(ACC_ENUM);

        // Access flags for an MethodParameters
        AccessFlag.ForMethodParameters.add(ACC_FINAL);
        AccessFlag.ForMethodParameters.add(ACC_SYNTHETIC);
        AccessFlag.ForMethodParameters.add(ACC_MANDATED);

        // Access flags for a Module
        AccessFlag.ForModule.add(ACC_OPEN);
        AccessFlag.ForModule.add(ACC_SYNTHETIC);
        AccessFlag.ForModule.add(ACC_MANDATED);

        // Access flags for a Module.Exports
        AccessFlag.ForModuleExports.add(ACC_SYNTHETIC);
        AccessFlag.ForModuleExports.add(ACC_MANDATED);

        // Access flags for a Module.Opens
        AccessFlag.ForModuleOpens.add(ACC_SYNTHETIC);
        AccessFlag.ForModuleOpens.add(ACC_MANDATED);

        // Access flags for a Module.Requires
        AccessFlag.ForModuleRequires.add(ACC_TRANSITIVE);
        AccessFlag.ForModuleRequires.add(ACC_STATIC_PHASE);
        AccessFlag.ForModuleRequires.add(ACC_SYNTHETIC);
        AccessFlag.ForModuleRequires.add(ACC_MANDATED);
    }

    /**
     * @param i Value in the Class file
     * @param m Modifier in the java source file
     */
    private AccessFlag(long i, String m) {
        this.value = i;
        this.modifier = m;
    }

    /**
     * Get <code>int</code> value of {@link #value}.
     *
     * @return <code>int</code> value of {@link #value}
     */
    public int intValue() {
        return Math.toIntExact(this.value);
    }

    /**
     * Check if the the <code>accFlags</code> matches the access flag or not.
     *
     * @param accFlags the access flags value
     * @return <code>true</code> if the access flag matches the
     * <code>accFlags</code>, else <code>false</code>
     */
    public boolean match(long accFlags) {
        return (accFlags & this.value) > 0;
    }

    @Override
    public String toString() {
        return String.format("%s value=%s modifier=%s", name(), BytesTool.getBinaryString(this.value), this.modifier);
    }

    /**
     * Get the modifiers text for a {@link ClassFile}.
     *
     * @param value Value in the Class file
     * @return Modifier text
     */
    public static String getClassModifier(long value) {
        return getModifier(value, AccessFlag.ForClass);
    }

    /**
     * Get the modifiers text for a {@link field_info}.
     *
     * @param value Value in the Class file
     * @return Modifier text
     */
    public static String getFieldModifier(long value) {
        return getModifier(value, AccessFlag.ForField);
    }

    /**
     * Get the modifiers text for a {@link method_info}.
     *
     * @param value Value in the Class file
     * @return Modifier text
     */
    public static String getMethodModifier(long value) {
        return getModifier(value, AccessFlag.ForMethod);
    }

    /**
     * Get the modifiers text for a {@link InnerClasses_attribute}.
     *
     * @param value Value in the Class file
     * @return Modifier text
     */
    public static String getInnerClassModifier(long value) {
        return getModifier(value, AccessFlag.ForInnerClass);
    }

    /**
     * Get the modifiers text for a {@link MethodParameters_attribute}.
     *
     * @param value Value in the Class file
     * @return Modifier text
     */
    public static String getMethodParametersModifier(long value) {
        return getModifier(value, AccessFlag.ForMethodParameters);
    }

    public static String getModifier(long value, List<AccessFlag> list) {
        final List<String> modifiers = new ArrayList<>();
        list.stream().filter(flag -> (flag.match(value))).forEachOrdered(flag ->
            modifiers.add(flag.modifier)
        );

        return String.join(" ", modifiers);
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/ClassFile.java`:

```java
/*
 * ClassFile.java    2:58 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.io.File;
import java.io.IOException;
import javax.swing.JTabbedPane;
import javax.swing.JTextPane;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.Code_attribute;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.constant.CONSTANT_Class_info;
import org.binaryinternals.format.classfile.constant.CONSTANT_Utf8_info;
import org.binaryinternals.format.classfile.constant.cp_info;
import org.binaryinternals.format.classfile.constant.cp_info.ConstantType;

/**
 * Represents a {@code class} file. A {@code class} file structure has the
 * following format:
 *
 * <pre>
 *    ClassFile {
 *        u4 magic;
 *        u2 minor_version;
 *        u2 major_version;
 *        u2 constant_pool_count;
 *        cp_info constant_pool[constant_pool_count-1];
 *        u2 access_flags;
 *        u2 this_class;
 *        u2 super_class;
 *        u2 interfaces_count;
 *        u2 interfaces[interfaces_count];
 *        u2 fields_count;
 *        field_info fields[fields_count];
 *        u2 methods_count;
 *        method_info methods[methods_count];
 *        u2 attributes_count;
 *        attribute_info attributes[attributes_count];
 *    }
 * </pre>
 *
 * The {@code ClassFile} object is constructed from the class byte array.
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html">
 * VM Spec: The ClassFile Structure </a>
 *
 * <pre>
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S116")
public class ClassFile extends FileFormat {

    /**
     * Magic number of {@code class} file.
     */
    public static final int FORMAT_MAGIC_NUMBER = 0xCAFEBABE;

    public final u4 magic;

    //
    // Class file Version
    //
    /**
     * Minor version of a {@code class} file. It is the {@code minor_version} in
     * {@code ClassFile} structure.
     *
     * @see ClassFile#getVersion()
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final u2 minor_version;

    /**
     * Major version of a {@code class} file. It is the {@code major_version} in
     * {@code ClassFile} structure.
     *
     * <pre>
     * The Java virtual machine implementation of Sun's JDK release 1.0.2 supports
     * class file format versions 45.0 through 45.3 inclusive. Sun's JDK releases
     * 1.1.X can support class file formats of versions in the range 45.0 through
     * 45.65535 inclusive. Implementations of version 1.2 of the Java 2 platform
     * can support class file formats of versions in the range 45.0 through 46.0
     * inclusive.
     * </pre>
     *
     * @see ClassFile#getVersion()
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final u2 major_version;

    //
    // Constant pool
    //
    /**
     * Constant Pool Count of a {@code class} or {@code interface}. It is the
     * {@code constant_pool_count} in {@code ClassFile} structure.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final u2 constant_pool_count;
    public final cp_info[] constant_pool;

    //
    // Class Declaration
    //
    /**
     * A mask of flags used to denote access permissions to and properties of
     * this class or interface.
     *
     * @see AccessFlag#ACC_PUBLIC
     * @see AccessFlag#ACC_FINAL
     * @see AccessFlag#ACC_SUPER
     * @see AccessFlag#ACC_INTERFACE
     * @see AccessFlag#ACC_ABSTRACT
     * @see AccessFlag#ACC_SYNTHETIC
     * @see AccessFlag#ACC_ANNOTATION
     * @see AccessFlag#ACC_ENUM
     * @see AccessFlag#ACC_MODULE
     */
    public final U2ClassComponent access_flags;

    /**
     * {@code This} class of a {@code class} or {@code interface}. It is the
     * {@code this_class} in {@code ClassFile} structure.
     *
     * @see ClassFile#getThisClassName()
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent this_class;

    /**
     * Super class of a {@code class} or {@code interface}. It is the
     * {@code super_class} in {@code ClassFile} structure.
     *
     * @see ClassFile#getSuperClassName()
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent super_class;

    /**
     * Interfaces count of a {@code class} or {@code interface}. It is the
     * {@code interfaces_count} in {@code ClassFile} structure.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent interfaces_count;
    public final U2ClassComponent[] interfaces;

    //
    // Field
    //
    /**
     * Fields Count of a {@code class} or {@code interface}. It is the
     * {@code fields_count} in {@code ClassFile} structure.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent fields_count;
    public final field_info[] fields;

    //
    // Method
    //
    /**
     * Methods Count of a {@code class} or {@code interface}. It is the
     * {@code methods_count} in {@code ClassFile} structure.
     *
     * @see ClassFile#methods_count
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent methods_count;
    public final method_info[] methods;

    //
    // Attribute
    //
    /**
     * Attributes count of a {@code class} or {@code interface}. It is the
     * {@code attributes_count} in {@code ClassFile} structure.
     *
     * @see ClassFile#attributes_count
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">
     * VM Spec: The ClassFile Structure
     * </a>
     */
    public final U2ClassComponent attributes_count;
    public final attribute_info[] attributes;

    /**
     * Creates a new instance of ClassFile from byte array.
     *
     * @param classFile Java class file
     * @throws IOException Error happened when reading the byte array
     * @throws FileFormatException Invalid class file format
     */
    public ClassFile(final File classFile) throws IOException, FileFormatException {
        this(BytesTool.readFileAsBytes(classFile), classFile.getName(), classFile.getCanonicalPath());
    }

    public ClassFile(final byte[] classFileBytes) throws IOException, FileFormatException {
        this(classFileBytes, null, null);
    }

    // java:S127 - "for" loop stop conditions should be invariant --- No we need it because Long/Double type occupies two Constant Pool index
    // java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
    @SuppressWarnings({"java:S127", "java:S3776"})
    public ClassFile(final byte[] classFileBytes, final String fileName, final String filePath) throws IOException, FileFormatException {
        super(classFileBytes, fileName, filePath);

        //
        // Parse the Classfile byte by byte
        //
        PosDataInputStream posDataInputStream = new PosDataInputStream(new PosByteArrayInputStream(super.fileByteArray));

        // magic number
        this.magic = new u4(posDataInputStream);
        if (this.magic.value != ClassFile.FORMAT_MAGIC_NUMBER) {
            throw new FileFormatException("The magic number of the byte array is not 0xCAFEBABE");
        }

        // Classfile version
        this.minor_version = new u2(posDataInputStream);
        this.major_version = new u2(posDataInputStream);

        // Constant Pool
        this.constant_pool_count = new u2(posDataInputStream);
        this.constant_pool = new cp_info[this.constant_pool_count.value];
        for (int i = 1; i < this.constant_pool_count.value; i++) {
            short tag = (short) posDataInputStream.readUnsignedByte();

            this.constant_pool[i] = ConstantType.parse(tag, posDataInputStream);
            if (tag == cp_info.ConstantType.CONSTANT_Long.tag || tag == cp_info.ConstantType.CONSTANT_Double.tag) {
                // Long/Double type occupies two Constant Pool index
                i++;
            }
        }

        // Class Declaration
        this.access_flags = new U2ClassComponent(posDataInputStream);
        this.this_class = new U2ClassComponent(posDataInputStream);
        this.super_class = new U2ClassComponent(posDataInputStream);
        this.interfaces_count = new U2ClassComponent(posDataInputStream);
        if (this.interfaces_count.getValue() > 0) {
            this.interfaces = new U2ClassComponent[this.interfaces_count.getValue()];
            for (int i = 0; i < this.interfaces_count.getValue(); i++) {
                this.interfaces[i] = new U2ClassComponent(posDataInputStream);
            }
        } else {
            this.interfaces = null;
        }

        // Fields
        this.fields_count = new U2ClassComponent(posDataInputStream);
        final int fieldCount = this.fields_count.getValue();
        if (fieldCount > 0) {
            this.fields = new field_info[fieldCount];
            for (int i = 0; i < fieldCount; i++) {
                this.fields[i] = new field_info(posDataInputStream, this.constant_pool);
            }
        } else {
            this.fields = null;
        }

        // Methods
        this.methods_count = new U2ClassComponent(posDataInputStream);
        final int methodCount = this.methods_count.getValue();

        if (methodCount > 0) {
            this.methods = new method_info[methodCount];
            for (int i = 0; i < methodCount; i++) {
                this.methods[i] = new method_info(posDataInputStream, this.constant_pool);
            }
        } else {
            this.methods = null;
        }

        // Attributes
        this.attributes_count = new U2ClassComponent(posDataInputStream);
        final int attributeCount = this.attributes_count.getValue();
        if (attributeCount > 0) {
            this.attributes = new attribute_info[attributeCount];
            for (int i = 0; i < attributeCount; i++) {
                this.attributes[i] = attribute_info.parse(posDataInputStream, this.constant_pool);
            }
        } else {
            this.attributes = null;
        }
    }

    /**
     * Get the text of {@link #this_class}, which is the class name.
     *
     * @return Corresponding text of {@link #this_class}
     * @throws FileFormatException Invalid {@link #constant_pool} item found
     */
    public String getThisClassName() throws FileFormatException {
        return this.getConstantClassInfoName(this.this_class.getValue());
    }

    /**
     * Generate the modifier of a {@code class} or {@code interface} from the
     * access flag value.
     *
     * @return A string for modifier
     */
    public String getModifiers() {
        return AccessFlag.getClassModifier(this.access_flags.value.value);
    }

    /**
     * Get the text of {@link #super_class}, which is the super class name.
     *
     * @return Corresponding text of {@link #super_class}
     * @throws FileFormatException Invalid {@link #constant_pool} item found
     */
    public String getSuperClassName() throws FileFormatException {
        int superClass = this.super_class.getValue();
        if (superClass == 0) {
            // java.lang.Object.class OR module-info.class
            return "";
        } else {
            return this.getConstantClassInfoName(superClass);
        }
    }

    /**
     * Get <code>CONSTANT_Class_info</code> name from the
     * {@link #constant_pool}.
     *
     * @param cpIndex {@link #constant_pool} item index
     * @return Get <code>CONSTANT_Class_info</code> name at <code>cpIndex</code>
     * @throws FileFormatException Invalid {@link #constant_pool} item found
     */
    public String getConstantClassInfoName(int cpIndex) throws FileFormatException {
        String name = null;
        if ((cpIndex >= 0 && cpIndex < this.constant_pool.length)
                && (this.constant_pool[cpIndex] instanceof CONSTANT_Class_info)) {
            CONSTANT_Class_info clsInfo = (CONSTANT_Class_info) this.constant_pool[cpIndex];
            name = getConstantUtf8Value(clsInfo.name_index.value, this.constant_pool);
        } else {
            throw new FileFormatException(String.format("Constant Pool index (value = %d) is out of range, or it is not a CONSTANT_Class_info. ", cpIndex));
        }

        return name;
    }

    /**
     * Get <code>CONSTANT_Utf8_info</code> text from the
     * {@link #constant_pool}..
     *
     * @param cpIndex Constant Pool object Index for
     * <code>CONSTANT_Utf8_info</code>
     * @param cpInfo Constant pool items
     * @return The UTF-8 text
     * @throws FileFormatException Invalid class file format
     */
    public static String getConstantUtf8Value(final int cpIndex, final cp_info[] cpInfo) throws FileFormatException {
        String returnValue = null;

        if ((cpIndex == 0) || (cpIndex >= cpInfo.length)) {
            throw new FileFormatException(String.format(
                    "Constant Pool index is out of range. CP index cannot be zero, and should be less than CP count (=%d). CP index = %d.",
                    cpInfo.length,
                    cpIndex));
        }

        if (cpInfo[cpIndex].tag.value == cp_info.ConstantType.CONSTANT_Utf8.tag) {
            final CONSTANT_Utf8_info utf8Info = (CONSTANT_Utf8_info) cpInfo[cpIndex];
            returnValue = utf8Info.getValue();
        } else {
            throw new FileFormatException(String.format("Unexpected constant pool type: Utf8(%d) expected, but it is '%d'.",
                    cp_info.ConstantType.CONSTANT_Utf8.tag,
                    cpInfo[cpIndex].tag.value));
        }

        return returnValue;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Get raw data
    /**
     * Returns a string of the constant pool item at the specified
     * {@code index}.
     *
     * @param index Index in the constant pool
     * @return String of the constant pool item at {@code index}
     */
    public String getCPDescription(final int index) {
        // Invalid index
        if (index >= this.constant_pool_count.value) {
            throw new IllegalArgumentException(String.format("Index is bigger than constant pool size. size=%d, index=%d", this.constant_pool_count.value, index));
        }

        // Special index: empty
        if (index == 0) {
            throw new IllegalArgumentException("Constant Pool Index cannot be zero. index=" + index);
        }

        cp_info cp = this.constant_pool[index];
        if (cp == null) {
            // For Double, Long type, each item take two indexs, so there could be some index contains nothing.
            throw new IllegalArgumentException("Nothing exist at the Constant Pool Index. index=" + index);
        }

        return cp.toString(this.constant_pool);
    }

    /**
     * Get the Java Class file version.
     *
     * @return The Java class file version.
     */
    public FormatVersion getVersion() {
        return FormatVersion.valueOf(this.major_version.value, this.minor_version.value);
    }

    @Override
    public String toString() {
        return "Class contains "
                + this.fields_count.value.value + " field(s) and "
                + this.methods_count.value.value + " method(s)";
    }

    @Override
    public String getContentTabName() {
        return "JVM Class File";
    }

    @Override
    public Icons getIcon() {
        return Icons.Java;
    }

    // Lazy creation of JTreeClassFile
    private JTreeClassFile jtreeAdapter;
    private JTreeClassFile getJTreeAdapter() {
        if (this.jtreeAdapter == null) {
            this.jtreeAdapter = new JTreeClassFile();
        }
        return this.jtreeAdapter;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.getJTreeAdapter().generateTreeNode(parentNode, this);
    }

    @Override
    public void treeSelectionChanged(final JTreeNodeFileComponent tnfc, final JTabbedPane tabs) {
        super.treeSelectionChanged(tnfc, tabs);

        if (Code_attribute.ATTRIBUTE_CODE_TEXT.equals(tnfc.getText())) {
            final byte[] data = this.getFileByteArray(tnfc.getStartPos(), tnfc.getLength());
            StringBuilder sb = this.getJTreeAdapter().generateOpcodeParseResult(data);
            JTextPane pane = super.tabAddTextPane(tabs, "Opcode");
            pane.setText(sb.toString());
        } else if (tnfc.getText().startsWith(GenerateTreeNodeClassFile.TEXT_CP_PREFIX)) {
            JTextPane pane = super.tabAddTextPane(tabs, "Constant Pool");
            pane.setText(this.getJTreeAdapter().generateReport2CP().toString());
        } else if (tnfc.getText().startsWith(GenerateTreeNodeClassFile.TEXT_FIELDS_PREFIX)) {
            JTextPane pane = super.tabAddTextPane(tabs, "Fields");
            pane.setText(this.getJTreeAdapter().generateReport2Fields().toString());
        } else if (tnfc.getText().startsWith(GenerateTreeNodeClassFile.TEXT_METHODS_PERFIX)) {
            JTextPane pane = super.tabAddTextPane(tabs, "Methods");
            pane.setText(this.getJTreeAdapter().generateReport2Methods().toString());
        }
    }

    /**
     * Class file Format Version numbers. Together, a major and a minor version
     * number determine the version of the class file format. If a class file
     * has major version number M and minor version number m, we denote the
     * version of its class file format as M.m.
     *
     * @author Amos Shi
     */
    public enum FormatVersion {

        /**
         * For 45.3, it could be both {@link JavaSEVersion#VERSION_1_1} or
         * {@link JavaSEVersion#VERSION_1_0_2}. We simply use the
         * {@link JavaSEVersion#VERSION_1_1} which is the newer one.
         */
        FORMAT_45_3(45, 3, JavaSEVersion.VERSION_1_1),
        FORMAT_46(46, 0, JavaSEVersion.VERSION_1_2),
        FORMAT_47(47, 0, JavaSEVersion.VERSION_1_3),
        FORMAT_48(48, 0, JavaSEVersion.VERSION_1_4),
        FORMAT_49(49, 0, JavaSEVersion.VERSION_5_0),
        FORMAT_50(50, 0, JavaSEVersion.VERSION_6),
        FORMAT_51(51, 0, JavaSEVersion.VERSION_7),
        FORMAT_52(52, 0, JavaSEVersion.VERSION_8),
        FORMAT_53(53, 0, JavaSEVersion.VERSION_9),
        FORMAT_54(54, 0, JavaSEVersion.VERSION_10),
        FORMAT_55(55, 0, JavaSEVersion.VERSION_11),
        FORMAT_56(56, 0, JavaSEVersion.VERSION_12),
        FORMAT_57(57, 0, JavaSEVersion.VERSION_13),
        FORMAT_58(58, 0, JavaSEVersion.VERSION_14),
        FORMAT_59(59, 0, JavaSEVersion.VERSION_15),
        FORMAT_60(60, 0, JavaSEVersion.VERSION_16),
        FORMAT_61(61, 0, JavaSEVersion.VERSION_17);

        public final int major_version;
        public final int minor_version;
        public final JavaSEVersion java_se;

        private FormatVersion(int major, int minor, JavaSEVersion javaSE) {
            this.major_version = major;
            this.minor_version = minor;
            this.java_se = javaSE;
        }

        public static FormatVersion valueOf(int major, int minor) {
            for (FormatVersion v : FormatVersion.values()) {
                if (v.major_version == major && v.minor_version == minor) {
                    return v;
                }
            }

            throw new IllegalArgumentException("The provided version number is not recognized");
        }

        /**
         * Get the class file version as a string.
         *
         * @return Version as String.
         */
        public String getVersion() {
            return String.format("%d.%d", this.major_version, this.minor_version);
        }
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/GenerateTreeNodeClassFile.java`:

```java
/*
 * GenerateTreeNodeClassFile.java    September 07, 2019, 21:22
 *
 * Copyright 2019, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.classfile;

import java.util.Locale;
import java.util.ResourceBundle;
import org.binaryinternals.commonlib.ui.GenerateTreeNodeFileFormat;

/**
 * Interface for generating tree node for {@link ClassFile}.
 *
 * @author Amos Shi
 */
public interface GenerateTreeNodeClassFile extends GenerateTreeNodeFileFormat {
    static final String FIELD_ACCESS_FLAGS = "access_flags";
    static final String FIELD_ATTRS = "attributes [%d]";
    static final String FIELD_ATTR_COUNT = "attributes_count";

    static final String TEXT_CPINDEX_PUREVALUE = "constant pool index = %d, %s";
    static final String TEXT_CPINDEX_VALUE = "constant pool index = %d, %s = %s";
    static final String TEXT_CP_PREFIX = "constant_pool[";
    static final String TEXT_FIELDS_PREFIX = "fields[";
    static final String TEXT_METHODS_PERFIX = "methods[";

    static final ResourceBundle MESSAGES = ResourceBundle.getBundle(GenerateTreeNodeClassFile.class.getPackageName() + ".MessagesBundle", Locale.ROOT);

    @Override
    default ResourceBundle getMessages() {
        return MESSAGES;
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/JTreeClassFile.java`:

```java
/*
 * JTreeClassFile.java    August 7, 2007, 4:23 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.HTMLKit;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.constant.cp_info;

/**
 * A tree for {@link ClassFile} displaying all components in the class file.
 *
 * @author Amos Shi
 * @see ClassFile
 */
public class JTreeClassFile implements GenerateTreeNodeClassFile {

    private static final String HTML_LI = "<li>%s</li>";
    private static final String HTML_OL_BEGIN = "<ol>";
    private static final String HTML_OL_END = "</ol>";

    private ClassFile classFile;
    private DefaultMutableTreeNode root;

    /**
     * Creates a tree for {@link ClassFile}.
     */
    JTreeClassFile() {
    }

    @Override
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "We need it")
    public void generateTreeNode(DefaultMutableTreeNode rootNode, FileFormat fileFormat) {
        this.classFile = (ClassFile) fileFormat;
        this.root = rootNode;

        this.addNode(this.root,
                0,
                u4.LENGTH,
                "magic",
                Integer.toHexString(ClassFile.FORMAT_MAGIC_NUMBER).toUpperCase(),
                "msg_magic",
                Icons.Magic
        );
        this.generateTreeNodeClsssFileVersion();
        this.generateConstantPool();
        this.generateClassDeclaration();
        this.generateFields();
        this.generateMethods();
        this.generateAttributes();
    }

    private void generateTreeNodeClsssFileVersion() {
        int floatPos = 4;

        this.addNode(this.root,
                floatPos,
                u2.LENGTH,
                "minor_version",
                this.classFile.minor_version.value,
                "msg_version",
                Icons.Versions
        );
        floatPos += u2.LENGTH;

        this.addNode(this.root,
                floatPos,
                u2.LENGTH,
                "major_version",
                this.classFile.major_version.value,
                "msg_version",
                Icons.Versions
        );
    }

    private void generateConstantPool() {
        // MAGIC(4) + Minor Version + Major Version
        int startPos = 4 + u2.LENGTH + u2.LENGTH;

        final int cpCount = this.classFile.constant_pool_count.value;
        this.addNode(this.root,
                startPos,
                u2.LENGTH,
                "constant_pool_count", 
                cpCount,
                "msg_constant_pool_count",
                Icons.Counter
        );
        startPos += u2.LENGTH;

        final cp_info[] cp = this.classFile.constant_pool;
        final DefaultMutableTreeNode constantPool = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                cp[cpCount - 1].getStartPos() + cp[cpCount - 1].getLength() - startPos,
                TEXT_CP_PREFIX + cpCount + "]",
                MESSAGES.getString("msg_constant_pool_table")
        ));
        this.root.add(constantPool);

        // JVM Spec: The constant_pool table is indexed from 1 to constant_pool_count - 1. 
        for (int i = 1; i < cpCount; i++) {
            if (cp[i] != null) {
                DefaultMutableTreeNode cpInfoNode = this.addNode(constantPool,
                        cp[i].getStartPos(), cp[i].getLength(),
                        String.valueOf(i), cp[i].getName(),
                        cp[i].getMessageKey(), Icons.Constant
                );
                this.addNode(cpInfoNode,
                        cp[i].getStartPos(), 1,
                        "tag", cp[i].tag.value,
                        "msg_cp_tag", Icons.Tag);
                cp[i].generateTreeNode(cpInfoNode, this.classFile);
            } else {
                this.addNode(constantPool,
                        0, 0,
                        String.valueOf(i), "[Empty Item]",
                        "msg_cp_empty", Icons.Empty);
            }
        }
    }

    private void generateClassDeclaration() {
        this.addNode(this.root,
                this.classFile.access_flags.getStartPos(),
                this.classFile.access_flags.getLength(),
                FIELD_ACCESS_FLAGS,
                BytesTool.getBinaryString(this.classFile.access_flags.value.value) + " " + this.classFile.getModifiers(),
                "msg_access_flags",
                Icons.AccessFlag
        );

        final int thisClassCpIndex = this.classFile.this_class.getValue();
        this.addNode(this.root,
                this.classFile.this_class.getStartPos(),
                this.classFile.this_class.getLength(),
                "this_class",
                String.format(TEXT_CPINDEX_VALUE, thisClassCpIndex, "name", this.classFile.getCPDescription(thisClassCpIndex)),
                "msg_this_class",
                Icons.Name
        );

        final int superClassCpIndex = this.classFile.super_class.getValue();
        final StringBuilder sb = new StringBuilder();
        sb.append("constant pool index = ").append(superClassCpIndex);
        // Note. for module-info.class, it do NOT have super class.
        if (superClassCpIndex > 0) {
            sb.append(" ").append(this.classFile.getCPDescription(superClassCpIndex));
        }
        this.addNode(this.root,
                this.classFile.super_class.getStartPos(),
                this.classFile.super_class.getLength(),
                "super_class", sb,
                "msg_super_class", Icons.Name
        );

        final int interfaceCount = this.classFile.interfaces_count.getValue();
        this.addNode(this.root, 
                this.classFile.interfaces_count.getStartPos(),
                this.classFile.interfaces_count.getLength(),
                "interfaces_count", interfaceCount,
                "msg_interfaces_count", Icons.Counter);

        if (interfaceCount > 0) {
            final U2ClassComponent[] interfaces = this.classFile.interfaces;

            final DefaultMutableTreeNode interfacesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    interfaces[0].getStartPos(),
                    interfaces[interfaceCount - 1].getStartPos() + interfaces[interfaceCount - 1].getLength() - interfaces[0].getStartPos(),
                    "interfaces[" + interfaceCount + "]",
                    MESSAGES.getString("msg_interfaces_table")
            ));
            this.root.add(interfacesNode);

            for (int i = 0; i < interfaceCount; i++) {
                this.addNode(interfacesNode,
                        interfaces[i].getStartPos(),
                        interfaces[i].getLength(),
                        String.format("interface %d", i + 1),
                        String.format(TEXT_CPINDEX_VALUE, interfaces[i].getValue(), "name", this.classFile.getCPDescription(interfaces[i].getValue())),
                        "msg_interfaces_item", Icons.Name);
            }
        }
    }

    private void generateFields() {
        final int fieldCount = this.classFile.fields_count.getValue();
        this.addNode(this.root,
                this.classFile.fields_count.getStartPos(),
                this.classFile.fields_count.getLength(),
                "fields_count",
                fieldCount,
                "msg_fields_count", Icons.Counter);

        if (fieldCount > 0) {
            final field_info[] fields = this.classFile.fields;
            final DefaultMutableTreeNode fieldsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    fields[0].getStartPos(),
                    fields[fieldCount - 1].getStartPos() + fields[fieldCount - 1].getLength() - fields[0].getStartPos(),
                    TEXT_FIELDS_PREFIX + fieldCount + "]",
                    MESSAGES.getString("msg_fields_table")
            ));
            this.root.add(fieldsNode);

            DefaultMutableTreeNode fieldNode;
            for (int i = 0; i < fieldCount; i++) {
                fieldNode = this.addNode(fieldsNode,
                        fields[i].getStartPos(),
                        fields[i].getLength(),
                        String.format("field %d", i + 1),
                        fields[i].getDeclaration(),
                        "msg_field_info",
                        Icons.Field
                );
                fields[i].generateTreeNode(fieldNode, classFile);
            }
        }
    }

    private void generateMethods() {
        final int methodCount = this.classFile.methods_count.getValue();
        this.addNode(this.root,
                this.classFile.methods_count.getStartPos(),
                this.classFile.methods_count.getLength(),
                "methods_count",
                methodCount,
                "msg_methods_count",
                Icons.Counter);

        if (methodCount > 0) {
            final method_info[] methods = this.classFile.methods;
            final DefaultMutableTreeNode methodsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    methods[0].getStartPos(),
                    methods[methodCount - 1].getStartPos() + methods[methodCount - 1].getLength() - methods[0].getStartPos(),
                    TEXT_METHODS_PERFIX + methodCount + "]",
                    MESSAGES.getString("msg_methods_table")
            ));
            this.root.add(methodsNode);

            for (int i = 0; i < methodCount; i++) {
                DefaultMutableTreeNode methodNode = this.addNode(methodsNode,
                        methods[i].getStartPos(),
                        methods[i].getLength(),
                        String.format("method %,d", i + 1),
                        methods[i].getDeclaration(),
                        "msg_method_info",
                        Icons.Method
                );
                methods[i].generateTreeNode(methodNode, classFile);
            }
        }
    }

    private void generateAttributes() {
        final int attrCount = this.classFile.attributes_count.getValue();

        this.addNode(this.root,
                this.classFile.attributes_count.getStartPos(),
                this.classFile.attributes_count.getLength(),
                FIELD_ATTR_COUNT,
                attrCount,
                "msg_attributes_count",
                Icons.Counter
        );

        if (attrCount > 0) {
            final attribute_info[] attrs = this.classFile.attributes;
            final DefaultMutableTreeNode attrsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    attrs[0].getStartPos(),
                    attrs[attrCount - 1].getStartPos() + attrs[attrCount - 1].getLength() - attrs[0].getStartPos(),
                    String.format(FIELD_ATTRS, attrCount),
                    MESSAGES.getString("msg_attributes_table")
            ));
            this.root.add(attrsNode);

            DefaultMutableTreeNode attrNode;
            for (int i = 0; i < attrCount; i++) {
                attribute_info attr = attrs[i];
                attrNode = this.addNode(attrsNode,
                        attr.getStartPos(),
                        attr.getLength(),
                        String.valueOf(i + 1),
                        attr.getName(),
                        attr.getMessageKey(),
                        Icons.Annotations
                );
                attr.generateTreeNodeCommon(attrNode, this.classFile);
            }
        }
    }

    StringBuilder generateOpcodeParseResult(byte[] opcodeData) {
        StringBuilder sb = new StringBuilder(1024);
        sb.append(HTMLKit.START);

        int cpindexCounter = 0;

        // The Extracted Code
        sb.append("<pre>");
        sb.append(BytesTool.getByteDataHexView(opcodeData));
        sb.append('\n');
        List<Opcode.InstructionParsed> codeResult = Opcode.parseCode(opcodeData);
        for (Opcode.InstructionParsed iResult : codeResult) {
            sb.append(iResult.toString(this.classFile));
            sb.append('\n');
            if (iResult.getCpindex() != null) {
                cpindexCounter++;
            }
        }
        sb.append("</pre>");

        // The Reference Object
        if (cpindexCounter > 0) {
            sb.append(HTML_OL_BEGIN);
            codeResult.stream().filter(iResult -> (iResult.getCpindex() != null)).forEachOrdered(
                    (Opcode.InstructionParsed iResult) -> sb.append(String.format(HTML_LI, HTMLKit.escapeFilter(
                            this.classFile.getCPDescription(iResult.getCpindex()))))
            );
            sb.append(HTML_OL_END);
        }

        sb.append(HTMLKit.END);
        return sb;
    }

    StringBuilder generateReport2CP() {
        StringBuilder sb = new StringBuilder(1024);
        sb.append(HTMLKit.START);

        int count;

        // Constant Pool
        count = this.classFile.constant_pool_count.value;
        sb.append(String.format("Constant Pool Count: %d", count));
        sb.append(HTMLKit.NEW_LINE);
        if (count > 0) {
            cp_info[] cpInfoList = this.classFile.constant_pool;

            // Constant Pool - by Type
            sb.append("Constant Pool - Class");
            this.generateReport4CPType(sb, cpInfoList, count, cp_info.ConstantType.CONSTANT_Class.tag);
            sb.append("Constant Pool - Field");
            this.generateReport4CPType(sb, cpInfoList, count, cp_info.ConstantType.CONSTANT_Fieldref.tag);
            sb.append("Constant Pool - Method");
            this.generateReport4CPType(sb, cpInfoList, count, cp_info.ConstantType.CONSTANT_Methodref.tag);

            // Constant Pool Object List
            sb.append("Constant Pool Object List");
            sb.append(HTMLKit.NEW_LINE);
            sb.append(HTML_OL_BEGIN);
            for (cp_info cpItem : this.classFile.constant_pool) {
                String cpitemString = (cpItem == null) ? "(empty)" : cpItem.toString(this.classFile.constant_pool);
                sb.append(String.format(HTML_LI, HTMLKit.escapeFilter(cpitemString)));
            }
            sb.append(HTML_OL_END);
        }

        sb.append(HTMLKit.END);
        return sb;
    }

    private void generateReport4CPType(StringBuilder sb, cp_info[] cpInfoList, int count, short tag) {
        sb.append(HTMLKit.NEW_LINE);
        sb.append("<ul>");
        for (int i = 1; i < count; i++) {
            if (cpInfoList[i] != null && cpInfoList[i].tag.value == tag) {
                sb.append(String.format("<li>%d. %s</li>", i,
                        HTMLKit.escapeFilter(this.classFile.getCPDescription(i))));
            }
        }
        sb.append("</ul>");
    }

    StringBuilder generateReport2Fields() {
        StringBuilder sb = new StringBuilder(1024);
        sb.append(HTMLKit.START);

        // Fields
        int count = this.classFile.fields_count.getValue();
        sb.append(String.format("Field Count: %d", count));
        sb.append(HTMLKit.NEW_LINE);
        if (count > 0) {
            sb.append(HTML_OL_BEGIN);
            for (field_info field : this.classFile.fields) {
                sb.append(String.format(HTML_LI, HTMLKit.escapeFilter(field.getDeclaration())));
            }
            sb.append(HTML_OL_END);
        }
        sb.append(HTMLKit.NEW_LINE);

        sb.append(HTMLKit.END);
        return sb;
    }

    StringBuilder generateReport2Methods() {
        StringBuilder sb = new StringBuilder(1024);
        sb.append(HTMLKit.START);

        // Methods
        int count = this.classFile.methods_count.getValue();
        sb.append(String.format("Method Count: %d", count));
        sb.append(HTMLKit.NEW_LINE);
        if (count > 0) {
            sb.append(HTML_OL_BEGIN);
            for (method_info method : this.classFile.methods) {
                sb.append(String.format(HTML_LI, HTMLKit.escapeFilter(method.getDeclaration())));
            }
            sb.append(HTML_OL_END);
        }
        sb.append(HTMLKit.NEW_LINE);

        sb.append(HTMLKit.END);
        return sb;
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/JavaLangSpec.java`:

```java
/*
 * JavaLangSpec.java    17:18 PM, May 19, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

/**
 * Java Language specification constants.
 *
 * @see <a href="http://docs.oracle.com/javase/specs/index.html">
 * The Java Language Specification
 * </a>
 * @author Amos Shi
 */
public class JavaLangSpec {

    /**
     * 51 character sequences, formed from ASCII characters, are reserved for
     * use as keywords and cannot be used as identifiers.
     *
     * <p>
     * The keywords <code>const</code> and <code>goto</code> are reserved, even
     * though they are not currently used. This may allow a Java compiler to
     * produce better error messages if these C++ keywords incorrectly appear in
     * programs.
     * </p>
     *
     * @see <a
     * href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.9">
     * Keywords
     * </a>
     */
    public enum Keyword {

        // ReservedKeyword

        ABSTRACT("abstract"),
        ASSERT("assert"),
        BOOLEAN("boolean"),
        BREAK("break"),
        BYTE("byte"),
        CASE("case"),
        CATCH("catch"),
        CHAR("char"),
        CLASS("class"),
        CONST("const"),
        CONTINUE("continue"),
        DEFAULT("default"),
        DO("do"),
        DOUBLE("double"),
        ELSE("else"),
        ENUM("enum"),
        EXTENDS("extends"),
        FINAL("final"),
        FINALLY("finally"),
        FLOAT("float"),
        FOR("for"),
        IF("if"),
        GOTO("goto"),
        IMPLEMENTS("implements"),
        IMPORT("import"),
        INSTANCEOF("instanceof"),
        INT("int"),
        INTERFACE("interface"),
        LONG("long"),
        NATIVE("native"),
        NEW("new"),
        PACKAGE("package"),
        PRIVATE("private"),
        PROTECTED("protected"),
        PUBLIC("public"),
        RETURN("return"),
        SHORT("short"),
        STATIC("static"),
        STRICTFP("strictfp"),
        SUPER("super"),
        SWITCH("switch"),
        SYNCHRONIZED("synchronized"),
        THIS("this"),
        THROW("throw"),
        THROWS("throws"),
        TRANSIENT("transient"),
        TRY("try"),
        VOID("void"),
        VOLATILE("volatile"),
        WHILE("while"),
        UNDERSCORE("_");

        public final String text;

        private Keyword(String k) {
            this.text = k;
        }
    }

    /**
     * 17 character sequences, also formed from ASCII characters, may be
     * interpreted as keywords or as other tokens, depending on the context in
     * which they appear.
     *
     * @see <a
     * href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.9">
     * Keywords
     * </a>
     */
    public enum ContextualKeyword {

        EXPORTS("exports"),
        MODULE("module"),
        NON_SEALED("non-sealed"),
        OPEN("open"),
        OPENS("opens"),
        PERMITS("permits"),
        PROVIDES("provides"),
        RECORD("record"),
        REQUIRES("requires"),
        SEALED("sealed"),
        TO("to"),
        TRANSITIVE("transitive"),
        USES("uses"),
        VAR("var"),
        WHEN("when"),
        WITH("with"),
        YIELD("yield");

        public final String keyword;

        private ContextualKeyword(String k) {
            this.keyword = k;
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/JavaSEVersion.java`:

```java
/*
 * JavaSEVersion.java    June 4, 2019
 *
 * Copyright  2019, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.time.LocalDate;
import java.time.Month;

/**
 * Java SE platform version.
 *
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1">The
 * ClassFile Structure</a>
 * @author Amos Shi
 */
public enum JavaSEVersion {

    VERSION_1_0_2("1.0.2", 1, false, LocalDate.of(1996, Month.MAY, 1)),
    VERSION_1_1("1.1", 1, false, LocalDate.of(1997, Month.FEBRUARY, 1)),
    VERSION_1_2("1.2", 1, false, LocalDate.of(1998, Month.DECEMBER, 1)),
    VERSION_1_3("1.3", 1, false, LocalDate.of(2000, Month.MAY, 1)),
    VERSION_1_4("1.4", 1, false, LocalDate.of(2002, Month.FEBRUARY, 1)),
    VERSION_5_0("5.0", 5, false, LocalDate.of(2004, Month.SEPTEMBER, 1)),
    VERSION_6("6", 6, false, LocalDate.of(2006, Month.DECEMBER, 1)),
    VERSION_7("7", 7, false, LocalDate.of(2011, Month.JULY, 1)),
    VERSION_8("8", 8, false, LocalDate.of(2014, Month.MARCH, 1)),
    VERSION_9("9", 9, false, LocalDate.of(2017, Month.SEPTEMBER, 1)),
    VERSION_10("10", 10, false, LocalDate.of(2018, Month.MARCH, 1)),
    VERSION_11("11", 11, true, LocalDate.of(2018, Month.SEPTEMBER, 1)),
    VERSION_12("12", 12, false, LocalDate.of(2019, Month.MARCH, 1)),
    VERSION_13("13", 13, false, LocalDate.of(2019, Month.SEPTEMBER, 1)),
    VERSION_14("14", 14, false, LocalDate.of(2020, Month.MARCH, 1)),
    VERSION_15("15", 15, false, LocalDate.of(2020, Month.SEPTEMBER, 1)),
    VERSION_16("16", 16, false, LocalDate.of(2021, Month.MARCH, 1)),
    VERSION_17("17", 17, true, LocalDate.of(2021, Month.SEPTEMBER, 1)),
    VERSION_18("18", 18, false, LocalDate.of(2022, Month.MARCH, 1)),
    VERSION_19("19", 19, false, LocalDate.of(2022, Month.SEPTEMBER, 1)),
    VERSION_20("20", 20, false, LocalDate.of(2023, Month.MARCH, 1)),
    VERSION_21("21", 21, true, LocalDate.of(2023, Month.SEPTEMBER, 1));
    /**
     * Version name.
     */
    public final String versionName;

    /**
     * Major version number.
     */
    public final int versionNumber;

    /**
     * Released Year and Month.
     */
    public final LocalDate released;

    /**
     * Is Long-Term-Support (LTS) release or not.
     */
    public final boolean isLTS;

    private JavaSEVersion(String name, int versionNumber, boolean lts, LocalDate released) {
        this.versionName = name;
        this.versionNumber = versionNumber;
        this.isLTS = lts;
        this.released = released;
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/Opcode.java`:

```java
/*
 * Opcode.java    September 14, 2007, 10:27 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * Opcode parser to interpret the Java {@code code} byte array into human
 * readable text.
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html">VM
 * Spec: The Java Virtual Machine Instruction Set</a>
 *
 * <pre>
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S116")
public final class Opcode {

    private static final Logger LOG = Logger.getLogger(Opcode.class.getName());

    /**
     * Opcode and non {@link ClassFile#constant_pool} index value. Example:
     * <code>bipush + immediate vlaue</code>,
     * <code>lload + local frame vlaue</code>
     */
    private static final String FORMAT_OPCODE_NUMBER = "%s %d";
    private static final String FORMAT_OPCODE_LOCAL_IINC = "%s index = %d const = %d";
    private static final String FORMAT_OPCODE_STRING = "%s %s";

    private Opcode() {
    }

    /**
     * The Java Virtual Machine Instruction Set.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5">
     * VM Spec: Instructions
     * </a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum Instruction {

        /**
         * Do nothing.
         */
        nop(0),
        /**
         * Push null. Push the null object reference onto the operand stack.
         */
        aconst_null(1),
        /**
         * Push int constant -1.
         *
         * An iconst_m1 instruction is type safe if one can validly push the
         * type int onto the incoming operand stack yielding the outgoing type
         * state.
         *
         * Push the int constant <code>i</code> (-1, 0, 1, 2, 3, 4 or 5) onto
         * the operand stack.
         */
        iconst_m1(2),
        /**
         * Push int constant 0.
         */
        iconst_0(3),
        /**
         * Push int constant 1.
         */
        iconst_1(4),
        /**
         * Push int constant 2.
         */
        iconst_2(5),
        /**
         * Push int constant 3.
         */
        iconst_3(6),
        /**
         * Push int constant 4.
         */
        iconst_4(7),
        /**
         * Push int constant 5.
         */
        iconst_5(8),
        /**
         * Push long constant 0.
         *
         * Push the long constant <code>l</code> (0 or 1) onto the operand
         * stack.
         */
        lconst_0(9),
        /**
         * Push long constant 1.
         */
        lconst_1(10),
        /**
         * Push float 0.0.
         *
         * Push the float constant <code>f</code> (0.0, 1.0, or 2.0) onto the
         * operand stack.
         */
        fconst_0(11),
        /**
         * Push float 1.0.
         */
        fconst_1(12),
        /**
         * Push float 2.0.
         */
        fconst_2(13),
        /**
         * Push double 0.0.
         *
         * Push the double constant <code>d</code> (0.0 or 1.0) onto the operand
         * stack.
         */
        dconst_0(14),
        /**
         * Push double 1.0.
         */
        dconst_1(15),
        /**
         * Push the immediate byte value.
         *
         * The immediate byte is sign-extended to an int value. That value is
         * pushed onto the operand stack.
         */
        bipush(16) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.immediateValue = pdis.readUnsignedByte();
                parsed.opCodeText = String.format(FORMAT_OPCODE_NUMBER, this.name(), parsed.immediateValue);
                return parsed;
            }
        },
        /**
         * Push the immediate short value.
         *
         * The immediate unsigned byte1 and byte2 values are assembled into an
         * intermediate short.
         *
         * The intermediate value is then sign-extended to an int value. That
         * value is pushed onto the operand stack.
         */
        sipush(17) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.immediateValue = pdis.readUnsignedShort();
                parsed.opCodeText = String.format(FORMAT_OPCODE_NUMBER, this.name(), parsed.immediateValue);
                return parsed;
            }
        },
        /**
         * Push item from runtime constant pool.
         *
         * The index is an unsigned byte that must be a valid index into the
         * runtime constant pool of the current class.
         */
        ldc(18) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedByte();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Push item from run-time constant pool (wide index).
         *
         * The unsigned indexbyte1 and indexbyte2 are assembled into an unsigned
         * 16-bit index into the run-time constant pool of the current class.
         * The index must be a valid index into the run-time constant pool of
         * the current class.
         */
        ldc_w(19) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Push long or double from runtime constant pool (wide index).
         *
         * The unsigned indexbyte1 and indexbyte2 are assembled into an unsigned
         * 16-bit index into the run-time constant pool of the current class.
         */
        ldc2_w(20) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Load int from local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The local variable at
         * index must contain an int. The value of the local variable at index
         * is pushed onto the operand stack.
         */
        iload(21) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Load long from local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte. Both index and index+1
         * must be indices into the local variable array of the current frame.
         * The local variable at index must contain a long. The value of the
         * local variable at index is pushed onto the operand stack.
         */
        lload(22) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Load float from local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The local variable at
         * index must contain a float. The value of the local variable at index
         * is pushed onto the operand stack.
         */
        fload(23) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Load double from local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte. Both index and index+1
         * must be indices into the local variable array of the current frame.
         * The local variable at index must contain a double. The value of the
         * local variable at index is pushed onto the operand stack.
         */
        dload(24) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Load reference from local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The local variable at
         * index must contain a reference. The objectref in the local variable
         * at index is pushed onto the operand stack.
         */
        aload(25) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Load int from local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The local variable at <code>n</code> must contain
         * an int. The value of the local variable at <code>n</code> is pushed
         * onto the operand stack.
         *
         * @see #iload_1
         * @see #iload_2
         * @see #iload_3
         */
        iload_0(26),
        /**
         * Load int from local variable at index 1.
         *
         * @see #iload_0
         */
        iload_1(27),
        /**
         * Load int from local variable at index 2.
         *
         * @see #iload_0
         */
        iload_2(28),
        /**
         * Load int from local variable at index 3.
         *
         * @see #iload_0
         */
        iload_3(29),
        /**
         * Load long from local variable at index 0.
         *
         * Both <code>n</code> and <code>n+1</code> must be indices into the
         * local variable array of the current frame. The local variable at
         * <code>n</code> must contain a long. The value of the local variable
         * at <code>n</code> is pushed onto the operand stack.
         *
         * @see #lload_1
         * @see #lload_2
         * @see #lload_3
         */
        lload_0(30),
        /**
         * Load long from local variable at index 1.
         *
         * @see #lload_0
         */
        lload_1(31),
        /**
         * Load long from local variable at index 2.
         *
         * @see #lload_0
         */
        lload_2(32),
        /**
         * Load long from local variable at index 3.
         *
         * @see #lload_0
         */
        lload_3(33),
        /**
         * Load float from local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The local variable at <code>n</code> must contain
         * a float. The value of the local variable at <code>n</code> is pushed
         * onto the operand stack.
         *
         * @see #fload_1
         * @see #fload_2
         * @see #fload_3
         */
        fload_0(34),
        /**
         * Load float from local variable at index 1.
         *
         * @see #fload_0
         */
        fload_1(35),
        /**
         * Load float from local variable at index 2.
         *
         * @see #fload_0
         */
        fload_2(36),
        /**
         * Load float from local variable at index 3.
         *
         * @see #fload_0
         */
        fload_3(37),
        /**
         * Load double from local variable at index 0.
         *
         * Both <code>n</code> and <code>n+1</code> must be indices into the
         * local variable array of the current frame. The local variable at
         * <code>n</code> must contain a double. The value of the local variable
         * at <code>n</code> is pushed onto the operand stack.
         *
         * @see #dload_1
         * @see #dload_2
         * @see #dload_3
         */
        dload_0(38),
        /**
         * Load double from local variable at index 1.
         *
         * @see #dload_0
         */
        dload_1(39),
        /**
         * Load double from local variable at index 2.
         *
         * @see #dload_0
         */
        dload_2(40),
        /**
         * Load double from local variable at index 3.
         *
         * @see #dload_0
         */
        dload_3(41),
        /**
         * Load reference from local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The local variable at <code>n</code> must contain
         * a reference. The objectref in the local variable at <code>n</code> is
         * pushed onto the operand stack.
         *
         * @see #aload_1
         * @see #aload_2
         * @see #aload_3
         */
        aload_0(42),
        /**
         * Load reference from local variable at index 1.
         *
         * @see #aload_0
         */
        aload_1(43),
        /**
         * Load reference from local variable at index 2.
         *
         * @see #aload_0
         */
        aload_2(44),
        /**
         * Load reference from local variable at index 3.
         *
         * @see #aload_0
         */
        aload_3(45),
        /**
         * Load int from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type int. The index must be of type int. Both
         * arrayref and index are popped from the operand stack. The int value
         * in the component of the array at index is retrieved and pushed onto
         * the operand stack.
         */
        iaload(46),
        /**
         * Load long from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type long. The index must be of type int.
         * Both arrayref and index are popped from the operand stack. The long
         * value in the component of the array at index is retrieved and pushed
         * onto the operand stack.
         */
        laload(47),
        /**
         * Load float from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type float. The index must be of type int.
         * Both arrayref and index are popped from the operand stack. The float
         * value in the component of the array at index is retrieved and pushed
         * onto the operand stack.
         */
        faload(48),
        /**
         * Load double from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type double. The index must be of type int.
         * Both arrayref and index are popped from the operand stack. The double
         * value in the component of the array at index is retrieved and pushed
         * onto the operand stack.
         */
        daload(49),
        /**
         * Load reference from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type reference. The index must be of type
         * int. Both arrayref and index are popped from the operand stack. The
         * reference value in the component of the array at index is retrieved
         * and pushed onto the operand stack.
         */
        aaload(50),
        /**
         * Load byte or boolean from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type reference. The index must be of type
         * int. Both arrayref and index are popped from the operand stack. The
         * reference value in the component of the array at index is retrieved
         * and pushed onto the operand stack.
         */
        baload(51),
        /**
         * Load char from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type byte or of type boolean. The index must
         * be of type int. Both arrayref and index are popped from the operand
         * stack. The byte value in the component of the array at index is
         * retrieved, sign-extended to an int value, and pushed onto the top of
         * the operand stack.
         */
        caload(52),
        /**
         * Load short from array.
         *
         * The arrayref must be of type reference and must refer to an array
         * whose components are of type short. The index must be of type int.
         * Both arrayref and index are popped from the operand stack. The
         * component of the array at index is retrieved and sign-extended to an
         * int value. That value is pushed onto the operand stack.
         */
        saload(53),
        /**
         * Store int into local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The value on the top
         * of the operand stack must be of type int. It is popped from the
         * operand stack, and the value of the local variable at index is set to
         * value.
         */
        istore(54) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Store long into local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte. Both <code>index</code>
         * and <code>index+1</code> must be indices into the local variable
         * array of the current frame. The value on the top of the operand stack
         * must be of type long. It is popped from the operand stack, and the
         * local variables at <code>index</code> and <code>index+1</code> are
         * set to value.
         */
        lstore(55) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Store float into local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The value on the top
         * of the operand stack must be of type float. It is popped from the
         * operand stack and undergoes value set conversion, resulting in value.
         * The value of the local variable at index is set to value.
         */
        fstore(56) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Store double into local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte. Both <code>index</code>
         * and <code>index+1</code> must be indices into the local variable
         * array of the current frame. The value on the top of the operand stack
         * must be of type double. It is popped from the operand stack and
         * undergoes value set conversion, resulting in value. The local
         * variables at <code>index</code> and <code>index+1</code> are set to
         * value.
         */
        dstore(57) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Store reference into local variable at <code>index</code>.
         *
         * The <code>index</code> is an unsigned byte that must be an index into
         * the local variable array of the current frame. The objectref on the
         * top of the operand stack must be of type returnAddress or of type
         * reference. It is popped from the operand stack, and the value of the
         * local variable at <code>index</code> is set to objectref.
         */
        astore(58) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Store int into local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The value on the top of the operand stack must be
         * of type int. It is popped from the operand stack, and the value of
         * the local variable at <code>n</code> is set to value.
         *
         * @see #istore_1
         * @see #istore_2
         * @see #istore_3
         */
        istore_0(59),
        /**
         * Store int into local variable at index 1.
         *
         * @see #istore_0
         */
        istore_1(60),
        /**
         * Store int into local variable at index 2.
         *
         * @see #istore_0
         */
        istore_2(61),
        /**
         * Store int into local variable at index 3.
         *
         * @see #istore_0
         */
        istore_3(62),
        /**
         * Store long into local variable at index 0.
         *
         * Both <code>n</code> and <code>n+1</code> must be indices into the
         * local variable array of the current frame. The value on the top of
         * the operand stack must be of type long. It is popped from the operand
         * stack, and the local variables at <code>n</code> and <code>n+1</code>
         * are set to value.
         *
         * @see #lstore_1
         * @see #lstore_2
         * @see #lstore_3
         */
        lstore_0(63),
        /**
         * Store long into local variable at index 1.
         *
         * @see #lstore_0
         */
        lstore_1(64),
        /**
         * Store long into local variable at index 2.
         *
         * @see #lstore_0
         */
        lstore_2(65),
        /**
         * Store long into local variable at index 3.
         *
         * @see #lstore_0
         */
        lstore_3(66),
        /**
         * Store float into local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The value on the top of the operand stack must be
         * of type float. It is popped from the operand stack and undergoes
         * value set conversion, resulting in value. The value of the local
         * variable at <code>n</code> is set to value.
         *
         * @see #fstore_1
         * @see #fstore_2
         * @see #fstore_3
         */
        fstore_0(67),
        /**
         * Store float into local variable at index 1.
         *
         * @see #fstore_0
         */
        fstore_1(68),
        /**
         * Store float into local variable at index 2.
         *
         * @see #fstore_0
         */
        fstore_2(69),
        /**
         * Store float into local variable at index 3.
         *
         * @see #fstore_0
         */
        fstore_3(70),
        /**
         * Store double into local variable at index 0.
         *
         * Both <code>n</code> and <code>n+1</code> must be indices into the
         * local variable array of the current frame. The value on the top of
         * the operand stack must be of type double. It is popped from the
         * operand stack and undergoes value set conversion, resulting in value.
         * The local variables at <code>n</code> and <code>n+1</code>are set to
         * value.
         *
         * @see #dstore_1
         * @see #dstore_2
         * @see #dstore_3
         */
        dstore_0(71),
        /**
         * Store double into local variable at index 1.
         *
         * @see #dstore_0
         */
        dstore_1(72),
        /**
         * Store double into local variable at index 2.
         *
         * @see #dstore_0
         */
        dstore_2(73),
        /**
         * Store double into local variable at index 3.
         *
         * @see #dstore_0
         */
        dstore_3(74),
        /**
         * Store reference into local variable at index 0.
         *
         * The <code>n</code> must be an index into the local variable array of
         * the current frame. The objectref on the top of the operand stack must
         * be of type returnAddress or of type reference. It is popped from the
         * operand stack, and the value of the local variable at <code>n</code>
         * is set to objectref.
         *
         * @see #astore_1
         * @see #astore_2
         * @see #astore_3
         */
        astore_0(75),
        /**
         * Store reference into local variable at index 1.
         *
         * @see #astore_0
         */
        astore_1(76),
        /**
         * Store reference into local variable at index 2.
         *
         * @see #astore_0
         */
        astore_2(77),
        /**
         * Store reference into local variable at index 3.
         *
         * @see #astore_0
         */
        astore_3(78),
        /**
         * Store into int array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         *
         * The <code>arrayref</code> must be of type reference and must refer to
         * an array whose components are of type int. Both index and value must
         * be of type int. The <code>arrayref</code>, <code>index</code>, and
         * <code>value</code> are popped from the operand stack. The int value
         * is stored as the component of the array indexed by index.
         */
        iastore(79),
        /**
         * Store into long array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        lastore(80),
        /**
         * Store into float array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        fastore(81),
        /**
         * Store into double array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        dastore(82),
        /**
         * Store into reference array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        aastore(83),
        /**
         * Store into byte or boolean array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        bastore(84),
        /**
         * Store into char array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        castore(85),
        /**
         * Store into short array in current Operand Stack
         * <code>..., arrayref, index, value</code>.
         */
        sastore(86),
        /**
         * Pop the top value from the operand stack.
         */
        pop(87),
        /**
         * Pop the top one or two values from the operand stack.
         */
        pop2(88),
        /**
         * Duplicate the top value on the operand stack and push the duplicated
         * value onto the operand stack.
         */
        dup(89),
        /**
         * Duplicate the top value on the operand stack and insert the
         * duplicated value two values down in the operand stack.
         */
        dup_x1(90),
        /**
         * Duplicate the top value on the operand stack and insert the
         * duplicated value two or three values down in the operand stack.
         */
        dup_x2(91),
        /**
         * Duplicate the top one or two values on the operand stack and push the
         * duplicated value or values back onto the operand stack in the
         * original order.
         */
        dup2(92),
        /**
         * Duplicate the top one or two values on the operand stack and insert
         * the duplicated values, in the original order, one value beneath the
         * original value or values in the operand stack.
         */
        dup2_x1(93),
        /**
         * Duplicate the top one or two values on the operand stack and insert
         * the duplicated values, in the original order, into the operand stack.
         */
        dup2_x2(94),
        /**
         * Swap the top two values on the operand stack.
         */
        swap(95),
        /**
         * Add int in current Operand Stack <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. The int result is value1 + value2. The result
         * is pushed onto the operand stack.
         *
         * @see #ladd
         * @see #fadd
         * @see #dadd
         */
        iadd(96),
        /**
         * Add long in current Operand Stack <code>..., value1, value2</code>.
         *
         * @see #iadd
         */
        ladd(97),
        /**
         * Add float in current Operand Stack <code>..., value1, value2</code>.
         *
         * @see #iadd
         */
        fadd(98),
        /**
         * Add double in current Operand Stack <code>..., value1, value2</code>.
         *
         * @see #iadd
         */
        dadd(99),
        /**
         * Subtract int in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. The int result is value1 - value2. The result
         * is pushed onto the operand stack.
         *
         * @see #lsub
         * @see #fsub
         * @see #dsub
         */
        isub(100),
        /**
         * Subtract long in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type long. The values are popped
         * from the operand stack. The long result is value1 - value2. The
         * result is pushed onto the operand stack.
         *
         * @see #isub
         */
        lsub(101),
        /**
         * Subtract float.
         *
         * @see #isub
         */
        fsub(102),
        /**
         * Subtract double.
         *
         * @see #isub
         */
        dsub(103),
        /**
         * Multiply int in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. The int result is value1 * value2. The result
         * is pushed onto the operand stack.
         *
         * @see #lmul
         * @see #fmul
         * @see #dmul
         */
        imul(104),
        /**
         * Multiply long.
         *
         * @see #imul
         */
        lmul(105),
        /**
         * Multiply float.
         *
         * @see #imul
         */
        fmul(106),
        /**
         * Multiply double.
         *
         * @see #imul
         */
        dmul(107),
        /**
         * Divide int in current Operand Stack <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. The int result is the value of the Java
         * programming language expression value1 / value2. The result is pushed
         * onto the operand stack.
         *
         * @see #ldiv
         * @see #fdiv
         * @see #ddiv
         */
        idiv(108),
        /**
         * Divide long.
         *
         * @see #idiv
         */
        ldiv(109),
        /**
         * Divide float.
         *
         * @see #idiv
         */
        fdiv(110),
        /**
         * Divide double.
         *
         * @see #idiv
         */
        ddiv(111),
        /**
         * Remainder int in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. The int result is
         * <code>value1 - (value1 / value2) * value2</code>. The result is
         * pushed onto the operand stack.
         *
         * @see #lrem
         * @see #frem
         * @see #drem
         */
        irem(112),
        /**
         * Remainder long.
         *
         * @see #irem
         */
        lrem(113),
        /**
         * Remainder float.
         *
         * @see #irem
         */
        frem(114),
        /**
         * Remainder double.
         *
         * @see #irem
         */
        drem(115),
        /**
         * Negate int in current Operand Stack <code>..., value</code>.
         *
         * The value must be of type int. It is popped from the operand stack.
         * The int result is the arithmetic negation of <code>value</code>,
         * <code>-value</code>. The result is pushed onto the operand stack.
         *
         * @see #lneg
         * @see #fneg
         * @see #dneg
         */
        ineg(116),
        /**
         * Negate long.
         *
         * @see #ineg
         */
        lneg(117),
        /**
         * Negate float.
         *
         * @see #ineg
         */
        fneg(118),
        /**
         * Negate double.
         *
         * @see #ineg
         */
        dneg(119),
        /**
         * Shift left int in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. An int result is calculated by shifting
         * value1 left by s bit positions, where s is the value of the low 5
         * bits of value2. The result is pushed onto the operand stack.
         *
         * @see #lshl
         */
        ishl(120),
        /**
         * Shift left long.
         *
         * @see #ishl
         */
        lshl(121),
        /**
         * Arithmetic shift right int, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. An int result is calculated by shifting
         * value1 right by s bit positions, with sign extension, where s is the
         * value of the low 5 bits of value2. The result is pushed onto the
         * operand stack.
         *
         * @see #lshr
         */
        ishr(122),
        /**
         * Arithmetic shift right long.
         *
         * @see #ishr
         */
        lshr(123),
        /**
         * Logical shift right int, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. The values are popped
         * from the operand stack. An int result is calculated by shifting
         * value1 right by s bit positions, with zero extension, where s is the
         * value of the low 5 bits of value2. The result is pushed onto the
         * operand stack.
         *
         * @see #lushr
         */
        iushr(124),
        /**
         * Logical shift right long.
         *
         * @see #iushr
         */
        lushr(125),
        /**
         * Boolean AND int, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. They are popped from the
         * operand stack. An int result is calculated by taking the bitwise AND
         * (conjunction) of value1 and value2. The result is pushed onto the
         * operand stack.
         *
         * @see #land
         */
        iand(126),
        /**
         * Boolean AND long.
         *
         * @see #iand
         */
        land(127),
        /**
         * Boolean OR int, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. They are popped from the
         * operand stack. An int result is calculated by taking the bitwise
         * inclusive OR of value1 and value2. The result is pushed onto the
         * operand stack.
         *
         * @see #lor
         */
        ior(128),
        /**
         * Boolean OR long.
         *
         * @see #ior
         */
        lor(129),
        /**
         * Boolean XOR int, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Both value1 and value2 must be of type int. They are popped from the
         * operand stack. An int result is calculated by taking the bitwise
         * exclusive OR of value1 and value2. The result is pushed onto the
         * operand stack.
         *
         * @see #lxor
         */
        ixor(130),
        /**
         * Boolean XOR long.
         *
         * @see #ixor
         */
        lxor(131),
        /**
         * Increment local variable by constant.
         *
         * The index is an unsigned byte that must be an index into the local
         * variable array of the current frame. The const is an immediate signed
         * byte. The local variable at index must contain an int. The value
         * const is first sign-extended to an int, and then the local variable
         * at index is incremented by that amount.
         */
        iinc(132) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.lvIndex = pdis.readUnsignedByte();
                parsed.immediateValue = Integer.valueOf(pdis.readByte());
                parsed.opCodeText = String.format(FORMAT_OPCODE_LOCAL_IINC, this.name(), parsed.lvIndex, parsed.immediateValue);
                return parsed;
            }
        },
        /**
         * Convert int to long, in current Operand Stack
         * <code>..., value</code>.
         *
         * The value on the top of the operand stack must be of type int. It is
         * popped from the operand stack and sign-extended to a long result.
         * That result is pushed onto the operand stack.
         */
        i2l(133),
        /**
         * Convert int to float.
         *
         * @see #i2l
         */
        i2f(134),
        /**
         * Convert int to double.
         *
         * @see #i2l
         */
        i2d(135),
        /**
         * Convert long to int, in current Operand Stack
         * <code>..., value</code>.
         *
         * The value on the top of the operand stack must be of type long. It is
         * popped from the operand stack and converted to an int result by
         * taking the low-order 32 bits of the long value and discarding the
         * high-order 32 bits. The result is pushed onto the operand stack.
         */
        l2i(136),
        /**
         * Convert long to float, in current Operand Stack
         * <code>..., value</code>.
         *
         * The l2f instruction performs a widening primitive conversion that may
         * lose precision because values of type float have only 24 significand
         * bits.
         */
        l2f(137),
        /**
         * Convert long to double, in current Operand Stack
         * <code>..., value</code>.
         *
         * The value on the top of the operand stack must be of type long. It is
         * popped from the operand stack and converted to a double result using
         * IEEE 754 round to nearest mode. The result is pushed onto the operand
         * stack.
         */
        l2d(138),
        /**
         * Convert float to int, in current Operand Stack
         * <code>..., value</code>.
         */
        f2i(139),
        /**
         * Convert float to long, in current Operand Stack
         * <code>..., value</code>.
         */
        f2l(140),
        /**
         * Convert float to double, in current Operand Stack
         * <code>..., value</code>.
         */
        f2d(141),
        /**
         * Convert double to int, in current Operand Stack
         * <code>..., value</code>.
         */
        d2i(142),
        /**
         * Convert double to long, in current Operand Stack
         * <code>..., value</code>.
         */
        d2l(143),
        /**
         * Convert double to float, in current Operand Stack
         * <code>..., value</code>.
         */
        d2f(144),
        /**
         * Convert int to byte.
         */
        i2b(145),
        /**
         * Convert int to char.
         */
        i2c(146),
        /**
         * Convert int to short.
         */
        i2s(147),
        /**
         * Compare long, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * Compare results are 1, 0, or -1.
         *
         * Both value1 and value2 must be of type long. They are both popped
         * from the operand stack, and a signed integer comparison is performed.
         * If value1 is greater than value2, the int value 1 is pushed onto the
         * operand stack. If value1 is equal to value2, the int value 0 is
         * pushed onto the operand stack. If value1 is less than value2, the int
         * value -1 is pushed onto the operand stack.
         */
        lcmp(148),
        /**
         * Compare float, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * @see #lcmp
         * @see #fcmpg
         */
        fcmpl(149),
        /**
         * Compare float, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * The {@link #fcmpg} and {@link #fcmpl} instructions differ only in
         * their treatment of a comparison involving NaN.
         *
         * @see #lcmp
         * @see #fcmpl
         */
        fcmpg(150),
        /**
         * Compare double, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * @see #lcmp
         * @see #dcmpg
         */
        dcmpl(151),
        /**
         * Compare double, in current Operand Stack
         * <code>..., value1, value2</code>.
         *
         * The {@link #dcmpg} and {@link #dcmpl} instructions differ only in
         * their treatment of a comparison involving NaN.
         *
         * @see #lcmp
         * @see #dcmpl
         */
        dcmpg(152),
        /**
         * Branch if int comparison with zero succeeds.
         *
         * ifeq succeeds if and only if value = 0.
         */
        ifeq(153) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        ifne(154) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        iflt(155) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        ifge(156) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        ifgt(157) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        ifle(158) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmpeq(159) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmpne(160) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmplt(161) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmpge(162) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmpgt(163) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_icmple(164) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_acmpeq(165) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        if_acmpne(166) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        /**
         * Branch always.
         *
         * Note: Add '_' suffix to avoid compile error since 'goto' is a Java
         * keyword, remove the '_' from the name when showing.
         *
         * @see #getName()
         */
        goto_(167) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.branchbyte = Integer.valueOf(pdis.readShort());
                parsed.opCodeText = this.getName();
                return parsed;
            }
        },
        /**
         * Jump subroutine.
         */
        jsr(168) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseBranchbyteShort(curPos, pdis);
            }
        },
        /**
         * Return from subroutine.
         *
         * The index is an unsigned byte between 0 and 255, inclusive. The local
         * variable at index in the current frame must contain a value of type
         * returnAddress. The contents of the local variable are written into
         * the Java Virtual Machine's pc register, and execution continues
         * there.
         */
        ret(169) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseLvindexUnsignedByte(curPos, pdis);
            }
        },
        /**
         * Access jump table by index and jump.
         */
        tableswitch(170) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                // 0-3 byte pad, when needed
                super.skipPad(pdis);

                InstructionParsed parsed = new InstructionParsed(curPos, this.code);

                parsed.tableSwitch = new tableswitch(pdis.readInt(), pdis.readInt(), pdis.readInt());
                for (int i = parsed.tableSwitch.lowbyte; i <= parsed.tableSwitch.highbyte; i++) {
                    parsed.tableSwitch.jumpoffsets.put(i, pdis.readInt());
                }

                parsed.opCodeText = String.format(FORMAT_OPCODE_STRING, this.name(), parsed.tableSwitch.toString(curPos));
                return parsed;
            }
        },
        /**
         * Access jump table by key match and jump.
         */
        lookupswitch(171) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                // 0-3 byte pad, when needed
                super.skipPad(pdis);

                InstructionParsed parsed = new InstructionParsed(curPos, this.code);

                parsed.lookupSwitch = new lookupswitch(pdis.readInt(), pdis.readInt());
                for (int i = 0; i < parsed.lookupSwitch.npairs; i++) {
                    parsed.lookupSwitch.mapoffsets.put(pdis.readInt(), pdis.readInt());
                }

                parsed.opCodeText = String.format(FORMAT_OPCODE_STRING, this.name(), parsed.lookupSwitch.toString(curPos));
                return parsed;
            }
        },
        /**
         * Return int from method.
         *
         * The current method must have return type boolean, byte, char, short,
         * or int. The value must be of type int.
         *
         * If the current method is a synchronized method, the monitor entered
         * or reentered on invocation of the method is updated and possibly
         * exited as if by execution of a {@link #monitorexit} instruction in
         * the current thread.
         */
        ireturn(172),
        /**
         * Return long from method.
         *
         * The current method must have return type long. The value must be of
         * type long.
         *
         * @see #ireturn
         */
        lreturn(173),
        /**
         * Return float from method.
         *
         * The current method must have return type float. The value must be of
         * type float.
         *
         * @see #ireturn
         */
        freturn(174),
        /**
         * Return double from method.
         *
         * The current method must have return type double. The value must be of
         * type double.
         *
         * @see #ireturn
         */
        dreturn(175),
        /**
         * Return reference from method.
         *
         * The objectref must be of type reference and must refer to an object
         * of a type that is assignment compatible with the type represented by
         * the return descriptor of the current method.
         *
         * @see #ireturn
         * @see method_info#getDeclaration()
         */
        areturn(176),
        /**
         * Return void from method.
         *
         * The current method must have return type void.
         *
         * Note: Add '_' suffix to avoid compile error since 'return' is a Java
         * keyword, remove the '_' from the name when showing.
         *
         * @see #ireturn
         * @see #getName()
         */
        return_(177) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.opCodeText = this.getName();
                return parsed;
            }
        },
        /**
         * Get static field from class.
         *
         * The value of the class or interface field is fetched and pushed onto
         * the operand stack.
         */
        getstatic(178) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Set static field in class.
         *
         * On successful resolution of the field, the class or interface that
         * declared the resolved field is initialized if that class or interface
         * has not already been initialized.
         */
        putstatic(179) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Fetch field from object.
         */
        getfield(180) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Set field in object.
         */
        putfield(181) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Invoke instance method; dispatch based on class.
         */
        invokevirtual(182) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Invoke instance method; direct invocation of instance initialization
         * methods and methods of the current class and its super types.
         */
        invokespecial(183) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Invoke a class (static) method.
         */
        invokestatic(184) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Invoke interface method.
         */
        invokeinterface(185) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                parsed.nArgs = pdis.readUnsignedByte();
                BytesTool.skip(pdis, 1);

                parsed.opCodeText = String.format("%s interface=%d, nargs=%d", this.name(), parsed.cpIndex, parsed.nArgs);
                return parsed;
            }
        },
        /**
         * Invoke a dynamically-computed call site.
         */
        invokedynamic(186) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();

                // Skip 2 zero bytes
                BytesTool.skip(pdis, 2);
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Create new object.
         *
         * Note: Add '_' suffix to avoid compile error since 'new' is a Java
         * keyword, remove the '_' from the name when showing.
         *
         * @see #getName()
         */
        new_(187) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                parsed.opCodeText = this.getName();
                return parsed;
            }
        },
        /**
         * Create new array.
         *
         * The atype is a code that indicates the type of array to create. It
         * must take one of the following values in {@link NewarrayType}.
         *
         */
        newarray(188) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.arrayType = pdis.readUnsignedByte();
                parsed.opCodeText = String.format(FORMAT_OPCODE_STRING, Opcode.Instruction.newarray.name(), NewarrayType.valueOf(parsed.arrayType).name());
                return parsed;
            }
        },
        /**
         * Create new array of reference.
         *
         * The {@link #anewarray} instruction is used to create a single
         * dimension of an array of object references or part of a
         * multidimensional array.
         */
        anewarray(189) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Get length of array.
         */
        arraylength(190),
        /**
         * Throw exception or error.
         */
        athrow(191),
        /**
         * Check whether object is of given type.
         */
        checkcast(192) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                return super.parseCpindexUnsignedShort(curPos, pdis);
            }
        },
        /**
         * Determine if object is of given type.
         *
         * Note: Add '_' suffix to avoid compile error since 'instanceof' is a
         * Java keyword, remove the '_' from the name when showing.
         *
         * @see #getName()
         */
        instanceof_(193) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                parsed.opCodeText = this.getName();
                return parsed;
            }
        },
        /**
         * Enter monitor for object.
         *
         * The objectref must be of type reference.
         *
         * Each object is associated with a monitor. A monitor is locked if and
         * only if it has an owner. The thread that executes
         * {@link #monitorenter} attempts to gain ownership of the monitor
         * associated with objectref,
         */
        monitorenter(194),
        /**
         * Exit monitor for object.
         *
         * The objectref must be of type reference.
         *
         * The thread that executes {@link #monitorexit} must be the owner of
         * the monitor associated with the instance referenced by objectref.
         */
        monitorexit(195),
        /**
         * Extend local variable index by additional bytes.
         */
        wide(196) {
            /**
             * The opcode with wide targets.
             */
            private int wide_opcode;

            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                wide_opcode = pdis.readUnsignedByte();
                InstructionParsed parsed = new InstructionParsed(curPos, wide_opcode);
                parsed.isWide = true;

                String opCodeText;
                if (WIDE_SINGLE_OPCODES.contains(wide_opcode)) {
                    parsed.lvIndex = pdis.readUnsignedShort();
                    opCodeText = String.format(FORMAT_OPCODE_NUMBER, getWideName(Opcode.Instruction.valueOf(wide_opcode).name()), parsed.lvIndex);
                } else if (wide_opcode == Opcode.Instruction.iinc.code) {
                    parsed.lvIndex = pdis.readUnsignedShort();
                    parsed.immediateValue = pdis.readUnsignedShort();
                    opCodeText = String.format(FORMAT_OPCODE_LOCAL_IINC, getWideName(Opcode.Instruction.iinc.name()), parsed.lvIndex, parsed.immediateValue);
                } else {
                    opCodeText = String.format("%s [Unknown opcode]", Opcode.Instruction.wide.name());
                }

                parsed.opCodeText = opCodeText;
                return parsed;
            }

            @Override
            String getName() {
                return getWideName(Opcode.Instruction.valueOf(this.wide_opcode).name());
            }

            /**
             * Get the name with "wide " prefix. Only applied for {@link #wide}.
             *
             * @return opcode name with "wide " prefix
             */
            String getWideName(String s) {
                return Instruction.wide.name() + " " + s;
            }
        },
        /**
         * Create new multidimensional array.
         */
        multianewarray(197) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.cpIndex = pdis.readUnsignedShort();
                int dimensions = pdis.readUnsignedByte();
                parsed.opCodeText = String.format("%s type=%d dimensions=%d", this.name(), parsed.cpIndex, dimensions);
                return parsed;
            }
        },
        /**
         * Branch if reference is null.
         */
        ifnull(198) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.branchbyte = pdis.readUnsignedShort();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Branch if reference not null.
         */
        ifnonnull(199) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.branchbyte = pdis.readUnsignedShort();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Branch always (wide index).
         */
        goto_w(200) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.branchbyte = pdis.readInt();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Jump subroutine (wide index).
         */
        jsr_w(201) {
            @Override
            protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
                InstructionParsed parsed = new InstructionParsed(curPos, this.code);
                parsed.branchbyte = pdis.readInt();
                parsed.opCodeText = this.name();
                return parsed;
            }
        },
        /**
         * Reserved opcode <code>breakpoint</code>.
         */
        breakpoint(202, true),
        /**
         * Reserved opcode <code>impdep1</code>.
         */
        impdep1(254, true),
        /**
         * Reserved opcode <code>impdep2</code>.
         */
        impdep2(255, true),
        /**
         * Unknown Opcode. This should never happen.
         */
        UNKNOWN(-1, true);

        public static final String OPCODE_NAME_RESERVED_PREFIX = "[Reserved] ";
        private static final List<Integer> WIDE_SINGLE_OPCODES = new ArrayList<>();
        static {
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.iload.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.lload.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.fload.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.dload.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.aload.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.istore.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.lstore.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.fstore.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.dstore.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.astore.code);
            WIDE_SINGLE_OPCODES.add(Opcode.Instruction.ret.code);
        }

        /**
         * Internal code for an Instruction.
         */
        public final int code;

        public final boolean reserved;

        Instruction(int i) {
            this(i, false);
        }

        Instruction(int i, boolean r) {
            this.code = i;
            this.reserved = r;
        }

        /**
         * Remove the postfix "_" from the {@link #name()}. Only applied for
         * {@link #goto_}, {@link #return_}, {@link #new_}, and
         * {@link #instanceof_}.
         *
         * @return The postfix "_" from the name
         *
         * @see #goto_
         * @see #return_
         * @see #new_
         * @see #instanceof_
         * @see #reserved
         * @see #wide
         */
        String getName() {
            String name = super.name();

            if (name.endsWith("_")) {
                name = name.substring(0, name.length() - 1);
            }
            if (this.reserved) {
                name = Instruction.OPCODE_NAME_RESERVED_PREFIX + name;
            }

            return name;
        }

        /**
         * Get Opcode name.
         *
         * @param opcode Internal value of an opcode.
         * @return Opcode name
         */
        public static Instruction valueOf(int opcode) {
            Instruction result = Instruction.UNKNOWN;
            for (Instruction i : Instruction.values()) {
                if (i.code == opcode) {
                    result = i;
                    break;
                }
            }

            return result;
        }

        /**
         * <pre>
         * java:S1130 - "throws" declarations should not be superfluous --- The subclass throws IOException
         * java:S1172 - Unused method parameters should be removed --- `pdis` is used by children classes
         * </pre>
         */
        @SuppressWarnings({"java:S1130", "java:S1172"})
        protected InstructionParsed parse(final int curPos, final PosDataInputStream pdis) throws IOException {
            InstructionParsed parsed = new InstructionParsed(curPos, this.code);
            parsed.opCodeText = this.name();
            return parsed;
        }

        private InstructionParsed parseBranchbyteShort(final int curPos, final PosDataInputStream pdis) throws IOException {
            InstructionParsed parsed = new InstructionParsed(curPos, this.code);
            parsed.branchbyte = Integer.valueOf(pdis.readShort());
            parsed.opCodeText = this.name();
            return parsed;
        }

        private InstructionParsed parseCpindexUnsignedShort(final int curPos, final PosDataInputStream pdis) throws IOException {
            InstructionParsed parsed = new InstructionParsed(curPos, this.code);
            parsed.cpIndex = pdis.readUnsignedShort();
            parsed.opCodeText = this.name();
            return parsed;
        }

        private InstructionParsed parseLvindexUnsignedByte(final int curPos, final PosDataInputStream pdis) throws IOException {
            InstructionParsed parsed = new InstructionParsed(curPos, this.code);
            parsed.lvIndex = pdis.readUnsignedByte();
            parsed.opCodeText = String.format(FORMAT_OPCODE_NUMBER, this.name(), parsed.lvIndex);
            return parsed;
        }

        /**
         * Skip 0-3 byte pad when needed, for {@link #tableswitch} and
         * {@link #lookupswitch}.
         *
         * @see #tableswitch
         * @see #lookupswitch
         */
        private void skipPad(final PosDataInputStream pdis) throws IOException {
            int skip = pdis.getPos() % 4;
            skip = (skip > 0) ? 4 - skip : skip;
            if (skip > 0) {
                BytesTool.skip(pdis, skip);
            }
        }

    }

    /**
     * Data types used by {@link Instruction#newarray}.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5.newarray">
     * VM Spec: Table 6.5.newarray-A. Array type codes
     * </a>
     */
    public enum NewarrayType {

        T_UNKNOWN(-1),
        T_BOOLEAN(4),
        T_CHAR(5),
        T_FLOAT(6),
        T_DOUBLE(7),
        T_BYTE(8),
        T_SHORT(9),
        T_INT(10),
        T_LONG(11);

        public final int atype;

        NewarrayType(int i) {
            this.atype = i;
        }

        /**
         * Get the type name based on {@link #atype}.
         *
         * @param value Value to match {@link #atype}
         * @return Type name corresponding to <code>value</code>
         */
        public static NewarrayType valueOf(int value) {
            NewarrayType v = NewarrayType.T_UNKNOWN;
            for (NewarrayType type : NewarrayType.values()) {
                if (type.atype == value) {
                    v = type;
                    break;
                }
            }
            return v;
        }
    }

    /**
     * Parse the java byte code in a method as a string.
     *
     * @param code Byte array of method source code
     * @return Readable string of the method source code
     */
    public static List<InstructionParsed> parseCode(final byte[] code) {
        if ((code == null) || (code.length < 1)) {
            return new ArrayList<>();
        }

        List<InstructionParsed> codeResult = new ArrayList<>();
        final PosDataInputStream pdis = new PosDataInputStream(new PosByteArrayInputStream(code));
        while (pdis.getPos() < code.length) {
            try {
                final int curPos = pdis.getPos();
                final int opcode = pdis.read();

                codeResult.add(Instruction.valueOf(opcode).parse(curPos, pdis));
            } catch (IOException ioe) {
                LOG.log(Level.SEVERE, "parseCode() with code length - {0}", code.length);
                LOG.log(Level.SEVERE, ioe.toString(), ioe);
                break;
            }
        }

        return codeResult;
    }

    /**
     * Instruction structure used by {@link Instruction#lookupswitch}.
     *
     * @see Instruction#lookupswitch
     */
    @SuppressFBWarnings(value="NM_CLASS_NAMING_CONVENTION", justification="Use the type name from JVM Spec")
    public static class lookupswitch {

        public final int defaultbyte;
        public final int npairs;
        public final Map<Integer, Integer> mapoffsets = new LinkedHashMap<>();

        lookupswitch(int defaultByte, int nPairs) {
            this.defaultbyte = defaultByte;
            this.npairs = nPairs;
        }

        public String toString(int currentOffset) {
            final StringBuilder sb = new StringBuilder(256);
            sb.append('(').append(this.npairs).append(" Pairs)");
            this.mapoffsets.keySet().forEach(key -> {
                Integer value = this.mapoffsets.get(key);
                sb.append(String.format("%n    case %d. jump to %d (relative offset = %d)", key, value + currentOffset, value));
            });
            sb.append(String.format("%n    default. jump to %d (relative offset = %d) ", this.defaultbyte + currentOffset, this.defaultbyte));

            return sb.toString();
        }
    }

    /**
     * Instruction structure used by {@link Instruction#tableswitch}.
     *
     * @see Instruction#tableswitch
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5.tableswitch">VM
     * Spec: The Java Virtual Machine Instruction Set</a>
     */
    @SuppressFBWarnings(value="NM_CLASS_NAMING_CONVENTION", justification="Use the type name from JVM Spec")
    public static class tableswitch {

        public final int defaultbyte;
        public final int lowbyte;
        public final int highbyte;
        public final Map<Integer, Integer> jumpoffsets = new LinkedHashMap<>();

        tableswitch(int defaultByte, int lowByte, int highByte) {
            this.defaultbyte = defaultByte;
            this.lowbyte = lowByte;
            this.highbyte = highByte;
        }

        public String toString(int currentOffset) {
            final StringBuilder sb = new StringBuilder(256);
            sb.append(" (from ").append(this.lowbyte).append(" to ").append(this.highbyte).append(')');
            this.jumpoffsets.keySet().forEach(key -> {
                Integer value = this.jumpoffsets.get(key);
                sb.append(String.format("%n    case %d. jump to %d (relative offset = %d) ", key, value + currentOffset, value));
            });
            sb.append(String.format("%n   default. jump to %d (relative offset = %d) ", this.defaultbyte + currentOffset, this.defaultbyte));

            return sb.toString();
        }

    }

    /**
     * Parsed result for each opcode instruction.
     */
    public static class InstructionParsed {

        /**
         * Current offset of the opCode in the class file <code>Code</code>
         * attribute byte array.
         */
        public final int offset;

        /**
         * Whether current opcode is {@link Instruction#wide} or not.
         *
         * @see Instruction#wide
         */
        protected boolean isWide = false;

        /**
         * Array type for {@link Instruction#newarray}.
         *
         * @see Instruction#newarray
         */
        protected Integer arrayType;

        /**
         * JVM Opcode value.
         *
         * @see Instruction#code
         */
        public final int opCode;

        /**
         * Name for {@link #opCode}.
         *
         * @see Instruction#code
         * @see Instruction#getName()
         */
        public final String opCodeName;

        /**
         * Text of the {@link #opCode}. In case {@link #opCode} is
         * {@link Instruction#wide}, the {@link #opCodeText} contains the
         * following opCode after <code>wide</code> also.
         */
        protected String opCodeText;

        /**
         * Referenced {@link ClassFile#constant_pool} object index if exist. It
         * will be <code>null</code> if the {@link Instruction} did not
         * reference to any {@link ClassFile#constant_pool} object.
         *
         * @see Instruction#ldc
         * @see Instruction#ldc_w
         * @see Instruction#ldc2_w
         * @see Instruction#getstatic
         * @see Instruction#putstatic
         * @see Instruction#getfield
         * @see Instruction#putfield
         * @see Instruction#invokevirtual
         * @see Instruction#invokespecial
         * @see Instruction#invokestatic
         * @see Instruction#invokeinterface
         * @see Instruction#invokedynamic
         * @see Instruction#new_
         * @see Instruction#anewarray
         * @see Instruction#checkcast
         * @see Instruction#instanceof_
         * @see Instruction#multianewarray
         */
        protected Integer cpIndex = null;

        /**
         * Index into the Local Variable array of the current frame.
         *
         * @see Instruction#iload
         * @see Instruction#lload
         */
        protected Integer lvIndex = null;

        /**
         * The immediate numeric value, that value is pushed onto the operand
         * stack.
         *
         * @see Instruction#bipush
         * @see Instruction#iinc
         * @see Instruction#sipush
         *
         */
        protected Integer immediateValue = null;

        /**
         * Number of arguments for {@link Instruction#invokeinterface}
         * instruction.
         *
         * @see Instruction#invokeinterface
         */
        protected Integer nArgs = null;

        /**
         * Execution proceeds at that offset from the address of the opcode of
         * current instruction.
         *
         * @see Instruction#goto_
         * @see Instruction#goto_w
         * @see Instruction#if_acmpeq
         * @see Instruction#if_acmpne
         * @see Instruction#if_icmpeq
         * @see Instruction#if_icmpge
         * @see Instruction#if_icmpgt
         * @see Instruction#if_icmple
         * @see Instruction#if_icmplt
         * @see Instruction#if_icmpne
         * @see Instruction#ifeq
         * @see Instruction#ifne
         * @see Instruction#iflt
         * @see Instruction#ifge
         * @see Instruction#ifgt
         * @see Instruction#ifle
         * @see Instruction#ifnonnull
         * @see Instruction#ifnull
         * @see Instruction#jsr
         * @see Instruction#jsr_w
         */
        protected Integer branchbyte = null;

        /**
         * Parsed data for {@link Instruction#lookupswitch}.
         *
         * @see Instruction#lookupswitch
         */
        protected lookupswitch lookupSwitch = null;

        /**
         * Parsed data for {@link Instruction#tableswitch}.
         *
         * @see Instruction#tableswitch
         */
        protected tableswitch tableSwitch = null;

        InstructionParsed(int curPos, int opcode) {
            this.offset = curPos;
            this.opCode = opcode;
            this.opCodeName = Instruction.valueOf(opcode).getName();
        }

        /**
         * Get the absolute value of the branch byte, if {@link #branchbyte} is
         * not null.
         *
         * @return Absolute value of the {@link #branchbyte}; return
         * <code>null</code> in case {@link #branchbyte} is null
         * @see #branchbyte
         */
        public Integer getAbsoluteBranchByte() {
            return (this.branchbyte != null) ? this.offset + this.branchbyte : null;
        }

        /**
         * Getter for {@link #opCodeText}.
         *
         * @return {@link #opCodeText} value
         */
        public String getOpcodeText() {
            return this.opCodeText;
        }

        /**
         * Getter for {@link #cpIndex}.
         *
         * @return {@link #cpIndex} value. <code>null</code> if no constant pool
         * index.
         */
        public Integer getCpindex() {
            return this.cpIndex;
        }

        /**
         * Getter for {@link #immediateValue}.
         *
         * @return {@link #immediateValue} value. <code>null</code> if not
         * applicable
         */
        public Integer getImmediateValue() {
            return this.immediateValue;
        }

        /**
         * Getter for {@link #lvIndex}.
         *
         * @return {@link #lvIndex} value. <code>null</code> if no local
         * variable index.
         */
        public Integer getLvindex() {
            return this.lvIndex;
        }

        /**
         * Getter for {@link #lookupSwitch}.
         *
         * @return {@link #lookupSwitch} value. <code>null</code> if current
         * instruction is not {@link Instruction#lookupswitch}
         */
        public lookupswitch getLookupSwitch() {
            return this.lookupSwitch;
        }

        /**
         * Getter for {@link #nArgs}.
         *
         * @return {@link #nArgs} value. <code>null</code> if not applicable
         */
        public Integer getNargs() {
            return this.nArgs;
        }

        /**
         * Getter for {@link #tableSwitch}.
         *
         * @return {@link #tableSwitch} value. <code>null</code> if current
         * instruction is not {@link Instruction#tableswitch}
         */
        public tableswitch getTableSwitch() {
            return this.tableSwitch;
        }

        /**
         * Getter for {@link #isWide}.
         *
         * @return {@link #isWide} value.
         */
        public boolean isWide() {
            return this.isWide;
        }

        /**
         * Getter for {@link #arrayType}.
         *
         * @return {@link #arrayType} value.
         */
        public Integer getArrayType() {
            return this.arrayType;
        }

        @Override
        public String toString() {
            String s = String.format("%04d: %s", this.offset, this.opCodeText);

            if (this.branchbyte != null) {
                String branch = String.format(" %d (branch byte offset = %d)", this.getAbsoluteBranchByte(), this.branchbyte);
                s += branch;
            }

            return s;
        }

        /**
         * Get the {@link Instruction} analysis result with
         * {@link ClassFile#constant_pool} description.
         *
         * @param cf the {@link ClassFile}
         * @return {@link Instruction} analysis result
         */
        public String toString(ClassFile cf) {
            String s = this.toString();

            if (this.cpIndex != null) {
                String cpDesc = cf.getCPDescription(this.cpIndex);
                // Avoid too long description
                if (cpDesc.length() > 1000) {
                    cpDesc = cpDesc.substring(1, 1000);
                }
                s = s + "  " + cpDesc;
            }

            return s;
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/PluginDescriptorClass.java`:

```java
/*
 * PluginDescriptorClass.java    Apr 17, 2021, 15:02
 *
 * Copyright 2021, BinaryInternals.org.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.classfile;

import org.binaryinternals.commonlib.core.PluginDescriptor;
import org.binaryinternals.commonlib.core.FileFormat;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorClass implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "Java class File (*.class)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"class"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return ClassFile.class;
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/SignatureConvertor.java`:

```java
/*
 * SignatureConvertor.java    September 20, 2007, 11:10 PM
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import org.binaryinternals.format.classfile.attribute.Signature_attribute;
import java.util.ArrayList;
import java.util.List;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.format.classfile.attribute.Signature_attribute.ReferenceType;

/**
 * Convert the Internal Form of Names into java language specification type
 * names.
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.2">
 * VM Spec: The Internal Form of Names
 * </a>
 *
 * <pre>
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S116")
public final class SignatureConvertor {

    /**
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.2.1">
     * VM Spec: Binary Class and Interface Names
     * </a>
     */
    public static final char BINARY_NAME_SEPARATOR = '/';

    /**
     * The ASCII periods (.) that normally separate the identifiers in in JLS (Java Language Specification).
     * 
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.2.1">
     * VM Spec: Binary Class and Interface Names
     * </a>
     */
    public static final char JLS_NAME_SEPARATOR = '.';

    /**
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.3.3">
     * VM Spec: Method Descriptors
     * </a>
     */
    public static final char METHODDESCRIPTOR_LEFT = '(';
    /**
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.3.3">
     * VM Spec: Method Descriptors
     * </a>
     */
    public static final char METHODDESCRIPTOR_RIGHT = ')';
    /**
     * <code>void</code> return type for method.
     */
    public static final String METHODRETURN_VOID = "V";

    private SignatureConvertor() {
    }

    /**
     * Get return type from method descriptor {@link method_info#descriptor_index}.
     *
     * @param signature Method signature in JVM internal format
     * @return Method return type in Java Programming language format
     * @throws FileFormatException Invalid signature string found
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.3.3">
     * VM Spec: Method Descriptors
     * </a>
     */
    public static SignatureResult methodReturnTypeExtractor(final String signature)
            throws FileFormatException {
        if (signature == null) {
            throw new IllegalArgumentException("'signature' should not be null.");
        }
        if (signature.length() < 3) {
            throw new IllegalArgumentException("'signature' should be more than 2 characters.");
        }

        final int bracketEnd = signature.indexOf(METHODDESCRIPTOR_RIGHT); // ')'
        if (bracketEnd == -1) {
            throw new IllegalArgumentException(String.format("There is no ')' in the method signature: %s", signature));
        }

        final String returnType = signature.substring(bracketEnd + 1);
        return methodReturnTypeJLS(returnType);
    }
    
    /**
     * JLS format of return type.
     *
     * @param returnType Return type in binary format
     * @return Method return type in Java Programming language format
     * @throws FileFormatException Invalid signature string found
     */
    public static SignatureResult methodReturnTypeJLS(final String returnType) throws FileFormatException {
        SignatureResult returnValue;
        if (METHODRETURN_VOID.equals(returnType)) {
            returnValue = new SignatureResult(0, returnType, JavaLangSpec.Keyword.VOID.text);
        } else {
            returnValue = SignatureConvertor.fieldDescriptorExtractor(returnType);
        }

        return returnValue;
    }


    /**
     * Get parameters type from method descriptor {@link method_info#descriptor_index}.
     *
     * <p>
     * Example: <code>(ILjava/lang/String;[I)</code> to
     * <code>(int, String, int[])</code>
     * </p>
     *
     * @param signature JVM internal format of method signature
     * @return Java Language Specification (JLS) format of parameters
     * @throws FileFormatException Invalid signature string found
     */
    public static String methodParameters2Readable(final String signature)
            throws FileFormatException {
        List<SignatureResult> paramters = methodParametersSplit(signature);
        StringBuilder result = new StringBuilder();

        result.append(METHODDESCRIPTOR_LEFT);
        int size = paramters.size();
        if (size > 0) {
            for (int i = 0; i < size; i++) {
                result.append(paramters.get(i).toString());
                if (i != size - 1) {
                    result.append(',');
                }
            }
        }
        result.append(METHODDESCRIPTOR_RIGHT);

        return result.toString();
    }

    // (com/sun/java/accessibility/AccessBridge;Ljavax/accessibility/AccessibleContext;)V
    public static List<SignatureResult> methodParametersSplit(final String signature)
            throws FileFormatException {
        // check parameter
        if (signature == null) {
            throw new IllegalArgumentException("'signature' should not be null.");
        }
        if (signature.length() < 3) {
            throw new IllegalArgumentException("'signature' should be more than 2 characters.");
        }
        final int bracketEnd = signature.indexOf(METHODDESCRIPTOR_RIGHT);            // ')'
        if ((signature.charAt(0) != METHODDESCRIPTOR_LEFT) || (bracketEnd == -1)) {  // '('
            throw new IllegalArgumentException(String.format("There is no '(' or ')' in the method signature: %s", signature));
        }

        // get the parameter signatures: ILjava/lang/String;[I
        // if the first byte is
        //   '[': omited
        //   Primitive type; end
        //   'L': find the next ';', parse it; then end
        StringBuilder sbParameter = new StringBuilder();
        List<String> parameters = new ArrayList<>();
        List<SignatureResult> parametersResult = new ArrayList<>();

        String rawParameters = signature.substring(1, bracketEnd + 1);  // com/sun/java/accessibility/AccessBridge;Ljavax/accessibility/AccessibleContext;)
        while (rawParameters.charAt(0) != METHODDESCRIPTOR_RIGHT) {  // ')'
            if (rawParameters.charAt(0) == '[') {
                sbParameter.append(rawParameters.charAt(0));
                rawParameters = rawParameters.substring(1);
            } else if (Signature_attribute.BaseType.isPrimitiveType(rawParameters.charAt(0))) {
                sbParameter.append(rawParameters.charAt(0));
                rawParameters = rawParameters.substring(1);
                // Add one parameter
                parameters.add(sbParameter.toString());
                sbParameter.setLength(0);
                sbParameter.trimToSize();
            } else if (rawParameters.charAt(0) == ReferenceType.ClassTypeSignature.signature) {     // 'L'
                int commaIndex = rawParameters.indexOf(';');
                sbParameter.append(rawParameters.substring(0, commaIndex + 1));
                rawParameters = rawParameters.substring(commaIndex + 1);
                // Add one parameter
                parameters.add(sbParameter.toString());
                sbParameter.setLength(0);
                sbParameter.trimToSize();
            } else {
                throw new FileFormatException("Un-recognized method descriptor: " + signature);
            }
        }

        if (!parameters.isEmpty()) {
            for (String s : parameters) {
                parametersResult.add(fieldDescriptorExtractor(s));
            }
        }

        return parametersResult;
    }

    /**
     * Extract field descriptor. Example:
     * <pre>
     * B                   -- byte
     * [I                  -- int[]
     * Ljava/lang/Object;  -- java.lang.Object
     * [Ljava/lang/String; -- java.lang.String[]
     * </pre>
     *
     * @param signature JVM internal format of field signature
     * @return Signature Parse result
     * @throws FileFormatException Invalid signature string found
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.3.2">
     * VM Spec: Field Descriptors
     * </a>
     */
    public static SignatureResult fieldDescriptorExtractor(final String signature)
            throws FileFormatException {

        if ((signature == null) || signature.isEmpty()) {
            throw new IllegalArgumentException("'signature' should not be null or empty.");
        }

        String sig = signature;
        int arrayCount = 0;
        while (sig.charAt(0) == ReferenceType.ArrayTypeSignature.signature) {  // '['
            arrayCount++;
            sig = sig.substring(1);
        }

        //
        final int sigLength = sig.length();
        String sigJls;
        if (sigLength == 1) {
            sigJls = Signature_attribute.BaseType.extractPrimitiveType(sig.charAt(0));
        } else {
            if (sig.charAt(0) == ReferenceType.ClassTypeSignature.signature
                    && sig.charAt(sig.length() - 1) == ReferenceType.ClassTypeSignatureSuffix.signature) {
                sig = sig.substring(1, sigLength - 1);
            }

            sigJls = parseClassSignature(sig);
        }

        return new SignatureResult(arrayCount, sig, sigJls);
    }

    /**
     * Convert class signature from JVM internal format to Java programming
     * language format.
     * <p>
     * Example: convert <code>java/lang/String;</code> to
     * <code>java.lang.String</code>.
     * </p>
     *
     * @param classSignature JVM internal format of class signature
     * @return Java Language Specification (JLS) format of class signature
     */
    public static String parseClassSignature(final String classSignature)
            throws IllegalArgumentException {
        if (classSignature == null) {
            throw new IllegalArgumentException("'ClassSignature' should not be null.");
        }

        return classSignature.replace(SignatureConvertor.BINARY_NAME_SEPARATOR, SignatureConvertor.JLS_NAME_SEPARATOR);
    }

    /**
     * Set package name of the class signature.
     * 
     * @param classSignature JVM internal format of class signature
     * @return Package name of class signature, or null if the class not in any package
     */
    public static String parsePackage(final String classSignature){
        if (classSignature == null) {
            throw new IllegalArgumentException("'ClassSignature' should not be null.");
        }
        
        int lastIndex = classSignature.lastIndexOf(SignatureConvertor.BINARY_NAME_SEPARATOR);
        if (lastIndex == -1) {
            return null;
        } else {
            return SignatureConvertor.parseClassSignature(classSignature.substring(0, lastIndex)).toLowerCase();
        }
    }

    /**
     * Signature parse result.
     */
    public static class SignatureResult {

        /**
         * Dimension if it is an array.
         */
        public final int ArrayDimension;
        /**
         * Binary name.
         */
        public final String TypeBinaryName;
        /**
         * Parsed Java Language Specification type name.
         */
        public final String TypeJLSName;
        
        /**
         * Package name of the type. It will be <code>null</code> if the {@link #TypeJLSName} do not in a package.
         */
        public final String TypePackage;

        SignatureResult(int count, String bin, String jls) {
            this.ArrayDimension = count;
            this.TypeBinaryName = bin;
            this.TypeJLSName = jls;
            this.TypePackage = parsePackage(bin);
        }

        /**
         * Get the readable format of signature.
         *
         * @return Readable format of signature
         */
        @Override
        public String toString() {
            final StringBuilder sb = new StringBuilder();
            int count = this.ArrayDimension;
            sb.append(this.TypeJLSName);
            while (count > 0) {
                sb.append("[]");
                count--;
            }

            return sb.toString();
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/U2ClassComponent.java`:

```java
/*
 * U2ClassComponent.java    10:32 PM, August 9, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * Super class for all simple components which have only one 16-bit ({@link u2})
 * field in a {@code class} file.
 *
 * @author Amos Shi
 */
public class U2ClassComponent extends FileComponent {

    public final u2 value;

    U2ClassComponent(final PosDataInputStream stream) throws IOException {
        this.startPos = stream.getPos();
        this.length = u2.LENGTH;
        this.value = new u2(stream);
    }

    /**
     * Get the {@link u2} vaue in {@link java.lang.Integer} format.
     *
     * @return Value of the {@link u2} component
     */
    public int getValue() {
        return this.value.value;
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Annotation.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code annotation} structure in {@code RuntimeVisibleAnnotations}
 * attribute.
 * <p>
 * It has the following format:
 * </p>
 *
 * <pre>
 * annotation {
 *   u2 type_index;
 *   u2 num_element_value_pairs;
 *   {   u2            element_name_index;
 *       element_value value;
 *   } element_value_pairs[num_element_value_pairs];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16">
 * VM Spec: annotation structure
 * </a>
 *
 * <pre>
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * java:S116  - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S1104", "java:S116"})
public class Annotation extends FileComponent implements GenerateTreeNodeClassFile {

    public final u2 type_index;
    public final u2 num_element_value_pairs;
    public final Annotation.element_value_pair[] element_value_pairs;

    protected Annotation(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super.startPos = posDataInputStream.getPos();
        this.type_index = new u2(posDataInputStream);
        this.num_element_value_pairs = new u2(posDataInputStream);
        if (this.num_element_value_pairs.value > 0) {
            this.element_value_pairs = new element_value_pair[this.num_element_value_pairs.value];
            for (int i = 0; i < this.num_element_value_pairs.value; i++) {
                this.element_value_pairs[i] = new element_value_pair(posDataInputStream);
            }
        } else {
            this.element_value_pairs = null;
        }
        super.length = posDataInputStream.getPos() - super.startPos;
    }

    /**
     * Get the value of {@code num_element_value_pairs}[{@code index}].
     *
     * @param index Index of the num_element_value_pairs item
     * @return The value of {@code num_element_value_pairs}[{@code index}]
     */
    public Annotation.element_value_pair getElementvaluePair(final int index) {
        Annotation.element_value_pair p = null;
        if (this.element_value_pairs != null && index < this.element_value_pairs.length) {
            p = this.element_value_pairs[index];
        }
        return p;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        final ClassFile classFile = (ClassFile) fileFormat;
        int currentPos = this.startPos;

        int cpIndex = this.type_index.value;
        this.addNode(parentNode,
                currentPos,
                u2.LENGTH,
                "type_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "type", ((ClassFile) classFile).getCPDescription(cpIndex)),
                "msg_attr_annotation__type_index",
                Icons.Kind
        );
        currentPos += u2.LENGTH;

        this.addNode(parentNode,
                currentPos,
                u2.LENGTH,
                "num_element_value_pairs",
                this.num_element_value_pairs.value,
                "msg_attr_annotation__num_element_value_pairs",
                Icons.Counter
        );
        currentPos += u2.LENGTH;

        if (this.num_element_value_pairs.value > 0) {
            DefaultMutableTreeNode elementValuePairsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    currentPos,
                    this.getStartPos() + this.getLength() - currentPos,
                    String.format("element_value_pairs [%d]", this.num_element_value_pairs.value),
                    MESSAGES.getString("msg_attr_annotation__element_value_pairs")
            ));
            parentNode.add(elementValuePairsNode);

            for (int i = 0; i < this.num_element_value_pairs.value; i++) {
                Annotation.element_value_pair pair = this.getElementvaluePair(i);
                DefaultMutableTreeNode elementValuePairNode = this.addNode(elementValuePairsNode,
                        pair.getStartPos(),
                        pair.getLength(),
                        String.valueOf(i + 1),
                        "element_value_pair",
                        "msg_attr_annotation__element_value_pairs",
                        Icons.Data
                );

                pair.generateTreeNode(elementValuePairNode, fileFormat);
            }
        }
    }

    /**
     * Each value of the {@link Annotation#element_value_pairs} table represents
     * a single element-value pair in the annotation represented by this
     * <code>annotation</code> structure.
     *
     * @see <a
     * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16">
     * VM Spec: The RuntimeVisibleAnnotations Attribute
     * </a>
     *
     * <pre>
     * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings({"java:S101"})
    public static final class element_value_pair extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * The name of the element of the element-value pair represented by this
         * {@link Annotation#element_value_pairs} entry.
         */
        public final u2 element_name_index;
        /**
         * Represents the value of the element-value pair represented by this
         * {@link Annotation#element_value_pairs} entry.
         */
        public final element_value value;

        protected element_value_pair(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            this.startPos = posDataInputStream.getPos();

            this.element_name_index = new u2(posDataInputStream);
            this.value = new element_value(posDataInputStream);

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.element_name_index.value;
            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "element_name_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "element name", classFile.getCPDescription(cpIndex)),
                    "msg_attr_annotation__element_value_pairs_element_name_index",
                    Icons.Name
            );

            DefaultMutableTreeNode valueNode = this.addNode(parentNode,
                    startPosMoving + u2.LENGTH,
                    this.getLength() - u2.LENGTH,
                    "value",
                    "raw data",
                    "msg_attr_annotation__element_value_pairs_value",
                    Icons.Data
            );
            this.value.generateTreeNode(valueNode, fileFormat);
        }
    }

    /**
     * The element_value structure is a discriminated union representing the
     * value of an element-value pair.
     *
     * <p>
     * It has the following format:
     * </p>
     * <pre>
     * element_value {
     *     u1 tag;
     *     union {
     *         u2 const_value_index;
     *
     *         {   u2 type_name_index;
     *             u2 const_name_index;
     *         } enum_const_value;
     *
     *         u2 class_info_index;
     *
     *         annotation annotation_value;
     *
     *         {   u2            num_values;
     *             element_value values[num_values];
     *         } array_value;
     *     } value;
     * }
     * </pre>
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16.1">
     * VM Spec: The element_value structure
     * </a>
     */
    @SuppressWarnings({"java:S101"})
    public static final class element_value extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * The <code>tag</code> item uses a single ASCII character to indicate
         * the type of the value of the element-value pair.
         *
         * @see TagEnum
         */
        public final char tag;
        /**
         * The value of {@link #union_const_value_index} might be null depending
         * on the {@link #tag} value
         */
        public final u2 union_const_value_index;
        /**
         * The value of {@link #union_enum_const_value} might be null depending
         * on the {@link #tag} value
         */
        public final enum_const_value union_enum_const_value;
        /**
         * The value of {@link #union_class_info_index} might be null depending
         * on the {@link #tag} value
         */
        public final u2 union_class_info_index;
        /**
         * The value of {@link #union_annotation_value} might be null depending
         * on the {@link #tag} value
         */
        public final Annotation union_annotation_value;
        /**
         * The value of {@link #union_array_value} might be null depending on
         * the {@link #tag} value
         */
        public final array_value union_array_value;

        protected element_value(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            this.startPos = posDataInputStream.getPos();

            this.tag = (char) posDataInputStream.read(); // Read 1 byte only
            if (this.tag == TagEnum.B.value
                    || this.tag == TagEnum.C.value
                    || this.tag == TagEnum.D.value
                    || this.tag == TagEnum.F.value
                    || this.tag == TagEnum.I.value
                    || this.tag == TagEnum.J.value
                    || this.tag == TagEnum.S.value
                    || this.tag == TagEnum.Z.value
                    || this.tag == TagEnum.s.value) {
                this.union_const_value_index = new u2(posDataInputStream);
                this.union_enum_const_value = null;
                this.union_class_info_index = null;
                this.union_annotation_value = null;
                this.union_array_value = null;

            } else if (this.tag == TagEnum.e.value) {
                this.union_const_value_index = null;
                this.union_enum_const_value = new enum_const_value(posDataInputStream);
                this.union_class_info_index = null;
                this.union_annotation_value = null;
                this.union_array_value = null;

            } else if (this.tag == TagEnum.c.value) {
                this.union_const_value_index = null;
                this.union_enum_const_value = null;
                this.union_class_info_index = new u2(posDataInputStream);
                this.union_annotation_value = null;
                this.union_array_value = null;

            } else if (this.tag == TagEnum.at.value) {
                this.union_const_value_index = null;
                this.union_enum_const_value = null;
                this.union_class_info_index = null;
                this.union_annotation_value = new Annotation(posDataInputStream);
                this.union_array_value = null;

            } else if (this.tag == TagEnum.array_type.value) {
                this.union_const_value_index = null;
                this.union_enum_const_value = null;
                this.union_class_info_index = null;
                this.union_annotation_value = null;
                this.union_array_value = new array_value(posDataInputStream);

            } else {
                throw new FileFormatException(String.format(
                        "Un-recognized tag value in strcutrue element_value. tag=%c (%02X), offset=%d (%08X)",
                        this.tag, (int) this.tag,
                        posDataInputStream.getPos(), posDataInputStream.getPos()
                ));
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            this.addNode(parentNode,
                    startPosMoving,
                    1,
                    "tag",
                    this.tag + " - " + element_value.TagEnum.getType(this.tag),
                    "msg_attr_element_value__tag",
                    Icons.Tag
            );
            startPosMoving += 1;

            if (this.union_const_value_index != null) {
                final int constValueIndex = this.union_const_value_index.value;
                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "const_value_index",
                        String.format(TEXT_CPINDEX_VALUE, constValueIndex, "const value", classFile.getCPDescription(constValueIndex)),
                        "msg_attr_element_value__const_value_index",
                        Icons.Constant
                );

            } else if (this.union_enum_const_value != null) {
                DefaultMutableTreeNode unionConstNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    enum_const_value.LENGTH,
                    enum_const_value.class.getSimpleName(),
                    MESSAGES.getString("msg_attr_element_value__enum_const_value")
                ));
                this.union_enum_const_value.generateTreeNode(unionConstNode, fileFormat);

            } else if (this.union_class_info_index != null) {
                int classInfoIndex = this.union_class_info_index.value;
                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "class_info_index",
                        String.format(TEXT_CPINDEX_VALUE, classInfoIndex, "class info", classFile.getCPDescription(classInfoIndex)),
                        "msg_attr_element_value__class_info_index",
                        Icons.Name
                );

            } else if (this.union_annotation_value != null) {
                DefaultMutableTreeNode unionAnnotationNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    this.union_annotation_value.getLength(),
                    "annotation_value",
                    MESSAGES.getString("msg_attr_element_value__annotation_value")
                ));
                this.union_annotation_value.generateTreeNode(unionAnnotationNode, classFile);

            } else if (this.union_array_value != null) {
                DefaultMutableTreeNode unionArrayValueNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    this.union_array_value.getLength(),
                    array_value.class.getSimpleName(),
                    MESSAGES.getString("msg_attr_element_value__array_value")
                ));
                this.union_array_value.generateTreeNode(unionArrayValueNode, fileFormat);
            }
        }

        /**
         * The valid characters for the <code>tag</code> item.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16.1-130">
         * VM Spec: The element_value structure
         * </a>
         *
         * <pre>
         * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
         * </pre>
         */
        @SuppressWarnings("java:S115")
        public enum TagEnum {

            /**
             * Type <code>byte</code>.
             */
            B('B', "byte"),
            /**
             * Type <code>char</code>.
             */
            C('C', "char"),
            /**
             * Type <code>double</code>.
             */
            D('D', "double"),
            /**
             * Type <code>float</code>.
             */
            F('F', "float"),
            /**
             * Type <code>int</code>.
             */
            I('I', "int"),
            /**
             * Type <code>long</code>.
             */
            J('J', "long"),
            /**
             * Type <code>short</code>.
             */
            S('S', "short"),
            /**
             * Type <code>boolean</code>.
             */
            Z('Z', "boolean"),
            /**
             * Type <code>String</code>.
             */
            s('s', "String"),
            /**
             * Type <code>Enum type</code>.
             */
            e('e', "Enum type"),
            /**
             * Type <code>Class</code>.
             */
            c('c', "Class"),
            /**
             * Type <code>Annotation type</code>.
             */
            at('@', "Annotation type"),
            /**
             * Type <code>Array type</code>.
             */
            array_type('[', "Array type");

            /**
             * Internal value of the enum.
             */
            public final char value;
            /**
             * The type name for a enumeration type.
             * <p>
             * See table
             * <code>Table 4.7.16.1-A. Interpretation of tag values as types.</code>
             * </p>
             */
            public final String Type;

            TagEnum(char v, String type) {
                this.value = v;
                this.Type = type;
            }

            /**
             * Get the type name for a enumeration {@link #value}.
             *
             * @param v a enumeration {@link #value}
             * @return Corresponding {@link #Type} for the enumeration
             * {@link #value}, or <code>Un-recognized</code> if it is not a
             * valid enumeration value
             */
            public static String getType(char v) {
                String result = "Un-recognized";
                for (TagEnum e : TagEnum.values()) {
                    if (e.value == v) {
                        result = e.Type;
                        break;
                    }
                }
                return result;
            }
        }

        public static final class enum_const_value extends FileComponent implements GenerateTreeNodeClassFile {

            public static final int LENGTH = 4;
            public final u2 type_name_index;
            public final u2 const_name_index;

            protected enum_const_value(final PosDataInputStream posDataInputStream) throws IOException {
                this.startPos = posDataInputStream.getPos();
                this.length = LENGTH;

                this.type_name_index = new u2(posDataInputStream);
                this.const_name_index = new u2(posDataInputStream);
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                final ClassFile classFile = (ClassFile) fileFormat;
                int startPosMoving = this.getStartPos();

                int cpIndex = this.type_name_index.value;
                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "type_name_index",
                        String.format(TEXT_CPINDEX_VALUE, cpIndex, "type name", classFile.getCPDescription(cpIndex)),
                        "msg_attr_element_value__enum_const_value__type_name_index",
                        Icons.Name
                );
                startPosMoving += u2.LENGTH;

                cpIndex = this.const_name_index.value;
                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "const_name_index",
                        String.format(TEXT_CPINDEX_VALUE, cpIndex, "const name", classFile.getCPDescription(cpIndex)),
                        "msg_attr_element_value__enum_const_value__const_name_index",
                        Icons.Name
                );
            }
        }

        public static final class array_value extends FileComponent implements GenerateTreeNodeClassFile {

            public final u2 num_values;
            public final element_value[] values;

            protected array_value(final PosDataInputStream posDataInputStream)
                    throws IOException, FileFormatException {
                this.startPos = posDataInputStream.getPos();

                this.num_values = new u2(posDataInputStream);
                if (this.num_values.value > 0) {
                    this.values = new element_value[this.num_values.value];
                    for (int i = 0; i < this.num_values.value; i++) {
                        this.values[i] = new element_value(posDataInputStream);
                    }
                } else {
                    this.values = null;
                }
                this.length = posDataInputStream.getPos() - this.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                int numValues = this.num_values.value;
                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "num_values",
                        numValues,
                        "msg_attr_element_value__array_value__num_values",
                        Icons.Counter
                );
                startPosMoving += u2.LENGTH;

                if (this.values != null && this.values.length > 0) {
                    DefaultMutableTreeNode valuesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            startPosMoving,
                            this.getLength() - 3,
                            "values[" + numValues + "]",
                            MESSAGES.getString("msg_attr_element_value__array_value__values")
                    ));
                    parentNode.add(valuesNode);

                    for (int i = 0; i < this.values.length; i++) {
                        DefaultMutableTreeNode valueNode = this.addNode(valuesNode,
                                this.values[i].getStartPos(),
                                this.values[i].getLength(),
                                String.valueOf(i + 1),
                                "value",
                                "msg_attr_element_value__array_value",
                                Icons.Data
                        );
                        this.values[i].generateTreeNode(valueNode, fileFormat);
                    }
                }
            } // End of generateTreeNode()
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/AnnotationDefault_attribute.java`:

```java
/*
 * AttributeAnnotationDefault.java    11:35 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code AnnotationDefault} attribute is a variable-length attribute in the
 * {@code attributes} table of certain {@code method_info} structures, namely
 * those representing elements of annotation types. The
 * {@code AnnotationDefault} attribute records the default value for the element
 * represented by the {@code method_info} structure.
 *
 * The {@code AnnotationDefault} attribute has the following format:
 * <pre>
 * AnnotationDefault_attribute {
 *    u2            attribute_name_index;
 *    u4            attribute_length;
 *
 *    element_value default_value;
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.22">
 * VM Spec: The AnnotationDefault attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class AnnotationDefault_attribute extends attribute_info {

    /**
     * The {@link #default_value} item represents the default value of the
     * annotation type element whose default value is represented by this
     * AnnotationDefault attribute.
     */
    public final Annotation.element_value default_value;

    AnnotationDefault_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        this.default_value = new Annotation.element_value(posDataInputStream);
        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        DefaultMutableTreeNode defaultValueNode = this.addNode(parentNode,
                super.startPos + 6,
                this.getLength() - 6,
                "default_value",
                "the default value of the annotation interface element represented by the method_info structure enclosing this AnnotationDefault attribute",
                "msg_attr_AnnotationDefault__default_value",
                Icons.Data
        );
        this.default_value.generateTreeNode(defaultValueNode, classFile);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_AnnotationDefault";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/BootstrapMethods_attribute.java`:

```java
/*
 * AttributeBootstrapMethods.java    11:41 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_MethodHandle_info;
import org.binaryinternals.format.classfile.constant.cp_info.ConstantType;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code BootstrapMethods} attribute is a variable-length attribute in the
 * {@code attributes} table of a {@code ClassFile} structure. The
 * {@code BootstrapMethods} attribute records bootstrap method specifiers
 * referenced by {@code invokedynamic} instructions.
 *
 * <pre>
 * BootstrapMethods_attribute {
 *     u2 attribute_name_index;
 *     u4 attribute_length;
 *     u2 num_bootstrap_methods;
 *     {   u2 bootstrap_method_ref;
 *         u2 num_bootstrap_arguments;
 *         u2 bootstrap_arguments[num_bootstrap_arguments];
 *     } bootstrap_methods[num_bootstrap_methods];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 7
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.23">
 * VM Spec: The BootstrapMethods Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class BootstrapMethods_attribute extends attribute_info {

    /**
     * Determines the number of bootstrap method specifiers in the
     * {@link #bootstrap_methods} array.
     */
    public final u2 num_bootstrap_methods;

    /**
     * Each entry in the {@link #bootstrap_methods} table contains an index to a
     * {@link CONSTANT_MethodHandle_info} structure which specifies a bootstrap
     * method, and a sequence (perhaps empty) of indexes to static arguments for
     * the bootstrap method.
     */
    public final bootstrap_method[] bootstrap_methods;

    BootstrapMethods_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws java.io.IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.num_bootstrap_methods = new u2(posDataInputStream);
        if (this.num_bootstrap_methods.value > 0) {
            this.bootstrap_methods = new bootstrap_method[this.num_bootstrap_methods.value];
            for (int i = 0; i < this.num_bootstrap_methods.value; i++) {
                this.bootstrap_methods[i] = new bootstrap_method(posDataInputStream);
            }
        } else {
            this.bootstrap_methods = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat classFile) {
        int startPosMoving = this.getStartPos();
        this.addNode(parentNode,
                startPosMoving + 6,
                u2.LENGTH,
                "num_bootstrap_methods",
                this.num_bootstrap_methods.value,
                "msg_attr_BootstrapMethods__num_bootstrap_methods",
                Icons.Counter
        );

        if (this.bootstrap_methods != null && this.bootstrap_methods.length > 0) {
            DefaultMutableTreeNode bootstrapMethodsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving + 8,
                    this.getLength() - 8,
                    String.format("bootstrap_methods [%d]", this.bootstrap_methods.length),
                    "msg_attr_bootstrap_methods"
            ));
            parentNode.add(bootstrapMethodsNode);

            for (int i = 0; i < this.bootstrap_methods.length; i++) {
                bootstrap_method m = this.bootstrap_methods[i];
                DefaultMutableTreeNode bootstrapMethodNode = this.addNode(bootstrapMethodsNode,
                        m.getStartPos(),
                        m.getLength(),
                        String.valueOf(i + 1),
                        "bootstrap_method",
                        "msg_attr_bootstrap_methods",
                        Icons.Method
                );
                m.generateTreeNode(bootstrapMethodNode, classFile);
            }
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_BootstrapMethods";
    }

    /**
     *
     * <pre>
     * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
     * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings({"java:S101", "java:S116"})
    public static final class bootstrap_method extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * The value of the {@link #bootstrap_method_ref} item must be a valid
         * index into the {@link ClassFile#constant_pool} table, the
         * <code>constant_pool</code> entry at that index must be a
         * {@link CONSTANT_MethodHandle_info} structure
         */
        public final u2 bootstrap_method_ref;

        /**
         * Gives the number of items in the {@link #bootstrap_arguments} array.
         */
        public final u2 num_bootstrap_arguments;

        /**
         * Each entry in the {@link #bootstrap_arguments} array must be a valid
         * index into the {@link ClassFile#constant_pool} table, the
         * <code>constant_pool</code> entry at that index must be loadable (
         * {@link ConstantType#loadable} is <code>true</code>) .
         */
        public final u2[] bootstrap_arguments;

        private bootstrap_method(final PosDataInputStream posDataInputStream) throws IOException {
            super.startPos = posDataInputStream.getPos();

            this.bootstrap_method_ref = new u2(posDataInputStream);
            this.num_bootstrap_arguments = new u2(posDataInputStream);
            if (this.num_bootstrap_arguments.value > 0) {
                this.bootstrap_arguments = new u2[this.num_bootstrap_arguments.value];
                for (int i = 0; i < this.num_bootstrap_arguments.value; i++) {
                    this.bootstrap_arguments[i] = new u2(posDataInputStream);
                }
            } else {
                this.bootstrap_arguments = null;
            }

            super.length = posDataInputStream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.bootstrap_method_ref.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "bootstrap_method_ref",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "bootstrap method ref", classFile.getCPDescription(cpIndex)),
                    "msg_attr_bootstrap_methods__bootstrap_method_ref",
                    Icons.Offset
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "num_bootstrap_arguments",
                    this.num_bootstrap_arguments.value,
                    "msg_attr_bootstrap_methods__num_bootstrap_arguments",
                    Icons.Counter
            );
            startPosMoving += u2.LENGTH;

            if (this.bootstrap_arguments != null && this.bootstrap_arguments.length > 0) {
                DefaultMutableTreeNode bootstrapArguments = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.bootstrap_arguments.length * u2.LENGTH,
                        String.format("bootstrap_arguments [%d]", this.bootstrap_arguments.length),
                        MESSAGES.getString("msg_attr_bootstrap_methods__bootstrap_arguments")
                ));
                parentNode.add(bootstrapArguments);

                for (int i = 0; i < this.bootstrap_arguments.length; i++) {
                    int argCpIndex = this.bootstrap_arguments[i].value;
                    this.addNode(bootstrapArguments,
                            startPosMoving,
                            u2.LENGTH,
                            String.format("argument %d", i + 1),
                            String.format(TEXT_CPINDEX_VALUE, argCpIndex, "argument value", classFile.getCPDescription(argCpIndex)),
                            "msg_attr_annotation__element_value_pairs",
                            Icons.Parameter
                    );
                    startPosMoving += u2.LENGTH;
                }
            }
        } // End of generateTreeNode()
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Bridge_attribute.java`:

```java
/*
 * Scala_attribute.java    00:02, August 15, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code Bridge} attribute.
 *
 * The {@code Bridge} attribute has the following format:
 * <pre>
 *    Bridge_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *    }
 * </pre>
 *
 * The following classes has this attribute:
 * <pre>
 *   apache-hive-3.1.2-bin/lib/hive-druid-handler-3.1.2.jar/org/skife/jdbi/org/antlr/runtime/UnbufferedTokenStream.class
 *   netbeans-12.0/ide/modules/ext/antlr-runtime-3.4.jar/org/antlr/runtime/UnbufferedTokenStream.class
 *   sonarqube-8.4.2.36762/extensions/plugins/sonar-scm-svn-plugin-1.10.0.1917.jar/org/antlr/runtime/UnbufferedTokenStream.class
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.4
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Bridge_attribute extends attribute_info {

    public static final int LENGTH = 0;

    Bridge_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of Deprecated is not %d, it is %d.", LENGTH, this.attribute_length.value));
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        // Nothing to add
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Bridge";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ClassesCount.java`:

```java
/*
 * Classes_attribute.java    11:21 AM, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_Class_info;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * Attribute with {@link #number_of_classes} and {@link #classes}. The attribute has the following format:
 *
 * <pre>
 *    XXXX_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 number_of_classes;
 *        u2 classes[number_of_classes];
 *    }
 * </pre>
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from JVM spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116"})
public abstract class ClassesCount extends attribute_info {

    /**
     * The value of the number_of_classes item indicates the number of entries
     * in the {@link #classes}table.
     */
    public final u2 number_of_classes;

    /**
     * Each value in the classes array must be a valid index into the
     * {@link ClassFile#constant_pool} table. The
     * {@link ClassFile#constant_pool} entry at that index must be a
     * {@link CONSTANT_Class_info} structure
     */
    public final u2[] classes;

    ClassesCount(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.number_of_classes = new u2(posDataInputStream);
        if (this.number_of_classes.value > 0) {
            this.classes = new u2[this.number_of_classes.value];
            for (int i = 0; i < this.number_of_classes.value; i++) {
                this.classes[i] = new u2(posDataInputStream);
            }
        } else {
            this.classes = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "number_of_classes", this.number_of_classes.value,
                this.getMessageKey_4_number_of_classes(), Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.number_of_classes.value > 0) {
            final DefaultMutableTreeNode numbersNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    u2.LENGTH * this.number_of_classes.value,
                    String.format("classes [%d]", this.number_of_classes.value),
                    this.getMessageKey_4_classes()
            ));
            parentNode.add(numbersNode);

            for (int i = 0; i < this.classes.length; i++) {
                int classIndex = this.classes[i].value;
                this.addNode(numbersNode,
                        startPosMoving + i * u2.LENGTH,
                        u2.LENGTH,
                        String.format("class %d", i + 1),
                        String.format(TEXT_CPINDEX_VALUE, classIndex, "class", ((ClassFile)classFile).getCPDescription(classIndex)),
                        this.getMessageKey_4_classes(),
                        Icons.Class
                );
            }
        }
    }

    /**
     * Get message key for {@link #number_of_classes}.
     *
     * @return Message key for {@link #number_of_classes}
     *
     * @see NestMembers_attribute
     * @see PermittedSubclasses_attribute
     */
    abstract String getMessageKey_4_number_of_classes();

    /**
     * Get message key for {@link #classes}.
     *
     * @return Message key for {@link #classes}
     *
     * @see NestMembers_attribute
     * @see PermittedSubclasses_attribute
     */
    abstract String getMessageKey_4_classes();
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Code_attribute.java`:

```java
/*
 * AttributeCode.java    5:09 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.Opcode;
import org.binaryinternals.format.classfile.constant.cp_info;
import org.binaryinternals.format.classfile.u2;
import org.binaryinternals.format.classfile.u4;

/**
 * The class for the {@code Code} attribute. The {@code Code} attribute has the
 * following format:
 *
 * <pre>
 *    Code_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 max_stack;
 *        u2 max_locals;
 *        u4 code_length;
 *        u1 code[code_length];
 *        u2 exception_table_length;
 *        {
 *                u2 start_pc;
 *                u2 end_pc;
 *                u2 handler_pc;
 *                u2 catch_type;
 *        } exception_table[exception_table_length];
 *        u2 attributes_count;
 *        attribute_info attributes[attributes_count];
 *    }
 * </pre>
 *
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.3">
 * VM Spec: The Code Attribute
 * </a>
 *
 * <pre>
 * java:S101  - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * java:S116  - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S1104", "java:S116"})
public class Code_attribute extends attribute_info {

    public static final String ATTRIBUTE_CODE_NODE = "code";
    public static final String ATTRIBUTE_CODE_VALUE = "byte codes";
    public static final String ATTRIBUTE_CODE_TEXT = String.format("%s: %s", ATTRIBUTE_CODE_NODE, ATTRIBUTE_CODE_VALUE);

    public final u2 max_stack;
    public final u2 max_locals;

    /**
     * The value of the {@link #code_length} item gives the number of bytes in
     * the code array for this method.
     *
     * The value of {@link #code_length} must be greater than <code>zero</code>
     * (as the code array must not be empty) and less than <code>65536</code>.
     */
    public final u4 code_length;
    public final byte[] code;
    public final u2 exception_table_length;
    public exception_table[] exceptionTable;
    public final u2 attributes_count;
    public final attribute_info[] attributes;

    Code_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream, final cp_info[] cp) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        int i;

        this.max_stack = new u2(posDataInputStream);
        this.max_locals = new u2(posDataInputStream);
        this.code_length = new u4(posDataInputStream);
        this.code = new byte[this.code_length.value];
        int readBytes = posDataInputStream.read(this.code);
        if (readBytes != this.code_length.value) {
            throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.code_length.value, readBytes));
        }

        this.exception_table_length = new u2(posDataInputStream);
        if (this.exception_table_length.value > 0) {
            this.exceptionTable = new exception_table[this.exception_table_length.value];
            for (i = 0; i < this.exception_table_length.value; i++) {
                this.exceptionTable[i] = new exception_table(posDataInputStream);
            }
        }

        this.attributes_count = new u2(posDataInputStream);
        if (this.attributes_count.value > 0) {
            this.attributes = new attribute_info[this.attributes_count.value];
            for (i = 0; i < this.attributes_count.value; i++) {
                this.attributes[i] = attribute_info.parse(posDataInputStream, cp);
            }
        } else {
            this.attributes = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the {@link #code} parse result. This method will return an empty list
     * if {@link #code} is <code>null</code>.
     *
     * @return Parsed {@link Opcode} list
     */
    public List<Opcode.InstructionParsed> parseCode() {
        if (this.code != null && this.code.length > 0) {
            return Opcode.parseCode(this.code);
        } else {
            return new ArrayList<>();
        }
    }

    /**
     * Get the value of {@code exception_table}[{@code index}].
     *
     * @param index Index of the exception table
     * @return The value of {@code exception_table}[{@code index}]
     */
    public exception_table getExceptionTable(final int index) {
        exception_table et = null;
        if (this.exceptionTable != null) {
            et = this.exceptionTable[index];
        }
        return et;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat classFile) {
        int i;
        final int codeLength = this.code_length.value;
        DefaultMutableTreeNode treeNodeExceptionTableItem;
        DefaultMutableTreeNode treeNodeAttribute;
        DefaultMutableTreeNode treeNodeAttributeItem;

        this.addNode(parentNode,
                super.startPos + 6,
                2,
                "max_stack",
                this.max_stack.value,
                "msg_attr_Code__max_stack",
                Icons.Max
        );
        this.addNode(parentNode,
                super.startPos + 8,
                2,
                "max_locals",
                this.max_locals.value,
                "msg_attr_Code__max_locals",
                Icons.Max
        );
        this.addNode(parentNode,
                super.startPos + 10,
                4,
                "code_length",
                this.code_length.value,
                "msg_attr_Code__code_length",
                Icons.Length
        );
        this.addNode(parentNode,
                super.startPos + 14,
                codeLength,
                ATTRIBUTE_CODE_NODE,
                ATTRIBUTE_CODE_VALUE,
                "msg_attr_Code__code",
                Icons.Data
        );
        this.addNode(parentNode,
                super.startPos + 14 + codeLength,
                2,
                "exception_table_length",
                this.exception_table_length.value,
                "msg_attr_exception_table_length",
                Icons.Length
        );

        // Add exception table
        if (this.exception_table_length.value > 0) {
            DefaultMutableTreeNode treeNodeExceptionTable = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 14 + codeLength + 2,
                    exception_table.LENGTH * this.exception_table_length.value,
                    String.format("exception_table [%d]", this.exception_table_length.value),
                    MESSAGES.getString("msg_attr_exception_table")
            ));

            Code_attribute.exception_table et;
            for (i = 0; i < this.exception_table_length.value; i++) {
                et = this.getExceptionTable(i);
                treeNodeExceptionTableItem = this.addNode(treeNodeExceptionTable,
                        et.getStartPos(),
                        et.getLength(),
                        String.valueOf(i + 1),
                        "exception_table",
                        "msg_attr_exception_table",
                        Icons.Exception
                );
                et.generateTreeNode(treeNodeExceptionTableItem, classFile);
            }

            parentNode.add(treeNodeExceptionTable);
        }

        // Add attributes
        final int attrCount = this.attributes_count.value;
        final int attrStartPos = super.startPos + 14 + codeLength + 2 + this.exception_table_length.value * exception_table.LENGTH;
        this.addNode(parentNode,
                attrStartPos,
                2,
                FIELD_ATTR_COUNT,
                attrCount,
                "msg_attr_Code_attributes_count",
                Icons.Counter
        );
        if (attrCount > 0) {
            int attrLength = 0;
            for (attribute_info codeAttr : this.attributes) {
                attrLength += codeAttr.getLength();
            }

            treeNodeAttribute = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    attrStartPos + 2,
                    attrLength,
                    String.format(FIELD_ATTRS, attrCount),
                    MESSAGES.getString("msg_attr_Code_attributes")
            ));

            for (i = 0; i < attrCount; i++) {
                attribute_info attr = this.attributes[i];
                treeNodeAttributeItem = this.addNode(treeNodeAttribute,
                        attr.getStartPos(),
                        attr.getLength(),
                        String.valueOf(i + 1),
                        attr.getName(),
                        attr.getMessageKey(),
                        Icons.Annotations
                );
                attr.generateTreeNodeCommon(treeNodeAttributeItem, (ClassFile) classFile);
            }

            parentNode.add(treeNodeAttribute);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Code";
    }

    /**
     * The {@code exception_table} structure in {@code Code} attribute.
     *
     * @author Amos Shi
     */
    public static final class exception_table extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = 8;
        public final u2 start_pc;
        public final u2 end_pc;
        public final u2 handler_pc;

        /**
         * If the value of the catch_type item is nonzero, it must be a valid
         * index into the constant_pool table. The constant_pool entry at that
         * index must be a CONSTANT_Class_info structure representing a class of
         * exceptions that this exception handler is designated to catch. The
         * exception handler will be called only if the thrown exception is an
         * instance of the given class or one of its subclasses.
         *
         * If the value of the catch_type item is zero, this exception handler
         * is called for all exceptions.
         */
        public final u2 catch_type;

        private exception_table(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();
            this.length = LENGTH;

            this.start_pc = new u2(posDataInputStream);
            this.end_pc = new u2(posDataInputStream);
            this.handler_pc = new u2(posDataInputStream);
            this.catch_type = new u2(posDataInputStream);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final int startPosMoving = super.getStartPos();

            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "start_pc",
                    this.start_pc.value,
                    "msg_attr_exception_table__start_end_pc",
                    Icons.Offset
            );
            this.addNode(parentNode,
                    startPosMoving + 2,
                    u2.LENGTH,
                    "end_pc",
                    this.end_pc.value,
                    "msg_attr_exception_table__start_end_pc",
                    Icons.Offset
            );
            this.addNode(parentNode,
                    startPosMoving + 4,
                    u2.LENGTH,
                    "handler_pc",
                    this.handler_pc.value,
                    "msg_attr_exception_table__handler_pc",
                    Icons.Offset
            );

            final int catchType = this.catch_type.value;
            String catchTypeDesc = (catchType == 0) ? "" : " - " + ((ClassFile) fileFormat).getCPDescription(catchType);
            this.addNode(parentNode,
                    startPosMoving + 6,
                    2,
                    "catch_type",
                    catchType + catchTypeDesc,
                    "msg_attr_exception_table__catch_type",
                    Icons.Kind
            );
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ConstantValue_attribute.java`:

```java
/*
 * AttributeConstantValue.java    5:08 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code ConstantValue} attribute. The {@code ConstantValue}
 * attribute has the following format:
 *
 * <pre>
 *    ConstantValue_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 constantvalue_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.2">
 * VM Spec: The ConstantValue Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ConstantValue_attribute extends attribute_info {

    /**
     * The {@link ClassFile#constant_pool} entry at that
     * {@link #constantvalue_index} gives the constant value represented by this
     * attribute.
     */
    public final u2 constantvalue_index;

    ConstantValue_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != 2) {
            throw new FileFormatException(String.format("The attribute_length of AttributeConstantValue is not 2, it is %d.", this.attribute_length.value));
        }
        this.constantvalue_index = new u2(posDataInputStream);

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int index = this.constantvalue_index.value;
        this.addNode(parentNode,
                super.startPos + 6,
                u2.LENGTH,
                "constantvalue_index",
                String.format(TEXT_CPINDEX_VALUE, index, "constant value", ((ClassFile) classFile).getCPDescription(index)),
                "msg_attr_ConstantValue__constantvalue_index",
                Icons.Constant
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ConstantValue";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Deprecated_attribute.java`:

```java
/*
 * AttributeDeprecated.java    5:37 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code Deprecated} attribute. The {@code Deprecated}
 * attribute has the following format:
 *
 * <pre>
 *    Deprecated_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.1
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.15">
 * VM Spec: The Deprecated Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Deprecated_attribute extends attribute_info {

    public static final int LENGTH = 0;

    Deprecated_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of Deprecated is not %d, it is %d.", LENGTH, this.attribute_length.value));
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        // Nothing to add
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Deprecated";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/EnclosingMethod_attribute.java`:

```java
/*
 * AttributeEnclosingMethod.java    10:48 AM, April 28, 2014
 *
 * Copyright  2004, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * An optional fixed-length attribute in the attributes table of a
 * {@code ClassFile} structure. A {@code class} must have an
 * {@code EnclosingMethod} attribute if and only if it is a local class or an
 * anonymous class. A A {@code class} may have no more than one
 * {@code EnclosingMethod} attribute.
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.7">
 * VM Spec: The EnclosingMethod Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class EnclosingMethod_attribute extends attribute_info {

    /**
     * Representing the innermost class that encloses the declaration of the
     * current class.
     */
    public final u2 class_index;
    /**
     * If the current class is not immediately enclosed by a method or
     * constructor, then the value of the <code>method_index</code> item must be
     * zero. Otherwise, the value of the <code>method_index</code> item must be
     * a valid index into the <code>constant_pool</code> table. The
     * <code>constant_pool</code> entry at that index must be a
     * <code>CONSTANT_NameAndType_info</code> structure representing the name
     * and type of a method in the class referenced by the {@link #class_index}
     * attribute above.
     */
    public final u2 method_index;

    EnclosingMethod_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.class_index = new u2(posDataInputStream);
        this.method_index = new u2(posDataInputStream);

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        ClassFile classFile = (ClassFile) format;
        int startPosMoving = super.startPos + 6;

        int cpIndex = this.class_index.value;
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "class_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "class", classFile.getCPDescription(cpIndex)),
                "msg_attr_EnclosingMethod__class_index", Icons.Index
        );
        startPosMoving += u2.LENGTH;

        final String methodDesc = (this.method_index.value == 0) ? "" : classFile.getCPDescription(this.method_index.value);
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "method_index", String.format(TEXT_CPINDEX_VALUE, this.method_index.value, "method", methodDesc),
                "msg_attr_EnclosingMethod__method_index", Icons.Index
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_EnclosingMethod";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Exceptions_attribute.java`:

```java
/*
 * AttributeExceptions.java    5:18 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_Class_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code Exceptions} attribute. The {@code Exceptions}
 * attribute has the following format:
 *
 * <pre>
 *    Exceptions_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 number_of_exceptions;
 *        u2 exception_index_table[number_of_exceptions];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.5">
 * VM Spec: The Exceptions Attribute
 * </a>
 *
 * <pre>
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class Exceptions_attribute extends attribute_info {

    /**
     * The value of the {@link #number_of_exceptions} item indicates the number
     * of entries in the {@link #exception_index_table}.
     */
    public final u2 number_of_exceptions;
    /**
     * Each value in the {@link #exception_index_table} array must be a valid
     * index into the {@link ClassFile#constant_pool} table. The
     * {@link ClassFile#constant_pool} entry at that <code>index</code> must be
     * a {@link CONSTANT_Class_info} structure representing a class type that
     * this method is declared to throw.
     */
    private final u2[] exception_index_table;

    Exceptions_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.number_of_exceptions = new u2(posDataInputStream);
        if (this.number_of_exceptions.value > 0) {
            this.exception_index_table = new u2[this.number_of_exceptions.value];
            for (int i = 0; i < this.number_of_exceptions.value; i++) {
                this.exception_index_table[i] = new u2(posDataInputStream);
            }
        } else {
            this.exception_index_table = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the value of {@code exception_index_table}[{@code index}].
     *
     * @param index Index of the exception table
     * @return The value of {@code exception_index_table}[{@code index}] or
     * <code>-1</code> if <code>index</code> is not valid
     */
    public int getExceptionIndexTableItem(final int index) {
        int i = -1;
        if (this.exception_index_table != null) {
            i = this.exception_index_table[index].value;
        }

        return i;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int i;
        final int numOfExceptions = this.number_of_exceptions.value;

        this.addNode(parentNode,
                startPos + 6,
                u2.LENGTH,
                "number_of_exceptions",
                numOfExceptions,
                "msg_attr_Exceptions__number_of_exceptions",
                Icons.Counter
        );
        if (numOfExceptions > 0) {
            DefaultMutableTreeNode treeNodeExceptions = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPos + 8,
                    numOfExceptions * u2.LENGTH,
                    String.format("exceptions [%d]", numOfExceptions),
                    MESSAGES.getString("msg_attr_Exceptions__exception_index_table")
            ));

            for (i = 0; i < numOfExceptions; i++) {
                int cpIndex = this.getExceptionIndexTableItem(i);
                this.addNode(treeNodeExceptions,
                        startPos + 10 + i * u2.LENGTH,
                        u2.LENGTH,
                        String.format("exception_index_table %d", i + 1),
                        String.format(TEXT_CPINDEX_VALUE, cpIndex, "exception type", ((ClassFile) classFile).getCPDescription(cpIndex)),
                        "msg_attr_Exceptions__exception_index_table",
                        Icons.Exception
                );
            }
            parentNode.add(treeNodeExceptions);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Exceptions";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/InnerClasses_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.AccessFlag;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_Class_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code InnerClasses} attribute. The {@code InnerClasses}
 * attribute has the following format:
 *
 * <pre>
 *    InnerClasses_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 number_of_classes;
 *        {  u2 inner_class_info_index;
 *           u2 outer_class_info_index;
 *           u2 inner_name_index;
 *           u2 inner_class_access_flags;
 *        } classes[number_of_classes];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.1
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.6">
 * VM Spec: The InnerClasses Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class InnerClasses_attribute extends attribute_info {

    public final u2 number_of_classes;
    private final Class[] classes;

    InnerClasses_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.number_of_classes = new u2(posDataInputStream);
        if (this.number_of_classes.value > 0) {
            this.classes = new Class[this.number_of_classes.value];
            for (int i = 0; i < this.number_of_classes.value; i++) {
                this.classes[i] = new Class(posDataInputStream);
            }
        } else {
            this.classes = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the value of {@code classes}[{@code index}].
     *
     * @param index Index of the classes
     * @return The value of {@code classes}[{@code index}]
     */
    public Class getClass(final int index) {
        Class cls = null;
        if (this.classes != null && this.classes.length > index) {
            cls = this.classes[index];
        }

        return cls;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat classFile) {
        int i;
        final int numOfClasses = this.number_of_classes.value;
        DefaultMutableTreeNode treeNodeInnerClass;

        this.addNode(parentNode,
                super.startPos + 6, u2.LENGTH,
                "number_of_classes", numOfClasses,
                "msg_attr_InnerClasses__number_of_classes", Icons.Counter
        );
        if (numOfClasses > 0) {
            treeNodeInnerClass = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 8,
                    this.getClass(numOfClasses - 1).getStartPos() + this.getClass(numOfClasses - 1).getLength() - (startPos + 8),
                    String.format("classes [%d]", numOfClasses),
                    MESSAGES.getString("msg_attr_classes")
            ));

            InnerClasses_attribute.Class cls;
            for (i = 0; i < numOfClasses; i++) {
                cls = this.getClass(i);

                DefaultMutableTreeNode treeNodeInnerClassItem = this.addNode(treeNodeInnerClass,
                        cls.getStartPos(),
                        cls.getLength(),
                        String.format("inner class %d", i + 1),
                        ((ClassFile)classFile).getCPDescription(cls.inner_class_info_index.value),
                        "msg_attr_classes",
                        Icons.Kind
                );
                cls.generateTreeNode(treeNodeInnerClassItem, classFile);
            }

            parentNode.add(treeNodeInnerClass);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_InnerClasses";
    }

    /**
     * The {@code classes} structure in {@code InnerClasses} attribute.
     *
     * @author Amos Shi
     */
    public static final class Class extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * The length of current component.
         */
        public static final int LENGTH = 8;

        /**
         * The value of the {@link inner_class_info_index} item must be a valid
         * index into the {@link ClassFile#constant_pool} table. The
         * {@link ClassFile#constant_pool} entry at that index must be a
         * {@link CONSTANT_Class_info} structure representing <code>C</code>.
         */
        public final u2 inner_class_info_index;
        /**
         * If C is not a member of a class or an interface - that is, if C is a
         * top-level class or interface or a local class or an anonymous class -
         * then the value of the outer_class_info_index item must be zero.
         *
         * Otherwise, the value of the outer_class_info_index item must be a
         * valid index into the constant_pool table, and the entry at that index
         * must be a CONSTANT_Class_info structure representing the class or
         * interface of which C is a member. The value of the
         * outer_class_info_index item must not equal the the value of the
         * inner_class_info_index item.
         */
        public final u2 outer_class_info_index;
        /**
         * If C is anonymous, the value of the inner_name_index item must be
         * zero.
         *
         * Otherwise, the value of the inner_name_index item must be a valid
         * index into the constant_pool table, and the entry at that index must
         * be a CONSTANT_Utf8_info structure that represents the original simple
         * name of C, as given in the source code from which this class file was
         * compiled.
         */
        public final u2 inner_name_index;
        public final u2 inner_class_access_flags;

        private Class(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();
            this.length = LENGTH;

            this.inner_class_info_index = new u2(posDataInputStream);
            this.outer_class_info_index = new u2(posDataInputStream);
            this.inner_name_index = new u2(posDataInputStream);
            this.inner_class_access_flags = new u2(posDataInputStream);
        }

        /**
         * Generate the modifier string from the
         * {@link #inner_class_access_flags} value.
         *
         * @return A string for modifier
         */
        public String getModifiers() {
            return AccessFlag.getInnerClassModifier(this.inner_class_access_flags.value);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            ClassFile classFile = (ClassFile) format;
            final int startPosMoving = this.getStartPos();

            int cpIndex = this.inner_class_info_index.value;

            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "inner_class_info_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "inner class type", ((ClassFile) classFile).getCPDescription(cpIndex)),
                    "msg_attr_classes__inner_class_info_index",
                    Icons.Index
            );

            cpIndex = this.outer_class_info_index.value;
            final String outer_class_info_index_desc = (cpIndex == 0) ? "" : classFile.getCPDescription(cpIndex);
            this.addNode(parentNode,
                    startPosMoving + 2,
                    u2.LENGTH,
                    "outer_class_info_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "outer class type", outer_class_info_index_desc),
                    "msg_attr_classes__outer_class_info_index",
                    Icons.Index
            );

            cpIndex = this.inner_name_index.value;
            final String inner_name_index_desc = (cpIndex == 0) ? "" : classFile.getCPDescription(cpIndex);
            this.addNode(parentNode,
                    startPosMoving + 4,
                    u2.LENGTH,
                    "inner_name_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "inner class name", inner_name_index_desc),
                    "msg_attr_classes__inner_name_index",
                    Icons.Name
            );

            this.addNode(parentNode,
                    startPosMoving + 6,
                    u2.LENGTH,
                    "inner_class_access_flags",
                    BytesTool.getBinaryString(this.inner_class_access_flags.value) + " - " + this.getModifiers(),
                    "msg_attr_classes__inner_class_access_flags",
                    Icons.AccessFlag
            );
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/LineNumberTable_attribute.java`:

```java
/*
 * AttributeLineNumberTable.java    5:28 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code LineNumberTable} attribute. The
 * {@code LineNumberTable} attribute has the following format:
 *
 * <pre>
 *    LineNumberTable_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 line_number_table_length;
 *        {  u2 start_pc;
 *           u2 line_number;
 *        } line_number_table[line_number_table_length];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.12">
 * VM Spec: The LineNumberTable Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class LineNumberTable_attribute extends attribute_info {

    public final u2 line_number_table_length;
    public final line_number_table[] lineNumberTable;

    LineNumberTable_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.line_number_table_length = new u2(posDataInputStream);
        if (this.line_number_table_length.value > 0) {
            this.lineNumberTable = new line_number_table[this.line_number_table_length.value];
            for (int i = 0; i < this.line_number_table_length.value; i++) {
                this.lineNumberTable[i] = new line_number_table(posDataInputStream);
            }
        } else {
            this.lineNumberTable = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the value of {@code line_number_table}[{@code index}].
     *
     * @param index Index of the line number table
     * @return The value of {@code line_number_table}[{@code index}]
     */
    public line_number_table getLineNumberTable(final int index) {
        line_number_table lnt = null;
        if (this.lineNumberTable != null && this.lineNumberTable.length > index) {
            lnt = this.lineNumberTable[index];
        }

        return lnt;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int lnt_length = this.line_number_table_length.value;

        this.addNode(parentNode,
                super.startPos + 6,
                u2.LENGTH,
                "line_number_table_length",
                lnt_length,
                "msg_attr_line_number_table_length",
                Icons.Length
        );

        if (lnt_length > 0) {
            final DefaultMutableTreeNode treeNodeLnt = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 8,
                    lnt_length * 4,
                    "line_number_table [" + lnt_length + "]",
                    MESSAGES.getString("msg_attr_line_number_table")
            ));

            DefaultMutableTreeNode treeNodeLntItem;
            LineNumberTable_attribute.line_number_table lnt;
            for (int i = 0; i < lnt_length; i++) {
                lnt = this.getLineNumberTable(i);

                treeNodeLntItem = this.addNode(treeNodeLnt,
                        lnt.getStartPos(),
                        lnt.getLength(),
                        String.valueOf(i + 1),
                        "line_number_table",
                        "msg_attr_line_number_table",
                        Icons.Row
                );
                lnt.generateTreeNode(treeNodeLntItem, classFile);
            }

            parentNode.add(treeNodeLnt);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_LineNumberTable";
    }

    /**
     * The {@code line_number_table} structure in {@code LineNumberTable}
     * attribute.
     *
     * @author Amos Shi
     * @see LineNumberTable_attribute
     */
    public static final class line_number_table extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = 4;
        public final u2 start_pc;
        public final u2 line_number;

        private line_number_table(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();
            this.length = LENGTH;

            this.start_pc = new u2(posDataInputStream);
            this.line_number = new u2(posDataInputStream);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final int startPosMoving = this.getStartPos();
            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "start_pc",
                    this.start_pc.value,
                    "msg_attr_line_number_table__start_pc",
                    Icons.Offset
            );
            this.addNode(parentNode,
                    startPosMoving + u2.LENGTH,
                    u2.LENGTH,
                    "line_number",
                    this.line_number.value,
                    "msg_attr_line_number_table__line_number",
                    Icons.Data
            );
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/LocalVariableTable_attribute.java`:

```java
/*
 * AttributeLocalVariableTable.java    5:33 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code LocalVariableTable} attribute. The
 * {@code LocalVariableTable} attribute has the following format:
 *
 * <pre>
 *    LocalVariableTable_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 local_variable_table_length;
 *        {   u2 start_pc;
 *            u2 length;
 *            u2 name_index;
 *            u2 descriptor_index;
 *            u2 index;
 *        } local_variable_table[local_variable_table_length];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.13">
 * VM Spec: The LocalVariableTable Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class LocalVariableTable_attribute extends attribute_info {

    public final u2 local_variable_table_length;
    private final local_variable_table[] localVariableTable;

    LocalVariableTable_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.local_variable_table_length = new u2(posDataInputStream);
        if (this.local_variable_table_length.value > 0) {
            this.localVariableTable = new local_variable_table[this.local_variable_table_length.value];
            for (int i = 0; i < this.local_variable_table_length.value; i++) {
                this.localVariableTable[i] = new local_variable_table(posDataInputStream);
            }
        } else {
            this.localVariableTable = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the value of {@code local_variable_table}[{@code index}].
     *
     * @param index Index of the local variable table
     * @return The value of {@code local_variable_table}[{@code index}]
     */
    public local_variable_table getLocalVariableTable(final int index) {
        local_variable_table lvt = null;
        if (this.localVariableTable != null && this.localVariableTable.length > 0) {
            lvt = this.localVariableTable[index];
        }

        return lvt;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat classFile) {
        final int lvt_length = this.local_variable_table_length.value;
        this.addNode(parentNode,
                super.startPos + 6,
                u2.LENGTH,
                "local_variable_table_length",
                lvt_length,
                "msg_attr_local_variable_table_length",
                Icons.Length
        );

        if (lvt_length > 0) {
            final DefaultMutableTreeNode treeNodeLvt = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 8,
                    lvt_length * LocalVariableTable_attribute.local_variable_table.LENGTH,
                    "local_variable_table [" + lvt_length + "]",
                    MESSAGES.getString("msg_attr_local_variable_table")
            ));

            for (int i = 0; i < lvt_length; i++) {
                LocalVariableTable_attribute.local_variable_table lvt = this.getLocalVariableTable(i);
                DefaultMutableTreeNode treeNodeLvtItem = this.addNode(treeNodeLvt,
                        lvt.getStartPos(),
                        lvt.getLength(),
                        String.format("%05d", i + 1),
                        "local_variable_table",
                        "msg_attr_local_variable_table",
                        Icons.Row
                );
                lvt.generateTreeNode(treeNodeLvtItem, classFile);
            }

            parentNode.add(treeNodeLvt);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_LocalVariableTable";
    }

    /**
     * The {@code local_variable_table} structure in {@code LocalVariableTable}
     * attribute.
     *
     * @author Amos Shi
     * @see LocalVariableTable_attribute
     */
    public static final class local_variable_table extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = 10;
        /**
         * The given local variable must have a value at indices into the
         * {@link Code_attribute#code} array in the interval
         * <code>[start_pc, start_pc + length)</code>, that is, between
         * <code>start_pc</code> inclusive and <code>start_pc + length</code>
         * exclusive.
         */
        public final u2 start_pc;
        /**
         * See {@link local_variable_table#start_pc}.
         */
        public final u2 length_code;
        /**
         * Representing a valid unqualified name denoting a local variable.
         */
        public final u2 name_index;
        /**
         * Representing a field descriptor which encodes the type of a local
         * variable in the source program.
         */
        public final u2 descriptor_index;
        /**
         * The given local variable must be at {@link #index} in the local
         * variable array of the current frame.
         * <p>
         * If the local variable at {@link #index} is of type
         * <code>double</code> or <code>long</code>, it occupies both
         * <code>index</code> and <code>index + 1</code>.
         * </p>
         */
        public final u2 index;

        private local_variable_table(final PosDataInputStream posDataInputStream) throws IOException {
            super.startPos = posDataInputStream.getPos();
            super.length = LENGTH;

            this.start_pc = new u2(posDataInputStream);
            this.length_code = new u2(posDataInputStream);
            this.name_index = new u2(posDataInputStream);
            this.descriptor_index = new u2(posDataInputStream);
            this.index = new u2(posDataInputStream);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final int pos = this.getStartPos();
            final ClassFile classFile = (ClassFile) fileFormat;
            int cpIndex;

            this.addNode(parentNode,
                    pos,
                    u2.LENGTH,
                    "start_pc",
                    this.start_pc.value,
                    "msg_attr_local_variable_table__start_pc_length",
                    Icons.Offset
            );

            this.addNode(parentNode,
                    pos + 2,
                    u2.LENGTH,
                    "length",
                    this.length_code.value,
                    "msg_attr_local_variable_table__start_pc_length",
                    Icons.Length
            );

            cpIndex = this.name_index.value;
            this.addNode(parentNode,
                    pos + 4,
                    u2.LENGTH,
                    "name_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "name", classFile.getCPDescription(cpIndex)),
                    "msg_attr_local_variable_table__name_index",
                    Icons.Name
            );

            cpIndex = this.descriptor_index.value;
            this.addNode(parentNode,
                    pos + 6,
                    u2.LENGTH,
                    "descriptor_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "descriptor", classFile.getCPDescription(cpIndex)),
                    "msg_attr_local_variable_table__descriptor_index",
                    Icons.Descriptor
            );

            this.addNode(parentNode,
                    pos + 8,
                    u2.LENGTH,
                    "index",
                    this.index.value,
                    "msg_attr_local_variable_table__index",
                    Icons.Index
            );
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/LocalVariableTypeTable_attribute.java`:

```java
/*
 * AttributeLocalVariableTypeTable.java    11:08 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u2;
import static org.binaryinternals.format.classfile.attribute.LocalVariableTable_attribute.local_variable_table.LENGTH;

/**
 * The {@code LocalVariableTypeTable} attribute is an optional variable-length
 * attribute in the {@code attributes} table of a {@code Code} attribute; It may
 * be used by debuggers to determine the value of a given local variable during
 * the execution of a method.
 *
 * The {@code LocalVariableTypeTable} attribute has the following format:
 *
 * <pre>
 * LocalVariableTypeTable_attribute {
 *    u2 attribute_name_index;
 *    u4 attribute_length;
 *
 *    u2 local_variable_type_table_length;
 *    {   u2 start_pc;
 *        u2 length;
 *        u2 name_index;
 *        u2 signature_index;
 *        u2 index;
 *    } local_variable_type_table[local_variable_type_table_length];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.14">
 * VM Spec: The LocalVariableTypeTable Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class LocalVariableTypeTable_attribute extends attribute_info {

    private static final String MSG_ATTR_LVTT = "msg_attr_LocalVariableTypeTable";

    /**
     * Indicates the number of entries in the {@link #local_variable_type_table}
     * array.
     */
    public final u2 local_variable_type_table_length;
    /**
     * Indicates a range of code array offsets within which a local variable has
     * a value.
     */
    public final local_variable_type_table[] local_variable_type_table;

    LocalVariableTypeTable_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws java.io.IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.local_variable_type_table_length = new u2(posDataInputStream);
        if (this.local_variable_type_table_length.value > 0) {
            this.local_variable_type_table = new local_variable_type_table[this.local_variable_type_table_length.value];
            for (int i = 0; i < this.local_variable_type_table_length.value; i++) {
                this.local_variable_type_table[i] = new local_variable_type_table(posDataInputStream);
            }
        } else {
            this.local_variable_type_table = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        final int tableLen = this.local_variable_type_table_length.value;
        this.addNode(parentNode,
                super.startPos + 6, u2.LENGTH,
                "local_variable_type_table_length", tableLen,
                "msg_attr_local_variable_type_table_length", Icons.Length
        );

        if (tableLen > 0) {
            DefaultMutableTreeNode lvttNodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 8,
                    tableLen * LENGTH,
                    String.format("local_variable_type_table [%d]", tableLen),
                    MESSAGES.getString(MSG_ATTR_LVTT)
            ));
            parentNode.add(lvttNodes);

            for (int i = 0; i < tableLen; i++) {
                local_variable_type_table item = this.local_variable_type_table[i];
                DefaultMutableTreeNode lvttNode = this.addNode(lvttNodes,
                        item.getStartPos(),
                        item.getLength(),
                        String.format("%05d", i + 1),
                        "local_variable_type_table",
                        MSG_ATTR_LVTT,
                        Icons.Row
                );
                item.generateTreeNode(lvttNode, format);
            }
        }
    }

    @Override
    public String getMessageKey() {
        return MSG_ATTR_LVTT;
    }

    /**
     * Each entry in the local_variable_type_table array indicates a range of
     * code array offsets within which a local variable has a value. It also
     * indicates the index into the local variable array of the current frame at
     * which that local variable can be found. Each entry must contain the
     * following five items (the 5 instance fields of current class).
     */
    public static final class local_variable_type_table extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = 10;
        public final u2 start_pc;
        public final u2 lvtt_length;
        /**
         * Representing a valid unqualified name denoting a local variable.
         */
        public final u2 name_index;
        /**
         * Representing a field signature which encodes the type of a local
         * variable in the source program.
         */
        public final u2 signature_index;
        /**
         * The given local variable must be at {@link index} in the local
         * variable array of the current frame.
         */
        public final u2 index;

        protected local_variable_type_table(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            super.startPos = posDataInputStream.getPos();
            super.length = LENGTH;

            this.start_pc = new u2(posDataInputStream);
            this.lvtt_length = new u2(posDataInputStream);
            this.name_index = new u2(posDataInputStream);
            this.signature_index = new u2(posDataInputStream);
            this.index = new u2(posDataInputStream);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            final int itemStartPos = this.getStartPos();
            int cpIndex;

            this.addNode(parentNode,
                    itemStartPos,
                    u2.LENGTH,
                    "start_pc",
                    this.start_pc.value,
                    "msg_attr_local_variable_type_table__start_pc_length",
                    Icons.Offset
            );
            this.addNode(parentNode,
                    itemStartPos + 2,
                    u2.LENGTH,
                    "length",
                    this.lvtt_length.value,
                    "msg_attr_local_variable_type_table__start_pc_length",
                    Icons.Length
            );

            cpIndex = this.name_index.value;
            this.addNode(parentNode,
                    itemStartPos + 4,
                    u2.LENGTH,
                    "name_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "name", classFile.getCPDescription(cpIndex)),
                    "msg_attr_local_variable_type_table__name_index",
                    Icons.Name
            );

            cpIndex = this.signature_index.value;
            this.addNode(parentNode,
                    itemStartPos + 6,
                    u2.LENGTH,
                    "signature_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "signature", classFile.getCPDescription(cpIndex)),
                    "msg_attr_local_variable_type_table__signature_index",
                    Icons.Descriptor
            );

            this.addNode(parentNode,
                    itemStartPos + 8,
                    u2.LENGTH,
                    "index",
                    this.index.value,
                    "msg_attr_local_variable_type_table__index",
                    Icons.Index
            );
        }
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/MethodParameters_attribute.java`:

```java
/*
 * AttributeMethodParameters.java    5:37 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.AccessFlag;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code MethodParameters} attribute. The
 * {@code MethodParameters} attribute has the following format:
 *
 * Parameter names aren’t compiled into the byte code by default. Hence we have
 * to add a compiler switch to enable named parameters:
 * <pre>
 *   javac -parameters
 * </pre>
 *
 * The MethodParameters attribute has the following format:
 * <pre>
 *    MethodParameters_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u1 parameters_count;
 *        {   u2 name_index;
 *            u2 access_flags;
 *        } parameters[parameters_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 8
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.24">
 * VM Spec: The MethodParameters Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class MethodParameters_attribute extends attribute_info {

    /**
     * The value of the parameters_count item indicates the number of parameter
     * descriptors in the method descriptor referenced by the descriptor_index
     * of the attribute's enclosing method_info structure.
     */
    public final u1 parameters_count;
    public final Parameter[] parameters;

    MethodParameters_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.parameters_count = new u1(posDataInputStream, true);
        if (this.parameters_count.value > 0) {
            this.parameters = new Parameter[this.parameters_count.value];
            for (int i = 0; i < this.parameters_count.value; i++) {
                this.parameters[i] = new Parameter(posDataInputStream);
            }
        } else {
            this.parameters = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        this.addNode(parentNode,
                startPosMoving, u1.LENGTH,
                "parameters_count",
                this.parameters_count.value,
                "msg_attr_MethodParameters__parameters_count",
                Icons.Counter
        );
        startPosMoving += u1.LENGTH;

        if (this.parameters == null || this.parameters.length < 1) {
            return;
        }

        DefaultMutableTreeNode parametersNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPosMoving,
                this.parameters.length * Parameter.LENGTH,
                String.format("parameters [%d]", this.parameters.length),
                MESSAGES.getString("msg_attr_MethodParameters__parameters_count")
        ));
        parentNode.add(parametersNode);

        for (int i = 0; i < this.parameters.length; i++) {
            DefaultMutableTreeNode parameterNode = this.addNode(parametersNode,
                    startPosMoving,
                    Parameter.LENGTH,
                    String.format("paramter %d", i + 1),
                    ((ClassFile) classFile).getCPDescription(this.parameters[i].name_index.value),
                    "msg_attr_parameters",
                    Icons.Parameter
            );
            this.parameters[i].generateTreeNode(parameterNode, classFile);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_MethodParameters";
    }

    public static final class Parameter extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = u2.LENGTH + u2.LENGTH;

        /**
         * The value of the name_index item must either be zero or a valid index
         * into the constant_pool table. If the value of the name_index item is
         * zero, then this parameters element indicates a formal parameter with
         * no name. If the value of the name_index item is nonzero, the
         * constant_pool entry at that index must be a CONSTANT_Utf8_info
         * structure representing a valid unqualified name denoting a formal
         * parameter.
         */
        public final u2 name_index;
        /**
         * The value of the access_flags item is as follows: 0x0010 (ACC_FINAL),
         * 0x1000 (ACC_SYNTHETIC), 0x8000 (ACC_MANDATED).
         *
         * @see AccessFlag#ForMethodParameters
         */
        public final u2 access_flags;

        private Parameter(final PosDataInputStream posDataInputStream) throws IOException {
            super.startPos = posDataInputStream.getPos();
            this.name_index = new u2(posDataInputStream);
            this.access_flags = new u2(posDataInputStream);
            super.length = posDataInputStream.getPos() - super.startPos;
        }

        public String getAccessFlagsText() {
            return AccessFlag.getMethodParametersModifier(this.access_flags.value);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int nameCpIndex = this.name_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "name_index",
                    String.format(TEXT_CPINDEX_VALUE, nameCpIndex, "name", classFile.getCPDescription(nameCpIndex)),
                    "msg_attr_parameters__name_index",
                    Icons.Name
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "access_flags",
                    BytesTool.getBinaryString(this.access_flags.value) + " - " + this.getAccessFlagsText(),
                    "msg_attr_parameters__access_flags",
                    Icons.AccessFlag
            );
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ModuleHashes_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code ModuleHashes} attribute. The
 * {@code AttributeModulePackages} attribute has the following format:
 *
 * <pre>
 *    ModuleHashes_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        // index to CONSTANT_utf8_info structure with algorithm name
 *        u2 algorithm_index;
 *
 *        // the number of entries in the hashes table
 *        u2 hashes_count;
 *        {   u2 module_name_index (index to CONSTANT_Module_info structure)
 *            u2 hash_length;
 *            u1 hash[hash_length];
 *        } hashes[hashes_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since OpenJDK 9
 *
 * @see
 * <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2017-February/011262.html">
 * OpenJDK specific attribute specifications</a>
 * @see
 * <a href="https://hg.openjdk.java.net/jdk9/dev/jdk/file/65464a307408/src/java.base/share/classes/jdk/internal/module/ClassFileAttributes.java">
 * ModuleHashes attribute.</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ModuleHashes_attribute extends attribute_info {

    /**
     * Index to CONSTANT_utf8_info structure with algorithm name.
     */
    public final u2 algorithm_index;

    /**
     * The value of the {@link #hashes_count} item indicates the number of
     * entries in the {@link #hashes} table.
     */
    public final u2 hashes_count;
    public final Hashes[] hashes;

    ModuleHashes_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.algorithm_index = new u2(posDataInputStream);
        this.hashes_count = new u2(posDataInputStream);
        if (this.hashes_count.value > 0) {
            this.hashes = new Hashes[this.hashes_count.value];
            for (int i = 0; i < this.hashes_count.value; i++) {
                this.hashes[i] = new Hashes(posDataInputStream);
            }
        } else {
            this.hashes = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat fileFormat) {
        ClassFile classFile = (ClassFile) fileFormat;
        int startPosMoving = super.startPos + 6;

        int cpIndex = this.algorithm_index.value;
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "algorithm_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "algorithm name", classFile.getCPDescription(cpIndex)),
                "msg_attr_ModuleHashes_algorithm_index", Icons.Name
        );
        startPosMoving += u2.LENGTH;

        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "hashes_count", this.hashes_count.value,
                "msg_attr_ModuleHashes_hashes_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.hashes_count.value > 0) {
            ModuleHashes_attribute.Hashes hashLastItem = this.hashes[this.hashes_count.value - 1];
            final DefaultMutableTreeNode providesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    hashLastItem.getStartPos() + hashLastItem.getLength() - startPosMoving,
                    String.format("hashes [%d]", this.hashes_count.value)
            ));
            parentNode.add(providesNode);

            for (int i = 0; i < this.hashes.length; i++) {
                DefaultMutableTreeNode hashNode = this.addNode(providesNode,
                        this.hashes[i].getStartPos(),
                        this.hashes[i].getLength(),
                        String.format("hash %d", i + 1),
                        classFile.getCPDescription(this.hashes[i].module_name_index.value),
                        "msg_attr_ModuleHashes_hashes",
                        Icons.Data
                );
                this.hashes[i].generateTreeNode(hashNode, fileFormat);
            }
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ModuleHashes";
    }

    /**
     * The {@code hashes} structure in {@code ModuleHashes} attribute.
     *
     * @author Amos Shi
     * @since OpenJDK 9
     * @see Module
     */
    public static final class Hashes extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * Index to CONSTANT_Module_info structure.
         */
        public final u2 module_name_index;
        public final u2 hash_length;
        public final u1[] hash;

        private Hashes(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();

            this.module_name_index = new u2(posDataInputStream);
            this.hash_length = new u2(posDataInputStream);
            if (this.hash_length.value > 0) {
                this.hash = new u1[this.hash_length.value];
                for (int i = 0; i < this.hash_length.value; i++) {
                    this.hash[i] = new u1(posDataInputStream);
                }
            } else {
                this.hash = null;
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.module_name_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "module_name_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "module name", classFile.getCPDescription(cpIndex)),
                    "msg_attr_ModuleHashes_module_name_index", Icons.Name
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "hash_length", this.hash_length.value,
                    "msg_attr_ModuleHashes_hash_length", Icons.Length
            );
            startPosMoving += u2.LENGTH;

            if (this.hash_length.value > 0) {
                this.addNode(parentNode,
                        startPosMoving, u1.LENGTH * this.hash_length.value,
                        "hash", "raw hash data",
                        "msg_attr_ModuleHashes_hash", Icons.Checksum
                );
            }
        }
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ModuleMainClass_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code ModuleMainClass} attribute. The
 * {@code ModuleMainClass} attribute has the following format:
 *
 * <pre>
 *    ModuleMainClass_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 main_class_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.27">
 * VM Spec: The ModuleMainClass Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ModuleMainClass_attribute extends attribute_info {

    /**
     * The value of the {@link #main_class_index} item must be a valid index into the
     * {@link ClassFile#constant_pool} table. The {@link ClassFile#constant_pool} entry at that index must be a
     * CONSTANT_Class_info structure representing the main class of the
     * current module.
     */
    public final u2 main_class_index;

    ModuleMainClass_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        this.main_class_index = new u2(posDataInputStream);
        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        // TODO - Find a test case to verify this attribute type is working or not
        System.out.println("Congratulations. We verified the tree ndoe for ConstantDynamicInfo is working. We can delete this log output now.");
        int cpIndex = this.main_class_index.value;
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "main_class_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "main class", ((ClassFile)classFile).getCPDescription(cpIndex)),
                "msg_attr_ModuleMainClass__main_class_index", Icons.Class
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ModuleMainClass";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ModulePackages_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_Package_info;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code ModulePackages} attribute. The
 * {@code ModulePackages} attribute has the following format:
 *
 * <pre>
 *    ModulePackages_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 package_count;
 *        u2 package_index[package_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since JDK 9
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.26">
 * VM Spec: The ModulePackages Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ModulePackages_attribute extends attribute_info {

    /**
     * The value of the package_count item indicates the number of entries in
     * the {@link #package_index}table.
     */
    public final u2 package_count;

    /**
     * The value of each entry in the {@link #package_index} table must be a
     * valid index into the {@link ClassFile#constant_pool} table. The
     * {@link ClassFile#constant_pool} entry at that index must be a
     * {@link CONSTANT_Package_info} structure representing a package in the
     * current module.
     */
    public final u2[] package_index;

    ModulePackages_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.package_count = new u2(posDataInputStream);
        if (this.package_count.value > 0) {
            this.package_index = new u2[this.package_count.value];
            for (int i = 0; i < this.package_count.value; i++) {
                this.package_index[i] = new u2(posDataInputStream);
            }
        } else {
            this.package_index = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "package_count", this.package_count.value,
                "msg_attr_ModulePackages__package_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.package_count.value > 0) {
            final DefaultMutableTreeNode packageIndexesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    u2.LENGTH * this.package_count.value,
                    String.format("package_index [%d]", this.package_count.value),
                    MESSAGES.getString("msg_attr_ModulePackages__package_index")
            ));
            parentNode.add(packageIndexesNode);

            for (int i = 0; i < this.package_index.length; i++) {
                int packageIndex = this.package_index[i].value;
                this.addNode(packageIndexesNode,
                        startPosMoving + i * u2.LENGTH,
                        u2.LENGTH,
                        String.format("package_index %d", i + 1),
                        String.format(TEXT_CPINDEX_VALUE, packageIndex, "package", ((ClassFile)classFile).getCPDescription(packageIndex)),
                        "msg_attr_ModulePackages__package_index",
                        Icons.Package
                );
            }
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ModulePackages";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ModuleResolution_attribute.java`:

```java
/*
 * AttributeConstantValue.java    5:08 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code ModuleResolution} attribute.
 *
 * The {@code ModuleResolution} attribute has the following format:
 *
 * <pre>
 *    ModuleResolution_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 resolution_flags;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 17
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ModuleResolution_attribute extends attribute_info {

    /**
     * resolution_flags.
     */
    public final u2 resolution_flags;

    ModuleResolution_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        if (this.attribute_length.value != 2) {
            throw new FileFormatException(String.format("The attribute_length of ModuleResolution is not 2, it is %d.", this.attribute_length.value));
        }

        this.resolution_flags = new u2(posDataInputStream);
        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos + 6,
                u2.LENGTH,
                "resolution_flags: " + BytesTool.getBinaryString(this.resolution_flags.value)
        )));
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ModuleResolution";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/ModuleTarget_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.constant.CONSTANT_Utf8_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code ModuleTarget} attribute. The {@code ModuleTarget}
 * attribute has the following format:
 *
 * <pre>
 *    ModuleTarget_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        // index to a CONSTANT_utf8_info structure
 *        u2 os_arch_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since JDK 9
 * @see
 * <a href="https://openjdk.java.net/jeps/261"> JEP 261: Module System</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ModuleTarget_attribute extends attribute_info {

    /**
     * Index to a {@link CONSTANT_Utf8_info} structure.
     */
    public final u2 os_arch_index;

    ModuleTarget_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        this.os_arch_index = new u2(posDataInputStream);

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int cpIndex = this.os_arch_index.value;
        this.addNode(parentNode,
                super.startPos + 6, u2.LENGTH,
                "os_arch_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "type name", ((ClassFile)classFile).getCPDescription(cpIndex)),
                "msg_attr_ModuleTarget_os_arch_index", Icons.Name
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_ModuleTarget";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Module_attribute.java`:

```java
/*
 * AttributeModule.java    May 17, 2019
 *
 * Copyright 2019, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.AccessFlag;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code Module} attribute.
 *
 * The {@code Module} attribute is a variable-length attribute in the attributes
 * table of a {@code ClassFile} structure. The {@code Module} attribute
 * indicates the modules required by a module; the packages exported and opened
 * by a module; and the services used and provided by a module.
 *
 * The {@code Module} attribute has the following format:
 *
 * <pre>
 * Module_attribute {
 *     u2 attribute_name_index;
 *     u4 attribute_length;
 *
 *     u2 module_name_index;
 *     u2 module_flags;
 *     u2 module_version_index;
 *
 *     u2 requires_count;
 *     {   u2 requires_index;
 *         u2 requires_flags;
 *         u2 requires_version_index;
 *     } requires[requires_count];
 *
 *     u2 exports_count;
 *     {   u2 exports_index;
 *         u2 exports_flags;
 *         u2 exports_to_count;
 *         u2 exports_to_index[exports_to_count];
 *     } exports[exports_count];
 *
 *     u2 opens_count;
 *     {   u2 opens_index;
 *         u2 opens_flags;
 *         u2 opens_to_count;
 *         u2 opens_to_index[opens_to_count];
 *     } opens[opens_count];
 *
 *     u2 uses_count;
 *     u2 uses_index[uses_count];
 *
 *     u2 provides_count;
 *     {   u2 provides_index;
 *         u2 provides_with_count;
 *         u2 provides_with_index[provides_with_count];
 *     } provides[provides_count];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 9
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.25">
 * VM Spec: The Module Attribute</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class Module_attribute extends attribute_info {

    public final u2 module_name_index;
    public final u2 module_flags;
    public final u2 module_version_index;

    public final u2 requires_count;
    public final Requires[] requires;

    public final u2 exports_count;
    public final Exports[] exports;

    public final u2 opens_count;
    public final Opens[] opens;

    public final u2 uses_count;
    public final u2[] uses_index;

    public final u2 provides_count;
    public final Provides[] provides;

    /**
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
     * </pre>
     */
    @SuppressWarnings("java:S3776")
    Module_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.module_name_index = new u2(posDataInputStream);
        this.module_flags = new u2(posDataInputStream);
        this.module_version_index = new u2(posDataInputStream);

        // Requires
        this.requires_count = new u2(posDataInputStream);
        if (this.requires_count.value > 0) {
            this.requires = new Requires[this.requires_count.value];
            for (int i = 0; i < this.requires_count.value; i++) {
                this.requires[i] = new Requires(posDataInputStream);
            }
        } else {
            this.requires = null;
        }

        // Exports
        this.exports_count = new u2(posDataInputStream);
        if (this.exports_count.value > 0) {
            this.exports = new Exports[this.exports_count.value];
            for (int i = 0; i < this.exports_count.value; i++) {
                this.exports[i] = new Exports(posDataInputStream);
            }
        } else {
            this.exports = null;
        }

        // Opens
        this.opens_count = new u2(posDataInputStream);
        if (this.opens_count.value > 0) {
            this.opens = new Opens[this.opens_count.value];
            for (int i = 0; i < this.opens_count.value; i++) {
                this.opens[i] = new Opens(posDataInputStream);
            }
        } else {
            this.opens = null;
        }

        // Uses
        this.uses_count = new u2(posDataInputStream);
        if (this.uses_count.value > 0) {
            this.uses_index = new u2[this.uses_count.value];
            for (int i = 0; i < this.uses_count.value; i++) {
                this.uses_index[i] = new u2(posDataInputStream);
            }
        } else {
            this.uses_index = null;
        }

        // Provides
        this.provides_count = new u2(posDataInputStream);
        if (this.provides_count.value > 0) {
            this.provides = new Provides[this.provides_count.value];
            for (int i = 0; i < this.provides_count.value; i++) {
                this.provides[i] = new Provides(posDataInputStream);
            }
        } else {
            this.provides = null;
        }

        // Check Length
        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get extracted {@link #module_flags}.
     *
     * @return Extracted {@link #module_flags}
     */
    public String getModuleFlags() {
        return AccessFlag.getModifier(this.module_flags.value, AccessFlag.ForModule);
    }

    /**
     * @param parentNode Parent JTree node
     * @param format Current class file object
     *
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
     * </pre>
     */
    @Override
    @SuppressWarnings("java:S3776")
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat format) {
        ClassFile classFile = (ClassFile) format;
        int startPosMoving = super.startPos + 6;

        // module_name_index
        int moduleNameCpIndex = this.module_name_index.value;
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "module_name_index",
                String.format(TEXT_CPINDEX_VALUE, moduleNameCpIndex, "module name", classFile.getCPDescription(moduleNameCpIndex)),
                "msg_attr_module_name_index",
                Icons.Module
        );
        startPosMoving += u2.LENGTH;

        // module_flags
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "module_flags",
                BytesTool.getBinaryString(this.module_flags.value) + " - " + this.getModuleFlags(),
                "msg_attr_module_flags",
                Icons.AccessFlag
        );
        startPosMoving += u2.LENGTH;

        // module_version_index
        String moduleVersion = (this.module_version_index.value == 0)
                ? "no version information"
                : classFile.getCPDescription(this.module_version_index.value);

        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "module_version_index",
                this.module_version_index.value + " - " + moduleVersion,
                "msg_attr_module_version_index",
                Icons.Versions
        );
        startPosMoving += u2.LENGTH;

        //
        // requires
        //
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "requires_count", this.requires_count.value,
                "msg_attr_requires_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.requires_count.value > 0) {
            final DefaultMutableTreeNode requiresNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    Module_attribute.Requires.LENGTH * this.requires_count.value,
                    String.format("requires [%d]", this.requires_count.value),
                    MESSAGES.getString("msg_attr_requires")
            ));
            parentNode.add(requiresNode);

            for (int i = 0; i < this.requires.length; i++) {
                DefaultMutableTreeNode requireNode = this.addNode(requiresNode,
                        this.requires[i].getStartPos(),
                        this.requires[i].getLength(),
                        String.format("requires %d", i + 1),
                        classFile.getCPDescription(this.requires[i].requires_index.value),
                        "msg_attr_requires",
                        Icons.Data
                );
                this.requires[i].generateTreeNode(requireNode, format);
            }

            // Update the new startPos
            Module_attribute.Requires requireLastItem = this.requires[this.requires.length - 1];
            startPosMoving = requireLastItem.getStartPos() + requireLastItem.getLength();
        }

        //
        // exports
        //
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "exports_count", this.exports_count.value,
                "msg_attr_exports_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.exports_count.value > 0) {
            Module_attribute.Exports exporstLastItem = this.exports[this.exports_count.value - 1];
            final DefaultMutableTreeNode exportsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    exporstLastItem.getStartPos() + exporstLastItem.getLength() - startPosMoving,
                    String.format("exports [%d]", this.exports_count.value),
                    MESSAGES.getString("msg_attr_exports")
            ));
            parentNode.add(exportsNode);

            for (int i = 0; i < this.exports.length; i++) {
                DefaultMutableTreeNode exportNode = this.addNode(exportsNode,
                        this.exports[i].getStartPos(),
                        this.exports[i].getLength(),
                        String.format("export %d", i + 1), classFile.getCPDescription(this.exports[i].exports_index.value),
                        "msg_attr_exports", Icons.Data
                );
                this.exports[i].generateTreeNode(exportNode, format);
            }

            // Update the new startPos
            startPosMoving = exporstLastItem.getStartPos() + exporstLastItem.getLength();
        }

        //
        // opens
        //
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "opens_count", this.opens_count.value,
                "msg_attr_opens_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.opens_count.value > 0) {
            Module_attribute.Opens opensLastItem = this.opens[this.opens_count.value - 1];
            final DefaultMutableTreeNode opensNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    opensLastItem.getStartPos() + opensLastItem.getLength() - startPosMoving,
                    String.format("opens [%d]", this.opens_count.value),
                    MESSAGES.getString("msg_attr_opens")
            ));
            parentNode.add(opensNode);

            for (int i = 0; i < this.opens.length; i++) {
                DefaultMutableTreeNode openNode = this.addNode(opensNode,
                        this.opens[i].getStartPos(),
                        this.opens[i].getLength(),
                        String.format("open %d", i + 1), classFile.getCPDescription(this.opens[i].opens_index.value),
                        "msg_attr_opens", Icons.Data
                );
                this.opens[i].generateTreeNode(openNode, format);
            }

            // Update the new startPos
            startPosMoving = opensLastItem.getStartPos() + opensLastItem.getLength();
        }

        //
        // uses
        //
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "uses_count", this.uses_count.value,
                "msg_attr_uses_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.uses_count.value > 0) {
            final int uses_count_length = u2.LENGTH * this.uses_count.value;
            final DefaultMutableTreeNode usesCountNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    uses_count_length,
                    String.format("uses_index [%d]", this.uses_count.value),
                    MESSAGES.getString("msg_attr_uses_index")
            ));
            parentNode.add(usesCountNode);

            for (int i = 0; i < this.uses_index.length; i++) {
                int cpIndex = this.uses_index[i].value;
                this.addNode(usesCountNode,
                        startPosMoving + i * u2.LENGTH,
                        u2.LENGTH,
                        String.format("uses_index %d", i + 1),
                        String.format(TEXT_CPINDEX_VALUE, cpIndex, "uses class", classFile.getCPDescription(cpIndex)),
                        "msg_attr_uses_index",
                        Icons.Class
                );
            }

            startPosMoving += uses_count_length;
        }

        //
        // provides
        //
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "provides_count", this.provides_count.value,
                "msg_attr_provides_count", Icons.Counter
        );
        startPosMoving += u2.LENGTH;

        if (this.provides_count.value > 0) {
            Module_attribute.Provides provideLastItem = this.provides[this.provides_count.value - 1];
            final DefaultMutableTreeNode providesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    provideLastItem.getStartPos() + provideLastItem.getLength() - startPosMoving,
                    String.format("provides [%d]", this.provides_count.value),
                    MESSAGES.getString("msg_attr_provides")
            ));
            parentNode.add(providesNode);

            for (int i = 0; i < this.provides.length; i++) {
                DefaultMutableTreeNode provideNode = this.addNode(providesNode,
                        this.provides[i].getStartPos(),
                        this.provides[i].getLength(),
                        String.format("provide %d", i + 1), classFile.getCPDescription(this.provides[i].provides_index.value),
                        "msg_attr_provides", Icons.Data
                );
                this.provides[i].generateTreeNode(provideNode, format);
            }
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Module";
    }

    /**
     * The {@code requires} structure in {@code Module} attribute.
     *
     * @author Amos Shi
     * @since Java 9
     * @see Module
     */
    public static final class Requires extends FileComponent implements GenerateTreeNodeClassFile {

        public static final int LENGTH = 6;
        public final u2 requires_index;
        public final u2 requires_flags;
        public final u2 requires_version_index;

        private Requires(final PosDataInputStream posDataInputStream)
                throws IOException {
            this.startPos = posDataInputStream.getPos();
            this.length = LENGTH;

            this.requires_index = new u2(posDataInputStream);
            this.requires_flags = new u2(posDataInputStream);
            this.requires_version_index = new u2(posDataInputStream);
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.requires_index.value;
            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "requires_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "requires module", classFile.getCPDescription(cpIndex)),
                    "msg_attr_requires_index",
                    Icons.Name
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "requires_flags",
                    BytesTool.getBinaryString(this.requires_flags.value) + " " + this.getRequiresFlags(),
                    "msg_attr_requires_flags",
                    Icons.AccessFlag
            );
            startPosMoving += u2.LENGTH;

            // requires_version_index
            String requiresVersionIndex = (this.requires_version_index.value == 0)
                    ? "no version information"
                    : classFile.getCPDescription(this.requires_version_index.value);
            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "requires_version_index",
                    this.requires_version_index.value + " - " + requiresVersionIndex,
                    "msg_attr_requires_version_index",
                    Icons.Versions
            );
        }

        /**
         * Get extracted {@link #requires_flags}.
         *
         * @return Extracted {@link #requires_flags}
         */
        public String getRequiresFlags() {
            return AccessFlag.getModifier(this.requires_flags.value, AccessFlag.ForModuleRequires);
        }
    }

    /**
     * The {@code exports} structure in {@code Module} attribute.
     *
     * @author Amos Shi
     * @since Java 9
     * @see Module
     */
    public static final class Exports extends FileComponent implements GenerateTreeNodeClassFile {

        public final u2 exports_index;
        public final u2 exports_flags;
        public final u2 exports_to_count;
        public final u2[] exports_to_index;

        private Exports(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();

            this.exports_index = new u2(posDataInputStream);
            this.exports_flags = new u2(posDataInputStream);
            this.exports_to_count = new u2(posDataInputStream);
            if (this.exports_to_count.value > 0) {
                this.exports_to_index = new u2[this.exports_to_count.value];
                for (int i = 0; i < this.exports_to_count.value; i++) {
                    this.exports_to_index[i] = new u2(posDataInputStream);
                }
            } else {
                this.exports_to_index = null;
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.exports_index.value;
            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "exports_index",
                    String.format(TEXT_CPINDEX_VALUE, cpIndex, "exports package", classFile.getCPDescription(cpIndex)),
                    "msg_attr_exports_index",
                    Icons.Package
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "exports_flags",
                    BytesTool.getBinaryString(this.exports_flags.value) + " " + this.getExportFlags(),
                    "msg_attr_exports_flags",
                    Icons.AccessFlag
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving,
                    u2.LENGTH,
                    "exports_to_count",
                    this.exports_to_count.value,
                    "msg_attr_exports_to_count",
                    Icons.Counter
            );
            startPosMoving += u2.LENGTH;

            if (this.exports_to_count.value > 0) {
                final DefaultMutableTreeNode exportsToIndexNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        u2.LENGTH * this.exports_to_count.value,
                        String.format("exports_to_index [%d]", this.exports_to_count.value),
                        MESSAGES.getString("msg_attr_exports_to_index")
                ));
                parentNode.add(exportsToIndexNode);

                for (int i = 0; i < this.exports_to_index.length; i++) {
                    cpIndex = this.exports_to_index[i].value;
                    this.addNode(exportsToIndexNode,
                            startPosMoving + i * u2.LENGTH,
                            u2.LENGTH,
                            String.format("exports_to_index %d", i + 1),
                            String.format(TEXT_CPINDEX_VALUE, cpIndex, "exports to index", classFile.getCPDescription(cpIndex)),
                            "msg_attr_exports_to_index",
                            Icons.Module
                    );
                }
            }
        }

        /**
         * Get extracted {@link #exports_flags}.
         *
         * @return Extracted {@link #exports_flags}
         */
        public String getExportFlags() {
            return AccessFlag.getModifier(this.exports_flags.value, AccessFlag.ForModuleExports);
        }
    }

    /**
     * The {@code opens} structure in {@code Module} attribute.
     *
     * @author Amos Shi
     * @since Java 9
     * @see Module
     */
    public static final class Opens extends FileComponent implements GenerateTreeNodeClassFile {

        public final u2 opens_index;
        public final u2 opens_flags;
        public final u2 opens_to_count;
        public final u2[] opens_to_index;

        private Opens(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();

            this.opens_index = new u2(posDataInputStream);
            this.opens_flags = new u2(posDataInputStream);
            this.opens_to_count = new u2(posDataInputStream);
            if (this.opens_to_count.value > 0) {
                this.opens_to_index = new u2[this.opens_to_count.value];
                for (int i = 0; i < this.opens_to_count.value; i++) {
                    this.opens_to_index[i] = new u2(posDataInputStream);
                }
            } else {
                this.opens_to_index = null;
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.opens_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "opens_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "opens package", classFile.getCPDescription(cpIndex)),
                    "msg_attr_opens_index", Icons.Package
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "opens_flags", BytesTool.getBinaryString(this.opens_flags.value) + " " + this.getOpenFlags(),
                    "msg_attr_opens_flags", Icons.AccessFlag
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "opens_to_count", this.opens_to_count.value,
                    "msg_attr_opens_to_count", Icons.Counter
            );
            startPosMoving += u2.LENGTH;

            if (this.opens_to_count.value > 0) {
                final DefaultMutableTreeNode exportsToIndexNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        u2.LENGTH * this.opens_to_count.value,
                        String.format("opens_to_index [%d]", this.opens_to_count.value),
                        "msg_attr_opens_to_index"
                ));
                parentNode.add(exportsToIndexNode);

                for (int i = 0; i < this.opens_to_index.length; i++) {
                    cpIndex = this.opens_to_index[i].value;
                    this.addNode(exportsToIndexNode,
                            startPosMoving + i * u2.LENGTH,
                            u2.LENGTH,
                            String.format("opens_to_index %d", i + 1),
                            String.format(TEXT_CPINDEX_VALUE, cpIndex, "opens module", classFile.getCPDescription(cpIndex)),
                            "msg_attr_opens_to_index",
                            Icons.Module
                    );
                }
            }
        }

        /**
         * Get extracted {@link #opens_flags}.
         *
         * @return Extracted {@link #opens_flags}
         */
        public String getOpenFlags() {
            return AccessFlag.getModifier(this.opens_flags.value, AccessFlag.ForModuleOpens);
        }
    }

    /**
     * The {@code provides} structure in {@code Module} attribute.
     *
     * @author Amos Shi
     * @since Java 9
     * @see Module
     */
    public static final class Provides extends FileComponent implements GenerateTreeNodeClassFile {

        public final u2 provides_index;
        public final u2 provides_with_count;
        public final u2[] provides_with_index;

        private Provides(final PosDataInputStream posDataInputStream) throws IOException {
            this.startPos = posDataInputStream.getPos();

            this.provides_index = new u2(posDataInputStream);
            this.provides_with_count = new u2(posDataInputStream);
            if (this.provides_with_count.value > 0) {
                this.provides_with_index = new u2[this.provides_with_count.value];
                for (int i = 0; i < this.provides_with_count.value; i++) {
                    this.provides_with_index[i] = new u2(posDataInputStream);
                }
            } else {
                this.provides_with_index = null;
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            int cpIndex = this.provides_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "provides_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "provides class", classFile.getCPDescription(cpIndex)),
                    "msg_attr_provides_index", Icons.Class
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "provides_with_count", this.provides_with_count.value,
                    "msg_attr_provides_with_count", Icons.Counter
            );
            startPosMoving += u2.LENGTH;

            if (this.provides_with_count.value > 0) {
                final DefaultMutableTreeNode exportsToIndexNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        u2.LENGTH * this.provides_with_count.value,
                        String.format("provides_with_index [%d]", this.provides_with_count.value),
                        MESSAGES.getString("msg_attr_provides_with_index")
                ));
                parentNode.add(exportsToIndexNode);

                for (int i = 0; i < this.provides_with_index.length; i++) {
                    this.addNode(exportsToIndexNode,
                            startPosMoving + i * u2.LENGTH,
                            u2.LENGTH,
                            String.format("provides_with_index %d", i + 1),
                            String.format(TEXT_CPINDEX_VALUE, cpIndex, "provides class", classFile.getCPDescription(cpIndex)),
                            "msg_attr_provides_with_index",
                            Icons.Class
                    );
                }
            }
        } // End of generateTreeNode()
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/NestHost_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code NestHost} attribute. The {@code NestHost} attribute
 * has the following format:
 *
 * <pre>
 *    NestHost_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 host_class_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 11
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.28">
 * VM Spec: The NestHost Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class NestHost_attribute extends attribute_info {

    /**
     * The value of the {@link #host_class_index} item must be a valid index
     * into the {@link ClassFile#constant_pool} table. The
     * {@link ClassFile#constant_pool} entry at that index must be a
     * CONSTANT_Class_info structure representing a class or interface which is
     * the nest host for the current class or interface.
     */
    public final u2 host_class_index;

    NestHost_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        this.host_class_index = new u2(posDataInputStream);
        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        int cpIndex = this.host_class_index.value;
        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "host_class_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "host class", ((ClassFile)classFile).getCPDescription(cpIndex)),
                "msg_attr_NestHost__host_class_index", Icons.Class
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NestHost";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/NestMembers_attribute.java`:

```java
/*
 * AttributeInnerClasses.java    5:20 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code NestMembers} attribute. The {@code NestMembers}
 * attribute has the following format:
 *
 * <pre>
 *    NestMembers_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 number_of_classes;
 *        u2 classes[number_of_classes];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 11
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.29">
 * VM Spec: The NestMembers Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class NestMembers_attribute extends ClassesCount {

    public NestMembers_attribute(u2 nameIndex, String type, PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NestMembers";
    }

    @Override
    String getMessageKey_4_classes() {
        return "msg_attr_NestMembers__classes";
    }

    @Override
    String getMessageKey_4_number_of_classes() {
        return "msg_attr_NestMembers__number_of_classes";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/PermittedSubclasses_attribute.java`:

```java
/*
 * PermittedSubclasses_attribute.java    10:38 AM, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code PermittedSubclasses} attribute. The
 * {@code PermittedSubclasses} attribute has the following format:
 *
 * <pre>
 *    PermittedSubclasses_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 number_of_classes;
 *        u2 classes[number_of_classes];
 *    }
 * </pre>
 *
 * Note. The code in current class the same as NestMembers_attribute. We need to
 * merge them later.
 *
 * @author Amos Shi
 * @since Java 17
 * @see <a href="https://openjdk.java.net/jeps/360"> JEP 360</a>
 * @see <a href="https://openjdk.java.net/jeps/409"> JEP 409</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class PermittedSubclasses_attribute extends ClassesCount {

    public PermittedSubclasses_attribute(u2 nameIndex, String type, PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_PermittedSubclasses";
    }

    @Override
    String getMessageKey_4_classes() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    String getMessageKey_4_number_of_classes() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Record_attribute.java`:

```java
/*
 * AttributeRecord.java    8:43 AM, August 12, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.constant.cp_info;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * The class for the {@code Record} attribute. The Record attribute indicates
 * that the current class is a record class, and stores information about the
 * record components of the record class. There may be at most one Record
 * attribute in the attributes table of a ClassFile structure.
 *
 * The {@code Record} attribute has the following format:
 *
 * <pre>
 *    Record_attribute {
 *        u2                    attribute_name_index;
 *        u4                    attribute_length;
 *
 *        u2                    components_count;
 *        record_component_info components[components_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 16
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.30">
 * VM Spec: The Record Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class Record_attribute extends attribute_info {

    /**
     * The value of the {@link #components_count} item indicates the number of
     * entries in the {@link #components} table.
     */
    public final u2 components_count;

    /**
     * Each entry in the {@link #components} table specifies a record component
     * of the current class, in the order the record components were declared.
     */
    public final record_component_info[] components;

    Record_attribute(final u2 nameIndex, final String type, final PosDataInputStream stream, final cp_info[] cp) throws IOException, FileFormatException {
        super(nameIndex, type, stream);
        this.components_count = new u2(stream);

        if (this.components_count.value > 0) {
            this.components = new record_component_info[this.components_count.value];
            for (int i = 0; i < this.components_count.value; i++) {
                this.components[i] = new record_component_info(stream, cp);
            }
        } else {
            this.components = null;
        }

        super.checkSize(stream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int startPosMoving = super.startPos + 6;

        this.addNode(parentNode,
                startPosMoving, u2.LENGTH,
                "components_count", this.components_count.value,
                "msg_attr_Record__components_count", Icons.Counter
        );

        if (this.components_count.value < 1) {
            return;
        }

        DefaultMutableTreeNode compsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPosMoving,
                super.length - 6 - 2,
                String.format("components [%d]", this.components_count.value),
                MESSAGES.getString("msg_attr_record_component_info")
        ));
        parentNode.add(compsNode);

        for (int i = 0; i < this.components_count.value; i++) {
            record_component_info info = this.components[i];
            DefaultMutableTreeNode infoNode = this.addNode(compsNode,
                    info.getStartPos(),
                    info.getLength(),
                    String.format("component %d", i + 1),
                    ((ClassFile)classFile).getCPDescription(info.name_index.value),
                    "msg_attr_record_component_info",
                    Icons.Data
            );
            info.generateTreeNode(infoNode, (ClassFile)classFile);
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Record";
    }

    /**
     * The <code>record_component_info</code> structure has the following
     * format.
     *
     * <pre>
     *    record_component_info {
     *        u2             name_index;
     *        u2             descriptor_index;
     *        u2             attributes_count;
     *        attribute_info attributes[attributes_count];
     *    }
     * </pre>
     *
     * <pre>
     * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S101")
    public static final class record_component_info extends FileComponent implements GenerateTreeNodeClassFile {

        /**
         * The value of the name_index item must be a valid index into the
         * {@link ClassFile#constant_pool} table. The <code>constant_pool</code>
         * entry at that index must be a <code>CONSTANT_Utf8_info</code>
         * structure representing a valid unqualified name denoting the record
         * component.
         */
        public final u2 name_index;

        /**
         * The value of the descriptor_index item must be a valid index into the
         * {@link ClassFile#constant_pool} table. The <code>constant_pool</code>
         * entry at that index must be a <code>CONSTANT_Utf8_info</code>
         * structure representing a field descriptor which encodes the type of
         * the record component.
         */
        public final u2 descriptor_index;

        /**
         * The value of the attributes_count item indicates the number of
         * additional attributes of this record component.
         */
        public final u2 attributes_count;

        /**
         * A record component can have any number of optional attributes
         * associated with it.
         */
        public final attribute_info[] attributes;

        private record_component_info(final PosDataInputStream stream, final cp_info[] cp) throws IOException, FileFormatException {
            super.startPos = stream.getPos();

            this.name_index = new u2(stream);
            this.descriptor_index = new u2(stream);
            this.attributes_count = new u2(stream);

            if (this.attributes_count.value > 0) {
                this.attributes = new attribute_info[this.attributes_count.value];
                for (int i = 0; i < this.attributes_count.value; i++) {
                    this.attributes[i] = attribute_info.parse(stream, cp);
                }
            } else {
                this.attributes = null;
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            ClassFile classFile = (ClassFile) format;
            int startPosMoving = super.getStartPos();

            int cpIndex = this.name_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "name_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "name", classFile.getCPDescription(cpIndex)),
                    "msg_attr_record_component_info__name_index", Icons.Name
            );
            startPosMoving += u2.LENGTH;

            cpIndex = this.descriptor_index.value;
            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "descriptor_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "descriptor", classFile.getCPDescription(cpIndex)),
                    "msg_attr_record_component_info__descriptor_index", Icons.Descriptor
            );
            startPosMoving += u2.LENGTH;

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    FIELD_ATTR_COUNT, this.attributes_count.value,
                    "msg_attr_record_component_info__attributes_count", Icons.Counter
            );
            startPosMoving += u2.LENGTH;

            if (this.attributes_count.value > 0) {
                int attrLength = 0;
                for (attribute_info attr : this.attributes) {
                    attrLength += attr.getLength();
                }

                DefaultMutableTreeNode treeNodeAttributes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        attrLength,
                        String.format(FIELD_ATTRS, this.attributes_count.value),
                        MESSAGES.getString("msg_attr_record_component_info__attributes")
                ));

                for (int i = 0; i < this.attributes_count.value; i++) {
                    attribute_info attr = this.attributes[i];
                    DefaultMutableTreeNode treeNodeAttributeItem = this.addNode(treeNodeAttributes,
                            attr.getStartPos(),
                            attr.getLength(),
                            String.valueOf(i + 1),
                            attr.getName(),
                            attr.getMessageKey(),
                            Icons.Annotations
                    );
                    attr.generateTreeNodeCommon(treeNodeAttributeItem, classFile);
                }
                parentNode.add(treeNodeAttributes);
            }
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeAnnotations.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The Runtime(In)VisibleAnnotations Attribute.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from JVM spec instead
 * java:S101 - Class names should comply with a naming convention  --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention  --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116"})
public abstract class RuntimeAnnotations extends attribute_info {

    public final u2 num_annotations;
    public final Annotation[] annotations;

    RuntimeAnnotations(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.num_annotations = new u2(posDataInputStream);
        if (this.num_annotations.value > 0) {
            this.annotations = new Annotation[this.num_annotations.value];
            for (int i = 0; i < this.num_annotations.value; i++) {
                this.annotations[i] = new Annotation(posDataInputStream);
            }
        } else {
            this.annotations = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        final ClassFile classFile = (ClassFile) format;
        final int startPosMoving = super.startPos;

        this.addNode(parentNode,
                startPosMoving + 6, u2.LENGTH,
                "num_annotations", this.num_annotations.value,
                this.getMessageKey_4_num_annotations(), Icons.Counter
        );

        if (this.num_annotations.value > 0) {
            DefaultMutableTreeNode annotationsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving + 8,
                    this.getLength() - 8,
                    String.format("annotations [%d]", this.num_annotations.value),
                    MESSAGES.getString(this.getMessageKey_4_annotations())
            ));
            parentNode.add(annotationsNode);

            for (int i = 0; i < this.num_annotations.value; i++) {
                Annotation a = this.annotations[i];
                DefaultMutableTreeNode annotationNode = this.addNode(annotationsNode,
                        a.getStartPos(),
                        a.getLength(),
                        String.valueOf(i + 1),
                        classFile.getCPDescription(a.type_index.value),
                        this.getMessageKey_4_annotations(),
                        Icons.Annotations
                );
                a.generateTreeNode(annotationNode, format);
            }
        }
    }

    /**
     * Get message key for {@link #annotations}.
     *
     * @return Message key for {@link #annotations}
     *
     * @see RuntimeVisibleAnnotations_attribute
     * @see RuntimeInvisibleAnnotations_attribute
     */
    abstract String getMessageKey_4_annotations();

    /**
     * Get message key for {@link #num_annotations}.
     *
     * @return Message key for {@link #num_annotations}
     *
     * @see RuntimeVisibleAnnotations_attribute
     * @see RuntimeInvisibleAnnotations_attribute
     */
    abstract String getMessageKey_4_num_annotations();
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeInvisibleAnnotations_attribute.java`:

```java
/*
 * AttributeRuntimeInvisibleAnnotations.java    11:13 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code RuntimeInvisibleAnnotations} attribute is similar to the
 * {@code RuntimeVisibleAnnotations} attribute, except that the annotations
 * represented by a {@code RuntimeInvisibleAnnotations} attribute must not be
 * made available for return by reflective APIs, unless the Java Virtual Machine
 * has been instructed to retain these annotations via some
 * implementation-specific mechanism such as a command line flag. In the absence
 * of such instructions, the Java Virtual Machine ignores this attribute.
 *
 * The {@code RuntimeInvisibleAnnotations} attribute has the following format:
 * <pre>
 * RuntimeInvisibleAnnotations_attribute {
 *    u2         attribute_name_index;
 *    u4         attribute_length;
 *
 *    u2         num_annotations;
 *    annotation annotations[num_annotations];
 *}
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.17">
 * VM Spec: The RuntimeInvisibleAnnotations Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeInvisibleAnnotations_attribute extends RuntimeAnnotations {

    RuntimeInvisibleAnnotations_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeInvisibleAnnotations";
    }

    @Override
    String getMessageKey_4_annotations() {
        return "msg_attr_RuntimeInvisibleAnnotations__annotations";
    }

    @Override
    String getMessageKey_4_num_annotations() {
        return "msg_attr_RuntimeInvisibleAnnotations__num_annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeInvisibleParameterAnnotations_attribute.java`:

```java
/*
 * AttributeRuntimeVisibleParameterAnnotations.java    11:25 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code RuntimeInvisibleParameterAnnotations} attribute is similar to the
 * {@code RuntimeVisibleParameterAnnotations} attribute, except that the
 * annotations represented by a {@code RuntimeInvisibleParameterAnnotations}
 * attribute must not be made available for return by reflective APIs, unless
 * the Java Virtual Machine has specifically been instructed to retain these
 * annotations via some implementation-specific mechanism such as a command line
 * flag. In the absence of such instructions, the Java Virtual Machine ignores
 * this attribute.
 *
 * The {@code RuntimeInvisibleParameterAnnotations} attribute has the following
 * format:
 * <pre>
 * RuntimeInvisibleParameterAnnotations_attribute {
 *    u2 attribute_name_index;
 *    u4 attribute_length;
 *
 *    u1 num_parameters;
 *    {   u2         num_annotations;
 *        annotation annotations[num_annotations];
 *    } parameter_annotations[num_parameters];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.19">
 * VM Spec: The RuntimeInvisibleParameterAnnotations attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeInvisibleParameterAnnotations_attribute extends RuntimeParameterAnnotations {

    RuntimeInvisibleParameterAnnotations_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws java.io.IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeInvisibleParameterAnnotations";
    }

    @Override
    String getMessageKey_4_num_parameters() {
        return "msg_attr_RuntimeInvisibleParameterAnnotations__num_parameters";
    }

    @Override
    String getMessageKey_4_parameter_annotations() {
        return "msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations";
    }

    @Override
    String getMessageKey_4_parameter_annotations__num_annotations() {
        return "msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations__num_annotations";
    }

    @Override
    String getMessageKey_4_parameter_annotations__annotations() {
        return "msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations__annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeInvisibleTypeAnnotations_attribute.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The RuntimeInvisibleTypeAnnotations attribute records run-time invisible
 * annotations on types used in the corresponding declaration of a class, field,
 * or method, or in an expression in the corresponding method body. The
 * RuntimeInvisibleTypeAnnotations attribute also records annotations on type
 * parameter declarations of generic classes, interfaces, methods, and
 * constructors.
 *
 * The RuntimeInvisibleTypeAnnotations attribute has the following format:
 * <pre>
 *   RuntimeInvisibleTypeAnnotations_attribute {
 *     u2              attribute_name_index;
 *     u4              attribute_length;
 *
 *     u2              num_annotations;
 *     type_annotation annotations[num_annotations];
 *   }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 8
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.21">
 * VM Spec: The RuntimeInvisibleTypeAnnotations Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeInvisibleTypeAnnotations_attribute extends RuntimeTypeAnnotations {

    public RuntimeInvisibleTypeAnnotations_attribute(u2 nameIndex, String name, PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, name, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeInvisibleTypeAnnotations";
    }

    @Override
    String getMessageKey_4_annotations() {
        return "msg_attr_RuntimeInvisibleTypeAnnotations__annotations";
    }

    @Override
    String getMessageKey_4_num_annotations() {
        return "msg_attr_RuntimeInvisibleTypeAnnotations__num_annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeParameterAnnotations.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 * The Runtime(In)VisibleParameterAnnotations Attribute.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from JVM spec instead
 * java:S101 - Class names should comply with a naming convention  --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention  --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116"})
public abstract class RuntimeParameterAnnotations extends attribute_info {

    public final u1 num_parameters;
    public final parameter_annotations[] parameter_annotations;

    RuntimeParameterAnnotations(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.num_parameters = new u1(posDataInputStream);
        if (this.num_parameters.value > 0) {
            this.parameter_annotations = new parameter_annotations[this.num_parameters.value];
            for (int i = 0; i < this.num_parameters.value; i++) {
                this.parameter_annotations[i] = new parameter_annotations(posDataInputStream);
            }
        } else {
            this.parameter_annotations = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        int startPosMoving = super.startPos;

        this.addNode(parentNode,
                startPosMoving + 6, 1,
                "num_parameters", this.num_parameters.value,
                this.getMessageKey_4_num_parameters(), Icons.Counter
        );

        if (this.parameter_annotations != null && this.parameter_annotations.length > 0) {
            DefaultMutableTreeNode parameterAnnotationsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving + 7,
                    this.getLength() - 7,
                    String.format("parameter_annotations [%d]", this.parameter_annotations.length),
                    MESSAGES.getString(this.getMessageKey_4_parameter_annotations())
            ));
            parentNode.add(parameterAnnotationsNode);

            for (int i = 0; i < this.parameter_annotations.length; i++) {
                DefaultMutableTreeNode parameterAnnotation = this.addNode(parameterAnnotationsNode,
                        this.parameter_annotations[i].getStartPos(),
                        this.parameter_annotations[i].getLength(),
                        String.valueOf(i + 1),
                        "parameter_annotation",
                        this.getMessageKey_4_parameter_annotations(),
                        Icons.Annotations
                );
                this.parameter_annotations[i].generateTreeNode(parameterAnnotation, fileFormat);
            }
        }
    }

    /**
     * Get message key for {@link #num_parameters}.
     *
     * @return Message key for {@link #num_parameters}
     *
     * @see RuntimeVisibleParameterAnnotations_attribute
     * @see RuntimeInvisibleParameterAnnotations_attribute
     */
    abstract String getMessageKey_4_num_parameters();

    /**
     * Get message key for {@link #parameter_annotations}.
     *
     * @return Message key for {@link #parameter_annotations}
     *
     * @see RuntimeVisibleParameterAnnotations_attribute
     * @see RuntimeInvisibleParameterAnnotations_attribute
     */
    abstract String getMessageKey_4_parameter_annotations();

    /**
     * Get message key for {@link parameter_annotations#num_annotations}.
     *
     * @return Message key for {@link parameter_annotations#num_annotations}
     *
     * @see RuntimeVisibleParameterAnnotations_attribute
     * @see RuntimeInvisibleParameterAnnotations_attribute
     */
    abstract String getMessageKey_4_parameter_annotations__num_annotations();

    /**
     * Get message key for {@link parameter_annotations#annotations}0.
     *
     * @return Message key for {@link parameter_annotations#annotations}
     *
     * @see RuntimeVisibleParameterAnnotations_attribute
     * @see RuntimeInvisibleParameterAnnotations_attribute
     */
    abstract String getMessageKey_4_parameter_annotations__annotations();

    public class parameter_annotations extends FileComponent implements GenerateTreeNodeClassFile {

        public final u2 num_annotations;
        public final Annotation[] annotations;

        private parameter_annotations(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            this.startPos = posDataInputStream.getPos();

            this.num_annotations = new u2(posDataInputStream);
            if (this.num_annotations.value > 0) {
                this.annotations = new Annotation[this.num_annotations.value];
                for (int i = 0; i < this.num_annotations.value; i++) {
                    this.annotations[i] = new Annotation(posDataInputStream);
                }
            } else {
                this.annotations = null;
            }

            this.length = posDataInputStream.getPos() - this.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            this.addNode(parentNode,
                    startPosMoving, u2.LENGTH,
                    "num_annotations", RuntimeParameterAnnotations.this.getMessageKey_4_parameter_annotations__num_annotations(),
                    "msg_version", Icons.Counter
            );

            if (this.annotations != null && this.annotations.length > 0) {
                DefaultMutableTreeNode annotationsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving + 2,
                        this.getLength() - 2,
                        String.format("annotations [%d]", this.annotations.length),
                        MESSAGES.getString(RuntimeParameterAnnotations.this.getMessageKey_4_parameter_annotations__annotations())
                ));
                parentNode.add(annotationsNode);

                for (int i = 0; i < this.annotations.length; i++) {
                    DefaultMutableTreeNode annotationNode = this.addNode(annotationsNode,
                            this.annotations[i].getStartPos(),
                            this.annotations[i].getLength(),
                            String.valueOf(i + 1),
                            classFile.getCPDescription(this.annotations[i].type_index.value),
                            RuntimeParameterAnnotations.this.getMessageKey_4_parameter_annotations__annotations(),
                            Icons.Annotations
                    );
                    this.annotations[i].generateTreeNode(annotationNode, fileFormat);
                }
            }
        } // End generateTreeNode()
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeTypeAnnotations.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 * The Runtime(In)VisibleTypeAnnotations Attribute.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from JVM spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S5993"})
public abstract class RuntimeTypeAnnotations extends attribute_info {

    public final u2 num_annotations;
    public final type_annotation[] annotations;

    public RuntimeTypeAnnotations(u2 nameIndex, String name, PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, name, posDataInputStream);

        this.num_annotations = new u2(posDataInputStream);
        if (this.num_annotations.value > 0) {
            this.annotations = new type_annotation[this.num_annotations.value];
            for (int i = 0; i < this.num_annotations.value; i++) {
                this.annotations[i] = new type_annotation(posDataInputStream);
            }
        } else {
            this.annotations = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get message key for {@link #annotations}.
     *
     * @return Message key for {@link #annotations}
     *
     * @see RuntimeVisibleTypeAnnotations_attribute
     * @see RuntimeInvisibleTypeAnnotations_attribute
     */
    abstract String getMessageKey_4_annotations();

    /**
     * Get message key for {@link #num_annotations}.
     *
     * @return Message key for {@link #num_annotations}
     *
     * @see RuntimeVisibleTypeAnnotations_attribute
     * @see RuntimeInvisibleTypeAnnotations_attribute
     */
    abstract String getMessageKey_4_num_annotations();

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, final FileFormat classFile) {
        int startPosMoving = super.startPos;
        this.addNode(parentNode,
                startPosMoving + 6,
                u2.LENGTH,
                "num_annotations",
                this.num_annotations.value,
                this.getMessageKey_4_num_annotations(),
                Icons.Counter
        );

        if (this.annotations != null && this.annotations.length > 0) {
            DefaultMutableTreeNode annotationsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving + 8,
                    this.getLength() - 8,
                    String.format("annotations [%d]", this.annotations.length),
                    MESSAGES.getString(this.getMessageKey_4_annotations())
            ));
            parentNode.add(annotationsNode);

            for (int i = 0; i < this.annotations.length; i++) {
                DefaultMutableTreeNode typeAnnotationNode = this.addNode(annotationsNode,
                        this.annotations[i].getStartPos(),
                        this.annotations[i].getLength(),
                        String.valueOf(i + 1),
                        "type_annotation",
                        this.getMessageKey_4_annotations(),
                        Icons.Annotations
                );
                this.annotations[i].generateTreeNode(typeAnnotationNode, classFile);
            }
        }
    }

    /**
     * The <code>type_annotation</code> structure has the following format.
     *
     * <pre>
     * type_annotation {
     *   u1 target_type;
     *   union {
     *     type_parameter_target;
     *     supertype_target;
     *     type_parameter_bound_target;
     *     empty_target;
     *     formal_parameter_target;
     *     throws_target;
     *     localvar_target;
     *     catch_target;
     *     offset_target;
     *     type_argument_target;
     *   } target_info;
     *   type_path target_path;
     *
     *   u2        type_index;
     *   u2        num_element_value_pairs;
     *   {   u2            element_name_index;
     *       element_value value;
     *   } element_value_pairs[num_element_value_pairs];
     * }
     * </pre>
     */
    public static class type_annotation extends FileComponent implements GenerateTreeNodeClassFile {

        public final u1 target_type;
        public final type_parameter_target union_type_parameter_target;
        public final supertype_target union_supertype_target;
        public final type_parameter_bound_target union_type_parameter_bound_target;
        public final empty_target union_empty_target;
        public final formal_parameter_target union_method_formal_parameter_target;
        public final throws_target union_throws_target;
        public final localvar_target union_localvar_target;
        public final catch_target union_catch_target;
        public final offset_target union_offset_target;
        public final type_argument_target union_type_argument_target;
        public final type_path target_path;
        /**
         * The rest fields are the same as {@link Annotation}
         */
        public final Annotation at;

        /**
         * <pre>
         * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
         * </pre>
         *
         * @param posDataInputStream Input stream
         * @throws IOException Read file failed
         * @throws FileFormatException Invalid file format
         */
        @SuppressWarnings("java:S3776")
        public type_annotation(PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            this.target_type = new u1(posDataInputStream);
            if (this.target_type.value == TargetType.VALUE_HEX_00.value
                    || this.target_type.value == TargetType.VALUE_HEX_01.value) {
                this.union_type_parameter_target = new type_parameter_target(posDataInputStream);
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_10.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = new supertype_target(posDataInputStream);
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_11.value
                    || this.target_type.value == TargetType.VALUE_HEX_12.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = new type_parameter_bound_target(posDataInputStream);
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_13.value
                    || this.target_type.value == TargetType.VALUE_HEX_14.value
                    || this.target_type.value == TargetType.VALUE_HEX_15.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = new empty_target(posDataInputStream);
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_16.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = new formal_parameter_target(posDataInputStream);
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_17.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = new throws_target(posDataInputStream);
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_40.value
                    || this.target_type.value == TargetType.VALUE_HEX_41.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = new localvar_target(posDataInputStream);
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_42.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = new catch_target(posDataInputStream);
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_43.value
                    || this.target_type.value == TargetType.VALUE_HEX_44.value
                    || this.target_type.value == TargetType.VALUE_HEX_45.value
                    || this.target_type.value == TargetType.VALUE_HEX_46.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = new offset_target(posDataInputStream);
                this.union_type_argument_target = null;
            } else if (this.target_type.value == TargetType.VALUE_HEX_47.value
                    || this.target_type.value == TargetType.VALUE_HEX_48.value
                    || this.target_type.value == TargetType.VALUE_HEX_49.value
                    || this.target_type.value == TargetType.VALUE_HEX_4A.value
                    || this.target_type.value == TargetType.VALUE_HEX_4B.value) {
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = new type_argument_target(posDataInputStream);
            } else {
                // If nothing matches, we do not throw exception, but trying to go through
                // Since later on, we will check the Attribute Length anyway
                this.union_type_parameter_target = null;
                this.union_supertype_target = null;
                this.union_type_parameter_bound_target = null;
                this.union_empty_target = null;
                this.union_method_formal_parameter_target = null;
                this.union_throws_target = null;
                this.union_localvar_target = null;
                this.union_catch_target = null;
                this.union_offset_target = null;
                this.union_type_argument_target = null;
            }
            this.target_path = new type_path(posDataInputStream);
            this.at = new Annotation(posDataInputStream);
            super.length = posDataInputStream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            final ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            this.addNode(parentNode,
                    startPosMoving,
                    u1.LENGTH,
                    "target_type",
                    String.format("0x%02X", this.target_type.value),
                    "msg_attr_type_annotation__target_type",
                    Icons.Tag
            );
            startPosMoving += u1.LENGTH;

            if (this.union_type_parameter_target != null) {
                DefaultMutableTreeNode typeParameterTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_type_parameter_target.getLength(),
                        type_annotation.type_parameter_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__type_parameter_target"
                ));
                parentNode.add(typeParameterTarget);

                this.addNode(typeParameterTarget,
                        startPosMoving,
                        u1.LENGTH,
                        "type_parameter_index",
                        this.union_type_parameter_target.type_parameter_index.value,
                        "msg_attr_type_annotation__target_info__type_parameter_target__type_parameter_index",
                        Icons.Index
                );
                startPosMoving += u1.LENGTH;

            } else if (this.union_supertype_target != null) {
                DefaultMutableTreeNode supertypeTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_supertype_target.getLength(),
                        type_annotation.supertype_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__supertype_target"
                ));
                parentNode.add(supertypeTarget);

                this.addNode(supertypeTarget,
                        startPosMoving,
                        u2.LENGTH,
                        "supertype_index",
                        this.union_supertype_target.supertype_index.value,
                        "msg_attr_type_annotation__target_info__supertype_target__supertype_index",
                        Icons.Index
                );
                startPosMoving += u2.LENGTH;

            } else if (this.union_type_parameter_bound_target != null) {
                DefaultMutableTreeNode typeParameterBoundTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_type_parameter_bound_target.getLength(),
                        type_annotation.type_parameter_bound_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__type_parameter_bound_target"
                ));
                parentNode.add(typeParameterBoundTarget);
                this.union_type_parameter_bound_target.generateTreeNode(typeParameterBoundTarget, fileFormat);

                startPosMoving += type_parameter_bound_target.LENGTH;

            } else if (this.union_empty_target != null) {
                // Do nothing since it is empty

            } else if (this.union_method_formal_parameter_target != null) {
                DefaultMutableTreeNode formalParameterTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_method_formal_parameter_target.getLength(),
                        type_annotation.formal_parameter_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__formal_parameter_target"
                ));
                parentNode.add(formalParameterTarget);

                this.addNode(formalParameterTarget,
                        startPosMoving,
                        u1.LENGTH,
                        "formal_parameter_index",
                        this.union_method_formal_parameter_target.formal_parameter_index.value,
                        "msg_attr_type_annotation__target_info__formal_parameter_target__formal_parameter_index",
                        Icons.Index
                );
                startPosMoving += u1.LENGTH;

            } else if (this.union_throws_target != null) {
                DefaultMutableTreeNode throwsTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_throws_target.getLength(),
                        type_annotation.throws_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__throws_target"
                ));
                parentNode.add(throwsTarget);

                this.addNode(throwsTarget,
                        startPosMoving, u2.LENGTH,
                        "throws_type_index", this.union_throws_target.throws_type_index.value,
                        "msg_attr_type_annotation__target_info__throws_target__throws_type_index",
                        Icons.Index
                );
                startPosMoving += u2.LENGTH;

            } else if (this.union_localvar_target != null) {
                DefaultMutableTreeNode localvarTargetNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_localvar_target.getLength(),
                        type_annotation.localvar_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__localvar_target"
                ));
                startPosMoving += this.union_localvar_target.getLength();
                parentNode.add(localvarTargetNode);

                this.union_localvar_target.generateTreeNode(localvarTargetNode, fileFormat);

            } else if (this.union_catch_target != null) {
                DefaultMutableTreeNode catchTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_catch_target.getLength(),
                        type_annotation.catch_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__catch_target"
                ));
                parentNode.add(catchTarget);

                this.addNode(catchTarget,
                        startPosMoving, u2.LENGTH,
                        "exception_table_index", this.union_catch_target.exception_table_index.value,
                        "msg_attr_type_annotation__target_info__catch_target__exception_table_index",
                        Icons.Index
                );
                startPosMoving += u2.LENGTH;

            } else if (this.union_offset_target != null) {
                DefaultMutableTreeNode offsetTarget = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_offset_target.getLength(),
                        type_annotation.offset_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__offset_target"
                ));
                parentNode.add(offsetTarget);

                this.addNode(offsetTarget,
                        startPosMoving, u2.LENGTH,
                        "offset", this.union_offset_target.offset.value,
                        "msg_attr_type_annotation__target_info__offset_target__offset",
                        Icons.Offset
                );
                startPosMoving += u2.LENGTH;

            } else if (this.union_type_argument_target != null) {
                DefaultMutableTreeNode typeArgumentTargetNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.union_type_argument_target.getLength(),
                        type_annotation.type_argument_target.UNION_NAME,
                        "msg_attr_type_annotation__target_info__type_argument_target"
                ));
                startPosMoving += this.union_type_argument_target.getLength();
                parentNode.add(typeArgumentTargetNode);

                this.union_type_argument_target.generateTreeNode(typeArgumentTargetNode, fileFormat);
            }

            // target_path
            DefaultMutableTreeNode targetPathNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPosMoving,
                    this.target_path.getLength(),
                    "target_path",
                    MESSAGES.getString("msg_attr_type_annotation__target_path")
            ));
            parentNode.add(targetPathNode);
            this.target_path.generateTreeNode(targetPathNode, fileFormat);

            // Annotation
            this.at.generateTreeNode(parentNode, classFile);
        }

        public enum TargetType {

            /**
             * type parameter declaration of generic class or interface.
             */
            VALUE_HEX_00(0x00),
            /**
             * type parameter declaration of generic method or constructor.
             */
            VALUE_HEX_01(0x01),
            /**
             * type in extends or implements clause of class declaration
             * (including the direct superclass or direct superinterface of an
             * anonymous class declaration), or in extends clause of interface
             * declaration.
             */
            VALUE_HEX_10(0x10),
            /**
             * type in bound of type parameter declaration of generic class or
             * interface.
             */
            VALUE_HEX_11(0x11),
            /**
             * type in bound of type parameter declaration of generic method or
             * constructor.
             */
            VALUE_HEX_12(0x12),
            /**
             * type in field declaration.
             */
            VALUE_HEX_13(0x13),
            /**
             * return type of method, or type of newly constructed object.
             */
            VALUE_HEX_14(0x14),
            /**
             * receiver type of method or constructor.
             */
            VALUE_HEX_15(0x15),
            /**
             * type in formal parameter declaration of method, constructor, or
             * lambda expression.
             */
            VALUE_HEX_16(0x16),
            /**
             * type in throws clause of method or constructor.
             */
            VALUE_HEX_17(0x17),
            /**
             * type in local variable declaration.
             */
            VALUE_HEX_40(0x40),
            /**
             * type in resource variable declaration.
             */
            VALUE_HEX_41(0x41),
            /**
             * type in exception parameter declaration.
             */
            VALUE_HEX_42(0x42),
            /**
             * type in instanceof expression.
             */
            VALUE_HEX_43(0x43),
            /**
             * type in new expression.
             */
            VALUE_HEX_44(0x44),
            /**
             * type in method reference expression using ::new.
             */
            VALUE_HEX_45(0x45),
            /**
             * type in method reference expression using ::Identifier.
             */
            VALUE_HEX_46(0x46),
            /**
             * type in cast expression.
             */
            VALUE_HEX_47(0x47),
            /**
             * type argument for generic constructor in new expression or
             * explicit constructor invocation statement.
             */
            VALUE_HEX_48(0x48),
            /**
             * type argument for generic method in method invocation expression.
             */
            VALUE_HEX_49(0x49),
            /**
             * type argument for generic constructor in method reference
             * expression using ::new.
             */
            VALUE_HEX_4A(0x4A),
            /**
             * type argument for generic method in method reference expression
             * using ::Identifier.
             */
            VALUE_HEX_4B(0x4B);

            /**
             * Internal value of the enum.
             */
            public final short value;

            TargetType(Integer v) {
                this.value = v.shortValue();
            }

            /**
             * Get union name in <code>type_annotation</code> structure.
             *
             * @param v {@link #value} of {@link TargetType}
             * @return <code>type_annotation</code> structure union name
             *
             * <pre>
             * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
             * </pre>
             */
            @SuppressWarnings("java:S3776")
            public static String getTargetUnionName(short v) {
                String unionName;

                if (v == VALUE_HEX_00.value
                        || v == VALUE_HEX_01.value) {
                    unionName = type_parameter_target.UNION_NAME;
                } else if (v == VALUE_HEX_10.value) {
                    unionName = supertype_target.UNION_NAME;
                } else if (v == VALUE_HEX_11.value
                        || v == VALUE_HEX_12.value) {
                    unionName = type_parameter_bound_target.UNION_NAME;
                } else if (v == VALUE_HEX_13.value
                        || v == VALUE_HEX_14.value
                        || v == VALUE_HEX_15.value) {
                    unionName = empty_target.UNION_NAME;
                } else if (v == VALUE_HEX_16.value) {
                    unionName = formal_parameter_target.UNION_NAME;
                } else if (v == VALUE_HEX_17.value) {
                    unionName = throws_target.UNION_NAME;
                } else if (v == VALUE_HEX_40.value
                        || v == VALUE_HEX_41.value) {
                    unionName = localvar_target.UNION_NAME;
                } else if (v == VALUE_HEX_42.value) {
                    unionName = catch_target.UNION_NAME;
                } else if (v == VALUE_HEX_43.value
                        || v == VALUE_HEX_44.value
                        || v == VALUE_HEX_45.value
                        || v == VALUE_HEX_46.value) {
                    unionName = offset_target.UNION_NAME;
                } else if (v == VALUE_HEX_47.value
                        || v == VALUE_HEX_48.value
                        || v == VALUE_HEX_49.value
                        || v == VALUE_HEX_4A.value
                        || v == VALUE_HEX_4B.value) {
                    unionName = type_argument_target.UNION_NAME;
                } else {
                    unionName = "Un-recognized";
                }

                return unionName;
            }

        }

        /**
         * The type_parameter_target item indicates that an annotation appears
         * on the declaration of the i'th type parameter of a generic class,
         * generic interface, generic method, or generic constructor.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.20.1">
         * VM Spec: The target_info union - type_parameter_target
         * </a>
         */
        public static final class type_parameter_target extends FileComponent {

            public static final String UNION_NAME = "type_parameter_target";

            /**
             * The value of the type_parameter_index item specifies which type
             * parameter declaration is annotated. A type_parameter_index value
             * of 0 specifies the first type parameter declaration.
             */
            public final u1 type_parameter_index;

            protected type_parameter_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.type_parameter_index = new u1(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        /**
         * The supertype_target item indicates that an annotation appears on a
         * type in the extends or implements clause of a class or interface
         * declaration.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.20.1">
         * VM Spec: The target_info union - supertype_target
         * </a>
         */
        public static final class supertype_target extends FileComponent {

            public static final String UNION_NAME = "supertype_target";

            /**
             * A supertype_index value of 65535 specifies that the annotation
             * appears on the superclass in an extends clause of a class
             * declaration.
             */
            public static final int SUPERTYPE_INDEX_SUERCLASS = 65535;

            /**
             * A supertype_index value of 65535 specifies that the annotation
             * appears on the superclass in an extends clause of a class
             * declaration. Any other supertype_index value is an index into the
             * interfaces array of the enclosing ClassFile structure, and
             * specifies that the annotation appears on that superinterface in
             * either the implements clause of a class declaration or the
             * extends clause of an interface declaration.
             */
            public final u2 supertype_index;

            protected supertype_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.supertype_index = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        public static final class type_parameter_bound_target extends FileComponent implements GenerateTreeNodeClassFile {

            public static final int LENGTH = u1.LENGTH + u1.LENGTH;
            public static final String UNION_NAME = "type_parameter_bound_target";
            public final u1 type_parameter_index;
            public final u1 bound_index;

            protected type_parameter_bound_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.type_parameter_index = new u1(posDataInputStream);
                this.bound_index = new u1(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving,
                        u1.LENGTH,
                        "type_parameter_index",
                        this.type_parameter_index.value,
                        "msg_attr_type_annotation__target_info__type_parameter_bound_target__type_parameter_index",
                        Icons.Index
                );
                startPosMoving += u1.LENGTH;

                this.addNode(parentNode,
                        startPosMoving,
                        u1.LENGTH,
                        "bound_index",
                        this.bound_index.value,
                        "msg_attr_type_annotation__target_info__type_parameter_bound_target__bound_index",
                        Icons.Index
                );
            }
        }

        public static final class empty_target extends FileComponent {

            public static final String UNION_NAME = "empty_target";

            protected empty_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                super.length = 0;
            }
        }

        public static final class formal_parameter_target extends FileComponent {

            public static final String UNION_NAME = "formal_parameter_target";
            public final u1 formal_parameter_index;

            protected formal_parameter_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.formal_parameter_index = new u1(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        public static final class throws_target extends FileComponent {

            public static final String UNION_NAME = "throws_target";
            public final u2 throws_type_index;

            protected throws_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.throws_type_index = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        /**
         * The <code>localvar_target</code> item indicates that an annotation
         * appears on the type in a local variable declaration, including a
         * variable declared as a resource in a try-with-resources statement.
         *
         * <pre>
         * localvar_target {
         *     u2 table_length;
         *     {   u2 start_pc;
         *         u2 length;
         *         u2 index;
         *     } table[table_length];
         * }
         * </pre>
         */
        public static final class localvar_target extends FileComponent implements GenerateTreeNodeClassFile {

            public static final String UNION_NAME = "localvar_target";
            public final u2 table_length;
            public final Table[] table;

            protected localvar_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.table_length = new u2(posDataInputStream);
                if (this.table_length.value > 0) {
                    this.table = new Table[this.table_length.value];
                    for (int i = 0; i < this.table_length.value; i++) {
                        this.table[i] = new Table(posDataInputStream);
                    }
                } else {
                    this.table = null;
                }
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving,
                        u2.LENGTH,
                        "table_length",
                        this.table_length.value,
                        "msg_attr_type_annotation__target_info__localvar_target__table_length",
                        Icons.Length
                );
                startPosMoving += u2.LENGTH;

                if (this.table == null || this.table.length < 1) {
                    return;
                }

                DefaultMutableTreeNode tablesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.getLength() - u2.LENGTH,
                        String.format("table [%d]", this.table.length),
                        MESSAGES.getString("msg_attr_type_annotation__target_info__localvar_target__table")
                ));
                parentNode.add(tablesNode);
                for (int i = 0; i < this.table.length; i++) {
                    DefaultMutableTreeNode tableNode = this.addNode(tablesNode,
                            this.table[i].getStartPos(),
                            this.table[i].getLength(),
                            String.valueOf(i + 1),
                            "table",
                            "msg_attr_type_annotation__target_info__localvar_target__table",
                            Icons.Data
                    );
                    this.table[i].generateTreeNode(tableNode, fileFormat);
                }
            }

            public static final class Table extends FileComponent implements GenerateTreeNodeClassFile {

                public final u2 start_pc;
                public final u2 length_code;
                public final u2 index;

                protected Table(final PosDataInputStream posDataInputStream) throws IOException {
                    super.startPos = posDataInputStream.getPos();
                    this.start_pc = new u2(posDataInputStream);
                    this.length_code = new u2(posDataInputStream);
                    this.index = new u2(posDataInputStream);
                    super.length = posDataInputStream.getPos() - super.startPos;
                }

                @Override
                public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                    int startPosMoving = this.getStartPos();
                    this.addNode(parentNode,
                            startPosMoving, u2.LENGTH,
                            "start_pc", this.start_pc.value,
                            "msg_attr_type_annotation__target_info__localvar_target__table__start_pc_length",
                            Icons.Offset
                    );
                    startPosMoving += u2.LENGTH;

                    this.addNode(parentNode,
                            startPosMoving, u2.LENGTH,
                            "length", this.length_code.value,
                            "msg_attr_type_annotation__target_info__localvar_target__table__start_pc_length",
                            Icons.Length
                    );
                    startPosMoving += u2.LENGTH;

                    this.addNode(parentNode,
                            startPosMoving, u2.LENGTH,
                            "index", this.index.value,
                            "msg_attr_type_annotation__target_info__localvar_target__table__index",
                            Icons.Index
                    );
                } // End of generateTreeNode()
            }
        }

        public static final class catch_target extends FileComponent {

            public static final String UNION_NAME = "catch_target";
            public final u2 exception_table_index;

            protected catch_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.exception_table_index = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        public static final class offset_target extends FileComponent {

            public static final String UNION_NAME = "offset_target";
            public final u2 offset;

            protected offset_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }
        }

        public static final class type_argument_target extends FileComponent implements GenerateTreeNodeClassFile {

            public static final String UNION_NAME = "type_argument_target";
            public final u2 offset;
            public final u1 type_argument_index;

            protected type_argument_target(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset = new u2(posDataInputStream);
                this.type_argument_index = new u1(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        "offset", this.offset.value,
                        "msg_attr_type_annotation__target_info__type_argument_target__offset",
                        Icons.Offset
                );
                startPosMoving += u2.LENGTH;

                this.addNode(parentNode,
                        startPosMoving, u1.LENGTH,
                        "type_argument_index", this.type_argument_index.value,
                        "msg_attr_type_annotation__target_info__type_argument_target__type_argument_index",
                        Icons.Index
                );
            }
        }

        public static final class type_path extends FileComponent implements GenerateTreeNodeClassFile {

            public final u1 path_length;
            public final Path[] path;

            protected type_path(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.path_length = new u1(posDataInputStream);
                if (this.path_length.value > 0) {
                    this.path = new Path[this.path_length.value];
                    for (int i = 0; i < this.path_length.value; i++) {
                        this.path[i] = new Path(posDataInputStream);
                    }
                } else {
                    this.path = null;
                }
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving, u1.LENGTH,
                        "path_length", this.path_length.value,
                        "msg_attr_type_path__path_length",
                        Icons.Length
                );
                startPosMoving += u1.LENGTH;

                if (this.path == null || this.path.length < 1) {
                    return;
                }

                DefaultMutableTreeNode pathsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.getLength() - u1.LENGTH,
                        String.format("path [%d]", this.path.length),
                        "msg_attr_type_path__path"
                ));
                parentNode.add(pathsNode);
                for (int i = 0; i < this.path.length; i++) {
                    DefaultMutableTreeNode pathNode = this.addNode(pathsNode,
                            this.path[i].getStartPos(),
                            this.path[i].getLength(),
                            String.valueOf(i + 1),
                            "path",
                            "msg_attr_type_path__path",
                            Icons.Data
                    );
                    this.path[i].generateTreeNode(pathNode, fileFormat);
                }
            }

            public static final class Path extends FileComponent implements GenerateTreeNodeClassFile {

                /**
                 * @see TypePathKind
                 */
                public final u1 type_path_kind;
                public final u1 type_argument_index;

                protected Path(final PosDataInputStream posDataInputStream) throws IOException {
                    super.startPos = posDataInputStream.getPos();
                    this.type_path_kind = new u1(posDataInputStream);
                    this.type_argument_index = new u1(posDataInputStream);
                    super.length = posDataInputStream.getPos() - super.startPos;
                }

                @Override
                public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                    int startPosMoving = this.getStartPos();

                    short pathKind = this.type_path_kind.value;
                    this.addNode(parentNode,
                            startPosMoving, u1.LENGTH,
                            "type_path_kind",
                            pathKind + " + " + TypePathKind.getDescription(pathKind),
                            "msg_attr_type_path__type_path_kind",
                            Icons.Kind
                    );
                    startPosMoving += u1.LENGTH;

                    this.addNode(parentNode,
                            startPosMoving, u1.LENGTH,
                            "type_argument_index",
                            this.type_argument_index.value,
                            "msg_attr_type_path__type_argument_index",
                            Icons.Index
                    );
                }
            }

            public enum TypePathKind {

                /**
                 * Annotation is deeper in an array type.
                 */
                VALUE_0(0, "Annotation is deeper in an array type"),
                /**
                 * Annotation is deeper in a nested type.
                 */
                VALUE_1(1, "Annotation is deeper in a nested type"),
                /**
                 * Annotation is on the bound of a wildcard type argument of a
                 * parameterized type.
                 */
                VALUE_2(2, "Annotation is on the bound of a wildcard type argument of a parameterized type"),
                /**
                 * Annotation is on a type argument of a parameterized type.
                 */
                VALUE_3(3, "Annotation is on a type argument of a parameterized type");

                /**
                 * Internal value of the type path kind.
                 */
                public final short value;
                /**
                 * Description of the type path kind.
                 */
                public final String description;

                TypePathKind(Integer v, String d) {
                    this.value = v.shortValue();
                    this.description = d;
                }

                public static String getDescription(short v) {
                    for (TypePathKind item : TypePathKind.values()) {
                        if (item.value == v) {
                            return item.description;
                        }
                    }

                    return "Un-Recognized";
                }
            }
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeVisibleAnnotations_attribute.java`:

```java
/*
 * RuntimeVisibleAnnotations_attribute.java    09:24 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code RuntimeVisibleAnnotations} attribute. The
 * {@code RuntimeVisibleAnnotations} attribute has the following format:
 *
 * <pre>
 * RuntimeVisibleAnnotations_attribute {
 *   u2         attribute_name_index;
 *   u4         attribute_length;
 *
 *   u2         num_annotations;
 *   annotation annotations[num_annotations];
 * }
 *
 * annotation {
 *   u2 type_index;
 *   u2 num_element_value_pairs;
 *   {   u2            element_name_index;
 *       element_value value;
 *   } element_value_pairs[num_element_value_pairs];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16">
 * VM Spec: The RuntimeVisibleAnnotations Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeVisibleAnnotations_attribute extends RuntimeAnnotations {

    RuntimeVisibleAnnotations_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeVisibleAnnotations";
    }

    @Override
    String getMessageKey_4_annotations() {
        return "msg_attr_RuntimeVisibleAnnotations__annotations";
    }

    @Override
    String getMessageKey_4_num_annotations() {
        return "msg_attr_RuntimeVisibleAnnotations__num_annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeVisibleParameterAnnotations_attribute.java`:

```java
/*
 * AttributeRuntimeVisibleParameterAnnotations.java    11:25 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code RuntimeVisibleParameterAnnotations} attribute is a variable-length
 * attribute in the {@code attributes} table of the {@code method_info}
 * structure. The {@code RuntimeVisibleParameterAnnotations} attribute records
 * run-time-visible Java programming language annotations on the parameters of
 * the corresponding method.
 *
 * The {@code RuntimeVisibleParameterAnnotations} attribute has the following
 * format:
 * <pre>
 * RuntimeVisibleParameterAnnotations_attribute {
 *    u2 attribute_name_index;
 *    u4 attribute_length;
 *
 *    u1 num_parameters;
 *    {   u2         num_annotations;
 *        annotation annotations[num_annotations];
 *    } parameter_annotations[num_parameters];
 * }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.18">
 * VM Spec: The RuntimeVisibleParameterAnnotations attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeVisibleParameterAnnotations_attribute extends RuntimeParameterAnnotations {

    RuntimeVisibleParameterAnnotations_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeVisibleParameterAnnotations";
    }

    @Override
    String getMessageKey_4_num_parameters() {
        return "msg_attr_RuntimeVisibleParameterAnnotations__num_parameters";
    }

    @Override
    String getMessageKey_4_parameter_annotations() {
        return "msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations";
    }

    @Override
    String getMessageKey_4_parameter_annotations__num_annotations() {
        return "msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations__num_annotations";
    }

    @Override
    String getMessageKey_4_parameter_annotations__annotations() {
        return "msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations__annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/RuntimeVisibleTypeAnnotations_attribute.java`:

```java
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The RuntimeVisibleTypeAnnotations attribute records run-time visible
 * annotations on types used in the declaration of the corresponding class,
 * field, or method, or in an expression in the corresponding method body. The
 * RuntimeVisibleTypeAnnotations attribute also records run-time visible
 * annotations on type parameter declarations of generic classes, interfaces,
 * methods, and constructors. The Java Virtual Machine must make these
 * annotations available so they can be returned by the appropriate reflective
 * APIs.
 *
 * The RuntimeVisibleTypeAnnotations attribute has the following format:
 * <pre>
 *   RuntimeVisibleTypeAnnotations_attribute {
 *     u2              attribute_name_index;
 *     u4              attribute_length;
 *
 *     u2              num_annotations;
 *     type_annotation annotations[num_annotations];
 *   }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 8
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.20">
 * VM Spec: The RuntimeVisibleTypeAnnotations Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class RuntimeVisibleTypeAnnotations_attribute extends RuntimeTypeAnnotations {

    public RuntimeVisibleTypeAnnotations_attribute(u2 nameIndex, String name, PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, name, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_RuntimeVisibleTypeAnnotations";
    }

    @Override
    String getMessageKey_4_annotations() {
        return "msg_attr_RuntimeVisibleTypeAnnotations__annotations";
    }

    @Override
    String getMessageKey_4_num_annotations() {
        return "msg_attr_RuntimeVisibleTypeAnnotations__num_annotations";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Signature_attribute.java`:

```java
/*
 * AttributeSignature.java    10:52 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.JavaLangSpec;
import org.binaryinternals.format.classfile.constant.cp_info;
import org.binaryinternals.format.classfile.u2;

/**
 * An optional fixed-length attribute in the attributes table of a
 * {@code ClassFile}, {@code field_info}, or {@code method_info} structure.
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.9">
 * VM Spec: The Signature Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class Signature_attribute extends attribute_info {

    public final u2 signature_index;

    /**
     * <pre>
     * java:S1172 - Unused method parameters should be removed --- `cp` is used by children classes
     * </pre>
     */
    @SuppressWarnings("java:S1172")
    Signature_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream, final cp_info[] cp) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);
        this.signature_index = new u2(posDataInputStream);
        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int sigIndex = this.signature_index.value;

        this.addNode(parentNode, super.startPos + 6, 2,
                "signature_index",
                String.format(TEXT_CPINDEX_VALUE, sigIndex, "signature", ((ClassFile) classFile).getCPDescription(sigIndex)),
                "msg_attr_Signature__signature_index",
                Icons.Signature
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Signature";
    }

    /**
     * A primitive type of the Java programming language.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-BaseType">
     * VM Spec: BaseType
     * </a>
     */
    public enum BaseType {

        /**
         * signed byte.
         */
        B('B', JavaLangSpec.Keyword.BYTE.text),
        /**
         * Unicode character code point in the Basic Multilingual Plane, encoded
         * with UTF-16.
         */
        C('C', JavaLangSpec.Keyword.CHAR.text),
        /**
         * double-precision floating-point value.
         */
        D('D', JavaLangSpec.Keyword.DOUBLE.text),
        /**
         * single-precision floating-point value.
         */
        F('F', JavaLangSpec.Keyword.FLOAT.text),
        /**
         * integer.
         */
        I('I', JavaLangSpec.Keyword.INT.text),
        /**
         * long integer.
         */
        J('J', JavaLangSpec.Keyword.LONG.text),
        /**
         * signed short.
         */
        S('S', JavaLangSpec.Keyword.SHORT.text),
        /**
         * true or false.
         */
        Z('Z', JavaLangSpec.Keyword.BOOLEAN.text);

        public final char signature;
        public final String JavaKeyWord;

        private BaseType(char c, String kw) {
            this.signature = c;
            this.JavaKeyWord = kw;
        }

        /**
         * Get the key word of the JVM internal type signature char.
         *
         * @param typeSignature JVM internal type signature char
         * @return the key word or <code>error message</code> if not found
         */
        public static String extractPrimitiveType(char typeSignature) {
            String kw = "[ERROR: unknown primitive type]";
            for (BaseType v : BaseType.values()) {
                if (v.signature == typeSignature) {
                    kw = v.JavaKeyWord;
                    break;
                }
            }

            return kw;
        }

        /**
         * Check if a JVM internal type signature is primitive type or not.
         *
         * @param typeSignature JVM internal type signature char
         * @return <code>true</code> for primitive types, else
         * <code>false</code>
         */
        public static Boolean isPrimitiveType(final char typeSignature) {
            Boolean returnValue = false;
            for (BaseType v : BaseType.values()) {
                if (v.signature == typeSignature) {
                    returnValue = true;
                    break;
                }
            }

            return returnValue;
        }
    }

    /**
     * A reference type signature represents a reference type of the Java
     * programming language, that is, a class or interface type, a type
     * variable, or an array type.
     *
     * @see <a
     * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.9.1">
     * VM Spec: Reference Type Signature
     * </a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum ReferenceType {

        ClassTypeSignature('L'),
        ClassTypeSignatureSuffix(';'),
        TypeVariableSignature('T'),
        ArrayTypeSignature('[');

        public final char signature;

        private ReferenceType(char c) {
            this.signature = c;
        }

    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/SourceDebugExtension_attribute.java`:

```java
/*
 * AttributeSourceDebugExtension.java    11:00 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.constant.CONSTANT_Utf8_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code SourceDebugExtension} attribute is an optional attribute in the
 * {@code attributes} table of a {@code ClassFile} structure. There can be no
 * more than one {@code SourceDebugExtension} attribute in the
 * {@code attributes} table of a given {@code ClassFile} structure.
 *
 * The {@code SourceDebugExtension} attribute has the following format:
 * <pre>
 * SourceDebugExtension_attribute {
 *   u2 attribute_name_index;
 *   u4 attribute_length;
 *
 *   u1 debug_extension[attribute_length];
 * }
 * </pre>
 *
 * Note. TODO - This Attribute is not tested - since no test case found
 *
 * @author Amos Shi
 * @since Java 5
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.11">
 * VM Spec: The Signature Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class SourceDebugExtension_attribute extends attribute_info {

    /**
     * The {@link #debug_extension} array holds extended debugging information
     * which has no semantic effect on the Java Virtual Machine.
     *
     * The information is represented using a modified UTF-8 string
     * ({@link CONSTANT_Utf8_info}) with no terminating zero byte.
     */
    public final byte[] debug_extension;

    SourceDebugExtension_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws java.io.IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (super.attribute_length.value > 0) {
            this.debug_extension = new byte[super.attribute_length.value];
            final int bytesRead = posDataInputStream.read(this.debug_extension);
            if (bytesRead != super.attribute_length.value) {
                throw new FileFormatException("Read bytes for SourceDebugExtension error.");
            }
        } else {
            this.debug_extension = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the {@link #debug_extension} as String.
     *
     * @return The string of {@link #debug_extension}
     */
    public String getDebugExtesionString() {
        return new String(this.debug_extension, StandardCharsets.UTF_8);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        if (this.debug_extension != null && this.debug_extension.length > 0) {
            this.addNode(parentNode,
                    super.startPos + 6, this.debug_extension.length,
                    "debug_extension", this.getDebugExtesionString(),
                    "msg_attr_SourceDebugExtension__debug_extension", Icons.Data
            );
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_SourceDebugExtension";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/SourceFile_attribute.java`:

```java
/*
 * AttributeSourceFile.java    5:26 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code SourceFile} attribute. The {@code SourceFile}
 * attribute has the following format:
 *
 * <pre>
 *    SourceFile_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u2 sourcefile_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.10">
 * VM Spec: The SourceFile Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class SourceFile_attribute extends attribute_info {

    public final u2 sourcefile_index;

    SourceFile_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != 2) {
            throw new FileFormatException(String.format("The attribute_length of AttributeSourceFile is not 2, it is %d.", this.attribute_length.value));
        }

        this.sourcefile_index = new u2(posDataInputStream);

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int cpIndex = this.sourcefile_index.value;
        this.addNode(parentNode,
                super.startPos + 6, u2.LENGTH,
                "sourcefile_index", String.format(TEXT_CPINDEX_VALUE, cpIndex, "source file", ((ClassFile)classFile).getCPDescription(cpIndex)),
                "msg_attr_SourceFile__sourcefile_index", Icons.Name
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_SourceFile";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/StackMapTable_attribute.java`:

```java
/*
 * AttributeStackMapTable.java    10:47 AM, April 28, 2014
 *
 * Copyright  2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 * A variable-length attribute in the {@code attributes} table of a {@code Code}
 * attribute.
 *
 * @author Amos Shi
 * @since Java 6
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.4">
 * VM Spec: The StackMapTable Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class StackMapTable_attribute extends attribute_info {

    private static final String FIELD_OFFSET_DELTA = "offset_delta";
    private static final String MSGKEY_OFFSET_DELTA= "msg_attr_stack_map_frame__all__offset_delta";
    private static final String MSGKEY_VTI = "msg_attr_verification_type_info";

    /**
     * Gives the number of {@link stack_map_frame} entries in the
     * {@link #entries} table.
     */
    public final u2 number_of_entries;
    /**
     * Each entry in the {@link #entries} table describes one stack map frame of
     * the method. The order of the stack map frames in the entries table is
     * significant.
     */
    public final stack_map_frame[] entries;

    StackMapTable_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws java.io.IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        this.number_of_entries = new u2(posDataInputStream);
        if (this.number_of_entries.value > 0) {
            this.entries = new stack_map_frame[this.number_of_entries.value];
            for (int i = 0; i < this.number_of_entries.value; i++) {
                this.entries[i] = new stack_map_frame(posDataInputStream);
            }
        } else {
            this.entries = null;
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                super.startPos + 6,
                2,
                "number_of_entries",
                this.number_of_entries.value,
                "msg_attr_StackMapTable__number_of_entries",
                Icons.Counter
        );

        if (this.number_of_entries.value > 0) {
            DefaultMutableTreeNode entriesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.startPos + 8,
                    this.getLength() - 8,
                    String.format("entries [%d]", this.number_of_entries.value),
                    MESSAGES.getString("msg_attr_StackMapTable__entries")
            ));
            parentNode.add(entriesNode);

            for (int i = 0; i < this.number_of_entries.value; i++) {
                DefaultMutableTreeNode entry = this.addNode(entriesNode,
                        this.entries[i].getStartPos(),
                        this.entries[i].getLength(),
                        String.format("entry %d", i + 1),
                        this.entries[i].getFrameTypeName(),
                        this.entries[i].getFrameMessageKey(),
                        Icons.Stack
                );
                this.entries[i].generateTreeNode(entry, classFile);
            }
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_StackMapTable";
    }

    public enum FrameTypeEnum {

        SAME(0, 63, "same_frame", "msg_attr_stack__same_frame", null),
        SAME_LOCALS_1_STACK_ITEM(64, 127, "same_locals_1_stack_item_frame", "msg_attr_stack__same_locals_1_stack_item_frame", stack_map_frame.same_locals_1_stack_item_frame.class),
        /**
         * Tags in the range [128-246] are reserved for future use.
         */
        RESERVED(128, 246, "RESERVED", "msg_attr_stack__reserved", null),
        SAME_LOCALS_1_STACK_ITEM_EXTENDED(247, 247, "same_locals_1_stack_item_frame_extended", "msg_attr_stack__same_locals_1_stack_item_frame_extended", stack_map_frame.same_locals_1_stack_item_frame_extended.class),
        CHOP(248, 250, "chop_frame", "msg_attr_stack__chop_frame", stack_map_frame.chop_frame.class),
        SAME_FRAME_EXTENDED(251, 251, "same_frame_extended", "msg_attr_stack__same_frame_extended", stack_map_frame.same_frame_extended.class),
        APPEND(252, 254, "append_frame", "msg_attr_stack__append_frame", stack_map_frame.append_frame.class),
        FULL_FRAME(255, 255, "full_frame", "msg_attr_stack__full_frame", stack_map_frame.full_frame.class);

        public final short low;
        public final short high;
        public final String unionName;
        public final String messageKey;

        /**
         * The Java class representing to the frame.
         */
        final Class<?> clazz;

        FrameTypeEnum(int l, int h, String name, String msgKey, Class<?> type) {
            this.low = (short) l;
            this.high = (short) h;
            this.unionName = name;
            this.messageKey = msgKey;
            this.clazz = type;
        }

        /**
         * Check if the <code>value</code> is in the value range or not.
         *
         * @param value The test value
         * @return   <code>true</code> if it is in range, else <code>false</code>
         */
        public boolean inRange(short value) {
            return value >= this.low && value <= this.high;
        }

        /**
         * Get the corresponding enum item for <code>value</code>.
         *
         * @param value The {@link stack_map_frame#frame_type} value
         * @return The corresponding {@link FrameTypeEnum} of <code>value</code>
         */
        public static FrameTypeEnum valueOf(short value) {
            for (FrameTypeEnum item : FrameTypeEnum.values()) {
                if (item.inRange(value)) {
                    return item;
                }
            }

            throw new IllegalArgumentException("Unregnized enum value " + value + " for " + FrameTypeEnum.class.getName());
        }
    }

    public abstract static class stack_frame extends FileComponent implements GenerateTreeNodeClassFile {
        /**
         * Get the calculated <code>offset_delta</code>.
         */
        public abstract int getOffsetDelta();
    }

    /**
     * A stack map frame is represented by a discriminated union,
     * <code>stack_map_frame</code>, which consists of a one-byte tag,
     * indicating which item of the union is in use, followed by zero or more
     * bytes, giving more information about the tag.
     *
     * <pre>
     * union stack_map_frame {
     *     same_frame;
     *     same_locals_1_stack_item_frame;
     *     same_locals_1_stack_item_frame_extended;
     *     chop_frame;
     *     same_frame_extended;
     *     append_frame;
     *     full_frame;
     * }
     * </pre>
     */
    public static final class stack_map_frame extends FileComponent implements GenerateTreeNodeClassFile {
        public final u1 frame_type;

        /**
         * One of: - {@link same_locals_1_stack_item_frame}
         * - {@link same_locals_1_stack_item_frame_extended}
         * - {@link chop_frame}
         * - {@link same_frame_extended}
         * - {@link append_frame}
         * - {@link full_frame}
         */
        public final stack_frame union_stack_frame;

        /**
         * <pre>
         * java:S1871 - Two branches in a conditional structure should not have exactly the same implementation --- We need it to make code more readable
         * </pre>
         */
        @SuppressWarnings("java:S1871")
        private stack_map_frame(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
            super.startPos = posDataInputStream.getPos();

            this.frame_type = new u1(posDataInputStream, true);

            Class<?> clazz = FrameTypeEnum.valueOf(this.frame_type.value).clazz;
            if (clazz != null) {
                try {
                    // There is only 1 constructor for sure
                    Constructor<?> cons = clazz.getDeclaredConstructors()[0];
                    switch (cons.getParameterCount()) {
                        case 1:
                            this.union_stack_frame = (stack_frame) (clazz.getDeclaredConstructors()[0].newInstance(posDataInputStream));
                            break;
                        case 2:
                            this.union_stack_frame = (stack_frame) (clazz.getDeclaredConstructors()[0].newInstance(posDataInputStream, this.frame_type.value));
                            break;
                        default:
                            throw new UnsupportedOperationException(String.format("Coding Problem: unrecognized contructor paramter count found = %s / %d", clazz.getName(), cons.getParameterCount()));
                    }
                } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
                    // Print stack trace is needed to extract InvocationTargetException
                    //  - https://stackoverflow.com/questions/6020719/
                    ex.printStackTrace();

                    throw new FileFormatException(String.format("Failed to parse the JVM stack_map_frame at position 0x%08X", posDataInputStream.getPos() - 1), ex);
                }
            } else {
                this.union_stack_frame = null;
            }

            super.length = posDataInputStream.getPos() - super.startPos;
        }

        @SuppressWarnings("java:S3776") // java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            this.addNode(parentNode,
                    this.getStartPos(),
                    u1.LENGTH,
                    "frame_type",
                    this.frame_type.value + " - " + this.getFrameTypeName(),
                    "msg_attr_stack_map_frame__frame_type",
                    Icons.Kind
            );

            if (this.union_stack_frame != null) {
                this.union_stack_frame.generateTreeNode(parentNode, fileFormat);
            }
        }

        /**
         * Get message key for the corresponding {@link #union_stack_frame}.
         *
         * @return {@link #union_stack_frame} message key, or <code>null</code> if {@link #union_stack_frame} is null
         */
        public String getFrameMessageKey () {
            return FrameTypeEnum.valueOf(this.frame_type.value).messageKey;
        }

        /**
         * Get the union name of {@link #frame_type}.
         *
         * @return {@link #frame_type} union name
         */
        public String getFrameTypeName() {
            return FrameTypeEnum.valueOf(this.frame_type.value).unionName;
        }

        /**
         * Get the calculated <code>offset_delta</code>.
         */
        public int getOffsetDelta() {
            FrameTypeEnum type = FrameTypeEnum.valueOf(this.frame_type.value);
            switch (type) {
                case SAME:
                    return this.frame_type.value;

                case SAME_LOCALS_1_STACK_ITEM:
                    return this.frame_type.value - 64;

                case SAME_LOCALS_1_STACK_ITEM_EXTENDED:
                case CHOP:
                case SAME_FRAME_EXTENDED:
                case APPEND:
                case FULL_FRAME:
                    return this.union_stack_frame.getOffsetDelta();

                default:
                    throw new UnsupportedOperationException("Unsupported offset_value for frame type: " + type.name());
            }
        }

        /**
         * The frame type <code>same_locals_1_stack_item_frame</code> is
         * represented by tags in the range <code>[64, 127]</code>. This frame
         * type indicates that the frame has exactly the same local variables as
         * the previous frame and that the operand stack has one entry.
         *
         * <pre>
         * same_locals_1_stack_item_frame {
         *     u1 frame_type = SAME_LOCALS_1_STACK_ITEM;   // 64-127
         *     verification_type_info stack[1];
         * }
         * </pre>
         */
        public static final class same_locals_1_stack_item_frame extends stack_frame {

            public final verification_type_info[] stack = new verification_type_info[1];

            same_locals_1_stack_item_frame(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.stack[0] = new verification_type_info(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();
                DefaultMutableTreeNode stacksNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.stack[0].getLength(),
                        "stack[1]"
                ));
                parentNode.add(stacksNode);

                DefaultMutableTreeNode stackNode = this.addNode(stacksNode,
                        this.stack[0].getStartPos(),
                        this.stack[0].getLength(),
                        "stack 1",
                        this.stack[0].getTagName(),
                        MSGKEY_VTI,
                        Icons.Verification
                );
                this.stack[0].generateTreeNode(stackNode, fileFormat);
            }

            @Override
            public int getOffsetDelta() {
                throw new UnsupportedOperationException("Not supported for " + this.getClass().getName());
            }
        }

        /**
         * The frame type <code>same_locals_1_stack_item_frame_extended</code>
         * is represented by the tag <code>247</code>. This frame type indicates
         * that the frame has exactly the same local variables as the previous
         * frame and that the operand stack has one entry.
         *
         * <pre>
         * same_locals_1_stack_item_frame_extended {
         *     u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED;   // 247
         *     u2 offset_delta;
         *     verification_type_info stack[1];
         * }
         * </pre>
         */
        public static final class same_locals_1_stack_item_frame_extended extends stack_frame {

            public final u2 offset_delta;
            public final verification_type_info[] stack = new verification_type_info[1];

            same_locals_1_stack_item_frame_extended(final PosDataInputStream posDataInputStream)
                    throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset_delta = new u2(posDataInputStream);
                this.stack[0] = new verification_type_info(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        FIELD_OFFSET_DELTA, this.offset_delta.value,
                        MSGKEY_OFFSET_DELTA, Icons.Offset
                );
                startPosMoving += u2.LENGTH;

                DefaultMutableTreeNode stacksNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        startPosMoving,
                        this.stack[0].getLength(),
                        "stack[1]"
                ));
                parentNode.add(stacksNode);

                DefaultMutableTreeNode stackNode = this.addNode(stacksNode,
                        this.stack[0].getStartPos(),
                        this.stack[0].getLength(),
                        "stack 1",
                        this.stack[0].getTagName(),
                        MSGKEY_VTI,
                        Icons.Verification
                );
                this.stack[0].generateTreeNode(stackNode, fileFormat);
            }

            @Override
            public int getOffsetDelta() {
                return this.offset_delta.value;
            }
        }

        /**
         * The frame type <code>chop_frame</code> is represented by tags in the
         * range <code>[248-250]</code>. This frame type indicates that the
         * frame has the same local variables as the previous frame except that
         * the last k local variables are absent, and that the operand stack is
         * empty.
         *
         * <pre>
         * chop_frame {
         *     u1 frame_type = CHOP;   // 248-250
         *     u2 offset_delta;
         * }
         * </pre>
         */
        public static final class chop_frame extends stack_frame {

            public final u2 offset_delta;

            chop_frame(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset_delta = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                this.addNode(parentNode,
                        this.getStartPos(), u2.LENGTH,
                        FIELD_OFFSET_DELTA, this.offset_delta.value,
                        MSGKEY_OFFSET_DELTA, Icons.Offset
                );
            }

            @Override
            public int getOffsetDelta() {
                return this.offset_delta.value;
            }
        }

        /**
         * The frame type <code>same_frame_extended</code> is represented by the
         * tag <code>251</code>. This frame type indicates that the frame has
         * exactly the same local variables as the previous frame and that the
         * operand stack is empty.
         *
         * <pre>
         * same_frame_extended {
         *     u1 frame_type = SAME_FRAME_EXTENDED;   // 251
         *     u2 offset_delta;
         * }
         * </pre>
         */
        public static final class same_frame_extended extends stack_frame {

            public final u2 offset_delta;

            same_frame_extended(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset_delta = new u2(posDataInputStream);
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                this.addNode(parentNode,
                        this.getStartPos(), u2.LENGTH,
                        FIELD_OFFSET_DELTA, this.offset_delta.value,
                        MSGKEY_OFFSET_DELTA, Icons.Offset
                );
            }

            @Override
            public int getOffsetDelta() {
                return this.offset_delta.value;
            }
        }

        /**
         * The frame type <code>append_frame</code> is represented by tags in
         * the range <code>[252-254]</code>. This frame type indicates that the
         * frame has the same locals as the previous frame except that k
         * additional locals are defined, and that the operand stack is empty.
         *
         * <pre>
         * append_frame {
         *     u1 frame_type = APPEND;   // 252-254
         *     u2 offset_delta;
         *     verification_type_info locals[frame_type - 251];
         * }
         * </pre>
         */
        public static final class append_frame extends stack_frame {

            public final u2 offset_delta;
            public final verification_type_info[] locals;

            append_frame(final PosDataInputStream posDataInputStream, short frameType) throws IOException {
                super.startPos = posDataInputStream.getPos();
                this.offset_delta = new u2(posDataInputStream);
                int size = frameType - 251;
                this.locals = new verification_type_info[size];
                for (int i = 0; i < size; i++) {
                    this.locals[i] = new verification_type_info(posDataInputStream);
                }
                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        FIELD_OFFSET_DELTA, this.offset_delta.value,
                        MSGKEY_OFFSET_DELTA, Icons.Offset
                );
                startPosMoving += u2.LENGTH;

                int sizeLocals = 0;
                if (this.locals.length > 0) {
                    for (verification_type_info local : this.locals) {
                        sizeLocals += local.getLength();
                    }
                    DefaultMutableTreeNode localsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            startPosMoving,
                            sizeLocals,
                            String.format("locals [%d]", this.locals.length),
                            MESSAGES.getString("msg_attr_stack__append_frame__locals")
                    ));
                    parentNode.add(localsNode);

                    for (int i = 0; i < this.locals.length; i++) {
                        DefaultMutableTreeNode localNode = this.addNode(localsNode,
                                this.locals[i].getStartPos(),
                                this.locals[i].getLength(),
                                "local " + (i + 1),
                                this.locals[i].getTagName(),
                                MSGKEY_VTI,
                                Icons.Verification
                        );
                        this.locals[i].generateTreeNode(localNode, fileFormat);
                    }
                }
            }

            @Override
            public int getOffsetDelta() {
                return this.offset_delta.value;
            }
        }

        /**
         * The frame type <code>full_frame</code> is represented by the tag
         * <code>255</code>.
         *
         * <pre>
         * full_frame {
         *     u1 frame_type = FULL_FRAME;    // 255
         *     u2 offset_delta;
         *     u2 number_of_locals;
         *     verification_type_info locals[number_of_locals];
         *     u2 number_of_stack_items;
         *     verification_type_info stack[number_of_stack_items];
         * }
         * </pre>
         */
        public static final class full_frame extends stack_frame {

            public final u2 offset_delta;
            public final u2 number_of_locals;
            public final verification_type_info[] locals;
            public final u2 number_of_stack_items;
            public final verification_type_info[] stack;

            full_frame(final PosDataInputStream posDataInputStream) throws IOException {
                super.startPos = posDataInputStream.getPos();

                this.offset_delta = new u2(posDataInputStream);
                this.number_of_locals = new u2(posDataInputStream);
                if (this.number_of_locals.value > 0) {
                    this.locals = new verification_type_info[this.number_of_locals.value];
                    for (int i = 0; i < this.number_of_locals.value; i++) {
                        this.locals[i] = new verification_type_info(posDataInputStream);
                    }
                } else {
                    this.locals = null;
                }

                this.number_of_stack_items = new u2(posDataInputStream);
                if (this.number_of_stack_items.value > 0) {
                    this.stack = new verification_type_info[this.number_of_stack_items.value];
                    for (int i = 0; i < this.number_of_stack_items.value; i++) {
                        this.stack[i] = new verification_type_info(posDataInputStream);
                    }
                } else {
                    this.stack = null;
                }

                super.length = posDataInputStream.getPos() - super.startPos;
            }

            @Override
            public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
                int startPosMoving = this.getStartPos();

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        FIELD_OFFSET_DELTA, this.offset_delta.value,
                        MSGKEY_OFFSET_DELTA, Icons.Offset
                );
                startPosMoving += u2.LENGTH;

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        "number_of_locals", this.number_of_locals.value,
                        "msg_attr_stack__full_frame__number_of_locals", Icons.Counter
                );
                startPosMoving += u2.LENGTH;

                int sizeLocals = 0;
                if (this.number_of_locals.value > 0) {
                    for (int i = 0; i < this.number_of_locals.value; i++) {
                        sizeLocals += this.locals[i].getLength();
                    }
                    DefaultMutableTreeNode localsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            startPosMoving,
                            sizeLocals,
                            String.format("locals [%d]", this.number_of_locals.value),
                            MESSAGES.getString("msg_attr_stack__full_frame__locals")
                    ));
                    startPosMoving += sizeLocals;
                    parentNode.add(localsNode);

                    for (int i = 0; i < this.locals.length; i++) {
                        DefaultMutableTreeNode localNode = this.addNode(localsNode,
                                this.locals[i].getStartPos(),
                                this.locals[i].getLength(),
                                "local " + (i + 1),
                                this.locals[i].getTagName(),
                                MSGKEY_VTI,
                                Icons.Verification
                        );
                        this.locals[i].generateTreeNode(localNode, fileFormat);
                    }
                }

                this.addNode(parentNode,
                        startPosMoving, u2.LENGTH,
                        "number_of_stack_items", this.number_of_stack_items.value,
                        "msg_attr_stack__full_frame__number_of_stack_items", Icons.Counter
                );
                startPosMoving += u2.LENGTH;

                int sizeStack = 0;
                if (this.number_of_stack_items.value > 0) {
                    for (int i = 0; i < this.number_of_stack_items.value; i++) {
                        sizeStack += this.stack[i].getLength();
                    }

                    DefaultMutableTreeNode stacksNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            startPosMoving,
                            sizeStack,
                            String.format("stack [%d]", this.number_of_stack_items.value),
                            MESSAGES.getString("msg_attr_stack__full_frame__stack")
                    ));
                    parentNode.add(stacksNode);

                    for (int i = 0; i < this.stack.length; i++) {
                        DefaultMutableTreeNode stackNode = this.addNode(stacksNode,
                                this.stack[i].getStartPos(),
                                this.stack[i].getLength(),
                                "stack " + (i + 1),
                                this.stack[i].getTagName(),
                                MSGKEY_VTI,
                                Icons.Verification
                        );
                        this.stack[i].generateTreeNode(stackNode, fileFormat);
                    }
                }
            }

            @Override
            public int getOffsetDelta() {
                return this.offset_delta.value;
            }
        }
    }

    public static final class verification_type_info extends FileComponent implements GenerateTreeNodeClassFile {

        public final u1 tag;
        public final Object_variable_info union_Object_variable_info;
        public final Uninitialized_variable_info union_Uninitialized_variable_info;

        private verification_type_info(final PosDataInputStream posDataInputStream)
                throws IOException {
            super.startPos = posDataInputStream.getPos();

            this.tag = new u1(posDataInputStream, true);
            if (this.tag.value == TagEnum.ITEM_Object.value) {
                this.union_Object_variable_info = new Object_variable_info(posDataInputStream);
                this.union_Uninitialized_variable_info = null;
            } else if (this.tag.value == TagEnum.ITEM_Uninitialized.value) {
                this.union_Object_variable_info = null;
                this.union_Uninitialized_variable_info = new Uninitialized_variable_info(posDataInputStream);
            } else {
                this.union_Object_variable_info = null;
                this.union_Uninitialized_variable_info = null;
            }

            super.length = posDataInputStream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
            ClassFile classFile = (ClassFile) fileFormat;
            int startPosMoving = this.getStartPos();

            this.addNode(parentNode,
                    startPosMoving,
                    1,
                    "tag",
                    this.tag.value + " - " + this.getTagName(),
                    "msg_attr_verification_type_info__tag",
                    Icons.Tag
            );
            startPosMoving += 1;

            if (this.union_Object_variable_info != null) {
                this.addNode(parentNode,
                        startPosMoving,
                        2,
                        "cpool_index",
                        this.union_Object_variable_info.cpool_index.value + " - " + classFile.getCPDescription(this.union_Object_variable_info.cpool_index.value),
                        "msg_attr_verification_type_info__cpool_index",
                        Icons.Index
                );
            } else if (this.union_Uninitialized_variable_info != null) {
                this.addNode(parentNode,
                        startPosMoving,
                        2,
                        "offset",
                        this.union_Uninitialized_variable_info.offset.value,
                        "msg_attr_verification_type_info__offset",
                        Icons.Offset
                );
            }
        }

        /**
         * Get name of {@link #tag}.
         *
         * @return {@link #tag} name
         */
        public String getTagName() {
            return verification_type_info.TagEnum.getTagName(this.tag.value);
        }

        public static final class Object_variable_info {

            public final u2 cpool_index;

            Object_variable_info(final PosDataInputStream posDataInputStream) throws IOException {
                this.cpool_index = new u2(posDataInputStream);
            }
        }

        /**
         * <pre>
         * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
         * </pre>
         */
        @SuppressWarnings("java:S1104")
        public static final class Uninitialized_variable_info {

            public u2 offset;

            Uninitialized_variable_info(final PosDataInputStream posDataInputStream) throws IOException {
                this.offset = new u2(posDataInputStream);
            }
        }

        /**
         * <pre>
         * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
         * </pre>
         */
        @SuppressWarnings("java:S115")
        public enum TagEnum {

            ITEM_Top(0),
            ITEM_Integer(1),
            ITEM_Float(2),
            ITEM_Double(3),
            ITEM_Long(4),
            ITEM_Null(5),
            ITEM_UninitializedThis(6),
            ITEM_Object(7),
            ITEM_Uninitialized(8);

            public final short value;
            public static final String TAGNAME_UNRECOGNIZED = "Unrecognized";

            TagEnum(int value) {
                this.value = (short) value;
            }

            /**
             * Get get enum name of the value <code>v</code>.
             *
             * @param v Value of the tag
             * @return The corresponding enum name
             */
            public static String getTagName(short v) {
                String result = TAGNAME_UNRECOGNIZED;
                for (TagEnum e : TagEnum.values()) {
                    if (e.value == v) {
                        result = e.name();
                        break;
                    }
                }
                return result;
            }
        }
    }

}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Synthetic_attribute.java`:

```java
/*
 * AttributeSynthetic.java    5:25 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code SourceFile} attribute. The {@code SourceFile}
 * attribute has the following format:
 *
 * <pre>
 *    Synthetic_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.1
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.8">
 * VM Spec: The Synthetic Attribute
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Synthetic_attribute extends attribute_info {

    Synthetic_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != 0) {
            throw new FileFormatException(String.format("The attribute_length of AttributeSynthetic is not 0, it is %d.", this.attribute_length.value));
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        // Nothing to add
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Synthetic";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/Unrecognized_attribute.java`:

```java
/*
 * AttributeExtended.java    12:37 AM, August 11, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the Unrecognized attribute. Non-standard attribute, all of the
 * attributes which are not defined in the VM Spec will be represented by this
 * class.
 *
 * <pre>
 *    attribute_info {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u1 info[attribute_length];
 *    }
 * </pre>
 *
 * The {@code info} is the raw byte array data.
 *
 *
 * @author Amos Shi
 * @since Java 1.0.2
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Unrecognized_attribute extends attribute_info {

    private byte[] rawData;

    Unrecognized_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value > 0) {
            this.rawData = new byte[this.attribute_length.value];
            int readBytes = posDataInputStream.read(this.rawData);
            if (readBytes != this.attribute_length.value) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes red %d", this.attribute_length.value, readBytes));
            }
        }

        super.checkSize(posDataInputStream.getPos());
    }

    /**
     * Get the value of {@code info}, in raw data format.
     *
     * @return The value of {@code info}
     */
    public byte[] getRawData() {
        return this.rawData.clone();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        if (this.attribute_length.value > 0) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.getStartPos() + 6,
                    this.attribute_length.value,
                    "raw data"
            )));
        }
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_Unrecognized";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/aspectj/AjSynthetic_attribute.java`:

```java
/*
 * WeaverVersion_attribute.java    19:08, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute.aspectj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code org.aspectj.weaver.AjSynthetic} attribute.
 *
 * The attribute has the following format:
 *
 * <pre>
 *    WeaverVersion_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *    }
 * </pre>
 *
 * The following classes has this attribute:
 * <pre>
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AbstractCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AnnotationCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/JCacheCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AnnotationAsyncExecutionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AnnotationTransactionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/JtaAnnotationTransactionAspect.class
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java">AjAttribute</a>
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java#L152">AjSynthetic</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from Source Code instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class AjSynthetic_attribute extends attribute_info {

    public static final int LENGTH = 0;
    public static final String FULLNAME = "org.aspectj.weaver.AjSynthetic";

    public AjSynthetic_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of %s is not %d, it is %d.", FULLNAME, LENGTH, this.attribute_length.value));
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        // Nothing is needed
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NoneJVM";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/aspectj/MethodDeclarationLineNumber_attribute.java`:

```java
/*
 * WeaverVersion_attribute.java    19:08, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute.aspectj;

import org.binaryinternals.format.classfile.attribute.attribute_info;
import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code org.aspectj.weaver.MethodDeclarationLineNumber} attribute.
 *
 * The attribute has the following format:
 *
 * <pre>
 *    MethodDeclarationLineNumber_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        int line_number;
 *        int offset;
 *    }
 * </pre>
 *
 * The following classes has this attribute:
 * <pre>
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AbstractCacheAspect$AbstractCacheAspect$1.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AbstractCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AnnotationCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AnyThrow.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AspectJCachingConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AspectJJCacheConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/JCacheCacheAspect$JCacheCacheAspect$1.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/JCacheCacheAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/context/annotation/aspectj/SpringConfiguredConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect$AbstractAsyncExecutionAspect$1.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AnnotationAsyncExecutionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AspectJAsyncConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect$AbstractTransactionAspect$1.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect$Rethrower$1CheckedExceptionRethrower.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect$Rethrower.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AnnotationTransactionAspect.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AspectJJtaTransactionManagementConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AspectJTransactionManagementConfiguration.class
 *   spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/JtaAnnotationTransactionAspect.class
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java">AjAttribute</a>
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java#L437">MethodDeclarationLineNumberAttribute.write()</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class MethodDeclarationLineNumber_attribute extends attribute_info {

    public static final int LENGTH = 8;
    public static final String FULLNAME = "org.aspectj.weaver.MethodDeclarationLineNumber";

    public final int line_number;
    public final int offset;

    public MethodDeclarationLineNumber_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of %s is not %d, it is %d.", FULLNAME, LENGTH, this.attribute_length.value));
        }
        this.line_number = posDataInputStream.readInt();
        this.offset = posDataInputStream.readInt();

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int floatPos = super.startPos + 6;
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_INT,
                "line_number: " + this.line_number,
                Icons.Row
        )));
        floatPos += PosDataInputStream.LENGTH_INT;

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_INT,
                "offset: " + this.offset,
                Icons.Offset
        )));
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NoneJVM";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/aspectj/WeaverVersion_attribute.java`:

```java
/*
 * WeaverVersion_attribute.java    19:08, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute.aspectj;

import java.io.IOException;
import java.time.Instant;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code org.aspectj.weaver.WeaverVersion} attribute.
 *
 * The attribute has the following format:
 *
 * <pre>
 *    WeaverVersion_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        short major_version;
 *        short minor_version;
 *        long version_time;
 *    }
 * </pre>
 *
 * The following classes has this attribute:
 * <pre>
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AbstractCacheAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/JCacheCacheAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect.class
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java">AjAttribute</a>
 * @see
 * <a href="https://github.com/eclipse/org.aspectj/blob/V1_9_7/org.aspectj.matcher/src/main/java/org/aspectj/weaver/AjAttribute.java#L293">WeaverVersionInfo.write()</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class WeaverVersion_attribute extends attribute_info {

    public static final int LENGTH = 12;
    public static final String FULLNAME = "org.aspectj.weaver.WeaverVersion";

    public final short major_version;
    public final short minor_version;
    public final long version_time;

    public WeaverVersion_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of %s is not %d, it is %d.", FULLNAME, LENGTH, this.attribute_length.value));
        }
        this.major_version = posDataInputStream.readShort();
        this.minor_version = posDataInputStream.readShort();
        this.version_time = posDataInputStream.readLong();

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int floatPos = super.startPos + 6;
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_SHORT,
                "major_version: " + this.major_version
        )));
        floatPos += PosDataInputStream.LENGTH_SHORT;

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_SHORT,
                "minor_version: " + this.minor_version
        )));
        floatPos += PosDataInputStream.LENGTH_SHORT;

        String verionTimeStr = (this.version_time != -1) ? Instant.ofEpochMilli(this.version_time).toString() : "";
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_LONG,
                String.format("minor_version: %d %s", this.version_time, verionTimeStr)
        )));
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NoneJVM";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/attribute_info.java`:

```java
/*
 * attribute_info.java    4:02 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.JavaSEVersion;
import org.binaryinternals.format.classfile.attribute.aspectj.AjSynthetic_attribute;
import org.binaryinternals.format.classfile.attribute.aspectj.MethodDeclarationLineNumber_attribute;
import org.binaryinternals.format.classfile.attribute.aspectj.WeaverVersion_attribute;
import org.binaryinternals.format.classfile.attribute.scala.ScalaSig_attribute;
import org.binaryinternals.format.classfile.attribute.scala.Scala_attribute;
import org.binaryinternals.format.classfile.constant.CONSTANT_Utf8_info;
import org.binaryinternals.format.classfile.constant.cp_info;
import org.binaryinternals.format.classfile.field_info;
import org.binaryinternals.format.classfile.method_info;
import org.binaryinternals.format.classfile.u2;
import org.binaryinternals.format.classfile.u4;

/**
 * Super class for attributes in class file. All attributes have the following
 * format:
 *
 * <pre>
 *    attribute_info {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        u1 info[attribute_length];
 *    }
 * </pre>
 *
 * The contents in {@code info} is determined by {@code attribute_name_index}.
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7">
 * VM Spec: Attributes
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public abstract class attribute_info extends FileComponent implements GenerateTreeNodeClassFile {

    private static final Logger LOG = Logger.getLogger(attribute_info.class.getName());

    /**
     * Non-standard attributes. All of the attributes which are not defined in
     * the VM Spec.
     */
    public static final String UNRECOGNIZED = "[Un-Recognized] ";

    /**
     * Name of the attribute. It is one of the enum names in
     * {@link AttributeTypes}.
     */
    public final String name;

    /**
     * The {@link #attribute_name_index} must be a valid unsigned 16-bit index
     * into the
     * {@link org.binaryinternals.format.classfile.ClassFile#constant_pool} of the
     * {@link ClassFile}, the {@link ClassFile#constant_pool} entry at
     * {@link #attribute_name_index} must be a
     * <code>CONSTANT_Utf8_info structure</code>
     * ({@link org.binaryinternals.format.classfile.constant.CONSTANT_Utf8_info})
     * representing the name of the attribute.
     */
    public final u2 attribute_name_index;

    /**
     * The value of the {@link #attribute_length} item indicates the length of
     * the subsequent information in bytes. The length does not include the
     * initial six bytes that contain the {@link #attribute_name_index} and
     * {@link #attribute_length} items.
     */
    public final u4 attribute_length;

    @SuppressWarnings("java:S5993")
    public attribute_info(final u2 nameIndex, final String name, final PosDataInputStream posDataInputStream) throws IOException {
        super.startPos = posDataInputStream.getPos() - 2;

        if (name == null || name.length() < 1) {
            throw new IllegalArgumentException("The attribute name annot be none. location=0x" + Integer.toHexString(posDataInputStream.getPos()));
        }
        this.name = name;
        this.attribute_name_index = nameIndex;
        this.attribute_length = new u4(posDataInputStream);

        super.length = this.attribute_length.value + u2.LENGTH + u4.LENGTH;
    }

    /**
     * Parse one JVM attribute.This method is not 'public' since it is supposed
     * to be called inside this library only.
     *
     * @param posDataInputStream Input Stream for the class file
     * @param cp Constant Pool item
     * @return Parsed result
     * @throws IOException Input Stream read fail
     * @throws FileFormatException Class file format error
     *
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
     * </pre>
     */
    @SuppressWarnings("java:S3776")
    public static attribute_info parse(final PosDataInputStream posDataInputStream, final cp_info[] cp) throws IOException, FileFormatException {
        attribute_info attr = null;

        final u2 attrNameIndex = new u2(posDataInputStream);
        if (cp_info.ConstantType.CONSTANT_Utf8.tag == cp[attrNameIndex.value].tag.value) {
            final String type = ((CONSTANT_Utf8_info) cp[attrNameIndex.value]).getValue();

            boolean matched = false;
            for (AttributeTypes attrType : AttributeTypes.values()) {
                if (attrType.getName().equals(type) && attrType.clazz != null) {
                    // There is only 1 constructor in the JVM Attributes
                    Constructor<?> cons = attrType.clazz.getDeclaredConstructors()[0];

                    try {
                        switch (cons.getParameterCount()) {
                            case 3:
                                matched = true;
                                attr = (attribute_info) cons.newInstance(attrNameIndex, type, posDataInputStream);
                                break;
                            case 4:
                                matched = true;
                                attr = (attribute_info) cons.newInstance(attrNameIndex, type, posDataInputStream, cp);
                                break;
                            default:
                                LOG.log(Level.SEVERE, "Coding Problem: unrecognized contructor paramter count found = {0} / {1}", new Object[]{attrType.clazz.getName(), cons.getParameterCount()});
                                break;
                        }
                    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
                        LOG.log(Level.SEVERE, "Failed to parse the JVM Attribute {0}, {1}", new Object[]{attrType.clazz.getName(), ex.toString()});
                    }
                }
            }
            if (!matched) {
                LOG.log(Level.WARNING, "Un-recognized Attribute Found !!! Type = {0}", type);
                attr = new Unrecognized_attribute(attrNameIndex, UNRECOGNIZED + type, posDataInputStream);
            }
        } else {
            throw new FileFormatException(String.format("Attribute name_index is not CONSTANT_Utf8. Constant index = %d, type = %d, position = 0x%X", attrNameIndex.value, cp[attrNameIndex.value].tag.value, posDataInputStream.getPos()));
        }

        return attr;
    }

    /**
     * Verify the current class file input stream position is correct.
     *
     * @param endPos Current position
     * @throws FileFormatException Invalid class file format
     */
    protected void checkSize(final int endPos) throws FileFormatException {
        if (this.startPos + this.length != endPos) {
            throw new FileFormatException(String.format("Attribute analysis failed. type='%s', startPos=%d, length=%d, endPos=%d", this.getName(), this.startPos, this.length, endPos));
        }
    }

    /**
     * The get the Message key which contains the corresponding description of current attribute.
     *
     * @return Message key
     */
    public abstract String getMessageKey();

    /**
     * Get the {@link #name} of the attribute, if {@link #name} is
     * <code>null</code>, it will return an empty string.
     *
     * Attributes are used in the {@link ClassFile}, {@link field_info},
     * {@link method_info}, and {@link Code_attribute} structures of the class
     * file format.
     *
     * @return A string of the attribute name
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7">
     * VM Spec: Attributes
     * </a>
     */
    public String getName() {
        return this.name;
    }

    public void generateTreeNodeCommon(final DefaultMutableTreeNode parentNode, final ClassFile classFile) {
        int startPosMoving = this.getStartPos();
        this.addNode(parentNode,
                startPosMoving,
                u2.LENGTH,
                "attribute_name_index",
                String.format(TEXT_CPINDEX_VALUE, this.attribute_name_index.value, "name", this.getName()),
                "msg_attribute_info__attribute_name_index",
                Icons.Name
        );

        startPosMoving += u2.LENGTH;
        this.addNode(parentNode,
                startPosMoving,
                u4.LENGTH,
                "attribute_length",
                this.attribute_length.value,
                "msg_attribute_info__attribute_length",
                Icons.Length
        );

        this.generateTreeNode(parentNode, classFile);
    }

    /**
     * Attributes in Java <code>classfile</code>.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7">
     * VM Spec: Attributes </a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum AttributeTypes {

        /**
         * The name for {@code ConstantValue} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.2">
         * VM Spec: The ConstantValue Attribute
         * </a>
         */
        ConstantValue(ConstantValue_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code Code} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.3">
         * VM Spec: The Code Attribute
         * </a>
         */
        Code(Code_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code StackMapTable} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.4">
         * VM Spec: The StackMapTable Attribute
         * </a>
         */
        StackMapTable(StackMapTable_attribute.class, ClassFile.FormatVersion.FORMAT_50, JavaSEVersion.VERSION_6),
        /**
         * The name for {@code Exceptions} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.5">
         * VM Spec: The Exceptions Attribute
         * </a>
         */
        Exceptions(Exceptions_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code InnerClasses} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.6">
         * VM Spec: The InnerClasses Attribute
         * </a>
         */
        InnerClasses(InnerClasses_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_1),
        /**
         * The name for {@code EnclosingMethod} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.7">
         * VM Spec: The EnclosingMethod Attribute
         * </a>
         */
        EnclosingMethod(EnclosingMethod_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code Synthetic} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.8">
         * VM Spec: The Synthetic Attribute
         * </a>
         */
        Synthetic(Synthetic_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_1),
        /**
         * The name for {@code Signature} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.9">
         * VM Spec: The Signature Attribute
         * </a>
         */
        Signature(Signature_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code SourceFile} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.10">
         * VM Spec: The SourceFile Attribute
         * </a>
         */
        SourceFile(SourceFile_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code SourceDebugExtension} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.11">
         * VM Spec: The SourceDebugExtension Attribute
         * </a>
         */
        SourceDebugExtension(SourceDebugExtension_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code LineNumberTable} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.12">
         * VM Spec: The LineNumberTable Attribute
         * </a>
         */
        LineNumberTable(LineNumberTable_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code LocalVariableTable} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.13">
         * VM Spec: The LocalVariableTable Attribute
         * </a>
         */
        LocalVariableTable(LocalVariableTable_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2),
        /**
         * The name for {@code LocalVariableTypeTable} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.14">
         * VM Spec: The LocalVariableTypeTable Attribute
         * </a>
         */
        LocalVariableTypeTable(LocalVariableTypeTable_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code Deprecated} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.15">
         * VM Spec: The Deprecated Attribute
         * </a>
         */
        Deprecated(Deprecated_attribute.class, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_1),
        /**
         * The name for {@code RuntimeVisibleAnnotations } attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.16">
         * VM Spec: The RuntimeVisibleAnnotations Attribute
         * </a>
         */
        RuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code RuntimeInvisibleAnnotations } attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.17">
         * VM Spec: The RuntimeInvisibleAnnotations Attribute
         * </a>
         */
        RuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code RuntimeVisibleParameterAnnotations } attribute
         * type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.18">
         * VM Spec: The RuntimeVisibleParameterAnnotations Attribute
         * </a>
         */
        RuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code RuntimeInvisibleParameterAnnotations} attribute
         * type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.19">
         * VM Spec: The RuntimeInvisibleParameterAnnotations Attribute
         * </a>
         */
        RuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code RuntimeVisibleTypeAnnotations} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.20">
         * VM Spec: The RuntimeVisibleTypeAnnotations Attribute
         * </a>
         */
        RuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_52, JavaSEVersion.VERSION_8),
        /**
         * The name for {@code RuntimeInvisibleTypeAnnotations} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.21">
         * VM Spec: The RuntimeInvisibleTypeAnnotations Attribute
         * </a>
         */
        RuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute.class, ClassFile.FormatVersion.FORMAT_52, JavaSEVersion.VERSION_8),
        /**
         * The name for {@code AnnotationDefault} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.22">
         * VM Spec: The AnnotationDefault Attribute
         * </a>
         */
        AnnotationDefault(AnnotationDefault_attribute.class, ClassFile.FormatVersion.FORMAT_49, JavaSEVersion.VERSION_5_0),
        /**
         * The name for {@code BootstrapMethods} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.23">
         * VM Spec: The BootstrapMethods Attribute
         * </a>
         */
        BootstrapMethods(BootstrapMethods_attribute.class, ClassFile.FormatVersion.FORMAT_51, JavaSEVersion.VERSION_7),
        /**
         * The name for {@code MethodParameters} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.24">
         * VM Spec: The MethodParameters Attribute
         * </a>
         */
        MethodParameters(MethodParameters_attribute.class, ClassFile.FormatVersion.FORMAT_52, JavaSEVersion.VERSION_8),
        /**
         * The name for {@code Module} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.25">
         * VM Spec: The Module Attribute
         * </a>
         */
        Module(Module_attribute.class, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9),
        /**
         * The name for {@code ModulePackages} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.26">
         * VM Spec: The ModuModulePackages Attribute
         * </a>
         */
        ModulePackages(ModulePackages_attribute.class, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9),
        /**
         * The name for {@code ModuleMainClass} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.27">
         * VM Spec: The ModuleMainClass Attribute
         * </a>
         */
        ModuleMainClass(ModuleMainClass_attribute.class, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9),
        /**
         * The name for {@code ModuleHashes} attribute type. This is a OpenJDK
         * specific attribute and do not exist in Oracle JDK.
         *
         * @see
         * <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2017-February/011262.html">
         * OpenJDK specific attribute specifications</a>
         */
        ModuleHashes(ModuleHashes_attribute.class, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9),
        /**
         * The name for {@code ModuleTarget} attribute type. This is a OpenJDK
         * specific attribute and do not exist in Oracle JDK.
         *
         * @see
         * <a href="https://openjdk.java.net/jeps/261"> JEP 261: Module
         * System</a>
         */
        ModuleTarget(ModuleTarget_attribute.class, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9),
        /**
         * The name for {@code NestHost} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.28">
         * VM Spec: The NestHost Attribute
         * </a>
         */
        NestHost(NestHost_attribute.class, ClassFile.FormatVersion.FORMAT_55, JavaSEVersion.VERSION_11),
        /**
         * The name for {@code NestMembers} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.29">
         * VM Spec: The NestMembers Attribute
         * </a>
         */
        NestMembers(NestMembers_attribute.class, ClassFile.FormatVersion.FORMAT_55, JavaSEVersion.VERSION_11),
        /**
         * The name for {@code Bridge} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        Bridge(Bridge_attribute.class, ClassFile.FormatVersion.FORMAT_48, JavaSEVersion.VERSION_1_4),
        /**
         * The name for {@code Record} attribute type.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.7.30">
         * VM Spec: The Record Attribute
         * </a>
         */
        Record(Record_attribute.class, ClassFile.FormatVersion.FORMAT_60, JavaSEVersion.VERSION_16),
        /**
         * The name for {@code PermittedSubclasses} attribute type.
         *
         * @see <a href="https://openjdk.java.net/jeps/360"> JEP 360</a>
         * @see <a href="https://openjdk.java.net/jeps/409"> JEP 409</a>
         */
        PermittedSubclasses(PermittedSubclasses_attribute.class, ClassFile.FormatVersion.FORMAT_61, JavaSEVersion.VERSION_17),
        /**
         * The name for {@code ModuleResolution} attribute type.
         *
         * This attribute is found in the following openJDK 17 .class files:
         * <pre>
         *   openjdk-17/jmods/jdk.incubator.foreign.jmod/classes/module-info.class
         *   openjdk-17/jmods/jdk.incubator.vector.jmod/classes/module-info.class
         * </pre>
         */
        ModuleResolution(ModuleResolution_attribute.class, ClassFile.FormatVersion.FORMAT_61, JavaSEVersion.VERSION_17),
        /**
         * The name for {@code Scala} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        Scala(Scala_attribute.class),
        /**
         * The name for {@code ScalaSig} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        ScalaSig(ScalaSig_attribute.class),
        /**
         * The name for {@code org.aspectj.weaver.WeaverVersion} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        WeaverVersion(WeaverVersion_attribute.class, WeaverVersion_attribute.FULLNAME),
        /**
         * The name for {@code org.aspectj.weaver.AjSynthetic} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        AjSynthetic(AjSynthetic_attribute.class, AjSynthetic_attribute.FULLNAME),
        /**
         * The name for {@code org.aspectj.weaver.AjSynthetic} attribute type.
         * This is a none-JVM-Spec attribute.
         */
        MethodDeclarationLineNumber(MethodDeclarationLineNumber_attribute.class, MethodDeclarationLineNumber_attribute.FULLNAME);

        /**
         * The Java class representing to the attributes.
         *
         * If {@link #clazz} is null, which means it is not implemented yet.
         */
        final Class<?> clazz;

        public final String fullname;

        /**
         * Class file format.
         */
        public final ClassFile.FormatVersion format;

        /**
         * Java SE platform version.
         */
        public final JavaSEVersion javaSE;

        AttributeTypes(Class<?> clazz, ClassFile.FormatVersion format, JavaSEVersion javaSE, String name) {
            this.clazz = clazz;
            this.format = format;
            this.javaSE = javaSE;
            this.fullname = name;
        }

        AttributeTypes(Class<?> clazz, ClassFile.FormatVersion format, JavaSEVersion javaSE) {
            this(clazz, format, javaSE, null);
        }

        AttributeTypes(Class<?> clazz, String name) {
            this(clazz, null, null, name);
        }

        AttributeTypes(Class<?> clazz) {
            this(clazz, null, null, null);
        }

        /**
         * Getter for {@link #clazz}.
         *
         * @return Value of {@link #clazz}
         */
        @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = "EI_EXPOSE_REP", justification = "We need it")
        public Class<?> getClassType() {
            return this.clazz;
        }

        /**
         * Get the attribute full name used in <code>.class</code> file.
         *
         * @return Attribute full name used in <code>.class</code> file
         */
        public String getName(){
            return (this.fullname == null) ? this.name() : this.fullname;
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/scala/ScalaSig_attribute.java`:

```java
/*
 * WeaverVersion_attribute.java    19:08, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute.scala;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code org.aspectj.weaver.ScalaSig} attribute.
 *
 * The attribute has the following format:
 *
 * <pre>
 *    ScalaSig_attribute {
 *        u2 attribute_name_index;
 *        u4 attribute_length;
 *
 *        byte major_version;
 *        byte minor_version;
 *        byte version_time;
 *    }
 * </pre>
 *
 * The following classes has this attribute:
 * <pre>
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/AbstractCacheAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/cache/aspectj/JCacheCacheAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.class
 *   spring-framework-5.2.8.RELEASE/libs/spring-aspects-5.2.8.RELEASE.jar/org/springframework/transaction/aspectj/AbstractTransactionAspect.class
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://www.scala-lang.org/old/sid/10">SID # 10 (draft) - Storage of
 * pickled Scala signatures in class file</a>
 * @see
 * <a href="https://www.scala-lang.org/old/sites/default/files/sids/dubochet/Mon,%202010-05-31,%2015:25/Storage%20of%20pickled%20Scala%20signatures%20in%20class%20files.pdf">Storage
 * of pickled Scala signatures in class files</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class ScalaSig_attribute extends attribute_info {

    public static final int LENGTH = 3;
    public static final String FULLNAME = "org.aspectj.weaver.ScalaSig";

    /**
     * The major version number.
     */
    public final int major_version;
    /**
     * The minor version number.
     */
    public final int minor_version;
    /**
     * The number of entries, which is always equal to <code>0</code> (as the
     * actual entries are defined in the <code>ScalaSignature</code>
     * annotation).
     */
    public final int number_of_entries;

    public ScalaSig_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != LENGTH) {
            throw new FileFormatException(String.format("The attribute_length of %s is not %d, it is %d.", FULLNAME, LENGTH, this.attribute_length.value));
        }
        this.major_version = posDataInputStream.readByte();
        this.minor_version = posDataInputStream.readByte();
        this.number_of_entries = posDataInputStream.readByte();

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int floatPos = super.startPos + 6;
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_BYTE,
                "major_version: " + this.major_version,
                Icons.Versions
        )));
        floatPos += PosDataInputStream.LENGTH_BYTE;

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_BYTE,
                "minor_version: " + this.minor_version,
                Icons.Versions
        )));
        floatPos += PosDataInputStream.LENGTH_BYTE;

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                PosDataInputStream.LENGTH_BYTE,
                "number_of_entries: " + this.number_of_entries,
                Icons.Counter
        )));
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NoneJVM";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/attribute/scala/Scala_attribute.java`:

```java
/*
 * Scala_attribute.java    19:06, August 14, 2021
 *
 * Copyright  2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.attribute.scala;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code Scala} attribute.
 * 
 * We found this attribute in Scala generated .class files, like:
 * <pre>
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/AssemblyBuilderFactory$.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILGenerator$$anonfun$Emit$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILGenerator$.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILGenerator$ExceptionStack.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anon$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$addPrimitive$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$caseILGenerator$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$caseOpCode$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$caseTypeBuilder$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$hasControlChars$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$pad$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printAssemblyBoilerplate$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printAttributes$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printHeader$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printSignature$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printSignature$2.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printTypeParams$1$$anonfun$apply$mcVI$sp$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$$anonfun$printTypeParams$1.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/ILPrinterVisitor$.class
 *   scala-2.9.3/lib/scala-compiler.jar/ch/epfl/lamp/compiler/msil/emit/Label$.class
 * </pre>
 * 
 * Per current findings, this attribute's length is always <code>0</code>.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Scala_attribute extends attribute_info {

    public Scala_attribute(final u2 nameIndex, final String type, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(nameIndex, type, posDataInputStream);

        if (this.attribute_length.value != 0) {
            throw new FileFormatException(String.format("The attribute_length of Scala is not 0, it is %d.", this.attribute_length.value));
        }

        super.checkSize(posDataInputStream.getPos());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        // Nothing to add
    }

    @Override
    public String getMessageKey() {
        return "msg_attr_NoneJVM";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Class_info.java`:

```java
/*
 * ConstantClassInfo.java    4:26 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.SignatureConvertor;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_Class_info} structure in constant pool. The
 * {@code CONSTANT_Class_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Class_info {
 *        u1 tag;
 *        u2 name_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.1">
 * VM Spec: The CONSTANT_Class_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_Class_info extends cp_info {

    public static final int LENGTH = 3;
    public final u2 name_index;

    CONSTANT_Class_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Class.tag);

        this.startPos = posDataInputStream.getPos() - 1;
        this.length = LENGTH;
        this.name_index = new u2(posDataInputStream);
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Class.name();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: name_index = [%d].",
                this.getName(), this.startPos, this.length, this.name_index.value);
    }

    @Override
    public String toString(cp_info[] constantPool) {
        // The value of the name_index item must be a valid index into the constant_pool table.
        // The constant_pool entry at that index must be a CONSTANT_Utf8_info structure
        // representing a valid fully qualified class or interface name encoded in internal form.
        return SignatureConvertor.parseClassSignature(((CONSTANT_Utf8_info) constantPool[this.name_index.value]).getValue());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int cpIndex = this.name_index.value;
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "class name", ((ClassFile) classFile).getCPDescription(cpIndex)),
                "msg_const_class_name_index",
                Icons.Name);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_class";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Double_info.java`:

```java
/*
 * ConstantDoubleInfo.java    4:44 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;

/**
 * The class for the {@code CONSTANT_Double_info} structure in constant pool.
 * The {@code CONSTANT_Double_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Double_info {
 *        u1 tag;
 *
 *        u4 high_bytes;
 *        u4 low_bytes;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.5">
 * VM Spec: The CONSTANT_Double_info Structure</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Double_info extends cp_info {

    public static final int RAW_DATA_SIZE = 8;
    public static final int LENGTH = 9;

    /**
     * In JVM Spec we have two fields: u4 high_bytes and u4 low_bytes.
     */
    public final byte[] rawData;
    public final double doubleValue;

    CONSTANT_Double_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Double.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.rawData = posDataInputStream.getBuf(posDataInputStream.getPos(), RAW_DATA_SIZE);
        this.doubleValue = posDataInputStream.readDouble();
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Double.name();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: [%f].",
                this.getName(), this.startPos, this.length, this.doubleValue);
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.valueOf(this.doubleValue);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        String value = "value = " + this.doubleValue + " Hex Value = " + BytesTool.getByteDataHexView(this.rawData);
        this.addNode(parentNode,
                super.startPos + 1,
                4,
                "high_bytes",
                value,
                "msg_const_double_bytes",
                Icons.Data
        );
        this.addNode(parentNode,
                super.startPos + 5,
                4,
                "low_bytes",
                value,
                "msg_const_double_bytes",
                Icons.Data
        );
    }

    @Override
    public String getMessageKey() {
        return "msg_const_longdouble";
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Dynamic.java`:

```java
/*
 * CONSTANT_Dynamic.java    Sep 25, 2021
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * Parent of The {@code CONSTANT_Dynamic_info} and
 * {@code CONSTANT_InvokeDynamic_info} structures.
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.10">
 * VM Spec: he CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public abstract class CONSTANT_Dynamic extends cp_info {

    public static final int LENGTH = 5;

    /**
     * The value of the {@link #name_and_type_index} item must be a valid index
     * into the bootstrap_methods array of the bootstrap method table of this
     * class file.
     */
    public final u2 bootstrap_method_attr_index;

    /**
     * The value of the {@link #name_and_type_index} item must be a valid index
     * into the {@link ClassFile#constant_pool} table. The {@code constant_pool}
     * entry at that index must be a {@code CONSTANT_NameAndType_info} structure
     * representing a method name and method descriptor.
     *
     * In a {@code CONSTANT_Dynamic_info} structure, the indicated descriptor
     * must be a field descriptor.
     */
    public final u2 name_and_type_index;

    CONSTANT_Dynamic(final short tag, final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(tag);

        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.bootstrap_method_attr_index = new u2(posDataInputStream);
        this.name_and_type_index = new u2(posDataInputStream);
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], bootstrap_method_attr_index: [%d], name_and_type_index: [%d]. ",
                this.getName(),
                this.startPos,
                super.length,
                this.bootstrap_method_attr_index.value,
                this.name_and_type_index.value);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_dynamic";
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.format("bootstrap_method_attr_index=%d name_and_type_index=%s",
                this.bootstrap_method_attr_index.value,
                constantPool[this.name_and_type_index.value].toString(constantPool));
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                startPos + 1,
                2,
                "bootstrap_method_attr_index",
                this.bootstrap_method_attr_index.value,
                "msg_const_dynamic_bootstrap_method_attr_index",
                Icons.Index
        );

        final int cpIndex = this.name_and_type_index.value;
        this.addNode(parentNode,
                startPos + 3,
                2,
                "name_and_type_index",
                String.format(TEXT_CPINDEX_PUREVALUE, cpIndex, ((ClassFile)classFile).getCPDescription(cpIndex)),
                "msg_const_dynamic_name_and_type_index",
                Icons.Offset
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Dynamic_info.java`:

```java
/*
 * ConstantDynamicInfo.java    May 17, 2019
 *
 * Copyright 2019, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * The {@code CONSTANT_Dynamic_info} structure is used to represent a
 * dynamically-computed constant, an arbitrary value that is produced by
 * invocation of a bootstrap method in the course of an {@code ldc} instruction,
 * among others. The auxiliary type specified by the structure constrains the
 * type of the dynamically-computed constant.
 *
 * <pre>
 *    CONSTANT_Dynamic_info {
 *      u1 tag;
 *
 *      u2 bootstrap_method_attr_index;
 *      u2 name_and_type_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.10">
 * VM Spec: he CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101"})
public class CONSTANT_Dynamic_info extends CONSTANT_Dynamic {

    CONSTANT_Dynamic_info(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(cp_info.ConstantType.CONSTANT_Dynamic.tag, posDataInputStream);

        // TODO - Find a test case to verify this chagne is working or not
        System.out.println("Congratulations. We verified the tree ndoe for ConstantDynamicInfo is working. We can delete this log output now.");
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Dynamic.name();
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Fieldref_info.java`:

```java
/*
 * ConstantFieldrefInfo.java    4:31 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.SignatureConvertor;

/**
 * The class for the {@code CONSTANT_Fieldref_info} structure in constant pool.
 * The {@code CONSTANT_Fieldref_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Fieldref_info {
 *        u1 tag;
 *        u2 class_index;
 *        u2 name_and_type_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
 * VM Spec: The CONSTANT_Fieldref_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Fieldref_info extends CONSTANT_Ref {

    CONSTANT_Fieldref_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Fieldref.tag, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_ref";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Fieldref.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        // Class
        String clazz = constantPool[this.class_index.value].toString(constantPool);

        // Name and Type
        CONSTANT_NameAndType_info nameType = (CONSTANT_NameAndType_info) constantPool[this.name_and_type_index.value];
        String name = constantPool[nameType.name_index.value].toString(constantPool);
        String type = constantPool[nameType.descriptor_index.value].toString(constantPool);
        String typeDesc;

        try {
            typeDesc = SignatureConvertor.fieldDescriptorExtractor(type).toString();
        } catch (FileFormatException ex) {
            typeDesc = type + UNRECOGNIZED_TYPE;
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, "Failed to parse the field type: " + type, ex);
        }

        return String.format("%s.%s : %s", clazz, name, typeDesc);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        super.generateTreeNode(parentNode,
                (ClassFile) format,
                "class name"
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Float_info.java`:

```java
/*
 * ConstantFloatInfo.java    4:41 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;

/**
 * The class for the {@code CONSTANT_Float_info} structure in constant pool. The
 * {@code CONSTANT_Float_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Float_info {
 *        u1 tag;
 *        u4 bytes;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 1.0.2
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.4">
 * VM Spec: The CONSTANT_Float_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Float_info extends cp_info {

    public static final int RAW_DATA_SIZE = 4;
    public static final int LENGTH = 5;
    public final byte[] rawData;
    public final Float floatValue;

    CONSTANT_Float_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Float.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.rawData = posDataInputStream.getBuf(posDataInputStream.getPos(), RAW_DATA_SIZE);
        this.floatValue = posDataInputStream.readFloat();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: [%f].",
                this.getName(), this.startPos, this.length, this.floatValue);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_intfloat";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Float.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.valueOf(this.floatValue);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                this.getStartPos() + 1,
                4,
                "bytes",
                this.floatValue + " - " + BytesTool.getByteDataHexView(this.rawData),
                "msg_const_float_bytes",
                Icons.Data
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Integer_info.java`:

```java
/*
 * ConstantIntegerInfo.java    4:38 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;

/**
 * The class for the {@code CONSTANT_Integer_info} structure in constant pool.
 * The {@code CONSTANT_Integer_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Integer_info {
 *        u1 tag;
 *        u4 bytes;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.4">
 * VM Spec: The CONSTANT_Integer_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Integer_info extends cp_info {

    public static final int RAW_DATA_SIZE = 4;
    public static final int LENGTH = 5;
    public final byte[] rawData;
    public final int integerValue;

    CONSTANT_Integer_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Integer.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.rawData = posDataInputStream.getBuf(posDataInputStream.getPos(), RAW_DATA_SIZE);
        this.integerValue = posDataInputStream.readInt();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: [%d].",
                this.getName(), super.startPos, super.length, this.integerValue);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_intfloat";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Integer.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.valueOf(this.integerValue);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                super.startPos + 1,
                4,
                "bytes",
                this.integerValue + " - " + BytesTool.getByteDataHexView(this.rawData),
                "msg_const_int_bytes",
                Icons.Data
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_InterfaceMethodref_info.java`:

```java
/*
 * ConstantInterfaceMethodrefInfo.java    4:35 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.ClassFile;

/**
 * The class for the {@code CONSTANT_InterfaceMethodref_info} structure in
 * constant pool. The {@code CONSTANT_InterfaceMethodref_info} structure has the
 * following format:
 *
 * <pre>
 *    CONSTANT_InterfaceMethodref_info {
 *        u1 tag;
 *
 *        u2 class_index;
 *        u2 name_and_type_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
 * VM Spec: The CONSTANT_InterfaceMethodref_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_InterfaceMethodref_info extends CONSTANT_Ref {

    CONSTANT_InterfaceMethodref_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_InterfaceMethodref.tag, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_ref";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_InterfaceMethodref.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return super.toString4Method(constantPool);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        super.generateTreeNode(parentNode,
                (ClassFile) format,
                "interface name"
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_InvokeDynamic_info.java`:

```java
/*
 * ConstantInvokeDynamicInfo.java    12:44 AM, April 28, 2014
 *
 * Copyright 2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * The {@code CONSTANT_InvokeDynamic_info} structure is used by an
 * {@code invokedynamic} instruction to specify a bootstrap method, the dynamic
 * invocation name, the argument and return types of the call, and optionally, a
 * sequence of additional constants called static arguments to the bootstrap
 * method.
 *
 * <pre>
 *    CONSTANT_InvokeDynamic_info {
 *      u1 tag;
 *
 *      u2 bootstrap_method_attr_index;
 *      u2 name_and_type_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.10">
 * VM Spec: he CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101"})
public class CONSTANT_InvokeDynamic_info extends CONSTANT_Dynamic {

    CONSTANT_InvokeDynamic_info(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(cp_info.ConstantType.CONSTANT_InvokeDynamic.tag, posDataInputStream);
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_InvokeDynamic.name();
    }
}
```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Long_info.java`:

```java
/*
 * ConstantLongInfo.java    4:43 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;

/**
 * The class for the {@code CONSTANT_Long_info} structure in constant pool. The
 * {@code CONSTANT_Long_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Long_info {
 *        u1 tag;
 *
 *        u4 high_bytes;
 *        u4 low_bytes;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.5">
 * VM Spec: The CONSTANT_Long_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Long_info extends cp_info {

    public static final int RAW_DATA_SIZE = 8;
    public static final int LENGTH = 9;

    /**
     * In JVM Spec we have two fields: u4 high_bytes and u4 low_bytes.
     */
    public final byte[] rawData;
    public final long longValue;

    CONSTANT_Long_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Long.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.rawData = posDataInputStream.getBuf(posDataInputStream.getPos(), RAW_DATA_SIZE);
        this.longValue = posDataInputStream.readLong();
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Long.name();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: [%d].",
                this.getName(), this.startPos, this.length, this.longValue);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_longdouble";
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.valueOf(this.longValue);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        String value = "value = " + this.longValue + " Hex Value = " + BytesTool.getByteDataHexView(this.rawData);
        this.addNode(parentNode,
                this.startPos + 1,
                4,
                "high_bytes",
                value,
                "msg_const_long_bytes",
                Icons.Data
        );
        this.addNode(parentNode,
                this.startPos + 5,
                4,
                "low_bytes",
                value,
                "msg_const_long_bytes",
                Icons.Data
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_MethodHandle_info.java`:

```java
/*
 * ConstantMethodHandleInfo.java    12:04 AM, April 28, 2014
 *
 * Copyright 2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u1;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code CONSTANT_MethodHandle_info} structure is used to represent a
 * method handle.
 *
 * <pre>
 *    CONSTANT_MethodHandle_info {
 *        u1 tag;
 *
 *        u1 reference_kind;
 *        u2 reference_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.8">
 * VM Spec: The CONSTANT_MethodHandle_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_MethodHandle_info extends cp_info {

    public static final int LENGTH = 5;
    /**
     * The value of the {@code reference_kind} item must be in the range 1 to 9.
     * The value denotes the {@code kind} of this method handle, which
     * characterizes its byte code behavior.
     */
    public final u1 reference_kind;
    /**
     * The value of the {@code reference_index} item must be a valid index into
     * the {@code constant_pool} table.
     */
    public final u2 reference_index;

    CONSTANT_MethodHandle_info(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(cp_info.ConstantType.CONSTANT_MethodHandle.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        this.reference_kind = new u1(posDataInputStream, true);
        this.reference_index = new u2(posDataInputStream);
        super.length = LENGTH;
    }

    @Override
    public String getDescription() {
        return this.getName() + ": Start Position: [" + super.startPos
                + "], length: [" + super.length
                + "], reference_kind: [" + this.reference_kind.value
                + "], reference_index = [" + this.reference_index.value + "]";
    }

    @Override
    public String getMessageKey() {
        return "msg_const_methodhandle";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_MethodHandle.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return String.format("reference_kind=%s reference_index=%s",
                ReferenceKind.name(this.reference_kind.value),
                constantPool[this.reference_index.value].toString(constantPool));
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                super.startPos + 1,
                1,
                "reference_kind",
                this.reference_kind.value + " - " + CONSTANT_MethodHandle_info.ReferenceKind.name(this.reference_kind.value),
                "msg_const_methodhandle_reference_kind",
                Icons.Kind
        );
        this.addNode(parentNode,
                super.startPos + 2,
                2,
                "reference_index",
                this.reference_index.value + " - " + ((ClassFile)classFile).getCPDescription(this.reference_index.value),
                "msg_const_methodhandle_reference_index",
                Icons.Offset
        );
    }

    /**
     * The value denotes the {@code kind} of this method handle, which
     * characterizes its bytecode behavior.
     *
     * @see <a
     * href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5">
     * VM Spec: Method Type and Method Handle Resolution
     * </a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum ReferenceKind {

        REF_getField(1),
        REF_getStatic(2),
        REF_putField(3),
        REF_putStatic(4),
        REF_invokeVirtual(5),
        REF_invokeStatic(6),
        REF_invokeSpecial(7),
        REF_newInvokeSpecial(8),
        REF_invokeInterface(9);

        /**
         * ID of the {@link ReferenceKind}.
         */
        public final int value;

        private ReferenceKind(int value) {
            this.value = value;
        }

        /**
         * Get the {@link ReferenceKind} name based on its internal
         * {@link #value}.
         *
         * @param value Internal {@link #value}
         * @return {@link ReferenceKind} name
         */
        public static String name(int value) {
            String result = "Un-recognized";
            for (ReferenceKind item : ReferenceKind.values()) {
                if (item.value == value) {
                    result = item.name();
                    break;
                }
            }

            return result;
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_MethodType_info.java`:

```java
/*
 * ConstantMethodTypeInfo.java    12:04 AM, April 28, 2014
 *
 * Copyright 2014, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.SignatureConvertor;
import org.binaryinternals.format.classfile.u2;

/**
 * The {@code CONSTANT_MethodHandle_info} structure is used to represent a
 * method handle.
 *
 * <pre>
 *    CONSTANT_MethodType_info {
 *        u1 tag;
 * 
 *        u2 descriptor_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see <a
 * href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.9">
 * VM Spec: The CONSTANT_MethodType_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_MethodType_info extends cp_info {

    public static final int LENGTH = 3;
    /**
     * The value of the {@code descriptor_index} item must be a valid index into
     * the {@code constant_pool} table. The {@code constant_pool} entry at that
     * index must be a {@code CONSTANT_Utf8_info} structure representing a
     * method descriptor.
     */
    public final u2 descriptor_index;

    CONSTANT_MethodType_info(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(cp_info.ConstantType.CONSTANT_MethodType.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        this.descriptor_index = new u2(posDataInputStream);
        super.length = LENGTH;
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], descriptor_index: [%d]. ",
                this.getName(), this.startPos, super.length, this.descriptor_index.value);
    }
    
    @Override
    public String getMessageKey() {
        return "msg_const_methodtype";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_MethodType.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        String descriptor = constantPool[this.descriptor_index.value].toString(constantPool);
        String parameters;
        String returnType;

        try {
            parameters = SignatureConvertor.methodParameters2Readable(descriptor);
        } catch (FileFormatException ex) {
            parameters = descriptor + UNRECOGNIZED_TYPE;
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, "Failed to parse the method parameters: " + descriptor, ex);
        }

        try {
            returnType = SignatureConvertor.methodReturnTypeExtractor(descriptor).toString();
        } catch (FileFormatException ex) {
            returnType = descriptor + UNRECOGNIZED_TYPE;
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, "Failed to parse the method return type: " + descriptor, ex);
        }

        return String.format("%s : %s", parameters, returnType);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int cpIndex = this.descriptor_index.value;
        this.addNode(parentNode,
                startPos + 1,
                2,
                "descriptor_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "descriptor", ((ClassFile) classFile).getCPDescription(cpIndex)),
                "msg_const_methodtype_descriptor_index",
                Icons.Descriptor
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Methodref_info.java`:

```java
/*
 * ConstantMethodrefInfo.java    4:34 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.ClassFile;

/**
 * The class for the {@code CONSTANT_Methodref_info} structure in constant pool.
 * The {@code CONSTANT_Methodref_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Methodref_info {
 *        u1 tag;
 *
 *        u2 class_index;
 *        u2 name_and_type_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
 * VM Spec: The CONSTANT_Methodref_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public class CONSTANT_Methodref_info extends CONSTANT_Ref {

    CONSTANT_Methodref_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Methodref.tag, posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_ref";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Methodref.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return super.toString4Method(constantPool);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        super.generateTreeNode(parentNode,
                (ClassFile) format,
                "class name"
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Module_info.java`:

```java
/*
 * ConstantModuleInfo.java    00:14 AM, July 19, 2018
 *
 * Copyright  2018, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_Module_info} structure in constant pool.
 * The {@code CONSTANT_Module_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Module_info {
 *        u1 tag;
 *
 *        u2 name_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 9
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.11">
 * VM Spec: The CONSTANT_Module_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_Module_info extends cp_info {

    public static final int LENGTH = 3;

    /**
     * The value of the {@link name_index} item must be a valid index into the
     * {@code constant_pool} table. The constant_pool entry at that index must
     * be a {@link CONSTANT_Utf8_info} structure representing a valid module name.
     */
    public final u2 name_index;

    CONSTANT_Module_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Module.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.name_index = new u2(posDataInputStream);
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: name_index=[%d].",
                this.getName(), super.startPos, this.length, this.name_index.value);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_module";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Module.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return ((CONSTANT_Utf8_info) constantPool[this.name_index.value]).getValue();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int cpIndex = this.name_index.value;
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "module name", ((ClassFile) classFile).getCPDescription(cpIndex)),
                "msg_const_module_name_index",
                Icons.Name
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_NameAndType_info.java`:

```java
/*
 * ConstantNameAndTypeInfo.java    4:46 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_NameAndType_info} structure in constant
 * pool. The {@code CONSTANT_NameAndType_info} structure has the following
 * format:
 *
 * <pre>
 *    CONSTANT_NameAndType_info {
 *        u1 tag;
 * 
 *        u2 name_index;
 *        u2 descriptor_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.6">
 * VM Spec: The CONSTANT_NameAndType_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_NameAndType_info extends cp_info {

    public static final int LENGTH = 5;
    public final u2 name_index;
    public final u2 descriptor_index;

    CONSTANT_NameAndType_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_NameAndType.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.name_index = new u2(posDataInputStream);
        this.descriptor_index = new u2(posDataInputStream);
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: name_index=[%d], descriptor_index=[%d].",
                this.getName(), this.startPos, this.length, this.name_index.value, this.descriptor_index.value);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_nameandtype";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_NameAndType.name();
    }
    
    @Override
    public String toString(cp_info[] constantPool) {
        String nameStr = constantPool[this.name_index.value].toString(constantPool);
        String typeStr = constantPool[this.descriptor_index.value].toString(constantPool);

        return String.format("name=%s, type=%s", nameStr, typeStr);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        ClassFile classFile = (ClassFile) format;

        int cpIndex = this.name_index.value;
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "name", classFile.getCPDescription(cpIndex)),
                "msg_const_nameandtype_name_index",
                Icons.Name
        );

        cpIndex = this.descriptor_index.value;
        this.addNode(parentNode,
                super.startPos + 3,
                2,
                "descriptor_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "descriptor", classFile.getCPDescription(cpIndex)),
                "msg_const_nameandtype_descriptor_index",
                Icons.Descriptor
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Package_info.java`:

```java
/*
 * ConstantPackageInfo.java    00:19 AM, July 19, 2018
 *
 * Copyright  2018, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_Package_info} structure in constant pool.
 * The {@code CONSTANT_Package_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Package_info {
 *        u1 tag;
 *
 *        u2 name_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @since Java 9
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.12">
 * VM Spec: The CONSTANT_Package_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_Package_info extends cp_info {

    public static final int LENGTH = 3;

    /**
     * The value of the {@link name_index} item must be a valid index into the
     * {@code constant_pool} table. The constant_pool entry at that index must
     * be a {@link CONSTANT_Utf8_info} structure representing a valid package
     * name encoded in internal form.
     */
    public final u2 name_index;

    CONSTANT_Package_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_Package.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.name_index = new u2(posDataInputStream);
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: name_index=[%d].",
                this.getName(), this.startPos, this.length, this.name_index.value);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_package";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Package.name();
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return ((CONSTANT_Utf8_info) constantPool[this.name_index.value]).getValue();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        final int cpIndex = this.name_index.value;
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "package name", ((ClassFile) classFile).getCPDescription(cpIndex)),
                "msg_const_package_name_index",
                Icons.Name
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Ref.java`:

```java
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.SignatureConvertor;
import org.binaryinternals.format.classfile.u2;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public abstract class CONSTANT_Ref extends cp_info {

    public static final int LENGTH = 5;
    public final u2 class_index;
    public final u2 name_and_type_index;

    protected CONSTANT_Ref(final short tag, final PosDataInputStream posDataInputStream) throws IOException {
        super(tag);

        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.class_index = new u2(posDataInputStream);
        this.name_and_type_index = new u2(posDataInputStream);
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: class_index=[%d], name_and_type_index=[%d].",
                this.getName(), this.startPos, this.length, this.class_index.value, this.name_and_type_index.value);
    }

    /**
     * Shared {@link #toString(cp_info[])} method for methods.
     *
     * @param constantPool Constant pool of current class file.
     * @return Reader friendly string of current object
     */
    protected String toString4Method(cp_info[] constantPool) {
        // Class
        String clazz = constantPool[this.class_index.value].toString(constantPool);

        // Name and Type
        CONSTANT_NameAndType_info nameType = (CONSTANT_NameAndType_info) constantPool[this.name_and_type_index.value];
        String nameStr = constantPool[nameType.name_index.value].toString(constantPool);
        String typeStr = constantPool[nameType.descriptor_index.value].toString(constantPool);
        String parameters;
        String returnType;

        try {
            parameters = SignatureConvertor.methodParameters2Readable(typeStr);
        } catch (FileFormatException ex) {
            parameters = typeStr + UNRECOGNIZED_TYPE;
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, "Failed to parse the method parameters: " + typeStr, ex);
        }

        try {
            returnType = SignatureConvertor.methodReturnTypeExtractor(typeStr).toString();
        } catch (FileFormatException ex) {
            returnType = typeStr + UNRECOGNIZED_TYPE;
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, "Failed to parse the method return type: " + typeStr, ex);
        }

        return String.format("%s.%s%s : %s", clazz, nameStr, parameters, returnType);
    }

    protected void generateTreeNode(DefaultMutableTreeNode parentNode, ClassFile classFile, String classPerfix) {
        final int classIndex = this.class_index.value;
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "class_index",
                String.format(TEXT_CPINDEX_VALUE, classIndex, classPerfix, classFile.getCPDescription(classIndex)),
                "msg_const_ref_class_index",
                Icons.Offset);

        final int ntIndex = this.name_and_type_index.value;
        this.addNode(parentNode,
                super.startPos + 3,
                2,
                "name_and_type_index",
                String.format(TEXT_CPINDEX_PUREVALUE, ntIndex, classFile.getCPDescription(ntIndex)),
                "msg_const_ref_name_and_type_index",
                Icons.Offset);
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_String_info.java`:

```java
/*
 * ConstantStringInfo.java    4:36 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_String_info} structure in constant pool.
 * The {@code CONSTANT_String_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_String_info {
 *        u1 tag;
 *
 *        u2 string_index;
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.3">
 * VM Spec: The CONSTANT_String_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_String_info extends cp_info {

    public static final int LENGTH = 3;
    public final u2 string_index;

    CONSTANT_String_info(final PosDataInputStream posDataInputStream) throws IOException {
        super(cp_info.ConstantType.CONSTANT_String.tag);
        super.startPos = posDataInputStream.getPos() - 1;
        super.length = LENGTH;

        this.string_index = new u2(posDataInputStream);
    }

    @Override
    public String getMessageKey() {
        return "msg_const_string";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_String.name();
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: string_index=[%d].", this.getName(), this.startPos, this.length, this.string_index.value);
    }

    @Override
    public String toString(cp_info[] constantPool) {
        // The value of the string_index item must be a valid index into the constant_pool table.
        // The constant_pool entry at that index must be a CONSTANT_Utf8_info structure
        // representing the sequence of characters to which the String object is to be initialized.
        return ((CONSTANT_Utf8_info) constantPool[this.string_index.value]).getValue();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        this.addNode(parentNode,
                super.startPos + 1,
                2,
                "string_index",
                String.format(TEXT_CPINDEX_VALUE, this.string_index.value, "string", ((ClassFile) classFile).getCPDescription(this.string_index.value)),
                "msg_const_string_string_index",
                Icons.Offset
        );
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/CONSTANT_Utf8_info.java`:

```java
/*
 * ConstantUtf8Info.java    4:52 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.u2;

/**
 * The class for the {@code CONSTANT_Utf8_info} structure in constant pool. The
 * {@code CONSTANT_Utf8_info} structure has the following format:
 *
 * <pre>
 *    CONSTANT_Utf8_info {
 *        u1 tag;
 *
 *        u2 length;
 *        u1 bytes[length];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.7">
 * VM Spec: The CONSTANT_Utf8_info Structure
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class CONSTANT_Utf8_info extends cp_info {

    public final u2 length_utf8;
    public final byte[] bytes;

    /**
     * Buffer for {@link #getValue()}.
     */
    private String value = null;

    CONSTANT_Utf8_info(final PosDataInputStream posDataInputStream) throws IOException, FileFormatException {
        super(cp_info.ConstantType.CONSTANT_Utf8.tag);
        super.startPos = posDataInputStream.getPos() - 1;

        this.length_utf8 = new u2(posDataInputStream);
        this.bytes = new byte[this.length_utf8.value];
        final int bytesRead = posDataInputStream.read(this.bytes);
        if (bytesRead != this.length_utf8.value) {
            throw new FileFormatException("Read bytes for CONSTANT_Utf8 error.");
        }

        super.length = this.length_utf8.value + 1 + 2;
    }

    @Override
    public String getDescription() {
        return String.format("%s: Start Position: [%d], length: [%d], value: [%s].", this.getName(), this.startPos, super.length, this.getValue());
    }

    @Override
    public String getMessageKey() {
        return "msg_const_utf8";
    }

    @Override
    public String getName() {
        return ConstantType.CONSTANT_Utf8.name();
    }

    /**
     * Get the {@link #bytes} value as a String, using platform's default
     * charset.
     *
     * @return The content as String
     */
    public String getValue() {
        if (this.value == null) {
            this.value = new String(this.bytes, StandardCharsets.UTF_8);
        }

        return this.value;
    }

    @Override
    public String toString(cp_info[] constantPool) {
        return this.getValue();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat classFile) {
        int floatPos = super.startPos + 1;
        this.addNode(parentNode, floatPos, u2.LENGTH, "length", this.length_utf8.value, "msg_const_utf8_length", Icons.Length);
        floatPos += u2.LENGTH;
        this.addNode(parentNode, floatPos, this.length_utf8.value, "bytes", this.getValue(), "msg_const_utf8_bytes", Icons.Data);
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/constant/cp_info.java`:

```java
/*
 * CPInfo.java    3:44 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile.constant;

import java.lang.reflect.InvocationTargetException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.classfile.ClassFile;
import org.binaryinternals.format.classfile.GenerateTreeNodeClassFile;
import org.binaryinternals.format.classfile.JavaSEVersion;
import org.binaryinternals.format.classfile.u1;

/**
 * The super class for constant pool items in class file. All constant pool
 * items have the following format:
 *
 * <pre>
 *    cp_info {
 *        u1 tag;
 *        u1 info[];
 *    }
 * </pre>
 *
 * The contents in {@code info} is determined by {@code tag}.
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4">
 * VM Spec: The Constant Pool
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings("java:S101")
public abstract class cp_info extends FileComponent implements GenerateTreeNodeClassFile {

    /**
     * Warning message for un-recognized type.
     */
    protected static final String UNRECOGNIZED_TYPE = " !!! Un-recognized type";

    /**
     * Each item in the {@link ClassFile#constant_pool} table must begin with a
     * 1-byte {@link #tag} indicating the kind of <code>cp_info</code> entry.
     *
     * The value come from the enum field {@link ConstantType#tag}.
     */
    public final u1 tag;

    cp_info(short tag) {
        this.tag = new u1(tag);
    }

    /**
     * Get a detailed, technical description of the constant pool item.
     *
     * @return Detailed, technical description of the item
     */
    public abstract String getDescription();

    /**
     * Get the name of current constant pool item.
     *
     * @return Name of the constant pool item
     */
    public abstract String getName();

    /**
     * The get the Message key which contains the corresponding description of current attribute.
     *
     * @return Message key
     */
    public abstract String getMessageKey();

    /**
     * Get a human reader friendly of current constant pool item.
     *
     * @param constantPool Constant Pool items needed
     * @return Reader friendly string
     */
    public abstract String toString(cp_info[] constantPool);

    /**
     * Constant pool tags.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4">
     * VM Spec: The Constant Pool
     * </a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from JVM Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum ConstantType {

        /**
         * The value for constant type {@code CONSTANT_Utf8}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.7">
         * VM Spec: The CONSTANT_Utf8_info Structure
         * </a>
         */
        CONSTANT_Utf8(1, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, false, CONSTANT_Utf8_info.class),
        /**
         * The value for constant type {@code CONSTANT_Integer}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.4">
         * VM Spec: The CONSTANT_Integer_info and CONSTANT_Float_info Structures
         * </a>
         */
        CONSTANT_Integer(3, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_Integer_info.class),
        /**
         * The value for constant type {@code CONSTANT_Float}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.4">
         * VM Spec: The CONSTANT_Integer_info and CONSTANT_Float_info Structures
         * </a>
         */
        CONSTANT_Float(4, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_Float_info.class),
        /**
         * The value for constant type {@code CONSTANT_Long}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.5">
         * VM Spec: The CONSTANT_Long_info and CONSTANT_Double_info Structures
         * </a>
         */
        CONSTANT_Long(5, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_Long_info.class),
        /**
         * The value for constant type {@code CONSTANT_Double}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.5">
         * VM Spec: The CONSTANT_Long_info and CONSTANT_Double_info Structures
         * </a>
         */
        CONSTANT_Double(6, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_Double_info.class),
        /**
         * The value for constant type {@code CONSTANT_Class}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.1">
         * VM Spec: The CONSTANT_Class_info Structure
         * </a>
         */
        CONSTANT_Class(7, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_Class_info.class),
        /**
         * The value for constant type {@code CONSTANT_String}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.3">
         * VM Spec: The CONSTANT_String_info Structure
         * </a>
         */
        CONSTANT_String(8, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, true, CONSTANT_String_info.class),
        /**
         * The value for constant type {@code CONSTANT_Fieldref}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
         * VM Spec: The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
         * CONSTANT_InterfaceMethodref_info Structures
         * </a>
         */
        CONSTANT_Fieldref(9, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, false, CONSTANT_Fieldref_info.class),
        /**
         * The value for constant type {@code CONSTANT_Methodref}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
         * VM Spec: The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
         * CONSTANT_InterfaceMethodref_info Structures
         * </a>
         */
        CONSTANT_Methodref(10, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, false, CONSTANT_Methodref_info.class),
        /**
         * The value for constant type {@code CONSTANT_InterfaceMethodref}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.2">
         * VM Spec: The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and
         * CONSTANT_InterfaceMethodref_info Structures
         * </a>
         */
        CONSTANT_InterfaceMethodref(11, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, false, CONSTANT_InterfaceMethodref_info.class),
        /**
         * The value for constant type {@code CONSTANT_NameAndType}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.6">
         * VM Spec: The CONSTANT_NameAndType_info Structure
         * </a>
         */
        CONSTANT_NameAndType(12, ClassFile.FormatVersion.FORMAT_45_3, JavaSEVersion.VERSION_1_0_2, false, CONSTANT_NameAndType_info.class),
        /**
         * The value for constant type {@code CONSTANT_MethodHandle}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.8">
         * VM Spec: The CONSTANT_MethodHandle_info Structure
         * </a>
         */
        CONSTANT_MethodHandle(15, ClassFile.FormatVersion.FORMAT_51, JavaSEVersion.VERSION_7, true, CONSTANT_MethodHandle_info.class),
        /**
         * The value for constant type {@code CONSTANT_MethodType}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.9">
         * VM Spec: The CONSTANT_MethodType_info Structure
         * </a>
         */
        CONSTANT_MethodType(16, ClassFile.FormatVersion.FORMAT_51, JavaSEVersion.VERSION_7, true, CONSTANT_MethodType_info.class),
        /**
         * The value for constant type {@code CONSTANT_Dynamic}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.10">
         * VM Spec: The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info
         * Structures
         * </a>
         */
        CONSTANT_Dynamic(17, ClassFile.FormatVersion.FORMAT_55, JavaSEVersion.VERSION_11, true, CONSTANT_Dynamic_info.class),
        /**
         * The value for constant type {@code CONSTANT_InvokeDynamic}.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.10">
         * VM Spec: The CONSTANT_InvokeDynamic Structure
         * </a>
         */
        CONSTANT_InvokeDynamic(18, ClassFile.FormatVersion.FORMAT_51, JavaSEVersion.VERSION_7, false, CONSTANT_InvokeDynamic_info.class),
        /**
         * The CONSTANT_Module_info structure is used to represent a module.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.11">
         * VM Spec: The CONSTANT_Module_info Structure
         * </a>
         */
        CONSTANT_Module(19, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9, false, CONSTANT_Module_info.class),
        /**
         * The CONSTANT_Package_info structure is used to represent a package
         * exported or opened by a module.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4.12">
         * VM Spec: The CONSTANT_Package_info Structure
         * </a>
         */
        CONSTANT_Package(20, ClassFile.FormatVersion.FORMAT_53, JavaSEVersion.VERSION_9, false, CONSTANT_Package_info.class);

        private static final Logger Log = Logger.getLogger(ConstantType.class.getName());

        /**
         * Value of tag.
         */
        public final short tag;

        /**
         * Class file format.
         */
        public final ClassFile.FormatVersion format;

        /**
         * Java SE platform version.
         */
        public final JavaSEVersion javaSE;

        /**
         * Some entries in the constant_pool table are loadable because they
         * represent entities that can be pushed onto the stack at run time to
         * enable further computation.
         *
         * @see
         * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.4-310">
         * VM Spec: Table 4.4-C. Loadable constant pool tags
         * </a>
         */
        public final boolean loadable;

        /**
         * The Java class representing to the attributes.
         */
        final Class<?> clazz;

        private ConstantType(int tag, ClassFile.FormatVersion format, JavaSEVersion javaSE, boolean loadable, Class<?> clz) {
            this.tag = (short) tag;
            this.format = format;
            this.javaSE = javaSE;
            this.loadable = loadable;
            this.clazz = clz;
        }

        /**
         * Get the {@link ConstantType} based on its internal {@link #tag}
         * value.
         *
         * @param tag Internal {@link #tag} value
         * @return Corresponding {@link ConstantType}
         */
        public static ConstantType valueOf(int tag) {
            for (ConstantType item : ConstantType.values()) {
                if (item.tag == tag) {
                    return item;
                }
            }

            throw new IllegalArgumentException("Invalid tag value: " + tag);
        }

        /**
         * Parse a constant pool item.
         *
         * @param tag Constant pool item tag, indicating the type of the item
         * @param posDataInputStream Class file byte stream
         * @return Parsed constant pool info
         * @throws FileFormatException An invalid class file format encountered
         */
        public static cp_info parse(int tag, final PosDataInputStream posDataInputStream) throws FileFormatException {
            cp_info cpInfo = null;

            for (ConstantType item : ConstantType.values()) {
                if (item.tag == tag) {
                    try {
                        // There is only 1 constructor in the JVM Attributes
                        cpInfo = (cp_info) item.clazz.getDeclaredConstructors()[0].newInstance(posDataInputStream);
                    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
                        Log.log(Level.SEVERE, "Failed to parse the JVM Constant Tag at position {0}, {1}", new Object[]{posDataInputStream.getPos() - 1, ex.toString()});
                    }
                }
            }

            if (cpInfo == null) {
                throw new FileFormatException(String.format("Unreconizable constant pool type found. Constant pool tag: [%d]; class file offset: [%d].", tag, posDataInputStream.getPos() - 1));
            } else {
                return cpInfo;
            }
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/field_info.java`:

```java
/*
 * field_info.java    3:57 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.constant.cp_info;

/**
 * {@code Field} of a class or interface. The {@code Field} structure has the
 * following format:
 *
 * <pre>
 *    field_info {
 *        u2 access_flags;
 *        u2 name_index;
 *        u2 descriptor_index;
 *        u2 attributes_count;
 *        attribute_info attributes[attributes_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.5">
 * VM Spec: Fields
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class field_info extends FileComponent implements GenerateTreeNodeClassFile {

    public final u2 access_flags;
    public final u2 name_index;
    public final u2 descriptor_index;
    public final u2 attributes_count;
    public final attribute_info[] attributes;
    private String declaration;
    private String descriptor;
    private String name;

    field_info(final PosDataInputStream posDataInputStream, final cp_info[] cp) throws IOException, FileFormatException {
        this.startPos = posDataInputStream.getPos();
        this.length = -1;

        this.access_flags = new u2(posDataInputStream);
        this.name_index = new u2(posDataInputStream);
        this.descriptor_index = new u2(posDataInputStream);
        this.attributes_count = new u2(posDataInputStream);

        final int attrCount = this.attributes_count.value;
        if (attrCount > 0) {
            this.attributes = new attribute_info[attrCount];
            for (int i = 0; i < attrCount; i++) {
                this.attributes[i] = attribute_info.parse(posDataInputStream, cp);
            }
        } else {
            this.attributes = null;
        }

        this.calculateLength();
        this.parse(cp);
    }

    private void calculateLength() {
        this.length = 8;

        for (int i = 0; i < this.attributes_count.value; i++) {
            this.length += this.attributes[i].getLength();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Get raw data

    /**
     * Get the declaration of the field. The declaration is generated by
     * {@code access_flags}, {@code name_index} and {@code descriptor_index}.
     *
     * @return {@code Field} declaration
     */
    public String getDeclaration() {
        return this.declaration;
    }

    /**
     * Get field descriptor.
     *
     * @return Field descriptor
     * @see #descriptor
     */
    public String getDescriptor() {
        return this.descriptor;
    }

    /**
     * Generate the modifier string from the {@link #access_flags} value.
     *
     * @return A string for modifier
     */
    public String getModifiers() {
        return AccessFlag.getFieldModifier(this.access_flags.value);
    }

    /**
     * Get field name.
     *
     * @return Field name
     * @see #name_index
     */
    public String getName() {
        return this.name;
    }

    /**
     * Set the declaration string.
     */
    private void parse(final cp_info[] cpInfo) throws FileFormatException {
        this.name = ClassFile.getConstantUtf8Value(this.name_index.value, cpInfo);
        this.descriptor = ClassFile.getConstantUtf8Value(this.descriptor_index.value, cpInfo);

        String type;
        try {
            type = SignatureConvertor.fieldDescriptorExtractor(this.descriptor).toString();
        } catch (FileFormatException se) {
            type = "[Unexpected signature type]: " + this.descriptor;
        }

        this.declaration = String.format("%s %s %s", this.getModifiers(), type, this.name);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        final ClassFile classFile = (ClassFile)fileFormat;
        final int floatPos = this.getStartPos();

        this.addNode(parentNode,
                floatPos,
                u2.LENGTH,
                FIELD_ACCESS_FLAGS,
                BytesTool.getBinaryString(this.access_flags.value) + " " + this.getModifiers(),
                "msg_field_info__access_flags",
                Icons.AccessFlag
        );

        final int nameIndex = this.name_index.value;
        this.addNode(parentNode,
                floatPos + 2,
                u2.LENGTH,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, nameIndex, "field name", classFile.getCPDescription(nameIndex)),
                "msg_field_info__name_index",
                Icons.Name
        );

        final int descriptorIndex = this.descriptor_index.value;
        this.addNode(parentNode,
                floatPos + 4,
                u2.LENGTH,
                "descriptor_index",
                String.format(TEXT_CPINDEX_VALUE, descriptorIndex, "field descriptor", classFile.getCPDescription(descriptorIndex)),
                "msg_field_info__descriptor_index",
                Icons.Descriptor
        );

        final int attributesCount = this.attributes_count.value;
        this.addNode(parentNode,
                floatPos + 6,
                u2.LENGTH,
                FIELD_ATTR_COUNT,
                attributesCount,
                "msg_field_info__attributes_count",
                Icons.Counter
        );

        if (attributesCount > 0) {
            final attribute_info lastAttr = this.attributes[attributesCount - 1];
            final DefaultMutableTreeNode treeNodeAttr =
                    new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    floatPos + 8,
                    lastAttr.getStartPos() + lastAttr.getLength() - floatPos - 8,
                    String.format(FIELD_ATTRS, attributesCount),
                    MESSAGES.getString("msg_field_info__attributes")
            ));

            DefaultMutableTreeNode treeNodeAttrItem;
            attribute_info attr;
            for (int i = 0; i < attributesCount; i++) {
                attr = this.attributes[i];
                treeNodeAttrItem = this.addNode(treeNodeAttr,
                        attr.getStartPos(),
                        attr.getLength(),
                        String.valueOf(i + 1),
                        attr.getName(),
                        attr.getMessageKey(),
                        Icons.Annotations
                );
                attr.generateTreeNodeCommon(treeNodeAttrItem, classFile);
            }
            parentNode.add(treeNodeAttr);
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/method_info.java`:

```java
/*
 * method_info.java    4:01 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.classfile.attribute.attribute_info;
import org.binaryinternals.format.classfile.constant.cp_info;

/**
 * {@code Method} of a class or interface. The {@code Method} structure has the
 * following format:
 *
 * <pre>
 *    method_info {
 *        u2 access_flags;
 *        u2 name_index;
 *        u2 descriptor_index;
 *        u2 attributes_count;
 *        attribute_info attributes[attributes_count];
 *    }
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.6">
 * VM Spec: Methods
 * </a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class method_info extends FileComponent implements GenerateTreeNodeClassFile {

    public final u2 access_flags;
    public final u2 name_index;
    public final u2 descriptor_index;
    public final u2 attributes_count;
    public final attribute_info[] attributes;
    private String declaration;
    private String descriptor;
    private String name;

    method_info(final PosDataInputStream posDataInputStream, final cp_info[] cp) throws IOException, FileFormatException {
        this.startPos = posDataInputStream.getPos();
        this.length = -1;

        this.access_flags = new u2(posDataInputStream);
        this.name_index = new u2(posDataInputStream);
        this.descriptor_index = new u2(posDataInputStream);

        this.attributes_count = new u2(posDataInputStream);
        final int attrCount = this.attributes_count.value;
        if (attrCount > 0) {
            this.attributes = new attribute_info[attrCount];
            for (int i = 0; i < attrCount; i++) {
                this.attributes[i] = attribute_info.parse(posDataInputStream, cp);
            }
        } else {
            this.attributes = null;
        }

        this.calculateLength();
        this.parse(cp);
    }

    private void calculateLength() {
        this.length = 8;

        for (int i = 0; i < this.attributes_count.value; i++) {
            this.length += this.attributes[i].getLength();
        }
    }

    /**
     * Get the value of {@code attributes}[{@code index}].
     *
     * @param index Index of the method attribute(s)
     * @return The value of {@code attributes}[{@code index}]
     */
    public attribute_info getAttribute(final int index) {
        attribute_info info = null;
        if (this.attributes != null) {
            info = this.attributes[index];
        }
        return info;
    }

    /**
     * Get the declaration of the field. The declaration is generated by
     * {@code access_flags}, {@code name_index} and {@code descriptor_index}.
     *
     * @return {@code Method} declaration
     */
    public String getDeclaration() {
        return this.declaration;
    }

    /**
     * Get method descriptor.
     *
     * @return Method descriptor
     * @see #name_index
     */
    public String getDescriptor() {
        return this.descriptor;
    }

    /**
     * Generate the modifier of a {@code Method} from the {@code access_flags}
     * value.
     *
     * @return A string for modifier
     */
    public String getModifiers() {
        return AccessFlag.getMethodModifier(this.access_flags.value);
    }

    /**
     * Get method name.
     *
     * @return Method name
     * @see #name_index
     */
    public String getName() {
        return this.name;
    }

    /**
     * Set the declaration string.
     */
    private void parse(final cp_info[] cpInfo) throws FileFormatException {
        this.descriptor = ClassFile.getConstantUtf8Value(this.descriptor_index.value, cpInfo);
        this.name = ClassFile.getConstantUtf8Value(this.name_index.value, cpInfo);

        //
        String returnType;
        String parameters;

        try {
            returnType = SignatureConvertor.methodReturnTypeExtractor(this.descriptor).toString();
        } catch (FileFormatException se) {
            returnType = String.format("[Unexpected method return type: %s]", this.descriptor);
        }
        try {
            parameters = SignatureConvertor.methodParameters2Readable(this.descriptor);
        } catch (FileFormatException se) {
            parameters = String.format("[Unexpected method parameters: %s]", this.descriptor);
        }

        this.declaration = String.format("%s %s %s %s",
                this.getModifiers(), returnType, this.name, parameters);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        final ClassFile classFile = (ClassFile)fileFormat;
        final int floatPos = this.getStartPos();
        int cpIndex;

        this.addNode(parentNode,
                floatPos,
                u2.LENGTH,
                FIELD_ACCESS_FLAGS,
                BytesTool.getBinaryString(this.access_flags.value) + " " + this.getModifiers(),
                "msg_method_info__access_flags",
                Icons.AccessFlag
        );

        cpIndex = this.name_index.value;
        this.addNode(parentNode,
                floatPos + 2,
                u2.LENGTH,
                "name_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "method name", classFile.getCPDescription(cpIndex)),
                "msg_method_info__name_index",
                Icons.Name
        );


        cpIndex = this.descriptor_index.value;
        this.addNode(parentNode,
                floatPos + 4,
                u2.LENGTH,
                "descriptor_index",
                String.format(TEXT_CPINDEX_VALUE, cpIndex, "method descriptor", classFile.getCPDescription(cpIndex)),
                "msg_method_info__descriptor_index",
                Icons.Descriptor
        );

        final int attributesCount = this.attributes_count.value;
        this.addNode(parentNode,
                floatPos + 6,
                u2.LENGTH,
                FIELD_ATTR_COUNT,
                attributesCount,
                "msg_method_info__attributes_count",
                Icons.Counter
        );

        if (attributesCount > 0) {
            final attribute_info lastAttr = this.getAttribute(attributesCount - 1);
            final DefaultMutableTreeNode treeNodeAttr = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    floatPos + 8,
                    lastAttr.getStartPos() + lastAttr.getLength() - floatPos - 8,
                    String.format(FIELD_ATTRS, attributesCount),
                    MESSAGES.getString("msg_method_info__attributes")
            ));

            DefaultMutableTreeNode treeNodeAttrItem;
            attribute_info attr;
            for (int i = 0; i < attributesCount; i++) {
                attr = this.getAttribute(i);
                treeNodeAttrItem = this.addNode(treeNodeAttr,
                        attr.getStartPos(),
                        attr.getLength(),
                        String.valueOf(i + 1),
                        attr.getName(),
                        attr.getMessageKey(),
                        Icons.Annotations
                );
                attr.generateTreeNodeCommon(treeNodeAttrItem, classFile);
            }
            parentNode.add(treeNodeAttr);
        }
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/package.html`:

```html
<html>
    <head>
        <!--
        
          @(#)package.html    April 11, 2009
        
        -->
    </head>
    <body>

        Parse a Java class file Byte Array, and provides a serious of friendly
        classes to get information from the parsed class file.


        <h2>Package Specification</h2>

        We start to use this package by constructing a
        {@link org.binaryinternals.format.classfile.ClassFile} object from
        a byte java class byte array:

        <pre>
    byte[] classByteArray = ...
    ClassFile classfile = new ClassFile(classByteArray)
        </pre>

        and then, we can get various information from the class file:

        <pre>
    String modifiers = classfile.getModifiers();
    cp_info[] cp = classfile.constant_pool;
    u2 fieldsCount = classfile.fields_count.value;
    field_info[] fields = classfile.field_info;
    u2 methodsCount = classfile.methods_count.value;
    method_info[] methods = classfile.methods;
    ...
        </pre>

        <h2>Related Documentation</h2>

        For overviews, tutorials, examples, guides, and tool documentation, please see:
        <ul>
            <li><a href="https://github.com/amosshi/binaryinternals">https://github.com/amosshi/binaryinternals</a>
            <li><a href="http://docs.oracle.com/javase/specs/">Java Language and Virtual Machine Specifications</a>
        </ul>

        <!-- Put @see and @since tags down here. -->
        @see org.binaryinternals.format.classfile.ClassFile
        @author Amos Shi

    </body>
</html>


```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/u1.java`:

```java
/*
 * u1.java    4:21 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * An unsigned one-byte quantity.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressFBWarnings(value="NM_CLASS_NAMING_CONVENTION", justification="Use the type name from JVM Spec")
@SuppressWarnings("java:S101")
public class u1 {

    /**
     * Length of the {@link u1} component.
     */
    public static final int LENGTH = 1;

    /**
     * Value of the {@link u1} component.
     */
    public final short value;

    public u1(short value) {
        this.value = value;
    }

    public u1(final PosDataInputStream posDataInputStream) throws IOException {
        this.value = posDataInputStream.readByte();
    }

    public u1(final PosDataInputStream posDataInputStream, boolean unsigned) throws IOException {
        if (unsigned) {
            this.value = (short) posDataInputStream.readUnsignedByte();
        } else {
            this.value = posDataInputStream.readByte();
        }
    }

    /**
     * Return the {@link #value} as <code>int</code>.
     *
     * @return The {@link #value} as <code>int</code>
     */
    public int intValue() {
        return this.value;
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/u2.java`:

```java
/*
 * u2.java    3:32 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * An unsigned two-byte quantity.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressFBWarnings(value="NM_CLASS_NAMING_CONVENTION", justification="Use the type name from JVM Spec")
@SuppressWarnings("java:S101")
public class u2 {

    /**
     * Length of the {@link u2} component.
     */
    public static final int LENGTH = 2;

    /**
     * Value of the {@link u2} component.
     */
    public final int value;

    public u2(final PosDataInputStream posDataInputStream) throws IOException {
        this.value = posDataInputStream.readUnsignedShort();
    }
}

```

`FormatCLASS/src/main/java/org/binaryinternals/format/classfile/u4.java`:

```java
/*
 * u4.java    3:29 AM, August 5, 2007
 *
 * Copyright  2007, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.classfile;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * An unsigned four-byte quantity.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from JVM Spec instead
 * </pre>
 */
@SuppressFBWarnings(value="NM_CLASS_NAMING_CONVENTION", justification="Use the type name from JVM Spec")
@SuppressWarnings("java:S101")
public class u4 {

    /**
     * Length of the {@link u4} component.
     */
    public static final int LENGTH = 4;

    /**
     * Value of the {@link u4} component.
     */
    public final int value;

    public u4(final PosDataInputStream posDataInputStream) throws IOException {
        value = posDataInputStream.readInt();
    }
}

```

`FormatCLASS/src/main/java/overview.html`:

```html
<!DOCTYPE html>
<html>
<head>
<!--

  @(#)package.html    April 11, 2009

  Copyright  2009, BinaryInternals.org. All rights reserved.
  Use is subject to license terms.

-->
</head>
<body>

This document is the API specification for JVM 8 of the Java Class File Library.

<h2>Related Documentation</h2>

<ul>
  <li><a href="https://github.com/amosshi/binaryinternals/">https://github.com/amosshi/binaryinternals/</a>
  <li><a href="https://docs.oracle.com/javase/specs/">Java Language and Virtual Machine Specifications</a>
  <li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/">The Java Language Specification, Java SE 8 Edition</a>
</ul>

<!-- Put @see and @since tags down here. -->
@see org.binaryinternals.classfile.core.ClassFile
@see org.binaryinternals.classfile.ui.JSplitPaneClassFile
@see org.binaryinternals.classfile.ui.JTreeZipFile
@author Amos Shi

</body>
</html>


```

`FormatCLASS/src/main/resources/org/binaryinternals/format/classfile/MessagesBundle.properties`:

```properties
# Copyright 2021 Binary Internals.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

msg_magic = The magic item supplies the magic number identifying the <code>class</code> file format; it has the value <code>0xCAFEBABE</code>.
msg_version = The values of the <code>minor_version</code> and <code>major_version</code> items are the minor and major version numbers of this <code>class</code> file. Together, a major and a minor version number determine the version of the <code>class</code> file format. If a <code>class</code> file has major version number <code>M</code> and minor version number <code>m</code>, we denote the version of its class file format as <code>M.m</code>.
msg_constant_pool_count = The value of the <code>constant_pool_count</code> item is equal to the number of entries in the <code>constant_pool</code> table plus one. A <code>constant_pool</code> index is considered valid if it is greater than zero and less than <code>constant_pool_count</code>, with the exception for constants of type <code>long</code> and <code>double</code>.
msg_constant_pool_table = The <code>constant_pool</code> is a table of structures representing various string constants, class and interface names, field names, and other constants that are referred to within the <code>ClassFile</code> structure and its substructures. The format of each <code>constant_pool</code> table entry is indicated by its first "<code>tag</code>" byte.<br/><br/>The <code>constant_pool</code> table is indexed from <code>1</code> to <code>constant_pool_count - 1</code>.
msg_cp_tag = A 1-byte <code>tag</code> indicating the kind of constant denoted by the entry.
msg_cp_empty = All 8-byte constants take up two entries in the <code>constant_pool</code> table of the class file. If a <code>CONSTANT_Long_info</code> or <code>CONSTANT_Double_info</code> structure is the entry at index <code>n</code> in the <code>constant_pool</code> table, then the next usable entry in the table is located at index <code>n+2</code>. The <code>constant_pool</code> index <code>n+1</code> must be valid but is considered unusable.<br/><br/>In retrospect, making 8-byte constants take two constant pool entries was a poor choice.
msg_access_flags = The value of the <code>access_flags</code> item is a mask of flags used to denote access permissions to and properties of this class or interface.
msg_this_class = The value of the <code>this_class</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the <code>class</code> or <code>interface</code> defined by this <code>class</code> file.
msg_super_class = For a class, the value of the <code>super_class</code> item either must be <code>zero</code> or must be a valid index into the <code>constant_pool</code> table. If the value of the <code>super_class</code> item is <code>nonzero</code>, the <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the direct superclass of the class defined by this <code>class</code> file. Neither the direct superclass nor any of its superclasses may have the <code>ACC_FINAL</code> flag set in the <code>access_flags</code> item of its <code>ClassFile</code> structure.<br/><br/> If the value of the <code>super_class</code> item is <code>zero</code>, then this <code>class</code> file must represent the class <code>Object</code>, the only class or interface without a direct superclass.<br/><br/>For an interface, the value of the <code>super_class</code> item must always be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the class <code>Object</code>.

msg_interfaces_count = The value of the <code>interfaces_count</code> item gives the number of direct <code>super interfaces</code> of this class or interface type.
msg_interfaces_table = Each value in the <code>interfaces</code> array must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at each value of <code>interfaces[i]</code>, where <code>0 \u2264 i < interfaces_count</code>, must be a <code>CONSTANT_Class_info</code> structure representing an interface that is a direct super interface of this class or interface type, in the left-to-right order given in the source for the type.
msg_interfaces_item = Interface name
msg_fields_count = The value of the <code>fields_count</code> item gives the number of <code>field_info</code> structures in the <code>fields</code> table. The <code>field_info</code> structures represent all fields, both class variables and instance variables, declared by this class or interface type.
msg_fields_table = Each value in the <code>fields</code> table must be a <code>field_info</code> structure giving a complete description of a field in this class or interface. The <code>fields</code> table includes only those fields that are declared by this class or interface. It does not include items representing fields that are inherited from superclasses or super interfaces.
msg_methods_count = The value of the <code>methods_count</code> item gives the number of <code>method_info</code> structures in the <code>methods</code> table.
msg_methods_table =  Each value in the <code>methods</code> table must be a <code>method_info</code> structure giving a complete description of a method in this class or interface. If neither of the <code>ACC_NATIVE</code> and <code>ACC_ABSTRACT</code> flags are set in the <code>access_flags</code> item of a <code>method_info</code> structure, the Java Virtual Machine instructions implementing the method are also supplied.<br/><br/>The <code>method_info</code> structures represent all methods declared by this class or interface type, including instance methods, class methods, instance initialization methods, and any class or interface initialization method. The methods table does not include items representing methods that are inherited from super classes or super interfaces.
msg_attributes_count = The value of the <code>attributes_count</code> item gives the number of attributes in the <code>attributes</code> table of this class.
msg_attributes_table =  Each value of the <code>attributes</code> table must be an <code>attribute_info</code> structure.

# 4.4. The Constant Pool

msg_const_class =  The <code>CONSTANT_Class_info</code> structure is used to represent a class or an interface.
msg_const_class_name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid binary class or interface name encoded in internal form.

msg_const_ref = Fields, methods, and interface methods are represented by similar structures as current.
msg_const_ref_class_index =  The value of the class_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class or interface type that has the field or method as a member.
msg_const_ref_name_and_type_index =  The value of the name_and_type_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_NameAndType_info</code> structure. This <code>constant_pool</code> entry indicates the name and descriptor of the field or method.

msg_const_string = The CONSTANT_String_info structure is used to represent constant objects of the type String.
msg_const_string_string_index = The value of the string_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing the sequence of Unicode code points to which the String object is to be initialized.

msg_const_intfloat = The CONSTANT_Integer_info and CONSTANT_Float_info structures represent 4-byte numeric (int and float) constants.
msg_const_int_bytes = The bytes item of the <code>CONSTANT_Integer_info</code> structure represents the value of the int constant. The bytes of the value are stored in big-endian (high byte first) order.
msg_const_float_bytes = The bytes item of the <code>CONSTANT_Float_info</code> structure represents the value of the float constant in IEEE 754 binary32 floating-point format. The bytes of the item are stored in big-endian (high byte first) order.

msg_const_longdouble = The CONSTANT_Long_info and CONSTANT_Double_info represent 8-byte numeric (long and double) constants.
msg_const_long_bytes = The unsigned high_bytes and low_bytes items of the <code>CONSTANT_Long_info</code> structure together represent the value of the long constant, where the bytes of each of <code>high_bytes</code> and <code>low_bytes</code> are stored in big-endian (high byte first) order.
msg_const_double_bytes = The high_bytes and low_bytes items of the <code>CONSTANT_Double_info</code> structure together represent the double value in IEEE 754 binary64 floating-point format. The bytes of each item are stored in big-endian (high byte first) order.

msg_const_nameandtype = The CONSTANT_NameAndType_info structure is used to represent a field or method, without indicating which class or interface type it belongs to.
msg_const_nameandtype_name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing either a valid unqualified name denoting a field or method, or the special method name <init>.
msg_const_nameandtype_descriptor_index = The value of the descriptor_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid field descriptor or method descriptor.

msg_const_utf8 = The <code>CONSTANT_Utf8_info_pool</code> structure is used to represent constant string values.
msg_const_utf8_length = The value of the length item gives the number of bytes in the bytes array (not the length of the resulting string).
msg_const_utf8_bytes = The bytes array contains the bytes of the string.<br/><br/>String content is encoded in modified UTF-8. Modified UTF-8 strings are encoded so that code point sequences that contain only non-null ASCII characters can be represented using only 1 byte per code point, but all code points in the Unicode codespace can be represented. Modified UTF-8 strings are not null-terminated.

msg_const_methodhandle = The CONSTANT_MethodHandle_info structure is used to represent a method handle.
msg_const_methodhandle_reference_kind = The value of the reference_kind item must be in the range 1 to 9. The value denotes the kind of this method handle, which characterizes its bytecode behavior.
msg_const_methodhandle_reference_index = The value of the reference_index item must be a valid index into the <code>constant_pool</code> table.

msg_const_methodtype = The CONSTANT_MethodType_info structure is used to represent a method type.
msg_const_methodtype_descriptor_index = The value of the descriptor_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a method descriptor.

msg_const_dynamic = Most structures in the <code>constant_pool</code> table represent entities directly, by combining names, descriptors, and values recorded statically in the table. In contrast, the CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info structures represent entities indirectly, by pointing to code which computes an entity dynamically. The code, called a bootstrap method, is invoked by the Java Virtual Machine during resolution of symbolic references derived from these structures. Each structure specifies a bootstrap method as well as an auxiliary name and type that characterize the entity to be computed.
msg_const_dynamic_bootstrap_method_attr_index = The value of the bootstrap_method_attr_index item must be a valid index into the bootstrap_methods array of the bootstrap method table of this class file.
msg_const_dynamic_name_and_type_index =  The value of the name_and_type_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_NameAndType_info</code> structure. This <code>constant_pool</code> entry indicates a name and descriptor.

msg_const_module = The CONSTANT_Module_info structure is used to represent a module.
msg_const_module_name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid module name.

msg_const_package = The <code>CONSTANT_Package_info</code> structure is used to represent a package exported or opened by a module.
msg_const_package_name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid package name encoded in internal form.

# 4.5. Fields

msg_field_info =  Each field is described by a field_info structure.<br/><br/> No two fields in one class file may have the same name and descriptor.
msg_field_info__access_flags = The value of the access_flags item is a mask of flags used to denote access permission to and properties of this field.
msg_field_info__name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure which represents a valid unqualified name denoting a field.
msg_field_info__descriptor_index = The value of the descriptor_index item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure which represents a valid field descriptor.
msg_field_info__attributes_count = The value of the attributes_count item indicates the number of additional attributes of this field.
msg_field_info__attributes = Each value of the attributes table must be an attribute_info structure.<br/><br/> A field can have any number of optional attributes associated with it.

# 4.6. Methods

msg_method_info = Each method, including each instance initialization method and the class or interface initialization method , is described by a <code>method_info</code> structure.<br/><br/> No two methods in one class file may have the same name and descriptor.
msg_method_info__access_flags = The value of the access_flags item is a mask of flags used to denote access permission to and properties of this method.
msg_method_info__name_index = The value of the name_index item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing either a valid unqualified name denoting a method, or (if this method is in a class rather than an interface) the special method name &ltinit&gt, or the special method name &ltclinit&gt.
msg_method_info__descriptor_index = The value of the descriptor_index item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid method descriptor.
msg_method_info__attributes_count = The value of the attributes_count item indicates the number of additional attributes of this method.
msg_method_info__attributes = Each value of the attributes table must be an <code>attribute_info</code> structure. A method can have any number of optional attributes associated with it.

# 4.7. Attributes

msg_attribute_info__attribute_name_index = For all attributes, the attribute_name_index item must be a valid unsigned 16-bit index into the constant pool of the class. The <code>constant_pool</code> entry at attribute_name_index must be a <code>CONSTANT_Utf8_info</code> structure representing the name of the attribute.
msg_attribute_info__attribute_length = The value of the attribute_length item indicates the length of the subsequent information in bytes. The length does not include the initial six bytes that contain the <code>attribute_name_index</code> and <code>attribute_length</code> items.


# 4.7.2. The ConstantValue Attribute

msg_attr_ConstantValue = The <code>ConstantValue</code> attribute is a fixed-length attribute in the attributes table of a <code>field_info</code> structure. A <code>ConstantValue</code> attribute represents the value of a constant expression.
msg_attr_ConstantValue__constantvalue_index = The value of the <code>constantvalue_index</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index gives the value represented by this attribute. The <code>constant_pool</code> entry must be of a type appropriate to the field.

# 4.7.3. The Code Attribute

msg_attr_Code = The <code>Code</code> attribute is a variable-length attribute in the attributes table of a <code>method_info</code> structure. A <code>Code</code> attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance initialization method and a class or interface initialization method.
msg_attr_Code__max_stack = The value of the <code>max_stack</code> item gives the maximum depth of the operand stack of this method at any point during execution of the method.
msg_attr_Code__max_locals = The value of the <code>max_locals</code> item gives the number of local variables in the local variable array allocated upon invocation of this method, including the local variables used to pass parameters to the method on its invocation.<br/><br/>The greatest local variable index for a value of type long or double is <code>max_locals - 2</code>. The greatest local variable index for a value of any other type is <code>max_locals - 1</code>.
msg_attr_Code__code_length = The value of the <code>code_length</code> item gives the number of bytes in the code array for this method.<br/><br/>The value of code_length must be greater than zero (as the code array must not be empty) and less than 65536.
msg_attr_Code__code = The code array gives the actual bytes of Java Virtual Machine code that implement the method.<br/><br/>When the code array is read into memory on a byte-addressable machine, if the first byte of the array is aligned on a 4-byte boundary, the tableswitch and lookupswitch 32-bit offsets will be 4-byte aligned. (Refer to the descriptions of those instructions for more information on the consequences of code array alignment.)<br/><br/>The detailed constraints on the contents of the code array are extensive and are given in a separate section.
msg_attr_exception_table_length = The value of the <code>exception_table_length</code> item gives the number of entries in the <code>exception_table</code> array.
msg_attr_exception_table = Each entry in the <code>exception_table</code> array describes one exception handler in the code array. The order of the handlers in the <code>exception_table</code> array is significant.
msg_attr_exception_table__start_end_pc = The values of the two items <code>start_pc</code> and <code>end_pc</code> indicate the ranges in the code array at which the exception handler is active.<br/><br/>The value of <code>start_pc</code> must be a valid index into the code array of the opcode of an instruction. <br/><br/>The value of <code>end_pc</code> either must be a valid index into the code array of the opcode of an instruction or must be equal to code_length, the length of the code array.<br/><br/>The value of <code>start_pc</code> must be less than the value of <code>end_pc</code>.<br/><br/>The <code>start_pc</code> is inclusive and <code>end_pc</code> is exclusive; that is, the exception handler must be active while the program counter is within the interval <code>[start_pc, end_pc)</code>.
msg_attr_exception_table__handler_pc = The value of the <code>handler_pc</code> item indicates the start of the exception handler. The value of the item must be a valid index into the code array and must be the index of the opcode of an instruction.
msg_attr_exception_table__catch_type = If the value of the <code>catch_type</code> item is <code>nonzero</code>, it must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class of exceptions that this exception handler is designated to catch.<br/><br/>The exception handler will be called only if the thrown exception is an instance of the given class or one of its subclasses.<br/><br/>If the value of the catch_type item is <code>zero</code>, this exception handler is called for all exceptions.
msg_attr_Code_attributes_count = The value of the <code>attributes_count</code> item indicates the number of attributes of the Code attribute.
msg_attr_Code_attributes = Each value of the attributes table must be an <code>attribute_info</code> structure. <br/><br/>A Code attribute can have any number of optional attributes associated with it.

# 4.7.4. The StackMapTable Attribute

msg_attr_StackMapTable = The <code>StackMapTable</code> attribute is a variable-length attribute in the attributes table of a <code>Code</code> attribute.<br/><br/>A <code>StackMapTable</code> attribute is used during the process of verification by type checking.<br/><br/>There may be at most one <code>StackMapTable</code> attribute in the attributes table of a <code>Code</code> attribute.
msg_attr_StackMapTable__number_of_entries = The value of the <code>number_of_entries</code> item gives the number of <code>stack_map_frame</code> entries in the <code>entries</code> table.
msg_attr_StackMapTable__entries = Each entry in the entries table describes one stack map frame of the method. The order of the stack map frames in the entries table is significant.
msg_attr_stack_map_frame__frame_type = Indicates the frame type of the stack map frame
msg_attr_stack_map_frame__all__offset_delta = The offset_delta value for the frame is given explicitly.

msg_attr_stack__same_frame = The frame type <code>same_frame</code> is represented by tags in the range <code>[0-63]</code>. This frame type indicates that the frame has exactly the same local variables as the previous frame and that the operand stack is empty. The <code>offset_delta</code> value for the frame is the value of the tag item, <code>frame_type</code>.
msg_attr_stack__same_locals_1_stack_item_frame = The frame type <code>same_locals_1_stack_item_frame</code> is represented by tags in the range <code>[64, 127]</code>. This frame type indicates that the frame has exactly the same local variables as the previous frame and that the operand stack has one entry.<br/><br/>The <code>offset_delta</code> value for the frame is given by the formula <code>frame_type - 64</code>.<br/><br/>The verification type of the one stack entry appears after the frame type.
msg_attr_stack__reserved = Tags in the range <code>[128-246]</code> are reserved for future use.
msg_attr_stack__same_locals_1_stack_item_frame_extended = The frame type <code>same_locals_1_stack_item_frame_extended</code> is represented by the tag <code>247</code>. This frame type indicates that the frame has exactly the same local variables as the previous frame and that the operand stack has one entry.<br/><br/>The <code>offset_delta</code> value for the frame is given explicitly, unlike in the frame type <code>same_locals_1_stack_item_frame</code>.<br/><br/>The verification type of the one stack entry appears after offset_delta.
msg_attr_stack__chop_frame = The frame type <code>chop_frame</code> is represented by tags in the range <code>[248-250]</code>. This frame type indicates that the frame has the same local variables as the previous frame except that the last k local variables are absent, and that the operand stack is empty.
msg_attr_stack__same_frame_extended = The frame type <code>same_frame_extended</code> is represented by the tag <code>251</code>. This frame type indicates that the frame has exactly the same local variables as the previous frame and that the operand stack is empty.
msg_attr_stack__append_frame = The frame type <code>append_frame</code> is represented by tags in the range <code>[252-254]</code>. This frame type indicates that the frame has the same locals as the previous frame except that k additional locals are defined, and that the operand stack is empty.
msg_attr_stack__append_frame__locals = The <code>0th</code> entry in locals represents the verification type of the first additional local variable. If <code>locals[M]</code> represents local variable <code>N</code>, then:<br/><br/>- <code>locals[M+1]</code> represents local variable <code>N+1</code> if <code>locals[M]</code> is one of <code>Top_variable_info</code>, <code>Integer_variable_info</code>, <code>Float_variable_info</code>, <code>Null_variable_info</code>, <code>UninitializedThis_variable_info</code>, <code>Object_variable_info</code>, or <code>Uninitialized_variable_info</code>; and<br/>- <code>locals[M+1]</code> represents local variable <code>N+2</code> if <code>locals[M]</code> is either <code>Long_variable_info</code> or <code>Double_variable_info</code>.<br/><br/>It is an error if, for any index <code>i</code>, <code>locals[i]</code> represents a local variable whose index is greater than the maximum number of local variables for the method.
msg_attr_stack__full_frame = The frame type <code>full_frame</code> is represented by the tag <code>255</code>.
msg_attr_stack__full_frame__number_of_locals = Number of records in the <code>locals</code> array
msg_attr_stack__full_frame__locals = The <code>0th</code> entry in locals represents the verification type of local variable <code>0</code>. If <code>locals[M]</code> represents local variable <code>N</code>, then:<br/><br/>- <code>locals[M+1]</code> represents local variable <code>N+1</code> if <code>locals[M]</code> is one of <code>Top_variable_info</code>, <code>Top_variable_info</code>Top_variable_info, <code>Top_variable_info</code>Top_variable_info, <code>Null_variable_info</code>, <code>UninitializedThis_variable_info</code>, <code>Object_variable_info</code>, or <code>Uninitialized_variable_info</code>; and<br/>- <code>locals[M+1]</code> represents local variable <code>N+2</code> if <code>locals[M]</code> is either <code>Long_variable_info</code> or <code>Double_variable_info</code>.<br/><br/>It is an error if, for any index <code>i</code>, <code>locals[i]</code> represents a local variable whose index is greater than the maximum number of local variables for the method.
msg_attr_stack__full_frame__number_of_stack_items = Number of records in the <code>stack</code> array
msg_attr_stack__full_frame__stack = The <code>0th</code> entry in stack represents the verification type of the bottom of the operand stack, and subsequent entries in stack represent the verification types of stack entries closer to the top of the operand stack. We refer to the bottom of the operand stack as stack entry <code>0</code>, and to subsequent entries of the operand stack as stack entry <code>1</code>, <code>2</code>, etc. If <code>stack[M]</code> represents stack entry <code>N</code>, then:<br/><br/>- <code>stack[M+1]</code> represents stack entry <code>N+1</code> if <code>stack[M]</code> is one of <code>Top_variable_info</code>, <code>Integer_variable_info</code>, <code>Float_variable_info</code>, <code>Null_variable_info</code>, <code>UninitializedThis_variable_info</code>, <code>Object_variable_info</code>, or <code>Uninitialized_variable_info</code>; and<br/>- <code>stack[M+1]</code> represents stack entry <code>N+2</code> if <code>stack[M]</code> is either <code>Long_variable_info</code> or <code>Double_variable_info</code>.<br/><br/>It is an error if, for any index <code>i</code>, <code>stack[i]</code> represents a stack entry whose index is greater than the maximum operand stack size for the method.

msg_attr_verification_type_info = A verification type specifies the type of either one or two locations, where a location is either a single local variable or a single operand stack entry.<br /><br />A verification type is represented by a discriminated union, <code>verification_type_info</code>, that consists of a one-byte <code>tag</code>, indicating which item of the union is in use, followed by zero or more bytes, giving more information about the <code>tag</code>.
msg_attr_verification_type_info__tag = The tag indicates the frame type of the stack map frame
msg_attr_verification_type_info__cpool_index = The <code>Object_variable_info</code> item indicates that the location has the verification type which is the class represented by the <code>CONSTANT_Class_info</code> structure found in the <code>constant_pool</code> table at the index given by <code>cpool_index</code>.
msg_attr_verification_type_info__offset = The Offset item indicates the offset, in the code array of the Code attribute that contains this <code>StackMapTable</code> attribute, of the <code>new</code> instruction that created the object being stored in the location.

# 4.7.5. The Exceptions Attribute

msg_attr_Exceptions = The <code>Exceptions</code> attribute is a variable-length attribute in the attributes table of a <code>method_info</code> structure. The <code>Exceptions</code> attribute indicates which checked exceptions a method may throw.<br/><br/>There may be at most one Exceptions attribute in the attributes table of a <code>method_info</code> structure.
msg_attr_Exceptions__number_of_exceptions = The value of the <code>number_of_exceptions</code> item indicates the number of entries in the <code>exception_index_table</code>.
msg_attr_Exceptions__exception_index_table = Each value in the <code>exception_index_table</code> array must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> table entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class type that this method is declared to throw.

# 4.7.6. The InnerClasses Attribute

msg_attr_InnerClasses =  The <code>InnerClasses</code> attribute is a variable-length attribute in the attributes table of a <code>ClassFile</code> structure.<br/><br/>If the constant pool of a class or interface <code>C</code> contains at least one <code>CONSTANT_Class_info entry</code> which represents a class or interface that is not a member of a package, then there must be exactly one <code>InnerClasses</code> attribute in the <code>attributes</code> table of the <code>ClassFile</code> structure for <code>C</code>.
msg_attr_InnerClasses__number_of_classes = The value of the <code>number_of_classes</code> item indicates the number of entries in the <code>classes</code> array.
msg_attr_classes = Every <code>CONSTANT_Class_info</code> entry in the <code>constant_pool</code> table which represents a class or interface <code>C</code> that is not a package member must have exactly one corresponding entry in the <code>classes</code> array.
msg_attr_classes__inner_class_info_index = The value of the <code>inner_class_info_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing <code>C</code>.
msg_attr_classes__outer_class_info_index = If <code>C</code> is not a member of a class or an interface - that is, if <code>C</code> is a top-level class or interface or a local class or an anonymous class - then the value of the <code>outer_class_info_index</code> item must be zero.<br/><br/>Otherwise, the value of the <code>outer_class_info_index</code> item must be a valid index into the <code>constant_pool</code> table, and the entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the class or interface of which <code>C</code> is a member.<br /><br />The value of the <code>outer_class_info_index</code> item must not equal the the value of the <code>inner_class_info_index</code> item.
msg_attr_classes__inner_name_index =  If <code>C</code> is anonymous, the value of <code>inner_name_index</code> the item must be zero.<br/><br/>Otherwise, the value of the <code>inner_name_index</code> item must be a valid index into the <code>constant_pool</code> table, and the entry at that index must be a <code>CONSTANT_Utf8_info</code> structure that represents the original simple name of <code>C</code>, as given in the source code from which this class file was compiled.
msg_attr_classes__inner_class_access_flags = The value of the <code>inner_class_access_flags</code> item is a mask of flags used to denote access permissions to and properties of class or interface <code>C</code> as declared in the source code from which this class file was compiled.<br/><br/>It is used by a compiler to recover the original information when source code is not available.

# 4.7.7. The EnclosingMethod Attribute

msg_attr_EnclosingMethod = The <code>EnclosingMethod</code> attribute is a fixed-length attribute in the attributes table of a <code>ClassFile</code> structure.<br/><br/>A class must have an <code>EnclosingMethod</code> attribute if and only if it represents a local class or an anonymous class.<br/><br/>There may be at most one <code>EnclosingMethod</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_EnclosingMethod__class_index = The value of the <code>class_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the innermost class that encloses the declaration of the current class.
msg_attr_EnclosingMethod__method_index = If the current class is not immediately enclosed by a method or constructor, then the value of the <code>method_index</code> item must be zero. <br/><br/> Otherwise, the value of the <code>method_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_NameAndType_info</code> structure representing the name and type of a method in the class referenced by the <code>class_index</code> attribute above.

# 4.7.8. The Synthetic Attribute

msg_attr_Synthetic = The <code>Synthetic</code> attribute is a fixed-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, or <code>method_info</code> structure.<br/><br/>A class member that does not appear in the source code must be marked using a <code>Synthetic</code> attribute, or else it must have its <code>ACC_SYNTHETIC</code> flag set.<br/><br/>The only exceptions to this requirement are compiler-generated members which are not considered implementation artifacts, namely:<br/><br/>* an instance initialization method representing a default constructor of the Java programming language<br/>* a class or interface initialization method<br/>* the implicitly declared members of enum and record classes<br/>

# 4.7.9. The Signature Attribute

msg_attr_Signature = The <code>Signature</code> attribute is a fixed-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.<br/><br/>A <code>Signature</code> attribute stores a signature for a class, interface, constructor, method, field, or record component whose declaration in the Java programming language uses type variables or parameterized types.<br/><br/> There may be at most one <code>Signature</code> attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.
msg_attr_Signature__signature_index = The value of the <code>signature_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/> The <code>constant_pool</code> entry at that index must be a The <code>CONSTANT_Utf8_info</code> structure representing a class signature if this Signature attribute is an attribute of a <code>ClassFile</code> structure; a method signature if this Signature attribute is an attribute of a <code>method_info</code> structure; or a field signature otherwise.

# 4.7.10. The SourceFile Attribute

msg_attr_SourceFile = The <code>SourceFile</code> attribute is an optional fixed-length attribute in the attributes table of a <code>ClassFile</code> structure. <br/><br/>There may be at most one <code>SourceFile</code> attribute in the attributes table of a <code>ClassFile</code> structure.
msg_attr_SourceFile__sourcefile_index = The value of the <code>sourcefile_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a string.

# 4.7.11. The SourceDebugExtension Attribute

msg_attr_SourceDebugExtension = The <code>SourceDebugExtension</code> attribute is an optional attribute in the attributes table of a <code>ClassFile</code> structure.<br/><br/>There may be at most one <code>SourceDebugExtension</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_SourceDebugExtension__debug_extension = The <code>debug_extension</code> array holds extended debugging information which has no semantic effect on the Java Virtual Machine.<br/><br/>The information is represented using a modified UTF-8 string with no terminating zero byte.

# 4.7.12. The LineNumberTable Attribute

msg_attr_LineNumberTable = The <code>LineNumberTable</code> attribute is an optional variable-length attribute in the attributes table of a <code>Code</code> attribute. It may be used by debuggers to determine which part of the code array corresponds to a given line number in the original source file. <br/><br/>If multiple <code>LineNumberTable</code> attributes are present in the attributes table of a <code>Code</code> attribute, then they may appear in any order. <br/><br/> There may be more than one <code>LineNumberTable</code> attribute per line of a source file in the attributes table of a <code>Code</code> attribute. That is, <code>LineNumberTable</code> attributes may together represent a given line of a source file, and need not be one-to-one with source lines.
msg_attr_line_number_table_length = The value of the <code>line_number_table_length</code> item indicates the number of entries in the <code>line_number_table</code> array.
msg_attr_line_number_table = Each entry in the <code>line_number_table</code> array indicates that the line number in the original source file changes at a given point in the code array.
msg_attr_line_number_table__start_pc = The value of the <code>start_pc</code> item must be a valid index into the code array of this <code>Code</code> attribute. <br/><br/>The item indicates the index into the code array at which the code for a new line in the original source file begins.
msg_attr_line_number_table__line_number = The value of the <code>line_number</code> item gives the corresponding line number in the original source file.

# 4.7.13. The LocalVariableTable Attribute

msg_attr_LocalVariableTable = The <code>LocalVariableTable</code> attribute is an optional variable-length attribute in the attributes table of a <code>Code</code> attribute. <br/><br/>It may be used by debuggers to determine the value of a given local variable during the execution of a method.<br/><br/>If multiple <code>LocalVariableTable</code> attributes are present in the attributes table of a <code>Code</code> attribute, then they may appear in any order.<br/><br/>There may be no more than one <code>LocalVariableTable</code> attribute per local variable in the attributes table of a <code>Code</code> attribute.
msg_attr_local_variable_table_length = The value of the <code>local_variable_table_length</code> item indicates the number of entries in the <code>local_variable_table</code> array.
msg_attr_local_variable_table = Each entry in the <code>local_variable_table</code> array indicates a range of code array offsets within which a local variable has a value, and indicates the index into the local variable array of the current frame at which that local variable can be found.
msg_attr_local_variable_table__start_pc_length = The value of the <code>start_pc</code> item must be a valid index into the code array of this <code>Code</code> attribute and must be the index of the opcode of an instruction.<br/><br/>The value of <code>start_pc</code> + <code>length</code> must either be a valid index into the code array of this <code>Code</code> attribute and be the index of the opcode of an instruction, or it must be the first index beyond the end of that code array.<br/><br/>The <code>start_pc</code> and <code>length</code> items indicate that the given local variable has a value at indices into the code array in the interval <code>[start_pc, start_pc + length)</code>, that is, between <code>start_pc</code> inclusive and <code>start_pc + length</code> exclusive.
msg_attr_local_variable_table__name_index = The value of the <code>name_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must contain a <code>CONSTANT_Utf8_info</code> structure representing a valid unqualified name denoting a local variable.
msg_attr_local_variable_table__descriptor_index = The value of the <code>descriptor_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must contain a <code>CONSTANT_Utf8_info</code> structure representing a field descriptor which encodes the type of a local variable in the source program.
msg_attr_local_variable_table__index = The value of the <code>index</code> item must be a valid index into the local variable array of the current frame. <br/><br/>The given local variable is at <code>index</code> in the local variable array of the current frame.<br/><br/> If the given local variable is of type <code>double</code> or <code>long</code>, it occupies both <code>index</code> and <code>index + 1</code>.

# 4.7.14. The LocalVariableTypeTable Attribute

msg_attr_LocalVariableTypeTable = The <code>LocalVariableTypeTable</code> attribute is an optional variable-length attribute in the attributes table of a <code>Code</code> attribute. It may be used by debuggers to determine the value of a given local variable during the execution of a method.<br/><br/>If multiple <code>LocalVariableTypeTable</code> attributes are present in the attributes table of a given <code>Code</code> attribute, then they may appear in any order.<br/><br/>There may be no more than one <code>LocalVariableTypeTable</code> attribute per local variable in the attributes table of a <code>Code</code> attribute.
msg_attr_local_variable_type_table_length = The value of the <code>local_variable_type_table_length</code> item indicates the number of entries in the <code>local_variable_type_table</code> array.
msg_attr_local_variable_type_table__start_pc_length = The value of the <code>start_pc</code> item must be a valid index into the code array of this <code>Code</code> attribute and must be the index of the opcode of an instruction.<br/><br/>The value of <code>start_pc + length</code> must either be a valid index into the code array of this <code>Code</code> attribute and be the index of the opcode of an instruction, or it must be the first index beyond the end of that code array.<br/><br/>The <code>start_pc</code> and <code>length</code> items indicate that the given local variable has a value at indices into the code array in the interval <code>[start_pc, start_pc + length)</code>, that is, between <code>start_pc</code> inclusive and <code>start_pc + length</code> exclusive.
msg_attr_local_variable_type_table__name_index = The value of the <code>name_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must contain a <code>CONSTANT_Utf8_info</code> structure representing a valid unqualified name denoting a local variable.
msg_attr_local_variable_type_table__signature_index = The value of the <code>signature_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must contain a <code>CONSTANT_Utf8_info</code> structure representing a field signature which encodes the type of a local variable in the source program.
msg_attr_local_variable_type_table__index = The value of the <code>index</code> item must be a valid index into the local variable array of the current frame.<br/><br/>The given local variable is at <code>index</code> in the local variable array of the current frame.<br/><br/>If the given local variable is of type <code>double</code> or <code>long</code>, it occupies both <code>index</code> and <code>index + 1</code>.

# 4.7.15. The Deprecated Attribute

msg_attr_Deprecated = The <code>Deprecated</code> attribute is an optional fixed-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, or <code>method_info</code> structure. <br/><br/>A class, interface, method, or field may be marked using a <code>Deprecated</code> attribute to indicate that the class, interface, method, or field has been superseded.<br/><br/>A run-time interpreter or tool that reads the class file format, such as a compiler, can use this marking to advise the user that a superseded class, interface, method, or field is being referred to. <br/><br/>The presence of a <code>Deprecated</code> attribute does not alter the semantics of a class or interface.

msg_attr_annotation__type_index = The value of the <code>type_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a field descriptor.<br/><br/>The field descriptor denotes the type of the annotation represented by this annotation structure.
msg_attr_annotation__num_element_value_pairs = The value of the <code>num_element_value_pairs</code> item gives the number of element-value pairs of the annotation represented by this annotation structure.
msg_attr_annotation__element_value_pairs = Each value of the <code>element_value_pairs</code> table represents a single element-value pair in the annotation represented by this annotation structure.
msg_attr_annotation__element_value_pairs_element_name_index = The value of the <code>element_name_index</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure. <br/><br/>The <code>constant_pool</code> entry denotes the name of the element of the element-value pair represented by this <code>element_value_pairs</code> entry.
msg_attr_annotation__element_value_pairs_value = The value of the value item represents the value of the element-value pair represented by this <code>element_value_pairs</code> entry.

msg_attr_element_value = The <code>element_value</code> structure is a discriminated union representing the value of an element-value pair.
msg_attr_element_value__tag = The tag item uses a single ASCII character to indicate the type of the value of the element-value pair. This determines which item of the value union is in use.
msg_attr_element_value__const_value_index = The <code>const_value_index</code> item denotes a constant of either a primitive type or the type <code>String</code> as the value of this element-value pair.<br/><br/>The value of the <code>const_value_index</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be of a type appropriate to the <code>tag</code> item.
msg_attr_element_value__enum_const_value = The <code>enum_const_value</code> item denotes an enum constant as the value of this element-value pair.
msg_attr_element_value__enum_const_value__type_name_index =The value of the <code>type_name_index</code> item must be a valid index into the <code>constant_pool</code> table. <br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a field descriptor. <br/><br/>The <code>constant_pool</code> entry gives the internal form of the binary name of the type of the enum constant represented by this <code>element_value</code> structure.
msg_attr_element_value__enum_const_value__const_name_index =The value of the <code>const_name_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure.<br/><br/>The <code>constant_pool</code> entry gives the simple name of the enum constant represented by this <code>element_value</code> structure.
msg_attr_element_value__class_info_index = The <code>class_info_index</code> item denotes a class literal as the value of this element-value pair.<br/><br/>The <code>class_info_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a return descriptor.<br/><br/>The return descriptor gives the type corresponding to the class literal represented by this <code>element_value</code> structure.
msg_attr_element_value__annotation_value = The <code>annotation_value</code> item denotes a "nested" annotation as the value of this element-value pair.<br/><br/>The value of the <code>annotation_value</code> item is an <code>annotation</code> structure that gives the annotation represented by this <code>element_value</code> structure.

msg_attr_element_value__array_value =  The <code>array_value</code> item denotes an array as the value of this element-value pair.
msg_attr_element_value__array_value__num_values = The value of the <code>num_values</code> item gives the number of elements in the array represented by this <code>element_value</code> structure.
msg_attr_element_value__array_value__values = Each value in the values table gives the corresponding element of the array represented by this <code>element_value</code> structure.

# 4.7.16. The RuntimeVisibleAnnotations Attribute

msg_attr_RuntimeVisibleAnnotations = The <code>RuntimeVisibleAnnotations</code> attribute is a variable-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.<br/><br/>The <code>RuntimeVisibleAnnotations</code> attribute stores run-time visible annotations on the declaration of the corresponding class, field, method, or record component.<br/><br/>There may be at most one <code>RuntimeVisibleAnnotations</code> attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.
msg_attr_RuntimeVisibleAnnotations__num_annotations = The value of the <code>num_annotations</code> item gives the number of run-time visible annotations represented by the structure.
msg_attr_RuntimeVisibleAnnotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time visible annotation on a declaration.

# 4.7.17. The RuntimeInvisibleAnnotations Attribute

msg_attr_RuntimeInvisibleAnnotations = The <code>RuntimeInvisibleAnnotations</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.<br/><br/>The <code>RuntimeInvisibleAnnotations</code> attribute stores run-time invisible annotations on the declaration of the corresponding class, method, field, or record component.<br/><br/>There may be at most one RuntimeInvisibleAnnotations attribute in the <code>attributes</code> table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure.
msg_attr_RuntimeInvisibleAnnotations__num_annotations = The value of the <code>num_annotations</code> item gives the number of run-time invisible annotations represented by the structure.
msg_attr_RuntimeInvisibleAnnotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time invisible annotation on a declaration.

# 4.7.18. The RuntimeVisibleParameterAnnotations Attribute

msg_attr_RuntimeVisibleParameterAnnotations = The <code>RuntimeVisibleParameterAnnotations</code> attribute is a variable-length attribute in the attributes table of the <code>method_info</code> structure.<br/><br/>The <code>RuntimeVisibleParameterAnnotations</code> attribute stores run-time visible annotations on the declarations of formal parameters of the corresponding method.<br/><br/>There may be at most one <code>RuntimeVisibleParameterAnnotations</code> attribute in the <code>attributes</code> table of a <code>method_info</code> structure.
msg_attr_RuntimeVisibleParameterAnnotations__num_parameters = The value of the <code>num_parameters</code> item gives the number of run-time visible parameter annotations represented by this structure.<br/><br/>There is no assurance that this number is the same as the number of parameter descriptors in the method descriptor.
msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations = Each entry in the <code>parameter_annotations</code> table represents all of the run-time visible annotations on the declaration of a single formal parameter.
msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations__num_annotations = The value of the <code>num_annotations</code> item indicates the number of run-time visible annotations on the declaration of the formal parameter corresponding to the <code>parameter_annotations</code> entry.
msg_attr_RuntimeVisibleParameterAnnotations_parameter_annotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time visible annotation on the declaration of the formal parameter corresponding to the <code>parameter_annotations</code> entry.

# 4.7.19. The RuntimeInvisibleParameterAnnotations Attribute

msg_attr_RuntimeInvisibleParameterAnnotations = The <code>RuntimeInvisibleParameterAnnotations</code> attribute is a variable-length attribute in the attributes table of a <code>method_info</code> structure. <br/><br/>The <code>RuntimeInvisibleParameterAnnotations</code> attribute stores run-time invisible annotations on the declarations of formal parameters of the corresponding method.<br/><br/>There may be at most one <code>RuntimeInvisibleParameterAnnotations</code> attribute in the <code>attributes</code> table of a <code>method_info</code> structure.
msg_attr_RuntimeInvisibleParameterAnnotations__num_parameters = The value of the <code>num_parameters</code> item gives the number of run-time invisible parameter annotations represented by this structure.<br/><br/>There is no assurance that this number is the same as the number of parameter descriptors in the method descriptor.
msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations = Each entry in the <code>parameter_annotations</code> table represents all of the run-time invisible annotations on the declaration of a single formal parameter.
msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations__num_annotations = The value of the <code>num_annotations</code> item indicates the number of run-time invisible annotations on the declaration of the formal parameter corresponding to the <code>parameter_annotations</code> entry.
msg_attr_RuntimeInvisibleParameterAnnotations_parameter_annotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time invisible annotation on the declaration of the formal parameter corresponding to the <code>parameter_annotations</code> entry.

# 4.7.20. The RuntimeVisibleTypeAnnotations Attribute

msg_attr_RuntimeVisibleTypeAnnotations = The <code>RuntimeVisibleTypeAnnotations</code> attribute is an variable-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure, or <code>Code</code> attribute.<br/><br/>The <code>RuntimeVisibleTypeAnnotations</code> attribute stores run-time visible annotations on types used in the declaration of the corresponding class, field, method, or record component, or in an expression in the corresponding method body. <br/><br/>The <code>RuntimeVisibleTypeAnnotations</code> attribute also stores run-time visible annotations on type parameter declarations of generic classes, interfaces, methods, and constructors.<br/><br/>There may be at most one <code>RuntimeVisibleTypeAnnotations</code> attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure, or <code>Code</code> attribute.<br/><br/>An <code>attributes</code> table contains a <code>RuntimeVisibleTypeAnnotations</code> attribute only if types are annotated in kinds of declaration or expression that correspond to the parent structure or attribute of the <code>attributes</code> table.
msg_attr_RuntimeVisibleTypeAnnotations__num_annotations = The value of the <code>num_annotations</code> item gives the number of run-time visible type annotations represented by the structure.
msg_attr_RuntimeVisibleTypeAnnotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time visible annotation on a type used in a declaration or expression.

# 4.7.21. The RuntimeInvisibleTypeAnnotations Attribute

msg_attr_RuntimeInvisibleTypeAnnotations = The <code>RuntimeInvisibleTypeAnnotations</code> attribute is an variable-length attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure, or <code>Code</code> attribute. <br/><br/>The <code>RuntimeInvisibleTypeAnnotations</code> attribute stores run-time invisible annotations on types used in the corresponding declaration of a class, field, method, or record component, or in an expression in the corresponding method body. <br/><br/>The <code>RuntimeInvisibleTypeAnnotations</code> attribute also stores annotations on type parameter declarations of generic classes, interfaces, methods, and constructors.<br/><br/>There may be at most one <code>RuntimeInvisibleTypeAnnotations</code> attribute in the attributes table of a <code>ClassFile</code>, <code>field_info</code>, <code>method_info</code>, or <code>record_component_info</code> structure, or <code>Code</code> attribute.<br/><br/>An attributes table contains a <code>RuntimeInvisibleTypeAnnotations</code> attribute only if types are annotated in kinds of declaration or expression that correspond to the parent structure or attribute of the <code>attributes</code> table.
msg_attr_RuntimeInvisibleTypeAnnotations__num_annotations = The value of the <code>num_annotations</code> item gives the number of run-time invisible type annotations represented by the structure.
msg_attr_RuntimeInvisibleTypeAnnotations__annotations = Each entry in the <code>annotations</code> table represents a single run-time invisible annotation on a type used in a declaration or expression.

msg_attr_type_annotation__target_type = The value of the <code>target_type</code> item denotes the kind of target on which the annotation appears. The various kinds of target correspond to the <code>type contexts</code> of the Java programming language where types are used in declarations and expressions.<br/><br/>The value of the <code>target_type</code> item determines whether the <code>type_annotation</code> structure appears in a <code>RuntimeVisibleTypeAnnotations</code> attribute in a <code>ClassFile</code> structure, a <code>field_info</code> structure, a <code>method_info</code> structure, or a <code>Code</code> attribute.

# msg_attr_type_annotation__target_info = The value of the <code>target_info</code> item denotes precisely which type in a declaration or expression is annotated.
msg_attr_type_annotation__target_info__type_parameter_target = The <code>type_parameter_target</code> item indicates that an annotation appears on the declaration of the <code>i</code>'th type parameter of a generic class, generic interface, generic method, or generic constructor.
msg_attr_type_annotation__target_info__type_parameter_target__type_parameter_index = The value of the <code>type_parameter_index</code> item specifies which type parameter declaration is annotated.<br/><br/>A <code>type_parameter_index</code> value of <code>0</code> specifies the first type parameter declaration.
msg_attr_type_annotation__target_info__supertype_target = The <code>supertype_target</code> item indicates that an annotation appears on a type in the extends or implements clause of a class or interface declaration.
msg_attr_type_annotation__target_info__supertype_target__supertype_index = A <code>supertype_index</code> value of <code>65535</code> specifies that the annotation appears on the superclass in an extends clause of a class declaration.<br/><br/>Any other <code>supertype_index</code> value is an index into the <code>interfaces</code> array of the enclosing <code>ClassFile</code> structure, and specifies that the annotation appears on that superinterface in either the <code>implements</code> clause of a class declaration or the <code>extends</code> clause of an interface declaration.

msg_attr_type_annotation__target_info__type_parameter_bound_target = The <code>type_parameter_bound_target</code> item indicates that an annotation appears on the <code>i</code>'th bound of the <code>j</code>'th type parameter declaration of a generic class, interface, method, or constructor.
msg_attr_type_annotation__target_info__type_parameter_bound_target__type_parameter_index = The value of the of <code>type_parameter_index</code> item specifies which type parameter declaration has an annotated bound. <br/><br/>A <code>type_parameter_index</code> value of <code>0</code> specifies the first type parameter declaration.
msg_attr_type_annotation__target_info__type_parameter_bound_target__bound_index = The value of the <code>bound_index</code> item specifies which bound of the type parameter declaration indicated by <code>type_parameter_index</code> is annotated. <br/><br/>A <code>bound_index</code> value of <code>0</code> specifies the first bound of a type parameter declaration.

# msg_attr_type_annotation__target_info__empty_target = The <code>empty_target</code> item indicates that an annotation appears on either the type in a field declaration, the type in a record component declaration, the return type of a method, the type of a newly constructed object, or the receiver type of a method or constructor.
msg_attr_type_annotation__target_info__formal_parameter_target = The <code>formal_parameter_target</code> item indicates that an annotation appears on the type in a formal parameter declaration of a method, constructor, or lambda expression.
msg_attr_type_annotation__target_info__formal_parameter_target__formal_parameter_index = The value of the <code>formal_parameter_index</code> item specifies which formal parameter declaration has an annotated type. A <code>formal_parameter_index</code> value of <code>i</code> may, but is not required to, correspond to the <code>i</code>'th parameter descriptor in the method descriptor.

msg_attr_type_annotation__target_info__throws_target = The <code>throws_target</code> item indicates that an annotation appears on the <code>i</code>'th type in the throws clause of a method or constructor declaration.
msg_attr_type_annotation__target_info__throws_target__throws_type_index = The value of the <code>throws_type_index</code> item is an index into the <code>exception_index_table</code> array of the <code>Exceptions</code> attribute of the <code>method_info</code> structure enclosing the <code>RuntimeVisibleTypeAnnotations</code> attribute.

msg_attr_type_annotation__target_info__localvar_target = The <code>localvar_target</code> item indicates that an annotation appears on the type in a local variable declaration, including a variable declared as a resource in a <code>try-with-resources</code> statement.
msg_attr_type_annotation__target_info__localvar_target__table_length = The value of the <code>table_length</code> item gives the number of entries in the <code>table</code> array.
msg_attr_type_annotation__target_info__localvar_target__table = Each entry indicates a range of code array offsets within which a local variable has a value. It also indicates the index into the local variable array of the current frame at which that local variable can be found.
msg_attr_type_annotation__target_info__localvar_target__table__start_pc_length = The given local variable has a value at indices into the code array in the interval <code>[start_pc, start_pc + length)</code>, that is, between <code>start_pc</code> inclusive and <code>start_pc + length</code> exclusive.
msg_attr_type_annotation__target_info__localvar_target__table__index = The given local variable must be at <code>index</code> in the local variable array of the current frame.<br/><br/>If the local variable at <code>index</code> is of type <code>double</code> or <code>long</code>, it occupies both <code>index</code> and <code>index + 1</code>.

msg_attr_type_annotation__target_info__catch_target = The <code>catch_target</code> item indicates that an annotation appears on the <code>i</code>'th type in an exception parameter declaration.
msg_attr_type_annotation__target_info__catch_target__exception_table_index = The value of the <code>exception_table_index</code> item is an index into the <code>exception_table</code> array of the <code>Code</code> attribute enclosing the <code>RuntimeVisibleTypeAnnotations</code> attribute.

msg_attr_type_annotation__target_info__offset_target = The <code>offset_target</code> item indicates that an annotation appears on either the type in an <code>instanceof</code> expression or a <code>new</code> expression, or the type before the <code>::</code> in a method reference expression.
msg_attr_type_annotation__target_info__offset_target__offset = The value of the <code>offset</code> item specifies the code array offset of either the <code>bytecode</code> instruction corresponding to the <code>instanceof</code> expression, the <code>new</code> bytecode instruction corresponding to the <code>new</code> expression, or the <code>bytecode</code> instruction corresponding to the method reference expression.

msg_attr_type_annotation__target_info__type_argument_target = The <code>type_argument_target</code> item indicates that an annotation appears either on the <code>i</code>'th type in a cast expression, or on the <code>i</code>'th type argument in the explicit type argument list for any of the following: a <code>new</code> expression, an explicit constructor invocation statement, a method invocation expression, or a method reference expression.
msg_attr_type_annotation__target_info__type_argument_target__offset = The value of the <code>offset</code> item specifies the code array offset of either<br/> the <code>bytecode</code> instruction corresponding to the cast expression,<br/> the <code>new</code> bytecode instruction corresponding to the <code>new</code> expression,<br/> the bytecode instruction corresponding to the explicit constructor invocation statement,<br/> the bytecode instruction corresponding to the method invocation expression,<br/> or the bytecode instruction corresponding to the method reference expression.
msg_attr_type_annotation__target_info__type_argument_target__type_argument_index = For a cast expression, the value of the <code>type_argument_index</code> item specifies which type in the cast operator is annotated. A <code>type_argument_index</code> value of <code>0</code> specifies the first (or only) type in the cast operator.<br/><br/>The possibility of more than one type in a cast expression arises from a cast to an intersection type.<br/><br/>For an explicit type argument list, the value of the <code>type_argument_index</code> item specifies which type argument is annotated. A <code>type_argument_index</code> value of <code>0</code> specifies the first type argument.

msg_attr_type_annotation__target_path = The value of the <code>target_path</code> item denotes precisely which part of the type indicated by <code>target_info</code> is annotated.
msg_attr_type_annotation__type_index__num_element_value_pairs__element_value_pairs = The meaning of these items in the <code>type_annotation</code> structure is the same as their meaning in the <code>annotation</code> structure.

msg_attr_type_path = Wherever a type is used in a declaration or expression, the <code>type_path</code> structure identifies which part of the type is annotated.
msg_attr_type_path__path_length = The value of the <code>path_length</code> item gives the number of entries in the <code>path</code> array.
msg_attr_type_path__path = Each entry in the <code>path</code> array represents an iterative, left-to-right step towards the precise location of the annotation in an array type, nested type, or parameterized type. 
msg_attr_type_path__type_path_kind =The legal values for the <code>type_path_kind</code> item are listed bellow.<br/><br/><code>0</code> Annotation is deeper in an array type<br/><code>1</code> Annotation is deeper in a nested type<br/><code>2</code> Annotation is on the bound of a wildcard type argument of a parameterized type<br/><code>3</code> Annotation is on a type argument of a parameterized type<br/>
msg_attr_type_path__type_argument_index =If the value of the <code>type_path_kind</code> item is <code>0</code>, <code>1</code>, or <code>2</code>, then the value of the <code>type_argument_index</code> item is <code>0</code>.<br/><br/>If the value of the <code>type_path_kind</code> item is <code>3</code>, then the value of the <code>type_argument_index</code> item specifies which type argument of a parameterized type is annotated, where <code>0</code> indicates the first type argument of a parameterized type.

# 4.7.22. The AnnotationDefault Attribute

msg_attr_AnnotationDefault =The <code>AnnotationDefault</code> attribute is a variable-length attribute in the attributes table of certain method_info structures, namely those representing elements of annotation interfaces.<br/><br/>The <code>AnnotationDefault</code> attribute records the default value for the element represented by the <code>method_info</code> structure.<br/><br/>There may be at most one <code>AnnotationDefault</code> attribute in the attributes table of a <code>method_info</code> structure which represents an element of an annotation interface.
msg_attr_AnnotationDefault__default_value = The <code>default_value</code> item represents the default value of the annotation interface element represented by the <code>method_info</code> structure enclosing this <code>AnnotationDefault</code> attribute.

# 4.7.23. The BootstrapMethods Attribute
msg_attr_BootstrapMethods = The <code>BootstrapMethods</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>BootstrapMethods</code> attribute records bootstrap methods used to produce dynamically-computed constants and dynamically-computed call sites.<br/><br/>There must be exactly one <code>BootstrapMethods</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure if the <code>constant_pool</code> table of the <code>ClassFile</code> structure has at least one <code>CONSTANT_Dynamic_info</code> or <code>CONSTANT_InvokeDynamic_info</code> entry.<br/><br/>There may be at most one <code>BootstrapMethods</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_BootstrapMethods__num_bootstrap_methods = The value of the <code>num_bootstrap_methods</code> item determines the number of bootstrap method specifiers in the <code>bootstrap_methods</code> array.
msg_attr_bootstrap_methods = Each entry in the <code>bootstrap_methods</code> table contains an index to a <code>CONSTANT_MethodHandle_info</code> structure which specifies a bootstrap method, and a sequence (perhaps empty) of indexes to <code>static arguments</code> for the bootstrap method.
msg_attr_bootstrap_methods__bootstrap_method_ref = The value of the <code>bootstrap_method_ref</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_MethodHandle_info</code> structure.
msg_attr_bootstrap_methods__num_bootstrap_arguments = The value of the <code>num_bootstrap_arguments</code> item gives the number of items in the <code>bootstrap_arguments</code> array.
msg_attr_bootstrap_methods__bootstrap_arguments = Each entry in the <code>bootstrap_arguments</code> array must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be loadable.

# 4.7.24. The MethodParameters Attribute
msg_attr_MethodParameters = The <code>MethodParameters</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>method_info</code> structure.<br/><br/>A <code>MethodParameters</code> attribute records information about the formal parameters of a method, such as their names.<br/><br/>There may be at most one <code>MethodParameters</code> attribute in the <code>attributes</code> table of a <code>method_info</code> structure.
msg_attr_MethodParameters__parameters_count = The value of the <code>parameters_count</code> item indicates the number of parameter descriptors in the method descriptor referenced by the <code>descriptor_index</code> of the attribute's enclosing <code>method_info</code> structure.
msg_attr_parameters = Parameter item
msg_attr_parameters__name_index = The value of the <code>name_index</code> item must either be zero or a valid index into the <code>constant_pool</code> table.<br/><br/>If the value of the <code>name_index</code> item is <code>zero</code>, then this parameters element indicates a formal parameter with no name.<br/><br/>If the value of the <code>name_index</code> item is <code>nonzero</code>, the <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing a valid unqualified name denoting a formal parameter.
msg_attr_parameters__access_flags =The value of the <code>access_flags</code> item is as follows:<br/><br/><code>0x0010 (ACC_FINAL)</code><br/>Indicates that the formal parameter was declared <code>final</code>.<br/><br/><code>0x1000 (ACC_SYNTHETIC)</code><br/>Indicates that the formal parameter was not explicitly or implicitly declared in source code, according to the specification of the language in which the source code was written. (The formal parameter is an implementation artifact of the compiler which produced this <code>class</code> file.)<br/><br/><code>0x8000 (ACC_MANDATED)</code><br/>Indicates that the formal parameter was implicitly declared in source code, according to the specification of the language in which the source code was written. (The formal parameter is mandated by a language specification, so all compilers for the language must emit it.)

# 4.7.25. The Module Attribute
msg_attr_Module = The <code>Module</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>Module</code> attribute indicates the modules required by a module; the packages exported and opened by a module; and the services used and provided by a module.<br/><br/>There may be at most one <code>Module</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_module_name_index = The value of the <code>module_name_index</code> item must be a valid index into the <code>constant_pool</code> table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Module_info</code> structure denoting the current module.
msg_attr_module_flags = The value of the <code>module_flags</code> item is as follows:<br/><br/><code>0x0020 (ACC_OPEN)</code><br/>Indicates that this module is open.<br/><br/><code>0x1000 (ACC_SYNTHETIC)</code><br/>Indicates that this module was not explicitly or implicitly declared.<br/><br/><code>0x8000 (ACC_MANDATED)</code><br/>Indicates that this module was implicitly declared.
msg_attr_module_version_index = The value of the <code>module_version_index</code> item must be either zero or a valid index into the <code>constant_pool</code> table.<br/><br/>If the value of the item is <code>zero</code>, then no version information about the current module is present.<br/><br/>If the value of the item is <code>nonzero</code>, then the <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing the version of the current module.

msg_attr_requires_count = The value of the <code>requires_count</code> item indicates the number of entries in the <code>requires</code> table.<br/><br/>If the current module is <code>java.base</code>, then <code>requires_count</code> must be <code>zero</code>.<br/><br/>If the current module is not <code>java.base</code>, then <code>requires_count</code> must be at least <code>one</code>.
msg_attr_requires = Each entry in the <code>requires</code> table specifies a dependence of the current module.<br/><br/>Unless the current module is <code>java.base</code>, exactly one entry in the <code>requires</code> table must have both a <code>requires_index</code> item which indicates <code>java.base</code> and a <code>requires_flags</code> item which has the <code>ACC_SYNTHETIC</code> flag not set.
msg_attr_requires_index = The value of the <code>requires_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Module_info</code> structure denoting a module on which the current module depends.<br/><br/>At most one entry in the <code>requires</code> table may specify a module of a given name with its <code>requires_index</code> item.
msg_attr_requires_flags =The value of the <code>requires_flags</code> item is as follows:<br/><br/><code>0x0020 (ACC_TRANSITIVE)</code><br/>Indicates that any module which depends on the current module, implicitly declares a dependence on the module indicated by this entry.<br/><br/><code>0x0040 (ACC_STATIC_PHASE)</code><br/>Indicates that this dependence is mandatory in the static phase, i.e., at compile time, but is optional in the dynamic phase, i.e., at run time.<br/><br/><code>0x1000 (ACC_SYNTHETIC)</code><br/>Indicates that this dependence was not explicitly or implicitly declared in the source of the module declaration.<br/><br/><code>0x8000 (ACC_MANDATED)</code><br/>Indicates that this dependence was implicitly declared in the source of the module declaration.<br/><br/>If the current module is not <code>java.base</code>, and the class file version number is <code>54.0</code> or above, then neither <code>ACC_TRANSITIVE</code> nor <code>ACC_STATIC_PHASE</code> may be set in <code>requires_flags</code>.
msg_attr_requires_version_index =The value of the <code>requires_version_index</code> item must be either <code>zero</code> or a valid index into the <code>constant_pool</code> table.<br/><br/>If the value of the item is <code>zero</code>, then no version information about the dependence is present.<br/><br/>If the value of the item is <code>nonzero</code>, then the <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure representing the version of the module specified by <code>requires_index</code>.

msg_attr_exports_count = The value of the <code>exports_count</code> item indicates the number of entries in the <code>exports</code> table.
msg_attr_exports = Each entry in the <code>exports</code> table specifies a package exported by the current module, such that <code>public</code> and <code>protected</code> types in the package, and their <code>public</code> and <code>protected</code> members, may be accessed from outside the current module, possibly from a limited set of "friend" modules.
msg_attr_exports_index = The value of the <code>exports_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Package_info</code> structure representing a package exported by the current module.<br/><br/>At most one entry in the <code>exports</code> table may specify a package of a given name with its <code>exports_index</code> item.
msg_attr_exports_flags = The value of the <code>exports_flags</code> item is as follows:<br/><br/><code>0x1000 (ACC_SYNTHETIC)</code><br/>Indicates that this export was not explicitly or implicitly declared in the source of the module declaration.<br/><br/><code>0x8000 (ACC_MANDATED)</code><br/>Indicates that this export was implicitly declared in the source of the module declaration.<br/><br/>
msg_attr_exports_to_count = The value of the <code>exports_to_count</code> indicates the number of entries in the <code>exports_to_index</code> table.<br/><br/>If <code>exports_to_count</code> is <code>zero</code>, then this package is exported by the current module in an <code>unqualified</code> fashion; code in any other module may access the types and members in the package.<br/><br/>If <code>exports_to_count</code> is <code>nonzero</code>, then this package is exported by the current module in a <code>qualified</code> fashion; only code in the modules listed in the <code>exports_to_index</code> table may access the types and members in the package.
msg_attr_exports_to_index = The value of each entry in the <code>exports_to_index</code> table must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Module_info</code> structure denoting a module whose code can access the types and members in this exported package.<br/><br/>For each entry in the <code>exports</code> table, at most one entry in its <code>exports_to_index</code> table may specify a module of a given name.

msg_attr_opens_count = The value of the <code>opens_count</code> item indicates the number of entries in the <code>opens</code> table.<br/><br/><code>opens_count</code> must be zero if the current module is open.
msg_attr_opens = Each entry in the <code>opens</code> table specifies a package opened by the current module, such that all types in the package, and all their members, may be accessed from outside the current module via the reflection libraries of the Java SE Platform, possibly from a limited set of "friend" modules.
msg_attr_opens_index = The value of the <code>opens_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Package_info</code> structure representing a package opened by the current module.<br/><br/>At most one entry in the opens table may specify a package of a given name with its <code>opens_index</code> item.
msg_attr_opens_flags = The value of the <code>aaa</code>opens_flags item is as follows:<br/><br/><code>0x1000 (ACC_SYNTHETIC)</code><br/>Indicates that this opening was not explicitly or implicitly declared in the source of the module declaration.<br/><br/><code>0x8000 (ACC_MANDATED)</code><br/>Indicates that this opening was implicitly declared in the source of the module declaration.<br/><br/>
msg_attr_opens_to_count = The value of the <code>opens_to_count</code> indicates the number of entries in the <code>opens_to_index</code> table.<br/><br/>If <code>opens_to_count</code> is <code>zero</code>, then this package is opened by the current module in an <code>unqualified</code> fashion; code in any other module may reflectively access the types and members in the package.<br/><br/>If <code>opens_to_count</code> is <code>nonzero</code>, then this package is opened by the current module in a <codequalifiedaaa</code> fashion; only code in the modules listed in the <code>exports_to_index</code> table may reflectively access the types and members in the package.
msg_attr_opens_to_index = The value of each entry in the <code>opens_to_index</code> table must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Module_info</code> structure denoting a module whose code can access the types and members in this opened package.<br/><br/>For each entry in the opens table, at most one entry in its <code>opens_to_index</code> table may specify a module of a given name.

msg_attr_uses_count = The value of the <code>uses_count</code> item indicates the number of entries in the <code>uses_index</code> table.
msg_attr_uses_index = The value of each entry in the <code>uses_index</code> table must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a service interface which the current module may discover via <code>java.util.ServiceLoader</code>.<br/><br/>At most one entry in the <code>uses_index</code> table may specify a service interface of a given name.

msg_attr_provides_count = The value of the <code>provides_count</code> item indicates the number of entries in the <code>provides</code> table.
msg_attr_provides = Each entry in the <code>provides</code> table represents a service implementation for a given service interface.
msg_attr_provides_index = The value of the <code>provides_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a service interface for which the current module provides a service implementation.<br/><br/>At most one entry in the <code>provides</code> table may specify a service interface of a given name with its <code>provides_index</code> item.
msg_attr_provides_with_count = The value of the <code>provides_with_count</code> indicates the number of entries in the <code>provides_with_index</code> table.<br/><br/><code>provides_with_count</code> must be nonzero.
msg_attr_provides_with_index = The value of each entry in the <code>provides_with_index</code> table must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a service implementation for the service interface specified by <code>provides_index</code>.<br/><br/>For each entry in the <code>provides</code> table, at most one entry in its <code>provides_with_index</code> table may specify a service implementation of a given name.

# 4.7.26. The ModulePackages Attribute
msg_attr_ModulePackages = The <code>ModulePackages</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>ModulePackages</code> attribute indicates all the packages of a module that are exported or opened by the <code>Module</code> attribute, as well as all the packages of the service implementations recorded in the <code>Module</code> attribute.<br/><br/>The <code>ModulePackages</code> attribute may also indicate packages in the module that are neither exported nor opened nor contain service implementations.<br/><br/>There may be at most one <code>ModulePackages</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_ModulePackages__package_count = The value of the <code>package_count</code> item indicates the number of entries in the <code>package_index</code> table.
msg_attr_ModulePackages__package_index = The value of each entry in the <code>package_index</code> table must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Package_info</code> structure representing a package in the current module.<br/><br/>At most one entry in the <code>package_index</code> table may specify a package of a given name.

# 4.7.27. The ModuleMainClass Attribute
msg_attr_ModuleMainClass = The <code>ModuleMainClass</code> attribute is a fixed-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>ModuleMainClass</code> attribute indicates the main class of a module.<br/><br/>There may be at most one <code>ModuleMainClass</code> attribute in the attributes table of a <code>ClassFile</code> structure.
msg_attr_ModuleMainClass__main_class_index = The value of the <code>main_class_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing the main class of the current module.

# 4.7.28. The NestHost Attribute
msg_attr_NestHost = The <code>NestHost</code> attribute is a fixed-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>NestHost</code> attribute records the nest host of the nest to which the current class or interface claims to belong.<br/><br/>There may be at most one <code>NestHost</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.
msg_attr_NestHost__host_class_index = The value of the <code>host_class_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class or interface which is the nest host for the current class or interface.

# 4.7.29. The NestMembers Attribute
msg_attr_NestMembers = The <code>NestMembers</code> attribute is a variable-length attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>NestMembers</code> attribute records the classes and interfaces that are authorized to claim membership in the nest hosted by the current class or interface.<br/><br/>There may be at most one <code>NestMembers</code> attribute in the <code>attributes</code> table of a <code>ClassFile</code> structure.<br/><br/>The <code>attributes</code> table of a <code>ClassFile</code> structure must not contain both a <code>NestMembers</code> attribute and a <code>NestHost</code> attribute.
msg_attr_NestMembers__number_of_classes = The value of the <code>number_of_classes</code> item indicates the number of entries in the <code>classes</code> array.
msg_attr_NestMembers__classes = Each value in the <code>classes</code> array must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class or interface which is a member of the nest hosted by the current class or interface.

# 4.7.30. The Record Attribute
msg_attr_Record = The <code>Record</code> attribute is a variable-length attribute in the attributes table of a <code>ClassFile</code> structure. The <code>Record</code> attribute indicates that the current class is a record class, and stores information about the record components of the record class. <br/><br/>There may be at most one Record attribute in the attributes table of a <code>ClassFile</code> structure.
msg_attr_Record__components_count = The value of the <code>components_count</code> item indicates the number of entries in the <code>components</code> table.
msg_attr_record_component_info = Each entry in the components table specifies a record component of the current class, in the order the record components were declared.
msg_attr_record_component_info__name_index = The value of the <code>name_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info_pool</code> structure representing a valid unqualified name denoting the record component.
msg_attr_record_component_info__descriptor_index = The value of the <code>descriptor_index</code> item must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info_pool</code> structure representing a field descriptor which encodes the type of the record component.
msg_attr_record_component_info__attributes_count = The value of the <code>attributes_count</code> item indicates the number of additional attributes of this record component.
msg_attr_record_component_info__attributes = Each value of the <code>attributes</code> table must be an <code>attribute_info</code> structure.<br/><br/>A record component can have any number of optional attributes associated with it.

# 4.7.31. The PermittedSubclasses Attribute
msg_attr_PermittedSubclasses = The <code>PermittedSubclasses</code> attribute is a variable-length attribute in the attributes table of a <code>ClassFile</code> structure. The <code>PermittedSubclasses</code> attribute records the classes and interfaces that are authorized to directly extend or implement the current class or interface.<br/><br/>There may be at most one <code>PermittedSubclasses</code> attribute in the attributes table of a <code>ClassFile</code> structure whose <code>access_flags</code> item does not have the <code>ACC_FINAL</code> flag set.<br/><br/>There must be no <code>PermittedSubclasses</code> attribute in the attributes table of a <code>ClassFile</code> structure whose <code>access_flags</code> item has the <code>ACC_FINAL</code> flag set.
msg_attr_PermittedSubclasses__number_of_classes = The value of the <code>number_of_classes</code> item indicates the number of entries in the <code>classes</code> array.
msg_attr_PermittedSubclasses__classes = Each value in the <code>classes</code> array must be a valid index into the <code>constant_pool</code> table.<br/><br/>The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Class_info</code> structure representing a class or interface which is authorized to directly extend or implement the current class or interface.

# Attributes Not described in JVM Spec, but exist in .class files

msg_attr_Bridge = This is an legacy JVM attribute will not exist in new compied codes.<br/><br/>The Bridge attribute is used to indicate a bridge method generated by a compiler for the Java programming language.

msg_attr_ModuleHashes = This is an legacy JVM attribute in OpenJDK 9.
msg_attr_ModuleHashes_algorithm_index = Index to <code>CONSTANT_utf8_info</code> structure with algorithm name
msg_attr_ModuleHashes_hashes_count = The number of entries in the <code>hashes</code> table
msg_attr_ModuleHashes_hashes = Hashes list
msg_attr_ModuleHashes_module_name_index = Module name of the hash, points to <code>CONSTANT_Module_info</code> structure
msg_attr_ModuleHashes_hash_length = Length of the <code>hash</code> field
msg_attr_ModuleHashes_hash = Hash value of the field

msg_attr_ModuleTarget = This is an legacy JVM attribute in OpenJDK 9.
msg_attr_ModuleTarget_os_arch_index = Operating system architecture name for this module

msg_attr_ModuleResolution = This is an proposed JVM attribute may exist later after OpenJDK 17.

msg_attr_Unrecognized = This is an Unrecognized JVM attribute, usually created by customized compiler or other JVM languages.
msg_attr_NoneJVM = This is an customized attribute did not specified in The Java Virtual Machine Specification.

```

`FormatDEX/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.dex</artifactId>
    <version>0.8</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatDEX</name>
    <description>Dalvik Executable format</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.format.class</artifactId>
            <version>21.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.dex.PluginDescriptorDEX</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>

```

`FormatDEX/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatdex {
    requires static org.binaryinternals.commonlib;
    requires static org.binaryinternals.formatclass;

    exports org.binaryinternals.format.dex;
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/DexFile.java`:

```java
/*
 * DexFile.java    June 14, 2015, 22:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.dex.header_item.Endian;

/**
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S116", "java:S1104"})
public final class DexFile extends FileFormat {

    /**
     * The constant NO_INDEX is used to indicate that an index value is absent.
     * Embedded in {@link class_def_item} and {@link debug_info_item}
     */
    public static final long NO_INDEX = 0xffffffffL;
    private static final Logger LOGGER = Logger.getLogger(DexFile.class.getName());

    /**
     * The constant array/string
     * {@link #DEX_FILE_MAGIC1}|{@link #DEX_FILE_MAGIC2} is the list of bytes
     * that must appear at the beginning of a <code>.dex</code> file in order
     * for it to be recognized as such.
     * <p>
     * The value intentionally contains a <code>newline</code> ("\n" or 0x0a)
     * and a <code>null</code> byte ("\0" or 0x00) in order to help in the
     * detection of certain forms of corruption. The value also encodes a format
     * version number as three decimal digits, which is expected to increase
     * monotonically over time as the format evolves.
     * </p>
     */
    @SuppressWarnings("java:S2386")
    static final byte[] DEX_FILE_MAGIC1 = new byte[]{'d', 'e', 'x', '\n'};
    @SuppressWarnings("java:S2386")
    static final byte[] DEX_FILE_MAGIC2 = new byte[]{'0', '3', '5', '\0'};

    /**
     * Magic value part 1.
     */
    public final byte[] magic1;
    /**
     * Magic value part 2.
     */
    public final byte[] magic2;

    /**
     * The file header.
     */
    public final header_item header;
    /**
     * String identifiers list, or <code>null</code>.
     */
    public final string_id_item[] string_ids;
    public final type_id_item[] type_ids;
    public final proto_id_item[] proto_ids;
    public final field_id_item[] field_ids;
    public final method_id_item[] method_ids;
    public final class_def_item[] class_defs;
    /**
     * The parsed file components.
     */
    public final SortedMap<Long, FileComponent> data = new TreeMap<>();
    public Type_ubyte[] link_data;

    /**
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high - We need this logic together
     * </pre>
     *
     * @param file Input file
     * @throws IOException Read file failed
     * @throws FileFormatException Invalid file format
     */
    @SuppressWarnings("java:S3776")
    public DexFile(File file) throws IOException, FileFormatException {
        super(file);

        // Check the file signature
        this.magic1 = new byte[DEX_FILE_MAGIC1.length];
        this.magic2 = new byte[DEX_FILE_MAGIC2.length];
        System.arraycopy(super.fileByteArray, 0, magic1, 0, DEX_FILE_MAGIC1.length);
        System.arraycopy(super.fileByteArray, 4, magic2, 0, DEX_FILE_MAGIC2.length);

        if (!BytesTool.isByteArraySame(DEX_FILE_MAGIC1, magic1)
                || magic2[DEX_FILE_MAGIC2.length - 1] != DEX_FILE_MAGIC2[DEX_FILE_MAGIC2.length - 1]) {
            throw new FileFormatException("This is not a valid DEX file, because the DEX file signature does not exist at the beginning of this file.");
        }

        // Parse section by section
        PosDataInputStream parseEndian = new PosDataInputStream(new PosByteArrayInputStream(super.fileByteArray));

        BytesTool.skip(parseEndian, DEX_FILE_MAGIC1.length);
        BytesTool.skip(parseEndian, DEX_FILE_MAGIC2.length);
        BytesTool.skip(parseEndian, Type_uint.LENGTH);           // checksum
        BytesTool.skip(parseEndian, 20);                         // signature
        BytesTool.skip(parseEndian, Type_uint.LENGTH);           // file_size
        BytesTool.skip(parseEndian, Type_uint.LENGTH);           // header_size

        int i1 = parseEndian.readUnsignedByte();
        int i2 = parseEndian.readUnsignedByte();
        int i3 = parseEndian.readUnsignedByte();
        int i4 = parseEndian.readUnsignedByte();

        Endian endian;
        if (Endian.ENDIAN_CONSTANT.equals(i1, i2, i3, i4)) {
            endian = Endian.ENDIAN_CONSTANT;
        } else if (Endian.REVERSE_ENDIAN_CONSTANT.equals(i1, i2, i3, i4)) {
            endian = Endian.REVERSE_ENDIAN_CONSTANT;
        } else {
            throw new FileFormatException("The dex file do not contain valid endian_tag. the value: 0x"
                    + Integer.toHexString(i1) + ", 0x"
                    + Integer.toHexString(i2) + ", 0x"
                    + Integer.toHexString(i3) + ", 0x"
                    + Integer.toHexString(i4));
        }

        PosDataInputStreamDex stream = new PosDataInputStreamDex(new PosByteArrayInputStream(super.fileByteArray), endian);
        SortedMap<Long, Class<?>> todoData = new TreeMap<>();

        // Header
        BytesTool.skip(stream, DEX_FILE_MAGIC1.length);
        BytesTool.skip(stream, DEX_FILE_MAGIC2.length);
        this.header = new header_item(stream);

        // string_ids
        if (this.header.string_ids_off.intValue() == 0) {
            this.string_ids = null;
        } else {
            stream.flyTo(this.header.string_ids_off.intValue());
            this.string_ids = new string_id_item[this.header.string_ids_size.intValue()];
            for (int i = 0; i < this.string_ids.length; i++) {
                this.string_ids[i] = new string_id_item(stream);
                todoData.put(this.string_ids[i].string_data_off.value, string_data_item.class);
            }
        }

        // type_ids
        if (this.header.type_ids_off.intValue() == 0) {
            this.type_ids = null;
        } else {
            stream.flyTo(this.header.type_ids_off.intValue());
            this.type_ids = new type_id_item[this.header.type_ids_size.intValue()];
            for (int i = 0; i < this.type_ids.length; i++) {
                this.type_ids[i] = new type_id_item(stream);
            }
        }

        // proto_ids
        if (this.header.proto_ids_off.intValue() == 0) {
            this.proto_ids = null;
        } else {
            stream.flyTo(this.header.proto_ids_off.intValue());
            this.proto_ids = new proto_id_item[this.header.proto_ids_size.intValue()];
            for (int i = 0; i < this.proto_ids.length; i++) {
                this.proto_ids[i] = new proto_id_item(stream);
                if (this.proto_ids[i].parameters_off.value != 0) {
                    todoData.put(this.proto_ids[i].parameters_off.value, type_list.class);
                }
            }
        }

        // field_ids
        if (this.header.field_ids_off.intValue() == 0) {
            this.field_ids = null;
        } else {
            stream.flyTo(this.header.field_ids_off.intValue());
            this.field_ids = new field_id_item[this.header.field_ids_size.intValue()];
            for (int i = 0; i < this.field_ids.length; i++) {
                this.field_ids[i] = new field_id_item(stream);
            }
        }

        // method_ids
        if (this.header.method_ids_off.intValue() == 0) {
            this.method_ids = null;
        } else {
            stream.flyTo(this.header.method_ids_off.intValue());
            this.method_ids = new method_id_item[this.header.method_ids_size.intValue()];
            for (int i = 0; i < this.method_ids.length; i++) {
                this.method_ids[i] = new method_id_item(stream);
            }
        }

        // class_defs
        if (this.header.class_defs_off.intValue() == 0) {
            this.class_defs = null;
        } else {
            stream.flyTo(this.header.class_defs_off.intValue());
            this.class_defs = new class_def_item[this.header.class_defs_size.intValue()];
            for (int i = 0; i < this.class_defs.length; i++) {
                this.class_defs[i] = new class_def_item(stream, this);

                if (this.class_defs[i].interfaces_off.value != 0) {
                    todoData.put(this.class_defs[i].interfaces_off.value, type_list.class);
                }
                if (this.class_defs[i].annotations_off.value != 0) {
                    todoData.put(this.class_defs[i].annotations_off.value, annotations_directory_item.class);
                }
                if (this.class_defs[i].class_data_off.value != 0) {
                    todoData.put(this.class_defs[i].class_data_off.value, class_data_item.class);
                }
                if (this.class_defs[i].static_values_off.value != 0) {
                    todoData.put(this.class_defs[i].static_values_off.value, encoded_array_item.class);
                }
            }
        }

        // data
        for (Map.Entry<Long, Class<?>> todoItem : todoData.entrySet()) {
            this.parseData(todoItem.getKey(), todoItem.getValue(), stream);
        }
    }

    void parseData(Long offset, Class<?> type, PosDataInputStreamDex stream) throws IOException, FileFormatException{
        int breakPos = stream.getPos();

        Constructor<?> cons = type.getDeclaredConstructors()[0];
        stream.flyTo(offset.intValue());
        try {
            switch(cons.getParameterCount()) {
                case 1:
                    this.data.put(offset, (FileComponent) cons.newInstance(stream));
                    break;
                case 2:
                    this.data.put(offset, (FileComponent) cons.newInstance(stream, this));
                    break;
                default:
                    throw new FileFormatException(String.format("Coding issue: no suitable constructor for type %s at 0x%X", type.getSimpleName(), offset.intValue()));
            }
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            String msg = String.format("newInstance failed for data item for type %s at 0x%X", type.getSimpleName(), offset.intValue());
            LOGGER.severe(msg);
            throw new IOException(msg, e);
        }

        stream.flyTo(breakPos);
    }

    static void check_uint(String fieldName, Type_uint uint, int streamPosition) throws FileFormatException {
        if (uint.value > Integer.MAX_VALUE) {
            throw new FileFormatException(String.format("%s is too big cannot be handled here: %d, position 0x%X", fieldName, uint.value, streamPosition));
        }
    }

    @Override
    public Icons getIcon() {
        return Icons.Dex;
    }

    /**
     * Get the underlying String value for a {@link #string_ids} item.
     *
     * @param index Index in the {@link #string_ids} array
     * @return String value for the {@link #string_ids} item, or
     * <code>null</code> for invalid index
     */
    public String get_string_ids_string(int index) {
        if (index < -1 || this.string_ids == null || index >= this.string_ids.length) {
            LOGGER.log(Level.WARNING, "Return null for invalid string_ids index={0}", index);
            return null;
        }

        FileComponent fc = this.data.get(this.string_ids[index].string_data_off.value);
        if (fc instanceof string_data_item) {
            return ((string_data_item) fc).getString();
        } else {
            return null;
        }
    }

    /**
     * Get the underlying String value for a {@link #type_ids} item.
     *
     * @param index Index in the {@link #type_ids} array
     * @return String value for the {@link #type_ids} item, or <code>null</code>
     * for invalid index
     */
    public String get_type_ids_string(int index) {
        if (index < -1 || this.type_ids == null || index >= this.type_ids.length) {
            LOGGER.log(Level.WARNING, "Return null for invalid type_ids index={0}", index);
            return null;
        }

        return this.get_string_ids_string(this.type_ids[index].descriptor_idx.intValue());
    }

    @Override
    public String getContentTabName() {
        return "Android DEX File";
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        (new JTreeDexFile()).generateTreeNode(parentNode, this);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/GenerateTreeNodeDexFile.java`:

```java
/*
 * GenerateTreeNodeDexFile.java    August 18, 2021, 19:13
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.dex;

import java.util.Locale;
import java.util.ResourceBundle;
import org.binaryinternals.commonlib.ui.GenerateTreeNodeFileFormat;

/**
 * Interface for generating tree node for {@link DexFile}.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S115 - Constant name does not follow naming conventions --- We respect the DEX spec name instead
 * </pre>
 */
@SuppressWarnings({"java:S115"})
public interface GenerateTreeNodeDexFile extends GenerateTreeNodeFileFormat {
    static final ResourceBundle MESSAGES = ResourceBundle.getBundle(JTreeDexFile.class.getPackageName() + ".MessagesBundle", Locale.ROOT);
    static final String msg_annotation_set_item = "msg_annotation_set_item";

    @Override
    default ResourceBundle getMessages() {
        return MESSAGES;
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/JTreeDexFile.java`:

```java
/*
 * JTreeDexFile.java    June 15, 2015, 23:45
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.nio.charset.StandardCharsets;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * </pre>
 */
@SuppressWarnings("java:S100")
public class JTreeDexFile implements GenerateTreeNodeDexFile {

    private static final Logger LOGGER = Logger.getLogger(JTreeDexFile.class.getName());

    JTreeDexFile() {
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        this.generate_magic(parentNode, dexFile);
        dexFile.header.generateTreeNode(parentNode, dexFile);
        this.generate_string_ids(parentNode, dexFile);
        this.generate_type_ids(parentNode, dexFile);
        this.generate_proto_ids(parentNode, dexFile);
        this.generate_field_ids(parentNode, dexFile);
        this.generate_method_ids(parentNode, dexFile);
        this.generate_class_defs(parentNode, dexFile);
        this.generate_data(parentNode, dexFile);
    }

    private void generate_magic(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        int startPos = 0;

        DefaultMutableTreeNode magicNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                DexFile.DEX_FILE_MAGIC1.length + DexFile.DEX_FILE_MAGIC2.length,
                "magic"));
        parentNode.add(magicNode);

        magicNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                DexFile.DEX_FILE_MAGIC1.length,
                "magic 1: " + new String(dexFile.magic1, StandardCharsets.UTF_8),
                Icons.Magic,
                GenerateTreeNodeDexFile.MESSAGES.getString("msg_dex_file_magic1")
        )));
        startPos += DexFile.DEX_FILE_MAGIC1.length;

        magicNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                DexFile.DEX_FILE_MAGIC2.length,
                "magic 2: " + new String(dexFile.magic2, StandardCharsets.UTF_8),
                Icons.Magic,
                GenerateTreeNodeDexFile.MESSAGES.getString("msg_dex_file_magic2")
        )));
    }

    private void generate_string_ids(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.string_ids == null || dexFile.string_ids.length < 1) {
            return;
        }

        int startPos = dexFile.header.string_ids_off.intValue();
        int size = dexFile.string_ids.length;

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                size * Type_uint.LENGTH,
                String.format("string_ids [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            string_id_item item = dexFile.string_ids[i];
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    String.format("string_id_item[%,d] : %s", i, left(dexFile.get_string_ids_string(i)))
            ));
            node.add(itemNode);
            item.generateTreeNode(itemNode, dexFile);
        }
    }

    private void generate_type_ids(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.type_ids == null || dexFile.type_ids.length < 1) {
            return;
        }

        int startPos = dexFile.header.type_ids_off.intValue();
        int size = dexFile.type_ids.length;

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                size * Type_uint.LENGTH,
                String.format("type_ids [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            type_id_item item = dexFile.type_ids[i];
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    String.format("type_id_item[%,d] : %s", i, item.get_descriptor_jls(dexFile))
            ));
            node.add(itemNode);
            item.generateTreeNode(itemNode, dexFile);
        }
    }

    private void generate_proto_ids(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.proto_ids == null || dexFile.proto_ids.length < 1) {
            return;
        }

        int size = dexFile.proto_ids.length;

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                dexFile.header.proto_ids_off.intValue(),
                size * proto_id_item.ITEM_SIZE,
                String.format("proto_ids [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            proto_id_item item = dexFile.proto_ids[i];
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    String.format("proto_id_item[%,d] : %s", i, item.get_shorty(dexFile))));
            item.generateTreeNode(itemNode, dexFile);
            node.add(itemNode);
        }
    }

    private void generate_field_ids(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.field_ids == null || dexFile.field_ids.length < 1) {
            return;
        }

        int size = dexFile.field_ids.length;
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                dexFile.header.field_ids_off.intValue(),
                size * field_id_item.ITEM_SIZE,
                String.format("field_ids [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            field_id_item item = dexFile.field_ids[i];
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    String.format("field_id_item[%,d] : %s", i, item.toString(dexFile))));
            item.generateTreeNode(itemNode, dexFile);
            node.add(itemNode);
        }
    }

    private void generate_method_ids(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.method_ids == null || dexFile.method_ids.length < 1) {
            return;
        }

        int size = dexFile.method_ids.length;
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                dexFile.header.method_ids_off.intValue(),
                size * method_id_item.ITEM_SIZE,
                String.format("method_ids [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            method_id_item item = dexFile.method_ids[i];
            int startPos = item.getStartPos();
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPos,
                    item.getLength(),
                    String.format("method_id_item[%,d] : %s", i, item.toString(dexFile))));
            item.generateTreeNode(itemNode, dexFile);
            node.add(itemNode);
        }
    }

    private void generate_class_defs(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.class_defs == null || dexFile.class_defs.length < 1) {
            return;
        }

        int size = dexFile.class_defs.length;
        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                dexFile.header.class_defs_off.intValue(),
                size * class_def_item.ITEM_SIZE,
                String.format("class_defs [%,d]", size)));
        parentNode.add(node);

        for (int i = 0; i < size; i++) {
            class_def_item item = dexFile.class_defs[i];
            int startPos = item.getStartPos();
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPos,
                    item.getLength(),
                    String.format("class_def_item[%,d] %s", i, item.get_class_jls(dexFile))));
            item.generateTreeNode(itemNode, dexFile);
            node.add(itemNode);
        }
    }

    private void generate_data(DefaultMutableTreeNode parentNode, DexFile dexFile) {
        if (dexFile.data.size() < 1) {
            return;
        }

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                dexFile.header.data_off.intValue(),
                dexFile.header.data_size.intValue(),
                String.format("data [%,d]", dexFile.data.size())));
        parentNode.add(node);

        dexFile.data.entrySet().stream().map(item -> item.getValue()).forEachOrdered(comp -> {
            int startPos = comp.getStartPos();

            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    startPos,
                    comp.getLength(),
                    Type_uint.toString(startPos) + " - " + comp.getClass().getSimpleName()));
            node.add(itemNode);

            if (comp instanceof GenerateTreeNode) {
                ((GenerateTreeNode) comp).generateTreeNode(itemNode);
            } else if (comp instanceof GenerateTreeNodeDexFile) {
                ((GenerateTreeNodeDexFile) comp).generateTreeNode(itemNode, dexFile);
            } else {
                // This should never happen, or else it is a coding logic error
                LOGGER.severe(String.format("FileComponent is not added to the tree: position=0x%X type=%s", comp.getStartPos(), comp.getClass().getName()));
            }
        });
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/PluginDescriptorDEX.java`:

```java
/*
 * PluginDescriptor.java    Apr 16, 2011, 20:14
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.dex;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;


/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorDEX implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "Android DEX File (*.dex)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"dex"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return DexFile.class;
    }

}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/PosDataInputStreamDex.java`:

```java
/*
 * PosDataInputStreamDex.java    June 17, 2015, 21:29
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.EOFException;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.format.dex.header_item.Endian;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We use different naming convention for better readablity
 * java:S1110 - Redundant parenthesis --- Redundant parenthesis is needed for readability
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S1110"})
public class PosDataInputStreamDex extends PosDataInputStream {

    /**
     * Full Byte length: 3.
     */
    private static final int BYTE_LENGTH_3 = 3;
    private static final int BYTE_LENGTH_5 = 5;
    private static final int BYTE_LENGTH_6 = 6;
    private static final int BYTE_LENGTH_7 = 7;

    /**
     * Byte position: 6.
     */
    private static final int BYTE_POSITION_5 = 5;

    /**
     * Endian of the {@link DexFile}. The default value is little-endian
     * {@link header_item.Endian#ENDIAN_CONSTANT}, as the DEX format
     * specification said.
     */
    protected final header_item.Endian endian;

    public PosDataInputStreamDex(PosByteArrayInputStream in) {
        super(in);
        this.endian = Endian.ENDIAN_CONSTANT;
    }

    public PosDataInputStreamDex(PosByteArrayInputStream in, header_item.Endian e) {
        super(in);
        this.endian = e;
    }

    /**
     * Read a {@link Type_byte} from the input stream.
     *
     * @return a {@link Type_byte}
     * @throws IOException I/O error
     */
    public Type_byte Dex_byte() throws IOException {
        return new Type_byte(this.readByte());
    }

    /**
     * Read a {@link Type_ubyte} from the input stream.
     *
     * @return a {@link Type_ubyte}
     * @throws IOException I/O error
     */
    public Type_ubyte Dex_ubyte() throws IOException {
        return new Type_ubyte(this.readUnsignedByte());
    }

    /**
     * Read a {@link Type_short} from the input stream.
     *
     * @return a {@link Type_short}
     * @throws IOException I/O Error
     */
    public Type_short Dex_short() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_short(this.readShort());
        } else {
            return new Type_short(this.readShortInLittleEndian());
        }
    }

    /**
     * Read a {@link Type_ushort} from the input stream.
     *
     * @return a {@link Type_ushort}
     * @throws IOException I/O Error
     */
    public Type_ushort Dex_ushort() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_ushort(this.readUnsignedShort());
        } else {
            return new Type_ushort(this.readUnsignedShortInLittleEndian());
        }
    }

    /**
     * Read a {@link Type_int} from the input stream.
     *
     * @return a {@link Type_int}
     * @throws IOException I/O Error
     */
    public Type_int Dex_int() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_int(this.readInt());
        } else {
            return new Type_int(this.readIntInLittleEndian());
        }
    }

    /**
     * Read a 3-byte {@link Type_int} from the input stream.
     *
     * @return a {@link Type_int}
     * @throws IOException I/O Error
     */
    public Type_int Dex_int3() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_int(this.readInt3());
        } else {
            return new Type_int(this.readInt3InLittleEndian());
        }
    }

    /**
     * Read a {@link Type_uint} from the input stream.
     *
     * @return a {@link Type_uint}
     * @throws IOException I/O Error
     */
    public Type_uint Dex_uint() throws IOException {
        if (this.endian.value == header_item.Endian.ENDIAN_CONSTANT.value) {
            return new Type_uint(this.readUnsignedInt());
        } else {
            return new Type_uint(this.readUnsignedIntInLittleEndian());
        }
    }

    /**
     * Read a {@link Type_uint} from the input stream for only 3 bytes.
     *
     * @return a {@link Type_uint}
     * @throws IOException I/O Error
     */
    public Type_uint Dex_uint3() throws IOException {
        if (this.endian.value == header_item.Endian.ENDIAN_CONSTANT.value) {
            return new Type_uint(this.readUnsignedInt3());
        } else {
            return new Type_uint(this.readUnsignedInt3InLittleEndian());
        }
    }

    /**
     * Read a {@link Type_long} from the input stream.
     *
     * @return a {@link Type_long}
     * @throws IOException I/O Error
     */
    public Type_long Dex_long() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_long(this.readLong());
        } else {
            return new Type_long(this.readLongInLittleEndian());
        }
    }

    /**
     * Read a 5/6/7-byte {@link Type_long} from the input stream.
     *
     * @param length Dynamic long length value: 5, 6, or 7
     * @return a {@link Type_long}
     * @throws IOException I/O Error
     */
    public Type_long Dex_long(int length) throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            switch (length) {
                case 5:
                    return new Type_long(this.readLong5());
                case 6:
                    return new Type_long(this.readLong6());
                case 7:
                    return new Type_long(this.readLong7());
                default:
            }
        } else {
            switch (length) {
                case 5:
                    return new Type_long(this.readLong5InLittleEndian());
                case 6:
                    return new Type_long(this.readLong6InLittleEndian());
                case 7:
                    return new Type_long(this.readLong7InLittleEndian());
                default:
            }
        }

        throw new IllegalArgumentException(String.format("Unexpected long value length: %d", length));
    }

    /**
     * Read a {@link Type_ulong} from the input stream.
     *
     * @return a {@link Type_ulong}
     * @throws IOException I/O Error
     */
    public Type_ulong Dex_ulong() throws IOException {
        if (this.endian == header_item.Endian.ENDIAN_CONSTANT) {
            return new Type_ulong(this.readUnsignedLong());
        } else {
            return new Type_ulong(this.readUnsignedLongInLittleEndian());
        }
    }

    /**
     * Read a {@link Type_sleb128} from the input stream.
     *
     * @throws IOException I/O Error
     * @throws FileFormatException Invalid LEB128 format
     * @return a {@link Type_sleb128}
     */
    public Type_sleb128 Dex_sleb128() throws IOException, FileFormatException {
        int startPos = super.getPos();
        int result = 0;
        int cur;
        int count = 0;
        int signBits = -1;

        do {
            cur = super.readByte() & 0xff;
            result |= (cur & 0x7f) << (count * 7);
            signBits <<= 7;
            count++;
        } while (((cur & 0x80) == 0x80) && count < 5);

        if ((cur & 0x80) == 0x80) {
            throw new FileFormatException("Invalid LEB128 sequence at file position " + super.getPos());
        }

        if (((signBits >> 1) & result) != 0) {
            result |= signBits;
        }

        return new Type_sleb128(result, super.getPos() - startPos);
    }

    /**
     * Read a {@link Type_uleb128} from the input stream.
     *
     * @throws IOException I/O Error
     * @throws FileFormatException Invalid LEB128 format
     * @return a {@link Type_uleb128}
     */
    public Type_uleb128 Dex_uleb128() throws IOException, FileFormatException {
        int startPos = super.getPos();
        int result = 0;
        int cur;
        int count = 0;

        do {
            cur = super.readByte() & 0xff;
            result |= (cur & 0x7f) << (count * 7);
            count++;
        } while (((cur & 0x80) == 0x80) && count < 5);

        if ((cur & 0x80) == 0x80) {
            throw new FileFormatException("Invalid LEB128 sequence at file position " + super.getPos());
        }

        return new Type_uleb128(result, super.getPos() - startPos);
    }

    /**
     * Read a {@link Type_uleb128p1} from the input stream.
     *
     * @throws IOException I/O Error
     * @throws FileFormatException Invalid LEB128 format
     * @return a {@link Type_uleb128p1}
     */
    public Type_uleb128p1 Dex_uleb128p1() throws IOException, FileFormatException {
        Type_uleb128 uleb128 = this.Dex_uleb128();
        return new Type_uleb128p1(uleb128.value - 1, uleb128.length);
    }

    public Double readDouble(int length) throws IOException{
        System.out.println(this.getClass().getSimpleName() + " VALUE_DOUBLE value_arg " + (length - 1) + " at 0x" + Integer.toHexString(this.getPos())  + " - to implment");

        byte[] raw = new byte[length];
        int rb = this.read(raw);
        if (rb != length) {
            throw new IOException(String.format("Cannot read enough bytes for double. expected=%d readbytes=%d", length, rb));
        }

        return Double.MAX_VALUE;
    }

    public Float readFloat(int length) throws IOException{
        System.out.println(this.getClass().getSimpleName() + " VALUE_FLOAT value_arg " + (length -1) + " at 0x" + Integer.toHexString(this.getPos())  + " - to implment");

        byte[] raw = new byte[length];
        int rb = this.read(raw);
        if (rb != length) {
            throw new IOException(String.format("Cannot read enough bytes for float. expected=%d readbytes=%d", length, rb));
        }

        return Float.MIN_VALUE;
    }

    /**
     * Read 3-byte int.
     */
    private int readInt3() throws IOException {
        int ch1 = this.in.read();
        int ch2 = this.in.read();
        int ch3 = this.in.read();
        if ((ch1 | ch2 | ch3) < 0) {
            throw new EOFException();
        }

        if ((ch3 & 0x80) > 0) {
            System.out.println("TODO verify - 3-byte int test case at 0x" + Integer.toHexString(this.getPos()) + " ----------------------- readInt3 ----");
            return 0xFF000000 | (ch1 << SHIFT_16) | (ch2 << SHIFT_8) | (ch3);
        } else {
            return (ch1 << SHIFT_16) | (ch2 << SHIFT_8) | (ch3);
        }
    }

    /**
     * Read 3-byte int in little-endian.
     */
    private int readInt3InLittleEndian() throws IOException {
        int ch1 = this.in.read();
        int ch2 = this.in.read();
        int ch3 = this.in.read();
        if ((ch1 | ch2 | ch3) < 0) {
            throw new EOFException();
        }

        if ((ch3 & 0x80) > 0) {
            // System.out.println("TODO verify via Java source code via minus value - 3-byte int test case at 0x" + Integer.toHexString(this.getPos()) + " ----------------------- readIntInLittleEndian3 ----");
            return 0xFF000000 | (ch3 << SHIFT_16) | (ch2 << SHIFT_8) | (ch1);
        } else {
            return (ch3 << SHIFT_16) | (ch2 << SHIFT_8) | (ch1);
        }
    }

    private long readLong5() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_5];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_4] & 0x80) > 0) {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong5 NEGATIVE----");
            return (0xFFFFFF0000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255)));
        } else {
            System.out.println("TODO test case at  0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong5 POSITIVE----");
            return (  ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255)));
        }
    }

    private long readLong5InLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_5];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_4] & 0x80) > 0) {
            System.out.println("TODO test case at   0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong5InLittleEndian NEGATIVE----");
            return (0xFFFFFF0000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        } else {
            return (  ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        }
    }

    private long readLong6() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_6];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_5] & 0x80) > 0) {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong6 NEGATIVE----");
            return (0xFFFF000000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255)));
        } else {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong6 POSITIVE----");
            return (  ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255)));
        }
    }
    private long readLong6InLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_6];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_5] & 0x80) > 0) {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong6InLittleEndian NEGATIVE----");
            return (0xFFFF000000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        } else {
            return (  ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        }
    }

    private long readLong7() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_7];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_6] & 0x80) > 0) {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong7 NEGATIVE----");
            return (0xFF00000000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_48)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255)));
        } else {
            System.out.println("TODO test case at 0x" + Integer.toHexString(this.getPos()) + " ------------------- to verify ---- readLong7 POSITIVE----");
            return (  ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255) << SHIFT_48)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255)));
        }
    }
    private long readLong7InLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_7];
        super.readFully(readBuffer);

        if ((readBuffer[BYTE_OFFSET_6] & 0x80) > 0) {
            return (0xFF00000000000000L
                    | ((long) (readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_48)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        } else {
            return (  ((long) (readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_48)
                    | ((long) (readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_40)
                    | ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_32)
                    | ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_24)
                    | ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_16)
                    | ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_8)
                    | ((long) (readBuffer[BYTE_OFFSET_0] & BYTE_MAX_255)));
        }
    }

    /**
     * Read 3-byte unsigned int.
     */
    private long readUnsignedInt3() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];

        super.readFully(readBuffer, BYTE_POSITION_5, BYTE_LENGTH_3);
        readBuffer[BYTE_OFFSET_0] = 0;
        readBuffer[BYTE_OFFSET_1] = 0;
        readBuffer[BYTE_OFFSET_2] = 0;
        readBuffer[BYTE_OFFSET_3] = 0;
        readBuffer[BYTE_OFFSET_4] = 0;

        return (((long) readBuffer[BYTE_OFFSET_0] << SHIFT_56)
                + ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_48)
                + ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_40)
                + ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_32)
                + ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_24)
                + ((readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_16)
                + ((readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_8)
                + ((readBuffer[BYTE_OFFSET_7] & BYTE_MAX_255)));
    }

    /**
     * Read 3-byte unsigned int in little-endian.
     */
    private long readUnsignedInt3InLittleEndian() throws IOException {
        final byte[] readBuffer = new byte[BYTE_LENGTH_8];

        super.readFully(readBuffer, 0, BYTE_LENGTH_3);
        readBuffer[BYTE_OFFSET_7] = readBuffer[BYTE_OFFSET_0];
        readBuffer[BYTE_OFFSET_6] = readBuffer[BYTE_OFFSET_1];
        readBuffer[BYTE_OFFSET_5] = readBuffer[BYTE_OFFSET_2];
        readBuffer[BYTE_OFFSET_4] = 0;
        readBuffer[BYTE_OFFSET_3] = 0;
        readBuffer[BYTE_OFFSET_2] = 0;
        readBuffer[BYTE_OFFSET_1] = 0;
        readBuffer[BYTE_OFFSET_0] = 0;

        return (((long) readBuffer[BYTE_OFFSET_0] << SHIFT_56)
                + ((long) (readBuffer[BYTE_OFFSET_1] & BYTE_MAX_255) << SHIFT_48)
                + ((long) (readBuffer[BYTE_OFFSET_2] & BYTE_MAX_255) << SHIFT_40)
                + ((long) (readBuffer[BYTE_OFFSET_3] & BYTE_MAX_255) << SHIFT_32)
                + ((long) (readBuffer[BYTE_OFFSET_4] & BYTE_MAX_255) << SHIFT_24)
                + ((readBuffer[BYTE_OFFSET_5] & BYTE_MAX_255) << SHIFT_16)
                + ((readBuffer[BYTE_OFFSET_6] & BYTE_MAX_255) << SHIFT_8)
                + ((readBuffer[BYTE_OFFSET_7] & BYTE_MAX_255)));
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_byte.java`:

```java
/*
 * Type_byte.java    June 17, 2015, 21:32
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 8-bit signed int.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_byte {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 1;

    /**
     * Value of the DEX <code>byte</code>.
     *
     * @see
     * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2.1">
     * Java byte type</a>
     */
    public final byte value;

    protected Type_byte(byte b) {
        this.value = b;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %d | %c", Integer.toHexString(this.value).toUpperCase(), this.value, this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_int.java`:

```java
/*
 * Type_int.java    June 17, 2015, 21:38
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 32-bit signed int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_int {
    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 4;

    /**
     * Value of the DEX <code>int</code>.
     */
    public final int value;

    protected Type_int(int i) {
        this.value = i;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %,d", Integer.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_long.java`:

```java
/*
 * Type_long.java    June 17, 2015, 21:39
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 64-bit signed int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_long {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 8;
    /**
     * Value of the DEX <code>long</code>.
     */
    public final long value;

    protected Type_long(long l) {
        this.value = l;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %,d", Long.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_short.java`:

```java
/*
 * Type_short.java    June 17, 2015, 21:36
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 16-bit signed int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_short {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 2;

    /**
     * Value of the DEX <code>short</code>.
     */
    public final short value;

    protected Type_short(short s) {
        this.value = s;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %,d", Integer.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_sleb128.java`:

```java
/*
 * Type_sleb128.java    June 17, 2015, 21:41
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * Signed LEB128, variable-length.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_sleb128 {

    /**
     * Value of the DEX <code>sleb128</code>.
     */
    public final int value;
    /**
     * Length of the number in DEX file in bytes.
     */
    public final int length;

    protected Type_sleb128(int v, int l) {
        this.value = v;
        this.length = l;
    }

    @Override
    public String toString() {
        return String.format("length=%d value=0x%s | %,d", this.length, Integer.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_ubyte.java`:

```java
/*
 * Type_ubyte.java    June 17, 2015, 21:32
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 8-bit unsigned int.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_ubyte {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 1;

    /**
     * Value of the DEX <code>ubyte</code>.
     */
    public final int value;

    protected Type_ubyte(int i) {
        this.value = i;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %d", Integer.toHexString(this.value).toUpperCase(), this.value);
    }

    /**
     * Get string for <code>ubyte</code> array.
     *
     * @param bytes <code>ubyte</code> array
     * @return String value
     */
    public static String toString(Type_ubyte[] bytes) {
        if (bytes == null || bytes.length < 1) {
            return "empty array";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("array (");
        for (int i = 0; i < bytes.length; i++) {
            sb.append(Integer.toHexString(bytes[i].value).toUpperCase());
            if (i != bytes.length - 1) {
                sb.append(", ");
            }
        }
        sb.append(")");

        return sb.toString();
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_uint.java`:

```java
/*
 * Type_uint.java    June 17, 2015, 21:39
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 32-bit unsigned int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_uint {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 4;

    /**
     * Value of the DEX <code>uint</code>.
     */
    public final long value;

    protected Type_uint(long l) {
        this.value = l;
    }

    @Override
    public boolean equals(Object other) {
        return other instanceof Type_uint && ((Type_uint)other).value == this.value;
    }

    @Override
    public int hashCode() {
        return Long.valueOf(this.value).hashCode();
    }

    public int intValue() {
        return (int) value;
    }

    @Override
    public String toString() {
        return Type_uint.toString(this.value);
    }

    /**
     * Convert <code>long</code> to String with both offset and readable format.
     *
     * @param l The <code>long</code> value
     * @return The String for <code>l</code>
     */
    public static String toString(long l) {
        return String.format("0x%s | %,d", Long.toHexString(l).toUpperCase(), l);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_uleb128.java`:

```java
/*
 * Type_uleb128.java    June 17, 2015, 21:42
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * Unsigned LEB128, variable-length.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_uleb128 {

    /**
     * Value of the DEX <code>uleb128</code>.
     */
    public final int value;
    /**
     * Length of the number in DEX file in bytes.
     */
    public final int length;

    protected Type_uleb128(int v, int l) {
        this.value = v;
        this.length = l;
    }

    @Override
    public String toString() {
        return String.format("length=%d value=0x%s | %,d", this.length, Integer.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_uleb128p1.java`:

```java
/*
 * Type_uleb128p1.java    June 17, 2015, 21:42
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * Unsigned LEB128 plus 1, variable-length.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_uleb128p1 {

    /**
     * Value of the DEX <code>uleb128</code>.
     */
    public final int value;
    /**
     * Length of the number in DEX file in bytes.
     */
    public final int length;

    protected Type_uleb128p1(int v, int l) {
        this.value = v;
        this.length = l;
    }

    @Override
    public String toString() {
        return String.format("length=%d value=0x%s | %,d", this.length, Integer.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_ulong.java`:

```java
/*
 * Type_ulong.java    June 17, 2015, 21:40
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.math.BigInteger;

/**
 * 64-bit unsigned int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_ulong {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 8;

    /**
     * Value of the DEX <code>ulong</code>.
     */
    public final BigInteger value;

    protected Type_ulong(BigInteger bi) {
        this.value = bi;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %s | %,d",
                this.value.toString(16).toUpperCase(),
                this.value.toString(),
                this.value.longValue());
    }
}
```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/Type_ushort.java`:

```java
/*
 * Type_ushort.java    June 17, 2015, 21:37
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

/**
 * 16-bit unsigned int, little-endian.
 *
 * @author Amos Shi
 * @see
 * <a href="https://source.android.com/devices/tech/dalvik/dex-format.html">
 * Dalvik Executable (DEX) format</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We need different Name convesins for readability
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Type_ushort {

    /**
     * Length of the type in bytes.
     */
    public static final int LENGTH = 2;

    /**
     * Value of the DEX <code>ubyte</code>.
     */
    public final int value;

    protected Type_ushort(int i) {
        this.value = i;
    }

    @Override
    public String toString() {
        return String.format("0x%s | %,d", Long.toHexString(this.value).toUpperCase(), this.value);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/access_flag.java`:

```java
/*
 * access_flag.java    June 21, 2021, 10:18
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.binaryinternals.format.classfile.AccessFlag;

/**
 * Bit-fields of these flags are used to indicate the accessibility and overall
 * properties of classes and class members.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class access_flag {

    /**
     * Access flags for Classes (and InnerClass annotations).
     */
    public static final List<AccessFlag> ForClass = Collections.synchronizedList(new ArrayList<>());
    /**
     * Access flags for Fields.
     */
    public static final List<AccessFlag> ForField = Collections.synchronizedList(new ArrayList<>());
    /**
     * Access flags for Methods.
     */
    public static final List<AccessFlag> ForMethod = Collections.synchronizedList(new ArrayList<>());

    static {
        // For Classes (and InnerClass annotations)
        access_flag.ForClass.add(AccessFlag.ACC_PUBLIC);
        access_flag.ForClass.add(AccessFlag.ACC_PRIVATE);
        access_flag.ForClass.add(AccessFlag.ACC_PROTECTED);
        access_flag.ForClass.add(AccessFlag.ACC_STATIC);
        access_flag.ForClass.add(AccessFlag.ACC_FINAL);
        access_flag.ForClass.add(AccessFlag.ACC_INTERFACE);
        access_flag.ForClass.add(AccessFlag.ACC_ABSTRACT);
        access_flag.ForClass.add(AccessFlag.ACC_SYNTHETIC);
        access_flag.ForClass.add(AccessFlag.ACC_ANNOTATION);
        access_flag.ForClass.add(AccessFlag.ACC_ENUM);

        // For Fields
        access_flag.ForField.add(AccessFlag.ACC_PUBLIC);
        access_flag.ForField.add(AccessFlag.ACC_PRIVATE);
        access_flag.ForField.add(AccessFlag.ACC_PROTECTED);
        access_flag.ForField.add(AccessFlag.ACC_STATIC);
        access_flag.ForField.add(AccessFlag.ACC_FINAL);
        access_flag.ForField.add(AccessFlag.ACC_VOLATILE);
        access_flag.ForField.add(AccessFlag.ACC_TRANSIENT);
        access_flag.ForField.add(AccessFlag.ACC_SYNTHETIC);
        access_flag.ForField.add(AccessFlag.ACC_ENUM);

        // For Methods
        access_flag.ForMethod.add(AccessFlag.ACC_PUBLIC);
        access_flag.ForMethod.add(AccessFlag.ACC_PRIVATE);
        access_flag.ForMethod.add(AccessFlag.ACC_PROTECTED);
        access_flag.ForMethod.add(AccessFlag.ACC_STATIC);
        access_flag.ForMethod.add(AccessFlag.ACC_FINAL);
        access_flag.ForMethod.add(AccessFlag.ACC_SYNCHRONIZED);
        access_flag.ForMethod.add(AccessFlag.ACC_BRIDGE);
        access_flag.ForMethod.add(AccessFlag.ACC_VARARGS);
        access_flag.ForMethod.add(AccessFlag.ACC_ABSTRACT);
        access_flag.ForMethod.add(AccessFlag.ACC_STRICT);
        access_flag.ForMethod.add(AccessFlag.ACC_SYNTHETIC);
        access_flag.ForMethod.add(AccessFlag.ACC_CONSTRUCTOR);
        access_flag.ForMethod.add(AccessFlag.ACC_DECLARED_SYNCHRONIZED);
    }

    /**
     * Private constructor for utility class.
     */
    private access_flag() {
    }

    public static String getClassModifier(long value) {
        return AccessFlag.getModifier(value, access_flag.ForClass);
    }

    public static String getFieldModifier(int value) {
        return AccessFlag.getModifier(value, access_flag.ForField);
    }

    public static String getMethodModifier(int value) {
        return AccessFlag.getModifier(value, access_flag.ForMethod);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/annotation_set_item.java`:

```java
/*
 * annotation_set_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class annotation_set_item extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_uint size;
    public final annotation_off_item[] entries;

    annotation_set_item(PosDataInputStreamDex stream, DexFile dexFile) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.size = stream.Dex_uint();
        if (this.size.value > 0) {
            this.entries = new annotation_off_item[this.size.intValue()];
            for (int i = 0; i < this.size.value; i++) {
                this.entries[i] = new annotation_off_item(stream, dexFile);
            }
        } else {
            this.entries = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public String toString() {
        return String.format(FORMAT_STRING_STRING, this.getClass().getSimpleName(), this.size);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;
        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "size",
                this.size,
                "msg_annotation_set_item__size",
                Icons.Size
        );
        floatPos += Type_uint.LENGTH;

        if (this.entries == null) {
            return;
        }

        DefaultMutableTreeNode entriesNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                annotation_off_item.LENGTH * this.entries.length,
                String.format("entries [%d]", this.entries.length),
                Icons.Data,
                MESSAGES.getString("msg_annotation_set_item__entries")
        ));
        parentNode.add(entriesNode);

        for (int i = 0; i < this.entries.length; i++) {
            // Since annotation_off_item has only 1 field, so we do not use child node
            annotation_off_item offItem = this.entries[i];
            DefaultMutableTreeNode offItemNode = addNode(entriesNode,
                    offItem.getStartPos(),
                    offItem.getLength(),
                    String.format("%s[%d].annotation_off", annotation_off_item.class.getSimpleName(), i),
                    offItem.annotation_off,
                    "msg_annotation_off_item__annotation_off",
                    Icons.Offset
            );

            annotation_item item = (annotation_item) dexFile.data.get(offItem.annotation_off.value);
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    annotation_item.class.getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_annotation_item")
            ));
            offItemNode.add(itemNode);
            item.generateTreeNode(itemNode, dexFile);
        }
    }

    public static class annotation_off_item extends FileComponent {

        public static final int LENGTH = Type_uint.LENGTH;
        public final Type_uint annotation_off;

        annotation_off_item(PosDataInputStreamDex stream, DexFile dexFile) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.annotation_off = stream.Dex_uint();
            super.length = stream.getPos() - super.startPos;

            dexFile.parseData(this.annotation_off.value, annotation_item.class, stream);
        }
    }

    public static class annotation_item extends FileComponent implements GenerateTreeNodeDexFile {

        public final Type_ubyte visibility;
        public final encoded_annotation annotation;

        annotation_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.visibility = stream.Dex_ubyte();
            this.annotation = new encoded_annotation(stream);
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;
            addNode(parentNode,
                    floatPos,
                    Type_ubyte.LENGTH,
                    "size",
                    String.format(FORMAT_STRING_STRING, this.visibility, Visibility.toString(this.visibility.value)),
                    "msg_annotation_item__visibility", //
                    Icons.Data // TODO Icon to be changed
            );
            floatPos += Type_ubyte.LENGTH;

            DefaultMutableTreeNode annoNode = addNode(parentNode,
                    floatPos,
                    this.annotation.getLength(),
                    "annotation",
                    this.annotation.toString(dexFile),
                    "msg_annotation_item__annotation",
                    Icons.Annotations
            );
            this.annotation.generateTreeNode(annoNode, dexFile);
        }

        public enum Visibility {
            VISIBILITY_BUILD(0x00, "msg_annotation_item__visibility_build"),
            VISIBILITY_RUNTIME(0x01, "msg_annotation_item__visibility_runtime"),
            VISIBILITY_SYSTEM(0x02, "msg_annotation_item__visibility_system");

            public final int value;
            public final String description;

            Visibility(int v, String d) {
                this.value = v;
                this.description = MESSAGES.getString(d);
            }

            @Override
            public String toString() {
                return String.format("%d - %s", this.value, this.description);
            }

            public static String toString(int v) {
                for (Visibility item : Visibility.values()) {
                    if (item.value == v) {
                        return item.toString();
                    }
                }

                return String.format("%d - %s", v, MESSAGES.getString("msg_common_unrecognized"));
            }
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/annotation_set_ref_list.java`:

```java
/*
 * annotation_set_ref_list.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class annotation_set_ref_list extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_uint size;
    public final annotation_set_ref_item[] list;

    annotation_set_ref_list(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
        super.startPos = stream.getPos();

        this.size = stream.Dex_uint();
        if (this.size.value > 0) {
            this.list = new annotation_set_ref_item[this.size.intValue()];
            for (int i = 0; i < this.size.value; i++) {
                this.list[i] = new annotation_set_ref_item(stream, dex);
            }
        } else {
            this.list = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public String toString() {
        return String.format(FORMAT_STRING_STRING, this.getClass().getSimpleName(), this.size);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "size",
                this.size,
                "msg_annotation_set_ref_list__size",
                Icons.Size);
        floatPos += Type_uint.LENGTH;

        if (this.list == null) {
            return;
        }

        DefaultMutableTreeNode listNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                annotation_set_ref_item.LENGTH * this.list.length,
                String.format("list [%d]", this.list.length),
                Icons.Data,
                MESSAGES.getString("msg_annotation_set_ref_list__list")
        ));
        parentNode.add(listNode);

        for (int i = 0; i < this.list.length; i++) {
            // Since annotation_set_ref_item has only 1 field, so we do not use child node
            annotation_set_ref_item refItem = this.list[i];
            DefaultMutableTreeNode refItemNode = addNode(listNode,
                    refItem.getStartPos(),
                    refItem.getLength(),
                    String.format("%s[%d].annotations_off", annotation_set_ref_item.class.getSimpleName(), i),
                    refItem.annotations_off,
                    "msg_annotation_set_ref_item__annotations_off",
                    Icons.Offset
            );

            if (refItem.annotations_off.value == 0) {
                continue;
            }

            FileComponent fc = dexFile.data.get(refItem.annotations_off.value);
            //annotation_set_item item = (annotation_set_item)
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    fc.getStartPos(),
                    fc.getLength(),
                    fc.getClass().getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_annotation_set_item")
            ));
            refItemNode.add(itemNode);
            if (fc instanceof GenerateTreeNodeDexFile) {
                ((GenerateTreeNodeDexFile) fc).generateTreeNode(itemNode, dexFile);
            }
        }
    }

    public static class annotation_set_ref_item extends FileComponent {

        public static final int LENGTH = Type_uint.LENGTH;
        public final Type_uint annotations_off;

        annotation_set_ref_item(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.annotations_off = stream.Dex_uint();
            if ((this.annotations_off.value != 0) && (!dex.data.keySet().contains(this.annotations_off.value))) {
                dex.parseData(this.annotations_off.value, annotation_set_item.class, stream);
            }
            super.length = stream.getPos() - super.startPos;
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/annotations_directory_item.java`:

```java
/*
 * annotations_directory_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class annotations_directory_item extends FileComponent implements GenerateTreeNodeDexFile {

    private static final String MSG_ANNOTATIONS_OFF = "annotations_off";

    public final Type_uint class_annotations_off;
    public final Type_uint fields_size;
    public final Type_uint annotated_methods_size;
    public final Type_uint annotated_parameters_size;
    public final field_annotation[] field_annotations;
    public final method_annotation[] method_annotations;
    public final parameter_annotation[] parameter_annotations;

    annotations_directory_item(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
        super.startPos = stream.getPos();

        this.class_annotations_off = stream.Dex_uint();
        if ((this.class_annotations_off.value != 0) && (!dex.data.keySet().contains(this.class_annotations_off.value))) {
            dex.parseData(this.class_annotations_off.value, annotation_set_item.class, stream);
        }

        this.fields_size = stream.Dex_uint();
        this.annotated_methods_size = stream.Dex_uint();
        this.annotated_parameters_size = stream.Dex_uint();

        // field_annotations
        if (this.fields_size.value > 0) {
            this.field_annotations = new field_annotation[this.fields_size.intValue()];
            for (int i = 0; i < this.fields_size.value; i++) {
                this.field_annotations[i] = new field_annotation(stream, dex);
            }
        } else {
            this.field_annotations = null;
        }

        // method_annotations
        if (this.annotated_methods_size.value > 0) {
            this.method_annotations = new method_annotation[this.annotated_methods_size.intValue()];
            for (int i = 0; i < this.annotated_methods_size.value; i++) {
                this.method_annotations[i] = new method_annotation(stream, dex);
            }
        } else {
            this.method_annotations = null;
        }

        // parameter_annotations
        if (this.annotated_parameters_size.value > 0) {
            this.parameter_annotations = new parameter_annotation[this.annotated_parameters_size.intValue()];
            for (int i = 0; i < this.annotated_parameters_size.value; i++) {
                this.parameter_annotations[i] = new parameter_annotation(stream, dex);
            }
        } else {
            this.parameter_annotations = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;

        DefaultMutableTreeNode classAnOffsetNode = addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "class_annotations_off",
                String.format(FORMAT_STRING_STRING, this.class_annotations_off, this.class_annotations_off),
                "msg_annotations_directory_item__class_annotations_off",
                Icons.Offset);
        floatPos += Type_uint.LENGTH;

        if (this.class_annotations_off.value != 0) {
            annotation_set_item classAn = (annotation_set_item) dexFile.data.get(this.class_annotations_off.value);
            DefaultMutableTreeNode classAnNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    classAn.getStartPos(),
                    classAn.getLength(),
                    classAn.getClass().getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString(msg_annotation_set_item)
            ));
            classAnOffsetNode.add(classAnNode);
            classAn.generateTreeNode(classAnNode, dexFile);
        }

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "fields_size",
                this.fields_size,
                "msg_annotations_directory_item__fields_size",
                Icons.Size);
        floatPos += Type_uint.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "annotated_methods_size",
                this.annotated_methods_size,
                "msg_annotations_directory_item__annotated_methods_size",
                Icons.Size);
        floatPos += Type_uint.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "annotated_parameters_size",
                this.annotated_parameters_size,
                "msg_annotations_directory_item__annotated_parameters_size",
                Icons.Size);

        if (this.field_annotations != null) {
            final int fieldLen = this.field_annotations.length;
            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.field_annotations[0].getStartPos(),
                    fieldLen * field_annotation.LENGTH,
                    String.format("field_annotations [%,d]", fieldLen),
                    Icons.Annotations,
                    MESSAGES.getString("msg_annotations_directory_item__field_annotations")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < fieldLen; i++) {
                field_annotation item = this.field_annotations[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("field_annotation [%,d]", i),
                        Icons.Annotations,
                        field_annotation.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dexFile);
            }
        }

        if (this.method_annotations != null) {
            final int methodLen = this.method_annotations.length;
            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.method_annotations[0].getStartPos(),
                    methodLen * method_annotation.LENGTH,
                    String.format("method_annotations [%,d]", methodLen),
                    Icons.Annotations,
                    MESSAGES.getString("msg_annotations_directory_item__method_annotations")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < methodLen; i++) {
                method_annotation item = this.method_annotations[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("method_annotation [%,d]", i),
                        Icons.Annotations,
                        method_annotation.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dexFile);
            }
        }

        if (this.parameter_annotations != null) {
            final int parameterLen = this.parameter_annotations.length;
            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.parameter_annotations[0].getStartPos(),
                    parameterLen * parameter_annotation.LENGTH,
                    String.format("parameter_annotations [%,d]", parameterLen),
                    Icons.Annotations,
                    MESSAGES.getString("msg_annotations_directory_item__parameter_annotations")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < parameterLen; i++) {
                parameter_annotation item = this.parameter_annotations[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("parameter_annotation [%,d]", i),
                        Icons.Annotations,
                        parameter_annotation.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dexFile);
            }
        }
    }

    public static class field_annotation extends FileComponent implements GenerateTreeNodeDexFile {

        public static final int LENGTH = Type_uint.LENGTH + Type_uint.LENGTH;
        public final Type_uint field_idx;
        public final Type_uint annotations_off;

        field_annotation(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
            super.startPos = stream.getPos();

            this.field_idx = stream.Dex_uint();
            this.annotations_off = stream.Dex_uint();
            if (!dex.data.keySet().contains(this.annotations_off.value)) {
                dex.parseData(this.annotations_off.value, annotation_set_item.class, stream);
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;

            addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    "field_idx",
                    String.format(FORMAT_STRING_STRING, this.field_idx, dexFile.field_ids[this.field_idx.intValue()].toString(dexFile)),
                    "msg_field_annotation__field_idx",
                    Icons.Index);
            floatPos += Type_uint.LENGTH;

            DefaultMutableTreeNode offsetNode = addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    MSG_ANNOTATIONS_OFF,
                    this.annotations_off,
                    "msg_field_annotation__annotations_off",
                    Icons.Shortcut);

            annotation_set_item value = (annotation_set_item) dexFile.data.get(this.annotations_off.value);
            DefaultMutableTreeNode valueNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    value.getStartPos(),
                    value.getLength(),
                    value.toString(),
                    Icons.Annotations,
                    MESSAGES.getString(msg_annotation_set_item)
            ));
            offsetNode.add(valueNode);
            value.generateTreeNode(valueNode, dexFile);
        }
    }

    public static class method_annotation extends FileComponent implements GenerateTreeNodeDexFile {

        public static final int LENGTH = Type_uint.LENGTH + Type_uint.LENGTH;

        public final Type_uint method_idx;
        public final Type_uint annotations_off;

        method_annotation(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
            super.startPos = stream.getPos();

            this.method_idx = stream.Dex_uint();
            this.annotations_off = stream.Dex_uint();
            if (!dex.data.keySet().contains(this.annotations_off.value)) {
                dex.parseData(this.annotations_off.value, annotation_set_item.class, stream);
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;

            addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    "method_idx",
                    String.format(FORMAT_STRING_STRING, this.method_idx, dexFile.method_ids[this.method_idx.intValue()].toString(dexFile)),
                    "msg_method_annotation__method_idx",
                    Icons.Index);
            floatPos += Type_uint.LENGTH;

            DefaultMutableTreeNode offsetNode = addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    MSG_ANNOTATIONS_OFF,
                    this.annotations_off,
                    "msg_method_annotation__annotations_off",
                    Icons.Offset);

            annotation_set_item value = (annotation_set_item) dexFile.data.get(this.annotations_off.value);
            DefaultMutableTreeNode valueNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    value.getStartPos(),
                    value.getLength(),
                    value.toString(),
                    Icons.Shortcut,
                    MESSAGES.getString(msg_annotation_set_item)
            ));
            offsetNode.add(valueNode);
            value.generateTreeNode(valueNode, dexFile);
        }
    }

    public static class parameter_annotation extends FileComponent implements GenerateTreeNodeDexFile {

        public static final int LENGTH = Type_uint.LENGTH + Type_uint.LENGTH;

        public final Type_uint method_idx;
        public final Type_uint annotations_off;

        parameter_annotation(PosDataInputStreamDex stream, DexFile dex) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.method_idx = stream.Dex_uint();
            this.annotations_off = stream.Dex_uint();
            if (!dex.data.keySet().contains(this.annotations_off.value)) {
                dex.parseData(this.annotations_off.value, annotation_set_ref_list.class, stream);
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;

            addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    "method_idx",
                    String.format(FORMAT_STRING_STRING, this.method_idx, dexFile.method_ids[this.method_idx.intValue()].toString(dexFile)),
                    "msg_parameter_annotation__method_idx",
                    Icons.Index);
            floatPos += Type_uint.LENGTH;

            DefaultMutableTreeNode offsetNode = addNode(parentNode,
                    floatPos,
                    Type_uint.LENGTH,
                    MSG_ANNOTATIONS_OFF,
                    this.annotations_off,
                    "msg_parameter_annotation__annotations_off",
                    Icons.Offset);

            annotation_set_ref_list value = (annotation_set_ref_list) dexFile.data.get(this.annotations_off.value);
            DefaultMutableTreeNode valueNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    value.getStartPos(),
                    value.getLength(),
                    value.toString(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_annotation_set_ref_list")
            ));
            offsetNode.add(valueNode);
            value.generateTreeNode(valueNode, dexFile);
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/class_data_item.java`:

```java
/*
 * class_data_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class class_data_item extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_uleb128 static_fields_size;
    public final Type_uleb128 instance_fields_size;
    public final Type_uleb128 direct_methods_size;
    public final Type_uleb128 virtual_methods_size;

    public final encoded_field[] static_fields;
    public final encoded_field[] instance_fields;
    public final encoded_method[] direct_methods;
    public final encoded_method[] virtual_methods;

    /**
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high - We need this logic together
     * </pre>
     */
    @SuppressWarnings("java:S3776")
    class_data_item(PosDataInputStreamDex stream, DexFile dexFile) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.static_fields_size = stream.Dex_uleb128();
        this.instance_fields_size = stream.Dex_uleb128();
        this.direct_methods_size = stream.Dex_uleb128();
        this.virtual_methods_size = stream.Dex_uleb128();

        if (this.static_fields_size.value > 0) {
            this.static_fields = new encoded_field[this.static_fields_size.value];
            for (int i = 0; i < this.static_fields_size.value; i++) {
                this.static_fields[i] = new encoded_field(stream);
            }
        } else {
            this.static_fields = null;
        }

        if (this.instance_fields_size.value > 0) {
            this.instance_fields = new encoded_field[this.instance_fields_size.value];
            for (int i = 0; i < this.instance_fields_size.value; i++) {
                this.instance_fields[i] = new encoded_field(stream);
            }
        } else {
            this.instance_fields = null;
        }

        if (this.direct_methods_size.value > 0) {
            this.direct_methods = new encoded_method[this.direct_methods_size.value];
            for (int i = 0; i < this.direct_methods_size.value; i++) {
                this.direct_methods[i] = new encoded_method(stream, dexFile);
            }
        } else {
            this.direct_methods = null;
        }

        if (this.virtual_methods_size.value > 0) {
            this.virtual_methods = new encoded_method[this.virtual_methods_size.value];
            for (int i = 0; i < this.virtual_methods_size.value; i++) {
                this.virtual_methods[i] = new encoded_method(stream, dexFile);
            }
        } else {
            this.virtual_methods = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    @SuppressWarnings("java:S3776")
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dex = (DexFile)format;
        int floatPos = super.startPos;

        addNode(parentNode, floatPos, this.static_fields_size.length, "static_fields_size", this.static_fields_size, "msg_class_data_item__static_fields_size", Icons.Size);
        floatPos += this.static_fields_size.length;
        addNode(parentNode, floatPos, this.instance_fields_size.length, "instance_fields_size", this.instance_fields_size, "msg_class_data_item__instance_fields_size", Icons.Size);
        floatPos += this.instance_fields_size.length;
        addNode(parentNode, floatPos, this.direct_methods_size.length, "direct_methods_size", this.direct_methods_size, "msg_class_data_item__direct_methods_size", Icons.Size);
        floatPos += this.direct_methods_size.length;
        addNode(parentNode, floatPos, this.virtual_methods_size.length, "virtual_methods_size", this.virtual_methods_size, "msg_class_data_item__virtual_methods_size", Icons.Size);

        if (this.static_fields != null) {
            int fieldLenSum = 0;
            for (encoded_field field : this.static_fields) {
                fieldLenSum += field.getLength();
            }

            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.static_fields[0].getStartPos(),
                    fieldLenSum,
                    String.format("static_fields [%,d]", this.static_fields.length),
                    Icons.Field,
                    MESSAGES.getString("msg_class_data_item__static_fields")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < this.static_fields.length; i++) {
                encoded_field item = this.static_fields[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("static_fields [%,d]", i),
                        Icons.Field,
                        encoded_field.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dex);
            }
        }

        if (this.instance_fields != null) {
            int fieldLenSum = 0;
            for (encoded_field field : this.instance_fields) {
                fieldLenSum += field.getLength();
            }

            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.instance_fields[0].getStartPos(),
                    fieldLenSum,
                    String.format("instance_fields [%,d]", this.instance_fields.length),
                    Icons.Field,
                    MESSAGES.getString("msg_class_data_item__instance_fields")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < this.instance_fields.length; i++) {
                encoded_field item = this.instance_fields[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("encoded_field [%,d]", i),
                        Icons.Field,
                        encoded_field.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dex);
            }
        }

        if (this.direct_methods != null) {
            int methodLenSum = 0;
            for (encoded_method method : this.direct_methods) {
                methodLenSum += method.getLength();
            }

            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.direct_methods[0].getStartPos(),
                    methodLenSum,
                    String.format("direct_methods [%,d]", this.direct_methods.length),
                    Icons.Method,
                    MESSAGES.getString("msg_class_data_item__direct_methods")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < this.direct_methods.length; i++) {
                encoded_method item = this.direct_methods[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("encoded_method [%,d]", i),
                        Icons.Method,
                        encoded_method.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dex);
            }
        }

        if (this.virtual_methods != null) {
            int methodLenSum = 0;
            for (encoded_method method : this.virtual_methods) {
                methodLenSum += method.getLength();
            }

            DefaultMutableTreeNode nodes = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.virtual_methods[0].getStartPos(),
                    methodLenSum,
                    String.format("virtual_methods [%,d]", this.virtual_methods.length),
                    Icons.Method,
                    MESSAGES.getString("msg_class_data_item__virtual_methods")
            ));
            parentNode.add(nodes);

            for (int i = 0; i < this.virtual_methods.length; i++) {
                encoded_method item = this.virtual_methods[i];
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        String.format("encoded_method [%,d]", i),
                        Icons.Method,
                        encoded_method.class.getSimpleName()
                ));
                nodes.add(node);
                item.generateTreeNode(node, dex);
            }
        }

    }

    public static class encoded_field extends FileComponent implements GenerateTreeNodeDexFile {

        public final Type_uleb128 field_idx_diff;
        public final Type_uleb128 access_flags;

        encoded_field(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.field_idx_diff = stream.Dex_uleb128();
            this.access_flags = stream.Dex_uleb128();
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;

            field_id_item field = dexFile.field_ids[this.field_idx_diff.value];
            addNode(parentNode,
                    floatPos,
                    this.field_idx_diff.length,
                    "field_idx_diff",
                    String.format(FORMAT_STRING_STRING, this.field_idx_diff, (field == null) ? "null (should not happen)" : field.toString(dexFile)),
                    "msg_encoded_field__field_idx_diff",
                    Icons.Index);
            floatPos += this.field_idx_diff.length;

            addNode(parentNode,
                    floatPos,
                    access_flags.length,
                    "access_flags",
                    this.access_flags.toString() + " - " + BytesTool.getBinaryString(this.access_flags.value) + access_flag.getFieldModifier(this.access_flags.value),
                    "msg_class_def_item__access_flags",
                    Icons.AccessFlag
            );
        }
    }

    public static class encoded_method extends FileComponent implements GenerateTreeNodeDexFile {

        public final Type_uleb128 method_idx_diff;
        public final Type_uleb128 access_flags;
        public final Type_uleb128 code_off;

        encoded_method(PosDataInputStreamDex stream, DexFile dexFile) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.method_idx_diff = stream.Dex_uleb128();
            this.access_flags = stream.Dex_uleb128();
            this.code_off = stream.Dex_uleb128();
            if (this.code_off.value != 0) {
                dexFile.parseData(Long.valueOf(this.code_off.value), code_item.class, stream);
            }
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;

            method_id_item method = dexFile.method_ids[this.method_idx_diff.value];
            addNode(parentNode,
                    floatPos,
                    this.method_idx_diff.length,
                    "method_idx_diff",
                    String.format(FORMAT_STRING_STRING, this.method_idx_diff, (method == null) ? "null (should not happen)" : method.toString(dexFile)),
                    "msg_encoded_method__method_idx_diff",
                    Icons.Index);
            floatPos += this.method_idx_diff.length;

            addNode(parentNode,
                    floatPos,
                    this.access_flags.length,
                    "access_flags",
                    this.access_flags.toString() + " - " + BytesTool.getBinaryString(this.access_flags.value) + access_flag.getMethodModifier(this.access_flags.value),
                    "msg_encoded_method__access_flags",
                    Icons.AccessFlag
            );

            DefaultMutableTreeNode codeoffNode = addNode(parentNode,
                    floatPos,
                    this.code_off.length,
                    "code_off",
                    this.code_off,
                    "msg_encoded_method__code_off",
                    Icons.Offset);
            if (this.code_off.value != 0) {
                code_item item = (code_item) dexFile.data.get(Long.valueOf(this.code_off.value));
                DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        item.getStartPos(),
                        item.getLength(),
                        code_item.class.getSimpleName(),
                        Icons.Shortcut,
                        MESSAGES.getString("msg_code_item")
                ));
                codeoffNode.add(itemNode);
                item.generateTreeNode(itemNode, dexFile);
            }
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/class_def_item.java`:

```java
/*
 * class_def_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class class_def_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * Item Size In Bytes.
     *
     * @see map_list.TypeCodes#TYPE_CLASS_DEF_ITEM
     */
    public static final int ITEM_SIZE = 0x20;

    /**
     * index into the type_ids list for this class. This must be a class type,
     * and not an array or primitive type.
     */
    public final Type_uint class_idx;
    private String clazz_jls;

    /**
     * access flags for the class (public, final, etc.). See "access_flags
     * Definitions" for details.
     */
    public final Type_uint access_flags;

    /**
     * index into the type_ids list for the superclass, or the constant value
     * NO_INDEX if this class has no superclass (i.e., it is a root class such
     * as Object). If present, this must be a class type, and not an array or
     * primitive type.
     */
    public final Type_uint superclass_idx;
    private String superclass_jls = null;

    /**
     * offset from the start of the file to the list of interfaces, or 0 if
     * there are none. This offset should be in the data section, and the data
     * there should be in the format specified by "type_list" below. Each of the
     * elements of the list must be a class type (not an array or primitive
     * type), and there must not be any duplicates.
     */
    public final Type_uint interfaces_off;
    private type_list interfaces = null;

    /**
     * index into the string_ids list for the name of the file containing the
     * original source for (at least most of) this class, or the special value
     * NO_INDEX to represent a lack of this information. The debug_info_item of
     * any given method may override this source file, but the expectation is
     * that most classes will only come from one source file.
     */
    public final Type_uint source_file_idx;
    private String source_file = null;

    /**
     * offset from the start of the file to the annotations structure for this
     * class, or 0 if there are no annotations on this class. This offset, if
     * non-zero, should be in the data section, and the data there should be in
     * the format specified by "annotations_directory_item" below, with all
     * items referring to this class as the definer.
     */
    public final Type_uint annotations_off;
    private annotations_directory_item annotations = null;

    /**
     * offset from the start of the file to the associated class data for this
     * item, or 0 if there is no class data for this class. (This may be the
     * case, for example, if this class is a marker interface.) The offset, if
     * non-zero, should be in the data section, and the data there should be in
     * the format specified by "class_data_item" below, with all items referring
     * to this class as the definer.
     */
    public final Type_uint class_data_off;

    /**
     * offset from the start of the file to the list of initial values for
     * static fields, or 0 if there are none (and all static fields are to be
     * initialized with 0 or null). This offset should be in the data section,
     * and the data there should be in the format specified by
     * "encoded_array_item" below. The size of the array must be no larger than
     * the number of static fields declared by this class, and the elements
     * correspond to the static fields in the same order as declared in the
     * corresponding field_list. The type of each array element must match the
     * declared type of its corresponding field. If there are fewer elements in
     * the array than there are static fields, then the leftover fields are
     * initialized with a type-appropriate 0 or null.
     */
    public final Type_uint static_values_off;

    class_def_item(final PosDataInputStreamDex stream, final DexFile dex) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.class_idx = stream.Dex_uint();
        this.access_flags = stream.Dex_uint();
        this.superclass_idx = stream.Dex_uint();
        this.interfaces_off = stream.Dex_uint();
        this.source_file_idx = stream.Dex_uint();
        this.annotations_off = stream.Dex_uint();
        this.class_data_off = stream.Dex_uint();
        if (this.class_data_off.value != 0) {
            dex.parseData(this.class_data_off.value, class_data_item.class, stream);
        }

        this.static_values_off = stream.Dex_uint();
        super.length = stream.getPos() - super.startPos;
    }

    /**
     * Get {@link #class_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return class name in JLS format
     * @see #class_idx
     */
    public String get_class_jls(DexFile dexFile) {
        if (this.clazz_jls == null) {
            this.clazz_jls = dexFile.type_ids[this.class_idx.intValue()].get_descriptor_jls(dexFile).toString();
        }
        return this.clazz_jls;
    }

    /**
     * Get {@link #superclass_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return super class name in JLS format
     * @see #superclass_idx
     */
    public String get_superclass_jls(DexFile dexFile) {
        if (this.superclass_jls == null) {
            this.superclass_jls = (this.superclass_idx.value == DexFile.NO_INDEX)
                    ? ""
                    : dexFile.type_ids[this.superclass_idx.intValue()].get_descriptor_jls(dexFile).toString();
        }
        return this.superclass_jls;
    }

    /**
     * Get {@link #interfaces_off} value.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link type_list} value if {@link #interfaces_off} is not
     * <code>0</code>, or else <code>null</code>
     * @see #interfaces_off
     */
    public type_list get_interfaces(DexFile dexFile) {
        if (this.interfaces_off.value == 0) {
            return null;
        }

        if (this.interfaces == null) {
            this.interfaces = (type_list) dexFile.data.get(this.interfaces_off.value);
        }
        return this.interfaces;
    }

    public String get_interfaces_desc(DexFile dexFile) {
        type_list types = this.get_interfaces(dexFile);
        return (types == null) ? "(no interface)" : types.toString(dexFile);
    }

    /**
     * Get {@link #annotations_off} value.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link annotations_directory_item} value if
     * {@link #annotations_off} is not <code>0</code>, or else <code>null</code>
     * @see #annotations_off
     */
    public annotations_directory_item get_annotations(DexFile dexFile) {
        if (this.annotations_off.value == 0) {
            return null;
        }

        if (this.annotations == null) {
            this.annotations = (annotations_directory_item) dexFile.data.get(this.annotations_off.value);
        }
        return this.annotations;
    }

    /**
     * Get {@link #source_file_idx} value.
     *
     * @param dexFile Current {@link DexFile}
     * @return source file
     * @see #source_file_idx
     */
    public String get_source_file(DexFile dexFile) {
        if (this.source_file == null) {
            this.source_file = (this.source_file_idx.value == 0 || this.source_file_idx.value == DexFile.NO_INDEX)
                    ? "(lack of information)"
                    : dexFile.get_string_ids_string(this.source_file_idx.intValue());
        }
        return this.source_file;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;
        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "class_idx",
                String.format(FORMAT_STRING_STRING, this.class_idx, this.get_class_jls(dexFile)),
                "msg_class_def_item__class_idx",
                Icons.Index);
        floatPos += Type_uint.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "access_flags",
                this.access_flags.toString() + " - " + BytesTool.getBinaryString(this.access_flags.value) + access_flag.getClassModifier(this.access_flags.intValue()),
                "msg_class_def_item__access_flags",
                Icons.AccessFlag
        );
        floatPos += Type_uint.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "superclass_idx",
                String.format(FORMAT_STRING_STRING, this.superclass_idx, this.get_superclass_jls(dexFile)),
                "msg_class_def_item__superclass_idx",
                Icons.Index);
        floatPos += Type_uint.LENGTH;

        DefaultMutableTreeNode ifsOffsetNode = addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "interfaces_off",
                String.format(FORMAT_STRING_STRING, this.interfaces_off, this.get_interfaces_desc(dexFile)),
                "msg_class_def_item__interfaces_off",
                Icons.Offset);
        floatPos += Type_uint.LENGTH;

        type_list ifs = this.get_interfaces(dexFile);
        if (ifs != null) {
            DefaultMutableTreeNode ifsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    ifs.getStartPos(),
                    ifs.getLength(),
                    type_list.class.getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_class_def_item__interfaces_off")
            ));
            ifsOffsetNode.add(ifsNode);
            ifs.generateTreeNode(ifsNode, dexFile);
        }

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "source_file_idx",
                String.format(FORMAT_STRING_STRING, this.source_file_idx, this.get_source_file(dexFile)),
                "msg_class_def_item__source_file_idx",
                Icons.Index);
        floatPos += Type_uint.LENGTH;

        DefaultMutableTreeNode ansOffsetNode = addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "annotations_off",
                this.annotations_off,
                "msg_class_def_item__annotations_off",
                Icons.Offset);
        floatPos += Type_uint.LENGTH;

        annotations_directory_item ans = this.get_annotations(dexFile);
        if (ans != null) {
            DefaultMutableTreeNode ansNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    ans.getStartPos(),
                    ans.getLength(),
                    annotations_directory_item.class.getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_annotations_directory_item")
            ));
            ansOffsetNode.add(ansNode);
            ans.generateTreeNode(ansNode, dexFile);
        }

        DefaultMutableTreeNode offNode = addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "class_data_off",
                this.class_data_off,
                "msg_class_def_item__class_data_off",
                Icons.Offset);
        floatPos += Type_uint.LENGTH;
        if (this.class_data_off.value != 0) {
            class_data_item item = (class_data_item) dexFile.data.get(this.class_data_off.value);
            DefaultMutableTreeNode itemNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    item.getStartPos(),
                    item.getLength(),
                    item.getClass().getSimpleName(),
                    Icons.Shortcut,
                    MESSAGES.getString("msg_class_data_item")
            ));
            offNode.add(itemNode);
            item.generateTreeNode(itemNode, dexFile);
        }

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "static_values_off",
                this.static_values_off,
                "msg_class_def_item__static_values_off",
                Icons.Offset);

    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/code_item.java`:

```java
/*
 * code_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class code_item extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_ushort registers_size;
    public final Type_ushort ins_size;
    public final Type_ushort outs_size;
    public final Type_ushort tries_size;
    public final Type_uint debug_info_off;

    public final Type_uint insns_size;
    public final Type_ushort[] insns;

    public final Type_ushort padding;
    public final try_item[] tries;
    public final encoded_catch_handler_list handlers;

    code_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();

        this.registers_size = stream.Dex_ushort();
        this.ins_size = stream.Dex_ushort();
        this.outs_size = stream.Dex_ushort();
        this.tries_size = stream.Dex_ushort();
        this.debug_info_off = stream.Dex_uint();
        // TODO Parse debug info

        this.insns_size = stream.Dex_uint();
        if (this.insns_size.value > 0) {
            DexFile.check_uint("code_item.insns_size", this.insns_size, stream.getPos());
            this.insns = new Type_ushort[(int) this.insns_size.value];
            for (int i = 0; i < this.insns_size.value; i++) {
                this.insns[i] = stream.Dex_ushort();
            }
        } else {
            this.insns = null;
        }

        // This element is only present if tries_size is non-zero and insns_size is odd.
        if (this.tries_size.value != 0 && ((this.insns_size.value & 1) == 1)) {
            this.padding = stream.Dex_ushort();
        } else {
            this.padding = null;
        }

        if (this.tries_size.value > 0) {
            this.tries = new try_item[this.tries_size.value];
            for (int i = 0; i < this.tries_size.value; i++) {
                this.tries[i] = new try_item(stream);
            }
            this.handlers = new encoded_catch_handler_list(stream);
        } else {
            this.tries = null;
            this.handlers = null;
        }


        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat dexFile) {
        int floatPos = super.startPos;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "registers_size", this.registers_size, "msg_code_item__registers_size", Icons.Size);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "ins_size", this.ins_size, "msg_code_item__ins_size", Icons.Size);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "outs_size", this.outs_size, "msg_code_item__outs_size", Icons.Size);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "tries_size", this.tries_size, "msg_code_item__tries_size", Icons.Size);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_uint.LENGTH, "debug_info_off", this.debug_info_off, "msg_code_item__debug_info_off", Icons.Offset);
    }


    public static class try_item extends FileComponent implements GenerateTreeNode {

        public final Type_uint start_addr;
        public final Type_ushort insn_count;
        public final Type_ushort handler_off;

        try_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.start_addr = stream.Dex_uint();
            this.insn_count = stream.Dex_ushort();
            this.handler_off = stream.Dex_ushort();
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            // TODO
        }
    }

    public static class encoded_catch_handler_list extends FileComponent implements GenerateTreeNode {

        public final Type_uleb128 size;
        public final encoded_catch_handler[] list;

        encoded_catch_handler_list(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.size = stream.Dex_uleb128();
            if (this.size.value > 0) {
                this.list = new encoded_catch_handler[this.size.value];
                for (int i = 0; i < this.size.value; i++) {
                    this.list[i] = new encoded_catch_handler(stream);
                }
            } else {
                this.list = null;
            }
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            // TODO
        }
    }

    public static class encoded_catch_handler extends FileComponent implements GenerateTreeNode {

        public final Type_sleb128 size;
        public final encoded_type_addr_pair[] handlers;
        public final Type_uleb128 catch_all_addr;

        encoded_catch_handler(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();

            this.size = stream.Dex_sleb128();
            final int sizeAbs = Math.abs(this.size.value);
            if (sizeAbs > 0) {
                this.handlers = new encoded_type_addr_pair[sizeAbs];
                for (int i = 0; i < sizeAbs; i++) {
                    this.handlers[i] = new encoded_type_addr_pair(stream);
                }
            } else {
                this.handlers = null;
            }

            if (this.size.value <= 0) {
                this.catch_all_addr = stream.Dex_uleb128();
            } else {
                this.catch_all_addr = null;
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            // TODO
        }
    }

    public static class encoded_type_addr_pair extends FileComponent implements GenerateTreeNode {

        public final Type_uleb128 type_idx;
        public final Type_uleb128 addr;

        encoded_type_addr_pair(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.type_idx = stream.Dex_uleb128();
            this.addr = stream.Dex_uleb128();
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            throw new UnsupportedOperationException("Not supported yet 5.");
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/debug_info_item.java`:

```java
/*
 * debug_info_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import org.binaryinternals.commonlib.core.FileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class debug_info_item extends FileComponent{
    
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/encoded_annotation.java`:

```java
/*
 * encoded_annotation.java    Aug 24, 2021
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class encoded_annotation extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_uleb128 type_idx;
    private String type_jls = null;
    public final Type_uleb128 size;
    public final annotation_element[] elements;

    encoded_annotation(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.type_idx = stream.Dex_uleb128();

        this.size = stream.Dex_uleb128();
        if (this.size.value > 0) {
            this.elements = new annotation_element[this.size.value];
            for (int i = 0; i < this.size.value; i++) {
                this.elements[i] = new annotation_element(stream);
            }
        } else {
            this.elements = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    /**
     * Get {@link #type_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return type name in JLS format
     * @see #type_idx
     */
    public String get_type_jls(DexFile dexFile) {
        if (this.type_jls == null) {
            this.type_jls = dexFile.type_ids[this.type_idx.value].get_descriptor_jls(dexFile).toString();
        }
        return this.type_jls;
    }

    public String toString(DexFile dexFile) {
        return String.format("%s type=%d | %s size=%d",
                this.getClass().getSimpleName(),
                this.type_idx.value,
                this.get_type_jls(dexFile),
                this.size.value);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;
        addNode(parentNode,
                floatPos,
                this.type_idx.length,
                "type_idx",
                String.format(FORMAT_STRING_STRING, this.type_idx, dexFile.get_type_ids_string(this.type_idx.value)),
                "msg_encoded_annotation__type_idx",
                Icons.Index);
        floatPos += this.type_idx.length;

        addNode(parentNode,
                floatPos,
                this.size.length,
                "size",
                this.size,
                "msg_encoded_annotation__size",
                Icons.Size);
        floatPos += this.size.length;

        if (this.elements != null) {
            DefaultMutableTreeNode elementsNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    floatPos,
                    this.length - this.type_idx.length - this.size.length,
                    String.format("elements [%d]", this.elements.length),
                    Icons.Data,
                    MESSAGES.getString("msg_encoded_annotation__elements")
            ));
            parentNode.add(elementsNode);

            for (int i = 0; i < this.elements.length; i++) {
                annotation_element element = this.elements[i];

                // Dev phase only
                if (element == null) {
                    continue;
                }

                DefaultMutableTreeNode elementNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        element.getStartPos(),
                        element.getLength(),
                        String.format("%s[%d]", annotation_element.class.getSimpleName(), i),
                        Icons.Data,
                        MESSAGES.getString("msg_encoded_annotation__elements")
                ));

                elementsNode.add(elementNode);
                element.generateTreeNode(elementNode, dexFile);
            }

        }

    }

    public static class annotation_element extends FileComponent implements GenerateTreeNodeDexFile {
        private static final Logger LOGGER = Logger.getLogger(annotation_element.class.getName());
        public final Type_uleb128 name_idx;
        public encoded_value value;

        annotation_element(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.name_idx = stream.Dex_uleb128();

            try {  // TODO Dev phase only
                this.value = new encoded_value(stream);
            } catch (FileFormatException e) {
                // This should never happen
                LOGGER.log(Level.SEVERE, e.getMessage(), e);
            }

            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
            DexFile dexFile = (DexFile)format;
            int floatPos = super.startPos;
            addNode(parentNode,
                    floatPos,
                    this.name_idx.length,
                    "name_idx",
                    String.format(FORMAT_STRING_STRING, this.name_idx, dexFile.get_string_ids_string(this.name_idx.value)),
                    "msg_annotation_element__name_idx",
                    Icons.Index);
            floatPos += this.name_idx.length;

            // Dev phase only
            if (this.value == null) {
                return;
            }

            DefaultMutableTreeNode valueNode = addNode(parentNode,
                    floatPos,
                    this.value.getLength(),
                    "value",
                    this.value,
                    "msg_annotation_element__value",
                    Icons.Data);
            this.value.generateTreeNode(valueNode, dexFile);
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/encoded_array.java`:

```java
/*
 * encoded_array.java    Aug 22, 2021, 16:53
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class encoded_array extends FileComponent implements GenerateTreeNodeDexFile {

    private static final Logger LOGGER = Logger.getLogger(encoded_array.class.getName());
    public final Type_uleb128 size;
    public final encoded_value[] values;

    encoded_array(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.size = stream.Dex_uleb128();
        if (this.size.value > 0) {
            this.values = new encoded_value[this.size.value];
            for (int i = 0; i < this.size.value; i++) {
                try {
                    this.values[i] = new encoded_value(stream);
                } catch (FileFormatException e) {
                    // This should never happen
                    LOGGER.log(Level.SEVERE, e.getMessage(), e);
                }
            }
        } else {
            this.values = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public String toString() {
        return String.format(FORMAT_STRING_STRING, this.getClass().getSimpleName(), size.toString());
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat dexFile) {
        int floatPos = super.startPos;
        addNode(parentNode,
                floatPos,
                size.length,
                "size",
                this.size,
                "msg_encoded_array__size",
                Icons.Size);
        floatPos += size.length;

        if (this.values != null) {
            DefaultMutableTreeNode valuesNode = addNode(parentNode,
                    floatPos,
                    this.length - this.size.length,
                    "values",
                    this.values.length,
                    "msg_encoded_array__values",
                    Icons.Data
            );

            for (int i = 0; i < this.values.length; i++) {
                encoded_value value = this.values[i];
                if (value != null) {
                    DefaultMutableTreeNode valueNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            value.getStartPos(),
                            value.getLength(),
                            String.format("%s[%d] %s", value.getClass().getSimpleName(), i, value.toString()),
                            Icons.Data,
                            MESSAGES.getString("msg_encoded_value")
                    ));

                    valuesNode.add(valueNode);
                    value.generateTreeNode(valueNode, dexFile);
                } else {
                    // This should never happen
                    LOGGER.log(Level.SEVERE, "{0} at 0x{1} : value[{2}] is null", new Object[]{this.getClass().getSimpleName(), Integer.toHexString(this.getStartPos()), i});
                }
            }
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/encoded_array_item.java`:

```java
/*
 * encoded_array_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class encoded_array_item extends FileComponent implements GenerateTreeNodeDexFile {
    
    public final encoded_array value;

    encoded_array_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.value = new encoded_array(stream);
        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat dexFile) {
        DefaultMutableTreeNode valueNode = addNode(parentNode, super.startPos, this.value.getLength(), "value", this.value, "msg_encoded_array_item__value", Icons.Data);
        this.value.generateTreeNode(valueNode, dexFile);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/encoded_value.java`:

```java
/*
 * encoded_value.java    Aug 22, 2021, 16:56
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class encoded_value extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_ubyte value_arg_and_type;

    /**
     * low-order five (5) bits as value_type.
     */
    public final int value_type;
    /**
     * high-order three (3) bits as value_arg.
     */
    public final int value_arg;

    private Type_ubyte union_value_byte;
    private Type_short union_value_short;
    private Type_ushort union_value_char;
    private Type_int union_value_int;
    private Type_long union_value_long;
    private Float union_value_float;
    private Double union_value_double;
    private Type_uint union_value_method_type;
    private Type_uint union_value_method_handle;
    private Type_uint union_value_string;
    private Type_uint union_value_type;
    private Type_uint union_value_field;
    private Type_uint union_value_method;
    private Type_uint union_value_enum;
    private encoded_array union_value_array;
    private encoded_annotation union_value_annotation;
    private Boolean union_value_bollean;

    /**
     * <pre>
     * java:S3776 - Cognitive Complexity of methods should not be too high --- No, it is not high
     * </pre>
     */
    @SuppressWarnings({"java:S127", "java:S3776"})
    encoded_value(final PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        value_arg_and_type  = stream.Dex_ubyte();

        // In the logic bellow we assume Java int type is still a 32-bit number
        // This should be truth in know future of Java programming language
        this.value_type = (value_arg_and_type.value & 0x0000001F);
        this.value_arg = (value_arg_and_type.value & 0x000000E0) >> 5;

        ValueFormat format = ValueFormat.valueOf(this.value_type);
        if (format == null) {
            throw new FileFormatException(String.format("Unrecognized value_type (%d) at location 0x%08X", this.value_type, stream.getPos()));
        }

        switch (format) {
            case VALUE_BYTE:
                this.union_value_byte = stream.Dex_ubyte();
                break;
            case VALUE_SHORT:
                this.union_value_short = this.read_short(stream, this.value_arg);
                break;
            case VALUE_CHAR:
                this.union_value_char = this.read_char(stream, this.value_arg);
                break;
            case VALUE_INT:
                this.union_value_int = this.read_int(stream, this.value_arg);
                break;
            case VALUE_LONG:
                this.union_value_long = this.read_long(stream, this.value_arg);
                break;
            case VALUE_FLOAT:
                this.union_value_float = stream.readFloat(this.value_arg + 1);
                break;
            case VALUE_DOUBLE:
                this.union_value_double = stream.readDouble(this.value_arg + 1);
                break;
            case VALUE_METHOD_TYPE:
                this.union_value_method_type = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_METHOD_HANDLE:
                this.union_value_method_handle = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_STRING:
                this.union_value_string = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_TYPE:
                this.union_value_type = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_FIELD:
                this.union_value_field = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_METHOD:
                this.union_value_method = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_ENUM:
                this.union_value_enum = this.read_uint(stream, this.value_arg);
                break;
            case VALUE_ARRAY:
                this.union_value_array = new encoded_array(stream);
                break;
            case VALUE_ANNOTATION:
                this.union_value_annotation = new encoded_annotation(stream);
                break;
            case VALUE_BOOLEAN:
                this.union_value_bollean = (this.value_arg == 1);
                break;
            case VALUE_NULL:
            default:
                this.union_value_byte = null;
                this.union_value_short = null;
                this.union_value_char = null;
                this.union_value_int = null;
                this.union_value_long = null;
                this.union_value_float = null;
                this.union_value_double = null;
                this.union_value_method_type = null;
                this.union_value_method_handle = null;
                this.union_value_string = null;
                this.union_value_type = null;
                this.union_value_field = null;
                this.union_value_method = null;
                this.union_value_enum = null;
                this.union_value_array = null;
                this.union_value_annotation = null;
                this.union_value_bollean = null;
                break;
        }

        super.length = stream.getPos() - super.startPos;
    }

    public Type_ubyte get_value_byte() {
        return this.union_value_byte;
    }

    public Type_short get_value_short() {
        return this.union_value_short;
    }
    public Type_ushort get_value_char() {
        return this.union_value_char;
    }
    public Type_int get_value_int() {
        return this.union_value_int;
    }
    public Type_long get_value_long() {
        return this.union_value_long;
    }
    public Float get_value_float() {
        return this.union_value_float;
    }
    public Double get_value_double() {
        return this.union_value_double;
    }
    public Type_uint get_value_method_type() {
        return this.union_value_method_type;
    }
    public Type_uint get_value_method_handle() {
        return this.union_value_method_handle;
    }
    public Type_uint get_value_string() {
        return this.union_value_string;
    }
    public Type_uint get_value_type() {
        return this.union_value_type;
    }
    public Type_uint get_value_field() {
        return this.union_value_field;
    }
    public Type_uint get_value_method() {
        return this.union_value_method;
    }
    public Type_uint get_value_enum() {
        return this.union_value_enum;
    }
    public encoded_array get_value_array() {
        return this.union_value_array;
    }
    public encoded_annotation get_value_annotation() {
        return this.union_value_annotation;
    }
    public Boolean get_value_bollean() {
        return this.union_value_bollean;
    }

    private Type_long read_long(final PosDataInputStreamDex stream, final int arg) throws FileFormatException, IOException{
        Type_long result = null;
        switch (arg) {
            case 0:
                result = new Type_long(stream.Dex_byte().value);
                break;

            case 1:
                result = new Type_long(stream.Dex_short().value);
                break;

            case 2:
                result = new Type_long(stream.Dex_int3().value);
                if (result.value < 0) {
                    System.out.println(this.getClass().getSimpleName() + String.format(" : read_long for triple bytes (minus value) at 0x%X ======= to verify =======", stream.getPos()) );
                }
                break;

            case 3:
                result = new Type_long(stream.Dex_int().value);
                break;

            case 4:
            case 5:
            case 6:
                result = stream.Dex_long(arg + 1);
                break;

            case 7:
                result = stream.Dex_long();
                break;

            default:
                throw new FileFormatException(String.format("Unrecognized value_arg (%d) in %s for int at location 0x%08X",
                        arg,
                        this.getClass().getSimpleName(),
                        stream.getPos())
                );
        }

        return result;
    }

    private Type_short read_short(final PosDataInputStreamDex stream, final int arg) throws FileFormatException, IOException{
        Type_short result = null;
        switch (arg) {
            case 0:
                result = new Type_short(stream.Dex_byte().value);
                break;
            case 1:
                result = stream.Dex_short();
                break;
            default:
                throw new FileFormatException(String.format("Unrecognized value_arg (%d) for short in %s at location 0x%08X",
                        arg,
                        this.getClass().getSimpleName(),
                        stream.getPos())
                );
        }

        return result;
    }

    private Type_ushort read_char(final PosDataInputStreamDex stream, final int arg) throws FileFormatException, IOException{
        Type_ushort result = null;
        switch (arg) {
            case 0:
                result = new Type_ushort(stream.Dex_ubyte().value);
                break;
            case 1:
                result = stream.Dex_ushort();
                break;
            default:
                throw new FileFormatException(String.format("Unrecognized value_arg (%d) for char/ushort in %s at location 0x%08X",
                        arg,
                        this.getClass().getSimpleName(),
                        stream.getPos())
                );
        }

        return result;

    }

    private Type_int read_int(final PosDataInputStreamDex stream, final int arg) throws FileFormatException, IOException{
        Type_int result = null;
        switch (arg) {
            case 0:
                result = new Type_int(stream.Dex_byte().value);
                break;
            case 1:
                result = new Type_int(stream.Dex_short().value);
                break;
            case 2:
                result = stream.Dex_int3();
                break;
            case 3:
                result = stream.Dex_int();
                break;
            default:
                throw new FileFormatException(String.format("Unrecognized value_arg (%d) in %s for int at location 0x%08X",
                        arg,
                        this.getClass().getSimpleName(),
                        stream.getPos())
                );
        }

        return result;
    }

    private Type_uint read_uint(final PosDataInputStreamDex stream, final int arg) throws FileFormatException, IOException{
        Type_uint result = null;
        switch (arg) {
            case 0:
                result = new Type_uint(stream.Dex_ubyte().value);
                break;
            case 1:
                result = new Type_uint(stream.Dex_ushort().value);
                break;
            case 2:
                result = stream.Dex_uint3();
                break;
            case 3:
                result = stream.Dex_uint();
                break;
            default:
                throw new FileFormatException(String.format("Unrecognized value_arg (%d) in %s for uint at location 0x%08X",
                        arg,
                        this.getClass().getSimpleName(),
                        stream.getPos())
                );
        }

        return result;
    }

    @Override
    @SuppressWarnings({"java:S2259"})
    public String toString() {
        return String.format("%s value_type=%d | %s value_arg=%d",
                this.getClass().getSimpleName(),
                this.value_type,
                ValueFormat.valueOf(this.value_type).name(),
                this.value_arg);
    }

    @Override
    @SuppressWarnings({"java:S2259", "java:S3776"})
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        DexFile dex = (DexFile)fileFormat;
        int floatPos = super.startPos;

        ValueFormat format = ValueFormat.valueOf(this.value_type);
        addNode(parentNode,
                floatPos,
                Type_ubyte.LENGTH,
                "value_arg + value_type",
                String.format("0x%s | %s", Integer.toHexString(this.value_arg_and_type.value), Integer.toBinaryString(this.value_arg_and_type.value)),
                "msg_encoded_value__value_type",
                Icons.Tag
        );
        addNode(parentNode,
                floatPos,
                Type_ubyte.LENGTH,
                "value_type",
                String.format("%d | 0x%s - %s", this.value_type, Integer.toHexString(this.value_type), format.name()),
                "msg_encoded_value__value_type",
                Icons.Tag
        );
        addNode(parentNode,
                floatPos,
                Type_ubyte.LENGTH,
                "value_arg",
                String.format("decimal %d | binary %s", this.value_arg, Integer.toBinaryString(this.value_arg)),
                "msg_encoded_value__value_arg",
                Icons.Parameter
        );
        floatPos += Type_ubyte.LENGTH;

        if (this.union_value_byte != null) {
            addNode(parentNode, floatPos, Type_ubyte.LENGTH, "VALUE_BYTE", this.union_value_byte, "msg_encoded_value__value_byte", Icons.Data);
        } else if (this.union_value_short != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_SHORT", this.union_value_short, "msg_encoded_value__value_short", Icons.Data);
        } else if (this.union_value_char != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_CHAR", this.union_value_char, "msg_encoded_value__value_char", Icons.Data);
        } else if (this.union_value_int != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_INT", this.union_value_int, "msg_encoded_value__value_int", Icons.Data);
        } else if (this.union_value_long != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_LONG", this.union_value_long, "msg_encoded_value__value_long", Icons.Data);
        } else if (this.union_value_float != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_FLOAT", this.union_value_float, "msg_encoded_value__value_float", Icons.Data);
        } else if (this.union_value_double != null) {
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_DOUBLE", this.union_value_double, "msg_encoded_value__value_double", Icons.Data);
        } else if (this.union_value_method_type != null) {
            // TODO for value
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_METHOD_TYPE", this.union_value_method_type, "msg_encoded_value__value_method_type", Icons.Data);
        } else if (this.union_value_method_handle != null) {
            // TODO for value
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_METHOD_HANDLE", this.union_value_method_handle, "msg_encoded_value__value_method_handle", Icons.Data);
        } else if (this.union_value_string != null) {
            addNode(parentNode,
                    floatPos,
                    this.value_arg + 1,
                    "VALUE_STRING",
                    String.format(FORMAT_STRING_STRING, this.union_value_string, dex.get_string_ids_string(this.union_value_string.intValue())),
                    "msg_encoded_value__value_string",
                    Icons.Data);
        } else if (this.union_value_type != null) {
            // TODO for value
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_TYPE", this.union_value_type, "msg_encoded_value__type", Icons.Data);
        } else if (this.union_value_field != null) {
            // TODO for value
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_FIELD", this.union_value_field, "msg_encoded_value__value_field", Icons.Data);
        } else if (this.union_value_method != null) {
            // TODO for value
            addNode(parentNode, floatPos, this.value_arg + 1, "VALUE_METHOD", this.union_value_method, "msg_encoded_value__value_method", Icons.Data);
        } else if (this.union_value_enum != null) {
            field_id_item fieldId = dex.field_ids[this.union_value_enum.intValue()];
            addNode(parentNode,
                    floatPos,
                    this.value_arg + 1,
                    "VALUE_ENUM",
                    String.format(FORMAT_STRING_STRING, this.union_value_enum, (fieldId == null) ? "null (should not happen)" : fieldId.toString(dex)),
                    "msg_encoded_value__value_enum",
                    Icons.Data);
        } else if (this.union_value_array != null) {
            DefaultMutableTreeNode arrayNode = addNode(parentNode,
                    floatPos, this.union_value_array.getLength(), "VALUE_ARRAY", this.union_value_array, "msg_encoded_value__value_array", Icons.Array);
            this.union_value_array.generateTreeNode(arrayNode, dex);
        } else if (this.union_value_annotation != null) {
            DefaultMutableTreeNode annoNode = addNode(parentNode,
                    floatPos, this.union_value_annotation.getLength(), "VALUE_ANNOTATION", this.union_value_annotation, "msg_encoded_value__value_annotation", Icons.Annotations);
            this.union_value_annotation.generateTreeNode(annoNode, dex);
        } else if (this.union_value_bollean != null) {
            addNode(parentNode, super.startPos, Type_ubyte.LENGTH, "VALUE_BOOLEAN", this.union_value_bollean, "msg_encoded_value__value_boolean", Icons.Data);
        }
    }

    public enum ValueFormat {
        VALUE_BYTE(0x00, 0),
        VALUE_SHORT(0x02, 1),
        VALUE_CHAR(0x03, 1),
        VALUE_INT(0x04, 3),
        VALUE_LONG(0x06, 7),
        VALUE_FLOAT(0x10, 3),
        VALUE_DOUBLE(0x11, 7),
        VALUE_METHOD_TYPE(0x15, 3),
        VALUE_METHOD_HANDLE(0x16, 3),
        VALUE_STRING(0x17, 3),
        VALUE_TYPE(0x18, 3),
        VALUE_FIELD(0x19, 3),
        VALUE_METHOD(0x1a, 3),
        VALUE_ENUM(0x1b, 3),
        VALUE_ARRAY(0x1c, 0),
        VALUE_ANNOTATION(0x1d, 0),
        VALUE_NULL(0x1e, 0),
        VALUE_BOOLEAN(0x1f, 1);

        /**
         * Internal code of the value type.
         */
        public final int code;

        /**
         * Max allowed value for {@link encoded_value#value_arg}
         */
        public final int arg_max;

        private ValueFormat(int i, int m) {
            this.code = i;
            this.arg_max = m;
        }

        /**
         * Get enum item based on {@link #code}.
         *
         * @param value Value to search
         * @return matched {@link ValueFormat} item, else <code>null</code>
         */
        public static ValueFormat valueOf(int value) {
            for (ValueFormat item : values()) {
                if (item.code == value) {
                    return item;
                }
            }
            return null;
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/field_id_item.java`:

```java
/*
 * field_id_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class field_id_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * Item Size In Bytes.
     *
     * @see map_list.TypeCodes#TYPE_FIELD_ID_ITEM
     */
    public static final int ITEM_SIZE = 0x08;

    /**
     * index into the type_ids list for the definer of this field. This must be
     * a class type, and not an array or primitive type.
     */
    public Type_ushort class_idx;
    private String clazz = null;
    private String clazz_jls = null;

    /**
     * index into the type_ids list for the type of this field.
     */
    public Type_ushort type_idx;
    private String type = null;
    private String type_jls = null;

    /**
     * index into the string_ids list for the name of this field. The string
     * must conform to the syntax for MemberName, defined above.
     */
    public Type_uint name_idx;
    private String name = null;

    field_id_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.class_idx = stream.Dex_ushort();
        this.type_idx = stream.Dex_ushort();
        this.name_idx = stream.Dex_uint();
        super.length = stream.getPos() - super.startPos;
    }

    /**
     * Get {@link #class_idx} name.
     *
     * @param dexFile Current {@link DexFile}
     * @return class name
     * @see #class_idx
     */
    public String get_class(DexFile dexFile) {
        if (this.clazz == null) {
            this.clazz = dexFile.get_type_ids_string(class_idx.value);
        }
        return this.clazz;
    }

    /**
     * Get {@link #class_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return class name in JLS format
     * @see #class_idx
     */
    public String get_class_jls(DexFile dexFile) {
        if (this.clazz_jls == null) {
            this.clazz_jls = dexFile.type_ids[class_idx.value].get_descriptor_jls(dexFile).toString();
        }
        return this.clazz_jls;
    }

    /**
     * Get {@link #type_idx} name.
     *
     * @param dexFile Current {@link DexFile}
     * @return type name
     * @see #type_idx
     */
    public String get_type(DexFile dexFile) {
        if (this.type == null) {
            this.type = dexFile.get_type_ids_string(type_idx.value);
        }
        return this.type;
    }

    /**
     * Get {@link #type_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return type name in JLS format
     * @see #type_idx
     */
    public String get_type_jls(DexFile dexFile) {
        if (this.type_jls == null) {
            this.type_jls = dexFile.type_ids[type_idx.value].get_descriptor_jls(dexFile).toString();
        }
        return this.type_jls;
    }

    /**
     * Get {@link #name_idx} name.
     *
     * @param dexFile Current {@link DexFile}
     * @return field name
     * @see #name_idx
     */
    public String get_name(DexFile dexFile) {
        if (this.name == null) {
            this.name = dexFile.get_string_ids_string(name_idx.intValue());
        }
        return this.name;
    }

    /**
     * String format of current {@link field_id_item}.
     *
     * @param dexFile Current {@link DexFile}
     * @return String format of a field
     */
    public String toString(DexFile dexFile) {
        return String.format("%s  %s.%s",
                this.get_type_jls(dexFile),
                this.get_class_jls(dexFile),
                this.get_name(dexFile)
        );
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;

        addNode(parentNode,
                floatPos,
                Type_ushort.LENGTH,
                "class_idx",
                String.format(FORMAT_STRING_STRING, this.class_idx, this.get_class_jls(dexFile)),
                "msg_field_id_item__class_idx",
                Icons.Index);
        floatPos += Type_ushort.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_ushort.LENGTH,
                "type_idx",
                String.format(FORMAT_STRING_STRING, this.type_idx, this.get_type_jls(dexFile)),
                "msg_field_id_item__type_idx",
                Icons.Index);
        floatPos += Type_ushort.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "name_idx",
                String.format(FORMAT_STRING_STRING, this.name_idx, this.get_name(dexFile)),
                "msg_field_id_item__name_idx",
                Icons.Index);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/header_item.java`:

```java
/*
 * header_item.java    June 18, 2015, 22:34
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <code>header_item</code> structure of the DEX file.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class header_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * @see map_list.TypeCodes#TYPE_HEADER_ITEM
     */
    public static final int ITEM_SIZE = 0x70;

    /**
     * adler32 checksum of the rest of the file (everything but magic and this
     * field); used to detect file corruption.
     */
    public final Type_uint checksum;

    /**
     * SHA-1 signature (hash) of the rest of the file (everything but {@link DexFile#DEX_FILE_MAGIC1}, {@link DexFile#DEX_FILE_MAGIC2},
     * {@link #checksum}, and this field {@link #signature}); used to uniquely
     * identify files.
     */
    public final Type_ubyte[] signature = new Type_ubyte[20];

    /**
     * size of the entire file (including the {@link header_item}), in bytes.
     */
    public final Type_uint file_size;

    /**
     * size of the header (this entire section), in bytes. This allows for at
     * least a limited amount of backwards/forwards compatibility without
     * invalidating the format.
     */
    public final Type_uint header_size = new Type_uint(0x70);

    /**
     * Endianness tag. The value is either {@link Endian#ENDIAN_CONSTANT} or
     * {@link Endian#REVERSE_ENDIAN_CONSTANT}.
     */
    public final Type_uint endian_tag;
    /**
     * Size of the link section, or 0 if this file isn't statically linked.
     */
    public final Type_uint link_size;
    /**
     * Offset from the start of the file to the link section, or 0 if
     * {@link #link_size} == 0. The offset, if non-zero, should be to an offset
     * into the {@link DexFile#link_data} section. The format of the data
     * pointed at is left unspecified by this document; this header field (and
     * the previous) are left as hooks for use by runtime implementations.
     */
    public final Type_uint link_off;
    public final Type_uint map_off;
    public final Type_uint string_ids_size;
    public final Type_uint string_ids_off;
    public final Type_uint type_ids_size;
    public final Type_uint type_ids_off;
    public final Type_uint proto_ids_size;
    public final Type_uint proto_ids_off;
    public final Type_uint field_ids_size;
    public final Type_uint field_ids_off;
    public final Type_uint method_ids_size;
    public final Type_uint method_ids_off;
    public final Type_uint class_defs_size;
    public final Type_uint class_defs_off;
    public final Type_uint data_size;
    public final Type_uint data_off;

    header_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();

        this.checksum = stream.Dex_uint();
        for (int i = 0; i < this.signature.length; i++) {
            this.signature[i] = stream.Dex_ubyte();
        }
        this.file_size = stream.Dex_uint();
        BytesTool.skip(stream, Type_uint.LENGTH);
        this.endian_tag = new Type_uint(stream.readUnsignedInt()); // Always read from left to right
        this.link_size = stream.Dex_uint();
        this.link_off = stream.Dex_uint();
        this.map_off = stream.Dex_uint();
        this.string_ids_size = stream.Dex_uint();
        this.string_ids_off = stream.Dex_uint();
        this.type_ids_size = stream.Dex_uint();
        this.type_ids_off = stream.Dex_uint();
        this.proto_ids_size = stream.Dex_uint();
        this.proto_ids_off = stream.Dex_uint();
        this.field_ids_size = stream.Dex_uint();
        this.field_ids_off = stream.Dex_uint();
        this.method_ids_size = stream.Dex_uint();
        this.method_ids_off = stream.Dex_uint();
        this.class_defs_size = stream.Dex_uint();
        this.class_defs_off = stream.Dex_uint();
        this.data_size = stream.Dex_uint();
        this.data_off = stream.Dex_uint();

        super.length = this.header_size.intValue() - DexFile.DEX_FILE_MAGIC1.length - DexFile.DEX_FILE_MAGIC2.length;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        DefaultMutableTreeNode nodeTemp;
        int floatPos = this.getStartPos();

        DefaultMutableTreeNode headerNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                this.getLength(),
                "header_item"));
        parentNode.add(headerNode);

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "checksum", this.checksum, "msg_header_item_checksum", Icons.Checksum);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, this.signature.length, "signature", Type_ubyte.toString(this.signature), "msg_header_item_signature", Icons.Signature);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "file_size", this.file_size, "msg_header_item_file_size", Icons.Size);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "header_size", this.header_size, "msg_header_item_header_size", Icons.Size);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                floatPos,
                Type_uint.LENGTH,
                "endian_tag: " + this.endian_tag.toString() + " / " + Endian.toString(this.endian_tag.intValue()),
                Icons.Endian,
                GenerateTreeNodeDexFile.MESSAGES.getString("msg_header_item_endian_tag")
        )));
        floatPos += Type_uint.LENGTH;

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "link_size", this.link_size, "msg_header_item_link_size", Icons.Size);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "link_off", this.link_off, "msg_header_item_link_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "map_off", this.map_off, "msg_header_item_map_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "string_ids_size", this.string_ids_size, "msg_header_item_string_ids_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "string_ids_off", this.string_ids_off, "msg_header_item_string_ids_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "type_ids_size", this.type_ids_size, "msg_header_item_type_ids_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "type_ids_off", this.type_ids_off, "msg_header_item_type_ids_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "proto_ids_size", this.proto_ids_size, "msg_header_item_proto_ids_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "proto_ids_off", this.proto_ids_off, "msg_header_item_proto_ids_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "field_ids_size", this.field_ids_size, "msg_header_item_field_ids_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "field_ids_off", this.field_ids_off, "msg_header_item_field_ids_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "method_ids_size", this.method_ids_size, "msg_header_item_method_ids_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "method_ids_off", this.method_ids_off, "msg_header_item_method_ids_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "class_defs_size", this.class_defs_size, "msg_header_item_class_defs_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "class_defs_off", this.class_defs_off, "msg_header_item_class_defs_off", Icons.Offset);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        nodeTemp = addNode(headerNode, floatPos, Type_uint.LENGTH, "data_size", this.data_size, "msg_header_item_data_size", Icons.Counter);
        floatPos = ((JTreeNodeFileComponent)nodeTemp.getUserObject()).getLastPosPlus1();

        addNode(headerNode, floatPos, Type_uint.LENGTH, "data_off", this.data_off, "msg_header_item_data_off", Icons.Offset);
    }


    /**
     * The constant {@link Endian#ENDIAN_CONSTANT} is used to indicate the
     * endianness of the file in which it is found. Although the standard .dex
     * format is little-endian, implementations may choose to perform
     * byte-swapping. Should an implementation come across a header whose
     * endian_tag is {@link Endian#REVERSE_ENDIAN_CONSTANT} instead of
     * {@link Endian#ENDIAN_CONSTANT}, it would know that the file has been
     * byte-swapped from the expected form.
     */
    public enum Endian {

        /**
         * Little-endian, which is DEX standard.
         */
        ENDIAN_CONSTANT(0x12345678),
        /**
         * Big-endian.
         */
        REVERSE_ENDIAN_CONSTANT(0x78563412);

        /**
         * Internal value of the endianness.
         */
        public final int value;
        public final int byte1;
        public final int byte2;
        public final int byte3;
        public final int byte4;

        private Endian(int i) {
            this.value = i;
            this.byte1 = i >> 24;
            this.byte2 = (i << 8) >> 24;
            this.byte3 = (i << 16) >> 24;
            this.byte4 = (i << 24) >> 24;
        }

        public boolean equals(int i1, int i2, int i3, int i4) {
            return (i1 == this.byte1) && (i2 == this.byte2) && (i3 == this.byte3) && (i4 == this.byte4);
        }

        public static String toString(int i) {
            if (Endian.ENDIAN_CONSTANT.value == i) {
                return Endian.ENDIAN_CONSTANT.name();
            } else if (Endian.REVERSE_ENDIAN_CONSTANT.value == i) {
                return Endian.REVERSE_ENDIAN_CONSTANT.name();
            } else {
                return "Un-recognized !!!";
            }
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/map_list.java`:

```java
/*
 * map_list.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.format.dex.annotation_set_item.annotation_item;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class map_list extends FileComponent implements GenerateTreeNode {

    public final Type_uint size;
    public final map_item[] list;

    map_list(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();

        this.size = stream.Dex_uint();
        DexFile.check_uint("map_list.size", this.size, stream.getPos());

        if (this.size.value > 0) {
            this.list = new map_item[(int) this.size.value];
            for (int i = 0; i < this.size.value; i++) {
                this.list[i] = new map_item(stream);
            }
        } else {
            this.list = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public static class map_item extends FileComponent implements GenerateTreeNode {

        /**
         * Item Size In Bytes.
         *
         * @see map_list.TypeCodes#TYPE_MAP_LIST
         */
        public static final int ITEM_SIZE = 12;

        public final Type_ushort type;
        public final Type_ushort unused;
        public final Type_uint size;
        public final Type_uint offset;

        map_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.type = stream.Dex_ushort();
            this.unused = stream.Dex_ushort();
            this.size = stream.Dex_uint();
            this.offset = stream.Dex_uint();
            super.length = stream.getPos() - super.startPos;
        }

        @Override
        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            throw new UnsupportedOperationException("Not supported yet.");
        }
    }

    public enum TypeCodes {
        TYPE_HEADER_ITEM(header_item.class, 0x0000),
        TYPE_STRING_ID_ITEM(string_id_item.class, 0x0001),
        TYPE_TYPE_ID_ITEM(type_id_item.class, 0x0002),
        TYPE_PROTO_ID_ITEM(proto_id_item.class, 0x0003),
        TYPE_FIELD_ID_ITEM(field_id_item.class, 0x0004),
        TYPE_METHOD_ID_ITEM(method_id_item.class, 0x0005),
        TYPE_CLASS_DEF_ITEM(class_def_item.class, 0x0006),
        TYPE_CALL_SITE_ID_ITEM(null, 0x0007),
        TYPE_METHOD_HANDLE_ITEM(method_handle_item.class, 0x0008),
        TYPE_MAP_LIST(map_list.class, 0x1000),
        TYPE_TYPE_LIST(type_list.class, 0x1001),
        TYPE_ANNOTATION_SET_REF_LIST(annotation_set_ref_list.class, 0x1002),
        TYPE_ANNOTATION_SET_ITEM(annotation_set_item.class, 0x1003),
        TYPE_CLASS_DATA_ITEM(class_data_item.class, 0x2000),
        TYPE_CODE_ITEM(code_item.class, 0x2001),
        TYPE_STRING_DATA_ITEM(string_data_item.class, 0x2002),
        TYPE_DEBUG_INFO_ITEM(debug_info_item.class, 0x2003),
        TYPE_ANNOTATION_ITEM(annotation_item.class, 0x2004),
        TYPE_ENCODED_ARRAY_ITEM(encoded_array_item.class, 0x2005),
        TYPE_ANNOTATIONS_DIRECTORY_ITEM(annotations_directory_item.class, 0x2006),
        TYPE_HIDDENAPI_CLASS_DATA_ITEM(null, 0xF000);

        public final Type_ushort value;
        final Class<?> item_type;

        private TypeCodes(Class<?> clazz, int value) {
            this.value = new Type_ushort(value);
            this.item_type = clazz;
        }

    }

}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/method_handle_item.java`:

```java
/*
 * method_handle_item.java    Aug 17, 2021, 19:16
 *
 * Copyright 2021, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class method_handle_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * Item Size In Bytes.
     *
     * @see map_list.TypeCodes#TYPE_METHOD_HANDLE_ITEM
     */
    public static final int ITEM_SIZE = 0x08;

    /**
     * type of the method handle.
     */
    public final Type_ushort method_handle_type;
    /**
     * (unused).
     */
    public final Type_ushort unused_1;
    /**
     * Field or method id depending on whether the method handle type is an
     * accessor or a method invoker.
     */
    public final Type_ushort field_or_method_id;
    /**
     * (unused).
     */
    public final Type_ushort unused_2;

    method_handle_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.method_handle_type = stream.Dex_ushort();
        this.unused_1 = stream.Dex_ushort();
        this.field_or_method_id = stream.Dex_ushort();
        this.unused_2 = stream.Dex_ushort();
        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        int floatPos = this.getStartPos();

        addNode(parentNode, floatPos, Type_ushort.LENGTH, "string_data_off", this.method_handle_type, "msg_method_handle_item__method_handle_type", Icons.Offset);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "unused", "(unused)", "msg_method_handle_item__unused", Icons.Empty);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "field_or_method_id", this.field_or_method_id, "msg_method_handle_item__field_or_method_id", Icons.Index);
        floatPos += Type_ushort.LENGTH;
        addNode(parentNode, floatPos, Type_ushort.LENGTH, "unused", "(unused)", "msg_method_handle_item__unused", Icons.Empty);
    }

    public enum Type {
        METHOD_HANDLE_TYPE_STATIC_PUT(0x00),
        METHOD_HANDLE_TYPE_STATIC_GET(0x01),
        METHOD_HANDLE_TYPE_INSTANCE_PUT(0x02),
        METHOD_HANDLE_TYPE_INSTANCE_GET(0x03),
        METHOD_HANDLE_TYPE_INVOKE_STATIC(0x04),
        METHOD_HANDLE_TYPE_INVOKE_INSTANCE(0x05),
        METHOD_HANDLE_TYPE_INVOKE_CONSTRUCTOR(0x06),
        METHOD_HANDLE_TYPE_INVOKE_DIRECT(0x07),
        METHOD_HANDLE_TYPE_INVOKE_INTERFACE(0x08);

        public final int value;

        private Type(int v) {
            this.value = v;
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/method_id_item.java`:

```java
/*
 * method_id_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class method_id_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * Item Size In Bytes.
     *
     * @see map_list.TypeCodes#TYPE_METHOD_ID_ITEM
     */
    public static final int ITEM_SIZE = 0x08;

    /**
     * index into the type_ids list for the definer of this method. This must be
     * a class or array type, and not a primitive type.
     */
    public final Type_ushort class_idx;
    private String clazz = null;
    private String clazz_jls = null;

    /**
     * index into the proto_ids list for the prototype of this method.
     */
    public final Type_ushort proto_idx;

    /**
     * index into the string_ids list for the name of this method. The string
     * must conform to the syntax for MemberName, defined above.
     */
    public final Type_uint name_idx;
    private String name = null;

    method_id_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.class_idx = stream.Dex_ushort();
        this.proto_idx = stream.Dex_ushort();
        this.name_idx = stream.Dex_uint();
        super.length = stream.getPos() - super.startPos;
    }


    /**
     * Get {@link #class_idx} name.
     *
     * @param dexFile Current {@link DexFile}
     * @return class name
     * @see #class_idx
     */
    public String get_class(DexFile dexFile) {
        if (this.clazz == null) {
            this.clazz = dexFile.get_type_ids_string(class_idx.value);
        }
        return this.clazz;
    }

    /**
     * Get {@link #class_idx} name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return class name in JLS format
     * @see #class_idx
     */
    public String get_class_jls(DexFile dexFile) {
        if (this.clazz_jls == null) {
            // The class string could be an array, so we use the TypeJLSName
            this.clazz_jls = dexFile.type_ids[class_idx.value].get_descriptor_jls(dexFile).TypeJLSName;
        }
        return this.clazz_jls;
    }

    /**
     * Get {@link #proto_idx} value.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link #proto_idx} value
     */
    public proto_id_item get_proto(DexFile dexFile) {
        return dexFile.proto_ids[this.proto_idx.value];
    }


    /**
     * Get {@link #name_idx} name.
     *
     * @param dexFile Current {@link DexFile}
     * @return field name
     * @see #name_idx
     */
    public String get_name(DexFile dexFile) {
        if (this.name == null) {
            this.name = dexFile.get_string_ids_string(name_idx.intValue());
        }
        return this.name;
    }

    /**
     * String format of current {@link method_id_item}.
     *
     * @param dexFile Current {@link DexFile}
     * @return String format of a method
     */
    public String toString(DexFile dexFile) {
        proto_id_item proto = this.get_proto(dexFile);
        type_list params = proto.get_parameters(dexFile);
        return String.format("%s %s.%s(%s)",
                proto.get_return_type_jls(dexFile),
                this.get_class_jls(dexFile),
                this.get_name(dexFile),
                (params == null) ? "" : params.toString(dexFile)
        );
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;

        addNode(parentNode,
                floatPos,
                Type_ushort.LENGTH,
                "class_idx",
                String.format(FORMAT_STRING_STRING, this.class_idx, this.get_class_jls(dexFile)),
                "msg_method_id_item__class_idx",
                Icons.Index);
        floatPos += Type_ushort.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_ushort.LENGTH,
                "proto_idx",
                this.get_proto(dexFile).toString(dexFile),
                "msg_method_id_item__proto_idx",
                Icons.Index);
        floatPos += Type_ushort.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "name_idx",
                String.format(FORMAT_STRING_STRING, this.name_idx, this.get_name(dexFile)),
                "msg_method_id_item__name_idx",
                Icons.Index);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/proto_id_item.java`:

```java
/*
 * proto_id_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class proto_id_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * Item Size In Bytes.
     *
     * @see map_list.TypeCodes#TYPE_PROTO_ID_ITEM
     */
    public static final int ITEM_SIZE = 0x0c;

    /**
     * index into the string_ids list for the short-form descriptor string of
     * this prototype. The string must conform to the syntax for
     * ShortyDescriptor, defined above, and must correspond to the return type
     * and parameters of this item.
     */
    public Type_uint shorty_idx;
    private String shorty = null;

    /**
     * index into the type_ids list for the return type of this prototype.
     */
    public Type_uint return_type_idx;
    private String return_type = null;
    private String return_type_jls = null;

    /**
     * offset from the start of the file to the list of parameter types for this
     * prototype, or 0 if this prototype has no parameters. This offset, if
     * non-zero, should be in the data section, and the data there should be in
     * the format specified by "type_list" below. Additionally, there should be
     * no reference to the type void in the list.
     */
    public final Type_uint parameters_off;

    proto_id_item(final PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.shorty_idx = stream.Dex_uint();
        this.return_type_idx = stream.Dex_uint();
        this.parameters_off = stream.Dex_uint();
        super.length = stream.getPos() - super.startPos;
    }

    /**
     * Get {@link #shorty_idx} text.
     *
     * @param dexFile Current {@link DexFile}
     * @return shorty text
     * @see #shorty_idx
     */
    public String get_shorty(final DexFile dexFile) {
        if (this.shorty == null) {
            this.shorty = dexFile.get_string_ids_string(shorty_idx.intValue());
        }
        return this.shorty;
    }

    /**
     * Get {@link #return_type_idx} text.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link #return_type_idx} text
     * @see #return_type_idx
     */
    public String get_return_type(final DexFile dexFile) {
        if (this.return_type == null) {
            this.return_type = dexFile.get_type_ids_string(return_type_idx.intValue());
        }
        return this.return_type;
    }

    /**
     * Get {@link #return_type_idx} text in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link #return_type_idx} text in JSL format
     * @see #return_type_idx
     */
    public String get_return_type_jls(final DexFile dexFile) {
        if (this.return_type_jls == null) {
            this.return_type_jls = dexFile.type_ids[return_type_idx.intValue()].get_descriptor_jls(dexFile).toString();
        }
        return this.return_type_jls;
    }

    /**
     * Get the corresponding {@link type_list} for {@link #parameters_off}.
     *
     * @param dexFile Current {@link DexFile}
     * @return {@link type_list} for {@link #parameters_off}, or null if no
     * parameters
     */
    public type_list get_parameters(final DexFile dexFile) {
        if (this.parameters_off.value == 0) {
            return null;
        } else {
            return (type_list) dexFile.data.get(this.parameters_off.value);
        }
    }

    /**
     * String format of current {@link proto_id_item}.
     *
     * @param dexFile Current {@link DexFile}
     * @return String format of a {@link proto_id_item}
     */
    public String toString(DexFile dexFile) {
        type_list params = this.get_parameters(dexFile);
        return String.format("%s - %s (%s)",
                this.get_shorty(dexFile),
                this.get_return_type_jls(dexFile),
                (params == null) ? "" : params.toString(dexFile)
        );
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat format) {
        DexFile dexFile = (DexFile)format;
        int floatPos = super.startPos;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "shorty_idx",
                String.format(FORMAT_STRING_STRING, this.shorty_idx, this.get_shorty(dexFile)),
                "msg_proto_id_item__shorty_idx",
                Icons.Index);
        floatPos += Type_uint.LENGTH;

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "return_type_idx",
                String.format(FORMAT_STRING_STRING, this.return_type_idx, this.get_return_type_jls(dexFile)),
                "msg_proto_id_item__return_type_idx",
                Icons.Return);
        floatPos += Type_uint.LENGTH;

        String param = (this.parameters_off.value == 0) ? "no parameter" : String.format("%d paramters", this.get_parameters(dexFile).size.value);
        DefaultMutableTreeNode parametersNode = addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "parameters_off",
                String.format(FORMAT_STRING_STRING, this.parameters_off, param),
                "msg_proto_id_item__parameters_off",
                Icons.Offset);

        type_list list = this.get_parameters(dexFile);
        if (list != null) {
            DefaultMutableTreeNode listNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    list.getStartPos(),
                    list.getLength(),
                    "type_list",
                    Icons.Shortcut,
                    MESSAGES.getString("msg_type_list")
            ));
            parametersNode.add(listNode);
            list.generateTreeNode(listNode, dexFile);
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/string_data_item.java`:

```java
/*
 * string_data_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from Dex Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class string_data_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * size of this string, in UTF-16 code units (which is the "string length"
     * in many systems). That is, this is the decoded length of the string. (The
     * encoded length is implied by the position of the 0 byte.)
     */
    public Type_uleb128 utf16_size;

    /**
     * a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a
     * byte of value 0. See "MUTF-8 (Modified UTF-8) Encoding" above for details
     * and discussion about the data format.
     */
    public byte[] data;

    string_data_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.utf16_size = stream.Dex_uleb128();
        if (this.utf16_size.value > 0) {
            this.data = new byte[this.utf16_size.value];
            int bytesRead = stream.read(this.data);
            if (bytesRead != this.data.length) {
                throw new IOException("Cannot read correct number of bytes for string_data_item. expected bytes = "
                        + this.data.length + ", atual bytes read = " + bytesRead);
            }
        } else {
            this.data = null;
        }
        super.length = stream.getPos() - super.startPos;
    }

    /**
     * Get the {@link #data} as a String, using platform's default charset.
     *
     * @return String for the content
     */
    public String getString() {
        return (this.data == null) ? "" : new String(this.data, StandardCharsets.UTF_8);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat fileFormat) {
        DefaultMutableTreeNode nodeTemp;
        int floatPos = this.getStartPos();
        int utf16Size = this.utf16_size.value;

        nodeTemp = addNode(parentNode, floatPos, this.utf16_size.length, "utf16_size", utf16Size, "msg_string_data_item__utf16_size", Icons.Size);
        floatPos = ((JTreeNodeFileComponent) nodeTemp.getUserObject()).getLastPosPlus1();
        if (utf16Size > 0) {
            addNode(parentNode, floatPos, this.data.length, "data", this.getString(), "msg_string_data_item__data", Icons.Data);
        }
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/string_id_item.java`:

```java
/*
 * string_id_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from Dex Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116", "java:S1104"})
public class string_id_item extends FileComponent implements GenerateTreeNodeDexFile {

    /**
     * @see map_list.TypeCodes#TYPE_STRING_ID_ITEM
     */
    public static final int ITEM_SIZE = 0x04;

    /**
     * offset from the start of the file to the string data for this item. The
     * offset should be to a location in the data section, and the data should
     * be in the format specified by "string_data_item" below. There is no
     * alignment requirement for the offset.
     */
    public final Type_uint string_data_off;

    string_id_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.string_data_off = stream.Dex_uint();
        super.length = Type_uint.LENGTH;
    }

    @Override
    public void generateTreeNode(final DefaultMutableTreeNode parentNode, final FileFormat format) {
        DexFile dexFile = (DexFile)format;
        DefaultMutableTreeNode offsetNode = addNode(parentNode, this.startPos, Type_uint.LENGTH, "string_data_off", string_data_off, "msg_string_id_item__string_data_off", Icons.Offset);

        string_data_item item = (string_data_item) dexFile.data.get(this.string_data_off.value);
        DefaultMutableTreeNode dataNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                item.getStartPos(),
                item.getLength(),
                "string_data_item",
                Icons.Shortcut,
                GenerateTreeNodeDexFile.MESSAGES.getString("msg_string_data_item")
        ));
        offsetNode.add(dataNode);
        item.generateTreeNode(dataNode, format);
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/type_id_item.java`:

```java
/*
 * type_id_item.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.SignatureConvertor;

/**
 * Type identifiers list item.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class type_id_item extends FileComponent implements GenerateTreeNodeDexFile {

    private static final Logger LOGGER = Logger.getLogger(type_id_item.class.getName());

    /**
     * Item size.
     *
     * @see map_list.TypeCodes#TYPE_TYPE_ID_ITEM
     */
    public static final int ITEM_SIZE = 0x04;

    /**
     * index into the string_ids list for the descriptor string of this type.
     * The string must conform to the syntax for TypeDescriptor, defined above.
     */
    public Type_uint descriptor_idx;

    /**
     * Local cache for the {@link #get_descriptor_jls(DexFile)}.
     */
    private SignatureConvertor.SignatureResult descriptor_jls = null;

    type_id_item(PosDataInputStreamDex stream) throws IOException {
        super.startPos = stream.getPos();
        this.descriptor_idx = stream.Dex_uint();
        super.length = Type_uint.LENGTH;
    }
    
    /**
     * Get descriptor text.
     *
     * @param dexFile Current {@link DexFile}
     * @return Descriptor text
     */
    public String get_descriptor(DexFile dexFile) {
        return dexFile.get_string_ids_string(descriptor_idx.intValue());
    }

    /**
     * Get parsed descriptor name in Java Language Specification format.
     *
     * @param dexFile Current {@link DexFile}
     * @return Parsed descriptor name
     */
    public SignatureConvertor.SignatureResult get_descriptor_jls(DexFile dexFile) {
        if (this.descriptor_jls == null) {
            String text = this.get_descriptor(dexFile);
            if (text == null) {
                LOGGER.warning(String.format("The current item points to a null string: position = 0x%08X", this.startPos));
                this.descriptor_jls = null;
            } else {
                try {
                    this.descriptor_jls = SignatureConvertor.methodReturnTypeJLS(text);
                } catch (FileFormatException ex) {
                    // This should never happen
                    this.descriptor_jls = null;
                    LOGGER.log(Level.SEVERE, "The current type_id_item points to an invalid signature string", ex);
                }
            }
        }

        return this.descriptor_jls;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode, FileFormat dexFile) {
        addNode(parentNode,
                this.startPos,
                Type_uint.LENGTH,
                "descriptor_idx",
                String.format("%s - %s", descriptor_idx, this.get_descriptor((DexFile)dexFile)),
                "msg_type_id_item__descriptor_idx",
                Icons.Offset
        );
    }
}

```

`FormatDEX/src/main/java/org/binaryinternals/format/dex/type_list.java`:

```java
/*
 * type_list.java    June 23, 2015, 06:20
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.dex;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.format.classfile.SignatureConvertor;

/**
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from DEX spec instead
 * java:S101 - Class names should comply with a naming convention --- We respect the name from DEX Spec instead
 * java:S116 - Field names should comply with a naming convention --- We respect the DEX spec name instead
 * java:S1104 - Class variable fields should not have public accessibility --- No, we like the simplified final value manner
 * </pre>
 */
@SuppressWarnings({"java:S100", "java:S101", "java:S116", "java:S1104"})
public class type_list extends FileComponent implements GenerateTreeNodeDexFile {

    public final Type_uint size;
    public final type_item[] list;

    type_list(PosDataInputStreamDex stream) throws IOException, FileFormatException {
        super.startPos = stream.getPos();
        this.size = stream.Dex_uint();
        if (this.size.value > 0) {
            DexFile.check_uint("type_list.size", this.size, stream.getPos());
            this.list = new type_item[(int) this.size.value];
            for (int i = 0; i < this.size.value; i++) {
                this.list[i] = new type_item(stream);
            }
        } else {
            this.list = null;
        }

        super.length = stream.getPos() - super.startPos;
    }

    @Override
    public void generateTreeNode(final DefaultMutableTreeNode parentNode, final FileFormat dexFile) {
        int floatPos = this.getStartPos();

        addNode(parentNode,
                floatPos,
                Type_uint.LENGTH,
                "size",
                this.size,
                "msg_type_list__size",
                Icons.Size
        );

        // Since type_item has only 1 field, so we do not use child node
        if (this.list != null && this.list.length > 0) {
            for (int i = 0; i < this.list.length; i++) {
                type_item item = this.list[i];
                addNode(parentNode,
                        item.getStartPos(),
                        item.getLength(),
                        String.format("type_item[%d].type_idx", i),
                        item.get_type_jls((DexFile)dexFile),
                        "msg_type_item__type_idx",
                        Icons.Index
                );
            }
        }
    }

    /**
     * String format of current {@link type_list}.
     *
     * @param dexFile Current {@link DexFile}
     * @return String format of type list
     */
    public String toString(DexFile dexFile) {
        if (this.size.value < 1) {
            return "";
        } else {
            List<String> items = new ArrayList<>();
            for (type_item item : this.list) {
                items.add(item.get_type_jls(dexFile).toString());
            }
            return String.join(", ", items);
        }
    }

    /**
     * Elements of the {@link type_list}.
     */
    public static class type_item extends FileComponent {

        /**
         * Item Size In Bytes.
         *
         * @see map_list.TypeCodes#TYPE_TYPE_LIST
         */
        public static final int ITEM_SIZE = 2;

        public final Type_ushort type_idx;
        private String type = null;
        private SignatureConvertor.SignatureResult type_jls = null;

        type_item(PosDataInputStreamDex stream) throws IOException, FileFormatException {
            super.startPos = stream.getPos();
            this.type_idx = stream.Dex_ushort();
            super.length = stream.getPos() - super.startPos;
        }

        /**
         * Get {@link #type} text.
         *
         * @param dexFile Current {@link DexFile}
         * @return {@link #type} text
         * @see #type
         */
        public String get_type(DexFile dexFile) {
            if (this.type == null) {
                this.type = dexFile.get_type_ids_string(type_idx.value);
            }
            return this.type;
        }

        /**
         * Get {@link #type} text in Java Language Specification format.
         *
         * @param dexFile Current {@link DexFile}
         * @return {@link #type} parse result for JLS format
         * @see #type
         */
        public SignatureConvertor.SignatureResult get_type_jls(DexFile dexFile) {
            if (this.type_jls == null) {
                this.type_jls = dexFile.type_ids[type_idx.value].get_descriptor_jls(dexFile);
            }
            return this.type_jls;
        }
    }
}

```

`FormatDEX/src/main/resources/org/binaryinternals/format/dex/MessagesBundle.properties`:

```properties
# Copyright 2021 Binary Internals.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

msg_common_unrecognized = Unrecognized value

msg_dex_file_magic1 = The constant array/string DEX_FILE_MAGIC is the list of bytes that must appear at the beginning of a .dex file in order for it to be recognized as such. The value intentionally contains a newline ("\n" or 0x0a) and a null byte ("\0" or 0x00) in order to help in the detection of certain forms of corruption.
msg_dex_file_magic2 = The value also encodes a format version number as three decimal digits, which is expected to increase monotonically over time as the format evolves.

msg_header_item_checksum = adler32 checksum of the rest of the file (everything but magic and this field); used to detect file corruption
msg_header_item_signature = SHA-1 signature (hash) of the rest of the file (everything but magic, checksum, and this field); used to uniquely identify files
msg_header_item_file_size = size of the entire file (including the header), in bytes
msg_header_item_header_size = size of the header (this entire section), in bytes. This allows for at least a limited amount of backwards/forwards compatibility without invalidating the format.
msg_header_item_endian_tag = endianness tag. See discussion above under "ENDIAN_CONSTANT and REVERSE_ENDIAN_CONSTANT" for more details.
msg_header_item_link_size = size of the link section, or 0 if this file isn't statically linked
msg_header_item_link_off = offset from the start of the file to the link section, or 0 if link_size == 0. The offset, if non-zero, should be to an offset into the link_data section. The format of the data pointed at is left unspecified by this document; this header field (and the previous) are left as hooks for use by runtime implementations.
msg_header_item_map_off = offset from the start of the file to the map item. The offset, which must be non-zero, should be to an offset into the data section, and the data should be in the format specified by "map_list" below.
msg_header_item_string_ids_size = count of strings in the string identifiers list
msg_header_item_string_ids_off = offset from the start of the file to the string identifiers list, or 0 if string_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the string_ids section.
msg_header_item_type_ids_size = count of elements in the type identifiers list, at most 65535
msg_header_item_type_ids_off = offset from the start of the file to the type identifiers list, or 0 if type_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the type_ids section.
msg_header_item_proto_ids_size = count of elements in the prototype identifiers list, at most 65535
msg_header_item_proto_ids_off = offset from the start of the file to the prototype identifiers list, or 0 if proto_ids_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the proto_ids section.
msg_header_item_field_ids_size = count of elements in the field identifiers list
msg_header_item_field_ids_off = offset from the start of the file to the field identifiers list, or 0 if field_ids_size == 0. The offset, if non-zero, should be to the start of the field_ids section.
msg_header_item_method_ids_size = count of elements in the method identifiers list
msg_header_item_method_ids_off = offset from the start of the file to the method identifiers list, or 0 if method_ids_size == 0. The offset, if non-zero, should be to the start of the method_ids section.
msg_header_item_class_defs_size = count of elements in the class definitions list
msg_header_item_class_defs_off = offset from the start of the file to the class definitions list, or 0 if class_defs_size == 0 (admittedly a strange edge case). The offset, if non-zero, should be to the start of the class_defs section.
msg_header_item_data_size = Size of data section in bytes. Must be an even multiple of sizeof(uint).
msg_header_item_data_off = offset from the start of the file to the start of the data section.

msg_string_id_item__string_data_off = offset from the start of the file to the string data for this item. The offset should be to a location in the data section, and the data should be in the format specified by "string_data_item" below. There is no alignment requirement for the offset.
msg_string_data_item = Appears in the data section of the ELF file.
msg_string_data_item__utf16_size = size of this string, in UTF-16 code units (which is the "string length" in many systems). That is, this is the decoded length of the string. (The encoded length is implied by the position of the 0 byte.)
msg_string_data_item__data = a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a byte of value 0. See "MUTF-8 (Modified UTF-8) Encoding" above for details and discussion about the data format.

msg_type_id_item__descriptor_idx = index into the string_ids list for the descriptor string of this type. The string must conform to the syntax for TypeDescriptor, defined above.

msg_proto_id_item__shorty_idx =index into the string_ids list for the short-form descriptor string of this prototype. The string must conform to the syntax for ShortyDescriptor, defined above, and must correspond to the return type and parameters of this item.
msg_proto_id_item__return_type_idx = index into the type_ids list for the return type of this prototype
msg_proto_id_item__parameters_off = offset from the start of the file to the list of parameter types for this prototype, or 0 if this prototype has no parameters. This offset, if non-zero, should be in the data section, and the data there should be in the format specified by "type_list" below. Additionally, there should be no reference to the type void in the list.

msg_field_id_item__class_idx = index into the type_ids list for the definer of this field. This must be a class type, and not an array or primitive type.
msg_field_id_item__type_idx = index into the type_ids list for the type of this field
msg_field_id_item__name_idx = index into the string_ids list for the name of this field. The string must conform to the syntax for MemberName, defined above.

msg_method_id_item__class_idx = index into the type_ids list for the definer of this method. This must be a class or array type, and not a primitive type.
msg_method_id_item__proto_idx = index into the proto_ids list for the prototype of this method
msg_method_id_item__name_idx = index into the string_ids list for the name of this method. The string must conform to the syntax for MemberName, defined above.

msg_class_def_item__class_idx = index into the type_ids list for this class. This must be a class type, and not an array or primitive type.
msg_class_def_item__access_flags = access flags for the class (public, final, etc.). See "access_flags Definitions" for details.
msg_class_def_item__superclass_idx = index into the type_ids list for the superclass, or the constant value NO_INDEX if this class has no superclass (i.e., it is a root class such as Object). If present, this must be a class type, and not an array or primitive type.
msg_class_def_item__interfaces_off = offset from the start of the file to the list of interfaces, or 0 if there are none. This offset should be in the data section, and the data there should be in the format specified by "type_list" below. Each of the elements of the list must be a class type (not an array or primitive type), and there must not be any duplicates.
msg_class_def_item__source_file_idx = index into the string_ids list for the name of the file containing the original source for (at least most of) this class, or the special value NO_INDEX to represent a lack of this information. The debug_info_item of any given method may override this source file, but the expectation is that most classes will only come from one source file.
msg_class_def_item__annotations_off = offset from the start of the file to the annotations structure for this class, or 0 if there are no annotations on this class. This offset, if non-zero, should be in the data section, and the data there should be in the format specified by "annotations_directory_item" below, with all items referring to this class as the definer.
msg_class_def_item__class_data_off = offset from the start of the file to the associated class data for this item, or 0 if there is no class data for this class. (This may be the case, for example, if this class is a marker interface.) The offset, if non-zero, should be in the data section, and the data there should be in the format specified by "class_data_item" below, with all items referring to this class as the definer.
msg_class_def_item__static_values_off = offset from the start of the file to the list of initial values for static fields, or 0 if there are none (and all static fields are to be initialized with 0 or null). This offset should be in the data section, and the data there should be in the format specified by "encoded_array_item" below. The size of the array must be no larger than the number of static fields declared by this class, and the elements correspond to the static fields in the same order as declared in the corresponding field_list. The type of each array element must match the declared type of its corresponding field. If there are fewer elements in the array than there are static fields, then the leftover fields are initialized with a type-appropriate 0 or null.

msg_call_site_id_item = appears in the call_site_ids section. <br /><br />alignment: 4 bytes.
msg_call_site_id_item__call_site_off = offset from the start of the file to call site definition. The offset should be in the data section, and the data there should be in the format specified by "call_site_item" below.

msg_call_site_item = The call_site_item is an encoded_array_item whose elements correspond to the arguments provided to a bootstrap linker method.<br /><br />appears in the data section. <br /><br />alignment: none (byte aligned).

msg_method_handle_item = appears in the method_handles section. <br /><br />alignment: 4 bytes.
msg_method_handle_item__method_handle_type = type of the method handle; see table below
msg_method_handle_item__field_or_method_id = Field or method id depending on whether the method handle type is an accessor or a method invoker
msg_method_handle_item__unused = (unused)

msg_class_data_item = referenced from class_def_item. <br /><br />appears in the data section. <br /><br />alignment: none (byte-aligned).
msg_class_data_item__static_fields_size = the number of static fields defined in this item
msg_class_data_item__instance_fields_size = the number of instance fields defined in this item
msg_class_data_item__direct_methods_size = the number of direct methods defined in this item
msg_class_data_item__virtual_methods_size = the number of virtual methods defined in this item
msg_class_data_item__static_fields = the defined static fields, represented as a sequence of encoded elements. The fields must be sorted by field_idx in increasing order.
msg_class_data_item__instance_fields = the defined instance fields, represented as a sequence of encoded elements. The fields must be sorted by field_idx in increasing order.
msg_class_data_item__direct_methods = the defined direct (any of static, private, or constructor) methods, represented as a sequence of encoded elements. The methods must be sorted by method_idx in increasing order.
msg_class_data_item__virtual_methods = the defined virtual (none of static, private, or constructor) methods, represented as a sequence of encoded elements. This list should not include inherited methods unless overridden by the class that this item represents. The methods must be sorted by method_idx in increasing order. The method_idx of a virtual method must not be the same as any direct method.

msg_encoded_field__field_idx_diff = index into the field_ids list for the identity of this field (includes the name and descriptor), represented as a difference from the index of previous element in the list. The index of the first element in a list is represented directly.
msg_encoded_field__access_flags = access flags for the field (public, final, etc.). See "access_flags Definitions" for details.

msg_encoded_method__method_idx_diff = index into the method_ids list for the identity of this method (includes the name and descriptor), represented as a difference from the index of previous element in the list. The index of the first element in a list is represented directly.
msg_encoded_method__access_flags = access flags for the method (public, final, etc.). See "access_flags Definitions" for details.
msg_encoded_method__code_off = offset from the start of the file to the code structure for this method, or 0 if this method is either abstract or native. The offset should be to a location in the data section. The format of the data is specified by "code_item" below.

msg_type_list = referenced from class_def_item and proto_id_item. <br /><br />appears in the data section<br /><br />alignment: 4 bytes
msg_type_list__size = size of the list, in entries
msg_type_list__list = elements of the list
msg_type_item__type_idx = index into the type_ids list

msg_code_item = referenced from encoded_method. <br /><br />appears in the data section. <br /><br />alignment: 4 bytes
msg_code_item__registers_size = the number of registers used by this code
msg_code_item__ins_size = the number of words of incoming arguments to the method that this code is for
msg_code_item__outs_size = the number of words of outgoing argument space required by this code for method invocation
msg_code_item__tries_size = the number of try_items for this instance. If non-zero, then these appear as the tries array just after the insns in this instance.
msg_code_item__debug_info_off = offset from the start of the file to the debug info (line numbers + local variable info) sequence for this code, or 0 if there simply is no information. The offset, if non-zero, should be to a location in the data section. The format of the data is specified by "debug_info_item" below.
msg_code_item__insns_size = size of the instructions list, in 16-bit code units
msg_code_item__insns = actual array of bytecode. The format of code in an insns array is specified by the companion document Dalvik bytecode. Note that though this is defined as an array of ushort, there are some internal structures that prefer four-byte alignment. Also, if this happens to be in an endian-swapped file, then the swapping is only done on individual ushorts and not on the larger internal structures.
msg_code_item__padding = two bytes of padding to make tries four-byte aligned. This element is only present if tries_size is non-zero and insns_size is odd.
msg_code_item__tries = array indicating where in the code exceptions are caught and how to handle them. Elements of the array must be non-overlapping in range and in order from low to high address. This element is only present if tries_size is non-zero.
msg_code_item__handlers = bytes representing a list of lists of catch types and associated handler addresses. Each try_item has a byte-wise offset into this structure. This element is only present if tries_size is non-zero.

msg_try_item__start_addr = start address of the block of code covered by this entry. The address is a count of 16-bit code units to the start of the first covered instruction.
msg_try_item__insn_count = number of 16-bit code units covered by this entry. The last code unit covered (inclusive) is start_addr + insn_count - 1.
msg_try_item__handler_off = offset in bytes from the start of the associated encoded_catch_hander_list to the encoded_catch_handler for this entry. This must be an offset to the start of an encoded_catch_handler.

msg_encoded_catch_handler_list__size = size of this list, in entries
msg_encoded_catch_handler_list__list = actual list of handler lists, represented directly (not as offsets), and concatenated sequentially

msg_encoded_catch_handler__size = number of catch types in this list. If non-positive, then this is the negative of the number of catch types, and the catches are followed by a catch-all handler. For example: A size of 0 means that there is a catch-all but no explicitly typed catches. A size of 2 means that there are two explicitly typed catches and no catch-all. And a size of -1 means that there is one typed catch along with a catch-all.
msg_encoded_catch_handler__handlers = stream of abs(size) encoded items, one for each caught type, in the order that the types should be tested.
msg_encoded_catch_handler__catch_all_addr = bytecode address of the catch-all handler. This element is only present if size is non-positive.

msg_encoded_type_addr_pair__type_idx = index into the type_ids list for the type of the exception to catch
msg_encoded_type_addr_pair__addr = bytecode address of the associated exception handler

msg_debug_info_item = Each debug_info_item defines a DWARF3-inspired byte-coded state machine that, when interpreted, emits the positions table and (potentially) the local variable information for a code_item. The sequence begins with a variable-length header (the length of which depends on the number of method parameters), is followed by the state machine bytecodes, and ends with an DBG_END_SEQUENCE byte. <br /><br />referenced from code_item<br /><br />appears in the data section<br /><br />alignment: none (byte-aligned)
msg_debug_info_item__line_start = the initial value for the state machine's line register. Does not represent an actual positions entry.
msg_debug_info_item__parameters_size = the number of parameter names that are encoded. There should be one per method parameter, excluding an instance method's this, if any.
msg_debug_info_item__parameter_names = string index of the method parameter name. An encoded value of NO_INDEX indicates that no name is available for the associated parameter. The type descriptor and signature are implied from the method descriptor and signature.

msg_annotations_directory_item = referenced from class_def_item<br /><br />appears in the data section<br /><br />alignment: 4 bytes
msg_annotations_directory_item__class_annotations_off = offset from the start of the file to the annotations made directly on the class, or 0 if the class has no direct annotations. The offset, if non-zero, should be to a location in the data section. The format of the data is specified by "annotation_set_item" below.
msg_annotations_directory_item__fields_size = count of fields annotated by this item
msg_annotations_directory_item__annotated_methods_size = count of methods annotated by this item
msg_annotations_directory_item__annotated_parameters_size = count of method parameter lists annotated by this item
msg_annotations_directory_item__field_annotations = list of associated field annotations. The elements of the list must be sorted in increasing order, by field_idx.
msg_annotations_directory_item__method_annotations = list of associated method annotations. The elements of the list must be sorted in increasing order, by method_idx.
msg_annotations_directory_item__parameter_annotations = list of associated method parameter annotations. The elements of the list must be sorted in increasing order, by method_idx.

msg_field_annotation__field_idx = index into the field_ids list for the identity of the field being annotated
msg_field_annotation__annotations_off = offset from the start of the file to the list of annotations for the field. The offset should be to a location in the data section. The format of the data is specified by "annotation_set_item" below.

msg_method_annotation__method_idx = index into the method_ids list for the identity of the method being annotated
msg_method_annotation__annotations_off = offset from the start of the file to the list of annotations for the method. The offset should be to a location in the data section. The format of the data is specified by "annotation_set_item" below.

msg_parameter_annotation__method_idx = index into the method_ids list for the identity of the method whose parameters are being annotated
msg_parameter_annotation__annotations_off = offset from the start of the file to the list of annotations for the method parameters. The offset should be to a location in the data section. The format of the data is specified by "annotation_set_ref_list" below.

msg_annotation_set_ref_list = referenced from parameter_annotations_item<br /><br />appears in the data section<br /><br />alignment: 4 bytes
msg_annotation_set_ref_list__size = size of the list, in entries
msg_annotation_set_ref_list__list = elements of the list
msg_annotation_set_ref_item__annotations_off = offset from the start of the file to the referenced annotation set or 0 if there are no annotations for this element. The offset, if non-zero, should be to a location in the data section. The format of the data is specified by "annotation_set_item" below.

msg_annotation_set_item = referenced from annotations_directory_item, field_annotations_item, method_annotations_item, and annotation_set_ref_item<br /><br />appears in the data section<br /><br />alignment: 4 bytes
msg_annotation_set_item__size = size of the set, in entries
msg_annotation_set_item__entries = elements of the set. The elements must be sorted in increasing order, by type_idx.
msg_annotation_off_item__annotation_off = offset from the start of the file to an annotation. The offset should be to a location in the data section, and the format of the data at that location is specified by "annotation_item" below.

msg_annotation_item = referenced from annotation_set_item<br /><br />appears in the data section<br /><br />alignment: none (byte-aligned)
msg_annotation_item__visibility = intended visibility of this annotation (see below)
msg_annotation_item__visibility_build = intended only to be visible at build time (e.g., during compilation of other code)
msg_annotation_item__visibility_runtime = intended to visible at runtime
msg_annotation_item__visibility_system = intended to visible at runtime, but only to the underlying system (and not to regular user code)
msg_annotation_item__annotation = encoded annotation contents, in the format described by "encoded_annotation format" under "encoded_value encoding" above.

msg_encoded_value = An encoded_value is an encoded piece of (nearly) arbitrary hierarchically structured data. The encoding is meant to be both compact and straightforward to parse.<br /><br />embedded in annotation_element and encoded_array_item
msg_encoded_value__value_type = byte indicating the type of the immediately subsequent value along with an optional clarifying argument in the high-order three bits. See below for the various value definitions.
msg_encoded_value__value_arg =  In most cases, value_arg encodes the length of the immediately-subsequent value in bytes, as (size - 1), e.g., 0 means that the value requires one byte, and 7 means it requires eight bytes; however, there are exceptions as noted below.
msg_encoded_value__value = bytes representing the value, variable in length and interpreted differently for different value_type bytes, though always little-endian. See the various value definitions below for details.
msg_encoded_value__value_byte = signed one-byte integer value
msg_encoded_value__value_short = signed two-byte integer value, sign-extended
msg_encoded_value__value_char = unsigned two-byte integer value, zero-extended
msg_encoded_value__value_int = signed four-byte integer value, sign-extended
msg_encoded_value__value_long = signed eight-byte integer value, sign-extended
msg_encoded_value__value_float = four-byte bit pattern, zero-extended to the right, and interpreted as an IEEE754 32-bit floating point value
msg_encoded_value__value_double = eight-byte bit pattern, zero-extended to the right, and interpreted as an IEEE754 64-bit floating point value
msg_encoded_value__value_method_type = unsigned (zero-extended) four-byte integer value, interpreted as an index into the proto_ids section and representing a method type value
msg_encoded_value__value_method_handle = unsigned (zero-extended) four-byte integer value, interpreted as an index into the method_handles section and representing a method handle value
msg_encoded_value__value_string = unsigned (zero-extended) four-byte integer value, interpreted as an index into the string_ids section and representing a string value
msg_encoded_value__type = unsigned (zero-extended) four-byte integer value, interpreted as an index into the type_ids section and representing a reflective type/class value
msg_encoded_value__value_field = unsigned (zero-extended) four-byte integer value, interpreted as an index into the field_ids section and representing a reflective field value
msg_encoded_value__value_method = unsigned (zero-extended) four-byte integer value, interpreted as an index into the method_ids section and representing a reflective method value
msg_encoded_value__value_enum = unsigned (zero-extended) four-byte integer value, interpreted as an index into the field_ids section and representing the value of an enumerated type constant
msg_encoded_value__value_array = an array of values, in the format specified by "encoded_array format" below. The size of the value is implicit in the encoding.
msg_encoded_value__value_annotation = a sub-annotation, in the format specified by "encoded_annotation format" below. The size of the value is implicit in the encoding.
msg_encoded_value__value_null = null reference value
msg_encoded_value__value_boolean = one-bit value; 0 for false and 1 for true. The bit is represented in the value_arg.

msg_encoded_array_item = referenced from class_def_item<br /><br />appears in the data section<br /><br />alignment: none (byte-aligned)
msg_encoded_array_item__value = bytes representing the encoded array value, in the format specified by "encoded_array Format" under "encoded_value Encoding" above.
msg_encoded_array__size = number of elements in the array
msg_encoded_array__values = a series of size encoded_value byte sequences in the format specified by this section, concatenated sequentially.

msg_encoded_annotation__type_idx = type of the annotation. This must be a class (not array or primitive) type.
msg_encoded_annotation__size = number of name-value mappings in this annotation
msg_encoded_annotation__elements = elements of the annotation, represented directly in-line (not as offsets). Elements must be sorted in increasing order by string_id index.

msg_annotation_element__name_idx = element name, represented as an index into the string_ids section. The string must conform to the syntax for MemberName, defined above.
msg_annotation_element__value = element value

msg_hiddenapi_class_data_item =  This section contains data on restricted interfaces used by each class.
msg_hiddenapi_class_data_item__size = total size of the section
msg_hiddenapi_class_data_item__offsets = array of offsets indexed by class_idx. A zero array entry at index class_idx means that either there is no data for this class_idx, or all hidden API flags are zero. Otherwise the array entry is non-zero and contains an offset from the beginning of the section to an array of hidden API flags for this class_idx.
msg_hiddenapi_class_data_item__flags = concatenated arrays of hidden API flags for each class. Possible flag values are described in the table below. Flags are encoded in the same order as fields and methods are encoded in class data.

```

`FormatELF/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.elf</artifactId>
    <version>0.3</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatELF</name>
    <description>Executable and Linkable Format</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.elf.PluginDescriptorELF</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>
    
</project>

```

`FormatELF/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatelf {
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.elf;
}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/Elf64Type.java`:

```java
/*
 * Elf64Type.java    June 21, 2020
 *
 * Copyright 2020, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import java.math.BigInteger;

/**
 * 64-bit ELF base types.
 *
 * <pre>
 *   typedef __u64    Elf64_Addr;
 *   typedef __u16    Elf64_Half;
 *   typedef __s16    Elf64_SHalf;
 *   typedef __u64    Elf64_Off;
 *   typedef __s32    Elf64_Sword;
 *   typedef __u32    Elf64_Word;
 *   typedef __u64    Elf64_Xword;
 *   typedef __s64    Elf64_Sxword;
 * </pre>
 *
 * @author Amos Shi
 * @see
 * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from ELF C programming language source code
 * </pre>
 */
@SuppressWarnings("java:S101")
public class Elf64Type {

    private Elf64Type() {
    }

    /**
     * <code>typedef __u64    Elf64_Addr;</code>.
     */
    public static class Elf64_Addr {

        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 8;
        public final BigInteger value;

        Elf64_Addr(BigInteger big) {
            this.value = big;
        }
    }

    /**
     * <code>typedef __u16    Elf64_Half;</code>.
     */
    public static class Elf64_Half {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 2;
        public final int value;

        Elf64_Half(int i) {
            this.value = i;
        }
    }

    /**
     * <code>typedef __u64    Elf64_Off;</code>.
     */
    public static class Elf64_Off {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 8;
        public final BigInteger value;

        Elf64_Off(BigInteger big) {
            this.value = big;
        }
    }

    /**
     * <code>typedef __s16    Elf64_SHalf;</code>.
     */
    public static class Elf64_SHalf {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 2;
        public final short value;

        Elf64_SHalf(short s) {
            this.value = s;
        }
    }

    /**
     * <code>typedef __s32    Elf64_Sword;</code>.
     */
    public static class Elf64_Sword {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 4;
        public final int value;

        Elf64_Sword(int i) {
            this.value = i;
        }
    }

    /**
     * <code>typedef __s64    Elf64_Sxword;</code>.
     */
    public static class Elf64_Sxword {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 8;
        public final long value;

        Elf64_Sxword(long l) {
            this.value = l;
        }
    }

    /**
     * <code>typedef __u32    Elf64_Word;</code>.
     */
    public static class Elf64_Word {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 4;
        public final long value;

        Elf64_Word(long l) {
            this.value = l;
        }
    }

    /**
     * <code>typedef __u64    Elf64_Xword;</code>.
     */
    public static class Elf64_Xword {
        /**
         * Binary data length in bytes.
         */
        public static final int LENGTH = 8;
        public final BigInteger value;

        Elf64_Xword(BigInteger big) {
            this.value = big;
        }
    }

}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/Elf64_Ehdr.java`:

```java
/*
 * elf64_hdr.java    Apr 10, 2020
 *
 * Copyright 2020, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Addr;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Half;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Off;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Word;

/**
 * ELF header for 64-bit system. In this class definition, we respect the name
 * defined in Linux source code.
 *
 * <pre>
 *   typedef struct elf64_hdr {
 *     unsigned char	e_ident[EI_NIDENT];      // ELF "magic number"
 *     Elf64_Half e_type;
 *     Elf64_Half e_machine;
 *     Elf64_Word e_version;
 *     Elf64_Addr e_entry;		         // Entry point virtual address
 *     Elf64_Off e_phoff;	         	 // Program header table file offset
 *     Elf64_Off e_shoff         ;		 // Section header table file offset
 *     Elf64_Word e_flags;
 *     Elf64_Half e_ehsize;
 *     Elf64_Half e_phentsize;
 *     Elf64_Half e_phnum;
 *     Elf64_Half e_shentsize;
 *     Elf64_Half e_shnum;
 *     Elf64_Half e_shstrndx;
 *   } Elf64_Ehdr;
 * </pre>
 *
 * @author Amos Shi
 *
 * @see
 * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
 *
 * <pre>
 * java:S101 - Class names should comply with a naming convention --- We respect the name from ELF C programming language source code
 * java:S116 - Field names should comply with a naming convention --- We respect the name from ELF C programming language source code
 * </pre>
 */
@SuppressWarnings({"java:S101", "java:S116"})
public class Elf64_Ehdr extends FileComponent implements GenerateTreeNode {

    /**
     * ELF file types.
     */
    public final Elf64_Half e_type;
    public final Elf64_Half e_machine;
    public final Elf64_Word e_version;
    /**
     * Entry point virtual address
     */
    public final Elf64_Addr e_entry;
    /**
     * Program header table file offset
     */
    public final Elf64_Off e_phoff;
    /**
     * Section header table file offset
     */
    public final Elf64_Off e_shoff;
    public final Elf64_Word e_flags;
    public final Elf64_Half e_ehsize;
    public final Elf64_Half e_phentsize;
    public final Elf64_Half e_phnum;
    public final Elf64_Half e_shentsize;
    public final Elf64_Half e_shnum;
    public final Elf64_Half e_shstrndx;

    Elf64_Ehdr(final PosDataInputStreamElf input) throws IOException, FileFormatException {
        super.startPos = input.getPos();

        this.e_type = input.read_Elf64_Half();
        this.e_machine = input.read_Elf64_Half();
        this.e_version = input.read_Elf64_Word();
        this.e_entry = input.read_Elf64_Addr();
        this.e_phoff = input.read_Elf64_Off();
        this.e_shoff = input.read_Elf64_Off();
        this.e_flags = input.read_Elf64_Word();
        this.e_ehsize = input.read_Elf64_Half();
        this.e_phentsize = input.read_Elf64_Half();
        this.e_phnum = input.read_Elf64_Half();
        this.e_shentsize = input.read_Elf64_Half();
        this.e_shnum = input.read_Elf64_Half();
        this.e_shstrndx = input.read_Elf64_Half();

        super.length = input.getPos() - super.startPos;
    }

    /**
     * Enum type for field {@link #e_type}.
     *
     * <pre>
     *   defined in: include/uapi/linux/elf.h
     *
     *   #define ET_NONE   0
     *   #define ET_REL    1
     *   #define ET_EXEC   2
     *   #define ET_DYN    3
     *   #define ET_CORE   4
     *   #define ET_LOPROC 0xff00
     *   #define ET_HIPROC 0xffff
     * </pre>
     *
     * <pre>
     *   defined in: arch/powerpc/boot/elf.h
     *
     *   #define ET_NONE   0
     *   #define ET_REL    1
     *   #define ET_EXEC   2
     *   #define ET_DYN    3
     *   #define ET_CORE   4
     *   #define ET_LOPROC 0xff00
     *   #define ET_HIPROC 0xffff
     * </pre>
     *
     * @see
     * <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
     * and Linkable Format</a>
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/arch/powerpc/boot/elf.h">arch/powerpc/boot/elf.h</a>
     */
    public enum ELF_FileType {
        ET_NONE(0x00),
        ET_REL(0x01),
        ET_EXEC(0x02),
        ET_DYN(0x03),
        ET_CORE(0x04),
        ET_LOOS(0xfe00),
        ET_HIOS(0xfeff),
        ET_LOPROC(0xff00),
        ET_HIPROC(0xffff);

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        private ELF_FileType(final int i) {
            this.value = i;
        }

        /**
         * Name of the value.
         *
         * @param v {@link #value} of an enum
         * @return Enum name if found, else <code>Unknown</code>
         */
        public static String nameOf(int v) {
            for (ELF_FileType item : ELF_FileType.values()) {
                if (item.value == v) {
                    return item.name();
                }
            }

            return ELF_FileType.class.getName() + " Unknown";
        }
    }

    /**
     * Enum type for field {@link #e_machine}.
     *
     * @see
     * <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
     * and Linkable Format</a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from ELF Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum ELF_Machine {
        /**
         * No specific instruction set.
         */
        NotSet(0x00),

        /**
         * SPARC.
         *
         * @see <a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a>
         */
        SPARC(0x02),

        /**
         * x86.
         *
         * @see <a href="https://en.wikipedia.org/wiki/X86">x86</a>
         */
        x86(0x03),

        /**
         * MIPS.
         *
         * @see <a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a>
         */
        MIPS(0x08),

        /**
         * PowerPC.
         *
         * @see <a href="https://en.wikipedia.org/wiki/PowerPC">PowerPC</a>
         */
        PowerPC(0x14),

        /**
         * PowerPC (64-bit).
         *
         * @see <a href="https://en.wikipedia.org/wiki/PowerPC">PowerPC (64-bit)</a>
         */
        PowerPC64(0x15),

        /**
         * S390, including S390x.
         *
         * @see <a href="https://en.wikipedia.org/wiki/Z/Architecture">S390</a>
         */
        S390(0x16),

        /**
         * ARM.
         *
         * @see <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
         */
        ARM(0x28),

        /**
         * SuperH.
         *
         * @see <a href="https://en.wikipedia.org/wiki/SuperH">SuperH</a>
         */
        SuperH(0x2A),

        /**
         * IA-64.
         *
         * @see <a href="https://en.wikipedia.org/wiki/SPARC">IA-64</a>
         */
        IA64(0x32),

        /**
         * amd64.
         *
         * @see <a href="https://en.wikipedia.org/wiki/Amd64">amd64</a>
         */
        amd64(0x3E),

        /**
         * TMS320C6000 Family.
         *
         * @see <a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320#C6000_series">TMS320C6000 Family</a>
         */
        TMS320C6000(0x8C),

        /**
         * AArch64.
         *
         * @see <a href="https://en.wikipedia.org/wiki/AArch64">AArch64</a>
         */
        AArch64(0xB7),

        /**
         * RISC-V.
         *
         * @see <a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a>
         */
        RISC_V(0xF3);

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        private ELF_Machine(final int i) {
            this.value = i;
        }

        /**
         * Name of the value.
         *
         * @param v {@link #value} of an enum
         * @return Enum name if found, else <code>Unknown</code>
         */
        public static String nameOf(int v) {
            for (ELF_Machine item : ELF_Machine.values()) {
                if (item.value == v) {
                    return item.name();
                }
            }

            return ELF_Machine.class.getName() + " Unknown";
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int currentPos = this.startPos;

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("ELF64 Header [0x%08X, %d]", this.startPos, this.length),
                "The ELF header on 64-bit CPU architecture."
        ));
        parentNode.add(node);

        // e_type
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_type = 0x%04X (%d): %s", this.e_type.value, this.e_type.value, ELF_FileType.nameOf(this.e_type.value)),
                "Identifies object file type.")));
        currentPos += Elf64_Half.LENGTH;

        // e_machine
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_machine = 0x%04X (%d): %s", this.e_machine.value, this.e_machine.value, ELF_Machine.nameOf(this.e_machine.value)),
                "Specifies target instruction set architecture.")));
        currentPos += Elf64_Half.LENGTH;

        // e_version
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Word.LENGTH,
                String.format("e_version = 0x%08X (%d)", this.e_version.value, this.e_version.value),
                "Set to 1 for the original version of ELF.")));
        currentPos += Elf64_Word.LENGTH;

        // e_entry
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Addr.LENGTH,
                String.format("e_entry = 0x%016X (%d)", this.e_entry.value, this.e_entry.value),
                "This is the memory address of the entry point from where the process starts executing. This field is either 32 or 64 bits long depending on the format defined earlier.")));
        currentPos += Elf64_Addr.LENGTH;

        // e_phoff
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Off.LENGTH,
                String.format("e_phoff = 0x%016X (%d)", this.e_phoff.value, this.e_phoff.value),
                "Points to the start of the program header table. It usually follows the file header immediately, making the offset 0x34 or 0x40 for 32- and 64-bit ELF executables, respectively.")));
        currentPos += Elf64_Off.LENGTH;

        // e_shoff
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Off.LENGTH,
                String.format("e_shoff = 0x%016X (%d)", this.e_shoff.value, this.e_shoff.value),
                "Points to the start of the section header table.")));
        currentPos += Elf64_Off.LENGTH;

        // e_flags
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Word.LENGTH,
                String.format("e_flags = 0x%08X (%d)", this.e_flags.value, this.e_flags.value),
                "Interpretation of this field depends on the target architecture.")));
        currentPos += Elf64_Word.LENGTH;

        // e_ehsize
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_ehsize = 0x%04X (%d)", this.e_ehsize.value, this.e_ehsize.value),
                "Contains the size of this header, normally 64 Bytes for 64-bit and 52 Bytes for 32-bit format.")));
        currentPos += Elf64_Half.LENGTH;

        // e_phentsize
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_phentsize = 0x%04X (%d)", this.e_phentsize.value, this.e_phentsize.value),
                "Contains the size of a program header table entry.")));
        currentPos += Elf64_Half.LENGTH;

        // e_phnum
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_phnum = 0x%04X (%d)", this.e_phnum.value, this.e_phnum.value),
                "Contains the number of entries in the program header table.")));
        currentPos += Elf64_Half.LENGTH;

        // e_shentsize
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_shentsize = 0x%04X (%d)", this.e_shentsize.value, this.e_shentsize.value),
                "Contains the size of a section header table entry.")));
        currentPos += Elf64_Half.LENGTH;

        // e_shnum
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_shnum = 0x%04X (%d)", this.e_shnum.value, this.e_shnum.value),
                "Contains the number of entries in the section header table.")));
        currentPos += Elf64_Half.LENGTH;

        // e_shstrndx
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                Elf64_Half.LENGTH,
                String.format("e_shstrndx = 0x%04X (%d)", this.e_shstrndx.value, this.e_shstrndx.value),
                "Contains index of the section header table entry that contains the section names.")));
    }
}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/ElfFile.java`:

```java
/*
 * ElfFile.java    June 23, 2015, 21:47
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import java.io.File;
import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * File for Executable and Linkable Format (ELF).
 *
 * ELF file would be different on different CPU architecture. Here we assume
 * the CPU is 64-bit x86 based.
 *
 * @author Amos Shi
 * @see <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a>
 * @see <a href="https://github.com/torvalds/linux/blob/master/include/linux/elfcore.h">include/linux/elfcore.h</a>
 * @see <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/elf.h">arch/x86/include/asm/elf.h</a>
 * @see <a href="https://github.com/torvalds/linux/blob/master/arch/arm64/include/asm/elf.h">arch/arm64/include/asm/elf.h</a>
 * @see <a href="https://github.com/torvalds/linux/blob/master/arch/powerpc/boot/elf.h">arch/powerpc/boot/elf.h</a>
 */
public class ElfFile extends FileFormat {
    
    public final Identification ident;
    public final Elf64_Ehdr header;

    public ElfFile(File file) throws IOException, FileFormatException {
        super(file);

        PosDataInputStream input = new PosDataInputStream(new PosByteArrayInputStream(this.fileByteArray));
        this.ident = new Identification(input);

        PosDataInputStreamElf inputElf = new PosDataInputStreamElf(new PosByteArrayInputStream(this.fileByteArray), this.ident.EI_DATA);
        BytesTool.skip(input, Identification.EI_NIDENT);
        this.header = new Elf64_Ehdr(inputElf);
    }

    @Override
    public String getContentTabName() {
        return "Executable and Linkable Format";
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.ident.generateTreeNode(parentNode);
        this.header.generateTreeNode(parentNode);
    }
}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/Identification.java`:

```java
/*
 * Identification.java    Apr 10, 2020
 *
 * Copyright 2020, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * ELF header.
 *
 * @author Amos Shi
 *
 * @see
 * <a href="https://github.com/torvalds/linux/blob/master/include/linux/elf.h">include/linux/elf.h</a>
 * @see
 * <a href="https://github.com/torvalds/linux/blob/master/include/linux/elfcore.h">include/linux/elfcore.h</a>
 * @see
 * <a href="https://github.com/torvalds/linux/blob/master/arch/powerpc/boot/elf.h">arch/powerpc/boot/elf.h</a>
 *
 * <pre>
 * java:S116 - Field names should comply with a naming convention --- We respect the name from ELF C programming language source code
 * </pre>
 */
@SuppressWarnings("java:S116")
public class Identification extends FileComponent implements GenerateTreeNode {

    /**
     * Number of bytes in identification.
     *
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
     */
    public static final int EI_NIDENT = 16;

    /**
     * Magic number of {@code class} file.
     */
    public static final int MAGIC_NUMBER = 0x7F454C46;
    public static final int EI_MAG_SIZE = 4;
    public static final int EI_CLASS_SIZE = 1;
    public static final int EI_DATA_SIZE = 1;
    public static final int EI_VERSION_SIZE = 1;
    public static final int EI_OSABI_SIZE = 1;
    public static final int EI_ABIVERSION_SIZE = 1;
    public static final int EI_PAD_SIZE = 7;

    /**
     * Magic number of ELF file: <code>0x7F454C46</code>.
     *
     * @see #MAGIC_NUMBER
     */
    public final int EI_MAG;

    /**
     * ELF classification: 32- or 64-bit.
     *
     * @see ElfClass
     */
    public final ElfClass EI_CLASS;

    /**
     * ELV version.
     */
    public final Version EI_VERSION;

    /**
     * Little or big endianness.
     *
     * @see Endianness
     */
    public final Endianness EI_DATA;

    /**
     * Target operating system ABI.
     */
    public final OSAbi EI_OSABI;

    /**
     * Further specifies the ABI version. Its interpretation depends on the
     * target ABI {@link #EI_OSABI}. Linux kernel (after at least 2.6) has no
     * definition of it.
     *
     * @see
     * <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
     * and Linkable Format</a>
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
     */
    public final int EI_ABIVERSION;

    /**
     * Currently unused.
     */
    public final byte[] EI_PAD = new byte[EI_PAD_SIZE];

    Identification(final PosDataInputStream input) throws IOException, FileFormatException {
        this.startPos = input.getPos();

        // Magic number
        this.EI_MAG = input.readInt();
        if (this.EI_MAG != MAGIC_NUMBER) {
            throw new FileFormatException("The magic number is not for ELF file. expected=" + Integer.toHexString(MAGIC_NUMBER) + ", value=" + Integer.toHexString(this.EI_MAG));
        }

        // ELF Class: 32-/64-bit
        int value = input.readUnsignedByte();
        if (!ElfClass.contains(value)) {
            throw new FileFormatException("Unrecognized EI_CLASS value in  ELF file header. value=" + value);
        }
        this.EI_CLASS = ElfClass.valueOf(value);

        // Endianness
        value = input.readUnsignedByte();
        if (!Endianness.contains(value)) {
            throw new FileFormatException("Unrecognized EI_DATA value in  ELF file header. value=" + value);
        }
        this.EI_DATA = Endianness.valueOf(value);

        // Version
        value = input.readUnsignedByte();
        if (!Version.contains(value)) {
            throw new FileFormatException("Unrecognized EI_VERSION value in  ELF file header. value=" + value);
        }
        this.EI_VERSION = Version.valueOf(value);

        // EI_OSABI
        value = input.readUnsignedByte();
        if (!OSAbi.contains(value)) {
            throw new FileFormatException("Unrecognized EI_OSABI value in  ELF file header. value=" + value);
        }
        this.EI_OSABI = OSAbi.valueOf(value);

        // EI_ABIVERSION
        this.EI_ABIVERSION = input.readUnsignedByte();

        // EI_PAD
        final int padLen = input.read(this.EI_PAD);
        if (padLen != EI_PAD_SIZE) {
            throw new FileFormatException("Failed to read EI_PAD value in  ELF file header. length=" + padLen);
        }

        this.length = input.getPos();

        if (this.length != EI_NIDENT) {
            throw new FileFormatException("Invalid length of ELF file identification. expected=" + EI_NIDENT + ", length=" + this.length);
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int currentPos = this.startPos;

        DefaultMutableTreeNode node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                String.format("ELF File Header [0x%08X, %d]", this.startPos, this.length),
                "The ELF header defines whether to use 32-bit or 64-bit addresses. The header contains three fields that are affected by this setting and offset other fields that follow them."
        ));
        parentNode.add(node);

        // EI_MAG
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_MAG_SIZE,
                String.format("EI_MAG = 0x%08X", this.EI_MAG),
                "0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number.")));
        currentPos += EI_MAG_SIZE;

        // EI_CLASS
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_CLASS_SIZE,
                String.format("EI_CLASS = %d : %s", this.EI_CLASS.value, this.EI_CLASS.name()),
                "Length of target CPU, like 32-bit or 64-bit"
        )));
        currentPos += EI_CLASS_SIZE;

        // EI_DATA
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_DATA_SIZE,
                String.format("EI_DATA = %d : %s", this.EI_DATA.value, this.EI_DATA.toString()),
                "Endianness of number format, like little or big endianness"
        )));
        currentPos += EI_DATA_SIZE;

        // EI_VERSION
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_VERSION_SIZE,
                String.format("EI_VERSION = %d : %s", this.EI_VERSION.value, this.EI_VERSION.name()),
                "Version of ELF file"
        )));
        currentPos += EI_VERSION_SIZE;

        // EI_OSABI
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_OSABI_SIZE,
                String.format("EI_OSABI = %d : %s", this.EI_OSABI.value, this.EI_OSABI.name()),
                "Identifies the target operating system ABI. Zero (0) means regardless of the target platform.")));
        currentPos += EI_OSABI_SIZE;

        // EI_ABIVERSION
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_ABIVERSION_SIZE,
                String.format("EI_ABIVERSION = %d", this.EI_ABIVERSION),
                "Further specifies the ABI version. Its interpretation depends on the target ABI. Linux kernel (after at least 2.6) has no definition of it, so it is ignored for statically-linked executables."
        )));
        currentPos += EI_ABIVERSION_SIZE;

        // EI_PAD
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                currentPos,
                EI_PAD_SIZE,
                String.format("EI_PAD (length = %d)", EI_PAD_SIZE),
                "Currently unused"
        )));
    }

    public enum ElfClass {
        /**
         * Invalid class.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/arch/powerpc/boot/elf.h">arch/powerpc/boot/elf.h</a>
         */
        ELFCLASSNONE(0),
        /**
         * Current ELF file is 32-bit format.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFCLASS32(1),
        /**
         * Current ELF file is 64-bit format.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFCLASS64(2);

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        private ElfClass(final int i) {
            this.value = i;
        }

        /**
         * Check if a value is a valid {@link ElfClass} enumeration value.
         *
         * @param v Value to test
         * @return <code>true</code> if contains the specified value, else
         * <code>false</code>
         */
        public static boolean contains(int v) {
            boolean result = false;
            for (ElfClass cls : ElfClass.values()) {
                if (cls.value == v) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        /**
         * Returns the enum constant of the specified enum type with the
         * specified name.
         *
         * @param v the value of the constant to return
         * @return the enum constant of the specified enum type with the
         * specified value
         */
        public static ElfClass valueOf(int v) {
            for (ElfClass cls : ElfClass.values()) {
                if (cls.value == v) {
                    return cls;
                }
            }

            throw new IllegalArgumentException(String.format("Unrecognized EI_CLASS value. value=%d", v));
        }
    }

    /**
     * Little or big endianness.
     *
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/kernel/kexec_elf.c">kernel/kexec_elf.c</a>
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/arch/x86/um/asm/elf.h">arch/x86/um/asm/elf.h</a>
     *
     */
    public enum Endianness {

        /**
         * Little endianness.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFDATA2LSB(1, "Little endianness"),
        /**
         * Big endianness.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFDATA2MSB(2, "Big endianness.");

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        /**
         * Description of the endianness since the enum name is not readable.
         */
        public final String description;

        private Endianness(int e, String d) {
            this.value = e;
            this.description = d;
        }

        @Override
        public String toString() {
            return this.name() + ", " + this.description;
        }

        /**
         * Check if a value is a valid {@link Endianness} enumeration value.
         *
         * @param v Value to test
         * @return <code>true</code> if contains the specified value, else
         * <code>false</code>
         */
        public static boolean contains(int v) {
            boolean result = false;
            for (Endianness cls : Endianness.values()) {
                if (cls.value == v) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        /**
         * Returns the enum constant of the specified enum type with the
         * specified name.
         *
         * @param v the value of the constant to return
         * @return the enum constant of the specified enum type with the
         * specified value
         */
        public static Endianness valueOf(int v) {
            for (Endianness endian : Endianness.values()) {
                if (endian.value == v) {
                    return endian;
                }
            }

            throw new IllegalArgumentException(String.format("Unrecognized EI_DATA value. value=%d", v));
        }

    }

    /**
     * Set to 1 for the original and current version of ELF.
     */
    public enum Version {
        /**
         * ELV version: current version.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        EV_CURRENT(1);

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        private Version(int v) {
            this.value = v;
        }

        /**
         * Check if a value is a valid {@link Version} enumeration value.
         *
         * @param v Value to test
         * @return <code>true</code> if contains the specified value, else
         * <code>false</code>
         */
        public static boolean contains(int v) {
            boolean result = false;
            for (Version ver : Version.values()) {
                if (ver.value == v) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        /**
         * Returns the enum constant of the specified enum type with the
         * specified name.
         *
         * @param v the value of the constant to return
         * @return the enum constant of the specified enum type with the
         * specified value
         */
        public static Version valueOf(int v) {
            for (Version ver : Version.values()) {
                if (ver.value == v) {
                    return ver;
                }
            }

            throw new IllegalArgumentException(String.format("Unrecognized EI_VERSION value. value=%d", v));
        }
    }

    /**
     * Identifies the target operating system ABI.
     *
     * @see
     * <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
     * and Linkable Format</a>
     * @see
     * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
     *
     * <pre>
     * java:S115 - Constant names should comply with a naming convention --- We respect the name from ELF Spec instead
     * </pre>
     */
    @SuppressWarnings("java:S115")
    public enum OSAbi {
        /**
         * Regardless of the target platform. The value <code>0</code> could be
         * either <code>System V</code> or <code>ELFOSABI_NONE</code>. Here we
         * respect the constant name defined in Linux source code located at
         * <code>include/uapi/linux/elf.h</code>.
         *
         * @see
         * <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
         * and Linkable Format</a>
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFOSABI_NONE(0x00),
        HP_UNIX(0x01),
        NetBSD(0x02),
        /**
         * Linux system.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h">include/uapi/linux/elf.h</a>
         */
        ELFOSABI_LINUX(0x03),
        GNU_Hurd(0x04),
        Solaris(0x06),
        AIX(0x07),
        IRIX(0x08),
        FreeBSD(0x09),
        Tru64(0x0A),
        Novell_Modesto(0x0B),
        OpenBSD(0x0C),
        OpenVMS(0x0D),
        NonStop_Kernel(0x0E),
        AROS(0x0F),
        Fenix_OS(0x10),
        CloudABI(0x11),
        Stratus_Technologies_OpenVOS(0x12),
        /**
         * ARM FDPIC platform.
         *
         * @see
         * <a href="https://github.com/torvalds/linux/blob/master/arch/arm/include/asm/elf.h">arch/arm/include/asm/elf.h</a>
         */
        ELFOSABI_ARM_FDPIC(65);

        /**
         * Inner value of the enumeration item.
         */
        public final int value;

        private OSAbi(int v) {
            this.value = v;
        }

        /**
         * Check if a value is a valid {@link Version} enumeration value.
         *
         * @param v Value to test
         * @return <code>true</code> if contains the specified value, else
         * <code>false</code>
         */
        public static boolean contains(int v) {
            boolean result = false;
            for (OSAbi abi : OSAbi.values()) {
                if (abi.value == v) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        /**
         * Returns the enum constant of the specified enum type with the
         * specified name.
         *
         * @param v the value of the constant to return
         * @return the enum constant of the specified enum type with the
         * specified value
         */
        public static OSAbi valueOf(int v) {
            for (OSAbi abi : OSAbi.values()) {
                if (abi.value == v) {
                    return abi;
                }
            }

            throw new IllegalArgumentException(String.format("Unrecognized EI_OSABI value. value=%d", v));
        }
    }

}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/PluginDescriptorELF.java`:

```java
/*
 * PluginDescriptorELF.java    June 23, 2015, 21:45
 *
 * Copyright 2015, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorELF implements PluginDescriptor {

    @Override
    public String getExtensionDescription() {
        return "Executable and Linkable Format (*.axf, *.bin, *.elf, *.o, *.prx, *.puff, *.so)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"axf", "bin", "elf", "o", "prx", "puff", "so"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return ElfFile.class;
    }

}

```

`FormatELF/src/main/java/org/binaryinternals/format/elf/PosDataInputStreamElf.java`:

```java
/*
 * PosDataInputStreamElf.java    Apr 10, 2020
 *
 * Copyright 2020, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.elf;

import java.io.IOException;
import java.math.BigInteger;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Addr;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Half;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Off;
import org.binaryinternals.format.elf.Elf64Type.Elf64_SHalf;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Sword;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Sxword;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Word;
import org.binaryinternals.format.elf.Elf64Type.Elf64_Xword;
import org.binaryinternals.format.elf.Identification.Endianness;

/**
 * Extended reader for <code>ELF</code> format.
 *
 * @author Amos Shi
 *
 * <pre>
 * java:S100 - Method names should comply with a naming convention --- We respect the name from ELF spec instead
 * </pre>
 */
@SuppressWarnings("java:S100")
public class PosDataInputStreamElf extends PosDataInputStream {

    protected final Endianness endian;

    PosDataInputStreamElf(PosByteArrayInputStream in, Endianness e) throws IOException {
        super(in);

        // Endianness
        if (e != Endianness.ELFDATA2LSB && e != Endianness.ELFDATA2MSB) {
            // Make sure there is only two Endianness
            throw new IllegalArgumentException("Invalid Endianness in ELF file. value=" + e);
        }
        this.endian = e;

        // Skip the ELF file Identification
        BytesTool.skip(this, Identification.EI_NIDENT);
    }

    /**
     * Read data for {@link Elf64_Addr} (<code>typedef __u64    Elf64_Addr</code>).
     *
     * @return Value in {@link Elf64_Addr}
     * @throws IOException Read data failed
     */
    public Elf64_Addr read_Elf64_Addr() throws IOException {
        BigInteger value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readUnsignedLongInLittleEndian()
                : this.readUnsignedLong();
        return new Elf64_Addr(value);
    }

    /**
     * Read data for {@link Elf64_Half}
     * (<code>typedef __u16	Elf64_Half;</code>).
     *
     * @return Value in {@link Elf64_Half}
     * @throws IOException Read data failed
     */
    public Elf64_Half read_Elf64_Half() throws IOException {
        int value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readUnsignedShortInLittleEndian()
                : this.readUnsignedShort();
        return new Elf64_Half(value);
    }

    /**
     * Read data for {@link Elf64_Off} (<code>typedef __u64	Elf64_Off;</code>).
     *
     * @return Value in {@link Elf64_Off}
     * @throws IOException Read data failed
     */
    public Elf64_Off read_Elf64_Off() throws IOException {
        BigInteger value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readUnsignedLongInLittleEndian()
                : this.readUnsignedLong();
        return new Elf64_Off(value);
    }

    /**
     * Read data for {@link Elf64_SHalf}
     * (<code>typedef __s16	Elf64_SHalf;</code>).
     *
     * @return Value in {@link Elf64_SHalf}
     * @throws IOException Read data failed
     */
    public Elf64_SHalf read_Elf64_SHalf() throws IOException {
        short value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readShortInLittleEndian()
                : this.readShort();
        return new Elf64_SHalf(value);
    }

    /**
     * Read data for {@link Elf64_Sword}
     * (<code>typedef __s32	Elf64_Sword;</code>).
     *
     * @return Value in {@link Elf64_Sword}
     * @throws IOException Read data failed
     */
    public Elf64_Sword read_Elf64_Sword() throws IOException {
        int value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readIntInLittleEndian()
                : this.readInt();
        return new Elf64_Sword(value);
    }

    /**
     * Read data for {@link Elf64_Sxword}
     * (<code>typedef __s64	Elf64_Sxword;</code>).
     *
     * @return Value in {@link Elf64_Sxword}
     * @throws IOException Read data failed
     */
    public Elf64_Sxword read_Elf64_Sxword() throws IOException {
        long value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readLongInLittleEndian()
                : this.readLong();
        return new Elf64_Sxword(value);
    }

    /**
     * Read data for {@link Elf64_Word}
     * (<code>typedef __u32	Elf64_Word;</code>).
     *
     * @return Value in {@link Elf64_Word}
     * @throws IOException Read data failed
     */
    public Elf64_Word read_Elf64_Word() throws IOException {
        long value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readUnsignedIntInLittleEndian()
                : this.readUnsignedInt();
        return new Elf64_Word(value);
    }

    /**
     * Read data for {@link Elf64_Xword}
     * (<code>typedef __u64	Elf64_Xword;</code>).
     *
     * @return Value in {@link Elf64_Xword}
     * @throws IOException Read data failed
     */
    public Elf64_Xword read_Elf64_Xword() throws IOException {
        BigInteger value = (Endianness.ELFDATA2LSB.value == this.endian.value)
                ? this.readUnsignedLongInLittleEndian()
                : this.readUnsignedLong();
        return new Elf64_Xword(value);
    }

}

```

`FormatJPEG/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.jpeg</artifactId>
    <version>2.1</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatJPEG</name>
    <description>JPEG or JPG is a commonly used method of lossy compression for digital images, particularly for those images produced by digital photography.</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.jpeg.PluginDescriptorJPEG</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>
    
</project>

```

`FormatJPEG/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatjpeg {
    requires static com.github.spotbugs.annotations;
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.jpeg;
    exports org.binaryinternals.format.jpeg.icc;
    exports org.binaryinternals.format.jpeg.ps;
    exports org.binaryinternals.format.jpeg.tiff;
    exports org.binaryinternals.format.jpeg.xmp;
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/FileData.java`:

```java
/*
 * FileData.java    Nov 05, 2010, 23:17
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class FileData extends FileComponent implements GenerateTreeNode {

    private final boolean isCompressedData;

    FileData(final PosDataInputStream pDis, final int length, final boolean isCompressedData) throws IOException {
        super.startPos = pDis.getPos();
        super.length = length;
        this.isCompressedData = isCompressedData;

        if (length > 0) {
            BytesTool.skip(pDis, length);
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        String nodeName;

        if (isCompressedData) {
            nodeName = "Compressed Data";
        } else {
            nodeName = "File Data";
        }
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos(),
                this.getLength(),
                nodeName)));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/JPEGFile.java`:

```java
/*
 * JPEGFile.java    August 21, 2010, 21:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;

/**
 *
 * @author Amos Shi
 */
public class JPEGFile extends FileFormat {

    public JPEGFile(File file) throws IOException, FileFormatException {
        super(file);
        this.parse();
    }

    private void parse() throws IOException, FileFormatException {
        Marker marker;
        PosDataInputStream posDataInputStream = new PosDataInputStream(new PosByteArrayInputStream(super.fileByteArray));

        // Marker - SOI
        final int soi = posDataInputStream.readUnsignedShort();
        if (MarkerCode.SOI != soi) {
            throw new FileFormatException(String.format(
                    "File is not started with JPEG SOI. Expected value %x, current value %x.",
                    MarkerCode.SOI, soi));
        }
        super.addFileComponent(new Marker_SOI(posDataInputStream, soi));

        // Markers & File Data
        boolean isCompressedData = false;
        boolean isNextMarkerFound;
        int i;
        int length;
        while (posDataInputStream.getPos() < (this.fileByteArray.length - 1)) {
            if (MarkerCode.isValid(this.getMarkerCode(posDataInputStream.getPos()))) {
                marker = MarkerParse.parse(posDataInputStream);
                super.addFileComponent(marker);
                isCompressedData = MarkerCode.isCompressedDataFollowed(marker.marker_code);
            } else {
                // find next marker
                isNextMarkerFound = false;
                for (i = posDataInputStream.getPos() + 1; i < this.fileByteArray.length - 1; i++) {
                    if (MarkerCode.isValid(this.getMarkerCode(i))) {
                        isNextMarkerFound = true;
                        break;
                    }
                }
                // Determine the length
                if (isNextMarkerFound) {
                    length = i - posDataInputStream.getPos();
                } else {
                    length = this.fileByteArray.length - posDataInputStream.getPos();
                }
                // Add one component
                super.addFileComponent(new FileData(posDataInputStream, length, isCompressedData));
            }
        }

        // Parse each Marker
        final Iterator<FileComponent> iteratorMarker = super.components.values().iterator();
        FileComponent comp;
        byte[] markerByteArray;
        int markerByteArraySize;

        while (iteratorMarker.hasNext()) {
            comp = iteratorMarker.next();
            if (comp instanceof Marker) {
                marker = (Marker) comp;
                if (marker.getMarkerLength() > 0) {
                    markerByteArraySize = marker.getLength() + MarkerCode.MARKER_CODE_BYTES_COUNT;
                    markerByteArray = new byte[markerByteArraySize];
                    System.arraycopy(this.fileByteArray, marker.getStartPos(), markerByteArray, 0, markerByteArraySize);
                    try {
                        marker.parse(new PosDataInputStream(new PosByteArrayInputStream(markerByteArray), marker.getStartPos()));
                    } catch (IOException | FileFormatException ex) {
                        System.out.println("JPEGFile.parse() - " + marker.getMarkerName() + " - " + ex.toString());
                    }
                }
            }
        }
    } // End method parse

    private int getMarkerCode(int markerOffset) {
        byte[] data = this.getFileByteArray(markerOffset, 2);
        return ((data[0] & 0x000000FF) << 8) + (data[1] & 0x000000FF);
    }

    @Override
    public String getContentTabName() {
        return "JPEG File";
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode root) {
        final Iterator<FileComponent> iterator = super.components.values().iterator();

        while (iterator.hasNext()) {
            FileComponent comp = iterator.next();
            if (comp instanceof GenerateTreeNode) {
                GenerateTreeNode generator = (GenerateTreeNode) comp;
                generator.generateTreeNode(root);
            }
        } // End while
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker.java`:

```java
/*
 * MarkerCode.java    August 27, 2010, 22:49
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker extends FileComponent implements GenerateTreeNode {

    private static final int IDENTIFIER_LENGTH_MAX = 100;
    @SuppressWarnings("ProtectedField")
    protected final int marker_code;
    @SuppressWarnings("ProtectedField")
    protected int marker_length;

    Marker(final PosDataInputStream pDIS, int markerCode) throws IOException, FileFormatException {

        // The marker is not valid
        if (!MarkerCode.isValid(markerCode)) {
            throw new FileFormatException(String.format(
                    "Non-valid marker found. marker code = %X (%d).",
                    markerCode, markerCode));
        }

        // Start Position of this Marker
        super.startPos = pDIS.getPos() - 2;

        // Marker Code
        this.marker_code = markerCode;

        // Marker Length
        if (MarkerCode.isLengthAvailable(markerCode)) {
            this.marker_length = pDIS.readUnsignedShort();
            super.length = this.marker_length + 2;
            long skip = this.marker_length - 2;
            BytesTool.skip(pDIS, skip);
        } else {
            this.marker_length = 0;
            super.length = MarkerCode.MARKER_CODE_BYTES_COUNT;
        }
    }

    protected void parse(final PosDataInputStream pDisMarker) throws IOException, FileFormatException {
    }

    protected void parseInitSkip(final PosDataInputStream pDisMarker) throws IOException {
        // Skip the marker code and length field
        long skip = MarkerCode.MARKER_CODE_BYTES_COUNT + MarkerCode.MARKER_LENGTH_BYTES_COUNT;
        BytesTool.skip(pDisMarker, skip);
    }

    protected String parseIdentifier(final PosDataInputStream pDisMarker) throws IOException {

        // Parse the Identifier, an '\000' ended ASCII string
        final StringBuffer sb = new StringBuffer(IDENTIFIER_LENGTH_MAX);
        while (sb.length() <= IDENTIFIER_LENGTH_MAX) {
            byte b = pDisMarker.readByte();
            if (b == 0) {
                break;
            }
            sb.append((char) b);
        }
        return sb.toString();
    }

    ///////////////////////////////////////////////////////////////////////////
    // Get each field
    public int getMarker() {
        return this.marker_code;
    }

    public String getMarkerName() {
        return MarkerCode.getMarkerName(this.marker_code);
    }

    public String getMarkerDescription() {
        return MarkerCode.getMarkerDescription(this.marker_code);
    }

    public int getMarkerLength() {
        return this.marker_length;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (MarkerCode.isLengthAvailable(this.marker_code)) {
            DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.getStartPos(),
                    2,
                    String.format("Marker code = 0x%X", this.getMarker()));
            comp.setDescription(MarkerCode.getMarkerCodeDescription());
            markerNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.getStartPos() + 2,
                    2,
                    String.format("length = %d", this.getMarkerLength()));
            markerNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.getStartPos() + 4,
                    this.getMarkerLength() - 2,
                    "marker data");
            markerNode.add(new DefaultMutableTreeNode(comp));
        } else {
            this.generateTreeNode_Marker(parentNode);
        }
    }

    DefaultMutableTreeNode generateTreeNode_Marker(DefaultMutableTreeNode root) {
        DefaultMutableTreeNode markerNode;

        JTreeNodeFileComponent node = new JTreeNodeFileComponent(
                this.getStartPos(),
                this.getLength(),
                this.getMarkerName());
        node.setDescription(this.getMarkerDescription());
        root.add(markerNode = new DefaultMutableTreeNode(node));

        return markerNode;
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/MarkerCode.java`:

```java
/*
 * MarkerCode.java    Oct 02, 2010, 21:39
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

/**
 *
 * @author Amos Shi
 */
public class MarkerCode {

    public static final int MARKER_CODE_BYTES_COUNT = 2;
    public static final int MARKER_LENGTH_BYTES_COUNT = 2;
    public static final int MIN = 0xFF00;
    public static final int TEMP = 0xFF01;                      // Standalone, For temporary private use in arithmetic coding
    public static final int RES_MIN = 0xFF02;                   // Reserved
    public static final int RES_MAX = 0xFFBF;                   // Reserved
    public static final int SOF00 = 0xFFC0;                     // Specified
    public static final int SOF01 = 0xFFC1;                     // Specified
    public static final int SOF02 = 0xFFC2;                     // Specified
    public static final int SOF03 = 0xFFC3;                     // Specified
    public static final int DHT = 0xFFC4;                       // Specified
    public static final int SOF05 = 0xFFC5;                     // Specified
    public static final int SOF06 = 0xFFC6;                     // Specified
    public static final int SOF07 = 0xFFC7;                     // Specified
    public static final int JPG = 0xFFC8;                       // Specified
    public static final int SOF09 = 0xFFC9;                     // Specified
    public static final int SOF10 = 0xFFCA;                     // Specified
    public static final int SOF11 = 0xFFCB;                     // Specified
    public static final int DAC = 0xFFCC;                       // Specified
    public static final int SOF13 = 0xFFCD;                     // Specified
    public static final int SOF14 = 0xFFCE;                     // Specified
    public static final int SOF15 = 0xFFCF;                     // Specified
    public static final int RST0 = 0xFFD0;                      // Specified, Standalone
    public static final int RST1 = 0xFFD1;                      // Specified, Standalone
    public static final int RST2 = 0xFFD2;                      // Specified, Standalone
    public static final int RST3 = 0xFFD3;                      // Specified, Standalone
    public static final int RST4 = 0xFFD4;                      // Specified, Standalone
    public static final int RST5 = 0xFFD5;                      // Specified, Standalone
    public static final int RST6 = 0xFFD6;                      // Specified, Standalone
    public static final int RST7 = 0xFFD7;                      // Specified, Standalone
    public static final int SOI = 0xFFD8;                       // Specified, Standalone
    public static final int EOI = 0xFFD9;                       // Specified, Standalone
    public static final int SOS = 0xFFDA;                       // Specified
    public static final int DQT = 0xFFDB;                       // Specified
    public static final int DNL = 0xFFDC;                       // Specified
    public static final int DRI = 0xFFDD;                       // Specified
    public static final int DHP = 0xFFDE;                       // Specified
    public static final int EXP = 0xFFDF;                       // Specified
    public static final int APP00 = 0xFFE0;                     // Specified
    public static final int APP01 = 0xFFE1;                     // Specified
    public static final int APP02 = 0xFFE2;                     // Specified
    public static final int APP03 = 0xFFE3;                     // Specified
    public static final int APP04 = 0xFFE4;                     // Specified
    public static final int APP05 = 0xFFE5;                     // Specified
    public static final int APP06 = 0xFFE6;                     // Specified
    public static final int APP07 = 0xFFE7;                     // Specified
    public static final int APP08 = 0xFFE8;                     // Specified
    public static final int APP09 = 0xFFE9;                     // Specified
    public static final int APP10 = 0xFFEA;                     // Specified
    public static final int APP11 = 0xFFEB;                     // Specified
    public static final int APP12 = 0xFFEC;                     // Specified
    public static final int APP13 = 0xFFED;                     // Specified
    public static final int APP14 = 0xFFEE;                     // Specified
    public static final int APP15 = 0xFFEF;                     // Specified
    public static final int JPG00 = 0xFFF0;                     // Reserved for JPEG extensions
    public static final int JPG01 = 0xFFF1;                     // Reserved for JPEG extensions
    public static final int JPG02 = 0xFFF2;                     // Reserved for JPEG extensions
    public static final int JPG03 = 0xFFF3;                     // Reserved for JPEG extensions
    public static final int JPG04 = 0xFFF4;                     // Reserved for JPEG extensions
    public static final int JPG05 = 0xFFF5;                     // Reserved for JPEG extensions
    public static final int JPG06 = 0xFFF6;                     // Reserved for JPEG extensions
    public static final int JPG07 = 0xFFF7;                     // Reserved for JPEG extensions
    public static final int JPG08 = 0xFFF8;                     // Reserved for JPEG extensions
    public static final int JPG09 = 0xFFF9;                     // Reserved for JPEG extensions
    public static final int JPG10 = 0xFFFA;                     // Reserved for JPEG extensions
    public static final int JPG11 = 0xFFFB;                     // Reserved for JPEG extensions
    public static final int JPG12 = 0xFFFC;                     // Reserved for JPEG extensions
    public static final int JPG13 = 0xFFFD;                     // Reserved for JPEG extensions
    public static final int COM = 0xFFFE;                       // Specified
    public static final int MAX = 0xFFFF;

    /**
     * The marker code value is in valid value space or not.
     *
     * @param code Marker code value
     * @return <code>true</code> when in valid value space, else <code>false</code>
     */
    public static boolean isValid(int code) {
        return (code > MIN && code != MAX);
    }

    /**
     * The marker structure is specified in <code>ITU</code> <code>T.81</code> or not.
     *
     * @param code Marker code value
     * @return <code>true</code> when the structure is specified, else <code>false</code>
     */
    public static boolean isSpecified(int code) {
        boolean result = false;
        if (code == TEMP) {
            result = true;
        } else if (code >= SOF00 && code <= APP15) {
            result = true;
        } else if (code == COM) {
            result = true;
        }

        return result;
    }

    /**
     * The marker is stands alone or not.
     * When a marker is stands alone, it is not the start of a marker segment.
     *
     * @param code Marker code value
     * @return <code>true</code> when standalone, else <code>false</code>
     */
    public static boolean isStandalone(int code) {
        boolean result = false;
        if (code == TEMP) {
            result = true;
        } else if (code >= RST0 && code <= EOI) {
            result = true;
        }

        return result;
    }

    /**
     * Whether a two byte length indicator is followed the marker code or not.
     *
     * @param code Marker code value
     * @return <code>true</code> when length indicator is available, else <code>false</code>
     */
    public static boolean isLengthAvailable(int code) {
        boolean result = false;
        if (code >= SOF00 && code <= SOF15) {
            result = true;
        } else if (code >= SOS && code <= APP15) {
            result = true;
        } else if (code == COM) {
            result = true;
        }

        return result;
    }

    /**
     * Whether compressed data is followed the marker.
     *
     * @param code Marker code value
     * @return <code>true</code> when compressed data is followed, else <code>false</code>
     */
    public static boolean isCompressedDataFollowed(int code) {
        if (code == SOS
                || code <= RST1
                || code <= RST2
                || code <= RST3
                || code <= RST4
                || code <= RST5
                || code <= RST6
                || code <= RST7) {
            return true;
        } else {
            return false;
        }
    }

    public static String getMarkerName(int markerCode) {
        String name = "Error";

        if (markerCode == MarkerCode.TEMP) {
            name = "TEMP";
        } else if (markerCode >= MarkerCode.RES_MIN && markerCode <= MarkerCode.RES_MAX) {
            name = "RES";
        } else if (markerCode >= MarkerCode.SOF00 && markerCode <= MarkerCode.COM) {
            switch (markerCode) {
                case MarkerCode.SOF00:
                    name = "SOF00";
                    break;
                case MarkerCode.SOF01:
                    name = "SOF01";
                    break;
                case MarkerCode.SOF02:
                    name = "SOF02";
                    break;
                case MarkerCode.SOF03:
                    name = "SOF03";
                    break;
                case MarkerCode.DHT:
                    name = "DHT";
                    break;
                case MarkerCode.SOF05:
                    name = "SOF05";
                    break;
                case MarkerCode.SOF06:
                    name = "SOF06";
                    break;
                case MarkerCode.SOF07:
                    name = "SOF07";
                    break;
                case MarkerCode.JPG:
                    name = "JPG";
                    break;
                case MarkerCode.SOF09:
                    name = "SOF09";
                    break;
                case MarkerCode.SOF10:
                    name = "SOF10";
                    break;
                case MarkerCode.SOF11:
                    name = "SOF11";
                    break;
                case MarkerCode.DAC:
                    name = "DAC";
                    break;
                case MarkerCode.SOF13:
                    name = "SOF13";
                    break;
                case MarkerCode.SOF14:
                    name = "SOF14";
                    break;
                case MarkerCode.SOF15:
                    name = "SOF15";
                    break;
                case MarkerCode.RST0:
                    name = "RST0";
                    break;
                case MarkerCode.RST1:
                    name = "RST1";
                    break;
                case MarkerCode.RST2:
                    name = "RST2";
                    break;
                case MarkerCode.RST3:
                    name = "RST3";
                    break;
                case MarkerCode.RST4:
                    name = "RST4";
                    break;
                case MarkerCode.RST5:
                    name = "RST5";
                    break;
                case MarkerCode.RST6:
                    name = "RST6";
                    break;
                case MarkerCode.RST7:
                    name = "RST7";
                    break;
                case MarkerCode.SOI:
                    name = "SOI";
                    break;
                case MarkerCode.EOI:
                    name = "EOI";
                    break;
                case MarkerCode.SOS:
                    name = "SOS";
                    break;
                case MarkerCode.DQT:
                    name = "DQT";
                    break;
                case MarkerCode.DNL:
                    name = "DNL";
                    break;
                case MarkerCode.DRI:
                    name = "DRI";
                    break;
                case MarkerCode.DHP:
                    name = "DHP";
                    break;
                case MarkerCode.EXP:
                    name = "EXP";
                    break;
                case MarkerCode.APP00:
                    name = "APP00";
                    break;
                case MarkerCode.APP01:
                    name = "APP01";
                    break;
                case MarkerCode.APP02:
                    name = "APP02";
                    break;
                case MarkerCode.APP03:
                    name = "APP03";
                    break;
                case MarkerCode.APP04:
                    name = "APP04";
                    break;
                case MarkerCode.APP05:
                    name = "APP05";
                    break;
                case MarkerCode.APP06:
                    name = "APP06";
                    break;
                case MarkerCode.APP07:
                    name = "APP07";
                    break;
                case MarkerCode.APP08:
                    name = "APP08";
                    break;
                case MarkerCode.APP09:
                    name = "APP09";
                    break;
                case MarkerCode.APP10:
                    name = "APP10";
                    break;
                case MarkerCode.APP11:
                    name = "APP11";
                    break;
                case MarkerCode.APP12:
                    name = "APP12";
                    break;
                case MarkerCode.APP13:
                    name = "APP13";
                    break;
                case MarkerCode.APP14:
                    name = "APP14";
                    break;
                case MarkerCode.APP15:
                    name = "APP15";
                    break;
                case MarkerCode.JPG00:
                    name = "SOF00";
                    break;
                case MarkerCode.JPG01:
                    name = "SOF01";
                    break;
                case MarkerCode.JPG02:
                    name = "SOF02";
                    break;
                case MarkerCode.JPG03:
                    name = "SOF03";
                    break;
                case MarkerCode.JPG04:
                    name = "SOF04";
                    break;
                case MarkerCode.JPG05:
                    name = "SOF05";
                    break;
                case MarkerCode.JPG06:
                    name = "SOF06";
                    break;
                case MarkerCode.JPG07:
                    name = "SOF07";
                    break;
                case MarkerCode.JPG08:
                    name = "SOF08";
                    break;
                case MarkerCode.JPG09:
                    name = "SOF09";
                    break;
                case MarkerCode.JPG10:
                    name = "SOF10";
                    break;
                case MarkerCode.JPG11:
                    name = "SOF11";
                    break;
                case MarkerCode.JPG12:
                    name = "SOF12";
                    break;
                case MarkerCode.JPG13:
                    name = "SOF13";
                    break;
                case MarkerCode.COM:
                    name = "COM";
                    break;
                default:
                    name = "Un-recognized";
                    break;
            }
        }

        return name;
    }

    public static String getMarkerDescription(int markerCode) {
        String desc = "Error";

        if (markerCode == MarkerCode.MIN) {
            desc = "MIN";
        } else if (markerCode == MarkerCode.TEMP) {
            desc = "[<strong>Reserved markers</strong>] For temporary private use in arithmetic coding";
        } else if (markerCode >= MarkerCode.RES_MIN && markerCode <= MarkerCode.RES_MAX) {
            desc = "[<strong>Reserved markers</strong>] Reserved";
        } else if (markerCode >= MarkerCode.SOF00 && markerCode <= MarkerCode.COM) {
            switch (markerCode) {
                case MarkerCode.SOF00:
                    desc = "[<strong>Start Of Frame markers, non-differential, Huffman coding</strong>] Baseline DCT";
                    break;
                case MarkerCode.SOF01:
                    desc = "[<strong>Start Of Frame markers, non-differential, Huffman coding</strong>] Extended sequential DCT";
                    break;
                case MarkerCode.SOF02:
                    desc = "[<strong>Start Of Frame markers, non-differential, Huffman coding</strong>] Progressive DCT";
                    break;
                case MarkerCode.SOF03:
                    desc = "[<strong>Start Of Frame markers, non-differential, Huffman coding</strong>] Lossless (sequential)";
                    break;
                case MarkerCode.DHT:
                    desc = "[<strong>Huffman table specification</strong>] Define Huffman table(s)";
                    break;
                case MarkerCode.SOF05:
                    desc = "[<strong>Start Of Frame markers, differential, Huffman coding</strong>] Differential sequential DCT";
                    break;
                case MarkerCode.SOF06:
                    desc = "[<strong>Start Of Frame markers, differential, Huffman coding</strong>] Differential progressive DCT";
                    break;
                case MarkerCode.SOF07:
                    desc = "[<strong>Start Of Frame markers, differential, Huffman coding</strong>] Differential lossless (sequential)";
                    break;
                case MarkerCode.JPG:
                    desc = "[<strong>Start Of Frame markers, non-differential, arithmetic coding</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.SOF09:
                    desc = "[<strong>Start Of Frame markers, non-differential, arithmetic coding</strong>] Extended sequential DCT";
                    break;
                case MarkerCode.SOF10:
                    desc = "[<strong>Start Of Frame markers, non-differential, arithmetic coding</strong>] Progressive DCT";
                    break;
                case MarkerCode.SOF11:
                    desc = "[<strong>Start Of Frame markers, non-differential, arithmetic coding</strong>] Lossless (sequential)";
                    break;
                case MarkerCode.DAC:
                    desc = "[<strong>Arithmetic coding conditioning specification</strong>] Define arithmetic coding conditioning(s)";
                    break;
                case MarkerCode.SOF13:
                    desc = "[<strong>Start Of Frame markers, differential, arithmetic coding</strong>] Differential sequential DCT";
                    break;
                case MarkerCode.SOF14:
                    desc = "[<strong>Start Of Frame markers, differential, arithmetic coding</strong>] Differential progressive DCT";
                    break;
                case MarkerCode.SOF15:
                    desc = "[<strong>Start Of Frame markers, differential, arithmetic coding</strong>] Differential lossless (sequential)";
                    break;
                case MarkerCode.RST0:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “0”";
                    break;
                case MarkerCode.RST1:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “1”";
                    break;
                case MarkerCode.RST2:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “2”";
                    break;
                case MarkerCode.RST3:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “3”";
                    break;
                case MarkerCode.RST4:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “4”";
                    break;
                case MarkerCode.RST5:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “5”";
                    break;
                case MarkerCode.RST6:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “6”";
                    break;
                case MarkerCode.RST7:
                    desc = "[<strong>Restart interval termination</strong>] Restart with modulo 8 count “7”";
                    break;
                case MarkerCode.SOI:
                    desc = "[<strong>Other markers</strong>] Start of image";
                    break;
                case MarkerCode.EOI:
                    desc = "[<strong>Other markers</strong>] End of image";
                    break;
                case MarkerCode.SOS:
                    desc = "[<strong>Other markers</strong>] Start of scan";
                    break;
                case MarkerCode.DQT:
                    desc = "[<strong>Other markers</strong>] Define quantization table(s)";
                    break;
                case MarkerCode.DNL:
                    desc = "[<strong>Other markers</strong>] Define number of lines";
                    break;
                case MarkerCode.DRI:
                    desc = "[<strong>Other markers</strong>] Define restart interval";
                    break;
                case MarkerCode.DHP:
                    desc = "[<strong>Other markers</strong>] Define hierarchical progression";
                    break;
                case MarkerCode.EXP:
                    desc = "[<strong>Other markers</strong>] Expand reference component(s)";
                    break;
                case MarkerCode.APP00:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP01:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP02:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP03:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP04:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP05:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP06:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP07:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP08:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP09:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP10:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP11:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP12:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP13:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP14:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.APP15:
                    desc = "[<strong>Other markers</strong>] Reserved for application segments";
                    break;
                case MarkerCode.JPG00:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG01:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG02:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG03:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG04:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG05:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG06:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG07:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG08:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG09:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG10:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG11:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG12:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.JPG13:
                    desc = "[<strong>Other markers</strong>] Reserved for JPEG extensions";
                    break;
                case MarkerCode.COM:
                    desc = "[<strong>Other markers</strong>] Comment";
                    break;
                default:
                    desc = "Un-recognized markder: " + markerCode;
                    break;
            }
        } else if (markerCode == MarkerCode.MAX) {
            desc = "MAX";
        }

        return desc;
    }

    public static String getMarkerCodeDescription() {
        // CCITT T.81, P31
        return "Two-byte codes assigned to marker.";
    }

    public static String getHeaderLengthDescription() {
        // CCITT T.81, P37
        return "Header length – Specifies the length of the header.";
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/MarkerParse.java`:

```java
/*
 * MarkerParse.java    Sep 19, 2010, 20:35
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class MarkerParse {

    /**
     *
     * @param pDisFile Data Input Stream for <code>file</code> byte array
     * @return The generated proper marker instance
     * @throws IOException Parse file failed
     * @throws FileFormatException Parse file failed
     */
    public static Marker parse(final PosDataInputStream pDisFile) throws IOException, FileFormatException {
        Marker marker;

        final int marker_code = pDisFile.readUnsignedShort();
        switch (marker_code) {
            case MarkerCode.APP00:
                marker = new Marker_APP00(pDisFile, marker_code);
                break;

            case MarkerCode.APP01:
                marker = new Marker_APP01(pDisFile, marker_code);
                break;

            case MarkerCode.APP02:
                marker = new Marker_APP02(pDisFile, marker_code);
                break;

            case MarkerCode.APP13:
                marker = new Marker_APP13(pDisFile, marker_code);
                break;

            case MarkerCode.APP14:
                marker = new Marker_APP14(pDisFile, marker_code);
                break;

            case MarkerCode.DQT:
                marker = new Marker_DQT(pDisFile, marker_code);
                break;

            case MarkerCode.DRI:
                marker = new Marker_DRI(pDisFile, marker_code);
                break;

            case MarkerCode.SOF00:
            case MarkerCode.SOF01:
            case MarkerCode.SOF02:
            case MarkerCode.SOF03:

            case MarkerCode.SOF05:
            case MarkerCode.SOF06:
            case MarkerCode.SOF07:

            case MarkerCode.SOF09:
            case MarkerCode.SOF10:
            case MarkerCode.SOF11:

            case MarkerCode.SOF13:
            case MarkerCode.SOF14:
            case MarkerCode.SOF15:
                marker = new Marker_SOFnn(pDisFile, marker_code);
                break;

            case MarkerCode.SOI:
                marker = new Marker_SOI(pDisFile, marker_code);
                break;

            case MarkerCode.EOI:
                marker = new Marker_EOI(pDisFile, marker_code);
                break;

            case MarkerCode.DHT:
                marker = new Marker_DHT(pDisFile, marker_code);
                break;

            case MarkerCode.SOS:
                marker = new Marker_SOS(pDisFile, marker_code);
                break;

            case MarkerCode.COM:
                marker = new Marker_COM(pDisFile, marker_code);
                break;

            default:
                marker = new Marker(pDisFile, marker_code);
                break;
        }

        return marker;
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP00.java`:

```java
/*
 * Marker_APP00.java    August 25, 2010, 23:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponenPlaceHolder;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP00 extends Marker {

    public static final String identifier_JFIF = "JFIF";
    private String identifier;
    private GenerateTreeNode compnent;

    Marker_APP00(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException, FileFormatException {
        super.parseInitSkip(pDisMarker);
        this.identifier = super.parseIdentifier(pDisMarker);

        if (Marker_APP00.identifier_JFIF.equals(this.identifier)) {
            this.compnent = new JFIF(pDisMarker);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        int lastPos;
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode identifierNode;

        comp = new JTreeNodeFileComponent(
                lastPos = this.getStartPos(),
                2,
                String.format("Marker code: 0x04X", this.marker_code));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2,
                String.format("length: %d", this.getMarkerLength()));
        comp.setDescription("Total APP0 field byte count, including the byte count value (2 bytes), but excluding the APP0 marker itself.");
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                this.identifier.length() + 1,
                String.format("identifier: %s", this.identifier));
        if (this.identifier.equals(Marker_APP00.identifier_JFIF)) {
            comp.setDescription("This zero terminated string (“JFIF”) uniquely identifies this APP0 marker. This string shall have zero parity (bit 7=0).");
        }
        markerNode.add(new DefaultMutableTreeNode(comp));

        markerNode.add(identifierNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + this.identifier.length() + 1,
                this.startPos + this.length - lastPos,
                this.identifier)));
        if (this.compnent != null) {
            this.compnent.generateTreeNode(identifierNode);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Inner Class
    private class JFIF implements GenerateTreeNode {

        private final int version_major;
        private final int version_minor;
        private final int units;
        private final int Xdensity;
        private final int Ydensity;
        private final int Xthumbnail;
        private final int Ythumbnail;
        private final FileComponenPlaceHolder RGBn;

        JFIF(final PosDataInputStream pDIS) throws IOException, FileFormatException {
            // Version
            this.version_major = pDIS.readUnsignedByte();
            this.version_minor = pDIS.readUnsignedByte();

            // Units
            this.units = pDIS.readUnsignedByte();

            // X,Y density
            this.Xdensity = pDIS.readUnsignedShort();
            this.Ydensity = pDIS.readUnsignedShort();

            // X,Y thumbnail and RGBs
            this.Xthumbnail = pDIS.readUnsignedByte();
            this.Ythumbnail = pDIS.readUnsignedByte();
            final int thumbnail_size = this.Xthumbnail * this.Ythumbnail;
            this.RGBn = new FileComponenPlaceHolder(pDIS, thumbnail_size * 3);
        }

        public void generateTreeNode(DefaultMutableTreeNode parentNode) {

            int pos = Marker_APP00.this.getStartPos();
            JTreeNodeFileComponent comp;

            // Marker_APP00 Version Major and Minor
            comp = new JTreeNodeFileComponent(
                    pos + 9,
                    1,
                    String.format("major version: %d", this.version_major));
            comp.setDescription("The most significant byte is used for major revisions.");
            parentNode.add(new DefaultMutableTreeNode(comp));
            comp = new JTreeNodeFileComponent(
                    pos + 0xA,
                    1,
                    String.format("minor version: %d", this.version_minor));
            comp.setDescription("The least significant byte for minor revisions.");
            parentNode.add(new DefaultMutableTreeNode(comp));

            // Marker_APP00 Density Units
            comp = new JTreeNodeFileComponent(
                    pos + 0xB,
                    1,
                    String.format("units: %d - %s", this.units, this.getUnitsDesc()));
            comp.setDescription("Units for the X and Y densities.<br />"
                    + "<ul>"
                    + "<li> units = <strong>0</strong>: no units, X and Y specify the pixel aspect ratio </li>"
                    + "<li> units = <strong>1</strong>: X and Y are dots per inch </li>"
                    + "<li> units = <strong>2</strong>: X and Y are dots per cm </li>"
                    + "</ul>");
            parentNode.add(new DefaultMutableTreeNode(comp));

            // Marker_APP00 X,Y density
            comp = new JTreeNodeFileComponent(
                    pos + 0xC,
                    2,
                    String.format("X density: %d", this.Xdensity));
            comp.setDescription("Horizontal pixel density");
            parentNode.add(new DefaultMutableTreeNode(comp));
            comp = new JTreeNodeFileComponent(
                    pos + 0xE,
                    2,
                    String.format("Y density: %d", this.Ydensity));
            comp.setDescription("Vertical pixel density");
            parentNode.add(new DefaultMutableTreeNode(comp));

            // Marker_APP00 X,Y thumbnail
            comp = new JTreeNodeFileComponent(
                    pos + 0x10,
                    1,
                    String.format("X thumbnail: %d", this.Xthumbnail));
            comp.setDescription("Thumbnail horizontal pixel count");
            parentNode.add(new DefaultMutableTreeNode(comp));
            comp = new JTreeNodeFileComponent(
                    pos + 0x11,
                    1,
                    String.format("Y thumbnail: %d", this.Ythumbnail));
            comp.setDescription("Thumbnail vertical pixel count");
            parentNode.add(new DefaultMutableTreeNode(comp));

            // RGBn
            comp = new JTreeNodeFileComponent(
                    pos + 0x12,
                    this.RGBn.getLength(),
                    String.format("RGBn: length = %d", this.RGBn.getLength()));
            comp.setDescription("Packed (24-bit) RGB values for the thumbnail pixels, <br />n = Xthumbnail * Ythumbnail");
            parentNode.add(new DefaultMutableTreeNode(comp));
        }

        public String getUnitsDesc() {
            switch (this.units) {
                case 0:
                    return "no units, X and Y specify the pixel spect ratio";
                case 1:
                    return "X and Y are dots per inch";
                case 2:
                    return "X and Y are dots per cm";
                default:
                    return "Unknown";
            }
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP01.java`:

```java
/*
 * Marker_APP01.java    August 25, 2010, 23:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.ui.JXMLViewer;
import org.binaryinternals.format.jpeg.tiff.TIFF;
import org.binaryinternals.format.jpeg.xmp.XMP;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP01 extends Marker {

    public static final String identifier_Exif = "Exif";
    public static final String identifier_XMP = "http://ns.adobe.com/xap/";
    private String identifier;
    private TIFF tiff;
    private XMP xmp;

    Marker_APP01(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException, FileFormatException {
        super.parseInitSkip(pDisMarker);
        this.identifier = super.parseIdentifier(pDisMarker);

        if (this.identifier.equalsIgnoreCase(Marker_APP01.identifier_Exif)) {
            // TODO - Clean the following code, call method 
            //        pDisMarker.getPartialStream(startPos, length) - This method test failed June.19.2013
            final int lengthTiff = this.marker_length - 2 - 6;
            final byte[] bytesTiff = new byte[lengthTiff];
            System.arraycopy(pDisMarker.getBuf(), 2 + 2 + 6, bytesTiff, 0, lengthTiff);
            this.tiff = new TIFF(new PosDataInputStream(
                    new PosByteArrayInputStream(bytesTiff),
                    this.getStartPos() + 2 + 2 + 6));
            
//            pDisMarker.getPartialStream(this.getStartPos() + 2 + 2 + 6, lengthTiff);
//            this.tiff = new TIFF(pDisMarker.getPartialStream(
//                    this.getStartPos() + 2 + 2 + 6,
//                    lengthTiff));            
        } else if (this.identifier.startsWith(Marker_APP01.identifier_XMP)) {
            final int lengthXMP = this.marker_length - 2 - this.identifier.length() - 1;
            final byte[] bytesXMP = new byte[lengthXMP];
            System.arraycopy(pDisMarker.getBuf(), 2 + 2 + this.identifier.length() + 1, bytesXMP, 0, lengthXMP);
            this.xmp = new XMP(new PosDataInputStream(
                    new PosByteArrayInputStream(bytesXMP),
                    this.getStartPos() + 2 + 2 + this.identifier.length() + 1));
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode nodeExif;

        comp = new JTreeNodeFileComponent(
                this.getStartPos(),
                2,
                "Marker code: 0xFFE1");
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 2,
                2,
                String.format("length: %d", this.getMarkerLength()));
        comp.setDescription(MarkerCode.getHeaderLengthDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        if (Marker_APP01.identifier_Exif.equals(this.identifier)) {
            comp = new JTreeNodeFileComponent(
                    this.getStartPos() + 4,
                    6,
                    String.format("identifier: %s", this.identifier));
            markerNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.getStartPos() + 10,
                    this.length - 10,
                    "TIFF");
            comp.setDescription("Exchangeable image file format for digital still cameras");
            markerNode.add(nodeExif = new DefaultMutableTreeNode(comp));
            this.tiff.generateTreeNode(nodeExif);
        } else if (this.identifier.startsWith(Marker_APP01.identifier_XMP)) {
            markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.getStartPos() + 4,
                    this.identifier.length() + 1,
                    String.format("identifier: %s", this.identifier))));

            comp = new JTreeNodeFileComponent(
                    this.xmp.getStartPos(),
                    this.xmp.getLength(),
                    "XMP data");
            comp.setDetailPanel(new JXMLViewer(new PosDataInputStream(new PosByteArrayInputStream(this.xmp.rawData))));
            markerNode.add(new DefaultMutableTreeNode(comp));
        } else {
            markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.getStartPos() + 2 + 2,
                    this.marker_length - 2,
                    "data")));
        }
    } // End of method generateTreeNode
} // End of Class


```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP02.java`:

```java
/*
 * Marker_APP02.java    August 25, 2010, 23:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.jpeg.icc.ICCProfile;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP02 extends Marker {

    public static final String IDENTIFIER_ICC_PROFILE = "ICC_PROFILE";
    private String identifier;
    private ICCProfile icc;

    Marker_APP02(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException {
        super.parseInitSkip(pDisMarker);
        this.identifier = super.parseIdentifier(pDisMarker);

        if (Marker_APP02.IDENTIFIER_ICC_PROFILE.equals(this.identifier)) {
            int lengthICC = this.marker_length - 2 - this.identifier.length() - 1;
            lengthICC = lengthICC - 2;
            final byte[] bytesICC = new byte[lengthICC];
            System.arraycopy(pDisMarker.getBuf(), 2 + 2 + this.identifier.length() + 1 + 2, bytesICC, 0, lengthICC);
            this.icc = new ICCProfile(new PosDataInputStream(
                    new PosByteArrayInputStream(bytesICC),
                    this.getStartPos() + 2 + 2 + this.identifier.length() + 1 + 2));
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        int lastPos;
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode identifierNode;

        comp = new JTreeNodeFileComponent(
                lastPos = this.getStartPos(),
                2,
                String.format("Marker code: 0x04X", this.marker_code));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2,
                String.format("length: %d", this.getMarkerLength()));
        comp.setDescription(MarkerCode.getHeaderLengthDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                this.identifier.length() + 1,
                String.format("identifier: %s", this.identifier))));

        if (Marker_APP02.IDENTIFIER_ICC_PROFILE.equals(this.identifier)) {
            markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos = lastPos + this.identifier.length() + 1,
                    2,
                    "????")));
            
            markerNode.add(identifierNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos = lastPos + 2,
                    this.startPos + this.length - lastPos,
                    this.identifier)));
            this.icc.generateTreeNode(identifierNode);
        } else {
            markerNode.add(identifierNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos = lastPos + this.identifier.length() + 1,
                    this.startPos + this.length - lastPos,
                    this.identifier)));
        }

    } // End of method generateTreeNode
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP03.java`:

```java
/*
 * Marker_APP03.java    August 25, 2010, 23:10
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP03 extends Marker {

    Marker_APP03(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP04.java`:

```java
/*
 * Marker_APP04.java    August 25, 2010, 23:10
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP04 extends Marker {

    Marker_APP04(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP05.java`:

```java
/*
 * Marker_APP05.java    August 25, 2010, 23:10
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP05 extends Marker {

    Marker_APP05(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP06.java`:

```java
/*
 * Marker_APP06.java    August 25, 2010, 23:10
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP06 extends Marker {

    Marker_APP06(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP08.java`:

```java
/*
 * Marker_APP08.java    August 25, 2010, 23:26
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP08 extends Marker {

    Marker_APP08(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP10.java`:

```java
/*
 * Marker_APP10.java    August 25, 2010, 23:27
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP10 extends Marker {

    Marker_APP10(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP12.java`:

```java
/*
 * Marker_APP12.java    August 25, 2010, 23:27
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP12 extends Marker {

    Marker_APP12(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP13.java`:

```java
/*
 * Marker_APP13.java    August 25, 2010, 23:27
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.jpeg.ps.PhotoshopImageResource;

/**
 * An APP13 marker designates a Photoshop Image Resource (PSIR) that contains IPTC metadata.
 *
 * @author Amos Shi
 */
public class Marker_APP13 extends Marker {

    public static final String IDENTIFIER_PHOTOSHOP = "Photoshop";
    private String identifier;
    private PhotoshopImageResource psir;

    Marker_APP13(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException, FileFormatException {
        super.parseInitSkip(pDisMarker);
        this.identifier = super.parseIdentifier(pDisMarker);
        if (this.identifier.contains(Marker_APP13.IDENTIFIER_PHOTOSHOP)) {
            final int lengthPhir = this.marker_length - 2 - this.identifier.length() - 1;
            final byte[] bytesPhir = new byte[lengthPhir];
            System.arraycopy(pDisMarker.getBuf(), 2 + 2 + this.identifier.length() + 1, bytesPhir, 0, lengthPhir);
            this.psir = new PhotoshopImageResource(new PosDataInputStream(
                    new PosByteArrayInputStream(bytesPhir),
                    this.getStartPos() + 2 + 2 + this.identifier.length() + 1));
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        int lastPos;
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode identifierNode;

        comp = new JTreeNodeFileComponent(
                lastPos = this.getStartPos(),
                2,
                String.format("Marker code: 0x04X", this.marker_code));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2,
                String.format("length: %d", this.getMarkerLength()));
        comp.setDescription(MarkerCode.getHeaderLengthDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                this.identifier.length() + 1,
                String.format("identifier: %s", this.identifier))));

        if (this.identifier.contains(Marker_APP13.IDENTIFIER_PHOTOSHOP)) {
            comp = new JTreeNodeFileComponent(
                    this.psir.getStartPos(),
                    this.psir.getLength(),
                    "Photoshop Image Resource Block");
            markerNode.add(identifierNode = new DefaultMutableTreeNode(comp));
            this.psir.generateTreeNode(identifierNode);
        } else {
            markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos = lastPos + this.identifier.length() + 1,
                    this.startPos + this.length - lastPos,
                    this.identifier)));
        }
    } // End of method generateTreeNode
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP14.java`:

```java
/*
 * Marker_APP14.java    August 25, 2010, 23:27
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP14 extends Marker {

    private String identifier;

    Marker_APP14(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException {
        super.parseInitSkip(pDisMarker);
        this.identifier = super.parseIdentifier(pDisMarker);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        int lastPos;
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode identifierNode;

        comp = new JTreeNodeFileComponent(
                lastPos = this.getStartPos(),
                2,
                String.format("Marker code: 0x04X", this.marker_code));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2,
                String.format("length: %d", this.getMarkerLength()));
        comp.setDescription(MarkerCode.getHeaderLengthDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                this.identifier.length() + 1,
                String.format("identifier: %s", this.identifier))));
        markerNode.add(identifierNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + this.identifier.length() + 1,
                this.startPos + this.length - lastPos,
                this.identifier)));
    } // End of method generateTreeNode
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_APP15.java`:

```java
/*
 * Marker_APP15.java    August 25, 2010, 23:27
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_APP15 extends Marker {

    Marker_APP15(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_COM.java`:

```java
/*
 * Marker_COM.java    August 25, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponenPlaceHolder;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_COM extends Marker {

    /** Comment byte. */
    private FileComponenPlaceHolder Cm;


    Marker_COM(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }


    @Override
    protected void parse(final PosDataInputStream pDisMarker)
            throws IOException, FileFormatException {

        super.parseInitSkip(pDisMarker);

        this.Cm = new FileComponenPlaceHolder(pDisMarker, super.getMarkerLength() - 2);
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);

        // Marker_APP00 Marker
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos(),
                2,
                "Marker code: 0xFFE0")));

        // Marker_APP00 Length
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 2,
                2,
                String.format("length: %d", this.getMarkerLength()))));

        // Comment
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 4,
                this.Cm.getLength(),
                String.format("Cm: length = %d", this.Cm.getLength()))));

    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DAC.java`:

```java
/*
 * Marker_SOF02.java    August 27, 2010, 23:17
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_DAC extends Marker {

    Marker_DAC(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DHP.java`:

```java
/*
 * Marker_DHP.java    August 27, 2010, 23:50
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_DHP extends Marker {

    Marker_DHP(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DHT.java`:

```java
/*
 * Marker_DHT.java    August 27, 2010, 23:26
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponenPlaceHolder;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_DHT extends Marker {

    /**
     * Table class. 0 = DC table or lossless table; 1 = AC table.
     */
    private int Tc;                      // TODO - Set all attributes as final
    /**
     * Huffman table destination identifier.
     */
    private int Th;
    /**
     * Number of Huffman codes of length <code>i</code>.
     */
    private int[] Li = new int[16];
    /**
     * Value associated with each Huffman code. Specifies, for each
     * <code>i</code>, the value associated with each Huffman code of length
     * <code>i</code>. The meaning of each value is determined by the Huffman
     * coding model. The Vi,j’s are the elements of the list
     * <code>HUFFVAL</code>.
     */
    private FileComponenPlaceHolder Vij;

    Marker_DHT(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker)
            throws IOException, FileFormatException {

        super.parseInitSkip(pDisMarker);

        // Tc, Th
        byte b = pDisMarker.readByte();
        this.Tc = (b & 0xF0) >> 4;    // TODO: Check this value
        this.Th = (b & 0x0F);         // TODO: Check this value

        // Li
        for (int i = 0; i < 16; i++) {
            this.Li[i] = pDisMarker.readUnsignedByte();
        }

        // Vij
        this.Vij = new FileComponenPlaceHolder(pDisMarker, super.marker_length - 19);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        final int pos = super.getStartPos();

        // Marker code
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 0,
                2,
                String.format("Marker code: 0x%X", super.getMarker()))));

        // Marker Length
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 2,
                2,
                String.format("length: %d", super.getMarkerLength()))));

        // Tc, Th
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 4,
                1,
                String.format("Tc: %d", this.Tc))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 4,
                1,
                String.format("Th: %d", this.Th))));

        // Li
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5,
                16,
                "Li: L1 - L16")));

        // Vij
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 21,
                this.Vij.getLength(),
                "Vij: Symbol-length assignment parameters")));

    }

}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DNL.java`:

```java
/*
 * Marker_DNL.java    August 27, 2010, 23:49
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_DNL extends Marker {

    Marker_DNL(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DQT.java`:

```java
/*
 * Marker_DQT.java    August 25, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponenPlaceHolder;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_DQT extends Marker {

    private int Pq;
    private int Tq;
    private FileComponenPlaceHolder Qk;

    Marker_DQT(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }


    @Override
    protected void parse(final PosDataInputStream pDisMarker)
            throws IOException, FileFormatException {

        super.parseInitSkip(pDisMarker);

        // Pq & Tq
        final byte b = pDisMarker.readByte();
        this.Pq = (b & 0xF0) >> 4;    // TODO - Check value more precisely
        this.Tq = (b & 0x0F);

        if (this.Pq != 0 && this.Pq != 1) {
            throw new FileFormatException(String.format(
                    "DQT Pq value unrecognizable: expected value is 0 or 1; current value is %d.",
                    this.Pq));
        }
        if (this.Tq != 0 && this.Tq != 1 && this.Tq != 2 && this.Tq != 3) {
            throw new FileFormatException(String.format(
                    "DQT Tq value unrecognizable: expected value is 0, 1, 2 or 3; current value is %d.",
                    this.Pq));
        }

        // Qk

        // This should be corret, but in testing, we find that when Pq is 0, it is still has 16-bit Pq.
        //this.Qk = new FileComponenPlaceHolder(pDisMarker, (this.Pq + 1) * 64);
        this.Qk = new FileComponenPlaceHolder(pDisMarker, this.length - 1 - 2 - 2);
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);

        // Marker code
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos(),
                2,
                "Marker code: 0xFFDB")));

        // Marker Length
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 2,
                2,
                String.format("length: %d", super.getMarkerLength()))));

        // Pq
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 4,
                1,
                String.format("Pq: %d", this.Pq))));

        // Tq
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 4,
                1,
                String.format("Tq: %d", this.Tq))));

        // Qk
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.getStartPos() + 5,
                this.Qk.getLength(),
                String.format("Qk: length = %d", this.Qk.getLength()))));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_DRI.java`:

```java
/*
 * Marker_DRI.java    August 27, 2010, 23:50
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_DRI extends Marker {

    private int Lr;
    private int Ri;

    Marker_DRI(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) throws IOException {
        super.parseInitSkip(pDisMarker);
        this.Lr = super.marker_length;
        this.Ri = pDisMarker.readUnsignedShort();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        int lastPos;
        JTreeNodeFileComponent comp;

        // Marker code
        comp = new JTreeNodeFileComponent(
                lastPos = this.getStartPos(),
                2,
                String.format("Marker code: 0x04X", this.marker_code));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        // Marker Length
        comp = new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2,
                String.format("length: %d", this.Lr));
        comp.setDescription(MarkerCode.getHeaderLengthDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));

        // Ri
        comp = new JTreeNodeFileComponent(
                lastPos + 2,
                2,
                String.format("Ri: %d", this.Ri));
        comp.setDescription("Restart interval – Specifies the number of MCU in the restart interval.");
        markerNode.add(new DefaultMutableTreeNode(comp));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_EOI.java`:

```java
/*
 * Marker_EXP.java    August 27, 2010, 23:51
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_EOI extends Marker {

    Marker_EOI(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        JTreeNodeFileComponent comp = new JTreeNodeFileComponent(
                this.getStartPos(),
                MarkerCode.MARKER_CODE_BYTES_COUNT,
                String.format("Marker code = 0x%X", super.getMarker()));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));
    }

}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_EXP.java`:

```java
/*
 * Marker_EXP.java    August 27, 2010, 23:51
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_EXP extends Marker {

    Marker_EXP(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_RSTm.java`:

```java
/*
 * Marker_SOF02.java    August 27, 2010, 23:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_RSTm extends Marker {

    Marker_RSTm(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_SOFnn.java`:

```java
/*
 * Marker_SOFnn.java    September 02, 2010, 00:44
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_SOFnn extends Marker {

    private static class Component {

        /** Component Identifier */
        @SuppressWarnings("PackageVisibleField")
        int C;
        /** Horizontal sampling factor */
        @SuppressWarnings("PackageVisibleField")
        int H;
        /** Vertical sampling factor  */
        @SuppressWarnings("PackageVisibleField")
        int V;
        /** Quantization table destination selector */
        @SuppressWarnings("PackageVisibleField")
        int Tq;
    }
    /** Sample precision */
    private int P;
    /** Number of lines */
    private int Y;
    /** Number of samples per line */
    private int X;
    /** Number of image components in frame */
    private int Nf;
    /** Image Components */
    private Component[] C;

    Marker_SOFnn(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker)
            throws IOException, FileFormatException {

        super.parseInitSkip(pDisMarker);

        // P,Y, X, Nf
        this.P = pDisMarker.readUnsignedByte();   // TODO - Check the values
        this.Y = pDisMarker.readUnsignedShort();  // TODO - Check the values
        this.X = pDisMarker.readUnsignedShort();  // TODO - Check the values
        this.Nf = pDisMarker.readUnsignedByte();  // TODO - Check the values

        // Components: Ci, Hi, Vi, Tqi
        byte b;
        this.C = new Component[this.Nf];
        for (int i = 0; i < this.Nf; i++) {
            this.C[i] = new Component();
            this.C[i].C = pDisMarker.readUnsignedByte();
            b = pDisMarker.readByte();
            this.C[i].H = (b & 0xF0) >> 4;
            this.C[i].V = (b & 0x0F);
            this.C[i].Tq = pDisMarker.readUnsignedByte();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        final int pos = super.getStartPos();

        // Marker code
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 0,
                2,
                String.format("Marker code: 0x%X", super.getMarker()))));

        // Marker Length
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 2,
                2,
                String.format("length: %d", super.getMarkerLength()))));

        // P, Y, X, Nf
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 4,
                1,
                String.format("P: %d", this.P))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5,
                2,
                String.format("Y: %d", this.Y))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 7,
                2,
                String.format("X: %d", this.X))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 9,
                1,
                String.format("Nf: %d", this.Nf))));

        // Components: Ci, Hi, Vi, Tqi
        if (this.Nf <= 0 || this.C == null) {
            return;
        }

        DefaultMutableTreeNode attributeNode;
        DefaultMutableTreeNode componentNode;

        markerNode.add(attributeNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 10,
                this.Nf * 3,
                "Component-specification parameters")));

        for (int i = 0; i < this.Nf; i++) {

            attributeNode.add(componentNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos + 10 + 3 * i,
                    3,
                    String.format("Component-%d", i + 1))));

            if (this.C[i] != null) {
                componentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 10 + 3 * i + 0,
                        1,
                        String.format("C: %d", this.C[i].C))));
                componentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 10 + 3 * i + 1,
                        1,
                        String.format("H: %d", this.C[i].H))));
                componentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 10 + 3 * i + 1,
                        1,
                        String.format("V: %d", this.C[i].V))));
                componentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 10 + 3 * i + 2,
                        1,
                        String.format("Tq: %d", this.C[i].Tq))));
            }
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_SOI.java`:

```java
/*
 * Marker_SOI.java    August 27, 2010, 23:51
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_SOI extends Marker {

    Marker_SOI(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        JTreeNodeFileComponent comp = new JTreeNodeFileComponent(
                this.getStartPos(),
                MarkerCode.MARKER_CODE_BYTES_COUNT,
                String.format("Marker code = 0x%X", super.getMarker()));
        comp.setDescription(MarkerCode.getMarkerCodeDescription());
        markerNode.add(new DefaultMutableTreeNode(comp));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_SOS.java`:

```java
/*
 * Marker_SOS.java    August 27, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Marker_SOS extends Marker {

    private static class Parameter {

        /** Scan component selector */
        @SuppressWarnings("PackageVisibleField")
        int Cs;
        /** DC entropy coding table destination selector. */
        @SuppressWarnings("PackageVisibleField")
        int Td;
        /** AC entropy coding table destination selector.  */
        @SuppressWarnings("PackageVisibleField")
        int Ta;
    }

    /** Number of image components in scan. */
    private int Ns;

    /** Scan component-specification parameters. */
    private Parameter[] parameter;

    /** Start of spectral or predictor selection. */
    private int Ss;

    /** End of spectral selection. */
    private int Se;

    /** Successive approximation bit position high. */
    private int Ah;

    /** Successive approximation bit position low or point transform. */
    private int Al;

    Marker_SOS(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }


    @Override
    protected void parse(final PosDataInputStream pDisMarker)
            throws IOException, FileFormatException {

        super.parseInitSkip(pDisMarker);

        byte b;

        // Ns
        this.Ns = pDisMarker.readUnsignedByte();        // TODO - Check this value

        // Scan component-specification parameters: Cs, Td, Ta
        this.parameter = new Parameter[this.Ns];
        for (int i = 0; i < this.Ns; i++) {
            this.parameter[i] = new Parameter();
            this.parameter[i].Cs = pDisMarker.readUnsignedByte();

            b = pDisMarker.readByte();
            this.parameter[i].Td = (b & 0xF0) >> 4;
            this.parameter[i].Ta = b & 0x0F;
        }
        // TODO - Now check the value Ls(marker length) matchs
        //super.verify();

        // Ss, Se, Ah, Al
        this.Ss = pDisMarker.readUnsignedByte();
        this.Se = pDisMarker.readUnsignedByte();

        b = pDisMarker.readByte();
        this.Ah = (b & 0xF0) >> 4;
        this.Al = b & 0x0F;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Interface Methods
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode markerNode = this.generateTreeNode_Marker(parentNode);
        DefaultMutableTreeNode attributeNode;
        final int pos = super.getStartPos();

        // Marker code
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 0,
                2,
                String.format("Marker code: 0x%X", super.getMarker()))));

        // Ls
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 2,
                2,
                String.format("Ls (Scan header length): %d", super.getMarkerLength()))));

        // Ns
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 4,
                1,
                String.format("Ns: %d", this.Ns))));

        // Scan component-specification parameters: Cs, Td, Ta
        if (this.Ns > 0) {
            DefaultMutableTreeNode parameterNode;

            markerNode.add(attributeNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos + 5,
                    this.Ns * 2,
                    "Scan component-specification parameters")));

            for (int i = 0; i < this.Ns; i++) {
                parameterNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 5 + 2*i,
                        2,
                        String.format("Parameter-%d", i + 1)));
                attributeNode.add(parameterNode);

                // Cs, Td, Ta
                parameterNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 5 + 2*i + 0,
                        1,
                        String.format("Cs: %d", this.parameter[i].Cs))));
                parameterNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 5 + 2*i + 1,
                        1,
                        String.format("Td: %d", this.parameter[i].Td))));
                parameterNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 5 + 2*i + 1,
                        1,
                        String.format("Ta: %d", this.parameter[i].Ta))));
            }
        }

        // Ss, Se, Ah, Al
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5 + this.Ns*2 + 0,
                1,
                String.format("Ss: %d", this.Ss))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5 + this.Ns*2 + 1,
                1,
                String.format("Se: %d", this.Se))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5 + this.Ns*2 + 2,
                1,
                String.format("Ah: %d", this.Ah))));
        markerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 5 + this.Ns*2 + 2,
                1,
                String.format("Al: %d", this.Al))));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/Marker_TEM.java`:

```java
/*
 * Marker_TEM.java    August 28, 2010, 00:00
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg;

import java.io.IOException;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
public class Marker_TEM extends Marker {

    Marker_TEM(final PosDataInputStream pDIS, int marker_code) throws IOException, FileFormatException {
        super(pDIS, marker_code);
    }

    @Override
    protected void parse(final PosDataInputStream pDisMarker) {
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/PluginDescriptorJPEG.java`:

```java
/*
 * PluginDescriptor.java    Apr 16, 2011, 20:14
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.jpeg;

import org.binaryinternals.commonlib.core.PluginDescriptor;
import org.binaryinternals.commonlib.core.FileFormat;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorJPEG implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "JPEG Image (*.jpg,*jpeg)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"jpeg", "jpg"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return JPEGFile.class;
    }

}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/Header.java`:

```java
/*
 * Header.java    Nov 09, 2010, 21:41
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Header extends FileComponent implements GenerateTreeNode {

    public static final int LENGTH = 128;
    public final long ProfileSize;                                              //  0 -  3
    public final String CMMType;                                                //  4 -  7
    public final String ProfileVersion;                                         //  8 - 11
    public final String ProfileDeviceClass;                                     // 12 - 15
    public final String DataColourSpace;                                        // 16 - 19
    public final String ProfileConnectionSpace;                                 // 20 - 23
    public final dateTimeNumber DateTime;                                       // 24 - 35
    public final String ProfileFileSignature;                                   // 36 - 39
    public final String PrimaryPlatform;                                        // 40 - 43
    public final long ProfileFlags;                                             // 44 - 47
    public final String DeviceManufacturer;                                     // 48 - 51
    public final String DeviceModel;                                            // 52 - 55
    public final long[] DeviceAttributes;                                       // 56 - 63
    public final long RenderingIntent;                                          // 64 - 67
    public final XYZNumber ProfileConnectionSpaceIlluminant;                    // 68 - 79
    public final String ProfileCreator;                                         // 80 - 83
    public final byte[] ProfileID = new byte[16];                               // 84 - 99
    public final byte[] Reserved = new byte[28];                                // 100-127

    public Header(final PosDataInputStream input) throws IOException {
        StringBuilder sb;

        super.startPos = input.getPos();
        super.length = Header.LENGTH;

        this.ProfileSize = input.readUnsignedInt();                             // 0 - 3
        this.CMMType = input.readASCII(4);                                      // 4 - 7

        // 8 - 11
        sb = new StringBuilder(8);
        sb.append(input.readByte());
        sb.append('.');
        sb.append(input.readByte());
        sb.append('.');
        sb.append(input.readByte());
        sb.append('.');
        sb.append(input.readByte());
        this.ProfileVersion = sb.toString();

        this.ProfileDeviceClass = input.readASCII(4);                           // 12 - 15
        this.DataColourSpace = input.readASCII(4);                              // 16 - 19
        this.ProfileConnectionSpace = input.readASCII(4);                       // 20 - 23
        this.DateTime = new dateTimeNumber(input);                              // 24 - 35
        this.ProfileFileSignature = input.readASCII(4);                         // 36 - 39
        this.PrimaryPlatform = input.readASCII(4);                              // 40 - 43
        this.ProfileFlags = input.readUnsignedInt();                            // 44 - 47 - TODO: Analysis known flags
        this.DeviceManufacturer = input.readASCII(4);                           // 48 - 51
        this.DeviceModel = input.readASCII(4);                                  // 52 - 55

        // 56 - 63 - TODO: Analysis known flags
        this.DeviceAttributes = new long[2];
        this.DeviceAttributes[0] = input.readUnsignedInt();
        this.DeviceAttributes[1] = input.readUnsignedInt();

        this.RenderingIntent = input.readUnsignedInt();                         // 64 - 67 - TODO: Analysis known flags
        this.ProfileConnectionSpaceIlluminant = new XYZNumber(input);           // 68 - 79
        this.ProfileCreator = input.readASCII(4);                               // 80 - 83
        input.readFully(this.ProfileID);                                        // 84 - 99
        input.readFully(this.Reserved);                                         // 100-127
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        // 0 - 3
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 0,
                4,
                String.format("Profile size = %d", this.ProfileSize));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 4 - 7
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 4,
                4,
                String.format("CMM Type = %s", this.CMMType));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 8 - 11
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 8,
                4,
                String.format("Profile version = %s", this.ProfileVersion));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 12 - 15
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 12,
                4,
                String.format("Profile/Device class = %s", this.ProfileDeviceClass));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 16 - 19
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 16,
                4,
                String.format("Data colour space = %s", this.DataColourSpace));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 20 - 23
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 20,
                4,
                String.format("Profile connection space = %s", this.ProfileConnectionSpace));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 24 - 35
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 24,
                12,
                String.format("Date and Time = %s", this.DateTime.toString()));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 36 - 39
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 36,
                4,
                String.format("Profile file signature = %s", this.ProfileFileSignature));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 40 - 43
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 40,
                4,
                String.format("Primary platform = %s", this.PrimaryPlatform));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 44 - 47
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 44,
                4,
                String.format("Profile flags = %s", Long.toHexString(this.ProfileFlags)));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 48 - 51
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 48,
                4,
                String.format("Device manufacturer = %s", this.DeviceManufacturer));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 52 - 55
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 52,
                4,
                String.format("Device model = %s", this.DeviceModel));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 56 - 63
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 56,
                8,
                "Device attributes");
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 64 - 67
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 64,
                4,
                "Rendering intent");
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 68 - 79
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 68,
                12,
                "Profile connection space illuminant");
        parentNode.add(node = new DefaultMutableTreeNode(comp));
        this.ProfileConnectionSpaceIlluminant.generateTreeNode(node, this.getStartPos() + 68);

        // 80 - 83
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 80,
                4,
                String.format("Device model = %s", this.ProfileCreator));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 84 - 99
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 80,
                4,
                String.format("Profile ID = %s", this.ProfileCreator));
        parentNode.add(new DefaultMutableTreeNode(comp));

        // 100 - 127
        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 80,
                4,
                String.format("Reserved = %s", this.ProfileCreator));
        parentNode.add(new DefaultMutableTreeNode(comp));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/ICCProfile.java`:

```java
/*
 * ICCProfile.java    Nov 09, 2010, 21:39
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import java.util.concurrent.ConcurrentSkipListMap;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see <a href="http://www.color.org/">INTERNATIONAL COLOR CONSORTIUM</a>
 */
public class ICCProfile extends FileComponent implements GenerateTreeNode {

    public final byte[] rawData;
    public final Header header;
    public final int tagCount;
    public final Tag[] tagTable;

    public ICCProfile(final PosDataInputStream input) throws IOException {
        super.startPos = input.getPos();
        super.length = input.getBuf().length;

        this.rawData = input.getBuf();
        this.header = new Header(input);
        this.tagCount = input.readInt();
        if (this.tagCount > 0) {
            this.tagTable = new Tag[this.tagCount];
            for (int i = 0; i < this.tagCount; i++) {
                this.tagTable[i] = new Tag(input);
            }
        } else {
            this.tagTable = null;
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        DefaultMutableTreeNode nodeHeader;
        DefaultMutableTreeNode nodeTagTable;
        int lastPos;
        int diff;

        parentNode.add(nodeHeader = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.header.getStartPos(),
                this.header.getLength(),
                "Profile header")));
        this.header.generateTreeNode(nodeHeader);

        parentNode.add(nodeHeader = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = this.header.getStartPos() + this.header.getLength(),
                4,
                String.format("Tag count = %d", this.tagCount))));

        lastPos = lastPos + 4;

        ConcurrentSkipListMap<Long, RefItem> sortedMap = new ConcurrentSkipListMap<>();
        for (int i = 0; i < this.tagTable.length; i++) {
            parentNode.add(nodeTagTable = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos + Tag.LENGTH * i,
                    Tag.LENGTH,
                    String.format("Tag[%d]", i))));
            this.tagTable[i].generateTreeNode(nodeTagTable);

            if (sortedMap.get(this.tagTable[i].Offset) == null) {
                RefItem refItem = new RefItem();
                refItem.i = i;
                refItem.tag = this.tagTable[i];
                sortedMap.put(refItem.tag.Offset, refItem);
            }
        }

        lastPos = lastPos + this.tagTable.length * Tag.LENGTH;
        for (RefItem ref : sortedMap.values()) {
            diff = (int) ((this.startPos + ref.tag.Offset) - lastPos);
            if (diff > 0) {
                generateTreeNodeDiff(parentNode, lastPos, diff, this.rawData, this.startPos);
            }

            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + (int) ref.tag.Offset,
                    (int) ref.tag.Size,
                    String.format("Data of Tag [%d]", ref.i))));
            lastPos = this.startPos + (int) ref.tag.Offset + (int) ref.tag.Size;
        }

        diff = (this.startPos + this.rawData.length) - lastPos;
        if (diff > 0) {
            generateTreeNodeDiff(parentNode, lastPos, diff, this.rawData, this.startPos);
        }
    }

    @SuppressWarnings("PackageVisibleInnerClass")
    private static class RefItem {

        int i;
        Tag tag;
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/Tag.java`:

```java
/*
 * Tag.java    Nov 09, 2010, 21:46
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class Tag extends FileComponent {

    public final static int LENGTH = 12;
    public final String TagSignature;
    public final long Offset;
    public final long Size;
    public final int BasePos;
    public final TagData tagData;

    public Tag(final PosDataInputStream input) throws IOException {
        super.startPos = input.getPos();
        super.length = LENGTH;

        this.TagSignature = input.readASCII(4);
        this.Offset = input.readUnsignedInt();
        this.Size = input.readUnsignedInt();
        this.BasePos = input.getOffset();

        byte[] dataBuf = new byte[(int) this.Size];
        System.arraycopy(input.getBuf(), (int) this.Offset, dataBuf, 0, dataBuf.length);
        this.tagData = Tag.parse(new PosDataInputStream(
                new PosByteArrayInputStream(dataBuf),
                input.getOffset() + (int) this.Offset));
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode nodeTagData;

        comp = new JTreeNodeFileComponent(
                this.getStartPos(),
                4,
                String.format("Signature = %s", this.TagSignature));
        comp.setDescription("Tag Signature");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 4,
                4,
                String.format("Offset = %d", this.Offset));
        comp.setDescription("Offset to beginning of tag data element");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.getStartPos() + 8,
                4,
                String.format("Size = %d", this.Size));
        comp.setDescription("Size of tag data element");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                (int) (this.BasePos + this.Offset),
                (int) this.Size,
                "Tag Data",
                Icons.Shortcut, null);
        parentNode.add(nodeTagData = new DefaultMutableTreeNode(comp));
        this.tagData.generateTreeNode(nodeTagData);
    }

    static TagData parse(final PosDataInputStream input) throws IOException {

        int tagType = input.readInt();
        input.reset();

        switch (tagType) {
            case TagType.textType:
                return new TagData_textType(input);
            case TagType.XYZType:
                return new TagData_XYZType(input);
            case TagType.viewingConditionsType:
                return new TagData_viewingConditionsType(input);
            case TagType.curveType:
                return new TagData_curveType(input);
            case TagType.measurementType:
                return new TagData_measurementType(input);
            case TagType.signatureType:
                return new TagData_signatureType(input);
            default:
                return new TagData(input);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData.java`:

```java
/*
 * TagData.java    Nov 22, 2010, 23:12
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData extends FileComponent implements GenerateTreeNode {

    public final int tagType;

    /**
     * 
     * @param input The input stream for this Tag Data only
     * @throws IOException Parse file failed
     */
    public TagData(final PosDataInputStream input) throws IOException {
        super.startPos = input.getPos();
        super.length = input.getBuf().length;

        this.tagType = input.readInt();

        // Reserved bytes
        BytesTool.skip(input, 4);
    }

    public String getTagType() {
        return TagType.getTypeSignature(this.tagType);
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_TagDataType(parentNode);
        if (this.length > 8) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.startPos + 8,
                    this.length - 8,
                    this.getTagType())));
        }
    }

    public void generateTreeNode_TagDataType(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                this.startPos,
                4,
                String.format("Signature = %s", TagType.getTypeSignature(this.tagType)));
        comp.setDescription("Identify what kind of data is contained within a tag.");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 4,
                4,
                "Reserved");
        comp.setDescription("Reserved for future expansion and must be set to 0.");
        parentNode.add(new DefaultMutableTreeNode(comp));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_XYZType.java`:

```java
/*
 * TagData_XYZType.java    Nov 22, 2010, 23:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData_XYZType extends TagData {

    public final XYZNumber[] data;

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_XYZType(final PosDataInputStream input) throws IOException {
        super(input);
        if (this.length > 8) {
            int dataLength = this.length - 8;
            int dataCount = dataLength / XYZNumber.LENGTH;
            this.data = new XYZNumber[dataCount];
            for (int i = 0; i < dataCount; i++) {
                this.data[i] = new XYZNumber(input);
            }
        } else {
            this.data = null;
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length > 8 && this.data != null) {
            DefaultMutableTreeNode xyzNode;
            JTreeNodeFileComponent comp;

            this.generateTreeNode_TagDataType(parentNode);
            for (int i = 0; i < this.data.length; i++) {
                comp = new JTreeNodeFileComponent(
                        startPos + 8 + XYZNumber.LENGTH * i,
                        XYZNumber.LENGTH,
                        String.format("%s [%d]", XYZNumber.class.getSimpleName(), i));
                comp.setDescription(this.data[i].toString());
                parentNode.add(xyzNode = new DefaultMutableTreeNode(comp));
                this.data[i].generateTreeNode(xyzNode, this.startPos + 8 + XYZNumber.LENGTH * i);
            }
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_curveType.java`:

```java
/*
 * TagData_curveType.java    Nov 27, 2010, 17:47
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * TODO - Study cure
 *
 * @author Amos Shi
 */
public class TagData_curveType extends TagData {

    public final long count;
    public final int curveValues[];

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_curveType(final PosDataInputStream input) throws IOException {
        super(input);

        this.count = input.readUnsignedInt();
        if (this.count == 0) {
            this.curveValues = new int[1];
            this.curveValues[0] = 0;
        } else if (this.count == 1) {
            this.curveValues = new int[1];
            this.curveValues[0] = 0;   // TODO - Read page 53
        } else {
            this.curveValues = new int[((int) this.count)];
            for (int i = 0; i < this.count; i++) {
                this.curveValues[i] = input.readUnsignedShort();
            }
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length > 8) {
            this.generateTreeNode_TagDataType(parentNode);

            JTreeNodeFileComponent comp;
            DefaultMutableTreeNode node;

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("count = %d", this.count));
            comp.setDescription("Count value specifying the number of entries (<code>n</code>) that follow.");
            parentNode.add(new DefaultMutableTreeNode(comp));

            if (this.count > 1) {
                comp = new JTreeNodeFileComponent(
                        this.startPos + 12,
                        ((int) this.count) * 2,
                        "curve values");
                comp.setDescription("Actual curve values starting with the zeroth entry and ending with the entry <code>n-1</code>.");
                parentNode.add(node = new DefaultMutableTreeNode(comp));

                for (int i = 0; i < this.count; i++) {
                    node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            this.startPos + 12 + i * 2,
                            2,
                            String.format("value [%d] = %d", i, this.curveValues[i]))));
                }
            }
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_measurementType.java`:

```java
/*
 * TagData_measurementType.java    Nov 27, 2010, 17:07
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData_measurementType extends TagData {

    public final static int LENGTH = 36;
    public final long standardObserver;
    public final XYZNumber measurementBacking;
    public final long measurementGeometry;
    public final long measurementFlare;
    public final long standardIlluminant;

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_measurementType(final PosDataInputStream input) throws IOException {
        super(input);
        if (super.length != LENGTH) {
            // TODO - throw error
        }

        this.standardObserver = input.readUnsignedInt();
        this.measurementBacking = new XYZNumber(input);
        this.measurementGeometry = input.readUnsignedInt();
        this.measurementFlare = input.readUnsignedInt();
        this.standardIlluminant = input.readUnsignedInt();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length > 8) {
            this.generateTreeNode_TagDataType(parentNode);

            DefaultMutableTreeNode xyzNode;
            JTreeNodeFileComponent comp;

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("standard observer = %d", this.standardObserver));
            comp.setDescription(null);  //  TODO - load the values from table 40
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    startPos + 12,
                    XYZNumber.LENGTH,
                    "measurement backing");
            comp.setDescription("XYZ tristimulus values for measurement backing.");
            parentNode.add(xyzNode = new DefaultMutableTreeNode(comp));
            this.measurementBacking.generateTreeNode(xyzNode, this.startPos + 12);

            comp = new JTreeNodeFileComponent(
                    this.startPos + 24,
                    4,
                    String.format("measurement geometry = %d", this.measurementGeometry));
            comp.setDescription(null);  //  TODO - load the values from table 41
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 28,
                    4,
                    String.format("measurement flare = %d", this.measurementFlare));
            comp.setDescription(null);  //  TODO - load the values from table 42
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.startPos + 32,
                    4,
                    String.format("standard illuminant = %d", this.standardIlluminant));
            comp.setDescription(null);  //  TODO - load the values from table 43
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_signatureType.java`:

```java
/*
 * TagData_signatureType.java    Nov 27, 2010, 17:25
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData_signatureType extends TagData {

    public final static int LENGTH = 12;
    public final String signature;

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_signatureType(final PosDataInputStream input) throws IOException {
        super(input);
        if (super.length != LENGTH) {
            // TODO - throw error
        }

        this.signature = input.readASCII(4);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length == LENGTH) {
            this.generateTreeNode_TagDataType(parentNode);

            JTreeNodeFileComponent comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("signature = %s", this.signature));
            comp.setDescription("Four-byte signature.");
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_textType.java`:

```java
/*
 * TagData_textType.java    Nov 22, 2010, 23:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData_textType extends TagData {

    public final String text;

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_textType(final PosDataInputStream input) throws IOException {
        super(input);
        StringBuilder sb = new StringBuilder(this.length - 8);
        for (int i = 8; i < this.length; i++) {
            sb.append((char) input.readByte());
        }
        this.text = sb.toString();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length > 8) {
            this.generateTreeNode_TagDataType(parentNode);

            JTreeNodeFileComponent comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    this.length - 8,
                    this.getTagType());
            comp.setDescription(this.text);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagData_viewingConditionsType.java`:

```java
/*
 * TagData_viewingConditionsType.java    Nov 27, 2010, 16:18
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class TagData_viewingConditionsType extends TagData {

    public final static int LENGTH = 36;
    public final XYZNumber illuminant;
    public final XYZNumber surround;
    public final long illuminantType;

    /**
     *
     * @param input Input stream of the file
     * @throws IOException Parse file failed
     */
    public TagData_viewingConditionsType(final PosDataInputStream input) throws IOException {
        super(input);
        if (super.length != LENGTH) {
            // TODO - throw error
        }

        this.illuminant = new XYZNumber(input);
        this.surround = new XYZNumber(input);
        this.illuminantType = input.readUnsignedInt();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.length == LENGTH) {
            this.generateTreeNode_TagDataType(parentNode);

            JTreeNodeFileComponent comp;
            DefaultMutableTreeNode xyzNode;

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    XYZNumber.LENGTH,
                    "illuminant");
            comp.setDescription("CIE ’absolute’ XYZ values for illuminant (in which Y is in cd/m<sup>2</sup>)");
            parentNode.add(xyzNode = new DefaultMutableTreeNode(comp));
            this.illuminant.generateTreeNode(xyzNode, this.startPos + 8);

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8 + XYZNumber.LENGTH,
                    XYZNumber.LENGTH,
                    "surround");
            comp.setDescription("CIE ’absolute’ XYZ values for surround (in which Y is in cd/m<sup>2</sup>)");
            parentNode.add(xyzNode = new DefaultMutableTreeNode(comp));
            this.surround.generateTreeNode(xyzNode, this.startPos + 8 + XYZNumber.LENGTH);

            comp = new JTreeNodeFileComponent(
                    this.startPos + 8 + XYZNumber.LENGTH + XYZNumber.LENGTH,
                    4,
                    String.format("illuminant type = %d", this.illuminantType));
            comp.setDescription(null);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            // For error case
            super.generateTreeNode(parentNode);
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/TagType.java`:

```java
/*
 * TagType.java    Nov 21, 2010, 00:26
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

/**
 *
 * @author Amos Shi
 */
public class TagType {

    public static final int chromaticityType = 0x6368726D;                      // ’chrm’, ICC 4.2.0.0 - 10.2
    public static final int colorantOrderType = 0x636C726F;                     // ‘clro’, ICC 4.2.0.0 - 10.3
    public static final int colorantTableType = 0x636c7274;                     // ‘clrt’, ICC 4.2.0.0 - 10.4
    public static final int curveType = 0x63757276;                             // ‘curv’, ICC 4.2.0.0 - 10.5
    public static final int dataType = 0x64617461;                              // ‘data’, ICC 4.2.0.0 - 10.6
    public static final int dateTimeType = 0x6474696D;                          // ‘dtim’, ICC 4.2.0.0 - 10.7
    public static final int lut16Type = 0x6D667432;                             // ‘mft2’, ICC 4.2.0.0 - 10.8
    public static final int lut8Type = 0x6D667431;                              // ‘mft1’, ICC 4.2.0.0 - 10.9
    public static final int lutAtoBType = 0x6D414220;                           // ‘mAB ’, ICC 4.2.0.0 - 10.10
    public static final int lutBtoAType = 0x6D424120;                           // ‘mBA ’, ICC 4.2.0.0 - 10.11
    public static final int measurementType = 0x6D656173;                       // ‘meas’, ICC 4.2.0.0 - 10.12
    public static final int multiLocalizedUnicodeType = 0x6D6C7563;             // ‘mluc’, ICC 4.2.0.0 - 10.13
    public static final int namedColor2Type = 0x6E636C32;                       // ‘ncl2’, ICC 4.2.0.0 - 10.14
    public static final int parametricCurveType = 0x70617261;                   // ‘para’, ICC 4.2.0.0 - 10.15
    public static final int profileSequenceDescType = 0x70736571;               // ‘pseq’, ICC 4.2.0.0 - 10.16
    public static final int responseCurveSet16Type = 0x72637332;                // ‘rcs2’, ICC 4.2.0.0 - 10.17
    public static final int s15Fixed16ArrayType = 0x73663332;                   // ‘sf32’, ICC 4.2.0.0 - 10.18
    public static final int signatureType = 0x73696720;                         // ‘sig ’, ICC 4.2.0.0 - 10.19
    public static final int textType = 0x74657874;                              // ‘text’, ICC 4.2.0.0 - 10.20
    public static final int u16Fixed16ArrayType = 0x75663332;                   // ‘uf32’, ICC 4.2.0.0 - 10.21
    public static final int uInt16ArrayType = 0x75693136;                       // ‘ui16’, ICC 4.2.0.0 - 10.22
    public static final int uInt32ArrayType = 0x75693332;                       // ‘ui32’, ICC 4.2.0.0 - 10.23
    public static final int uInt64ArrayType = 0x75693634;                       // ‘ui64’, ICC 4.2.0.0 - 10.24
    public static final int uInt8ArrayType = 0x75693038;                        // ‘ui08’, ICC 4.2.0.0 - 10.25
    public static final int viewingConditionsType = 0x76696577;                 // ‘view’, ICC 4.2.0.0 - 10.26
    public static final int XYZType = 0x58595A20;                               // ‘XYZ ’, ICC 4.2.0.0 - 10.27

    /**
     *
     * @param sig Type Signature value in number
     * @return Type Signature string
     */
    public static String getTypeSignature(int sig) {
        StringBuilder sb = new StringBuilder(5);
        sb.append((char) ((sig & 0xFF000000) >> 24));
        sb.append((char) (((sig & 0x00FF0000) << 8) >> 24));
        sb.append((char) (((sig & 0x0000FF00) << 16) >> 24));
        sb.append((char) (((sig & 0x000000FF) << 24) >> 24));
        return sb.toString();
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/XYZNumber.java`:

```java
/*
 * XYZNumber.java    Nov 10, 2010, 09:17
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class XYZNumber {

    public static final int LENGTH = 12;
    public final s15Fixed16Number x;
    public final s15Fixed16Number y;
    public final s15Fixed16Number z;

    public XYZNumber(final PosDataInputStream input) throws IOException {
        this.x = new s15Fixed16Number(input);
        this.y = new s15Fixed16Number(input);
        this.z = new s15Fixed16Number(input);
    }

    @Override
    public String toString() {
        return String.format("[x=%s, y=%s, z=%s]",
                this.x.toString(), this.y.toString(), this.z.toString());
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode, int startPos) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos,
                4,
                String.format("x = %s", this.x.toString()))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos + 4,
                4,
                String.format("y = %s", this.y.toString()))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                startPos + 8,
                4,
                String.format("z = %s", this.z.toString()))));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/dateTimeNumber.java`:

```java
/*
 * dateTimeNumber.java    Nov 09, 2010, 23:02
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * The type <code>dateTimeNumber</code> defined in ICC Specification
 * ICC.1:2004-10 (Profile version 4.2.0.0).
 *
 * @author Amos Shi
 */
@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Use the type name from ICC Specification")
public class dateTimeNumber {

    public final int year;
    public final int month;
    public final int day;
    public final int hour;
    public final int minute;
    public final int second;

    public dateTimeNumber(final PosDataInputStream input) throws IOException {
        this.year = input.readUnsignedShort();
        this.month = input.readUnsignedShort();
        this.day = input.readUnsignedShort();
        this.hour = input.readUnsignedShort();
        this.minute = input.readUnsignedShort();
        this.second = input.readUnsignedShort();
    }

    @Override
    public String toString() {
        return String.format("%d-%02d-%02d %02d:%02d:%02d", year, month, day, hour, minute, second);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/icc/s15Fixed16Number.java`:

```java
/*
 * s15Fixed16Number.java    Nov 10, 2010, 09:18
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.icc;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 *
 * @author Amos Shi
 */
@SuppressFBWarnings(value = "NM_CLASS_NAMING_CONVENTION", justification = "Use the type name from ICC Specification")
public class s15Fixed16Number {

    public final byte[] rawData;
    public final double value;

    public s15Fixed16Number(final PosDataInputStream input) throws IOException {
        this.rawData = new byte[4];
        this.rawData[0] = input.readByte();
        this.rawData[1] = input.readByte();
        this.rawData[2] = input.readByte();
        this.rawData[3] = input.readByte();

        StringBuilder sb = new StringBuilder(9);
        sb.append(String.format("%02X", this.rawData[0]));
        sb.append(String.format("%02X", this.rawData[1]));
        sb.append(String.format("%02X", this.rawData[2]));
        sb.append(String.format("%02X", this.rawData[3]));

        long l = Long.parseLong(sb.toString(), 16);
        if (l > 0x80000000) {
            this.value = ((((~l) << 32) >> 32) * -1) / 65536.0;
        } else {
            int p1 = Integer.parseInt(sb.substring(0, 4), 16);
            int p2 = Integer.parseInt(sb.substring(4), 16);
            this.value = p1 + p2 / 65536.0;
        }
    }

    @Override
    public String toString() {
        return String.format("%.4f", this.value);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/ps/IRB_8BIM.java`:

```java
/*
 * XMP.java    Nov 08, 2010, 12:58
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.ps;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IRB_8BIM extends FileComponent {

    public static final int SIGNATURE = 0x3842494D;
    public static final String SIGNATURE_TEXT = "8BIM";
    public final int identifier;
    public final String name;
    private final boolean name_skip1byte;
    public final int size;
    public final byte[] data;
    private final boolean data_skip1byte;

    IRB_8BIM(final PosDataInputStream input) throws IOException {
        super.startPos = input.getPos() - 4;

        // identifier
        this.identifier = input.readUnsignedShort();

        // name
        int nameLen = input.readUnsignedShort();
        StringBuilder sb = new StringBuilder(10);
        for (int i = 0; i < nameLen; i++) {
            sb.append((char) input.readByte());
        }
        this.name = sb.toString();

        // size
        this.size = input.readInt();

        // skip for name
        this.data_skip1byte = ((this.size & 1) != 0);
        if (this.data_skip1byte) {
            BytesTool.skip(input, 1);
        }

        // data
        if (this.size > 0) {
            this.data = new byte[this.size];
            for (int i = 0; i < this.size; i++) {
                this.data[i] = input.readByte();
            }
        } else {
            this.data = null;
        }

        // skip for name
        this.name_skip1byte = ((this.size & 1) != 0);  // true for odd value; false for even
        if (this.name_skip1byte) {
            BytesTool.skip(input, 1);
        }

        // total length
        super.length = input.getPos() - super.startPos;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int lastPos;
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = this.startPos,
                4,
                "Signature = '8BIM'")));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 4,
                2,
                String.format("Resource Unique Identifier = 0x%04X", this.identifier))));

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 2,
                2 + this.name.length(),
                String.format("Name = '%s'", this.name))));
        if (this.name_skip1byte) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos = lastPos + 2 + this.name.length(),
                    1,
                    "skip for even")));
        }

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + ((this.name_skip1byte) ? 1 : 2 + this.name.length()),
                4,
                String.format("Size = %d", this.size))));

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                lastPos = lastPos + 4,
                this.size,
                "Resource Data")));
        if (this.data_skip1byte) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    lastPos + this.size,
                    1,
                    "skip for even")));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/ps/PhotoshopImageResource.java`:

```java
/*
 * XMP.java    Nov 08, 2010, 12:55
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.ps;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see <a href="http://www.adobe.com/devnet/photoshop.html">Adobe Photoshop Developer Center</a>
 */
public class PhotoshopImageResource extends FileComponent {

    public final byte[] rawData;
    public final String signature;
    public final List<IRB_8BIM> irb_8bim;

    public PhotoshopImageResource(final PosDataInputStream input) throws IOException {
        super.startPos = input.getPos();
        super.length = input.getBuf().length;

        this.rawData = input.getBuf();
        this.irb_8bim = new ArrayList<>(100);

        StringBuilder sb = new StringBuilder(5);
        sb.append((char)this.rawData[0]);
        sb.append((char)this.rawData[1]);
        sb.append((char)this.rawData[2]);
        sb.append((char)this.rawData[3]);
        this.signature = sb.toString();

        if (IRB_8BIM.SIGNATURE_TEXT.equals(this.signature)) {
            while (((input.getPos() - input.getOffset()) < this.rawData.length)
                    && (input.readInt() == IRB_8BIM.SIGNATURE)) {               // 0x3842494D = "8BIM"
                this.irb_8bim.add(new IRB_8BIM(input));
            }
        }
        // else if ... (other signature)
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int count;
        DefaultMutableTreeNode node;

        if (IRB_8BIM.SIGNATURE_TEXT.equals(this.signature)) {
            count = 0;
            for (IRB_8BIM irb : this.irb_8bim) {
                parentNode.add(node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        irb.getStartPos(),
                        irb.getLength(),
                        String.format("IRB-8BIM [%d]", count))));
                count++;
                irb.generateTreeNode(node);
            }
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD.java`:

```java
/*
 * IFD.java    Sep 06, 2010, 23:28
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;

public class IFD extends FileComponent {

    public static final int SIZE = 12; // Size of IFD
    public final int tiff_StartPos;
    @SuppressWarnings("ProtectedField")
    protected byte[] tiff_ByteArray;
    public final int byte_order;
    public final int ifd_tag;
    public final int ifd_type;
    public final int ifd_count;
    @SuppressWarnings("ProtectedField")
    protected int ifd_value_offset;
    public final int data_size;                                                 // Total size of the IFD data
    private TagSpace tag_space = TagSpace.DEFAULT;

    protected IFD(final PosDataInputStream pDIS, int byteOrder, int tag, int type, int startPosTiff, byte[] byteArrayTiff) throws IOException, FileFormatException {
        super.startPos = pDIS.getPos() - 4;
        super.length = IFD.SIZE;

        this.tiff_StartPos = startPosTiff;
        this.tiff_ByteArray = byteArrayTiff;
        this.byte_order = byteOrder;

        this.ifd_tag = tag;
        this.ifd_type = type;
        this.ifd_count = this.readInt(pDIS);

        this.data_size = IFDType.getTypeLength(this.ifd_type) * this.ifd_count;
    }

    public IFD(final PosDataInputStream pDIS, int byteOrder, int tag, int type, int startPosTiff) throws IOException {
        super.startPos = pDIS.getPos() - 4;
        super.length = IFD.SIZE;

        this.tiff_StartPos = startPosTiff;
        this.byte_order = byteOrder;

        this.ifd_tag = tag;
        this.ifd_type = type;
        this.ifd_count = this.readInt(pDIS);
        this.ifd_value_offset = this.readInt(pDIS);                                 // Maybe value

        this.data_size = IFDType.getTypeLength(this.ifd_type) * this.ifd_count;
    }

    protected final void checkIFDCount(int countExpected) throws FileFormatException {
        if (this.ifd_count != countExpected) {
            throw new FileFormatException(String.format(
                    "IFD %d (%s): ifd count must be %d. current value = %d",
                    this.ifd_tag,
                    this.getTagName(),
                    countExpected,
                    this.ifd_count));
        }
    }

    protected final PosDataInputStream getTiffOffsetReader() throws IOException {
        final PosDataInputStream reader = new PosDataInputStream(new PosByteArrayInputStream(this.tiff_ByteArray));

        if (this.ifd_value_offset > this.tiff_ByteArray.length) {
            throw new ArrayIndexOutOfBoundsException("TIFF IFD: the data offset is bigger than tiff buffer length");
        }
        if (this.ifd_value_offset + this.data_size > this.tiff_ByteArray.length) {
            throw new ArrayIndexOutOfBoundsException("TIFF IFD: the data ending offset is bigger than tiff buffer length");
        }

        BytesTool.skip(reader, this.ifd_value_offset);
        return reader;
    }

    // Note: Common tag only, none GPS, none InterO
    public String getTagName() {
        String s = null;
        if (this.tag_space == TagSpace.DEFAULT) {
            s = IFDTag.getTagName(this.ifd_tag);
        } else if (this.tag_space == TagSpace.GPS) {
            s = IFDTag.getTagNameGPS(this.ifd_tag);
        } else if (this.tag_space == TagSpace.INTERO) {
            s = IFDTag.getTagNameIntero(this.ifd_tag);
        }

        // Temp
        if (this.getClass().getName().equalsIgnoreCase(IFD.class.getName())) {
            String care = String.format("- CARE ME !!!!! - %s, %04X, %d",
                    this.tag_space.toString(),
                    this.ifd_tag,
                    this.ifd_tag);
            System.out.println(care);
            s = s + care;
        }

        return s;
    }

    public TagSpace getTagSpace() {
        return this.tag_space;
    }

    protected final int readUnsignedShort(final PosDataInputStream pDIS) throws IOException {
        return IFDParse.readUnsignedShort(pDIS, this.byte_order);
    }

    protected final int readInt(final PosDataInputStream pDIS) throws IOException {
        return IFDParse.readInt(pDIS, this.byte_order);
    }

    protected final long readUnsignedInt(final PosDataInputStream pDIS) throws IOException {
        if (this.byte_order == TIFFHeader.BYTEORDER_BIGENDIAN) {
            return pDIS.readUnsignedInt();
        } else {
            return pDIS.readUnsignedIntInLittleEndian();
        }
    }

    void setTagSpace(TagSpace ts) {
        this.tag_space = ts;
    }

    public boolean isValue() {
        return this.data_size > 0 && this.data_size <= 4;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {

        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                this.startPos + 0,
                2,
                String.format("Tag: %04X.H (%d)", this.ifd_tag, this.ifd_tag));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Tag));
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 2,
                2,
                String.format("Type: %d - %s", this.ifd_type, IFDType.getTypeName(this.ifd_type)));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Type));
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 4,
                4,
                String.format("Count: %d", this.ifd_count));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Count));
        parentNode.add(new DefaultMutableTreeNode(comp));

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("Value: %X", this.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Value));
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    this.startPos + 8,
                    4,
                    String.format("Offset: %d", this.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    this.tiff_StartPos + this.ifd_value_offset,
                    this.ifd_count * IFDType.getTypeLength(this.ifd_type),
                    "data",
                    Icons.Shortcut, null);
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }

    protected void generateTreeNode(DefaultMutableTreeNode parentNode, int pos) {

        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                pos + 0,
                2,
                String.format("Tag: %04X.H (%d)", this.ifd_tag, this.ifd_tag));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Tag));
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                pos + 2,
                2,
                String.format("Type: %d - %s", this.ifd_type, IFDType.getTypeName(this.ifd_type)));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Type));
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                pos + 4,
                4,
                String.format("Count: %d", this.ifd_count));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Count));
        parentNode.add(new DefaultMutableTreeNode(comp));
    }

    @SuppressWarnings("PublicInnerClass")
    public enum TagSpace {

        DEFAULT,
        GPS,
        INTERO
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFDGroup.java`:

```java
/*
 * IFDGroup.java    Oct 31, 2010, 19:04
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

class IFDGroup {

    /** Absolute start position within the file. */
    public final int startPos;
    /** Total length of the group, in bytes. */
    public final int length;
    /** The Offset position within TIFF. */
    public final int offset;
    /** The 2-byte count of the number of directory entries. */
    public final int ifd_number;
    /** The sequence of 12-byte IFD field entries. */
    public final IFD[] ifd;
    /** The 4-byte offset of the next IFD */
    public final int next;

    IFDGroup(byte[] byteArrayTiff, final TIFFHeader tiffHeader, final int offset)
            throws IOException, FileFormatException {

        // Absolute start position & Offset within tiff
        this.startPos = tiffHeader.getStartPos() + offset;
        this.offset = offset;

        // IFD count and data
        final PosDataInputStream pDisTiff = new PosDataInputStream(
                new PosByteArrayInputStream(byteArrayTiff),
                tiffHeader.getStartPos());
        BytesTool.skip(pDisTiff, offset);
        this.ifd_number = IFDParse.readUnsignedShort(pDisTiff, tiffHeader.byte_order);
        if (this.ifd_number > 0) {                                              // IFD count could be zero
            this.ifd = new IFD[this.ifd_number];
            for (int i = 0; i < this.ifd_number; i++) {
                this.ifd[i] = IFDParse.parse(pDisTiff, tiffHeader.byte_order, tiffHeader.getStartPos(), byteArrayTiff);
            }
        } else {
            this.ifd = null;
        }
        this.next = IFDParse.readInt(pDisTiff, tiffHeader.byte_order);

        // Size
        this.length = 2 + this.ifd_number * IFD.SIZE + 4;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode nodeGroup;
        DefaultMutableTreeNode nodeIFD;

        parentNode.add(nodeGroup = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos,
                this.length,
                "IFD Group")));

        // IFD number
        comp = new JTreeNodeFileComponent(
                this.startPos,
                2,
                String.format("IFD number: %d", this.ifd_number));
        comp.setDescription(TIFF.IFD_Number_Description);
        nodeGroup.add(new DefaultMutableTreeNode(comp));

        // IFD[]
        for (int i = 0; i < this.ifd_number; i++) {
            comp = new JTreeNodeFileComponent(
                    this.ifd[i].getStartPos(),
                    IFD.SIZE,
                    String.format("IFD[%d] - %s", i, this.ifd[i].getTagName()));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
            nodeGroup.add(nodeIFD = new DefaultMutableTreeNode(comp));
            this.ifd[i].generateTreeNode(nodeIFD);
        }

        // Next IFD
        nodeGroup.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                this.startPos + this.length - 4,
                4,
                String.format("Next IFD: Offset within Tiff = %04X (%d)", this.next, this.next))));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFDMessage.java`:

```java
/*
 * IFDMessage.java    Oct 07, 2010, 11:24
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.util.Locale;
import java.util.ResourceBundle;

/**
 *
 * @author Amos shi
 */
public class IFDMessage{

    private static final ResourceBundle res;

    static{
        res = ResourceBundle.getBundle(IFDMessage.class.getName().replace('.', '/'), Locale.ROOT);
    }

    public static final String KEY_IFD = "IFD";
    public static final String KEY_IFD_Type = "IFD_Type";
    public static final String KEY_IFD_Tag = "IFD_Tag";
    public static final String KEY_IFD_Count = "IFD_Count";
    public static final String KEY_IFD_Offset = "IFD_Offset";
    public static final String KEY_IFD_Value = "IFD_Value";
    public static final String KEY_IFD_Value_Ref = "IFD_Value_Ref";

    public static final String KEY_IFD_0106_Description = "IFD_0106_Description";
    public static final String KEY_IFD_010F_Description = "IFD_010F_Description";
    public static final String KEY_IFD_0110_Description = "IFD_0110_Description";
    public static final String KEY_IFD_0112_Description = "IFD_0112_Description";
    public static final String KEY_IFD_011A_Description = "IFD_011A_Description";
    public static final String KEY_IFD_011B_Description = "IFD_011B_Description";
    public static final String KEY_IFD_0128_Description = "IFD_0128_Description";
    public static final String KEY_IFD_0131_Description = "IFD_0131_Description";
    public static final String KEY_IFD_0132_Description = "IFD_0132_Description";
    public static final String KEY_IFD_013E_Description = "IFD_013E_Description";
    public static final String KEY_IFD_013F_Description = "IFD_013F_Description";
    public static final String KEY_IFD_0201_Description = "IFD_0201_Description";
    public static final String KEY_IFD_0202_Description = "IFD_0202_Description";
    public static final String KEY_IFD_0211_Description = "IFD_0211_Description";
    public static final String KEY_IFD_0213_Description = "IFD_0213_Description";
    public static final String KEY_IFD_0214_Description = "IFD_0214_Description";
    public static final String KEY_IFD_829A_Description = "IFD_829A_Description";
    public static final String KEY_IFD_829D_Description = "IFD_829D_Description";
    public static final String KEY_IFD_8769_Exif_Category_A = "IFD_8769_Exif_Category_A";
    public static final String KEY_IFD_8769_Exif_Category_B = "IFD_8769_Exif_Category_B";
    public static final String KEY_IFD_8769_Exif_Category_C = "IFD_8769_Exif_Category_C";
    public static final String KEY_IFD_8769_Exif_Category_D = "IFD_8769_Exif_Category_D";
    public static final String KEY_IFD_8769_Exif_Category_E = "IFD_8769_Exif_Category_E";
    public static final String KEY_IFD_8769_Exif_Category_F = "IFD_8769_Exif_Category_F";
    public static final String KEY_IFD_8769_Exif_Category_G = "IFD_8769_Exif_Category_G";
    public static final String KEY_IFD_8769_Exif_FormatVersion = "IFD_8769_Exif_FormatVersion";
    public static final String KEY_IFD_8822_Description = "IFD_8822_Description";
    public static final String KEY_IFD_8825_GPS_Category_A = "IFD_8825_GPS_Category_A";
    public static final String KEY_IFD_8827_Description = "IFD_8827_Description";
    public static final String KEY_IFD_9000_Description = "IFD_9000_Description";
    public static final String KEY_IFD_9003_Description = "IFD_9003_Description";
    public static final String KEY_IFD_9004_Description = "IFD_9004_Description";
    public static final String KEY_IFD_9101_Description = "IFD_9101_Description";
    public static final String KEY_IFD_9102_Description = "IFD_9102_Description";
    public static final String KEY_IFD_9201_Description = "IFD_9201_Description";
    public static final String KEY_IFD_9202_Description = "IFD_9202_Description";
    public static final String KEY_IFD_9204_Description = "IFD_9204_Description";
    public static final String KEY_IFD_9205_Description = "IFD_9205_Description";
    public static final String KEY_IFD_9207_Description = "IFD_9207_Description";
    public static final String KEY_IFD_9208_Description = "IFD_9208_Description";
    public static final String KEY_IFD_9209_Description = "IFD_9209_Description";
    public static final String KEY_IFD_920A_Description = "IFD_920A_Description";
    public static final String KEY_IFD_927C_Description = "IFD_927C_Description";
    public static final String KEY_IFD_9286_Description = "IFD_9286_Description";
    public static final String KEY_IFD_9290_Description = "IFD_9290_Description";
    public static final String KEY_IFD_9291_Description = "IFD_9291_Description";
    public static final String KEY_IFD_9292_Description = "IFD_9292_Description";
    public static final String KEY_IFD_A000_Description = "IFD_A000_Description";
    public static final String KEY_IFD_A001_Description = "IFD_A001_Description";
    public static final String KEY_IFD_A002_Description = "IFD_A002_Description";
    public static final String KEY_IFD_A003_Description = "IFD_A003_Description";
    public static final String KEY_IFD_A005_Intero_Category_A = "IFD_A005_Intero_Category_A";
    public static final String KEY_IFD_A20E_Description = "IFD_A20E_Description";
    public static final String KEY_IFD_A20F_Description = "IFD_A20F_Description";
    public static final String KEY_IFD_A210_Description = "IFD_A210_Description";
    public static final String KEY_IFD_A215_Description = "IFD_A215_Description";
    public static final String KEY_IFD_A217_Description = "IFD_A217_Description";
    public static final String KEY_IFD_A300_Description = "IFD_A300_Description";
    public static final String KEY_IFD_A301_Description = "IFD_A301_Description";
    public static final String KEY_IFD_A302_Description = "IFD_A302_Description";
    public static final String KEY_IFD_A401_Description = "IFD_A401_Description";
    public static final String KEY_IFD_A402_Description = "IFD_A402_Description";
    public static final String KEY_IFD_A403_Description = "IFD_A403_Description";
    public static final String KEY_IFD_A404_Description = "IFD_A404_Description";
    public static final String KEY_IFD_A405_Description = "IFD_A405_Description";
    public static final String KEY_IFD_A406_Description = "IFD_A406_Description";
    public static final String KEY_IFD_A407_Description = "IFD_A407_Description";
    public static final String KEY_IFD_A408_Description = "IFD_A408_Description";
    public static final String KEY_IFD_A409_Description = "IFD_A409_Description";
    public static final String KEY_IFD_A40A_Description = "IFD_A40A_Description";
    public static final String KEY_IFD_A40C_Description = "IFD_A40C_Description";
    public static final String KEY_IFD_A500_Description = "IFD_A500_Description";

    public static final String KEY_IFD_GPS_0000_Description = "IFD_GPS_0000_Description";
    public static final String KEY_IFD_ItO_0001_Description = "IFD_ItO_0001_Description";

    public static String getString(String key){
        return res.getString(key);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFDParse.java`:

```java
/*
 * IFDParse.java    Sep 09, 2010, 12:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 */
public class IFDParse {

    public static IFD parse(final PosDataInputStream pDIS, int byteOrder, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        final int tag = readUnsignedShort(pDIS, byteOrder);
        final int type = readUnsignedShort(pDIS, byteOrder);

        switch (tag) {
            case IFDTag.IFD_0106_PhotometricInterpretation:
                return new IFD_0106_PhotometricInterpretation(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_010E_ImageDescription:
                return new IFD_010E_ImageDescription(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_010F_Make:
                return new IFD_010F_Make(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0110_Model:
                return new IFD_0110_Model(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0112_Orientation:
                return new IFD_0112_Orientation(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_011A_XResolution:
                return new IFD_011A_XResolution(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_011B_YResolution:
                return new IFD_011B_YResolution(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0128_ResolutionUnit:
                return new IFD_0128_ResolutionUnit(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0131_Software:
                return new IFD_0131_Software(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0132_DateTime:
                return new IFD_0132_DateTime(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_013E_WhitePoint:
                return new IFD_013E_WhitePoint(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_013F_PrimaryChromaticities:
                return new IFD_013F_PrimaryChromaticities(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0201_JPEGInterchangeFormat:
                return new IFD_0201_JPEGInterchangeFormat(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0202_JPEGInterchangeFormatLength:
                return new IFD_0202_JPEGInterchangeFormatLength(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0211_YCbCrCoefficients:
                return new IFD_0211_YCbCrCoefficients(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0213_YCbCrPositioning:
                return new IFD_0213_YCbCrPositioning(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0214_ReferenceBlackWhite:
                return new IFD_0214_ReferenceBlackWhite(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

            case IFDTag.IFD_829A_ExposureTime:
                return new IFD_829A_ExposureTime(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_829D_FNumber:
                return new IFD_829D_FNumber(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_8769_Exif:
                return new IFD_8769_Exif(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_8822_ExposureProgram:
                return new IFD_8822_ExposureProgram(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_8825_GPS:
                return new IFD_8825_GPS(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_8827_PhotographicSensitivity:
                return new IFD_8827_PhotographicSensitivity(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9000_ExifVersion:
                return new IFD_9000_ExifVersion(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9003_DateTimeOriginal:
                return new IFD_9003_DateTimeOriginal(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9004_DateTimeDigitized:
                return new IFD_9004_DateTimeDigitized(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9101_ComponentsConfiguration:
                return new IFD_9101_ComponentsConfiguration(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9102_CompressedBitsPerPixel:
                return new IFD_9102_CompressedBitsPerPixel(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9201_ShutterSpeedValue:
                return new IFD_9201_ShutterSpeedValue(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9202_ApertureValue:
                return new IFD_9202_ApertureValue(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9204_ExposureBiasValue:
                return new IFD_9204_ExposureBiasValue(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9205_MaxApertureValue:
                return new IFD_9205_MaxApertureValue(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9207_MeteringMode:
                return new IFD_9207_MeteringMode(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9208_LightSource:
                return new IFD_9208_LightSource(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9209_Flash:
                return new IFD_9209_Flash(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_920A_FocalLength:
                return new IFD_920A_FocalLength(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_927C_MakerNode:
                return new IFD_927C_MakerNode(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9286_UserComment:
                return new IFD_9286_UserComment(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9290_SubsecTime:
                return new IFD_9290_SubsecTime(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9291_SubsecTimeOriginal:
                return new IFD_9291_SubsecTimeOriginal(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_9292_SubsecTimeDigitized:
                return new IFD_9292_SubsecTimeDigitized(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A000_FlashpixVersion:
                return new IFD_A000_FlashpixVersion(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A001_ColorSpace:
                return new IFD_A001_ColorSpace(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A002_PixelXDimension:                           // Short or Long
                return new IFD_A002_PixelXDimension(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A003_PixelYDimension:                           // Short or Long
                return new IFD_A003_PixelYDimension(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A005_Interoperability:
                return new IFD_A005_Interoperability(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A20E_FocalPlaneXResolution:
                return new IFD_A20E_FocalPlaneXResolution(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A20F_FocalPlaneYResolution:
                return new IFD_A20F_FocalPlaneYResolution(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A210_FocalPlaneResolutionUnit:
                return new IFD_A210_FocalPlaneResolutionUnit(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A215_ExposureIndex:
                return new IFD_A215_ExposureIndex(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A217_SensingMethod:
                return new IFD_A217_SensingMethod(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A300_FileSource:
                return new IFD_A300_FileSource(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A301_SceneType:
                return new IFD_A301_SceneType(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A302_CFAPattern:
                return new IFD_A302_CFAPattern(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A401_CustomRendered:
                return new IFD_A401_CustomRendered(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A402_ExposureMode:
                return new IFD_A402_ExposureMode(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A403_WhiteBalance:
                return new IFD_A403_WhiteBalance(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A404_DigitalZoomRatio:
                return new IFD_A404_DigitalZoomRatio(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A405_FocalLengthIn35mmFilm:
                return new IFD_A405_FocalLengthIn35mmFilm(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A406_SceneCaptureType:
                return new IFD_A406_SceneCaptureType(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A407_GainControl:
                return new IFD_A407_GainControl(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A408_Contrast:
                return new IFD_A408_Contrast(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A409_Saturation:
                return new IFD_A409_Saturation(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A40A_Sharpness:
                return new IFD_A40A_Sharpness(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A40C_SubjectDistanceRange:
                return new IFD_A40C_SubjectDistanceRange(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_A500_Gamma:
                return new IFD_A500_Gamma(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

            default:
                if (type == IFDType.SHORT) {
                    return new IFD_SHORT(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.LONG) {
                    return new IFD_LONG(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.ASCII) {
                    return new IFD_ASCII(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.RATIONAL) {
                    return new IFD_RATIONAL(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.UNDEFINED) {
                    return new IFD_UNDEFINED(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.SRATIONAL) {
                    return new IFD_SRATIONAL(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else {
                    return new IFD(pDIS, byteOrder, tag, type, startPosTiff);
                }
        }
    }

    static IFD parseGPS(final PosDataInputStream pDIS, int byteOrder, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        final int tag = readUnsignedShort(pDIS, byteOrder);
        final int type = readUnsignedShort(pDIS, byteOrder);

        switch (tag) {
            case IFDTag.IFD_0000_GPSVersionID:
                return new IFD_0000_GPSVersionID(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

            default:
                if (type == IFDType.ASCII) {
                    return new IFD_ASCII(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.BYTE) {
                    return new IFD_BYTE(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.RATIONAL) {
                    return new IFD_RATIONAL(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.SHORT) {
                    return new IFD_SHORT(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else if (type == IFDType.UNDEFINED) {
                    return new IFD_UNDEFINED(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else {
                    return new IFD(pDIS, byteOrder, tag, type, startPosTiff);
                }
        }

    }

    static IFD parseIntero(final PosDataInputStream pDIS, int byteOrder, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        final int tag = readUnsignedShort(pDIS, byteOrder);
        final int type = readUnsignedShort(pDIS, byteOrder);

        switch (tag) {
            case IFDTag.IFD_0001_InteroperabilityIndex:
                return new IFD_0001_InteroperabilityIndex(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            case IFDTag.IFD_0002_InteroperabilityVersion:
                return new IFD_0002_InteroperabilityVersion(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
            default:
                if (type == IFDType.ASCII) {
                    return new IFD_ASCII(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
                } else {
                    return new IFD(pDIS, byteOrder, tag, type, startPosTiff);
                }
        }
    }

    public static int readUnsignedShort(final PosDataInputStream pDIS, int byteOrder) throws IOException {
        if (byteOrder == TIFFHeader.BYTEORDER_BIGENDIAN) {
            return pDIS.readUnsignedShort();
        } else {
            return pDIS.readUnsignedShortInLittleEndian();
        }
    }

    public static int readInt(final PosDataInputStream pDIS, int byteOrder) throws IOException {
        if (byteOrder == TIFFHeader.BYTEORDER_BIGENDIAN) {
            return pDIS.readInt();
        } else {
            return pDIS.readIntInLittleEndian();
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFDTag.java`:

```java
/*
 * IFDTag.java    Sep 06, 2010, 23:41
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.jpeg.tiff;

import java.util.ResourceBundle;

/**
 *
 * @author Amos Shi
 */
public class IFDTag {

    ////////////////////////////////////////////////////////////////////////////
    // ITFF-v6

    public static final int IFD_00FE_NewSubfileType = 0x00FE;
    public static final int IFD_00FF_SubfileType = 0x00FF;
    public static final int IFD_0100_ImageWidth = 0x0100;                       // TIFF-v6: Page 18, 34
    public static final int IFD_0101_ImageLength = 0x0101;                      // TIFF-v6: Page 18, 34
    public static final int IFD_0102_BitsPerSample = 0x0102;                    // TIFF-v6: Page 22, 29
    public static final int IFD_0103_Compression = 0x0103;                      // TIFF-v6: Page 17, 30, 49, 104
    public static final int IFD_0106_Color = 0x0106;                            // TIFF-v6: Page 17, 111
    public static final int IFD_0106_PhotometricInterpretation = 0x0106;        // TIFF-v6: Page 37, 90, 111
    public static final int IFD_0107_Threshholding = 0x0107;
    public static final int IFD_0108_CellWidth = 0x0108;
    public static final int IFD_0109_CellLength = 0x0109;
    public static final int IFD_010A_FillOrder = 0x010A;
    public static final int IFD_010D_DocumentName = 0x010D;
    public static final int IFD_010E_ImageDescription = 0x010E;
    public static final int IFD_010F_Make = 0x010F;
    public static final int IFD_0110_Model = 0x0110;
    public static final int IFD_0111_StripOffsets = 0x0111;                     // TIFF-v6: Page 19, 40
    public static final int IFD_0112_Orientation = 0x0112;
    public static final int IFD_0115_SamplesPerPixel = 0x0115;                  // TIFF-v6: Page 24, 39
    public static final int IFD_0116_RowsPerStrip = 0x0116;                     // TIFF-v6: Page 19, 39
    public static final int IFD_0117_StripByteCounts = 0x0117;                  // TIFF-v6: Page 19, 40
    public static final int IFD_0118_MinSampleValue = 0x0118;
    public static final int IFD_0119_MaxSampleValue = 0x0119;
    public static final int IFD_011A_XResolution = 0x011A;                      // TIFF-v6: Page 19, 41
    public static final int IFD_011B_YResolution = 0x011B;                      // TIFF-v6: Page 19, 41
    public static final int IFD_011C_PlanarConfiguration = 0x011C;
    public static final int IFD_011D_PageName = 0x011D;
    public static final int IFD_011E_XPosition = 0x011E;
    public static final int IFD_011F_YPosition = 0x011F;
    public static final int IFD_0120_FreeOffsets = 0x0120;
    public static final int IFD_0121_FreeByteCounts = 0x0121;
    public static final int IFD_0122_GrayResponseUnit = 0x0122;
    public static final int IFD_0123_GrayResponseCurve = 0x0123;
    public static final int IFD_0124_T4Options = 0x0124;
    public static final int IFD_0125_T6Options = 0x0125;
    public static final int IFD_0128_ResolutionUnit = 0x0128;                   // TIFF-v6: Page 18, 38
    public static final int IFD_0129_PageNumber = 0x0129;
    public static final int IFD_012D_TransferFunction = 0x012D;
    public static final int IFD_0131_Software = 0x0131;
    public static final int IFD_0132_DateTime = 0x0132;
    public static final int IFD_013B_Artist = 0x013B;
    public static final int IFD_013C_HostComputer = 0x013C;
    public static final int IFD_013D_Predictor = 0x013D;
    public static final int IFD_013E_WhitePoint = 0x013E;
    public static final int IFD_013F_PrimaryChromaticities = 0x013F;
    public static final int IFD_0140_ColorMap = 0x0140;                         // TIFF-v6: Page 23, 29
    public static final int IFD_0141_HalftoneHints = 0x0141;
    public static final int IFD_0142_TileWidth = 0x0142;
    public static final int IFD_0143_TileLength = 0x0143;
    public static final int IFD_0144_TileOffsets = 0x0144;
    public static final int IFD_0145_TileByteCounts = 0x0145;
    public static final int IFD_014C_InkSet = 0x014C;
    public static final int IFD_014D_InkNames = 0x014D;
    public static final int IFD_014E_NumberOfInks = 0x014E;
    public static final int IFD_0150_DotRange = 0x0150;
    public static final int IFD_0151_TargetPrinter = 0x0151;
    public static final int IFD_0152_ExtraSamples = 0x0152;                     // TIFF-v6: Page 31, 77
    public static final int IFD_0153_SampleFormat = 0x0153;
    public static final int IFD_0154_SMinSampleValue = 0x0154;
    public static final int IFD_0155_SMaxSampleValue = 0x0155;
    public static final int IFD_0156_TransferRange = 0x0156;
    public static final int IFD_0200_JPEGProc = 0x0200;
    public static final int IFD_0201_JPEGInterchangeFormat = 0x0201;
    public static final int IFD_0202_JPEGInterchangeFormatLength = 0x0202;
    public static final int IFD_0203_JPEGRestartInterval = 0x0203;
    public static final int IFD_0205_JPEGLosslessPredictors = 0x0205;
    public static final int IFD_0206_JPEGPointTransforms = 0x0206;
    public static final int IFD_0207_JPEGQTables = 0x0207;
    public static final int IFD_0208_JPEGDCTables = 0x0208;
    public static final int IFD_0209_JPEGACTables = 0x0209;
    public static final int IFD_0211_YCbCrCoefficients = 0x0211;
    public static final int IFD_0212_YCbCrSubSampling = 0x0212;
    public static final int IFD_0213_YCbCrPositioning = 0x0213;
    public static final int IFD_0214_ReferenceBlackWhite = 0x0214;
    public static final int IFD_8298_Copyright = 0x8298;

    ////////////////////////////////////////////////////////////////////////////
    // CIPA DC-008-2010

    public static final int IFD_829A_ExposureTime = 0x829A;
    public static final int IFD_829D_FNumber = 0x829D;
    public static final int IFD_8769_Exif = 0x8769;
    public static final int IFD_8822_ExposureProgram = 0x8822;
    public static final int IFD_8824_SpectralSensitivity = 0x8824;
    public static final int IFD_8825_GPS = 0x8825;                              // GPS Info IFD Pointer
    public static final int IFD_8827_PhotographicSensitivity = 0x8827;
    public static final int IFD_8828_OECF = 0x8828;
    public static final int IFD_8830_SensitivityType = 0x8830;
    public static final int IFD_8831_StandardOutputSensitivity = 0x8831;
    public static final int IFD_8832_RecommendedExposureIndex = 0x8832;
    public static final int IFD_8833_ISOSpeed = 0x8833;
    public static final int IFD_8834_ISOSpeedLatitudeyyy = 0x8834;
    public static final int IFD_8835_ISOSpeedLatitudezzz = 0x8835;
    public static final int IFD_9000_ExifVersion = 0x9000;
    public static final int IFD_9003_DateTimeOriginal = 0x9003;
    public static final int IFD_9004_DateTimeDigitized = 0x9004;
    public static final int IFD_9101_ComponentsConfiguration = 0x9101;
    public static final int IFD_9102_CompressedBitsPerPixel = 0x9102;
    public static final int IFD_9201_ShutterSpeedValue = 0x9201;
    public static final int IFD_9202_ApertureValue = 0x9202;
    public static final int IFD_9203_BrightnessValue = 0x9203;
    public static final int IFD_9204_ExposureBiasValue = 0x9204;
    public static final int IFD_9205_MaxApertureValue = 0x9205;
    public static final int IFD_9206_SubjectDistance = 0x9206;
    public static final int IFD_9207_MeteringMode = 0x9207;
    public static final int IFD_9208_LightSource = 0x9208;
    public static final int IFD_9209_Flash = 0x9209;
    public static final int IFD_920A_FocalLength = 0x920A;
    public static final int IFD_9214_SubjectArea = 0x9214;
    public static final int IFD_927C_MakerNode = 0x927C;
    public static final int IFD_9286_UserComment = 0x9286;
    public static final int IFD_9290_SubsecTime = 0x9290;
    public static final int IFD_9291_SubsecTimeOriginal = 0x9291;
    public static final int IFD_9292_SubsecTimeDigitized = 0x9292;
    public static final int IFD_A000_FlashpixVersion = 0xA000;
    public static final int IFD_A001_ColorSpace = 0xA001;
    public static final int IFD_A002_PixelXDimension = 0xA002;
    public static final int IFD_A003_PixelYDimension = 0xA003;
    public static final int IFD_A004_RelatedSoundFile = 0xA004;
    public static final int IFD_A005_Interoperability = 0xA005;                 // Interoperability IFD Pointer
    public static final int IFD_A20B_FlashEnergy = 0xA20B;
    public static final int IFD_A20C_SpatialFrequencyResponse = 0xA20C;
    public static final int IFD_A20E_FocalPlaneXResolution = 0xA20E;
    public static final int IFD_A20F_FocalPlaneYResolution = 0xA20F;
    public static final int IFD_A210_FocalPlaneResolutionUnit = 0xA210;
    public static final int IFD_A214_SubjectLocation = 0xA214;
    public static final int IFD_A215_ExposureIndex = 0xA215;
    public static final int IFD_A217_SensingMethod = 0xA217;
    public static final int IFD_A300_FileSource = 0xA300;
    public static final int IFD_A301_SceneType = 0xA301;
    public static final int IFD_A302_CFAPattern = 0xA302;
    public static final int IFD_A401_CustomRendered = 0xA401;
    public static final int IFD_A402_ExposureMode = 0xA402;
    public static final int IFD_A403_WhiteBalance = 0xA403;
    public static final int IFD_A404_DigitalZoomRatio = 0xA404;
    public static final int IFD_A405_FocalLengthIn35mmFilm = 0xA405;
    public static final int IFD_A406_SceneCaptureType = 0xA406;
    public static final int IFD_A407_GainControl = 0xA407;
    public static final int IFD_A408_Contrast = 0xA408;
    public static final int IFD_A409_Saturation = 0xA409;
    public static final int IFD_A40A_Sharpness = 0xA40A;
    public static final int IFD_A40B_DeviceSettingDescription = 0xA40B;
    public static final int IFD_A40C_SubjectDistanceRange = 0xA40C;
    public static final int IFD_A420_ImageUniqueID = 0xA420;
    public static final int IFD_A430_CameraOwnerName = 0xA430;
    public static final int IFD_A431_BodySerialNumber = 0xA431;
    public static final int IFD_A432_LensSpecification = 0xA432;
    public static final int IFD_A433_LensMake = 0xA433;
    public static final int IFD_A434_LensModel = 0xA434;
    public static final int IFD_A435_LensSerialNumber = 0xA435;
    public static final int IFD_A500_Gamma = 0xA500;

    // GPS Private IFD

    public static final int IFD_0000_GPSVersionID = 0x0000;
    public static final int IFD_0001_GPSLatitudeRef = 0x0001;
    public static final int IFD_0002_GPSLatitude = 0x0002;
    public static final int IFD_0003_GPSLongitudeRef = 0x0003;
    public static final int IFD_0004_GPSLongitude = 0x0004;
    public static final int IFD_0005_GPSAltitudeRef = 0x0005;
    public static final int IFD_0006_GPSAltitude = 0x0006;
    public static final int IFD_0007_GPSTimeStamp = 0x0007;
    public static final int IFD_0008_GPSSatellites = 0x0008;
    public static final int IFD_0009_GPSStatus = 0x0009;
    public static final int IFD_000A_GPSMeasureMode = 0x000A;
    public static final int IFD_000B_GPSDOP = 0x000B;
    public static final int IFD_000C_GPSSpeedRef = 0x000C;
    public static final int IFD_000D_GPSSpeed = 0x000D;
    public static final int IFD_000E_GPSTrackRef = 0x000E;
    public static final int IFD_000F_GPSTrack = 0x000F;
    public static final int IFD_0010_GPSImgDirectionRef = 0x0010;
    public static final int IFD_0011_GPSImgDirection = 0x0011;
    public static final int IFD_0012_GPSMapDatum = 0x0012;
    public static final int IFD_0013_GPSDestLatitudeRef = 0x0013;
    public static final int IFD_0014_GPSDestLatitude = 0x0014;
    public static final int IFD_0015_GPSDestLongitudeRef = 0x0015;
    public static final int IFD_0016_GPSDestLongitude = 0x0016;
    public static final int IFD_0017_GPSDestBearingRef = 0x0017;
    public static final int IFD_0018_GPSDestBearing = 0x0018;
    public static final int IFD_0019_GPSDestDistanceRef = 0x0019;
    public static final int IFD_001A_GPSDestDistance = 0x001A;
    public static final int IFD_001B_GPSProcessingMethod = 0x001B;
    public static final int IFD_001C_GPSAreaInformation = 0x001C;
    public static final int IFD_001D_GPSDateStamp = 0x001D;
    public static final int IFD_001E_GPSDifferential = 0x001E;
    public static final int IFD_001F_GPSHPositioiningError = 0x001F;

    // Interoperability Private IFD

    public static final int IFD_0001_InteroperabilityIndex = 0x0001;
    public static final int IFD_0002_InteroperabilityVersion = 0x0002;
    private static final ResourceBundle IFDTagMessage = ResourceBundle.getBundle(IFDTag.class.getName().replace('.', '/'));

    public static String getTagName(int tag){
        final String name;
        switch(tag){

            ////////////////////////////////////////////////////////////////////
            // ITFF-v6

            case IFDTag.IFD_00FE_NewSubfileType:
                name = IFDTagMessage.getString("IFD_00FE_NewSubfileType");
                break;

            case IFDTag.IFD_00FF_SubfileType:
                name = IFDTagMessage.getString("IFD_00FF_SubfileType");
                break;

            case IFDTag.IFD_0100_ImageWidth:
                name = IFDTagMessage.getString("IFD_0100_ImageWidth");
                break;

            case IFDTag.IFD_0101_ImageLength:
                name = IFDTagMessage.getString("IFD_0101_ImageLength");
                break;

            case IFDTag.IFD_0102_BitsPerSample:
                name = IFDTagMessage.getString("IFD_0102_BitsPerSample");
                break;

            case IFDTag.IFD_0103_Compression:
                name = IFDTagMessage.getString("IFD_0103_Compression");
                break;

//          case IFDTag.IFD_0106_Color:
            case IFDTag.IFD_0106_PhotometricInterpretation:
                name = IFDTagMessage.getString("IFD_0106_PhotometricInterpretation");
                break;

            case IFDTag.IFD_0107_Threshholding:
                name = IFDTagMessage.getString("IFD_0107_Threshholding");
                break;

            case IFDTag.IFD_0108_CellWidth:
                name = IFDTagMessage.getString("IFD_0108_CellWidth");
                break;

            case IFDTag.IFD_0109_CellLength:
                name = IFDTagMessage.getString("IFD_0109_CellLength");
                break;

            case IFDTag.IFD_010A_FillOrder:
                name = IFDTagMessage.getString("IFD_010A_FillOrder");
                break;

            case IFDTag.IFD_010D_DocumentName:
                name = IFDTagMessage.getString("IFD_010D_DocumentName");
                break;

            case IFDTag.IFD_010E_ImageDescription:
                name = IFDTagMessage.getString("IFD_010E_ImageDescription");
                break;

            case IFDTag.IFD_010F_Make:
                name = IFDTagMessage.getString("IFD_010F_Make");
                break;

            case IFDTag.IFD_0110_Model:
                name = IFDTagMessage.getString("IFD_0110_Model");
                break;

            case IFDTag.IFD_0111_StripOffsets:
                name = IFDTagMessage.getString("IFD_0111_StripOffsets");
                break;

            case IFDTag.IFD_0112_Orientation:
                name = IFDTagMessage.getString("IFD_0112_Orientation");
                break;

            case IFDTag.IFD_0115_SamplesPerPixel:
                name = IFDTagMessage.getString("IFD_0115_SamplesPerPixel");
                break;

            case IFDTag.IFD_0116_RowsPerStrip:
                name = IFDTagMessage.getString("IFD_0116_RowsPerStrip");
                break;

            case IFDTag.IFD_0117_StripByteCounts:
                name = IFDTagMessage.getString("IFD_0117_StripByteCounts");
                break;

            case IFDTag.IFD_0118_MinSampleValue:
                name = IFDTagMessage.getString("IFD_0118_MinSampleValue");
                break;

            case IFDTag.IFD_0119_MaxSampleValue:
                name = IFDTagMessage.getString("IFD_0119_MaxSampleValue");
                break;

            case IFDTag.IFD_011A_XResolution:
                name = IFDTagMessage.getString("IFD_011A_XResolution");
                break;

            case IFDTag.IFD_011B_YResolution:
                name = IFDTagMessage.getString("IFD_011B_YResolution");
                break;

            case IFDTag.IFD_011C_PlanarConfiguration:
                name = IFDTagMessage.getString("IFD_011C_PlanarConfiguration");
                break;

            case IFDTag.IFD_011D_PageName:
                name = IFDTagMessage.getString("IFD_011D_PageName");
                break;

            case IFDTag.IFD_011E_XPosition:
                name = IFDTagMessage.getString("IFD_011E_XPosition");
                break;

            case IFDTag.IFD_011F_YPosition:
                name = IFDTagMessage.getString("IFD_011F_YPosition");
                break;

            case IFDTag.IFD_0120_FreeOffsets:
                name = IFDTagMessage.getString("IFD_0120_FreeOffsets");
                break;

            case IFDTag.IFD_0121_FreeByteCounts:
                name = IFDTagMessage.getString("IFD_0121_FreeByteCounts");
                break;

            case IFDTag.IFD_0122_GrayResponseUnit:
                name = IFDTagMessage.getString("IFD_0122_GrayResponseUnit");
                break;

            case IFDTag.IFD_0123_GrayResponseCurve:
                name = IFDTagMessage.getString("IFD_0123_GrayResponseCurve");
                break;

            case IFDTag.IFD_0124_T4Options:
                name = IFDTagMessage.getString("IFD_0124_T4Options");
                break;

            case IFDTag.IFD_0125_T6Options:
                name = IFDTagMessage.getString("IFD_0125_T6Options");
                break;

            case IFDTag.IFD_0128_ResolutionUnit:
                name = IFDTagMessage.getString("IFD_0128_ResolutionUnit");
                break;

            case IFDTag.IFD_0129_PageNumber:
                name = IFDTagMessage.getString("IFD_0129_PageNumber");
                break;

            case IFDTag.IFD_012D_TransferFunction:
                name = IFDTagMessage.getString("IFD_012D_TransferFunction");
                break;

            case IFDTag.IFD_0131_Software:
                name = IFDTagMessage.getString("IFD_0131_Software");
                break;

            case IFDTag.IFD_0132_DateTime:
                name = IFDTagMessage.getString("IFD_0132_DateTime");
                break;

            case IFDTag.IFD_013B_Artist:
                name = IFDTagMessage.getString("IFD_013B_Artist");
                break;

            case IFDTag.IFD_013C_HostComputer:
                name = IFDTagMessage.getString("IFD_013C_HostComputer");
                break;

            case IFDTag.IFD_013D_Predictor:
                name = IFDTagMessage.getString("IFD_013D_Predictor");
                break;

            case IFDTag.IFD_013E_WhitePoint:
                name = IFDTagMessage.getString("IFD_013E_WhitePoint");
                break;

            case IFDTag.IFD_013F_PrimaryChromaticities:
                name = IFDTagMessage.getString("IFD_013F_PrimaryChromaticities");
                break;

            case IFDTag.IFD_0140_ColorMap:
                name = IFDTagMessage.getString("IFD_0140_ColorMap");
                break;

            case IFDTag.IFD_0141_HalftoneHints:
                name = IFDTagMessage.getString("IFD_0141_HalftoneHints");
                break;

            case IFDTag.IFD_0142_TileWidth:
                name = IFDTagMessage.getString("IFD_0142_TileWidth");
                break;

            case IFDTag.IFD_0143_TileLength:
                name = IFDTagMessage.getString("IFD_0143_TileLength");
                break;

            case IFDTag.IFD_0144_TileOffsets:
                name = IFDTagMessage.getString("IFD_0144_TileOffsets");
                break;

            case IFDTag.IFD_0145_TileByteCounts:
                name = IFDTagMessage.getString("IFD_0145_TileByteCounts");
                break;

            case IFDTag.IFD_014C_InkSet:
                name = IFDTagMessage.getString("IFD_014C_InkSet");
                break;

            case IFDTag.IFD_014D_InkNames:
                name = IFDTagMessage.getString("IFD_014D_InkNames");
                break;

            case IFDTag.IFD_014E_NumberOfInks:
                name = IFDTagMessage.getString("IFD_014E_NumberOfInks");
                break;

            case IFDTag.IFD_0150_DotRange:
                name = IFDTagMessage.getString("IFD_0150_DotRange");
                break;

            case IFDTag.IFD_0151_TargetPrinter:
                name = IFDTagMessage.getString("IFD_0151_TargetPrinter");
                break;

            case IFDTag.IFD_0152_ExtraSamples:
                name = IFDTagMessage.getString("IFD_0152_ExtraSamples");
                break;

            case IFDTag.IFD_0153_SampleFormat:
                name = IFDTagMessage.getString("IFD_0153_SampleFormat");
                break;

            case IFDTag.IFD_0154_SMinSampleValue:
                name = IFDTagMessage.getString("IFD_0154_SMinSampleValue");
                break;

            case IFDTag.IFD_0155_SMaxSampleValue:
                name = IFDTagMessage.getString("IFD_0155_SMaxSampleValue");
                break;

            case IFDTag.IFD_0156_TransferRange:
                name = IFDTagMessage.getString("IFD_0156_TransferRange");
                break;

            case IFDTag.IFD_0200_JPEGProc:
                name = IFDTagMessage.getString("IFD_0200_JPEGProc");
                break;

            case IFDTag.IFD_0201_JPEGInterchangeFormat:
                name = IFDTagMessage.getString("IFD_0201_JPEGInterchangeFormat");
                break;

            case IFDTag.IFD_0202_JPEGInterchangeFormatLength:
                name = IFDTagMessage.getString("IFD_0202_JPEGInterchangeFormatLength");
                break;

            case IFDTag.IFD_0203_JPEGRestartInterval:
                name = IFDTagMessage.getString("IFD_0203_JPEGRestartInterval");
                break;

            case IFDTag.IFD_0205_JPEGLosslessPredictors:
                name = IFDTagMessage.getString("IFD_0205_JPEGLosslessPredictors");
                break;

            case IFDTag.IFD_0206_JPEGPointTransforms:
                name = IFDTagMessage.getString("IFD_0206_JPEGPointTransforms");
                break;

            case IFDTag.IFD_0207_JPEGQTables:
                name = IFDTagMessage.getString("IFD_0207_JPEGQTables");
                break;

            case IFDTag.IFD_0208_JPEGDCTables:
                name = IFDTagMessage.getString("IFD_0208_JPEGDCTables");
                break;

            case IFDTag.IFD_0209_JPEGACTables:
                name = IFDTagMessage.getString("IFD_0209_JPEGACTables");
                break;

            case IFDTag.IFD_0211_YCbCrCoefficients:
                name = IFDTagMessage.getString("IFD_0211_YCbCrCoefficients");
                break;

            case IFDTag.IFD_0212_YCbCrSubSampling:
                name = IFDTagMessage.getString("IFD_0212_YCbCrSubSampling");
                break;

            case IFDTag.IFD_0213_YCbCrPositioning:
                name = IFDTagMessage.getString("IFD_0213_YCbCrPositioning");
                break;

            case IFDTag.IFD_0214_ReferenceBlackWhite:
                name = IFDTagMessage.getString("IFD_0214_ReferenceBlackWhite");
                break;

            case IFDTag.IFD_8298_Copyright:
                name = IFDTagMessage.getString("IFD_8298_Copyright");
                break;

            ////////////////////////////////////////////////////////////////////
            // CIPA DC-008-2010

            case IFDTag.IFD_829A_ExposureTime:
                name = IFDTagMessage.getString("IFD_829A_ExposureTime");
                break;

            case IFDTag.IFD_829D_FNumber:
                name = IFDTagMessage.getString("IFD_829D_FNumber");
                break;

            case IFDTag.IFD_8769_Exif:
                name = IFDTagMessage.getString("IFD_8769_Exif");
                break;

            case IFDTag.IFD_8822_ExposureProgram:
                name = IFDTagMessage.getString("IFD_8822_ExposureProgram");
                break;

            case IFDTag.IFD_8824_SpectralSensitivity:
                name = IFDTagMessage.getString("IFD_8824_SpectralSensitivity");
                break;

            case IFDTag.IFD_8825_GPS:
                name = IFDTagMessage.getString("IFD_8825_GPS");
                break;

            case IFDTag.IFD_8827_PhotographicSensitivity:
                name = IFDTagMessage.getString("IFD_8827_PhotographicSensitivity");
                break;

            case IFDTag.IFD_8828_OECF:
                name = IFDTagMessage.getString("IFD_8828_OECF");
                break;

            case IFDTag.IFD_8830_SensitivityType:
                name = IFDTagMessage.getString("IFD_8830_SensitivityType");
                break;

            case IFDTag.IFD_8831_StandardOutputSensitivity:
                name = IFDTagMessage.getString("IFD_8831_StandardOutputSensitivity");
                break;

            case IFDTag.IFD_8832_RecommendedExposureIndex:
                name = IFDTagMessage.getString("IFD_8832_RecommendedExposureIndex");
                break;

            case IFDTag.IFD_8833_ISOSpeed:
                name = IFDTagMessage.getString("IFD_8833_ISOSpeed");
                break;

            case IFDTag.IFD_8834_ISOSpeedLatitudeyyy:
                name = IFDTagMessage.getString("IFD_8834_ISOSpeedLatitudeyyy");
                break;

            case IFDTag.IFD_8835_ISOSpeedLatitudezzz:
                name = IFDTagMessage.getString("IFD_8835_ISOSpeedLatitudezzz");
                break;

            case IFDTag.IFD_9000_ExifVersion:
                name = IFDTagMessage.getString("IFD_9000_ExifVersion");
                break;

            case IFDTag.IFD_9003_DateTimeOriginal:
                name = IFDTagMessage.getString("IFD_9003_DateTimeOriginal");
                break;

            case IFDTag.IFD_9004_DateTimeDigitized:
                name = IFDTagMessage.getString("IFD_9004_DateTimeDigitized");
                break;

            case IFDTag.IFD_9101_ComponentsConfiguration:
                name = IFDTagMessage.getString("IFD_9101_ComponentsConfiguration");
                break;

            case IFDTag.IFD_9102_CompressedBitsPerPixel:
                name = IFDTagMessage.getString("IFD_9102_CompressedBitsPerPixel");
                break;

            case IFDTag.IFD_9201_ShutterSpeedValue:
                name = IFDTagMessage.getString("IFD_9201_ShutterSpeedValue");
                break;

            case IFDTag.IFD_9202_ApertureValue:
                name = IFDTagMessage.getString("IFD_9202_ApertureValue");
                break;

            case IFDTag.IFD_9203_BrightnessValue:
                name = IFDTagMessage.getString("IFD_9203_BrightnessValue");
                break;

            case IFDTag.IFD_9204_ExposureBiasValue:
                name = IFDTagMessage.getString("IFD_9204_ExposureBiasValue");
                break;

            case IFDTag.IFD_9205_MaxApertureValue:
                name = IFDTagMessage.getString("IFD_9205_MaxApertureValue");
                break;

            case IFDTag.IFD_9206_SubjectDistance:
                name = IFDTagMessage.getString("IFD_9206_SubjectDistance");
                break;

            case IFDTag.IFD_9207_MeteringMode:
                name = IFDTagMessage.getString("IFD_9207_MeteringMode");
                break;

            case IFDTag.IFD_9208_LightSource:
                name = IFDTagMessage.getString("IFD_9208_LightSource");
                break;

            case IFDTag.IFD_9209_Flash:
                name = IFDTagMessage.getString("IFD_9209_Flash");
                break;

            case IFDTag.IFD_920A_FocalLength:
                name = IFDTagMessage.getString("IFD_920A_FocalLength");
                break;

            case IFDTag.IFD_9214_SubjectArea:
                name = IFDTagMessage.getString("IFD_9214_SubjectArea");
                break;

            case IFDTag.IFD_927C_MakerNode:
                name = IFDTagMessage.getString("IFD_927C_MakerNode");
                break;

            case IFDTag.IFD_9286_UserComment:
                name = IFDTagMessage.getString("IFD_9286_UserComment");
                break;

            case IFDTag.IFD_9290_SubsecTime:
                name = IFDTagMessage.getString("IFD_9290_SubsecTime");
                break;

            case IFDTag.IFD_9291_SubsecTimeOriginal:
                name = IFDTagMessage.getString("IFD_9291_SubsecTimeOriginal");
                break;

            case IFDTag.IFD_9292_SubsecTimeDigitized:
                name = IFDTagMessage.getString("IFD_9292_SubsecTimeDigitized");
                break;

            case IFDTag.IFD_A000_FlashpixVersion:
                name = IFDTagMessage.getString("IFD_A000_FlashpixVersion");
                break;

            case IFDTag.IFD_A001_ColorSpace:
                name = IFDTagMessage.getString("IFD_A001_ColorSpace");
                break;

            case IFDTag.IFD_A002_PixelXDimension:
                name = IFDTagMessage.getString("IFD_A002_PixelXDimension");
                break;

            case IFDTag.IFD_A003_PixelYDimension:
                name = IFDTagMessage.getString("IFD_A003_PixelYDimension");
                break;

            case IFDTag.IFD_A004_RelatedSoundFile:
                name = IFDTagMessage.getString("IFD_A004_RelatedSoundFile");
                break;

            case IFDTag.IFD_A005_Interoperability:
                name = IFDTagMessage.getString("IFD_A005_Interoperability");
                break;

            case IFDTag.IFD_A20B_FlashEnergy:
                name = IFDTagMessage.getString("IFD_A20B_FlashEnergy");
                break;

            case IFDTag.IFD_A20C_SpatialFrequencyResponse:
                name = IFDTagMessage.getString("IFD_A20C_SpatialFrequencyResponse");
                break;

            case IFDTag.IFD_A20E_FocalPlaneXResolution:
                name = IFDTagMessage.getString("IFD_A20E_FocalPlaneXResolution");
                break;

            case IFDTag.IFD_A20F_FocalPlaneYResolution:
                name = IFDTagMessage.getString("IFD_A20F_FocalPlaneYResolution");
                break;

            case IFDTag.IFD_A210_FocalPlaneResolutionUnit:
                name = IFDTagMessage.getString("IFD_A210_FocalPlaneResolutionUnit");
                break;

            case IFDTag.IFD_A214_SubjectLocation:
                name = IFDTagMessage.getString("IFD_A214_SubjectLocation");
                break;

            case IFDTag.IFD_A215_ExposureIndex:
                name = IFDTagMessage.getString("IFD_A215_ExposureIndex");
                break;

            case IFDTag.IFD_A217_SensingMethod:
                name = IFDTagMessage.getString("IFD_A217_SensingMethod");
                break;

            case IFDTag.IFD_A300_FileSource:
                name = IFDTagMessage.getString("IFD_A300_FileSource");
                break;

            case IFDTag.IFD_A301_SceneType:
                name = IFDTagMessage.getString("IFD_A301_SceneType");
                break;

            case IFDTag.IFD_A302_CFAPattern:
                name = IFDTagMessage.getString("IFD_A302_CFAPattern");
                break;

            case IFDTag.IFD_A401_CustomRendered:
                name = IFDTagMessage.getString("IFD_A401_CustomRendered");
                break;

            case IFDTag.IFD_A402_ExposureMode:
                name = IFDTagMessage.getString("IFD_A402_ExposureMode");
                break;

            case IFDTag.IFD_A403_WhiteBalance:
                name = IFDTagMessage.getString("IFD_A403_WhiteBalance");
                break;

            case IFDTag.IFD_A404_DigitalZoomRatio:
                name = IFDTagMessage.getString("IFD_A404_DigitalZoomRatio");
                break;

            case IFDTag.IFD_A405_FocalLengthIn35mmFilm:
                name = IFDTagMessage.getString("IFD_A405_FocalLengthIn35mmFilm");
                break;

            case IFDTag.IFD_A406_SceneCaptureType:
                name = IFDTagMessage.getString("IFD_A406_SceneCaptureType");
                break;

            case IFDTag.IFD_A407_GainControl:
                name = IFDTagMessage.getString("IFD_A407_GainControl");
                break;

            case IFDTag.IFD_A408_Contrast:
                name = IFDTagMessage.getString("IFD_A408_Contrast");
                break;

            case IFDTag.IFD_A409_Saturation:
                name = IFDTagMessage.getString("IFD_A409_Saturation");
                break;

            case IFDTag.IFD_A40A_Sharpness:
                name = IFDTagMessage.getString("IFD_A40A_Sharpness");
                break;

            case IFDTag.IFD_A40B_DeviceSettingDescription:
                name = IFDTagMessage.getString("IFD_A40B_DeviceSettingDescription");
                break;

            case IFDTag.IFD_A40C_SubjectDistanceRange:
                name = IFDTagMessage.getString("IFD_A40C_SubjectDistanceRange");
                break;

            case IFDTag.IFD_A420_ImageUniqueID:
                name = IFDTagMessage.getString("IFD_A420_ImageUniqueID");
                break;

            case IFDTag.IFD_A430_CameraOwnerName:
                name = IFDTagMessage.getString("IFD_A430_CameraOwnerName");
                break;

            case IFDTag.IFD_A431_BodySerialNumber:
                name = IFDTagMessage.getString("IFD_A431_BodySerialNumber");
                break;

            case IFDTag.IFD_A432_LensSpecification:
                name = IFDTagMessage.getString("IFD_A432_LensSpecification");
                break;

            case IFDTag.IFD_A433_LensMake:
                name = IFDTagMessage.getString("IFD_A433_LensMake");
                break;

            case IFDTag.IFD_A434_LensModel:
                name = IFDTagMessage.getString("IFD_A434_LensModel");
                break;

            case IFDTag.IFD_A435_LensSerialNumber:
                name = IFDTagMessage.getString("IFD_A435_LensSerialNumber");
                break;

            case IFDTag.IFD_A500_Gamma:
                name = IFDTagMessage.getString("IFD_A500_Gamma");
                break;

            default:
                name = IFDTagMessage.getString("UNKNOWN_TAG");
        }

        return name;
    }

    
    public static String getTagNameGPS(int tag){
        final String name;
        switch(tag){
            case IFDTag.IFD_0000_GPSVersionID:
                name = IFDTagMessage.getString("IFD_0000_GPSVersionID");
                break;
            case IFDTag.IFD_0001_GPSLatitudeRef:
                name = IFDTagMessage.getString("IFD_0001_GPSLatitudeRef");
                break;
            case IFDTag.IFD_0002_GPSLatitude:
                name = IFDTagMessage.getString("IFD_0002_GPSLatitude");
                break;
            case IFDTag.IFD_0003_GPSLongitudeRef:
                name = IFDTagMessage.getString("IFD_0003_GPSLongitudeRef");
                break;
            case IFDTag.IFD_0004_GPSLongitude:
                name = IFDTagMessage.getString("IFD_0004_GPSLongitude");
                break;
            case IFDTag.IFD_0005_GPSAltitudeRef:
                name = IFDTagMessage.getString("IFD_0005_GPSAltitudeRef");
                break;
            case IFDTag.IFD_0006_GPSAltitude:
                name = IFDTagMessage.getString("IFD_0006_GPSAltitude");
                break;
            case IFDTag.IFD_0007_GPSTimeStamp:
                name = IFDTagMessage.getString("IFD_0007_GPSTimeStamp");
                break;
            case IFDTag.IFD_0008_GPSSatellites:
                name = IFDTagMessage.getString("IFD_0008_GPSSatellites");
                break;
            case IFDTag.IFD_0009_GPSStatus:
                name = IFDTagMessage.getString("IFD_0009_GPSStatus");
                break;
            case IFDTag.IFD_000A_GPSMeasureMode:
                name = IFDTagMessage.getString("IFD_000A_GPSMeasureMode");
                break;
            case IFDTag.IFD_000B_GPSDOP:
                name = IFDTagMessage.getString("IFD_000B_GPSDOP");
                break;
            case IFDTag.IFD_000C_GPSSpeedRef:
                name = IFDTagMessage.getString("IFD_000C_GPSSpeedRef");
                break;
            case IFDTag.IFD_000D_GPSSpeed:
                name = IFDTagMessage.getString("IFD_000D_GPSSpeed");
                break;
            case IFDTag.IFD_000E_GPSTrackRef:
                name = IFDTagMessage.getString("IFD_000E_GPSTrackRef");
                break;
            case IFDTag.IFD_000F_GPSTrack:
                name = IFDTagMessage.getString("IFD_000F_GPSTrack");
                break;
            case IFDTag.IFD_0010_GPSImgDirectionRef:
                name = IFDTagMessage.getString("IFD_0010_GPSImgDirectionRef");
                break;
            case IFDTag.IFD_0011_GPSImgDirection:
                name = IFDTagMessage.getString("IFD_0011_GPSImgDirection");
                break;
            case IFDTag.IFD_0012_GPSMapDatum:
                name = IFDTagMessage.getString("IFD_0012_GPSMapDatum");
                break;
            case IFDTag.IFD_0013_GPSDestLatitudeRef:
                name = IFDTagMessage.getString("IFD_0013_GPSDestLatitudeRef");
                break;
            case IFDTag.IFD_0014_GPSDestLatitude:
                name = IFDTagMessage.getString("IFD_0014_GPSDestLatitude");
                break;
            case IFDTag.IFD_0015_GPSDestLongitudeRef:
                name = IFDTagMessage.getString("IFD_0015_GPSDestLongitudeRef");
                break;
            case IFDTag.IFD_0016_GPSDestLongitude:
                name = IFDTagMessage.getString("IFD_0016_GPSDestLongitude");
                break;
            case IFDTag.IFD_0017_GPSDestBearingRef:
                name = IFDTagMessage.getString("IFD_0017_GPSDestBearingRef");
                break;
            case IFDTag.IFD_0018_GPSDestBearing:
                name = IFDTagMessage.getString("IFD_0018_GPSDestBearing");
                break;
            case IFDTag.IFD_0019_GPSDestDistanceRef:
                name = IFDTagMessage.getString("IFD_0019_GPSDestDistanceRef");
                break;
            case IFDTag.IFD_001A_GPSDestDistance:
                name = IFDTagMessage.getString("IFD_001A_GPSDestDistance");
                break;
            case IFDTag.IFD_001B_GPSProcessingMethod:
                name = IFDTagMessage.getString("IFD_001B_GPSProcessingMethod");
                break;
            case IFDTag.IFD_001C_GPSAreaInformation:
                name = IFDTagMessage.getString("IFD_001C_GPSAreaInformation");
                break;
            case IFDTag.IFD_001D_GPSDateStamp:
                name = IFDTagMessage.getString("IFD_001D_GPSDateStamp");
                break;
            case IFDTag.IFD_001E_GPSDifferential:
                name = IFDTagMessage.getString("IFD_001E_GPSDifferential");
                break;
            case IFDTag.IFD_001F_GPSHPositioiningError:
                name = IFDTagMessage.getString("IFD_001F_GPSHPositioiningError");
                break;
            default:
                name = IFDTagMessage.getString("UNKNOWN_GPS_TAG");
        }

        return name;
    }


    public static String getTagNameIntero(int tag){
        final String name;
        switch(tag){
            case IFDTag.IFD_0001_InteroperabilityIndex:
                name = IFDTagMessage.getString("IFD_0001_InteroperabilityIndex");
                break;
            case IFDTag.IFD_0002_InteroperabilityVersion:
                name = IFDTagMessage.getString("IFD_0002_InteroperabilityVersion");
                break;
            default:
                name = IFDTagMessage.getString("UNKNOWN_TAG");
        }

        return name;
    }


}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFDType.java`:

```java
/*
 * IFDType.java    Sep 07, 2010, 22:43
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

/**
 *
 * @author Amos Shi
 */
public class IFDType {

    public static final int UnexpectedType = 0;
    public static final int BYTE = 1;
    public static final int ASCII = 2;
    public static final int SHORT = 3;
    public static final int LONG = 4;
    public static final int RATIONAL = 5;
    public static final int SBYTE = 6;
    public static final int UNDEFINED = 7;
    public static final int SSHORT = 8;
    public static final int SLONG = 9;
    public static final int SRATIONAL = 10;
    public static final int FLOAT = 11;
    public static final int DOUBLE = 12;

    public static final int LENGTH_BYTE = 1;
    public static final int LENGTH_ASCII = 1;
    public static final int LENGTH_SHORT = 2;
    public static final int LENGTH_LONG = 4;
    public static final int LENGTH_RATIONAL = 8;
    public static final int LENGTH_SBYTE = 1;
    public static final int LENGTH_UNDEFINED = 1;
    public static final int LENGTH_SSHORT = 2;
    public static final int LENGTH_SLONG = 4;
    public static final int LENGTH_SRATIONAL = 8;
    public static final int LENGTH_FLOAT = 4;
    public static final int LENGTH_DOUBLE = 8;

    
    public static String getTypeName(int type) {
        final String typeName;
        switch (type) {
            case IFDType.BYTE:
                typeName = "BYTE";
                break;
            case IFDType.ASCII:
                typeName = "ASCII";
                break;
            case IFDType.SHORT:
                typeName = "SHORT";
                break;
            case IFDType.LONG:
                typeName = "LONG";
                break;
            case IFDType.RATIONAL:
                typeName = "RATIONAL";
                break;
            case IFDType.SBYTE:
                typeName = "SBYTE";
                break;
            case IFDType.UNDEFINED:
                typeName = "UNDEFINED";
                break;
            case IFDType.SSHORT:
                typeName = "SSHORT";
                break;
            case IFDType.SLONG:
                typeName = "SLONG";
                break;
            case IFDType.SRATIONAL:
                typeName = "SRATIONAL";
                break;
            case IFDType.FLOAT:
                typeName = "FLOAT";
                break;
            case IFDType.DOUBLE:
                typeName = "DOUBLE";
                break;
            default:
                typeName = "Unknown";
        }
        return typeName;
    }

    public static int getTypeLength(int type){
        final int length;
        switch (type) {
            case IFDType.BYTE:
                length = IFDType.LENGTH_BYTE;
                break;
            case IFDType.ASCII:
                length = IFDType.LENGTH_ASCII;
                break;
            case IFDType.SHORT:
                length = IFDType.LENGTH_SHORT;
                break;
            case IFDType.LONG:
                length = IFDType.LENGTH_LONG;
                break;
            case IFDType.RATIONAL:
                length = IFDType.LENGTH_RATIONAL;
                break;
            case IFDType.SBYTE:
                length = IFDType.LENGTH_SBYTE;
                break;
            case IFDType.UNDEFINED:
                length = IFDType.LENGTH_UNDEFINED;
                break;
            case IFDType.SSHORT:
                length = IFDType.LENGTH_SSHORT;
                break;
            case IFDType.SLONG:
                length = IFDType.LENGTH_SLONG;
                break;
            case IFDType.SRATIONAL:
                length = IFDType.LENGTH_SRATIONAL;
                break;
            case IFDType.FLOAT:
                length = IFDType.LENGTH_FLOAT;
                break;
            case IFDType.DOUBLE:
                length = IFDType.LENGTH_DOUBLE;
                break;
            default:
                length = -1;
        }
        return length;
    }

}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0000_GPSVersionID.java`:

```java
/*
 * IFD_0000_GPSVersionID.java    Oct 30, 2010, 12:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 * @see IFD_8825_GPS#Category_A
 */
public class IFD_0000_GPSVersionID extends IFD_BYTE {

    public static final int COUNT = 4;

    public IFD_0000_GPSVersionID(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public String getGPSVersionID() {
        StringBuilder sb = new StringBuilder(3);
        sb.append(super.value[0]);
        sb.append('.');
        sb.append(super.value[1]);
        return sb.toString();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_BYTE(
                parentNode,
                String.format("%s: %s", this.getTagName(), this.getGPSVersionID()),
                IFDMessage.getString(IFDMessage.KEY_IFD_GPS_0000_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8825_GPS_Category_A));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0001_InteroperabilityIndex.java`:

```java
/*
 * IFD_0001_InteroperabilityIndex.java    Oct 30, 2010, 12:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 * @see IFD_A005_Interoperability#Category_A
 */
public class IFD_0001_InteroperabilityIndex extends IFD_ASCII {

    public static final int COUNT = 4;

    public IFD_0001_InteroperabilityIndex(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_ASCII(
                parentNode,
                String.format("%s: %s", this.getTagName(), super.value),
                IFDMessage.getString(IFDMessage.KEY_IFD_ItO_0001_Description)
                + IFD_A005_Interoperability.Category_A);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0002_InteroperabilityVersion.java`:

```java
/*
 * IFD_0002_InteroperabilityVersion.java    Nov 06, 2010, 15:24
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 */
public class IFD_0002_InteroperabilityVersion extends IFD_UNDEFINED {

    public static final int COUNT = 4;

    public IFD_0002_InteroperabilityVersion(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    public String getVersion() {
        final StringBuffer sb = new StringBuffer(COUNT + 1);
        for (int i = 0; i < COUNT; i++) {
            sb.append((char) super.value[i]);
        }
        return sb.toString();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %s", this.getTagName(), this.getVersion()),
                null);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0106_PhotometricInterpretation.java`:

```java
/*
 * IFD_0106_PhotometricInterpretation.java    Oct 04, 2010, 14:55
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0106_PhotometricInterpretation extends IFD_SHORT_COUNT1 {

    public IFD_0106_PhotometricInterpretation(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {

        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0106_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_010E_ImageDescription.java`:

```java
/*
 * IFD_010E_ImageDescription.java    Sep 13, 2010, 23:15
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 */
public class IFD_010E_ImageDescription extends IFD_ASCII {

    private final static String IFD_Image_Description = "A string that describes the subject of the image."
            + "For example, a user may wish to attach a comment such as \"1988 company picnic\" to an image.";

    public IFD_010E_ImageDescription(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("Image Description: %s", this.value));
            comp.setDescription(IFD_010E_ImageDescription.IFD_Image_Description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("Offset: %d", super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    String.format("Image Description: %s", this.value),
                    Icons.Shortcut, null);
            comp.setDescription(IFD_010E_ImageDescription.IFD_Image_Description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_010F_Make.java`:

```java
/*
 * IFD_010F_Make.java    Sep 13, 2010, 23:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0110_Model
 * @see IFD_0131_Software
 */
public class IFD_010F_Make extends IFD_ASCII {

    public IFD_010F_Make(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%s: %s", super.getTagName(), this.value),
                IFDMessage.getString(IFDMessage.KEY_IFD_010F_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0110_Model.java`:

```java
/*
 * IFD_0110_Model.java    Sep 13, 2010, 23:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see IFD_010F_Make
 * @see IFD_0131_Software
 */
public class IFD_0110_Model extends IFD_ASCII {

    public IFD_0110_Model(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("Model: %s", this.value));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_0110_Description));
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    String.format("Model: %s", this.value),
                    Icons.Shortcut, null);
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_0110_Description));
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0112_Orientation.java`:

```java
/*
 * IFD_0132_DateTime.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0112_Orientation extends IFD_SHORT_COUNT1 {

    public IFD_0112_Orientation(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0112_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_011A_XResolution.java`:

```java
/*
 * IFD_011A_XResolution.java    Oct 04, 2010, 10:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0112_Orientation
 * @see IFD_0128_ResolutionUnit
 * @see IFD_011B_YResolution
 */
public class IFD_011A_XResolution extends IFD_RATIONAL_COUNT1 {

    public IFD_011A_XResolution(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_011A_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_011B_YResolution.java`:

```java
/*
 * IFD_011B_YResolution.java    Oct 04, 2010, 10:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0112_Orientation
 * @see IFD_0128_ResolutionUnit
 * @see IFD_011A_XResolution
 */
public class IFD_011B_YResolution extends IFD_RATIONAL_COUNT1 {

    public IFD_011B_YResolution(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_011B_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0128_ResolutionUnit.java`:

```java
/*
 * IFD_0128_ResolutionUnit.java    Sep 12, 2010, 22:57
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0128_ResolutionUnit extends IFD_SHORT_COUNT1 {

    public IFD_0128_ResolutionUnit(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    public String getResolutionUnitName() {
        switch (super.value[0]) {
            case 1:
                return "No absolute unit of measurement";
            case 2:
                return "Inch";
            case 3:
                return "Centimeter";
            default:
                return "Unrecognized value";
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                2,
                String.format("Resolution Unit: %d - %s", this.value[0], this.getResolutionUnitName()));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_0128_Description));
        parentNode.add(new DefaultMutableTreeNode(comp));

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 10,
                2,
                "Unused")));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0131_Software.java`:

```java
/*
 * IFD_0131_Software.java    Sep 13, 2010, 22:54
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see IFD_010F_Make
 * @see IFD_0110_Model
 */
public class IFD_0131_Software extends IFD_ASCII {

    public IFD_0131_Software(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("Software: %s", this.value));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_0131_Description));
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("Offset: %d", super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    String.format("Software: %s", this.value),
                    Icons.Shortcut, null);
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_0131_Description));
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0132_DateTime.java`:

```java
/*
 * IFD_0132_DateTime.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import java.util.Calendar;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0132_DateTime extends IFD_ASCII {

    public static final int COUNT = 20;
    public final Calendar datetime;

    public IFD_0132_DateTime(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);

        final PosDataInputStream reader = super.getTiffOffsetReader();
        final byte[] buf = new byte[IFD_0132_DateTime.COUNT];
        reader.readFully(buf, 0, IFD_0132_DateTime.COUNT);
        this.datetime = IFD_0132_DateTime.buf2calendar(buf);
    }

    /**
     * Convert a <code>YYYY:MM:DD HH:MM:SS</code> byte buffer into a <code>Calendar</code> instance.
     */
    static Calendar buf2calendar(final byte[] buf) {
        final int value_0 = 48;                                                 // ASCII value of '0'
        final int year = (Byte.valueOf(buf[0]).intValue() - value_0) * 1000
                + (Byte.valueOf(buf[1]).intValue() - value_0) * 100
                + (Byte.valueOf(buf[2]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[3]).intValue() - value_0);
        final int month = (Byte.valueOf(buf[5]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[6]).intValue() - value_0);
        final int date = (Byte.valueOf(buf[8]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[9]).intValue() - value_0);
        final int hourOfDay = (Byte.valueOf(buf[11]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[12]).intValue() - value_0);
        final int minute = (Byte.valueOf(buf[14]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[15]).intValue() - value_0);
        final int second = (Byte.valueOf(buf[17]).intValue() - value_0) * 10
                + (Byte.valueOf(buf[18]).intValue() - value_0);

        Calendar c = Calendar.getInstance();
        c.set(year, month, date, hourOfDay, minute, second);
        return c;
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%04d:%02d:%02d %02d:%02d:%02d",
                this.datetime.get(Calendar.YEAR),
                this.datetime.get(Calendar.MONTH),
                this.datetime.get(Calendar.DATE),
                this.datetime.get(Calendar.HOUR_OF_DAY),
                this.datetime.get(Calendar.MINUTE),
                this.datetime.get(Calendar.SECOND)),
                IFDMessage.getString(IFDMessage.KEY_IFD_0132_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_013E_WhitePoint.java`:

```java
/*
 * IFD_013E_WhitePoint.java    Oct 30, 2010, 16:29
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_013E_WhitePoint extends IFD_RATIONAL {

   public static final int COUNT = 2;

    public IFD_013E_WhitePoint(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_013E_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_013F_PrimaryChromaticities.java`:

```java
/*
 * IFD_013F_PrimaryChromaticities.java    Oct 30, 2010, 16:29
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_013F_PrimaryChromaticities extends IFD_RATIONAL {

    public static final int COUNT = 6;

    public IFD_013F_PrimaryChromaticities(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_013F_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0201_JPEGInterchangeFormat.java`:

```java
/*
 * IFD_0201_JPEGInterchangeFormat.java    Oct 31, 2010, 23:14
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0201_JPEGInterchangeFormat extends IFD_LONG_COUNT1 {

    public IFD_0201_JPEGInterchangeFormat(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    public boolean isBitstreamPresent(){
        return (super.value[0] > 0);
    }

    /**
     * The <code>JPEG</code> interchange format bit stream offset within the <code>TIFF</code>.
     * This attribute is valid only if {@link  #isBitstreamPresent} returns <code>true</code>.
     * @return the offset value
     */
    public long getBitstreamOffset(){
        return super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_LONG(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0201_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0202_JPEGInterchangeFormatLength.java`:

```java
/*
 * IFD_0202_JPEGInterchangeFormatLength.java    Oct 31, 2010, 23:14
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0201_JPEGInterchangeFormat
 */
public class IFD_0202_JPEGInterchangeFormatLength extends IFD_LONG_COUNT1 {

    public IFD_0202_JPEGInterchangeFormatLength(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * The length in bytes of the <code>JPEG</code> interchange format bit stream.
     * 
     * @return the length
     */
    public long getBitstreamLength(){
        return super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_LONG(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0202_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0211_YCbCrCoefficients.java`:

```java
/*
 * IFD_0211_YCbCrCoefficients.java    Oct 30, 2010, 17:39
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0211_YCbCrCoefficients extends IFD_RATIONAL {

    public static final int COUNT = 3;

    public IFD_0211_YCbCrCoefficients(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0211_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0213_YCbCrPositioning.java`:

```java
/*
 * IFD_0213_YCbCrPositioning.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_0213_YCbCrPositioning extends IFD_SHORT_COUNT1 {

    public IFD_0213_YCbCrPositioning(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {

        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    public int getYCbCrPositioning() {
        return super.getValue();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_0213_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_0214_ReferenceBlackWhite.java`:

```java
/*
 * IFD_0214_ReferenceBlackWhite.java    Oct 04, 2010, 11:08
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0213_YCbCrPositioning
 * @see org.binaryinternals.format.jpeg.ps.PhotoshopImageResource
 */
public class IFD_0214_ReferenceBlackWhite extends IFD_RATIONAL {

    public static final int COUNT = 6;

    public IFD_0214_ReferenceBlackWhite(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_0214_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_829A_ExposureTime.java`:

```java
/*
 * IFD_829A_ExposureTime.java    Oct 04, 2010, 14:29
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_829A_ExposureTime extends IFD_RATIONAL_COUNT1 {

    private final static String IFD_Description = IFDMessage.getString(IFDMessage.KEY_IFD_829A_Description)
            + IFD_8769_Exif.CATEGORY_G;

    public IFD_829A_ExposureTime(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(parentNode, IFD_Description);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_829D_FNumber.java`:

```java
/*
 * IFD_829D_FNumber.java    Oct 11, 2010, 22:43
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_829D_FNumber extends IFD_RATIONAL_COUNT1 {

    private final static String IFD_Description = IFDMessage.getString(IFDMessage.KEY_IFD_829D_Description)
            + IFD_8769_Exif.CATEGORY_G;

    public IFD_829D_FNumber(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(parentNode, IFD_Description);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_8769_Exif.java`:

```java
/*
 * IFD_8769_Exif.java    Sep 12, 2010, 22:40
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_8769_Exif extends IFD_LONG_Pointer {

    public static final String CATEGORY_A = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_A);
    public static final String CATEGORY_B = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_B);
    public static final String CATEGORY_C = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_C);
    public static final String CATEGORY_D = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_D);
    public static final String CATEGORY_E = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_E);
    public static final String CATEGORY_F = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F);
    public static final String CATEGORY_G = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G);

    public IFD_8769_Exif(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);

        // Sub IFD
        final PosDataInputStream reader = new PosDataInputStream(
                new PosByteArrayInputStream(this.tiff_ByteArray),
                super.tiff_StartPos);
        BytesTool.skip(reader, this.getExifOffset() + 2);
        if (this.ifd_number > 0) {
            for (int i = 0; i < this.ifd_number; i++) {
                this.ifd_sub[i] = IFDParse.parse(reader, byteOrder, startPosTiff, byteArrayTiff);
            }
        }
        // Next IFD
        super.next = IFDParse.readInt(reader, byteOrder);
    }

    public final long getExifOffset() {
        return super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        // Offset
        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format("Exif Offset: %d", this.getExifOffset()));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        DefaultMutableTreeNode node;
        DefaultMutableTreeNode node_subifd;

        // Sub IFD
        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2 + this.ifd_number * IFD.SIZE,
                "Exif Sub IFD",
                Icons.Shortcut, null);
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
        node = new DefaultMutableTreeNode(comp);
        parentNode.add(node);

        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2,
                String.format("IFD number: %d", this.ifd_number));
        comp.setDescription(TIFF.IFD_Number_Description);
        node.add(new DefaultMutableTreeNode(comp));

        if (this.ifd_sub == null) {
            return;
        }

        // Sub IFD[]
        for (int i = 0; i < this.ifd_sub.length; i++) {
            comp = new JTreeNodeFileComponent(
                    this.ifd_sub[i].getStartPos(),
                    IFD.SIZE,
                    String.format("Sub IFD[%d] - %s", i, this.ifd_sub[i].getTagName()));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
            node_subifd = new DefaultMutableTreeNode(comp);
            node.add(node_subifd);
            if (this.ifd_sub[i] != null) {
                this.ifd_sub[i].generateTreeNode(node_subifd);
            }
        }

        // Next IFD
        super.generateTreeNode_NextIFD(node);
    }
    /**
     * @see IFD_9000_ExifVersion
     * @see IFD_A000_FlashpixVersion
     */
    public static final String FormatVersion = IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_FormatVersion);  // Section 4.2

    /**
     * @see IFD_9000_ExifVersion
     * @see IFD_A000_FlashpixVersion
     */
    static String getVersion(byte[] value) {
        final StringBuffer sb = new StringBuffer(5);
        sb.append((char) value[0]);  // byte A1
        sb.append((char) value[1]);  // byte A2
        sb.append('.');
        sb.append((char) value[2]);  // byte B1
        sb.append((char) value[3]);  // byte B2

        return sb.toString();
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_8822_ExposureProgram.java`:

```java
/*
 * IFD_8822_ExposureProgram.java    Oct 11, 2010, 23:17
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_8822_ExposureProgram extends IFD_SHORT_COUNT1 {

    private final static String IFD_Description = IFDMessage.getString(IFDMessage.KEY_IFD_8822_Description)
            + IFD_8769_Exif.CATEGORY_G;

    public IFD_8822_ExposureProgram(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(parentNode, IFD_Description);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_8825_GPS.java`:

```java
/*
 * IFD_8825_GPS.java    Oct 01, 2010, 10:10
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_8825_GPS extends IFD_LONG_Pointer {

    public static final String Category_A = IFDMessage.getString(IFDMessage.KEY_IFD_8825_GPS_Category_A);

    public IFD_8825_GPS(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        // Sub IFD
        final PosDataInputStream reader = new PosDataInputStream(
                new PosByteArrayInputStream(this.tiff_ByteArray),
                super.tiff_StartPos
                );
        BytesTool.skip(reader, this.getGPSOffset() + 2);
        if (this.ifd_number > 0) {
            for (int i = 0; i < this.ifd_number; i++) {
                this.ifd_sub[i] = IFDParse.parseGPS(reader, byteOrder, startPosTiff, byteArrayTiff);
                this.ifd_sub[i].setTagSpace(TagSpace.GPS);
            }
        }
        // Next IFD
        super.next = IFDParse.readInt(reader, byteOrder);
    }

    public final long getGPSOffset() {
        return super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format("GPS Offset: %d", super.value[0]));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        DefaultMutableTreeNode node;
        DefaultMutableTreeNode node_subifd;

        // Sub IFD

        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2 + this.ifd_number * IFD.SIZE,
                "GPS Sub IFD",
                Icons.Shortcut, null);
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
        node = new DefaultMutableTreeNode(comp);
        parentNode.add(node);

        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2,
                String.format("IFD number: %d", this.ifd_number));
        comp.setDescription(TIFF.IFD_Number_Description);
        node.add(new DefaultMutableTreeNode(comp));

        if (this.ifd_sub == null) {
            return;
        }

        // Sub IFD[]
        for (int i = 0; i < this.ifd_sub.length; i++) {
            comp = new JTreeNodeFileComponent(
                    this.ifd_sub[i].getStartPos(),
                    IFD.SIZE,
                    String.format("Sub IFD[%d] - %s", i, this.ifd_sub[i].getTagName()));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
            node_subifd = new DefaultMutableTreeNode(comp);
            node.add(node_subifd);
            if (this.ifd_sub[i] != null) {
                this.ifd_sub[i].generateTreeNode(node_subifd);
            }
        }

        // Next IFD
        super.generateTreeNode_NextIFD(node);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_8827_PhotographicSensitivity.java`:

```java
/*
 * IFD_0132_DateTime.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_8827_PhotographicSensitivity extends IFD_SHORT_COUNT1 {

    public IFD_8827_PhotographicSensitivity(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_8827_Description));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9000_ExifVersion.java`:

```java
/*
 * IFD_9000_ExifVersion.java    Oct 16, 2010, 16:24
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_A
 * @see IFD_8769_Exif#FormatVersion
 */
public class IFD_9000_ExifVersion extends IFD_UNDEFINED {

    public static final int COUNT = 4;

    public IFD_9000_ExifVersion(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public String getExifVersion() {
        return IFD_8769_Exif.getVersion(super.value);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %s", this.getTagName(), this.getExifVersion()),
                IFDMessage.getString(IFDMessage.KEY_IFD_9000_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_A)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_FormatVersion));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9003_DateTimeOriginal.java`:

```java
/*
 * IFD_9003_DateTimeOriginal.java    Oct 16, 2010, 10:45
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import java.util.Calendar;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_F
 */
public class IFD_9003_DateTimeOriginal extends IFD_ASCII {

    public static final int COUNT = 20;
    public final Calendar datetime;

    public IFD_9003_DateTimeOriginal(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);

        final PosDataInputStream reader = super.getTiffOffsetReader();
        final byte[] buf = new byte[IFD_9003_DateTimeOriginal.COUNT];
        reader.readFully(buf, 0, IFD_9003_DateTimeOriginal.COUNT);
        this.datetime = IFD_0132_DateTime.buf2calendar(buf);
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%04d:%02d:%02d %02d:%02d:%02d",
                this.datetime.get(Calendar.YEAR),
                this.datetime.get(Calendar.MONTH),
                this.datetime.get(Calendar.DATE),
                this.datetime.get(Calendar.HOUR_OF_DAY),
                this.datetime.get(Calendar.MINUTE),
                this.datetime.get(Calendar.SECOND)),
                IFDMessage.getString(IFDMessage.KEY_IFD_9003_Description) + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9004_DateTimeDigitized.java`:

```java
/*
 * IFD_9004_DateTimeDigitized.java    Oct 16, 2010, 14:59
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import java.util.Calendar;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_F
 */
public class IFD_9004_DateTimeDigitized extends IFD_ASCII {

    public static final int COUNT = 20;
    public final Calendar datetime;

    public IFD_9004_DateTimeDigitized(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);

        final PosDataInputStream reader = super.getTiffOffsetReader();
        final byte[] buf = new byte[IFD_9004_DateTimeDigitized.COUNT];
        reader.readFully(buf, 0, IFD_9004_DateTimeDigitized.COUNT);
        this.datetime = IFD_0132_DateTime.buf2calendar(buf);
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%04d:%02d:%02d %02d:%02d:%02d",
                this.datetime.get(Calendar.YEAR),
                this.datetime.get(Calendar.MONTH),
                this.datetime.get(Calendar.DATE),
                this.datetime.get(Calendar.HOUR_OF_DAY),
                this.datetime.get(Calendar.MINUTE),
                this.datetime.get(Calendar.SECOND)),
                IFDMessage.getString(IFDMessage.KEY_IFD_9004_Description) + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9101_ComponentsConfiguration.java`:

```java
/*
 * IFD_9101_ComponentsConfiguration.java    Oct 16, 2010, 15:22
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0106_PhotometricInterpretation
 * @see IFD_8769_Exif#CATEGORY_C
 */
public class IFD_9101_ComponentsConfiguration extends IFD_UNDEFINED {

    public static final int COUNT = 4;

    public IFD_9101_ComponentsConfiguration(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public String getValue(){
        final StringBuffer sb = new StringBuffer(20);
        sb.append(super.value[0]);
        sb.append(' ');
        sb.append(super.value[1]);
        sb.append(' ');
        sb.append(super.value[2]);
        sb.append(' ');
        sb.append(super.value[3]);

        return sb.toString();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %s", this.getTagName(), this.getValue()),
                IFDMessage.getString(IFDMessage.KEY_IFD_9101_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_C));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9102_CompressedBitsPerPixel.java`:

```java
/*
 * IFD_9102_CompressedBitsPerPixel.java    Oct 30, 2010, 20:22
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_C
 */
public class IFD_9102_CompressedBitsPerPixel extends IFD_RATIONAL_COUNT1 {

    public IFD_9102_CompressedBitsPerPixel(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9102_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_C));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9201_ShutterSpeedValue.java`:

```java
/*
 * IFD_9201_ShutterSpeedValue.java    Oct 30, 2010, 15:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9201_ShutterSpeedValue extends IFD_SRATIONAL_COUNT1 {

    public IFD_9201_ShutterSpeedValue(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SRATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9201_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9202_ApertureValue.java`:

```java
/*
 * IFD_9202_ApertureValue.java    Oct 30, 2010, 15:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9202_ApertureValue extends IFD_RATIONAL_COUNT1 {

    public IFD_9202_ApertureValue(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9202_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9204_ExposureBiasValue.java`:

```java
/*
 * IFD_9204_ExposureBiasValue.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9204_ExposureBiasValue extends IFD_SRATIONAL_COUNT1 {

    public IFD_9204_ExposureBiasValue(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SRATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9204_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9205_MaxApertureValue.java`:

```java
/*
 * IFD_9205_MaxApertureValue.java    Oct 26, 2010, 13:28
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9205_MaxApertureValue extends IFD_RATIONAL_COUNT1 {

    public IFD_9205_MaxApertureValue(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9205_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G)
                );
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9207_MeteringMode.java`:

```java
/*
 * IFD_0132_DateTime.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9207_MeteringMode extends IFD_SHORT_COUNT1 {

    public IFD_9207_MeteringMode(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9207_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9208_LightSource.java`:

```java
/*
 * IFD_0132_DateTime.java    Sep 11, 2010, 23:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9208_LightSource extends IFD_SHORT_COUNT1 {

    public IFD_9208_LightSource(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_9208_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9209_Flash.java`:

```java
/*
 * IFD_9209_Flash.java    Oct 26, 2010, 19:11
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_9209_Flash extends IFD_SHORT_COUNT1 {

    public final int FlashFired;
    public final int FlashReturn;
    public final int FlashMode;
    public final int FlashFunction;
    public final int RedeyeMode;

    public IFD_9209_Flash(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        this.FlashFired = this.value[0] & 0x00000001;
        this.FlashReturn = (this.value[0] >> 1) & 0x000000003;
        this.FlashMode = (this.value[0] >> 3) & 0x000000003;
        this.FlashFunction = (this.value[0] >> 5) & 0x000000001;
        this.RedeyeMode = (this.value[0] >> 6) & 0x000000001;
    }

    public String getValueBinaryString(){
        StringBuilder sb = new StringBuilder(8);
        sb.append(Integer.toBinaryString(this.value[0]));
        while(sb.length() < 7){
            sb.insert(0, '0');
        }

        return sb.toString();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {

        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                2,
                String.format("%s: %s", super.getTagName(), this.getValueBinaryString()));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_9209_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 9,
                1,
                String.format("Flash fired: %d", this.FlashFired))));
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 9,
                1,
                String.format("Flash return: %d", this.FlashReturn))));
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 9,
                1,
                String.format("Flash mode: %d", this.FlashMode))));
        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 9,
                1,
                String.format("Flash function: %d", this.FlashFunction))));

        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos + 10,
                2,
                "Unused")));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_920A_FocalLength.java`:

```java
/*
 * IFD_920A_FocalLength.java    Oct 27, 2010, 00:08
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_920A_FocalLength extends IFD_RATIONAL_COUNT1 {

    public IFD_920A_FocalLength(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_920A_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G)
                );
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_927C_MakerNode.java`:

```java
/*
 * IFD_927C_MakerNode.java    Oct 27, 2010, 00:15
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_D
 */
public class IFD_927C_MakerNode extends IFD_UNDEFINED {

    public IFD_927C_MakerNode(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                this.getTagName(),
                IFDMessage.getString(IFDMessage.KEY_IFD_927C_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_D));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9286_UserComment.java`:

```java
/*
 * IFD_9286_UserComment.java    Oct 27, 2010, 09:19
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see IFD_010E_ImageDescription
 * @see IFD_8769_Exif#CATEGORY_D
 */
public class IFD_9286_UserComment extends IFD_UNDEFINED {

    public final String CharacterCode;

    public IFD_9286_UserComment(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        if (super.value.length >= 8) {
            StringBuilder sb = new StringBuilder(8);
            for (int i = 0; i < 8; i++) {
                if (super.value[i] == 0) {
                    break;
                }
                sb.append((char)super.value[i]);
            }
            this.CharacterCode = sb.toString();
        } else {
            this.CharacterCode = null;
        }
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + super.ifd_value_offset,
                super.data_size,
                this.getTagName(),
                Icons.Shortcut, null);
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_9286_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_D));
        parentNode.add(node = new DefaultMutableTreeNode(comp));

        node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.tiff_StartPos + super.ifd_value_offset,
                8,
                String.format("Character Code: %s", this.CharacterCode))));
        if (super.data_size - 8 > 0) {
            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + 8,
                    super.data_size - 8,
                    this.getTagName())));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9290_SubsecTime.java`:

```java
/*
 * IFD_9290_SubsecTime.java    Oct 27, 2010, 22:02
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_0132_DateTime
 * @see IFD_8769_Exif#CATEGORY_F
 * @see IFD_9291_SubsecTimeOriginal
 * @see IFD_9292_SubsecTimeDigitized
 */
public class IFD_9290_SubsecTime extends IFD_ASCII {

    public IFD_9290_SubsecTime(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%s: %s", super.getTagName(), this.value),
                IFDMessage.getString(IFDMessage.KEY_IFD_9290_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9291_SubsecTimeOriginal.java`:

```java
/*
 * IFD_9291_SubsecTimeOriginal.java    Oct 27, 2010, 22:03
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_9003_DateTimeOriginal
 * @see IFD_8769_Exif#CATEGORY_F
 * @see IFD_9290_SubsecTime
 * @see IFD_9292_SubsecTimeDigitized
 */
public class IFD_9291_SubsecTimeOriginal extends IFD_ASCII {

    public IFD_9291_SubsecTimeOriginal(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%s: %s", super.getTagName(), this.value),
                IFDMessage.getString(IFDMessage.KEY_IFD_9291_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_9292_SubsecTimeDigitized.java`:

```java
/*
 * IFD_9292_SubsecTimeDigitized.java    Oct 27, 2010, 22:04
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_9004_DateTimeDigitized
 * @see IFD_8769_Exif#CATEGORY_F
 * @see IFD_9290_SubsecTime
 * @see IFD_9291_SubsecTimeOriginal
 */
public class IFD_9292_SubsecTimeDigitized extends IFD_ASCII {

    public IFD_9292_SubsecTimeDigitized(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_ASCII(
                parentNode,
                String.format("%s: %s", super.getTagName(), this.value),
                IFDMessage.getString(IFDMessage.KEY_IFD_9292_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_F));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A000_FlashpixVersion.java`:

```java
/*
 * IFD_A000_FlashpixVersion.java    Oct 28, 2010, 12:09
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_9000_ExifVersion
 * @see IFD_8769_Exif#CATEGORY_A
 * @see IFD_8769_Exif#FormatVersion
 */
public class IFD_A000_FlashpixVersion extends IFD_UNDEFINED {

    public static final int COUNT = 4;

    public IFD_A000_FlashpixVersion(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public String getFlashpixVersion() {
        return IFD_8769_Exif.getVersion(super.value);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %s", this.getTagName(), this.getFlashpixVersion()),
                IFDMessage.getString(IFDMessage.KEY_IFD_A000_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_A)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_FormatVersion));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A001_ColorSpace.java`:

```java
/*
 * IFD_A001_ColorSpace.java    Oct 28, 2010, 12:26
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_B
 */
public class IFD_A001_ColorSpace extends IFD_SHORT_COUNT1 {

    public IFD_A001_ColorSpace(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A001_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_B));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A002_PixelXDimension.java`:

```java
/*
 * IFD_A002_PixelXDimension.java    Oct 28, 2010, 13:00
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_SHORT
 * @see IFD_LONG
 * @see IFD_8769_Exif#CATEGORY_C
 */
public class IFD_A002_PixelXDimension extends IFD_LONG_COUNT1 {

    public IFD_A002_PixelXDimension(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_LONG(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A002_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_C));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A003_PixelYDimension.java`:

```java
/*
 * IFD_A003_PixelYDimension.java    Oct 28, 2010, 13:06
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_SHORT
 * @see IFD_LONG
 * @see IFD_8769_Exif#CATEGORY_C
 */
public class IFD_A003_PixelYDimension extends IFD_LONG_COUNT1 {

    public IFD_A003_PixelYDimension(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_LONG(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A003_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_C));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A005_Interoperability.java`:

```java
/*
 * IFD_A005_Interoperability.java    Oct 01, 2010, 10:17
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_A005_Interoperability extends IFD_LONG_Pointer {

    public static final String Category_A = IFDMessage.getString(IFDMessage.KEY_IFD_A005_Intero_Category_A);

    public IFD_A005_Interoperability(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        // Sub IFD
        final PosDataInputStream reader = new PosDataInputStream(
                new PosByteArrayInputStream(this.tiff_ByteArray),
                super.tiff_StartPos);
        BytesTool.skip(reader, this.getInteroperabilityOffset() + 2);
        if (this.ifd_number > 0) {
            for (int i = 0; i < this.ifd_number; i++) {
                this.ifd_sub[i] = IFDParse.parseIntero(reader, byteOrder, startPosTiff, byteArrayTiff);
                this.ifd_sub[i].setTagSpace(TagSpace.INTERO);
            }
        }
        // Next IFD
        super.next = IFDParse.readInt(reader, byteOrder);
    }

    public final long getInteroperabilityOffset() {
        return super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format("Interoperability Offset: %d", super.value[0]));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        DefaultMutableTreeNode node;
        DefaultMutableTreeNode node_subifd;

        // Sub IFD
        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2 + this.ifd_number * IFD.SIZE,
                "Interoperability Sub IFD",
                Icons.Shortcut, null);
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
        node = new DefaultMutableTreeNode(comp);
        parentNode.add(node);

        comp = new JTreeNodeFileComponent(
                super.tiff_StartPos + (int) this.value[0],
                2,
                String.format("IFD number: %d", this.ifd_number));
        comp.setDescription(TIFF.IFD_Number_Description);
        node.add(new DefaultMutableTreeNode(comp));

        if (this.ifd_sub == null) {
            return;
        }

        // Sub IFD[]
        for (int i = 0; i < this.ifd_sub.length; i++) {
            comp = new JTreeNodeFileComponent(
                    this.ifd_sub[i].getStartPos(),
                    IFD.SIZE,
                    String.format("Sub IFD[%d] - %s", i, this.ifd_sub[i].getTagName()));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD));
            node_subifd = new DefaultMutableTreeNode(comp);
            node.add(node_subifd);
            if (this.ifd_sub[i] != null) {
                this.ifd_sub[i].generateTreeNode(node_subifd);
            }
        }

        // Next IFD
        super.generateTreeNode_NextIFD(node);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A20E_FocalPlaneXResolution.java`:

```java
/*
 * IFD_A20E_FocalPlaneXResolution.java    Oct 30, 2010, 18:12
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_A210_FocalPlaneResolutionUnit
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A20E_FocalPlaneXResolution extends IFD_RATIONAL_COUNT1 {

    public IFD_A20E_FocalPlaneXResolution(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A20E_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G)
                );
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A20F_FocalPlaneYResolution.java`:

```java
/*
 * IFD_A20F_FocalPlaneYResolution.java    Oct 30, 2010, 18:12
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_A210_FocalPlaneResolutionUnit
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A20F_FocalPlaneYResolution extends IFD_RATIONAL_COUNT1 {

    public IFD_A20F_FocalPlaneYResolution(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A20F_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G)
                );
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A210_FocalPlaneResolutionUnit.java`:

```java
/*
 * IFD_A210_FocalPlaneResolutionUnit.java    Oct 30, 2010, 18:12
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_A20E_FocalPlaneXResolution
 * @see IFD_A20F_FocalPlaneYResolution
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A210_FocalPlaneResolutionUnit extends IFD_SHORT_COUNT1 {

    public IFD_A210_FocalPlaneResolutionUnit(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A210_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G)
                );
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A215_ExposureIndex.java`:

```java
/*
 * IFD_A217_SensingMethod.java    Oct 28, 2010, 13:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A215_ExposureIndex extends IFD_RATIONAL_COUNT1 {

    public IFD_A215_ExposureIndex(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A215_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A217_SensingMethod.java`:

```java
/*
 * IFD_A217_SensingMethod.java    Oct 28, 2010, 13:16
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A217_SensingMethod extends IFD_SHORT_COUNT1 {

    public IFD_A217_SensingMethod(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A217_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A300_FileSource.java`:

```java
/*
 * IFD_A300_FileSource.java    Oct 28, 2010, 13:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A300_FileSource extends IFD_UNDEFINED {

    public static final int COUNT = 1;

    public IFD_A300_FileSource(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public int getFileSource(){
        return (int)super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %d", this.getTagName(), this.getFileSource()),
                IFDMessage.getString(IFDMessage.KEY_IFD_A300_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A301_SceneType.java`:

```java
/*
 * IFD_A301_SceneType.java    Oct 28, 2010, 13:42
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A301_SceneType extends IFD_UNDEFINED {

    public static final int COUNT = 1;

    public IFD_A301_SceneType(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public int getSceneType(){
        return (int)super.value[0];
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_UNDEFINED(
                parentNode,
                String.format("%s: %d", this.getTagName(), this.getSceneType()),
                IFDMessage.getString(IFDMessage.KEY_IFD_A301_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A302_CFAPattern.java`:

```java
/*
 * IFD_A302_CFAPattern.java    Oct 28, 2010, 19:03
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A302_CFAPattern extends IFD_UNDEFINED {

    static final String[] FILTER_COLORS = {"RED", "GREEN", "BLUE", "CYAN", "MAGENTA", "YELLOW", "WHITE"};
    /** Horizontal repeat pixel unit. */
    public final int n;
    /** Vertical repeat pixel unit. */
    public final int m;

    public IFD_A302_CFAPattern(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        final PosDataInputStream reader = new PosDataInputStream(new PosByteArrayInputStream(super.value));
        n = reader.readUnsignedShort();
        m = reader.readUnsignedShort();
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;
        String description = IFDMessage.getString(IFDMessage.KEY_IFD_A302_Description)
                    + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_G);

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    super.getTagName());
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));

        } else {
            // Offset
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    super.getTagName(),
                    Icons.Shortcut, null);
            comp.setDescription(description);
            parentNode.add(node = new DefaultMutableTreeNode(comp));

            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    2,
                    String.format("Horizontal repeat pixel unit = %d", this.n))));
            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + 2,
                    2,
                    String.format("Vertical repeat pixel unit = %d", this.m))));

            int cfa;
            for (int i = 0; i < this.ifd_count - 4; i++) {
                cfa = (int) super.value[4 + i];
                node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        super.tiff_StartPos + super.ifd_value_offset + 4 + i,
                        1,
                        String.format("CFA value: %d - %s", cfa, FILTER_COLORS[cfa]))));
            }
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A401_CustomRendered.java`:

```java
/*
 * IFD_A401_CustomRendered.java    Oct 28, 2010, 22:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A401_CustomRendered extends IFD_SHORT_COUNT1 {

    public IFD_A401_CustomRendered(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A401_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A402_ExposureMode.java`:

```java
/*
 * IFD_A402_ExposureMode.java    Oct 28, 2010, 22:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A402_ExposureMode extends IFD_SHORT_COUNT1 {

    public IFD_A402_ExposureMode(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A402_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A403_WhiteBalance.java`:

```java
/*
 * IFD_A403_WhiteBalance.java    Oct 28, 2010, 22:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A403_WhiteBalance extends IFD_SHORT_COUNT1 {

    public IFD_A403_WhiteBalance(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A403_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A404_DigitalZoomRatio.java`:

```java
/*
 * IFD_A404_DigitalZoomRatio.java    Oct 28, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A404_DigitalZoomRatio extends IFD_RATIONAL_COUNT1 {

    public IFD_A404_DigitalZoomRatio(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A404_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A405_FocalLengthIn35mmFilm.java`:

```java
/*
 * IFD_A405_FocalLengthIn35mmFilm.java    Oct 28, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 * @see IFD_920A_FocalLength
 */
public class IFD_A405_FocalLengthIn35mmFilm extends IFD_SHORT_COUNT1 {

    public IFD_A405_FocalLengthIn35mmFilm(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A405_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A406_SceneCaptureType.java`:

```java
/*
 * IFD_A406_SceneCaptureType.java    Oct 28, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 * @see IFD_A301_SceneType
 */
public class IFD_A406_SceneCaptureType extends IFD_SHORT_COUNT1 {

    public IFD_A406_SceneCaptureType(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A406_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A407_GainControl.java`:

```java
/*
 * IFD_A407_GainControl.java    Oct 28, 2010, 23:30
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A407_GainControl extends IFD_SHORT_COUNT1 {

    public IFD_A407_GainControl(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A407_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A408_Contrast.java`:

```java
/*
 * IFD_A408_Contrast.java    Oct 28, 2010, 23:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A408_Contrast extends IFD_SHORT_COUNT1 {

    public IFD_A408_Contrast(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A408_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A409_Saturation.java`:

```java
/*
 * IFD_A409_Saturation.java    Oct 28, 2010, 23:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A409_Saturation extends IFD_SHORT_COUNT1 {

    public IFD_A409_Saturation(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A409_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A40A_Sharpness.java`:

```java
/*
 * IFD_A40A_Sharpness.java    Oct 28, 2010, 23:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A40A_Sharpness extends IFD_SHORT_COUNT1 {

    public IFD_A40A_Sharpness(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A40A_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A40C_SubjectDistanceRange.java`:

```java
/*
 * IFD_A40C_SubjectDistanceRange.java    Oct 28, 2010, 23:31
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_A40C_SubjectDistanceRange extends IFD_SHORT_COUNT1 {

    public IFD_A40C_SubjectDistanceRange(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_SHORT(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A40C_Description)
                + IFD_8769_Exif.CATEGORY_G);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_A500_Gamma.java`:

```java
/*
 * IFD_A500_Gamma.java    Oct 30, 2010, 18:13
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_B
 */
public class IFD_A500_Gamma extends IFD_RATIONAL_COUNT1 {

    public IFD_A500_Gamma(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        super.generateTreeNode_RATIONAL(
                parentNode,
                IFDMessage.getString(IFDMessage.KEY_IFD_A500_Description)
                + IFDMessage.getString(IFDMessage.KEY_IFD_8769_Exif_Category_B));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_ASCII.java`:

```java
/*
 * IFD_ASCII.java    Sep 09, 2010, 12:44
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_ASCII extends IFD {

    public final String value;

    public IFD_ASCII(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);

        if (super.isValue()) {
            final StringBuffer sb = new StringBuffer(5);
            sb.append((char) pDIS.readByte());  // byte 1
            sb.append((char) pDIS.readByte());  // byte 2
            sb.append((char) pDIS.readByte());  // byte 3
            sb.append((char) pDIS.readByte());  // byte 4
            this.value = sb.toString();
        } else {
            super.ifd_value_offset = super.readInt(pDIS);                           // Offset

            final PosDataInputStream reader = super.getTiffOffsetReader();
            final StringBuffer sb = new StringBuffer(super.ifd_count + 2);
            for (int i = 0; i < super.ifd_count; i++) {
                sb.append((char) reader.readByte());
            }
            this.value = sb.toString();
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.isValue()) {
            this.generateTreeNode_ASCII(
                    parentNode,
                    String.format("%s: %s", super.getTagName(), this.value),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value));
        } else {
            this.generateTreeNode_ASCII(
                    parentNode,
                    String.format("%s: %s", super.getTagName(), this.value),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
        }
    }

    void generateTreeNode_ASCII(DefaultMutableTreeNode parentNode, String node, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    node);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    node,
                    Icons.Shortcut, null);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_BYTE.java`:

```java
/*
 * IFD_BYTE.java    Sep 09, 2010, 12:44
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_BYTE extends IFD {

    public final byte[] value;

    public IFD_BYTE(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);

        if (super.isValue()) {
            this.value = new byte[4];
            this.value[0] = pDIS.readByte();
            this.value[1] = pDIS.readByte();
            this.value[2] = pDIS.readByte();
            this.value[3] = pDIS.readByte();
        } else {
            super.ifd_value_offset = super.readInt(pDIS);                           // Offset

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new byte[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                this.value[i] = reader.readByte();
            }
        }

    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.isValue()) {
            this.generateTreeNode_BYTE(
                    parentNode,
                    String.format("%s: %s", super.getTagName(), this.value),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value));
        } else {
            this.generateTreeNode_BYTE(
                    parentNode,
                    String.format("%s: %s", super.getTagName(), this.value),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
        }
    }

    // The same as ASCII
    void generateTreeNode_BYTE(DefaultMutableTreeNode parentNode, String node, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    node);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    node,
                    Icons.Shortcut, null);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }

}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_DOUBLE.java`:

```java
/*
 * IFD_DOUBLE.java    Sep 09, 2010, 12:50
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_DOUBLE extends IFD {

    public IFD_DOUBLE(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_FLOAT.java`:

```java
/*
 * IFD_FLOAT.java    Sep 09, 2010, 12:50
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_FLOAT extends IFD {

    public IFD_FLOAT(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_LONG.java`:

```java
/*
 * IFD_LONG.java    Sep 09, 2010, 12:46
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_LONG extends IFD {

    public final long[] value;

    public IFD_LONG(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.LONG, startPosTiff, byteArrayTiff);

        if (super.isValue()) {
            this.value = new long[1];
            this.value[0] = super.readUnsignedInt(pDIS);
        } else {
            super.ifd_value_offset = super.readInt(pDIS);                           // Offset

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new long[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                this.value[i] = super.readUnsignedInt(reader);
            }
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.isValue()) {
            this.generateTreeNode_LONG(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_Value));
        }else{
            this.generateTreeNode_LONG(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
        }
    }

    public void generateTreeNode_LONG(DefaultMutableTreeNode parentNode, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format("%s: %d", super.getTagName(), this.value[0]));
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    super.getTagName(),
                    Icons.Shortcut, null);
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_LONG_COUNT1.java`:

```java
/*
 * IFD_LONG_COUNT1.java    Oct 28, 2010, 12:43
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
class IFD_LONG_COUNT1 extends IFD_LONG {

    public static final int COUNT = 1;

    IFD_LONG_COUNT1(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public long getValue() {
        return super.value[0];
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_LONG_Pointer.java`:

```java
/*
 * IFD_LONG_Pointer.java    Oct 31, 2010, 11:55
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see IFD_8769_Exif#CATEGORY_G
 */
public class IFD_LONG_Pointer extends IFD_LONG_COUNT1 {

    public final int ifd_number;
    public final IFD[] ifd_sub;
    int next;

    public IFD_LONG_Pointer(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);

        // Sub IFD
        final PosDataInputStream reader = new PosDataInputStream(
                new PosByteArrayInputStream(this.tiff_ByteArray),
                super.tiff_StartPos);
        BytesTool.skip(reader, super.value[0]);
        this.ifd_number = super.readUnsignedShort(reader);
        if (this.ifd_number > 0) {
            this.ifd_sub = new IFD[this.ifd_number];
        } else {
            this.ifd_sub = null;
        }
    }

    protected void generateTreeNode_NextIFD(DefaultMutableTreeNode parentNode) {
        if (this.ifd_sub != null) {
            parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    this.ifd_sub[this.ifd_sub.length - 1].getStartPos() + IFD.SIZE,
                    4,
                    String.format("Next IFD: Offset within Tiff = %04X (%d)", this.next, this.next))));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_RATIONAL.java`:

```java
/*
 * IFD_RATIONAL.java    Sep 09, 2010, 12:47
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_RATIONAL extends IFD {

    public final Rational[] value;

    public IFD_RATIONAL(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.RATIONAL, startPosTiff, byteArrayTiff);
        super.ifd_value_offset = super.readInt(pDIS);                               // Offset

        // Read the rational values
        if (super.ifd_count > 0) {
            long n, d;

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new Rational[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                n = super.readUnsignedInt(reader);
                d = super.readUnsignedInt(reader);
                this.value[i] = new Rational(n, d);
            }
        } else {
            this.value = new Rational[1];
            this.value[0] = new Rational(0, 0);
        }
    }

    public Rational[] getValues() {
        return this.value;
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_RATIONAL(parentNode, ShortText.getString(ShortText.KEY_Type_Rational));
    }

    void generateTreeNode_RATIONAL(DefaultMutableTreeNode parentNode, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        if (super.ifd_count <= 0) {
            return;
        }
        for (int i = 0; i < super.ifd_count; i++) {
            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8,
                    8,
                    String.format(ShortText.getString(ShortText.KEY_rational_n), i),
                    Icons.Shortcut, null);
            comp.setDescription(description);
            node = new DefaultMutableTreeNode(comp);
            parentNode.add(node);

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_numerator_n), this.value[0].numerator),
                    Icons.Shortcut, null);
            comp.setDescription(ShortText.getString(ShortText.KEY_Numerator));
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8 + 4,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_denominator_n), this.value[0].denominator),
                    Icons.Shortcut, null);
            comp.setDescription(ShortText.getString(ShortText.KEY_Denominator));
            node.add(new DefaultMutableTreeNode(comp));
        }
    }

    @SuppressWarnings("PublicInnerClass")
    public static class Rational {

        public final long numerator;
        public final long denominator;

        private Rational(long n, long d) {
            this.numerator = n;
            this.denominator = d;
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_RATIONAL_COUNT1.java`:

```java
/*
 * IFD_RATIONAL.java    Oct 16, 2010, 12:49
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_RATIONAL_COUNT1 extends IFD_RATIONAL {

    public static final int COUNT = 1;

    public IFD_RATIONAL_COUNT1(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {

        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue(){
        return false;
    }

    public Rational getValue() {
        return this.value[0];
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SBYTE.java`:

```java
/*
 * IFD_SBYTE.java    Sep 09, 2010, 12:47
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_SBYTE extends IFD {

    public IFD_SBYTE(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SHORT.java`:

```java
/*
 * IFD_SHORT.java    Sep 09, 2010, 12:46
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_SHORT extends IFD {

    public final int[] value;

    public IFD_SHORT(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.SHORT, startPosTiff, byteArrayTiff);

        if (super.isValue()) {
            this.value = new int[2];
            this.value[0] = super.readUnsignedShort(pDIS);
            this.value[1] = super.readUnsignedShort(pDIS);
        } else {
            super.ifd_value_offset = super.readInt(pDIS);                           // Offset

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new int[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                this.value[i] = super.readUnsignedShort(reader);
            }
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.isValue()) {
            this.generateTreeNode_SHORT(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_Value));
        }else{
            this.generateTreeNode_SHORT(parentNode, IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
        }
    }

    void generateTreeNode_SHORT(DefaultMutableTreeNode parentNode, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            switch (super.ifd_count) {
                case 1:
                    comp = new JTreeNodeFileComponent(
                            pos + 8,
                            2,
                            String.format("%s: %d", super.getTagName(), this.value[0]));
                    comp.setDescription(description);
                    parentNode.add(new DefaultMutableTreeNode(comp));

                    parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                            pos + 10,
                            2,
                            ShortText.getString(ShortText.KEY_Unused))));
                    break;
                case 2:
                    comp = new JTreeNodeFileComponent(
                            pos + 8,
                            2,
                            String.format("%s[0]: %d", super.getTagName(), this.value[0]));
                    comp.setDescription(description);
                    parentNode.add(new DefaultMutableTreeNode(comp));

                    comp = new JTreeNodeFileComponent(
                            pos + 10,
                            2,
                            String.format("%s[1]: %d", super.getTagName(), this.value[1]));
                    comp.setDescription(description);
                    parentNode.add(new DefaultMutableTreeNode(comp));
                    break;
                default:
                    // Do nothing
                    break;
            }
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    super.getTagName(),
                    Icons.Shortcut, null);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SHORT_COUNT1.java`:

```java
/*
 * IFD_SHORT_COUNT1.java    Oct 15, 2010, 23:01
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
class IFD_SHORT_COUNT1 extends IFD_SHORT {

    public static final int COUNT = 1;

    IFD_SHORT_COUNT1(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {

        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue() {
        return true;
    }

    public int getValue() {
        return super.value[0];
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SLONG.java`:

```java
/*
 * IFD_SLONG.java    Sep 09, 2010, 12:49
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_SLONG extends IFD {

    public IFD_SLONG(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SRATIONAL.java`:

```java
/*
 * IFD_SRATIONAL.java    Sep 09, 2010, 12:49
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_SRATIONAL extends IFD {

    public final SRational[] value;

    public IFD_SRATIONAL(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.SRATIONAL, startPosTiff, byteArrayTiff);
        super.ifd_value_offset = super.readInt(pDIS);                               // Offset

        // Read the rational values
        if (super.ifd_count > 0) {
            int n, d;

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new SRational[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                n = super.readInt(reader);
                d = super.readInt(reader);
                this.value[i] = new SRational(n, d);
            }
        } else {
            this.value = new SRational[1];
            this.value[0] = new SRational(0, 0);
        }
    }

    public SRational[] getValues() {
        return this.value;
    }

    @Override
    public boolean isValue() {
        return false;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        this.generateTreeNode_SRATIONAL(parentNode, ShortText.getString(ShortText.KEY_Type_SRational));
    }

    void generateTreeNode_SRATIONAL(DefaultMutableTreeNode parentNode, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode node;

        comp = new JTreeNodeFileComponent(
                pos + 8,
                4,
                String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
        comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
        parentNode.add(new DefaultMutableTreeNode(comp));

        if (super.ifd_count <= 0) {
            return;
        }
        for (int i = 0; i < super.ifd_count; i++) {
            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8,
                    8,
                    String.format(ShortText.getString(ShortText.KEY_srational_n), i),
                    Icons.Shortcut, null);
            comp.setDescription(description);
            node = new DefaultMutableTreeNode(comp);
            parentNode.add(node);

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_numerator_n), this.value[0].numerator),
                    Icons.Shortcut, null);
            comp.setDescription(ShortText.getString(ShortText.KEY_Numerator));
            node.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset + i * 8 + 4,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_denominator_n), this.value[0].denominator),
                    Icons.Shortcut, null);
            comp.setDescription(ShortText.getString(ShortText.KEY_Denominator));
            node.add(new DefaultMutableTreeNode(comp));
        }
    }

    @SuppressWarnings("PublicInnerClass")
    public static class SRational {

        public final int numerator;
        public final int denominator;

        private SRational(int n, int d) {
            this.numerator = n;
            this.denominator = d;
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SRATIONAL_COUNT1.java`:

```java
/*
 * IFD_SRATIONAL_COUNT1.java    Oct 26, 2010, 12:43
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 */
public class IFD_SRATIONAL_COUNT1 extends IFD_SRATIONAL {

    public static final int COUNT = 1;

    public IFD_SRATIONAL_COUNT1(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {

        super(pDIS, byteOrder, tag, startPosTiff, byteArrayTiff);
        super.checkIFDCount(COUNT);
    }

    @Override
    public boolean isValue(){
        return false;
    }

    public SRational getValue() {
        return this.value[0];
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_SSHORT.java`:

```java
/*
 * IFD_SSHORT.java    Sep 09, 2010, 12:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 */
public class IFD_SSHORT extends IFD {

    public IFD_SSHORT(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff) 
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.ASCII, startPosTiff, byteArrayTiff);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/IFD_UNDEFINED.java`:

```java
/*
 * IFD_UNDEFINED.java    Sep 09, 2010, 12:48
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 */
public class IFD_UNDEFINED extends IFD {

    public final byte[] value;

    public IFD_UNDEFINED(final PosDataInputStream pDIS, int byteOrder, int tag, int startPosTiff, byte[] byteArrayTiff)
            throws IOException, FileFormatException {
        super(pDIS, byteOrder, tag, IFDType.UNDEFINED, startPosTiff, byteArrayTiff);

        if (super.isValue()) {
            this.value = new byte[4];
            this.value[0] = pDIS.readByte();
            this.value[1] = pDIS.readByte();
            this.value[2] = pDIS.readByte();
            this.value[3] = pDIS.readByte();
        } else {
            super.ifd_value_offset = super.readInt(pDIS);                           // Offset

            final PosDataInputStream reader = super.getTiffOffsetReader();
            this.value = new byte[super.ifd_count];
            for (int i = 0; i < super.ifd_count; i++) {
                this.value[i] = reader.readByte();
            }
        }

    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        if (this.isValue()) {
            this.generateTreeNode_UNDEFINED(
                    parentNode,
                    this.getTagName(),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value));
        } else {
            this.generateTreeNode_UNDEFINED(
                    parentNode,
                    this.getTagName(),
                    IFDMessage.getString(IFDMessage.KEY_IFD_Value_Ref));
        }
    }

    void generateTreeNode_UNDEFINED(DefaultMutableTreeNode parentNode, String node, String description) {
        int pos = super.startPos;
        super.generateTreeNode(parentNode, pos);

        JTreeNodeFileComponent comp;

        if (this.isValue()) {
            if (super.ifd_count < 4) {
                comp = new JTreeNodeFileComponent(
                        pos + 8,
                        super.ifd_count,
                        node);
                comp.setDescription(description);
                parentNode.add(new DefaultMutableTreeNode(comp));
                parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        pos + 8 + super.ifd_count,
                        4 - super.ifd_count,
                        ShortText.getString(ShortText.KEY_Unused))));
            } else {
                comp = new JTreeNodeFileComponent(
                        pos + 8,
                        4,
                        node);
                comp.setDescription(description);
                parentNode.add(new DefaultMutableTreeNode(comp));
            }
        } else {
            comp = new JTreeNodeFileComponent(
                    pos + 8,
                    4,
                    String.format(ShortText.getString(ShortText.KEY_Offset_n), super.ifd_value_offset));
            comp.setDescription(IFDMessage.getString(IFDMessage.KEY_IFD_Offset));
            parentNode.add(new DefaultMutableTreeNode(comp));

            comp = new JTreeNodeFileComponent(
                    super.tiff_StartPos + super.ifd_value_offset,
                    super.data_size,
                    node,
                    Icons.Shortcut, null);
            comp.setDescription(description);
            parentNode.add(new DefaultMutableTreeNode(comp));
        }
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/RefItem.java`:

```java
/*
 * RefItem.java    Oct 30, 2010, 23:13
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import org.binaryinternals.format.jpeg.tiff.IFD.TagSpace;



```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/ShortText.java`:

```java
/*
 * ShortText.java    Oct 26, 2010, 12:14
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.util.ResourceBundle;

/**
 *
 * @author Amos shi
 */
public class ShortText{

    private static final ResourceBundle res;

    static{
        res = ResourceBundle.getBundle(ShortText.class.getName().replace('.', '/'));
    }

    public static final String KEY_Offset_n = "Offset_n";

    public static final String KEY_Type_Rational = "Type_Rational";
    public static final String KEY_Type_SRational = "Type_SRational";

    public static final String KEY_rational_n = "rational_n";
    public static final String KEY_srational_n = "srational_n";
    public static final String KEY_Numerator = "Numerator";
    public static final String KEY_numerator_n = "numerator_n";
    public static final String KEY_Denominator = "Denominator";
    public static final String KEY_denominator_n = "denominator_n";
    public static final String KEY_Unused = "Unused";

    public static String getString(String key){
        return res.getString(key);
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/TIFF.java`:

```java
/*
 * TIFF.java    Nov 06, 2010, 16:55
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentSkipListMap;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;

public class TIFF extends FileComponent implements GenerateTreeNode {

    public static final String IFD_Number_Description = "A 2-byte count of the number of directory entries (i.e., the number of fields)";
    private final byte[] tiffByteArray;
    private final TIFFHeader tiffHeader;
    ArrayList<IFDGroup> exifGroup = new ArrayList<>();

    public TIFF(final PosDataInputStream pDisTiff)
            throws IOException, FileFormatException {

        super.startPos = pDisTiff.getPos();
        super.length = 0; // Not appliable
        this.tiffByteArray = pDisTiff.getBuf();
        this.tiffHeader = new TIFFHeader(pDisTiff);

        IFDGroup group = new IFDGroup(this.tiffByteArray, this.tiffHeader, this.tiffHeader.offset_0ifd);
        this.exifGroup.add(group);
        while (group.next != 0) {
            group = new IFDGroup(this.tiffByteArray, this.tiffHeader, group.next);
            this.exifGroup.add(group);
        }
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;
        DefaultMutableTreeNode nodeTiffHeader;

        // TIFF Header
        comp = new JTreeNodeFileComponent(
                this.startPos,
                TIFFHeader.SIZE,
                "TIFF Header");
        comp.setDescription("A TIFF file begins with an 8-byte image file header that points to an image file directory (IFD).");
        parentNode.add(nodeTiffHeader = new DefaultMutableTreeNode(comp));
        this.tiffHeader.generateTreeNode(nodeTiffHeader);

        // TIFF Data
        ConcurrentSkipListMap<Integer, RefItem> sortedMap = new ConcurrentSkipListMap<>();
        int lastEnd = this.tiffHeader.getStartPos() + TIFFHeader.SIZE;          // Absolute position
        int diff;

        for (IFDGroup group : this.exifGroup) {
            RefItem refItem = new RefItem();
            refItem.offset = group.offset;
            refItem.length = group.length;
            refItem.ifdgroup = group;
            sortedMap.put(refItem.offset, refItem);

            this.loadRefItem(group.ifd, sortedMap);
        }

        for (RefItem ref : sortedMap.values()) {
            diff = (this.startPos + ref.offset) - lastEnd;
            if (diff > 0) {
                generateTreeNodeDiff(parentNode, lastEnd, diff, this.tiffByteArray, this.startPos);
            }

            if (ref.ifdgroup != null) {
                ref.ifdgroup.generateTreeNode(parentNode);
            } else {
                parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        this.tiffHeader.getStartPos() + ref.offset,
                        ref.length,
                        String.format("Reference of tag [%s] %04X.H (%d, %s)",
                                ref.ifd.getTagSpace().toString(),
                                ref.ifd.ifd_tag,
                                ref.ifd.ifd_tag,
                                ref.ifd.getTagName()))));
            }

            lastEnd = this.startPos + ref.offset + ref.length;
        }

        // In case, there is some extra space in the end
        diff = (this.tiffHeader.getStartPos() + this.tiffByteArray.length) - lastEnd;
        if (diff > 0) {
            generateTreeNodeDiff(parentNode, lastEnd, diff, this.tiffByteArray, this.startPos);
        }
    }

    private void loadRefItem(IFD[] ifds, ConcurrentSkipListMap<Integer, RefItem> sortedMap) {
        if (ifds == null) {
            return;
        }

        // Add Special Logic for IFD_0201_JPEGInterchangeFormat & IFD_0202_JPEGInterchangeFormatLength
        // Now we just assume these two IFD tags should be in the same exifGroup
        long jpeg_offset = 0;
        long jpeg_length = 0;
        IFD ifd_jpeg_offset = null;

        for (IFD item : ifds) {
            if (item instanceof IFD_0201_JPEGInterchangeFormat) {
                jpeg_offset = ((IFD_0201_JPEGInterchangeFormat) item).getBitstreamOffset();
                ifd_jpeg_offset = item;
            } else if (item instanceof IFD_0202_JPEGInterchangeFormatLength) {
                jpeg_length = ((IFD_0202_JPEGInterchangeFormatLength) item).getBitstreamLength();
            }

            if (item instanceof IFD_LONG_Pointer) {
                IFD_LONG_Pointer p = (IFD_LONG_Pointer) item;

                RefItem refItem = new RefItem();
                refItem.offset = (int) p.value[0];
                refItem.length = 2 + p.ifd_number * IFD.SIZE + 4;
                refItem.ifd = p;
                sortedMap.put(refItem.offset, refItem);

                this.loadRefItem(p.ifd_sub, sortedMap);
            } else {
                if (item.isValue() == false) {
                    RefItem refItem = new RefItem();
                    refItem.offset = item.ifd_value_offset;
                    refItem.length = item.data_size;
                    refItem.ifd = item;
                    sortedMap.put(refItem.offset, refItem);
                }
            }
        }

        if (jpeg_offset > 0 && jpeg_length > 0 && ifd_jpeg_offset != null) {
            RefItem refItem = new RefItem();
            refItem.offset = (int) jpeg_offset;
            refItem.length = (int) jpeg_length;
            refItem.ifd = ifd_jpeg_offset;
            sortedMap.put(refItem.offset, refItem);
        }
    }

    @SuppressWarnings("PackageVisibleInnerClass")
    private static class RefItem {

        int offset;
        int length;
        IFD ifd = null;
        IFDGroup ifdgroup = null;
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/tiff/TIFFHeader.java`:

```java
/*
 * TIFFHeader.java    Sep 07, 2010, 21:45
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.tiff;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 */
public class TIFFHeader extends FileComponent {

    public static final int SIZE = 8; // Size of TIFF Header
    public static final int BYTEORDER_LITTLEENDIAN = 18761; // "II"
    public static final int BYTEORDER_BIGENDIAN = 19789; // "MM"
    public static final int ARBITRARY_NUMBER_42 = 42;
    /** The byte order used within the file. */
    public final int byte_order;
    /**
     * An arbitrary but carefully chosen number (<code>42</code>)
     * that further identifies the file as a <code>TIFF</code> file.
     */
    public final int arbitray_number;
    /** The offset (in bytes) of the first IFD. */
    public final int offset_0ifd;

    public TIFFHeader(final PosDataInputStream pDisMarker) 
            throws IOException, FileFormatException {
        super.startPos = pDisMarker.getPos();
        super.length = SIZE;
        this.byte_order = pDisMarker.readUnsignedShort();
        if (this.byte_order == TIFFHeader.BYTEORDER_BIGENDIAN) {
            this.arbitray_number = pDisMarker.readUnsignedShort();
            this.offset_0ifd = pDisMarker.readInt();
        } else if (this.byte_order == TIFFHeader.BYTEORDER_LITTLEENDIAN) {
            this.arbitray_number = pDisMarker.readUnsignedShortInLittleEndian();
            this.offset_0ifd = pDisMarker.readIntInLittleEndian();
        } else {
            throw new FileFormatException(String.format("Marker APP01: Un-recognized TIFF header byte order value: expected value is %x or %s, current value is %x.", TIFFHeader.BYTEORDER_BIGENDIAN, TIFFHeader.BYTEORDER_LITTLEENDIAN, this.byte_order));
        }
    }

    public String getByteOrderName() {
        switch (this.byte_order) {
            case BYTEORDER_LITTLEENDIAN:
                return "little-endian byte order";
            case BYTEORDER_BIGENDIAN:
                return "big-endian byte order";
            default:
                return "Unknown byte order";
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent comp;

        comp = new JTreeNodeFileComponent(
                this.startPos + 0,
                2,
                String.format("byte order: %X - %s", this.byte_order, this.getByteOrderName()));
        comp.setDescription("The byte order used within the file. Legal values are:<br />"
                + "<ul>"
                + "<li> <strong>II</strong> (4949.H): In the <code>II</code> format, byte order is always from the least significant byte to the most significant byte, for both 16-bit and 32-bit integers This is called <i>little-endian</i> byte order. </li>"
                + "<li> <strong>MM</strong> (4D4D.H): In the <code>MM</code> format, byte order is always from most significant to least significant, for both 16-bit and 32-bit integers. This is called <i>big-endian</i> byte order.</li>"
                + "</ul>");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 2,
                2,
                String.format("arbitrary number: %d", this.arbitray_number));
        comp.setDescription("An arbitrary but carefully chosen number (<code>42</code>) that further identifies the file as a TIFF file.<br />"
                + "The byte order depends on the value of <i>byte order</i>.");
        parentNode.add(new DefaultMutableTreeNode(comp));

        comp = new JTreeNodeFileComponent(
                this.startPos + 4,
                4,
                String.format("first IFD offset: %d", this.offset_0ifd));
        comp.setDescription("The <code>offset</code> (in bytes) of the first IFD. "
                + "The directory may be at any location in the file after the header but <i>must begin on a word boundary</i>. "
                + "In particular, an Image File Directory may follow the image data it describes. "
                + "Readers must follow the pointers wherever they may lead."
                + "<br />"
                + "The term <strong><i>byte offset</i></strong> is always used in this document to refer to a location with respect to the beginning of the TIFF file. "
                + "The first byte of the file has an offset of <strong>0</strong>."
                );
        parentNode.add(new DefaultMutableTreeNode(comp));
    }
}

```

`FormatJPEG/src/main/java/org/binaryinternals/format/jpeg/xmp/XMP.java`:

```java
/*
 * XMP.java    Nov 06, 2010, 20:41
 *
 * Copyright 2010, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.jpeg.xmp;

import java.util.logging.Logger;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.FileFormatException;


/**
 *
 * @author Amos Shi
 * @see <a href="http://www.adobemediaplayer.com/devnet/xmp.html">Adobe XMP Developer Center </a>
 */
public class XMP extends FileComponent{

    private static final Logger LOG = Logger.getLogger(XMP.class.getName());
    public final byte[] rawData;
    private final String xmpmeta;
    //public final XMPMeta xmpMeta;

    public XMP(final PosDataInputStream input) throws FileFormatException {
        super.startPos = input.getPos();
        super.length = input.getBuf().length;

        this.rawData = input.getBuf();
        StringBuilder sb = new StringBuilder(this.rawData.length + 1);
        for (byte b : this.rawData) {
            sb.append((char) b);
        }
        this.xmpmeta = sb.toString();
        LOG.info(this.xmpmeta);

        // TODO - Analysis the data via XMPMeta

//        try {
//            this.xmpMeta = XMPMetaFactory.parse(input);
//        } catch (XMPException ex) {
//            Logger.getLogger(XMP.class.getName()).log(Level.SEVERE, null, ex);
//            throw new JPEGFileFormatException(ex);
//        }

    }
}

```

`FormatJPEG/src/main/resources/org/binaryinternals/format/jpeg/tiff/IFDMessage.properties`:

```properties
#
# IFDDescription.properties    Oct 07, 2010, 12:24
#
# Copyright 2010, BinaryInternals.org. All rights reserved.
# Use is subject to license terms.
#


_dummy=dummy
IFD_Type=The IFD field <code>Type</code>:<br />\n<ul>\n<li> <strong>1</strong> = <code>BYTE</code>: 8-bit unsigned integer. </li>\n<li> <strong>2</strong> = <code>ASCII</code>: 8-bit byte that contains a 7-bit ASCII code; the last byte must be NUL (binary zero). </li>\n<li> <strong>3</strong> = <code>SHORT</code>: 16-bit (2-byte) unsigned integer. </li>\n<li> <strong>4</strong> = <code>LONG</code>: 32-bit (4-byte) unsigned integer. </li>\n<li> <strong>5</strong> = <code>RATIONAL</code>: Two LONGs: the first represents the numerator of a fraction; the second, the denominator. </li>\n<li> <strong>6</strong> = <code>SBYTE</code>: An 8-bit signed (twos-complement) integer. </li>\n<li> <strong>7</strong> = <code>UNDEFINED</code>: An 8-bit byte that may contain anything, depending on the definition of the field. </li>\n<li> <strong>8</strong> = <code>SSHORT</code>: A 16-bit (2-byte) signed (twos-complement) integer. </li>\n<li> <strong>9</strong> = <code>SLONG</code>: A 32-bit (4-byte) signed (twos-complement) integer. </li>\n<li> <strong>10</strong> = <code>SRATIONAL</code>: Two SLONG\u2019s: the first represents the numerator of a fraction, the second the denominator. </li>\n<li> <strong>11</strong> = <code>FLOAT</code>: Single precision (4-byte) IEEE format. </li>\n<li> <strong>12</strong> = <code>DOUBLE</code>: Double precision (8-byte) IEEE format. </li>\n</ul>\n
IFD_Tag=The Tag that identifies the IFD field.
IFD_Count=The number of values, <i>Count</i> of the indicated <code>Type</code>.
IFD_Value=The <code>Value</code>, instead of pointing to the value.
IFD_Offset=The file <code>offset</code> (in bytes) of the <code>Value</code> for the field. \n<br />\nThis file <code>offset</code> may point anywhere in the file, even after the image data.
IFD_Value_Ref=<code>Value</code> of the field.
IFD=Image File Directory entry
IFD_0106_Description=The color space of the image data.<br />\n<ul>\n<!-- #0 - WhiteIsZero -->\n<li> <strong>0</strong>: <strong>WhiteIsZero<strong>.\n<br />\nFor bilevel and grayscale images: 0 is imaged as white. The maximum value is imaged as black. This is the normal value for Compression=2.\n</li>\n<!-- #1 - BlackIsZero -->\n<li> <strong>1</strong>: <strong>BlackIsZero</strong>. \n<br />\nFor bilevel and grayscale images: 0 is imaged as black. The maximum value is imaged as white. If this value is specified for Compression=2, the image should display and print reversed.\n</li>\n<!-- #2 - RGB -->\n<li> <strong>2</strong>: <strong>RGB</strong>.\n<br />\nIn the <code>RGB</code> model, a color is described as a combination of the three primary colors of light (red, green, and blue) in particular concentrations.\n<br />\nFor each of the three components, <code>0</code> represents minimum intensity, and <code>2**BitsPerSample - 1</code> represents maximum intensity. \nThus an <code>RGB</code> value of <code>(0,0,0)</code> represents black, and <code>(255,255,255)</code> represents white, assuming 8-bit components. \n<br />\nFor <code>PlanarConfiguration</code> = <code>1</code>, the components are stored in the indicated order: \nfirst Red, then Green, then Blue. \n<br />\nFor <code>PlanarConfiguration</code> = <code>2</code>, the StripOffsets for the component planes are stored in the indicated order: \nfirst the Red component plane <code>StripOffsets</code>, then the Green plane <code>StripOffsets</code>, then the Blue plane <code>StripOffsets</code>.\n</li>\n<!-- #3 - Palette color -->\n<li> <strong>3</strong>: <strong>Palette color</strong>.\n<br />\nIn this model, a color is described with a single component. \n<br />\nThe value of the component is used as an index into the red, green and blue curves in the <code>ColorMap</code> field to retrieve an <code>RGB</code> triplet that defines the color. \n<br />\nWhen <code>PhotometricInterpretation=3</code> is used, <code>ColorMap</code> must be present and <code>SamplesPerPixel</code> must be 1.\n</li>\n<!-- #4 - Transparency Mask -->\n<li> <strong>4</strong>: <strong>Transparency Mask.</strong>\n<p>\nThis means that the image is used to define an irregularly shaped region of another image in the same TIFF file. \n<code>SamplesPerPixel</code> and <code>BitsPerSample</code> must be <code>1</code>. \n<code>PackBits</code> compression is recommended. \nThe 1-bits define the interior of the region; the 0-bits define the exterior of the region.\n</p><p>\nA reader application can use the mask to determine which parts of the image to display. \nMain image pixels that correspond to 1-bits in the transparency mask are imaged to the screen or printer, \nbut main image pixels that correspond to 0-bits in the mask are not displayed or printed.\n</p><p>\n<i>The image mask is typically at a higher resolution than the main image, if the main image is grayscale or color so that the edges can be sharp.</i>\n</p><p>\nThere is no default for PhotometricInterpretation, and it is required. \nDo not rely on applications defaulting to what you want.\n</p>\n</li>\n<!-- #5 - CMYK -->\n<li> <strong>5</strong>: <strong>CMYK</strong></li>\n<!-- #6 - YCbCr -->\n<li> <strong>6</strong>: <code>YC<sub>b</sub>C<sub>r</sub></code>\n<br />\nA value of 6 indicates that the image data is in the <code>YC<sub>b</sub>C<sub>r</sub></code> color space. \n<br />\n<code>TIFF</code> uses the international standard notation <code>YC<sub>b</sub>C<sub>r</sub></code> for color-difference sample coding. \n<br />\n<code>Y</code> is the luminance component. \n<code>C<sub>b</sub></code> and <code>C<sub>r</sub></code> are the two chrominance components. \n<br />\n<code>RGB</code> pixels are converted to and from <code>YC<sub>b</sub>C<sub>r</sub></code> form for storage and display.\n</li>\n<!-- #8 - 1976 CIE L*a*b* -->\n<li> <strong>8</strong>: 1976 CIE <i>L*a*b*</i></li>\n</ul>;
IFD_010F_Description=The scanner manufacturer.<br />\nManufacturer of the scanner, video digitizer, or other type of equipment used to generate the image. Synthetic images should not include this field.\n
IFD_0110_Description=The scanner model name or number.<br />\nThe model name or number of the scanner, video digitizer, or other type of equipment used to generate the image.\n
IFD_0112_Description=The orientation of the image with respect to the rows and columns.<br />\n<ul>\n<li> <strong>1</strong>: The 0th row represents the visual top of the image, and the 0th column represents the visual left-hand side.</li>\n<li> <strong>2</strong>: The 0th row represents the visual top of the image, and the 0th column represents the visual right-hand side.</li>\n<li> <strong>3</strong>: The 0th row represents the visual bottom of the image, and the 0th column represents the visual right-hand side.</li>\n<li> <strong>4</strong>: The 0th row represents the visual bottom of the image, and the 0th column represents the visual left-hand side.</li>\n<li> <strong>5</strong>: The 0th row represents the visual left-hand side of the image, and the 0th column represents the visual top.</li>\n<li> <strong>6</strong>: The 0th row represents the visual right-hand side of the image, and the 0th column represents the visual top.</li>\n<li> <strong>7</strong>: The 0th row represents the visual right-hand side of the image, and the 0th column represents the visual bottom.</li>\n<li> <strong>8</strong>: The 0th row represents the visual left-hand side of the image, and the 0th column represents the visual bottom.</li>\n</ul>\nDefault is <code>1</code>.<br />\n<i>Support for orientations other than 1 is not a Baseline TIFF requirement.</i>
IFD_011A_Description=The number of pixels per <code>ResolutionUnit</code> in the <code>ImageWidth</code> (typically, horizontal - see <code>Orientation</code>) direction.
IFD_011B_Description=The number of pixels per <code>ResolutionUnit</code> in the <code>ImageLength</code> (typically, vertical) direction.
IFD_0128_Description=The unit of measurement for XResolution and YResolution.<br />\n<ul>\n<li> <strong>1</strong>: No absolute unit of measurement. Used for images that may have a non-square aspect ratio, but no meaningful absolute dimensions.<br />\nThe drawback of ResolutionUnit=1 is that different applications will import the image \nat different sizes. Even if the decision is arbitrary, it might be better to use dots per \ninch or dots per centimeter, and to pick XResolution and YResolution so that the \naspect ratio is correct and the maximum dimension of the image is about four inches \n(the \u201cfour\u201d is arbitrary.)\n</li>\n<li> <strong>2</strong>: Inch.</li>\n<li> <strong>3</strong>: Centimeter.</li>\n</ul>\nDefault is <code>2</code>.<br />
IFD_0131_Description=Name and version number of the software package(s) used to create the image.
IFD_0132_Description=Date and time of image creation.<br />\nThe format is: <code>YYYY:MM:DD HH:MM:SS</code>, with hours like those on a 24-hour clock, and one space character between the date and the time. <br />\nThe length of the string, including the terminating <code>NUL</code>, is <code>20</code> bytes.
IFD_0213_Description=Specifies the positioning of subsampled chrominance components relative to luminance samples.\n<br /><br />\n<table border=1 >\n<tr><th>Tag value</th><th>YC<sub>b</sub>C<sub>r</sub> Positioning</th><th>X and Y offsets of first chrominance sample</th></tr>\n<tr>\n<td><strong>1</strong></td>\n<td>centered</td>\n<td>Xoffset[0,0] = <i>ChromaSubsampleHoriz</i> / 2 - 0.5 <br />Yoffset[0,0] = <i>ChromaSubsampleVert</i> / 2 - 0.5</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>cosited</td>\n<td>Xoffset[0,0] = 0<br />Yoffset[0,0] = 0</td>\n</tr>\n</table> \nThe default value of this field is <code>1</code>.\n<p><i>See TIFF Revision 6.0 for detail.</i></p>
IFD_0214_Description=Specifies a pair of headroom and footroom image data values (codes) for each pixel component. \n<br />\nThe first component code within a pair is associated with <code>ReferenceBlack</code>, and the second is associated with <code>ReferenceWhite</code>. \n<br />\nThe ordering of pairs is the same as those for pixel components of the <code>PhotometricInterpretation</code> type. \n<br />\n<code>ReferenceBlackWhite</code> can be applied to images with a <code>PhotometricInterpretation</code> value of <code>RGB</code> or <code>YC<sub>b</sub>C<sub>r</sub></code>. \n<br />\n<code>ReferenceBlackWhite</code> is not used with other <code>PhotometricInterpretation</code> values.
IFD_8769_Exif_Category_A=<p>Exif Category <code>A</code>: <i>Tags Relating to Version</i></p>
IFD_8769_Exif_Category_B=<p>Exif Category <code>B</code>: <i>Tags Relating to Image Data Characteristics</i></p>
IFD_8769_Exif_Category_C=<p>Exif Category <code>C</code>: <i>Tags Relating to Image Configuration</i></p>
IFD_8769_Exif_Category_D=<p>Exif Category <code>D</code>: <i>Tags Relating to User Information</i></p>
IFD_8769_Exif_Category_E=<p>Exif Category <code>E</code>: <i>Tags Relating to Related File Information</i></p>
IFD_8769_Exif_Category_F=<p>Exif Category <code>F</code>: <i>Tags Relating to Date and Time</i></p>
IFD_8769_Exif_Category_G=<p>Exif Category <code>G</code>: <i>Tags Relating to Picture-Taking Conditions</i></p>
IFD_829A_Description=Exposure time, given in seconds (<code>sec</code>).<br />
IFD_829D_Description=The F number<br />
IFD_8822_Description=Default = <code>0</code><br />\n<ul>\n<li> <strong>0</strong> = Not defined </li>\n<li> <strong>1</strong> = Manual </li>\n<li> <strong>2</strong> = Normal program </li>\n<li> <strong>3</strong> = Aperture priority </li>\n<li> <strong>4</strong> = Shutter priority </li>\n<li> <strong>5</strong> = Creative program (biased toward depth of field) </li>\n<li> <strong>6</strong> = Action program (biased toward fast shutter speed) </li>\n<li> <strong>7</strong> = Portrait mode (for closeup photos with the background out of focus)</li>\n<li> <strong>8</strong> = Landscape mode (for landscape photos with the background in focus) </li>\n<li> <strong>other</strong> = reserved </li>\n</ul><br />
IFD_8827_Description=<p>\nThis tag indicates the sensitivity of the camera or input device when the image was shot. \n</p>\n<p>\nMore specifically, it indicates one of the following values that are parameters defined in ISO 12232: \n<ul>\n<li> standard output sensitivity (SOS) </li>\n<li> recommended exposure index (REI) </li>\n<li> ISO speed </li>\n</ul>\n</p>\n<p>\nAccordingly, if a tag corresponding to a parameter that is designated by a <code>SensitivityType</code> tag is recorded, \nthe values of the tag and of this <code>PhotographicSensitivity</code> tag are the same. \n</p>\n<p>\nHowever, if the value is 65535 (the maximum value of SHORT) or higher, the value of this tag shall be 65535. \nWhen recording this tag, the <code>SensitivityType</code> tag should also be recorded. \n</p>\n<p>\nIn addition, while \u201c<code>Count = Any</code>\u201d, only <code>1</code> count should be used when recording this tag.\n</p>\n<p>\nNote that this tag was referred to as \u201c<code>ISOSpeedRatings</code>\u201d in versions of this standard up to Version 2.21.\n</p>\n
IFD_9000_Description=The version of this standard supported. <br/>\nNonexistence of this field is taken to mean nonconformance to the standard. <br/>\nIn according with conformance to this standard, this tag shall be recorded like "0230\u201d as 4-byte ASCII. <br/>\nSince the type is UNDEFINED, it shall not be terminated with NULL.
IFD_8769_Exif_FormatVersion=\n<p>\n<i>Format Version</i>\n</p>\n\n<p>\nThe version of the format specified here is recorded as 4 Bytes. \nThe address bytes are recorded as A1, A2, B1, and B2, starting with the lowest number. \nA1 and A2 store the upper part of the standard version, with the lower part stored in B1 and B2. \nWhen changes are made to the version number of this standard, the following rules apply.\n<ul>\n<li> When the changes are such that data readers can properly recognize conventional information and\nskip the data that was recorded using newly added functions, the lower part of the version (B1, B2)\nis changed.</li>\n<li> When there is a possibility that a data reader implementing the old standard may operate incorrectly\ndue to the new specifications, the upper part of the version (A1, A2) is changed.\n</li>\n</ul>\nPlayers should be able to play back files of versions earlier than the supported standard.\n</p>
IFD_9003_Description=<p>\nThe date and time when the original image data was generated. <br/><br/>\nFor a <code>DSC</code> the date and time the picture was taken are recorded. <br/>\nThe format is "<code>YYYY:MM:DD HH:MM:SS</code>" with time shown in 24-hour format, and the date and time separated by one <code>blank</code> character <code>[20.H]</code>. \n</p>\n<p>\nWhen the date and time are unknown, all the character spaces except colons (":") should be filled with <code>blank</code> characters,\n or else the Interoperability field should be filled with <code>blank</code> characters. \n</p>\n<p>\nThe character string length is <code>20</code> Bytes including <code>NULL</code> for termination. \n</p>\n<p>\nWhen the field is left blank, it is treated as unknown.\n</p>\n
IFD_9004_Description=<p>\nThe date and time when the image was stored as digital data. <br/><br/>\nIf, for example, an image was captured by <code>DSC</code> and at the same time the file was recorded, \nthen the DateTimeOriginal and DateTimeDigitized will have the same contents. <br/>\nThe format is "<code>YYYY:MM:DD HH:MM:SS</code>" with time shown in 24-hour format, \nand the date and time separated by one blank character [20.H]. \n</p>\n<p>\nWhen the date and time are unknown, all the character spaces except colons (":")should be filled with <code>blank</code> characters, \nor else the Interoperability field should be filled with <code>blank</code> characters. \n</p>\n<p>\nThe character string length is 20 Bytes including NULL for termination. \n</p>\n<p>\nWhen the field is left blank, it is treated as unknown.\n</p>
IFD_9101_Description=<p>\nInformation specific to compressed data. <br/><br/>\nThe channels of each component are arranged in order from the <code>1st</code> component to the <code>4th</code>.  <br/>\nFor uncompressed data the data arrangement is given in the <code>PhotometricInterpretation</code> tag.  <br/>\nHowever, since <code>PhotometricInterpretation</code> can only express the order of <code>Y</code>, <code>C<sub>b</sub></code> and <code>C<sub>r</sub></code>, \nthis tag is provided for cases when compressed data uses components other than <code>Y</code>, <code>C<sub>b</sub></code>, and <code>C<sub>r</sub></code> and to enable support of other sequences.\n</p>\n<p>\nDefault = \n<ul>\n<li>4 5 6 0: (if RGB uncompressed) </li>\n<li>1 2 3 0: (other cases) </li>\n</ul>\n</p>\n<p>\nMeaning of each value:\n<ul>\n<li> <code>0</code> = does not exist </li>\n<li> <code>1</code> = Y  </li>\n<li> <code>2</code> = Cb </li>\n<li> <code>3</code> = Cr </li>\n<li> <code>4</code> = R  </li>\n<li> <code>5</code> = G  </li>\n<li> <code>6</code> = B  </li>\n<li> Other = reserved </li>\n</ul>\n</p>\n
IFD_9204_Description=The exposure bias. <br/>\nThe unit is the APEX value. Ordinarily it is given in the range of <code>-99.99</code> to <code>99.99</code>.
IFD_9205_Description=The smallest F number of the lens. <br/>\nThe unit is the APEX value. Ordinarily it is given in the range of <code>00.00</code> to <code>99.99</code>, but it is not limited to this range.
IFD_9207_Description=The metering mode.<br />\n<ul>\n<li> <strong>0</strong>: unknown</li>\n<li> <strong>1</strong>: Average</li>\n<li> <strong>2</strong>: Center Weighted Average</li>\n<li> <strong>3</strong>: Spot</li>\n<li> <strong>4</strong>: Multi Spot</li>\n<li> <strong>5</strong>: Pattern</li>\n<li> <strong>6</strong>: Partial</li>\n<li> <strong>255</strong>: other</li>\n<li> <strong>Other</strong>: reserved</li>\n</ul>\nDefault value is <code>0</code>.<br />
IFD_9208_Description=The kind of light source.<br />\n<ul>\n<li> <strong>0</strong>: unknown</li>\n<li> <strong>1</strong>: Daylight</li>\n<li> <strong>2</strong>: Fluorescent</li>\n<li> <strong>3</strong>: Tungsten (incandescent light)</li>\n<li> <strong>4</strong>: Flash</li>\n<li> <strong>9</strong>: Fine weather</li>\n<li> <strong>10</strong>: Cloudy weather</li>\n<li> <strong>11</strong>: Shade</li>\n<li> <strong>12</strong>: Daylight fluorescent (D 5700 - 7100K)</li>\n<li> <strong>13</strong>: Day white fluorescent (N 4600 - 5500K)</li>\n<li> <strong>14</strong>: Cool white fluorescent (W 3800 - 4500K)</li>\n<li> <strong>15</strong>: White fluorescent (WW 3250 - 3800K)</li>\n<li> <strong>16</strong>: Warm white fluorescent (L 2600 - 3250K)</li>\n<li> <strong>17</strong>: Standard light A</li>\n<li> <strong>18</strong>: Standard light B</li>\n<li> <strong>19</strong>: Standard light C</li>\n<li> <strong>20</strong>: D55</li>\n<li> <strong>21</strong>: D65</li>\n<li> <strong>22</strong>: D75</li>\n<li> <strong>23</strong>: D50</li>\n<li> <strong>24</strong>: ISO studio tungsten</li>\n<li> <strong>255</strong>: other light source</li>\n<li> <strong>Other</strong>: reserved</li>\n</ul>\nDefault value is <code>0</code>.<br />
IFD_9209_Description=This tag indicates the status of flash when the image was shot.<br/>\n<p>\nBit 0 indicates the flash firing status, <br/>\nbits 1 and 2 indicate the flash return status, <br/>\nbits 3 and 4 indicate the flash mode, <br/>\nbit 5 indicates whether the flash function is present, <br/>\nand bit 6 indicates "red eye" mode.\n</p>\n<p>\n<strong>Bit Coding of the Flash Tag:</strong>\n</p>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<td width="50" align="center">7</td>\n<td width="50" align="center" bgcolor="#00C000">6</td>\n<td width="50" align="center" bgcolor="#00C000">5</td>\n<td width="50" align="center" bgcolor="#00C000">4</td>\n<td width="50" align="center" bgcolor="#00C000">3</td>\n<td width="50" align="center" bgcolor="#00C000">2</td>\n<td width="50" align="center" bgcolor="#00C000">1</td>\n<td width="50" align="center" bgcolor="#00C000">0</td>\n</tr>\n<tr>\n<td align="center">&nbsp;</td>\n<td align="center">Red-eye<br/>mode</td>\n<td align="center">Flash<br/>function</td>\n<td align="center" colspan="2">Flash mode</td>\n<td align="center" colspan="2">Flash return</td>\n<td align="center">Flash<br/>fired</td>\n</tr>\n</table>\n\n<ul> \nValues for bit <code>0</code> indicating whether the flash fired.\n<li><strong><code>0</code></strong>b: Flash did not fire.</li>\n<li><strong><code>1</code></strong>b: Flash fired.</li>\n</ul>\n<ul> \nValues for bits <code>1</code> and <code>2</code> indicating the status of returned light.\n<li><strong><code>00</code></strong>b: No strobe return detection function</li>\n<li><strong><code>01</code></strong>b: reserved</li>\n<li><strong><code>10</code></strong>b: Strobe return light not detected.</li>\n<li><strong><code>11</code></strong>b: Strobe return light detected.</li>\n</ul>\n<ul> \nValues for bits <code>3</code> and <code>4</code> indicating the camera's flash mode.\n<li><strong><code>00</code></strong>b: unknown</li>\n<li><strong><code>01</code></strong>b: Compulsory flash firing</li>\n<li><strong><code>10</code></strong>b: Compulsory flash suppression</li>\n<li><strong><code>11</code></strong>b: Auto mode</li>\n</ul>\n<ul> \nValues for bit <code>5</code> indicating the presence of a flash function.\n<li><strong><code>0</code></strong>b: Flash function present</li>\n<li><strong><code>1</code></strong>b: No flash function</li>\n</ul>\n<ul> \nValues for bit <code>6</code> indicating the camera's red-eye mode.\n<li><strong><code>0</code></strong>b: No red-eye reduction mode or unknown</li>\n<li><strong><code>1</code></strong>b: Red-eye reduction supported</li>\n</ul>\n
IFD_920A_Description=The actual focal length of the lens, in <code>mm</code>.<br/> Conversion is not made to the focal length of a 35 <code>mm</code> film camera.
IFD_927C_Description=A tag for manufacturers of Exif/DCF writers to record any desired information. <br/>The contents are up to the manufacturer, but this tag shall not be used for any other than its intended purpose.
IFD_9286_Description=A tag for Exif users to write keywords or comments on the image besides those in <code>ImageDescription</code>,\nand without the character code limitations of the <code>ImageDescription</code> tag.\n<p>\nThe character code used in the <code>UserComment</code> tag is identified based on an ID code in a fixed 8-byte area at the start of the tag data area. \nThe unused portion of the area shall be padded with <code>NULL</code> ("<code>00.H</code>"). \nID codes are assigned by means of registration. \nThe designation method and references for each character code are given in <strong>Table</strong> bellow. \nThe value of Count <code>N</code> is determined based on the 8 bytes in the character code area and the number of bytes in the user comment part. \nSince the TYPE is not <code>ASCII</code>, <code>NULL</code> termination is not necessary.\n</p>\n\n<p>\n<strong>Table Character Codes and their Designation</strong>\n</p>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<th align="center">Character Code</td>\n<th align="center">Code Designation (8 Bytes)</td>\n<th align="center">References</td>\n</tr>\n<tr>\n<td align="center"> ASCII </td>\n<td align="center"> 41.H, 53.H, 43.H, 49.H, 49.H, 00.H, 00.H, 00.H </td>\n<td align="center"> ITU-T T.50 IA5 </td>\n</tr>\n<tr>\n<td align="center"> JIS </td>\n<td align="center"> 4A.H, 49.H, 53.H, 00.H, 00.H, 00.H, 00.H, 00.H </td>\n<td align="center"> JIS X208-1990 </td>\n</tr>\n<tr>\n<td align="center"> Unicode </td>\n<td align="center"> 55.H, 4E.H, 49.H, 43.H, 4F.H, 44.H, 45.H, 00.H </td>\n<td align="center"> Unicode Standard </td>\n</tr>\n<tr>\n<td align="center"> Undefined </td>\n<td align="center"> 00.H, 00.H, 00.H, 00.H, 00.H, 00.H, 00.H, 00.H </td>\n<td align="center"> Undefined </td>\n</tr>\n</table>\n\n<p>\nThe ID code for the <code>UserComment</code> area may be a Defined code such as <code>JIS</code> or <code>ASCII</code>, or may be Undefined. \nThe Undefined name is UndefinedText, and the ID code is filled with 8 Bytes of all "<code>NULL</code>" ("<code>00.H</code>"). \nAn Exif/DCF reader that reads the <code>UserComment</code> tag shall have a function for determining the ID code. \nThis function is not required in Exif/DCF readers that do not use the UserComment tag (see <strong>Table</strong> bellow).\n</p>\n\n<p>\n<strong>Table  Implementation of Defined and Undefined Character Codes</strong>\n</p>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<th align="center">ID Code</td>\n<th align="center">Exif/DCF reader Implementation</td>\n</tr>\n<tr>\n<td align="center"> Defined<br/>(<code>JIS</code>, <code>ASCII</code>, etc.) </td>\n<td> Determines the ID code and displays it in accord with the Exif/DCF reader capability. </td>\n</tr>\n<tr>\n<td align="center"> Undefined<br/>(all <code>NULL</code>) </td>\n<td> Depends on the localized PC in each country. \n(If a character code is used for which there is no clear specification like Shift-JIS in Japan, Undefined is used.)\nAlthough the possibility of unreadable characters exists, display of these characters is left as a matter of Exif/DCF reader implementation. \n</td>\n</tr>\n</table>\n\n<p>\nWhen a UserComment area is set aside, \nit is recommended that the ID code be <code>ASCII</code> and that the following user comment part be filled with blank characters [<code>20.H</code>].\n</p>
IFD_9290_Description=A tag used to record fractions of seconds for the <code>DateTime<code> tag.
IFD_9291_Description=A tag used to record fractions of seconds for the <code>DateTimeOriginal</code> tag.
IFD_9292_Description=A tag used to record fractions of seconds for the <code>DateTimeDigitized</code> tag.
IFD_A000_Description=The Flashpix format version supported by a <code>FPXR</code> file. <br/>\n<p>\nIf the <code>FPXR</code> function supports Flashpix format Ver. 1.0, \nthis is indicated similarly to <code>ExifVersion</code> by recording "<code>0100</code>" as 4-byte <code>ASCII</code>. \nSince the type is <code>UNDEFINED</code>, <strong>it shall not be terminated with <code>NULL</code></strong>.\n</p>
IFD_A001_Description=The color space information tag (<code>ColorSpace</code>) is always recorded as the color space specifier.\n<p>\nNormally <code>sRGB</code> (=<code>1</code>) is used to define the color space based on the PC monitor conditions and environment. \nIf a color space other than <code>sRGB</code> is used, Uncalibrated (=<code>FFFF.H</code>) is set. \nImage data recorded as Uncalibrated may be treated as <code>sRGB</code> when it is converted to Flashpix.\n</p>\n<ul>\n<li> <code>1</code> = sRGB </li>\n<li> <code>FFFF.H</code> = Uncalibrated </li>\n<li> Other = reserved </li>\n</ul>\n
IFD_A002_Description=Information specific to compressed data. \n<p>\nWhen a compressed file is recorded, the valid width of the meaningful image shall be recorded in this tag, \nwhether or not there is padding data or a restart marker.\n</p>\n<p>\nThis tag shall not exist in an uncompressed file.\n</p>\n
IFD_A003_Description=Information specific to compressed data. \n<p>\nWhen a compressed file is recorded, the valid height of the meaningful image shall be recorded in this tag, \nwhether or not there is padding data or a restart marker.\nThis tag shall not exist in an uncompressed file. \n<!-- For details see section 4.8.1 and Annex F. -->\nSince data padding is unnecessary in the vertical direction, \nthe number of lines recorded in this valid image height tag will in fact be the same as that recorded in the <code>SOF</code>.\n</p>\n\n
IFD_A217_Description=Indicates the image sensor type on the camera or input device. \n<p>\nThe values are as follows.\n</p>\n<ul>\n<li><code>1</code>: Not defined</li>\n<li><code>2</code>: One-chip color area sensor</li>\n<li><code>3</code>: Two-chip color area sensor</li>\n<li><code>4</code>: Three-chip color area sensor</li>\n<li><code>5</code>: Color sequential area sensor</li>\n<li><code>7</code>: Trilinear sensor</li>\n<li><code>8</code>: Color sequential linear sensor</li>\n<li>Other: reserved</li>\n</ul>\n
IFD_A300_Description=Indicates the image source. \n<p>\nIf a <code>DSC</code> recorded the image, this tag value always shall be set to <code>3</code>.\n</p>\n<ul>\n<li><code>0</code>: others</li>\n<li><code>1</code>: scanner of transparent type</li>\n<li><code>2</code>: scanner of reflex type</li>\n<li><code>3</code>: <code>DSC</code></li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>3</code>.\n
IFD_A301_Description=Indicates the type of scene. \n<p>\nIf a <code>DSC</code> recorded the image, this tag value shall always be set to <code>1</code>,\nindicating that the image was directly photographed.\n</p>\n<ul>\n<li><code>1</code>: A directly photographed image</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>1</code>.\n
IFD_A302_Description=Indicates the color filter array (<code>CFA</code>) geometric pattern of the image sensor when a one-chip color area sensor is used. \nIt does not apply to all sensing methods.\n\n<p>\n(The Figure bellow) shows how a <code>CFA</code> pattern is recorded for a one-chip color area sensor when the color filter array is repeated in m x n (vertical x lateral) pixel units.\n</p>\n<strong>Figure: CFA Pattern Description</strong>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<th align="center">Length</td>\n<th align="center">Type</td>\n<th align="center">Meaning</td>\n</tr>\n<tr>\n<td align="center"> <code>2</code> </td>\n<td align="center"> <code>SHORT</code> </td>\n<td align="center"> Horizontal repeat pixel unit = <code>n</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>2</code> </td>\n<td align="center"> <code>SHORT</code> </td>\n<td align="center"> Vertical repeat pixel unit = <code>m</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>1</code> </td>\n<td align="center"> <code>BYTE</code> </td>\n<td align="center"> <code>CFA</code> value <code>[0.0]</code> </td>\n</tr>\n<tr>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> <code>1</code> </td>\n<td align="center"> <code>BYTE</code> </td>\n<td align="center"> <code>CFA</code> value <code>[n-1.0]</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>1</code> </td>\n<td align="center"> <code>BYTE</code> </td>\n<td align="center"> <code>CFA</code> value <code>[0.m-1]</code> </td>\n</tr>\n<tr>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> <code>1</code> </td>\n<td align="center"> <code>BYTE</code> </td>\n<td align="center"> <code>CFA</code> value <code>[n-1.m-1]</code> </td>\n</tr>\n</table>\n\n<p>\nThe relation of color filter color to <code>CFA</code> value is shown in Table bellow.\n</p>\n<strong>Table: Color Filter Color and <code>CFA</code> Value</strong>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<th align="center">Filter Color</td>\n<th align="center"><code>CFA</code> Value</td>\n</tr>\n<tr>\n<td align="center"> <code>RED</code> </td>\n<td align="center"> <code>00.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>GREEN</code> </td>\n<td align="center"> <code>01.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>BLUE</code> </td>\n<td align="center"> <code>02.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>CYAN</code> </td>\n<td align="center"> <code>03.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>MAGENTA</code> </td>\n<td align="center"> <code>04.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>YELLOW</code> </td>\n<td align="center"> <code>05.H</code> </td>\n</tr>\n<tr>\n<td align="center"> <code>WHITE</code> </td>\n<td align="center"> <code>06.H</code> </td>\n</tr>\n</table>\n\n<p>\nFor example, when the <code>CFA</code> pattern values are <code>{0002.H, 0002.H, 01.H, 00.H, 02.H, 01.H}</code>, \nthe color filter array is as shown in Figure bellow.\n</p>\n<strong>Figure: Color Filter Array</strong>\n<table border="1" cellpadding="0" cellspacing="0">\n<tr>\n<td width="31" align="center"> <code>G</code> </td>\n<td width="31" align="center"> <code>R</code> </td>\n<td width="31" align="center"> <code>G</code> </td>\n<td width="31" align="center"> <code>R</code> </td>\n<td width="50" align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> <code>B</code> </td>\n<td align="center"> <code>G</code> </td>\n<td align="center"> <code>B</code> </td>\n<td align="center"> <code>G</code> </td>\n<td align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> <code>G</code> </td>\n<td align="center"> <code>R</code> </td>\n<td align="center"> <code>G</code> </td>\n<td align="center"> <code>R</code> </td>\n<td align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> <code>B</code> </td>\n<td align="center"> <code>G</code> </td>\n<td align="center"> <code>B</code> </td>\n<td align="center"> <code>G</code> </td>\n<td align="center"> ... </td>\n</tr>\n<tr>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n<td align="center"> ... </td>\n<td align="center"> &nbsp; </td>\n</tr>\n</table>\n
IFD_A401_Description=This tag indicates the use of special processing on image data, such as rendering geared to output.\nWhen special processing is performed, the Exif/DCF reader is expected to disable or minimize any further processing.\n<ul>\n<li><code>0</code>: Normal process</li>\n<li><code>1</code>: Custom process</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>0</code>.
IFD_A402_Description=This tag indicates the exposure mode set when the image was shot. \nIn auto-bracketing mode, the camera shoots a series of frames of the same scene at different exposure settings.\n<ul>\n<li><code>0</code>: Auto exposure</li>\n<li><code>1</code>: Manual exposure</li>\n<li><code>2</code>: Auto bracket</li>\n<li>Other: reserved</li>\n</ul>\n
IFD_A403_Description=This tag indicates the white balance mode set when the image was shot.\n<ul>\n<li><code>0</code>: Auto white balance</li>\n<li><code>1</code>: Manual white balance</li>\n<li>Other: reserved</li>\n</ul>\n
IFD_A404_Description=This tag indicates the digital zoom ratio when the image was shot.<br/> \nIf the numerator of the recorded value is 0, this indicates that digital zoom was not used.
IFD_A405_Description=This tag indicates the equivalent focal length assuming a 35mm film camera, in <code>mm<code>.<br/> \nA value of <code>0</code> means the focal length is unknown. Note that this tag differs from the <code>FocalLength</code> tag.
IFD_A406_Description=This tag indicates the type of scene that was shot. <br/>\nIt may also be used to record the mode in which the image was shot. Note that this differs from the scene type (<code>SceneType</code>) tag.\n<ul>\n<li><code>0</code>: Standard</li>\n<li><code>1</code>: Landscape</li>\n<li><code>2</code>: Portrait</li>\n<li><code>3</code>: Night scene</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>0</code>.
IFD_A407_Description=This tag indicates the degree of overall image gain adjustment.\n<ul>\n<li><code>0</code>: None</li>\n<li><code>1</code>: Low gain up</li>\n<li><code>2</code>: High gain up</li>\n<li><code>3</code>: Low gain down</li>\n<li><code>4</code>: High gain down</li>\n<li>Other: reserved</li>\n</ul>\n
IFD_A408_Description=This tag indicates the direction of contrast processing applied by the camera when the image was shot.\n<ul>\n<li><code>0</code>: Normal</li>\n<li><code>1</code>: Soft</li>\n<li><code>2</code>: Hard</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>0</code>.\n
IFD_A409_Description=This tag indicates the direction of saturation processing applied by the camera when the image was shot.\n<ul>\n<li><code>0</code>: Normal</li>\n<li><code>1</code>: Low saturation</li>\n<li><code>2</code>: High saturation</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>0</code>.
IFD_A40A_Description=This tag indicates the direction of sharpness processing applied by the camera when the image was shot.\n<ul>\n<li><code>0</code>: Normal</li>\n<li><code>1</code>: Soft</li>\n<li><code>2</code>: Hard</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>0</code>.
IFD_A40C_Description=This tag indicates the distance to the subject.\n<ul>\n<li><code>0</code>: unknown</li>\n<li><code>1</code>: Macro</li>\n<li><code>2</code>: Close view</li>\n<li><code>3</code>: Distant view</li>\n<li>Other: reserved</li>\n</ul>
IFD_8825_GPS_Category_A=<p>GPS Category <code>A</code>: <i>Tags Relating to GPS</i></p>
IFD_A005_Intero_Category_A=<p>Interoperability Category <code>A</code>: <i>Attached Information Related to Interoperability</i></p>
IFD_GPS_0000_Description=Indicates the version of <code>GPSInfoIFD</code>. \n<p>\nThe version is given as <code>2.3.0.0</code>. \nThis tag is mandatory when <code>GPSInfo</code> tag is present. \nNote that the <code>GPSVersionID</code> tag is written as a different byte than the Exif Version tag.\n<p>\n<ul>\n<li><code>2.3.0.0</code>: Version 2.3</li>\n<li>Other: reserved</li>\n</ul>\nDefault value is <code>2.3.0.0</code>.
IFD_A215_Description=Indicates the exposure index selected on the camera or input device at the time the image is captured.
IFD_9201_Description=Shutter speed. <br/>The unit is the <code>APEX</code> (Additive System of Photographic Exposure) setting.
IFD_9202_Description=The lens aperture. <br/>The unit is the <code>APEX</code> value.
IFD_013E_Description=The chromaticity of the white point of the image. \n<p>\nThis is the chromaticity when each of the primaries has its ReferenceWhite value. \nThe value is described using the 1931 CIE xy chromaticity diagram and only the chromaticity is specified.\nThis value can correspond to the chromaticity of the alignment white of a monitor,\nthe filter set and light source combination of a scanner or the imaging model of a rendering package. \nThe ordering is white[x], white[y].\n</p>\n<p>\nFor example, the CIE Standard Illuminant D65 used by CCIR Recommendation 709 and Kodak PhotoYCC is:\n</p>\n&nbsp;&nbsp;&nbsp;&nbsp; <code>3127/10000</code>, <code>3290/10000</code>\n<p>\nNo default.\n</p>\n
IFD_013F_Description=The chromaticities of the primaries of the image. \n<p>\nThis is the chromaticity for each of the primaries when it has its ReferenceWhite value \nand the other primaries have their ReferenceBlack values. \nThese values are described using the 1931 CIE xy chromaticity diagram and only the chromaticities are specified. \nThese values can correspond to the chromaticities of the phosphors of a monitor, \nthe filter set and light source combination of a scanner or the imaging model of a rendering package. \nThe ordering is red[x], red[y], green[x], green[y], blue[x], and blue[y].\n</p>\n<p>\nFor example the CCIR Recommendation 709 primaries are:\n</p>\n&nbsp;&nbsp;&nbsp;&nbsp; <code>640/1000</code>, <code>330/1000</code>,<br/>\n&nbsp;&nbsp;&nbsp;&nbsp; <code>300/1000</code>, <code>600/1000</code>,<br/>\n&nbsp;&nbsp;&nbsp;&nbsp; <code>150/1000</code>, <code>60/1000</code>\n<p>\nNo default.\n</p>\n
IFD_0211_Description=The transformation from RGB to YC<sub>b</sub>C<sub>r</sub> image data. \n<p>\nThe transformation is specified as three rational values that represent the coefficients used to compute luminance, Y.\n</p>\n<p>\nThe three rational coefficient values, LumaRed, LumaGreen and LumaBlue, \nare the proportions of red, green, and blue respectively in luminance, Y.\n</p>\n<p>\nY, C<sub>b</sub>, and C<sub>r</sub> may be computed from RGB using the luminance coefficients specified by this field as follows:\n</p>\n Y = ( <i>LumaRed</i> * <code>R</code> + <i>LumaGreen</i> * <code>G</code> + <i>LumaBlue</i> * <code>B</code> ) <br/>\n C<sub>b</sub> = ( <code>B</code> - <code>Y</code> ) / ( 2 - 2 * <i>LumaBlue</i> ) <br/>\n C<sub>r</sub> = ( <code>R</code> - <code>Y</code> ) / ( 2 - 2 * <i>LumaRed</i> )\n<p>\n<code>R</code>, <code>G</code>, and <code>B</code> may be computed from YCbCr as follows:\n</p>\n <code>R</code> = C<sub>r</sub> *( 2 - 2 * <i>LumaRed</i> ) + Y <br/>\n <code>G</code> = ( <code>Y</code> - <i>LumaBlue</i> * <code>B</code> - <i>LumaRed</i> * <code>R</code> ) / <i>LumaGreen</i> <br/>\n <code>B</code> = C<sub>b</sub> * ( 2 - 2 * LumaBlue ) + Y\n<p>\nIn disciplines such as printing, film, and video, there are practical reasons to provide\nfootroom codes below the ReferenceBlack code and headroom codes above ReferenceWhite code. \nIn such cases the values of the transformation matrix used to convert from \nYC<sub>b</sub>C<sub>r</sub> to RGB must be multiplied by a scale factor to produce full-range RGB values. \nThese scale factors depend on the reference ranges specified by the ReferenceBlackWhite field. \nSee the ReferenceBlackWhite and TransferFunction fields for more details.\n</p>\n<p>\nThe values coded by this field will typically reflect the transformation specified by a standard for \nYC<sub>b</sub>C<sub>r</sub> encoding. The following table contains examples of commonly used values.\n</p>\n\n<table border="1" >\n<tr><th>Standard</th><th><i>LumaRed</i></th><th><i>LumaGreen</i></th><th><i>LumaBlue</i></th></tr>\n<tr>\n<td>CCIR Recommendation 601-1</td>\n<td>299 / 1000</td>\n<td>587 / 1000</td>\n<td>114 / 1000</td>\n</tr>\n<tr>\n<td>CCIR Recommendation 709</td>\n<td>2125 / 10000</td>\n<td>7154 / 10000</td>\n<td>721 / 10000</td>\n</tr>\n</table> \n\n<p>\nThe default values for this field are those defined by CCIR Recommendation 601-1: \n299/1000, 587/1000 and 114/1000, for <i>LumaRed</i>, <i>LumaGreen</i> and <i>LumaBlue</i>, respectively.\n</p>
IFD_A20E_Description=Indicates the number of pixels in the image width (<code>X</code>) direction per <code>FocalPlaneResolutionUnit</code> on the camera focal plane.
IFD_A20F_Description=Indicates the number of pixels in the image height (<code>Y</code>) direction per <code>FocalPlaneResolutionUnit</code> on the camera focal plane.
IFD_A210_Description=Indicates the unit for measuring <code>FocalPlaneXResolution</code> and <code>FocalPlaneYResolution</code>. \nThis value is the same as the <code>ResolutionUnit</code>.\n<p>\n<strong>Note on use of tags concerning focal plane resolution</strong>\n</p>\n<p>\nThese tags record the actual focal plane resolutions of the main image which is written as a file\nafter processing instead of the pixel resolution of the image sensor in the camera. \nIt should be noted carefully that the data from the image sensor is resampled.\n</p>\n<p>\nThese tags are used at the same time as a <code>FocalLength</code> tag \nwhen the angle of field of the recorded image is to be calculated precisely.\n</p>
IFD_A500_Description=Indicates the value of coefficient gamma. \n<p>\nThe formula of transfer function used for image reproduction is expressed as follows.\n</p>\n<p>\n&nbsp;&nbsp;&nbsp;&nbsp; (Reproduced value) = (Input value)<sup>gamma</sup>\n</p>\n<p>\nBoth reproduced value and input value indicate normalized value, \nwhose minimum value is <code>0</code> and maximum value is <code>1</code>.\n</p>\n
IFD_9102_Description=Information specific to compressed data. <br/>\nThe compression mode used for a compressed image is indicated in unit bits per pixel.
IFD_ItO_0001_Description=Indicates the identification of the Interoperability rule. \n<p>\nThe following rules are defined. Four Bytes used including the termination code (<code>NULL</code>).\n</p>\n<ul>\n<li>"<strong>R98</strong>" = Indicates a file conforming to R98 file specification of Recommended Exif Interoperability Rules (Exif R 98) or to DCF basic file stipulated by Design Rule for Camera File System.</li>\n<li>"<strong>THM</strong>" = Indicates a file conforming to DCF thumbnail file stipulated by Design rule for Camera File System.</li>\n<li>\u201c<strong>R03</strong>\u201d = Indicates a file conforming to DCF Option File stipulated by Design rule for Camera File System.</li>\n</ul>
IFD_0201_Description=This Field indicates whether a <code>JPEG</code> interchange format bitstream is present in the <code>TIFF</code> file. \n<p>\nIf a JPEG interchange format bitstream is present, then this Field points to the Start of Image (<code>SOI</code>) marker code.\n<br/>\nIf this Field is <code>zero</code> or not present, a JPEG interchange format bitstream is not present.\n</p>\n
IFD_0202_Description=This Field indicates the length in bytes of the <code>JPEG</code> interchange format bitstream.\n<p>\nThis Field is useful for extracting the <code>JPEG</code> interchange format bitstream without parsing the bitstream.\n<br/>\nThis Field is relevant only if the <code>JPEGInterchangeFormat</code> Field is present and is <code>non-zero</code>.\n</p>\n

```

`FormatJPEG/src/main/resources/org/binaryinternals/format/jpeg/tiff/IFDTag.properties`:

```properties
#
# IFDTag.properties    Oct 10, 2010, 20:16
#
# Copyright 2010, BinaryInternals.org. All rights reserved.
# Use is subject to license terms.
#


_dummy=dummy
IFD_00FE_NewSubfileType=New Subfile Type
IFD_0001_InteroperabilityIndex=Interoperability Identification
UNKNOWN_GPS_TAG=Unknown GPS Tag
IFD_001F_GPSHPositioiningError=Horizontal positioning error
IFD_001E_GPSDifferential=GPS differential correction
IFD_001D_GPSDateStamp=GPS date
IFD_001C_GPSAreaInformation=Name of GPS area
IFD_001B_GPSProcessingMethod=Name of GPS processing method
IFD_001A_GPSDestDistance=Distance of destination
IFD_0019_GPSDestDistanceRef=Reference for distance of destination
IFD_0018_GPSDestBearing=Bearing of destination
IFD_0017_GPSDestBearingRef=Reference for bearing of destination
IFD_0016_GPSDestLongitude=Longitude of destination
IFD_0015_GPSDestLongitudeRef=Reference for longitude of destination
IFD_0014_GPSDestLatitude=Latitude of destination
IFD_0013_GPSDestLatitudeRef=Reference for latitude of destination
IFD_0012_GPSMapDatum=Geodetic survey data used
IFD_0011_GPSImgDirection=Direction of image
IFD_0010_GPSImgDirectionRef=Reference for direction of image
IFD_000F_GPSTrack=Direction of movement
IFD_000E_GPSTrackRef=Reference for direction of movement
IFD_000D_GPSSpeed=Speed of GPS receiver
IFD_000C_GPSSpeedRef=Speed unit
IFD_000B_GPSDOP=Measurement precision
IFD_000A_GPSMeasureMode=GPS measurement mode
IFD_0009_GPSStatus=GPS receiver status
IFD_0008_GPSSatellites=GPS satellites used for measurement
IFD_0007_GPSTimeStamp=GPS time (atomic clock)
IFD_0006_GPSAltitude=Altitude
IFD_0005_GPSAltitudeRef=Altitude reference
IFD_0004_GPSLongitude=Longitude
IFD_0003_GPSLongitudeRef=East or West Longitude
IFD_0002_GPSLatitude=Latitude
IFD_0001_GPSLatitudeRef=North or South Latitude
IFD_0000_GPSVersionID=GPS tag version
UNKNOWN_TAG=Unknown Tag
IFD_A500_Gamma=Gamma
IFD_A435_LensSerialNumber=Lens serial number
IFD_A434_LensModel=Lens model
IFD_A433_LensMake=Lens make
IFD_A432_LensSpecification=Lens Specification
IFD_A431_BodySerialNumber=Body Serial Number
IFD_A430_CameraOwnerName=Camera Owner Name
IFD_A420_ImageUniqueID=Unique image ID
IFD_A40C_SubjectDistanceRange=Subject distance range
IFD_A40B_DeviceSettingDescription=Device settings description
IFD_A40A_Sharpness=Sharpness
IFD_A409_Saturation=Saturation
IFD_A408_Contrast=Contrast
IFD_A407_GainControl=Gain control
IFD_A406_SceneCaptureType=Scene capture type
IFD_A405_FocalLengthIn35mmFilm=Focal length in 35 mm film
IFD_A404_DigitalZoomRatio=Digital zoom ratio
IFD_A403_WhiteBalance=White balance
IFD_A402_ExposureMode=Exposure mode
IFD_A401_CustomRendered=Custom image processing
IFD_A302_CFAPattern=CFA pattern
IFD_A301_SceneType=Scene type
IFD_A300_FileSource=Fie source
IFD_A215_ExposureIndex=Exposure index
IFD_A214_SubjectLocation=Subject location
IFD_A210_FocalPlaneResolutionUnit=Focal plane resolution unit
IFD_A20F_FocalPlaneYResolution=Focal plane Y resolution
IFD_A20E_FocalPlaneXResolution=Focal plane X resolution
IFD_A20C_SpatialFrequencyResponse=Spatial frequency response
IFD_A20B_FlashEnergy=Flash energy
IFD_A005_Interoperability=Interoperability tag
IFD_A004_RelatedSoundFile=Related audio file
IFD_A003_PixelYDimension=Valid image height
IFD_A002_PixelXDimension=Valid image width
IFD_A001_ColorSpace=Color space information
IFD_A000_FlashpixVersion=Supported Flashpix version
IFD_9292_SubsecTimeDigitized=DateTime Digitized subseconds
IFD_9291_SubsecTimeOriginal=DateTime Original subseconds
IFD_9290_SubsecTime=DateTime Subseconds
IFD_9286_UserComment=User comments
IFD_927C_MakerNode=Manufacturer notes
IFD_9214_SubjectArea=Subject area
IFD_920A_FocalLength=Lens focal length
IFD_9209_Flash=Flash
IFD_9208_LightSource=Light source
IFD_9207_MeteringMode=Metering mode
IFD_9206_SubjectDistance=Subject distance
IFD_9205_MaxApertureValue=Maximum lens aperture
IFD_9204_ExposureBiasValue=Exposure bias
IFD_9203_BrightnessValue=Brightness
IFD_9202_ApertureValue=Aperture
IFD_9201_ShutterSpeedValue=Shutter speed
IFD_9102_CompressedBitsPerPixel=Image compression mode
IFD_9101_ComponentsConfiguration=Meaning of each component
IFD_9004_DateTimeDigitized=Date and time image was made digital data
IFD_9003_DateTimeOriginal=Date and time original image was generated
IFD_9000_ExifVersion=Exif version
IFD_8835_ISOSpeedLatitudezzz=ISO Speed Latitude zzz
IFD_8834_ISOSpeedLatitudeyyy=ISO Speed Latitude yyy
IFD_8833_ISOSpeed=ISO Speed
IFD_8832_RecommendedExposureIndex=Recommended Exposure Index
IFD_8831_StandardOutputSensitivity=Standard Output Sensitivity
IFD_8830_SensitivityType=Sensitivity Type
IFD_8828_OECF=Opto-Electric Conversion Function
IFD_8827_PhotographicSensitivity=Photographic Sensitivity
IFD_8825_GPS=GPS tag
IFD_8824_SpectralSensitivity=Spectral Sensitivity
IFD_8822_ExposureProgram=Exposure Program
IFD_8769_Exif=Exif tag
IFD_829D_FNumber=F-Number
IFD_829A_ExposureTime=Exposure Time
IFD_8298_Copyright=Copyright
IFD_0214_ReferenceBlackWhite=Reference Black White
IFD_0213_YCbCrPositioning=YCbCr Positioning
IFD_0212_YCbCrSubSampling=YCbCr Sub Sampling
IFD_0211_YCbCrCoefficients=YCbCr Coefficients
IFD_0209_JPEGACTables=JPEG AC Tables
IFD_0208_JPEGDCTables=JPEG DC Tables
IFD_0207_JPEGQTables=JPEG Q Tables
IFD_0206_JPEGPointTransforms=JPEG Point Transforms
IFD_0205_JPEGLosslessPredictors=JPEG Lossless Predictors
IFD_0203_JPEGRestartInterval=JPEG Restart Interval
IFD_0202_JPEGInterchangeFormatLength=JPEG Interchange Format Length
IFD_0201_JPEGInterchangeFormat=JPEG Interchange Format
IFD_0200_JPEGProc=JPEG Proc
IFD_0156_TransferRange=Transfer Range
IFD_0155_SMaxSampleValue=S Max Sample Value
IFD_0154_SMinSampleValue=S Min Sample Value
IFD_0153_SampleFormat=Sample Format
IFD_0152_ExtraSamples=Extra Samples
IFD_0151_TargetPrinter=Target Printer
IFD_0150_DotRange=Dot Range
IFD_014E_NumberOfInks=Number Of Inks
IFD_014D_InkNames=Ink Names
IFD_014C_InkSet=Ink Set
IFD_0145_TileByteCounts=Tile Byte Counts
IFD_0144_TileOffsets=Tile Offsets
IFD_0143_TileLength=Tile Length
IFD_0142_TileWidth=Tile Width
IFD_0141_HalftoneHints=Halftone Hints
IFD_0140_ColorMap=Color Map
IFD_013F_PrimaryChromaticities=Primary Chromaticities
IFD_013E_WhitePoint=White Point
IFD_013D_Predictor=Predictor
IFD_013C_HostComputer=Host Computer
IFD_013B_Artist=Artist
IFD_0132_DateTime=Date Time
IFD_0131_Software=Software
IFD_012D_TransferFunction=Transfer Function
IFD_0129_PageNumber=Page Number
IFD_0128_ResolutionUnit=Resolution Unit
IFD_0125_T6Options=T6 Options
IFD_0124_T4Options=T4 Options
IFD_0123_GrayResponseCurve=Gray Response Curve
IFD_0122_GrayResponseUnit=Gray Response Unit
IFD_0121_FreeByteCounts=Free Byte Counts
IFD_0120_FreeOffsets=Free Offsets
IFD_011F_YPosition=Y Position
IFD_011E_XPosition=X Position
IFD_011D_PageName=Page Name
IFD_011C_PlanarConfiguration=Planar Configuration
IFD_011B_YResolution=Y Resolution
IFD_011A_XResolution=X Resolution
IFD_0119_MaxSampleValue=Max Sample Value
IFD_0118_MinSampleValue=Min Sample Value
IFD_0117_StripByteCounts=Strip Byte Counts
IFD_0116_RowsPerStrip=Rows Per Strip
IFD_0115_SamplesPerPixel=Samples Per Pixel
IFD_0112_Orientation=Orientation
IFD_0111_StripOffsets=Strip Offsets
IFD_0110_Model=Model
IFD_010F_Make=Make
IFD_010E_ImageDescription=Image Description
IFD_010D_DocumentName=Document Name
IFD_010A_FillOrder=Fill Order
IFD_0109_CellLength=Cell Length
IFD_0108_CellWidth=Cell Width
IFD_0107_Threshholding=Thresh holding
IFD_0106_PhotometricInterpretation=Photometric Interpretation
IFD_0103_Compression=Compression
IFD_0102_BitsPerSample=Bits Per Sample
IFD_0101_ImageLength=Image Length
IFD_0100_ImageWidth=Image Width
IFD_00FF_SubfileType=Subfile Type
IFD_A217_SensingMethod=Sensing Method
IFD_0002_InteroperabilityVersion=Interoperability Version

```

`FormatJPEG/src/main/resources/org/binaryinternals/format/jpeg/tiff/ShortText.properties`:

```properties
# To change this template, choose Tools | Templates
# and open the template in the editor.

_dummy=_dummy
Numerator=Numerator
Denominator=Denominator
rational_n=unsigned rational[%d]
numerator_n=numerator: %d
denominator_n=denominator: %d
Offset_n=Offset: %d
Type_Rational=Unsigned Rational value
Type_SRational=Signed Rational value
srational_n=signed rational[%d]
Unused=Unused

```

`FormatPDF/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.pdf</artifactId>
    <version>0.6</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatPDF</name>
    <description>Portable Document Format (PDF), standardized as ISO 32000, is a file format developed by Adobe in 1993 to present documents, including text formatting and images, in a manner independent of application software, hardware, and operating systems.</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.pdf.PluginDescriptorPDF</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>

```

`FormatPDF/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatpdf {
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.pdf;
    exports org.binaryinternals.format.pdf.basicobj;
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/Comment.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * PDF Comment, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.2.3</code>: Comments.
 *
 * @author Amos Shi
 */
public class Comment extends FileComponent implements GenerateTreeNode {

    /**
     * Comment text.
     */
    public final String Text;

    Comment(PosDataInputStream stream, ASCIILine line) throws IOException {
        super.startPos = stream.getPos() - line.length();
        super.length = line.length();
        this.Text = line.line;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Comment");
        DefaultMutableTreeNode nodeComment = new DefaultMutableTreeNode(nodeComp);
        nodeComment.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                this.Text.length(),
                "Text")));
        nodeComment.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos + this.Text.length(),
                super.length - this.Text.length(),
                "New Line")));
        parentNode.add(nodeComment);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/CrossReferenceTable.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * PDF Cross-Reference Table, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.5.4</code>: Cross-Reference Table.
 *
 * @author Amos Shi
 */
public class CrossReferenceTable extends FileComponent implements GenerateTreeNode {

    static final String SIGNATURE = "xref";
    public final List<Subsection> Subsections = new ArrayList<Subsection>(5);
    /**
     * The first line current object.
     */
    public final ASCIILine HeaderLine;

    CrossReferenceTable(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        super.startPos = stream.getPos() - line.length();
        this.HeaderLine = line;
        this.parse(stream);

        // The Length
        super.length = line.length();
        for (Subsection subsection : Subsections) {
            super.length += subsection.getLength();
        }
    }

    private void parse(PosDataInputStream stream) throws IOException, FileFormatException {
        ASCIILine line;
        do {
            line = stream.readASCIILine();
            if (Trailer.SIGNATURE.equalsIgnoreCase(line.line)) {
                stream.backward(line.length());
                break;
            }
            this.Subsections.add(new Subsection(stream, line));
        } while (stream.hasNext());
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Cross Reference Table");
        nodeComp.setDescription(Texts.getString(Texts.PDF_CROSS_REFERENCE_TABLE));
        DefaultMutableTreeNode nodeCRT = new DefaultMutableTreeNode(nodeComp);
        parentNode.add(nodeCRT);

        int pos = this.startPos;
        nodeCRT.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.line.length(),
                Texts.Signature + SIGNATURE)));
        pos += this.HeaderLine.line.length();
        nodeCRT.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.newLineLength,
                "New Line")));

        for (Subsection subsection : Subsections) {
            subsection.generateTreeNode(nodeCRT);
        }
    }

    public static class Subsection extends FileComponent implements GenerateTreeNode {

        /**
         * First object number.
         */
        public final int FirstObjectNumber;
        /**
         * Number of entries.
         */
        public final int NumberOfEntries;
        /**
         * The first line of the Subsection.
         */
        public final ASCIILine HeaderLine;
        /**
         * Cross reference entries list.
         */
        public final List<Entry> Entries = new ArrayList<Entry>(20);

        Subsection(PosDataInputStream stream, ASCIILine line) throws FileFormatException, IOException {
            super.startPos = stream.getPos() - line.length();
            this.HeaderLine = line;

            String[] subsection_header = line.line.split(" ");
            if (subsection_header.length < 2) {
                throw new FileFormatException(String.format(
                        "This is not a valid Cross Reerence Table Subsection header. Postion [%d], text [%s].",
                        stream.getPos(),
                        line));
            }

            this.FirstObjectNumber = Integer.parseInt(subsection_header[0]);
            this.NumberOfEntries = Integer.parseInt(subsection_header[1]);
            for (int i = 0; i < this.NumberOfEntries; i++) {
                this.Entries.add(new Entry(stream));
            }

            super.length = line.length() + this.NumberOfEntries * Entry.LENGTH;
        }

        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            int pos = this.startPos;
            DefaultMutableTreeNode nodeSS = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    super.length,
                    String.format("Subsection: From %d Length %d", this.FirstObjectNumber, this.NumberOfEntries)));
            parentNode.add(nodeSS);

            nodeSS.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    this.HeaderLine.line.length(),
                    String.format("Header '%s'", this.HeaderLine))));
            pos += this.HeaderLine.line.length();
            nodeSS.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    this.HeaderLine.newLineLength,
                    "New Line")));

            for (Entry entry : Entries) {
                entry.generateTreeNode(nodeSS);
            }
        }
    }

    public static class Entry extends FileComponent implements GenerateTreeNode {

        public static final int LENGTH = 20;
        public static final int OFFSET_LENGTH = 10;
        public static final int GENERATIONNUMBER_LENGTH = 5;
        public static final char TYPE_IN_USE = 'n';
        public static final char TYPE_FREE = 'f';
        public final int Offset;
        public final int GenerationNumber;
        public final char Type;

        Entry(PosDataInputStream stream) throws IOException {
            super.startPos = stream.getPos();
            super.length = LENGTH;

            this.Offset = Integer.parseInt(stream.readASCII(OFFSET_LENGTH));
            BytesTool.skip(stream, 1);
            this.GenerationNumber = Integer.parseInt(stream.readASCII(GENERATIONNUMBER_LENGTH));
            BytesTool.skip(stream, 1);
            this.Type = (char) stream.readByte();
            BytesTool.skip(stream, 2);
        }

        /**
         * Get meaning of the {@link #Type} field.
         */
        public String getTypeMeaning() {
            String result = "Error";
            switch (this.Type) {
                case TYPE_IN_USE:
                    result = "In-Use (n)";
                    break;
                case TYPE_FREE:
                    result = "Free (f)";
                    break;
                default:
                    result = "ERROR!!! Un-recgonized";
                    break;
            }

            return result;
        }

        public void generateTreeNode(DefaultMutableTreeNode parentNode) {
            int pos = this.startPos;
            DefaultMutableTreeNode nodeEntry = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    super.length,
                    String.format("Entry %010d - %s", this.Offset, this.getTypeMeaning())));
            parentNode.add(nodeEntry);

            nodeEntry.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    OFFSET_LENGTH,
                    String.format("Offset: %d", this.Offset))));
            pos += OFFSET_LENGTH;
            nodeEntry.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    1,
                    "Separator")));
            pos += 1;
            nodeEntry.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    GENERATIONNUMBER_LENGTH,
                    String.format("Generation Number: %d", this.GenerationNumber))));
            pos += GENERATIONNUMBER_LENGTH;
            nodeEntry.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    1,
                    "Separator")));
            pos += 1;
            JTreeNodeFileComponent compType = new JTreeNodeFileComponent(
                    pos,
                    1,
                    String.format("Type - " + Character.toString(this.Type)));
            compType.setDescription(Texts.getString(Texts.PDF_CROSS_REFERENCE_TABLE_KEY));
            nodeEntry.add(new DefaultMutableTreeNode(compType));
            pos += 1;
            nodeEntry.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    2,
                    "End of Line")));
        }
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/EmptyLine.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * An empty line in the PDF file.
 *
 * @author Amos Shi
 */
public class EmptyLine extends FileComponent implements GenerateTreeNode {

    /**
     * The content of current line.
     */
    public final ASCIILine Line;

    EmptyLine(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        super.startPos = stream.getPos() - line.length();
        super.length = line.length();
        this.Line = line;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Empty Line");
        DefaultMutableTreeNode nodeEL = new DefaultMutableTreeNode(nodeComp);
        nodeEL.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                this.Line.line.length(),
                "Content")));
        nodeEL.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos + this.Line.line.length(),
                this.Line.newLineLength,
                Texts.NewLine)));
        parentNode.add(nodeEL);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/EndOfFile.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * PDF End of File (
 * <code>EOF</code>) object, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.5.5</code>: File Trailer.
 *
 * @author Amos Shi
 */
public class EndOfFile extends FileComponent implements GenerateTreeNode {

    static final String SIGNATURE = "%%EOF";
    /**
     * The content of current line.
     */
    public final ASCIILine Line;

    EndOfFile(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        super.startPos = stream.getPos() - line.length();
        super.length = line.length();
        this.Line = line;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "End of File");
        DefaultMutableTreeNode nodeEoF = new DefaultMutableTreeNode(nodeComp);

        nodeEoF.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                this.Line.line.length(),
                Texts.Signature + SIGNATURE)));
        nodeEoF.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos + this.Line.line.length(),
                this.Line.newLineLength,
                Texts.NewLine)));
        parentNode.add(nodeEoF);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/Header.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * PDF file Header. , see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.5.2</code>: File Header.
 *
 * @author Amos Shi
 */
public class Header extends FileComponent implements GenerateTreeNode {

    /**
     * The first line of a PDF file shall be a header consisting of the 5
     * characters %PDF– followed by a version number of the form 1.N, where N is
     * a digit between 0 and 7.
     */
    public static final String PDF_HEADER = "%PDF-";
    /**
     * PDF file version. Example:
     * <code>1.0</code>,
     * <code>1.1</code>,
     * <code>1.2</code>,
     * <code>1.3</code>,
     * <code>1.4</code>,
     * <code>1.5</code>,
     * <code>1.6</code>,
     * <code>1.7</code>, etc.
     */
    public final ASCIILine Version;

    Header(PosDataInputStream stream) throws IOException {
        super.startPos = 0;
        this.Version = stream.readASCIILine();
        super.length = stream.getPos() - super.startPos;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                this.getStartPos(),
                super.length,
                String.format("PDF Header: version = %s", this.Version.line));
        nodeComp.setDescription(Texts.getString(Texts.PDF_FILE_HEADER));
        DefaultMutableTreeNode treenodePDFHeader = new DefaultMutableTreeNode(nodeComp);

        int pos = this.startPos;
        treenodePDFHeader.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                PDF_HEADER.length(),
                "PDF Signature")));
        pos += PDF_HEADER.length();
        treenodePDFHeader.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.Version.line.length(),
                "PDF Version = " + this.Version)));
        pos += this.Version.line.length();
        treenodePDFHeader.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.Version.newLineLength,
                Texts.NewLine)));
        parentNode.add(treenodePDFHeader);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/IndirectObject.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.format.pdf.basicobj.Analysis;
import org.binaryinternals.format.pdf.basicobj.Reference;
import org.binaryinternals.format.pdf.basicobj.Stream;

/**
 * PDF Indirect Object, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.10</code>: Indirect Object.
 *
 * @author Amos Shi
 */
public class IndirectObject extends FileComponent implements GenerateTreeNode {

    /**
     * Start definition regular expression. <p> Example: </p>
     * <pre>
     *  5534 0 obj
     *  5491 0 obj SOME TEXT OF OBJECT
     *  5491 0 objSOME TEXT OF OBJECT
     * </pre>
     *
     */
    public static final String SIGNATURE_START_REGEXP = "\\d+.*\\d+.*obj.*";
    /**
     * Key word in the first line of current object.
     */
    public static final String SIGNATURE_START = "obj";
    /**
     * End line of current object.
     */
    public static final String SIGNATURE_END = "endobj";
    /**
     * A positive integer object number. <p> Indirect objects may be numbered
     * sequentially within a PDF file, but this is not required; object numbers
     * may be assigned in any arbitrary order. </p>
     */
    private final int objectNumber;
    /**
     * A non-negative integer generation number. <p> In a newly created file,
     * all indirect objects shall have generation numbers of 0. Nonzero
     * generation numbers may be introduced when the file is later updated. </p>
     */
    private final int generationNumber;
    /**
     * Length of {@link #objectNumber} and {@link #generationNumber}.
     */
    private final int numberLen;
    /**
     * The last line of the indirect object.
     */
    private final ASCIILine signatureStart;
    /**
     * The last line of the indirect object.
     */
    private ASCIILine signatureEnd;
    /**
     * Component of current object.
     */
    private List<FileComponent> components = Collections.synchronizedList(new ArrayList<FileComponent>(100));

    IndirectObject(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        stream.backward(line.length());
        super.startPos = stream.getPos();
        this.objectNumber = Integer.parseInt(stream.readASCIIUntil(PDFStatics.WhiteSpace.SP));
        this.generationNumber = Integer.parseInt(stream.readASCIIUntil(PDFStatics.WhiteSpace.SP));
        this.numberLen = stream.getPos() - super.startPos;
        BytesTool.skip(stream, SIGNATURE_START.length());
        byte b1 = stream.readByte();
        byte b2 = stream.readByte();
        if (b1 == PDFStatics.WhiteSpace.CR && b2 == PDFStatics.WhiteSpace.LF) {
            this.signatureStart = new ASCIILine(SIGNATURE_START, 2);
        } else if (b1 == PDFStatics.WhiteSpace.CR || b1 == PDFStatics.WhiteSpace.LF) {
            this.signatureStart = new ASCIILine(SIGNATURE_START, 1);
            stream.backward(1);
        } else {
            this.signatureStart = new ASCIILine(SIGNATURE_START, 0);
            stream.backward(2);
        }

        // parse
        this.parseStartEnd(stream);

        // Furthur parse
        this.parseObject(stream);
    }

    private void parseStartEnd(PosDataInputStream stream) throws IOException {
        ASCIILine line;
        do {
            line = stream.readASCIILine();
            if (line.line.length() == SIGNATURE_END.length() && SIGNATURE_END.equalsIgnoreCase(line.line)) {
                super.length = stream.getPos() - super.startPos;
                this.signatureEnd = line;
                break;
            }
        } while (stream.getPos() < (stream.getBuf().length - 1));
    }

    private void parseObject(PosDataInputStream root) throws IOException, FileFormatException {
        PosDataInputStream stream = root.getPartialStream(super.startPos + this.numberLen + this.signatureStart.length(),
                super.length - this.numberLen - this.signatureStart.length() - this.signatureEnd.length());

        // Filter Stream Object First
        ASCIILine line;
        List<FileComponent> compStreams = new ArrayList<FileComponent>(2);

        while (stream.hasNext()) {
            line = stream.readASCIILine();
            if (line.line.endsWith(Stream.SIGNATURE_START)) {
                compStreams.add(new Stream(stream, line));
            }
        }

        // -- Calculate the lastIndex
        int lastIndex = super.startPos + super.length - this.signatureEnd.length();
        if (compStreams.size() > 0) {
            for (FileComponent comp : compStreams) {
                if (comp instanceof Stream) {
                    lastIndex = (lastIndex > comp.getStartPos()) ? comp.getStartPos() : lastIndex;
                }
            }
        }

        int pos = super.startPos + this.numberLen + this.signatureStart.length();
        int len = lastIndex - pos;
        stream = root.getPartialStream(pos, len);
        FileComponent comp;
        Analysis analysis = new Analysis();

        while (stream.hasNext()) {
            comp = analysis.parseNextObject(stream, this.components);
            if (comp == null) {
                // To Ensure Continue Analysis
                byte next1 = stream.readByte();
                // Show error message
                System.out.println(String.format("ERROR ======== IndirectObject.parseObject() - Object number = %d, Generation number = %d, Location = %d (%X), Value = %s",
                        this.objectNumber,
                        this.generationNumber,
                        stream.getPos(),
                        stream.getPos(),
                        String.valueOf((char) next1)));
            }
        } // End while

        // Add the stream object we've found earlier
        if (compStreams.size() > 0) {
            for (FileComponent compStream : compStreams) {
                this.components.add(compStream);
            }
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Indirect Object: %d %d", this.objectNumber, this.generationNumber));
        nodeComp.setDescription(Texts.getString(Texts.PDF_INDIRECT_OBJECT));
        DefaultMutableTreeNode nodeIO = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeIO.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.numberLen,
                String.format("Object Number = %d, Generation Number = %d", this.objectNumber, this.generationNumber))));
        pos += this.numberLen;

        nodeIO.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.signatureStart.line.length(),
                Texts.Signature + this.signatureStart.line)));
        pos += this.signatureStart.line.length();

        if (this.signatureStart.newLineLength > 0) {
            nodeIO.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    this.signatureStart.newLineLength,
                    Texts.NewLine)));
            pos += this.signatureStart.newLineLength;
        }

        int contLen = super.length - this.numberLen - this.signatureStart.length() - this.signatureEnd.length();
        DefaultMutableTreeNode nodeContent;
        nodeIO.add(nodeContent = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                contLen,
                "Indirect Object Content")));

        for (FileComponent comp : this.components) {
            if (comp instanceof GenerateTreeNode) {
                ((GenerateTreeNode) comp).generateTreeNode(nodeContent);
            }
        }

        pos += contLen;
        nodeIO.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                SIGNATURE_END.length(),
                Texts.Signature + SIGNATURE_END)));
        pos += SIGNATURE_END.length();
        nodeIO.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.signatureEnd.newLineLength,
                Texts.NewLine)));

        parentNode.add(nodeIO);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/PDFFile.java`:

```java
/**
 * PDFFile.java May 17, 2011, 09:29
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved. 
 * Use is subject to license terms.
 */
package org.binaryinternals.format.pdf;

import java.io.File;
import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * PDF File Object.
 *
 * @author Amos Shi
 * @see <a href="http://www.adobe.com/devnet/pdf/pdf_reference.html">PDF
 * Reference</a>
 */
public class PDFFile extends FileFormat {

    public PDFFile(final File file) throws IOException, FileFormatException {
        super(file);
        this.parse();
    }

    private void parse() throws IOException, FileFormatException {
        PosDataInputStream stream = new PosDataInputStream(new PosByteArrayInputStream(super.fileByteArray));

        // File Header - Verify if this is an PDF file
        String pdfHeader = stream.readASCII(Header.PDF_HEADER.length());
        if (!Header.PDF_HEADER.equals(pdfHeader)) {
            throw new FileFormatException(String.format(
                    "This is not a PDF file. Expeted file header [%s], but it is [%s].",
                    Header.PDF_HEADER,
                    pdfHeader));
        }
        Header header = new Header(stream);
        super.addFileComponent(header);

        // Read PDF Components
        PosDataInputStream.ASCIILine line;
        while (stream.hasNext()) {
            line = stream.readASCIILine();

            if (line.line.equalsIgnoreCase(EndOfFile.SIGNATURE)) {                          // %%EOF
                super.addFileComponent(new EndOfFile(stream, line));
            } else if (line.line.charAt(0) == PDFStatics.DelimiterCharacter.PS_CHAR) {      // %, Comment line
                super.addFileComponent(new Comment(stream, line));
            } else if (line.line.matches(IndirectObject.SIGNATURE_START_REGEXP)) {          // 1 0 obj 
                super.addFileComponent(new IndirectObject(stream, line));
            } else if (line.line.trim().equalsIgnoreCase(CrossReferenceTable.SIGNATURE)) {  // xref
                super.addFileComponent(new CrossReferenceTable(stream, line));
            } else if (line.line.equalsIgnoreCase(Trailer.SIGNATURE)) {                     // trailer
                super.addFileComponent(new Trailer(stream, line));
            } else if (line.line.equalsIgnoreCase(StartXRef.SIGNATURE)) {                   // startxref
                super.addFileComponent(new StartXRef(stream, line));
            } else {
                super.addFileComponent(new EmptyLine(stream, line));
            }
        } // End While
    }

    @Override
    public String getContentTabName() {
        return "PDF File";
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode root) {
        super.components.values().stream().filter(comp -> (comp instanceof GenerateTreeNode)).forEachOrdered(comp -> {
            ((GenerateTreeNode) comp).generateTreeNode(root);
        });
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/PDFStatics.java`:

```java
package org.binaryinternals.format.pdf;

/**
 * Static values of PDF file definition.
 *
 * @author Amos
 */
public class PDFStatics {

    /**
     * See
     * <pre>PDF 32000-1:2008</pre>
     * <code>7.2.2</code>: Table 1 – White-space characters.
     */
    public static class WhiteSpace {

        /**
         * Null (NUL). <p>Value
         * <code>0x00</code>.</p>
         */
        public static final byte NUL = 0x00;
        /**
         * HORIZONTAL TAB (HT).<p>Value
         * <code>0x09</code>.</p>
         */
        public static final byte HT = 0x09;
        /**
         * LINE FEED (LF). New line character.<p>Value
         * <code>0x0A</code>.</p>
         */
        public static final byte LF = 0x0A;
        /**
         * FORM FEED (FF).<p>Value
         * <code>0x0C</code>.</p>
         */
        public static final byte FF = 0x0C;
        /**
         * CARRIAGE RETURN (CR).<p>Value
         * <code>0x0D</code>.</p>
         */
        public static final byte CR = 0x0D;
        /**
         * SPACE (SP). <p>Value
         * <code>0x20</code>.</p>
         */
        public static final byte SP = 0x20;
    }

    /**
     * See
     * <pre>PDF 32000-1:2008</pre>
     * <code>7.2.2</code>: Table 2 – Delimiter characters.
     */
    public static class DelimiterCharacter {

        /**
         * LEFT PARENTHESIS:
         * <code>(</code>.
         */
        public static final byte LP = 0x28;
        /**
         * RIGHT PARENTHESIS:
         * <code>)</code>.
         */
        public static final byte RP = 0x29;
        /**
         * LESS-THAN SIGN:
         * <code>&#60;</code>.
         */
        public static final byte LT = 0x3C;
        /**
         * GREATER-THAN SIGN:
         * <code>&#62;</code>.
         */
        public static final byte GT = 0x3E;
        /**
         * LEFT SQUARE BRACKET:
         * <code>[</code>.
         */
        public static final byte LS = 0x5B;
        /**
         * RIGHT SQUARE BRACKET:
         * <code>]</code>.
         */
        public static final byte RS = 0x5D;
        /**
         * LEFT CURLY BRACKET:
         * <code>{</code>.
         */
        public static final byte LC = 0x7B;
        /**
         * RIGHT CURLY BRACKET:
         * <code>}</code>.
         */
        public static final byte RC = 0x7D;
        /**
         * SOLIDUS:
         * <code>/</code>.
         */
        public static final byte SO = 0x2F;
        /**
         * PERCENT SIGN:
         * <code>%</code>.
         */
        public static final byte PS = 0x25;
        /**
         * PERCENT SIGN:
         * <code>%</code>.
         *
         * @see #PS
         */
        public static final char PS_CHAR = '%';
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/PluginDescriptorPDF.java`:

```java
/*
 * PluginDescriptorPDF.java    May 17, 2011, 09:26
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.pdf;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorPDF implements PluginDescriptor {

    @Override
    public String getExtensionDescription() {
        return "Portable Document Format (*.pdf)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"pdf"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return PDFFile.class;
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/StartXRef.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * PDF
 * <code>startxref</code> Object in File Trailer, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.5.5</code>: File Trailer.
 *
 * @author Amos Shi
 */
public class StartXRef extends FileComponent implements GenerateTreeNode {

    static final String SIGNATURE = "startxref";
    /**
     * The first line of current object.
     */
    public final ASCIILine HeaderLine;
    /**
     * Offset of the last cross-reference section.
     */
    public final int Offset;
    /**
     * {@link #Offset} line.
     */
    public final ASCIILine OffsetLine;

    StartXRef(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        super.startPos = stream.getPos() - line.length();
        this.HeaderLine = line;
        this.OffsetLine = stream.readASCIILine();
        this.Offset = Integer.parseInt(this.OffsetLine.line);
        super.length = stream.getPos() - super.startPos;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Start X Ref");
        DefaultMutableTreeNode nodeTrailer = new DefaultMutableTreeNode(nodeComp);
        parentNode.add(nodeTrailer);

        int pos = this.startPos;
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.line.length(),
                Texts.Signature + SIGNATURE)));
        pos += this.HeaderLine.line.length();
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.newLineLength,
                Texts.NewLine)));
        pos += this.HeaderLine.newLineLength;
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.OffsetLine.line.length(),
                String.format("Offset of last Cross Reference Section: %d (%08X)", this.Offset, this.Offset))));
        pos += this.OffsetLine.line.length();
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.OffsetLine.newLineLength,
                Texts.NewLine)));
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/Texts.java`:

```java
package org.binaryinternals.format.pdf;

import java.util.Locale;
import java.util.ResourceBundle;

/**
 * Texts used in User Interface.
 *
 * @author Amos Shi
 */
public class Texts {

    static final ResourceBundle MESSAGES = ResourceBundle.getBundle(Texts.class.getPackageName() + ".MessagesBundle", Locale.ROOT);
    public static final String NewLine = "New Line";
    public static final String Signature = "Signature: ";
    public static final String Space = "Space";

    public static String getString(String key) {
        return MESSAGES.getString(key);
    }
    public static final String PDF_FILE_HEADER = "PDF_FILE_HEADER";
    public static final String PDF_INDIRECT_OBJECT = "PDF_INDIRECT_OBJECT";
    public static final String PDF_CROSS_REFERENCE_TABLE = "PDF_CROSS_REFERENCE_TABLE";
    public static final String PDF_CROSS_REFERENCE_TABLE_KEY = "PDF_CROSS_REFERENCE_TABLE_KEY";
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/Trailer.java`:

```java
package org.binaryinternals.format.pdf;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * PDF File Trailer, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.5.5</code>: File Trailer.
 *
 * @author Amos Shi
 */
public class Trailer extends FileComponent implements GenerateTreeNode {

    static final String SIGNATURE = "trailer";
    /**
     * The first line of current object.
     */
    public final ASCIILine HeaderLine;

    Trailer(PosDataInputStream stream, ASCIILine line) throws IOException, FileFormatException {
        this.HeaderLine = line;
        super.startPos = stream.getPos() - line.length();
        this.parse(stream);
        super.length = stream.getPos() - super.startPos;
    }

    private void parse(PosDataInputStream stream) throws IOException, FileFormatException {
        ASCIILine line;
        do {
            line = stream.readASCIILine();
            if (StartXRef.SIGNATURE.equalsIgnoreCase(line.line)) {
                stream.backward(line.length());
                break;
            }
        } while (stream.hasNext());
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Trailer");
        DefaultMutableTreeNode nodeTrailer = new DefaultMutableTreeNode(nodeComp);
        parentNode.add(nodeTrailer);

        int pos = this.startPos;
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.line.length(),
                Texts.Signature + SIGNATURE)));
        pos += this.HeaderLine.line.length();
        nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.HeaderLine.newLineLength,
                Texts.NewLine)));
        pos += this.HeaderLine.newLineLength;
        int len = super.length - this.HeaderLine.length();
        if (len > 0) {
            nodeTrailer.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    pos,
                    len,
                    "Trailer Content")));
        }

    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Analysis.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import java.util.List;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.DefaultFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * Basic object analysis.
 *
 * @author Amos Shi
 */
public class Analysis {

    public FileComponent parseNextObject(PosDataInputStream stream, List<FileComponent> components) throws IOException {
        FileComponent comp;
        byte next1 = stream.readByte();
        byte next2;

        switch (next1) {
            case PDFStatics.WhiteSpace.LF:                                      // New Line
            case PDFStatics.WhiteSpace.CR:                                      // New Line
                comp = new DefaultFileComponent(stream.getPos() - 1, 1, Texts.NewLine);
                break;
            case PDFStatics.WhiteSpace.SP:                                      // ' '  - White Space
                comp = new DefaultFileComponent(stream.getPos() - 1, 1, Texts.Space);
                break;
            case PDFStatics.DelimiterCharacter.LP:                              //  '('  - Leteral String
                stream.backward(1);
                comp = new StringLiteral(stream);
                break;
            case PDFStatics.DelimiterCharacter.LT:
                next2 = stream.readByte();
                stream.backward(2);
                if (next2 == PDFStatics.DelimiterCharacter.LT) {                //  '<<' - Dictionary
                    comp = new Dictionary(stream);
                } else {
                    comp = new StringHexadecimal(stream);                       //  '<'  - Hexadecimal String
                }
                break;
            case PDFStatics.DelimiterCharacter.SO:                              //  '/' - Name
                stream.backward(1);
                comp = new Name(stream);
                break;
            case PDFStatics.DelimiterCharacter.LS:                              //  '[' - Array
                stream.backward(1);
                comp = new Array(stream);
                break;
            case Numeric.StartByte.SIGN_ADD:
            case Numeric.StartByte.SIGN_MINUS:
            case Numeric.StartByte.NUMBER_0:
            case Numeric.StartByte.NUMBER_1:
            case Numeric.StartByte.NUMBER_2:
            case Numeric.StartByte.NUMBER_3:
            case Numeric.StartByte.NUMBER_4:
            case Numeric.StartByte.NUMBER_5:
            case Numeric.StartByte.NUMBER_6:
            case Numeric.StartByte.NUMBER_7:
            case Numeric.StartByte.NUMBER_8:
            case Numeric.StartByte.NUMBER_9:
                stream.backward(1);
                comp = new Numeric(stream);
                break;
            case Boolean.StartByte.TRUE:
            case Boolean.StartByte.FALSE:
                stream.backward(1);
                comp = new Boolean(stream);                                     // 'true' 'false' - Boolean Object
                break;
            case Null.StartByte.NULL:
                stream.backward(1);
                comp = new Null(stream);                                        // 'null' - Null Object
                break;
            case Reference.SIGNATURE:
                stream.backward(1);
                comp = new Reference(stream);                                   // '9 0 R' - Reference Indirect Object

                this.MergeReferenceObjects(components, (Reference) comp);

                break;
            default:                                                            // Unknown
                stream.backward(1);
                comp = null;
                break;
        } // End Switch

        components.add(comp);
        return comp;
    }

    /**
     * Merge the former 2 objects before the {@link Reference} object 'R'. <p>
     * Example:
     * <pre>
     * 5 0 obj
     * /Type /XObject
     * /Subtype /Image
     * /Width 2038
     * /Height 171
     * /BitsPerComponent 4
     * /Length 347
     * /Filter 8 0 R
     * </pre> When we found the '
     * <code>R</code>', we need to merge the former
     * <code>8</code> and
     * <code>0</code> together with the
     * <code>R</code> object.
     */
    private void MergeReferenceObjects(List<FileComponent> components, Reference ref) {
        int size = components.size();

        boolean found = false;
        int pdfObjectCounter = 0;
        int i;
        for (i = size - 1; i >= 0; i--) {
            if (!(components.get(i) instanceof DefaultFileComponent)) {
                pdfObjectCounter++;
            }
            if (pdfObjectCounter == 2) {
                found = true;
                break;
            }
        }

        if (found) {
            for (int j = size - 1; j >= i; j--) {
                ref.formerComponents.add(0, components.get(j));
                components.remove(j);
            }
        }
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Array.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Array, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.6</code>: Array Objects.
 *
 * @author Amos Shi
 */
public class Array extends FileComponent implements GenerateTreeNode {

    /**
     * Component of current object.
     */
    private List<FileComponent> components = Collections.synchronizedList(new ArrayList<FileComponent>(31));

    Array(PosDataInputStream stream) throws IOException {
        // System.out.println("==== PDF Array");   // Deubg output
        super.startPos = stream.getPos();
        this.parse(stream);
        this.organizeArray();
        super.length = stream.getPos() - super.startPos;
    }

    private void parse(PosDataInputStream stream) throws IOException {
        // The '[' sign
        BytesTool.skip(stream, 1);

        FileComponent comp;
        Analysis analysis = new Analysis();

        byte next1;
        while (stream.hasNext()) {
            comp = analysis.parseNextObject(stream, this.components);
            if (comp == null) {
                next1 = stream.readByte();
                if (next1 == PDFStatics.DelimiterCharacter.RS) {
                    // Stop current Dictionary Object
                    // System.out.println("==== PDF Array -- Ends at " + stream.getPos());   // Deubg output
                    break;
                } else {
                    System.out.println(String.format("ERROR ======== Array.parse() - Location = %d (%X), Value = %s",
                            stream.getPos(), stream.getPos(), String.valueOf((char) next1)));
                }
            }
        } // End While
    }

    private void organizeArray() {
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Array Object");
        DefaultMutableTreeNode nodeArray = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeArray.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + (char) PDFStatics.DelimiterCharacter.LS)));
        pos += 1;

        int contLen = super.length - 1 - 1;
        DefaultMutableTreeNode nodeContent;
        nodeArray.add(nodeContent = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                contLen,
                "Array Content")));

        for (FileComponent comp : this.components) {
            if (comp instanceof GenerateTreeNode) {
                ((GenerateTreeNode) comp).generateTreeNode(nodeContent);
            }
        }

        pos += contLen;
        nodeArray.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + (char) PDFStatics.DelimiterCharacter.RS)));

        parentNode.add(nodeArray);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Boolean.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * PDF basic object Name, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.5</code>: Name Objects.
 *
 * @author Amos Shi
 */
public final class Boolean extends FileComponent implements GenerateTreeNode {

    public static final String VALUE_TRUE = "true";
    public static final String VALUE_FALSE = "false";
    /**
     * Name text in
     * <code>Raw</code> format.
     */
    private String RawText;

    Boolean(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.parse(stream);
        this.length = stream.getPos() - super.startPos;
        
        // System.out.println(this.toString());   // Deubg output
    }

    private void parse(PosDataInputStream stream) throws IOException {
        StringBuilder builder = new StringBuilder(6);
        byte b1 = stream.readByte();
        builder.append((char) b1);
        if (b1 == StartByte.TRUE) {
            builder.append(stream.readASCII(VALUE_TRUE.length() - 1));
        } else {
            builder.append(stream.readASCII(VALUE_FALSE.length() - 1));
        }
        this.RawText = builder.toString();
    }

    public boolean getValue() {
        boolean result = false;

        if (VALUE_TRUE.equalsIgnoreCase(this.RawText)) {
            result = true;
        } else if (VALUE_FALSE.equalsIgnoreCase(this.RawText)) {
            result = false;
        } else {
            throw new IllegalArgumentException(String.format(
                    "Unrecognized boolean value. Value text = '%s', Position = %d (0x%X)",
                    this.RawText,
                    this.startPos,
                    this.startPos));
        }

        return result;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Boolean Object");
        DefaultMutableTreeNode nodeName = new DefaultMutableTreeNode(nodeComp);

        nodeName.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                this.RawText)));

        parentNode.add(nodeName);
    }

    @Override
    public String toString() {
        return String.format("Boolean Object: Start Position = %d, Length = %d, Raw Text = '%s'",
                super.startPos,
                super.length,
                this.RawText);
    }

    public static class StartByte {

        /**
         * Start byte for
         * <code>true</code>.
         */
        public static final byte TRUE = 't';
        /**
         * Start byte for
         * <code>false</code>.
         */
        public static final byte FALSE = 'f';
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Dictionary.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.DefaultFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Dictionary, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.7</code>: Dictionary Object.
 *
 * @author Amos Shi
 */
public class Dictionary extends FileComponent implements GenerateTreeNode {

    /**
     * Signature indicates the start of current object.
     */
    public static final String SIGNATURE_START = "<<";
    /**
     * Signature indicates the end of current object.
     */
    public static final String SIGNATURE_END = ">>";
    /**
     * Component of current object.
     */
    private List<FileComponent> components = Collections.synchronizedList(new ArrayList<FileComponent>(31));
    /**
     * Dictionary entries. <p> The first element of each entry is the key and
     * the second element is the value. The key shall be a name {@link Name}.
     * The value may be any kind of object, including another dictionary. A
     * dictionary entry whose value is null {@link Null} shall be treated the
     * same as if the entry does not exist. </p> <p> The entries in a dictionary
     * represent an associative table and as such shall be unordered even though
     * an arbitrary order may be imposed upon them when written in a file. That
     * ordering shall be ignored. </p> <p> Multiple entries in the same
     * dictionary shall not have the same key. </p>
     */
    public final HashMap<String, FileComponent> DictionaryEntries = new HashMap<String, FileComponent>();

    Dictionary(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.parse(stream);
        this.organizeDictionary();
        super.length = stream.getPos() - super.startPos;

        // Debug Output
        System.out.println(this.toString());
        Iterator it = this.DictionaryEntries.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry pairs = (Map.Entry) it.next();
            System.out.println(pairs.getKey() + " = " + pairs.getValue());
            it.remove(); // avoids a ConcurrentModificationException
        } // End while
    }

    private void parse(PosDataInputStream stream) throws IOException {
        // The '<<' sign
        BytesTool.skip(stream, SIGNATURE_START.length());

        FileComponent comp;
        Analysis analysis = new Analysis();

        byte next1;
        byte next2;
        boolean stop = false;
        while (stream.hasNext()) {
            comp = analysis.parseNextObject(stream, this.components);
            if (comp == null) {
                next1 = stream.readByte();
                switch (next1) {
                    // Dictionary Ends
                    case PDFStatics.DelimiterCharacter.GT:
                        next2 = stream.readByte();
                        if (next2 == PDFStatics.DelimiterCharacter.GT) {
                            // Stop current Dictionary Object
                            stop = true;
                            // System.out.println("==== PDF Dictionary -- Ends at " + stream.getPos());   // Deubg output
                        }
                        break;
                    default:
                        System.out.println(String.format("ERROR ======== Dictionary.parse() - Location = %d (%X), Value = %s",
                                stream.getPos(), stream.getPos(), String.valueOf((char) next1)));
                        break;
                } // switch
                if (stop == true) {
                    break;   // Quit current while-loop
                }
            }
        } // End While
    }

    private void organizeDictionary() {
        String name = null;
        int counter = 0;
        for (FileComponent comp : this.components) {
            if (comp instanceof DefaultFileComponent) {
                continue;
            }

            counter++;

            if (counter == 1) {
                if (comp instanceof Name) {
                    name = ((Name) comp).getName();
                } else {
                    System.out.println("==== ERROR!!! Incorrect Dictionary Content. " + this.toString());
                    name = null;
                }
            } else if (counter == 2 && name != null) {
                this.DictionaryEntries.put(name, comp);
            }

            if (counter >= 2) {
                counter = 0;
            }
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Dictionary Object");
        DefaultMutableTreeNode nodeDic = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeDic.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                SIGNATURE_START.length(),
                Texts.Signature + SIGNATURE_START)));
        pos += SIGNATURE_START.length();

        int contLen = super.length - SIGNATURE_START.length() - SIGNATURE_END.length();
        DefaultMutableTreeNode nodeContent;
        nodeDic.add(nodeContent = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                contLen,
                "Dictionary Content")));

        for (FileComponent comp : this.components) {
            if (comp instanceof GenerateTreeNode) {
                ((GenerateTreeNode) comp).generateTreeNode(nodeContent);
            }
        }

        pos += contLen;
        nodeDic.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                SIGNATURE_END.length(),
                Texts.Signature + SIGNATURE_END)));

        parentNode.add(nodeDic);
    }

    @Override
    public String toString() {
        return String.format("Dictionary Object: Start Position = %d, Length = %d, Component Count = %d",
                super.startPos,
                super.length,
                this.components.size());
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Name.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Name, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.5</code>: Name Objects.
 *
 * @author Amos Shi
 */
public final class Name extends FileComponent implements GenerateTreeNode {

    /**
     * Name text in
     * <code>Raw</code> format.
     */
    private final String RawName;

    Name(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        BytesTool.skip(stream, 1);
        this.RawName = stream.readASCIIUntil(
                PDFStatics.WhiteSpace.SP,
                PDFStatics.WhiteSpace.LF,
                PDFStatics.WhiteSpace.CR,
                PDFStatics.DelimiterCharacter.LP,
                PDFStatics.DelimiterCharacter.RP,
                PDFStatics.DelimiterCharacter.LT,
                PDFStatics.DelimiterCharacter.GT,
                PDFStatics.DelimiterCharacter.LS,
                PDFStatics.DelimiterCharacter.RS,
                PDFStatics.DelimiterCharacter.LC,
                PDFStatics.DelimiterCharacter.RC,
                PDFStatics.DelimiterCharacter.SO,
                PDFStatics.DelimiterCharacter.PS);
        stream.backward(1);
        this.length = stream.getPos() - super.startPos; // The length includes 3 parts: '/' RawNameText ' '(Space at the End)
    }

    public String getName() {
        // TODO - Change to the .getName() - Issue: No test case until now.
        //        The following if-clause is used to search for such case
        if (this.RawName.contains("#")) {
            System.out.println(this.toString());
        }
        return this.RawName;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Name Object: " + this.getName());
        DefaultMutableTreeNode nodeName = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeName.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + (char) PDFStatics.DelimiterCharacter.SO)));
        pos += 1;

        int len = super.length - 1;
        nodeName.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                len,
                "Name = " + this.RawName)));

        parentNode.add(nodeName);
    }

    @Override
    public String toString() {
        return String.format("Name Object: Start Position = %d, Length = %d, Raw Name = '%s'",
                super.startPos,
                super.length,
                this.RawName);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Null.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * PDF basic object Null, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.9</code>: Null Object.
 *
 * @author Amos Shi
 */
public final class Null extends FileComponent implements GenerateTreeNode {

    public static final String VALUE = "null";
    /**
     * Name text in
     * <code>Raw</code> format.
     */
    private String RawText;

    Null(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.parse(stream);
        this.length = stream.getPos() - super.startPos;

        // System.out.println(this.toString());   // Deubg output
    }

    private void parse(PosDataInputStream stream) throws IOException {
        StringBuilder builder = new StringBuilder(6);
        byte b1 = stream.readByte();
        builder.append((char) b1);
        builder.append(stream.readASCII(VALUE.length() - 1));
        this.RawText = builder.toString();
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Null Object");
        DefaultMutableTreeNode nodeName = new DefaultMutableTreeNode(nodeComp);

        nodeName.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                this.RawText)));

        parentNode.add(nodeName);
    }

    @Override
    public String toString() {
        return String.format("Null Object: Start Position = %d (0x%X), Length = %d, Raw Text = '%s'",
                super.startPos,
                super.startPos,
                super.length,
                this.RawText);
    }

    public static class StartByte {

        /**
         * Start byte for
         * <code>null</code>.
         */
        public static final byte NULL = 'n';
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Numeric.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;

/**
 *
 * @author Amos
 */
public class Numeric extends FileComponent implements GenerateTreeNode {

    /**
     * Numeric text in
     * <code>Raw</code> format.
     */
    private final String RawNumberText;

    Numeric(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.RawNumberText = stream.readASCIIUntil(
                PDFStatics.WhiteSpace.SP,
                PDFStatics.WhiteSpace.CR,
                PDFStatics.WhiteSpace.LF,
                PDFStatics.DelimiterCharacter.LP,
                PDFStatics.DelimiterCharacter.RP,
                PDFStatics.DelimiterCharacter.LT,
                PDFStatics.DelimiterCharacter.GT,
                PDFStatics.DelimiterCharacter.LS,
                PDFStatics.DelimiterCharacter.RS,
                PDFStatics.DelimiterCharacter.LC,
                PDFStatics.DelimiterCharacter.RC,
                PDFStatics.DelimiterCharacter.SO,
                PDFStatics.DelimiterCharacter.PS);
        stream.backward(1);
        this.length = stream.getPos() - super.startPos;

        // System.out.println(this.toString());   // Deubg output
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Numeric Object: " + this.RawNumberText);
        DefaultMutableTreeNode nodeNum = new DefaultMutableTreeNode(nodeComp);

        nodeNum.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                this.RawNumberText)));

        parentNode.add(nodeNum);
    }
    
    @Override
    public String toString() {
        return String.format("Numeric Object: Start Position = %d, Length = %d, Raw Text = '%s'",
                super.startPos,
                super.length,
                this.RawNumberText);
    }    

    public static class StartByte {

        /**
         * Sign '+'.
         */
        public static final byte SIGN_ADD = 0x2B;
        /**
         * Sign '-'.
         */
        public static final byte SIGN_MINUS = 0x2D;
        /**
         * Number '0'.
         */
        public static final byte NUMBER_0 = 0x30;
        /**
         * Number '1'.
         */
        public static final byte NUMBER_1 = 0x31;
        /**
         * Number '2'.
         */
        public static final byte NUMBER_2 = 0x32;
        /**
         * Number '3'.
         */
        public static final byte NUMBER_3 = 0x33;
        /**
         * Number '4'.
         */
        public static final byte NUMBER_4 = 0x34;
        /**
         * Number '5'.
         */
        public static final byte NUMBER_5 = 0x35;
        /**
         * Number '6'.
         */
        public static final byte NUMBER_6 = 0x36;
        /**
         * Number '7'.
         */
        public static final byte NUMBER_7 = 0x37;
        /**
         * Number '8'.
         */
        public static final byte NUMBER_8 = 0x38;
        /**
         * Number '9'.
         */
        public static final byte NUMBER_9 = 0x39;
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Reference.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.Texts;

/**
 * Reference of PDF Indirect Object, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.10</code>: Indirect Object.
 *
 * @author Amos Shi
 */
public final class Reference extends FileComponent implements GenerateTreeNode {

    static final byte SIGNATURE = 'R';
    public final byte Value;
    /**
     * Component of current object.
     */
    protected List<FileComponent> formerComponents = Collections.synchronizedList(new ArrayList<FileComponent>(7));

    Reference(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.Value = stream.readByte();
        this.length = stream.getPos() - super.startPos;

        // System.out.println(this.toString());   // Deubg output
    }

    /**
     * Length of the former objects {@link #formerComponents}.
     */
    public int getFormerLength() {
        int len = 0;
        if (this.formerComponents.size() > 0) {
            for (FileComponent comp : this.formerComponents) {
                len += comp.getLength();
            }
        }
        return len;
    }

    /**
     * Need to call current method to get the object length, instead of using
     * the {@link #length} field because the reference object total length would
     * include the former 2 objects.
     */
    @Override
    public int getLength() {
        return this.getFormerLength() + this.length;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos - this.getFormerLength(),
                this.getLength(),
                "Refence to Indirect Object");
        DefaultMutableTreeNode nodeRef = new DefaultMutableTreeNode(nodeComp);

        for (FileComponent comp : this.formerComponents) {
            if (comp instanceof GenerateTreeNode) {
                ((GenerateTreeNode) comp).generateTreeNode(nodeRef);
            }
        }

        nodeRef.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                1,
                String.valueOf((char) this.Value))));

        parentNode.add(nodeRef);
    }

    @Override
    public String toString() {
        return String.format("Refence to Indirect Object: Start Position = %d, Length = %d, Raw Value = '%s'",
                super.startPos,
                super.length,
                (char) this.Value);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/Stream.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream.ASCIILine;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Stream, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.8</code>: Stream Objects.
 *
 * @author Amos Shi
 */
public class Stream extends FileComponent implements GenerateTreeNode {

    public static final String SIGNATURE_START = "stream";
    public static final String SIGNATURE_END = "endstream";
    /**
     * The signature length.
     */
    public final int signatureLen;
    public ASCIILine signatureEnd = null;

    public Stream(PosDataInputStream stream, PosDataInputStream.ASCIILine line) throws IOException, FileFormatException {
        this.signatureLen = SIGNATURE_START.length() + line.newLineLength;
        super.startPos = stream.getPos() - this.signatureLen;
        this.parse(stream);
        this.length = stream.getPos() - super.startPos;
    }

    private void parse(PosDataInputStream stream) throws IOException, FileFormatException {
        ASCIILine line;
        while (stream.hasNext()) {
            line = stream.readASCIILine();
            if (line.line.endsWith(Stream.SIGNATURE_END)) {
                this.signatureEnd = line;
            }
        }

        if (this.signatureEnd == null) {
            throw new FileFormatException(String.format(
                    "The 'endstream' tag is not found for current object. Object Start Offset = %d, Current Offset = %d",
                    super.startPos,
                    stream.getPos()));
        }
    }

    /**
     * Get the start position of the Encoded Stream Content.
     */
    public int getStreamStartPos() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    /**
     * Get the Encoded Stream Content Length of current {@link Stream} object.
     * <p> The content length does not include the signature
     * <code>stream</code> or
     * <code>endstream</code>. </p>
     */
    public int getStreamLength() {
        return this.length - this.signatureLen - 1 - this.signatureEnd.length();
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {

        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Stream");
        DefaultMutableTreeNode nodeStream = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                SIGNATURE_START.length(),
                Texts.Signature + SIGNATURE_START)));
        pos += SIGNATURE_START.length();

        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.signatureLen - SIGNATURE_START.length(),
                Texts.NewLine)));
        pos += (this.signatureLen - SIGNATURE_START.length());

        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.getStreamLength(),
                "Stream Content: Length = " + this.getStreamLength())));
        pos += this.getStreamLength();

        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.NewLine)));
        pos += 1;

        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.signatureEnd.line.length(),
                Texts.Signature + SIGNATURE_END)));
        pos += this.signatureEnd.line.length();

        nodeStream.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                this.signatureEnd.newLineLength,
                Texts.NewLine)));

        parentNode.add(nodeStream);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/StringHexadecimal.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Hexadecimal String, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.4.3</code>: Hexadecimal Strings.
 *
 * @author Amos Shi
 */
public final class StringHexadecimal extends FileComponent implements GenerateTreeNode {

    /**
     * String text in
     * <code>Raw</code> format.
     */
    private String RawText;

    StringHexadecimal(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        BytesTool.skip(stream, 1);
        //this.RawText = stream.readASCIIUntil(PDFStatics.DelimiterCharacter.GT);
        this.parse(stream);
        super.length = stream.getPos() - super.startPos;

        // System.out.println(this.toString());       // Deubg output
    }

    /**
     * Each pair of hexadecimal digits defines one byte of the string. <p>
     * White-space characters (such as SPACE (20h), HORIZONTAL TAB (09h),
     * CARRIAGE RETURN (0Dh), LINE FEED (0Ah), and FORM FEED (0Ch)) shall be
     * ignored. </p>
     */
    private void parse(PosDataInputStream stream) throws IOException {
        StringBuilder sb = new StringBuilder(100);
        byte b;

        do {
            b = stream.readByte();
            if (b != PDFStatics.WhiteSpace.SP
                    && b != PDFStatics.WhiteSpace.HT
                    && b != PDFStatics.WhiteSpace.CR
                    && b != PDFStatics.WhiteSpace.LF
                    && b != PDFStatics.WhiteSpace.FF
                    && b != PDFStatics.WhiteSpace.NUL
                    && b != PDFStatics.DelimiterCharacter.GT) {
                sb.append((char) b);
            }
        } while (b != PDFStatics.DelimiterCharacter.GT && stream.hasNext());

        this.RawText = sb.toString();
    }

    /**
     * Get the String format of the Hexadecimal String. <p> A hexadecimal string
     * shall be written as a sequence of hexadecimal digits (0–9 and either A–F
     * or a–f) encoded as ASCII characters and enclosed within angle brackets
     * (using LESS-THAN SIGN (3Ch) and GREATER-THAN SIGN (3Eh)). </p> <p> If the
     * final digit of a hexadecimal string is missing—that is, if there is an
     * odd number of digits—the final digit shall be assumed to be 0. </p>
     */
    public String getString() {

        int len = this.RawText.length();
        int lenHalf;
        String text;
        StringBuilder sb = new StringBuilder(20);

        if (len > 0) {
            if (len != ((len >> 1) << 1)) {
                text = this.RawText + "0";
            } else {
                text = this.RawText;
            }

            lenHalf = text.length() / 2;
            for (int i = 0; i < lenHalf; i++) {
                int beginIndex = i * 2;
                sb.append((char) Integer.valueOf(
                        text.substring(beginIndex, beginIndex + 2),
                        16).byteValue());
            }
        }

        return sb.toString();
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Hexadecimal String");
        nodeComp.setDescription("Raw String Text: " + this.RawText);
        DefaultMutableTreeNode nodeStr = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + PDFStatics.DelimiterCharacter.LT)));
        pos += 1;

        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                super.length - 2,
                "Raw Data")));
        pos += (super.length - 2);

        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + PDFStatics.DelimiterCharacter.GT)));

        parentNode.add(nodeStr);
    }

    @Override
    public String toString() {
        return String.format("Hexadecimal String Object: Start Position = %d, Length = %d, Raw Text = '%s'",
                super.startPos,
                super.length,
                this.RawText);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/StringLiteral.java`:

```java
package org.binaryinternals.format.pdf.basicobj;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.format.pdf.PDFStatics;
import org.binaryinternals.format.pdf.Texts;

/**
 * PDF basic object Literal String, see
 * <pre>PDF 32000-1:2008</pre>
 * <code>7.3.4.2</code>: Literal Strings.
 *
 * @author Amos Shi
 */
class StringLiteral extends FileComponent implements GenerateTreeNode {

    /**
     * Escape character in a literal string. <p> Within a literal string, the
     * REVERSE SOLIDUS is used as an escape character. The character immediately
     * following the REVERSE SOLIDUS determines its precise interpretation as
     * shown in Table 3. </p>
     */
    public static final byte REVERSE_SOLIDUS = '\\';
    /**
     * Literal String text in
     * <code>Raw</code> format.
     */
    private String RawText;

    public StringLiteral(PosDataInputStream stream) throws IOException {
        super.startPos = stream.getPos();
        this.parse(stream);
        super.length = stream.getPos() - super.startPos;
    }

    private void parse(PosDataInputStream stream) throws IOException {

        StringBuilder builder = new StringBuilder(32);

        // Parentheses Level.
        // - Balanced pairs of parentheses within a string require no special treatment.
        // - Example: (Strings may contain balanced parentheses ( ) and special characters (*!&}^% and so on).)
        int parentheseLevel = 0;  // 

        boolean stop = false;
        while (stream.hasNext()) {
            byte next = stream.readByte();
            switch (next) {
                // Escape 
                case REVERSE_SOLIDUS:
                    // Skip the charactor after REVERSE SOLIDUS
                    BytesTool.skip(stream, 1);
                    break;
                case PDFStatics.DelimiterCharacter.LP:
                    parentheseLevel++;
                    break;
                case PDFStatics.DelimiterCharacter.RP:
                    parentheseLevel--;
                    if (parentheseLevel <= 0) {
                        // To the end of current Liternal String
                        stop = true;
                    }
                    break;
                default:
                    builder.append((char) next);
                    break;
            }
            if (stop) {
                break;            // Stop current while-loop
            }
        }

        this.RawText = builder.toString();
    }

    public String getString() {
        // TODO - Change to the .getString()
        return this.RawText;
    }

    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        JTreeNodeFileComponent nodeComp = new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                "Literal String");
        nodeComp.setDescription("Raw String Text: " + this.RawText);
        DefaultMutableTreeNode nodeStr = new DefaultMutableTreeNode(nodeComp);

        int pos = super.startPos;
        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + (char) PDFStatics.DelimiterCharacter.LP)));
        pos += 1;

        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                super.length - 2,
                "Raw Data")));
        pos += (super.length - 2);

        nodeStr.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                pos,
                1,
                Texts.Signature + (char) PDFStatics.DelimiterCharacter.RP)));

        parentNode.add(nodeStr);
    }

    @Override
    public String toString() {
        return String.format("Literal String Object: Start Position = %d, Length = %d, Raw Text = '%s'",
                super.startPos,
                super.length,
                this.RawText);
    }
}

```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/basicobj/package.html`:

```html
<html>
    <head>
        <!--
        
          @(#)package.html    June 21, 2013
        
        -->
    </head>
    <body>

        <h2>Package Specification</h2>

        PDF 8 basic types of objects.

        <ol>
            <li>7.3.2 Boolean values</li>
            <li>7.3.3 Integer and Real numbers</li>
            <li>7.3.4 Strings</li>
            <li>7.3.5 Names</li>
            <li>7.3.6 Arrays</li>
            <li>7.3.7 Dictionaries</li>
            <li>7.3.8 Streams</li>
            <li>7.3.9 <code>null</code> object</li>
        </ol>

        For details, you may read PDF Reference section <code>7.3</code>.

        <h2>Related Documentation</h2>

        <ul>
            <li><a href="http://www.adobe.com/devnet/pdf/pdf_reference.html">PDF Reference and Adobe Extensions to the PDF Specification</a></li>
        </ul>

        <!-- Put @see and @since tags down here. -->
        @author Amos Shi

    </body>
</html>


```

`FormatPDF/src/main/java/org/binaryinternals/format/pdf/filter/package.html`:

```html
<html>
    <head>
        <!--
        
          @(#)package.html    June 21, 2013
        
        -->
    </head>
    <body>

        <h2>Package Specification</h2>

        PDF Filters.

        <ol>
            <li>7.4.2 ASCIIHexDecode Filter</li>
            <li>7.4.3 ASCII85Decode Filter</li>
            <li>7.4.4 LZWDecode and FlateDecode Filters</li>
            <li>7.4.5 RunLengthDecode Filter</li>
            <li>7.4.6 CCITTFaxDecode Filter</li>
            <li>7.4.7 JBIG2Decode Filter</li>
            <li>7.4.8 DCTDecode Filter</li>
            <li>7.4.9 JPXDecode Filter</li>
            <li>7.4.10 Crypt Filter</li>
        </ol>

        For details, you may read PDF Reference section <code>7.4</code>.

        <h2>Related Documentation</h2>

        <ul>
            <li><a href="http://www.adobe.com/devnet/pdf/pdf_reference.html">PDF Reference and Adobe Extensions to the PDF Specification</a></li>
        </ul>

        <!-- Put @see and @since tags down here. -->
        @author Amos Shi

    </body>
</html>


```

`FormatPDF/src/main/resources/org/binaryinternals/format/pdf/MessagesBundle.properties`:

```properties
PDF_FILE_HEADER=The first line of a PDF file shall be a header consisting of the 5 characters %PDF\u2013 followed by a version number of the form 1.N, where N is a digit between 0 and 7.
PDF_INDIRECT_OBJECT=Any object in a PDF file may be labelled as an indirect object. This gives the object a unique object identifier by which other objects can refer to it (for example, as an element of an array or as the value of a dictionary entry).
PDF_CROSS_REFERENCE_TABLE=The cross-reference table contains information that permits random access to indirect objects within the file so that the entire file need not be read to locate any particular object.
PDF_CROSS_REFERENCE_TABLE_KEY='n': an in-use entry; 'f': a free entry. There are two kinds of cross-reference entries: one for objects that are in use and another for objects that have been deleted and therefore are free. Both types of entries have similar basic formats, distinguished by the keyword n (for an in-use entry) or f (for a free entry).

```

`FormatPNG/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.png</artifactId>
    <version>1.1</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatPNG</name>
    <description>Portable Network Graphics (PNG) is a raster-graphics file format that supports lossless data compression.</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.png.PluginDescriptorPNG</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>

```

`FormatPNG/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatpng {
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.png;
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk.java`:

```java
/**
 * Chunk.java    Apr 21, 2011, 22:46
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see <a href="http://www.LIBPNG.org">PNG (Portable Network Graphics) Specification</a>
 */
public class Chunk extends FileComponent implements GenerateTreeNode {

    /**
     * A 4-byte unsigned integer giving the number of bytes in the chunk's data
     * field.
     * <p>
     * The length counts <strong>only</strong> the data field,
     * <strong>not</strong> itself, the chunk type code, or the CRC.
     * Zero is a valid length.
     * Although encoders and decoders should treat the length as unsigned,
     * its value must not exceed <code>2<sup>31</sup>-1</code> bytes.
     * </p>
     */
    public final int Length;
    /**
     * A 4-byte chunk type code.
     * <p>
     * For convenience in description and in examining PNG files, type codes
     * are restricted to consist of uppercase and lowercase ASCII letters
     * (A-Z and a-z, or 65-90 and 97-122 decimal).
     * However, encoders and decoders must treat the codes as fixed binary
     * values, not character strings.
     * For example, it would not be correct to represent the type code
     * <code>IDAT</code> by the EBCDIC equivalents of those letters.
     * Additional naming conventions for chunk types are discussed in the next
     * section.
     * </p>
     */
    public final byte[] ChunkType = new byte[PNGFile.CHUNK_TYPE_SIZE];
    /**
     * The data bytes appropriate to the chunk type, if any.
     * <p>
     * This field can be <code>null</code> for zero length.
     * </p>
     */
    public final byte[] ChunkData;
    /**
     * A 4-byte CRC (Cyclic Redundancy Check) calculated on the preceding bytes
     * in the chunk, including the chunk type code and chunk data fields,
     * but <strong>not</strong> including the length field.
     * <p>
     * The CRC is always present, even for chunks containing no data.
     * </p>
     */
    public final byte[] CRC = new byte[CRC_SIZE];
    
    /**
     * Size of {@link #CRC}.
     */
    private static final int CRC_SIZE = 4;

    Chunk(PosDataInputStream stream, PNGFile png) throws IOException {
        this.startPos = stream.getPos();

        this.Length = stream.readInt();  // Chunk Length
        this.length = this.Length + 12;

        // Chunk Type
        if (stream.read(this.ChunkType) != PNGFile.CHUNK_TYPE_SIZE) {
            throw new IOException("Read the chunk type field failed near position " + stream.getPos());
        }

        // Chunk Data
        if (this.Length > 0) {
            this.ChunkData = new byte[this.Length];
            if (stream.read(this.ChunkData) != this.Length) {
                throw new IOException("Read the chunk data failed near position " + stream.getPos());
            }
        } else {
            this.ChunkData = null;
        }

        // CRC
        if (stream.read(this.CRC) != CRC_SIZE) {
            throw new IOException("Read the CRC field failed near position " + stream.getPos());
        }
    }

    public String getChunkTypeName() {
        StringBuilder sb = new StringBuilder(this.ChunkType.length);
        sb.append((char) this.ChunkType[0]);
        sb.append((char) this.ChunkType[1]);
        sb.append((char) this.ChunkType[2]);
        sb.append((char) this.ChunkType[3]);
        return sb.toString();
    }

    protected final void checkLength(String chunkTypeName, int lengthExpected) throws FileFormatException {
        if (this.Length != lengthExpected) {
            throw new FileFormatException(String.format(
                    "Chunk (%s): chunk data length must be %d. current value = %d",
                    chunkTypeName,
                    lengthExpected,
                    this.Length));
        }
    }

    protected PosDataInputStream getChunkDataStream() {
        if (this.ChunkData != null) {
            return new PosDataInputStream(
                    new PosByteArrayInputStream(this.ChunkData),
                    this.startPos + 4 + 4);
        } else {
            return null;
        }
    }

    public void generateTreeNode(DefaultMutableTreeNode parent) {
        int start = this.startPos;
        DefaultMutableTreeNode chunkDataNode;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                4,
                String.format("Length = %d", this.Length))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 4,
                4,
                String.format("Chunk Type = %s", this.getChunkTypeName()))));

        start = start + 4;            // Or else when Lengh == 0, the 4 is not added
        if (this.Length > 0) {
            parent.add(chunkDataNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start, // start = start + 4
                    this.Length,
                    "Chunk Data")));
            this.generateTreeNodeChunkData(chunkDataNode);
        }
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start + this.Length,
                4,
                "CRC")));
    }

    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        System.out.println("Care me!");
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_IDAT.java`:

```java
/**
 * Chunk_IDAT.java    May 02, 2011, 11:23
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The IDAT chunk contains the actual image data.
 * <p>
 * The IDAT chunk contains the output data stream of the compression algorithm.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_IDAT extends Chunk {

    public static final String CHUNK_TYPE_NAME = "IDAT";

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType(){
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_IDAT(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                this.Length,
                "Image Data")));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_IEND.java`:

```java
/**
 * Chunk_IEND.java    Apr 30, 2011, 22:51
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import org.binaryinternals.commonlib.core.PosDataInputStream;

/**
 * Image trailer.
 * <p>
 * The <span>IEND</span> chunk must appear LAST.
 * It marks the end of the PNG data stream.
 * The chunk's data field is empty.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_IEND extends Chunk {

    public static final String CHUNK_TYPE_NAME = "IEND";

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType(){
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_IEND(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_IHDR.java`:

```java
/**
 * Chunk_IHDR.java    Apr 30, 2011, 11:58
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * Image header.
 * 
 * <p>
 * The <span>IHDR</span> chunk must appear FIRST.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_IHDR extends Chunk {

    public static final String CHUNK_TYPE_NAME = "IHDR";

    /**
     * Width and height give the image dimensions in pixels.
     * <p>
     * They are 4-byte integers.
     * Zero is an invalid value.
     * The maximum for each is <code>2<sup>31</sup>-1</code> in order to
     * accommodate languages that have difficulty with unsigned 4-byte values.
     * </p>
     */
    public final int Width;
    /**
     * Hight of image dimensions in pixels.
     * 
     * @see Chunk_IHDR#Width
     */
    public final int Height;
    /**
     * Bit depth is a single-byte integer giving the number of bits per sample
     * or per palette index (not per pixel).
     * <p>
     * Valid values are 1, 2, 4, 8, and 16, although not all values are allowed
     * for all color types.
     * </p>
     */
    public final int BitDepth;
    /**
     * Color type is a single-byte integer that describes the interpretation of
     * the image data.
     * <p>
     * Color type codes represent sums of the following values:
     * 1 (palette used), 2 (color used), and 4 (alpha channel used).
     * Valid values are 0, 2, 3, 4, and 6.
     * </p>
     */
    public final int ColorType;
    /**
     * Compression method is a single-byte integer that indicates the method
     * used to compress the image data.
     * <p>
     * At present, only compression method 0 (deflate/inflate compression with
     * a sliding window of at most 32768 bytes) is defined.
     * All standard PNG images must be compressed with this scheme.
     * The compression method field is provided for possible future expansion
     * or proprietary variants. Decoders must check this byte and report an
     * error if it holds an unrecognized code.
     * </p>
     */
    public final int CompressionMethod;
    /**
     * Filter method is a single-byte integer that indicates the preprocessing
     * method applied to the image data before compression.
     * <p>
     * At present, only filter method 0 (adaptive filtering with five basic
     * filter types) is defined. As with the compression method field, decoders
     * must check this byte and report an error if it holds an unrecognized code.
     * </p>
     */
    public final int FilterMethod;
    /**
     * Interlace method is a single-byte integer that indicates the transmission
     * order of the image data.
     * <p>
     * Two values are currently defined: 0 (no interlace) or 1 (Adam7 interlace).
     * </p>
     */
    public final int InterlaceMethod;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType(){
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_IHDR(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Width = chunkDataStream.readInt();
        this.Height = chunkDataStream.readInt();
        this.BitDepth = chunkDataStream.read();
        this.ColorType = chunkDataStream.read();
        this.CompressionMethod = chunkDataStream.read();
        this.FilterMethod = chunkDataStream.read();
        this.InterlaceMethod = chunkDataStream.read();
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                4,
                String.format("Width = %d", this.Width))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 4,
                4,
                String.format("Height = %d", this.Height))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 4,
                1,
                String.format("Bit depth = %d", this.BitDepth))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Color type = %d", this.ColorType))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Compression method = %d", this.CompressionMethod))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Filter method = %d", this.FilterMethod))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start + 1,
                1,
                String.format("Interlace method = %d", this.InterlaceMethod))));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_PLTE.java`:

```java
/**
 * Chunk_PLTE .java    May 01, 2011, 15:04
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * The <span>PLTE</span> chunk contains from 1 to 256 palette entries.
 * <p>
 * Each entry is a three-byte series of the form:
 * </p>
 * <pre>
 * Red:   1 byte (0 = black, 255 = red)
 * Green: 1 byte (0 = black, 255 = green)
 * Blue:  1 byte (0 = black, 255 = blue)
 * </pre>
 * <p>
 * The number of entries is determined from the chunk length.
 * A chunk length not divisible by 3 is an error.
 * </p>
 * 
 * @author Amos Shi
 */
public class Chunk_PLTE extends Chunk {

    public static final String CHUNK_TYPE_NAME = "PLTE";
    public final PaletteEntry[] Palette;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_PLTE(PosDataInputStream stream, PNGFile png) throws IOException, FileFormatException {
        super(stream, png);

        // A chunk length not divisible by 3 is an error.
        if ((this.Length % 3) != 0) {
            throw new FileFormatException(
                    String.format("The chunk data lengh cannot be divisible by 3. value = %d", this.Length));
        }

        // Palete entry number should be >= 1.
        int count = this.Length / 3;
        if (count < 1) {
            throw new FileFormatException(
                    String.format("The palette entry is invalid. count = %d", count));
        }

        this.Palette = new PaletteEntry[count];
        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        for (int i = 0; i < this.Palette.length; i++) {
            this.Palette[i] = new PaletteEntry(
                    chunkDataStream.read(),
                    chunkDataStream.read(),
                    chunkDataStream.read());
        }
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;
        DefaultMutableTreeNode node;

        for (int i = 0; i < this.Palette.length; i++) {
            parent.add(node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    3,
                    String.format("Palette entry [%d] = [%03d, %03d, %03d]",
                    i,
                    this.Palette[i].Red,
                    this.Palette[i].Green,
                    this.Palette[i].Blue))));

            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    1,
                    String.format("Red = %03d", this.Palette[i].Red))));
            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start + 1,
                    1,
                    String.format("Green = %03d", this.Palette[i].Green))));
            node.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start + 2,
                    1,
                    String.format("Blue = %03d", this.Palette[i].Blue))));
            start += 3;
        }
    }

    public static class PaletteEntry {

        public final int Red;
        public final int Green;
        public final int Blue;

        public PaletteEntry(int r, int g, int b) {
            this.Red = r;
            this.Green = g;
            this.Blue = b;
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_bKGD.java`:

```java
/**
 * Chunk_bKGD.java    May 01, 2011, 22:37
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>bKGD</span> chunk specifies a default background color to present
 * the image against.
 * <p>
 * Note that viewers are not bound to honor this chunk;
 * a viewer can choose to use a different background.
 * </p>
 * <p>
 * Note: For color type 3 (indexed color), only the field
 * <code>PaletteIndex</code> is valid.
 * For color types 0 and 4 (gray scale, with or without alpha), only the field
 * <code>Gray</code> is valid.
 * For color types 2 and 6 (true color, with or without alpha), only the fields
 * <code>Red</code>, <code>Green</code> and <code>Blue</code> are valid.
 * </p>
 * <p>
 * When a field is not valid, the value will be set as <code>-1</code>.
 * </p>
 * 
 * @author Amos Shi
 */
public class Chunk_bKGD extends Chunk {

    public static final String CHUNK_TYPE_NAME = "bKGD";

    /**
     * The value is the palette index of the color to be used as background.
     * <p>
     * For color type 3 (indexed color), the <span>bKGD</span> chunk contains:
     * </p>
     * <pre>
     * Palette index:  1 byte
     * </pre>
     */
    public final int PaletteIndex;
    /**
     * The value is the gray level to be used as background.
     * <p>
     * For color types 0 and 4 (gray scale, with or without alpha),
     * <span>bKGD</span> contains:
     * </p>
     * <pre>
     * Gray:  2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * </pre>
     * <p>
     * If the image bit depth is less than 16, the least significant bits
     * are used and the others are 0.
     * </p>
     */
    public final int Gray;
    /**
     * This is the RGB color to be used as background.
     * <p>
     * For color types 2 and 6 (true color, with or without alpha),
     * <span>bKGD</span> contains:
     * </p>
     * <pre>
     * Red:   2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * Green: 2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * Blue:  2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * </pre>
     * <p>
     * If the image bit depth is less than 16, the least significant bits are
     * used and the others are 0.
     * </p>
     */
    public final int Red;
    /**
     * Refer to field <code>Red</code>.
     *
     * @see Chunk_bKGD#Red
     */
    public final int Green;
    /**
     * Refer to field <code>Red</code>.
     *
     * @see Chunk_bKGD#Red
     */
    public final int Blue;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_bKGD(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        switch(this.ChunkData.length) {
            case 1:
                this.PaletteIndex = chunkDataStream.read();
                this.Gray = -1;
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                break;
            case 2:
                this.PaletteIndex = -1;
                this.Gray = chunkDataStream.readShort();
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                break;
            case 6:
                this.PaletteIndex = -1;
                this.Gray = -1;
                this.Red = chunkDataStream.readShort();
                this.Green = chunkDataStream.readShort();
                this.Blue = chunkDataStream.readShort();
                break;
            default:
                // Un-recognized
                this.PaletteIndex = -1;
                this.Gray = -1;
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                break;
        }
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        switch (this.ChunkData.length) {
            case 1:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("Palette index = %d", this.PaletteIndex))));
                break;

            case 2:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        2,
                        String.format("Gray = %d", this.Gray))));
                break;

            case 6:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        2,
                        String.format("Red = %d", this.Red))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 2,
                        2,
                        String.format("Green = %d", this.Green))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 4,
                        2,
                        String.format("Blue = %d", this.Blue))));
                break;

            default:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        this.ChunkData.length,
                        "Un-recognized")));
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_cHRM.java`:

```java
/**
 * Chunk_cHRM.java    May 02, 2011, 09:31
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * Applications that need device-independent specification of colors in a PNG
 * file can use the <span>cHRM</span> chunk to specify the 1931 CIE
 * <code>x,y</code> chromaticities of the red, green, and blue primaries used
 * in the image, and the referenced white point.
 * <p>
 * The <span>cHRM</span> chunk contains:
 * </p>
 * <pre>
 * White Point x: 4 bytes
 * White Point y: 4 bytes
 * Red x:         4 bytes
 * Red y:         4 bytes
 * Green x:       4 bytes
 * Green y:       4 bytes
 * Blue x:        4 bytes
 * Blue y:        4 bytes
 * </pre>
 * <p>
 * Each value is encoded as a 4-byte unsigned integer, representing the
 * <code>x</code> or <code>y</code> value times 100000.
 * For example, a value of 0.3127 would be stored as the integer 31270.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_cHRM extends Chunk {

    public static final String CHUNK_TYPE_NAME = "cHRM";
    public final int WhitePointX;
    public final int WhitePointY;
    public final int RedX;
    public final int RedY;
    public final int GreenX;
    public final int GreenY;
    public final int BlueX;
    public final int BlueY;
    public final double WhitePointX_value;
    public final double WhitePointY_value;
    public final double RedX_value;
    public final double RedY_value;
    public final double GreenX_value;
    public final double GreenY_value;
    public final double BlueX_value;
    public final double BlueY_value;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_cHRM(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.WhitePointX = chunkDataStream.readInt();
        this.WhitePointY = chunkDataStream.readInt();
        this.RedX = chunkDataStream.readInt();
        this.RedY = chunkDataStream.readInt();
        this.GreenX = chunkDataStream.readInt();
        this.GreenY = chunkDataStream.readInt();
        this.BlueX = chunkDataStream.readInt();
        this.BlueY = chunkDataStream.readInt();
        this.WhitePointX_value = ((double)this.WhitePointX) / 100000;
        this.WhitePointY_value = ((double)this.WhitePointY) / 100000;
        this.RedX_value = ((double)this.RedX) / 100000;
        this.RedY_value = ((double)this.RedY) / 100000;
        this.GreenX_value = ((double)this.GreenX) / 100000;
        this.GreenY_value = ((double)this.GreenY) / 100000;
        this.BlueX_value = ((double)this.BlueX) / 100000;
        this.BlueY_value = ((double)this.BlueY) / 100000;
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                4,
                String.format("While Point x = %05d or %f", this.WhitePointX, this.WhitePointX_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("While Point y = %05d or %f", this.WhitePointY, this.WhitePointY_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("Red x = %05d or %f", this.RedX, this.RedX_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("Red y = %05d or %f", this.RedY, this.RedY_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("Green x = %05d or %f", this.GreenX, this.GreenX_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("Green y = %05d or %f", this.GreenY, this.GreenY_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 4,
                4,
                String.format("Blue x = %05d or %f", this.BlueX, this.BlueX_value))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start + 4,
                4,
                String.format("Blue y = %05d or %f", this.BlueY, this.BlueY_value))));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_gAMA.java`:

```java
/**
 * Chunk_gAMA.java    May 01, 2011, 11:33
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>gAMA</span> chunk specifies the relationship between the image 
 * samples and the desired display output intensity as a power function.
 *
 * 
 * @author Amos Shi
 */
public class Chunk_gAMA extends Chunk {

    public static final String CHUNK_TYPE_NAME = "gAMA";

    public final int Gamma;
    public final double Value;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_gAMA(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Gamma = chunkDataStream.readInt();
        this.Value = (1/((double)this.Gamma))*100000;
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                4,
                String.format("Gama = %d or 1/%f", this.Gamma, this.Value))));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_hIST.java`:

```java
/**
 * Chunk_hIST.java    May 02, 2011, 11:33
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>hIST</span> chunk gives the approximate usage frequency of each
 * color in the color palette.
 * <p>
 * A <span>hIST</span> chunk can appear only when a <span>PLTE</span> chunk
 * appears. If a viewer is unable to provide all the colors listed in the
 * palette, the histogram may help it decide how to choose a subset of the
 * colors for display.
 * </p>
 * <p>
 * The <span>hIST</span> chunk contains a series of 2-byte (16 bit) unsigned
 * integers. There must be exactly one entry for each entry in the
 * <span>PLTE</span> chunk. Each entry is proportional to the fraction of pixels
 * in the image that have that palette index; the exact scale factor is chosen
 * by the encoder.
 * </p>
 * 
 * @author Amos Shi
 */
public class Chunk_hIST extends Chunk {

    public static final String CHUNK_TYPE_NAME = "hIST";
    public final int[] Frequency;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_hIST(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        int count = this.Length / 2;

        if (count > 0) {
            PosDataInputStream chunkDataStream = super.getChunkDataStream();
            this.Frequency = new int[count];
            for (int i = 0; i < count; i++) {
                this.Frequency[i] = chunkDataStream.readUnsignedShort();
            }
        } else {
            this.Frequency = null;
        }
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        if (this.Frequency == null) {
            return;
        }

        for (int i = 0; i < this.Frequency.length; i++) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    2,
                    String.format("Frequency [%d] = %d", i, this.Frequency[i]))));
            start += 2;
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_iTXt.java`:

```java
/**
 * Chunk_iEXt.java    May 04, 2011, 16:05
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * This chunk is semantically equivalent to the <span>tEXt</span> and
 * <span>zTXt</span> chunks, but the textual data is in the UTF-8 encoding of
 * the Unicode character set instead of Latin-1.
 * <p>
 * This chunk contains:
 * </p>
 * <pre>
 * Keyword:             1-79 bytes (character string)
 * Null separator:      1 byte
 * Compression flag:    1 byte
 * Compression method:  1 byte
 * Language tag:        0 or more bytes (character string)
 * Null separator:      1 byte
 * Translated keyword:  0 or more bytes
 * Null separator:      1 byte
 * Text:                0 or more bytes
 * </pre>
 *
 * @author Amos Shi
 * @see Chunk_tEXt
 * @see Chunk_zTXt
 */
public class Chunk_iTXt extends Chunk {

    public static final String CHUNK_TYPE_NAME = "iTXt";
    /**
     * Refer to {@link Chunk_tEXt#Keyword}.
     * 
     * @see Chunk_tEXt#Keyword
     */
    public final String Keyword;
    /**
     * The compression flag is 0 for uncompressed text, 1 for compressed text.
     * Only the text field may be compressed.
     */
    public final int CompressionFlag;
    /**
     * The only value presently defined for the compression method byte is 0,
     * meaning zlib data stream with deflate compression.
     * For uncompressed text, encoders should set the compression method to 0
     * and decoders should ignore it.
     */
    public final int CompressionMethod;
    /**
     * The language tag [RFC-1766] indicates the human language used by the
     * translated keyword and the text.
     * Unlike the keyword, the language tag is case-insensitive.
     * It is an ASCII [ISO-646] string consisting of hyphen-separated words of
     * 1-8 letters each (for example: cn, en-uk, no-bok, x-klingon).
     * If the first word is two letters long, it is an ISO language code
     * [ISO-639]. If the language tag is empty, the language is unspecified.
     */
    // TODO - language tag [RFC-1766]
    // TODO - ASCII [ISO-646] string
    public final String LanguageTag;
    /**
     * The translated keyword and text both use the UTF-8 encoding of the
     * Unicode character set [ISO/IEC-10646-1], and neither may contain a zero
     * byte (null character).
     */
    // TODO - UTF-8 encoding, [ISO/IEC-10646-1]
    public final byte[] TranslatedKeyword;
    public final String TranslatedKeywordString = null;  // TODO - Parse the text
    /**
     * The text, unlike the other strings, is not null-terminated; its length is
     * implied by the chunk length.
     *
     * @see #TranslatedKeyword
     */
    public final byte[] Text;
    public final String TextString = null;  // TODO - Parse the text

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_iTXt(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Keyword = chunkDataStream.readASCII();
        this.CompressionFlag = chunkDataStream.read();
        this.CompressionMethod = chunkDataStream.read();
        this.LanguageTag = chunkDataStream.readASCII();
        this.TranslatedKeyword = chunkDataStream.readBinary();

        int rest = this.Length
                - this.Keyword.length() - 1
                - 1 - 1
                - this.LanguageTag.length() - 1;
        if (this.TranslatedKeyword.length > 0) {
            rest -= this.TranslatedKeyword.length;
        }
        rest -= 1;
        if (rest > 0) {
            this.Text = new byte[rest];
            if (chunkDataStream.read(this.Text) != rest) {
                throw new IOException("Read the text field failed near position " + chunkDataStream.getPos());
            }
        } else {
            this.Text = null;
        }
    }

    @Override
    public String toString() {
        return String.format("%s: %s", this.Keyword, this.Text);
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                this.Keyword.length(),
                String.format("Keyword = %s", this.Keyword))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += this.Keyword.length(),
                1,
                "Null separator")));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 1,
                1,
                String.format("Compression flag = %d", this.CompressionFlag))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 1,
                1,
                String.format("Compression method = %d", this.CompressionMethod))));
        if (this.LanguageTag.length() > 0) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += 1,
                    this.LanguageTag.length(),
                    String.format("Language tag = %s", this.LanguageTag))));
            start += this.LanguageTag.length();
        }
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                1,
                "Null separator")));
        if (this.TranslatedKeyword != null) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += 1,
                    this.TranslatedKeyword.length,
                    "Translated keyword")));
            start += this.TranslatedKeyword.length;
        }
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                1,
                "Null separator")));

        if (this.Text != null) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += 1,
                    this.Text.length,
                    "Text")));
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_pHYs.java`:

```java
/**
 * Chunk_pHYs.java    Apr 30, 2011, 23:01
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>pHYs</span> chunk specifies the intended pixel size or aspect ratio for display
 * of the image.
 *
 * @author Amos Shi
 */
public class Chunk_pHYs extends Chunk {

    public static final String CHUNK_TYPE_NAME = "pHYs";
    /** Pixels per unit, X axis.   */
    public final int AxisX;
    /** Pixels per unit, Y axis.   */
    public final int AxisY;
    /**
     * Unit specifier.
     * <pre>
     * 0: unit is unknown
     * 1: unit is the meter
     * </pre>
     */
    public final int Unit;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_pHYs(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.AxisX = chunkDataStream.readInt();
        this.AxisY = chunkDataStream.readInt();
        this.Unit = chunkDataStream.read();
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                4,
                String.format("Pixels per unit, X axis = %d", this.AxisX))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 4,
                4,
                String.format("Pixels per unit, Y axis = %d", this.AxisY))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start + 4,
                1,
                String.format("Unit specifier = %d", this.Unit))));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_sBIT.java`:

```java
/**
 * Chunk_sBIT.java    May 01, 2011, 17:06
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>sBIT</span> chunk is provided in order to store the original number
 * of significant bits.
 *
 * @author Amos Shi
 */
public class Chunk_sBIT extends Chunk {

    public static final String CHUNK_TYPE_NAME = "sBIT";

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_sBIT(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        switch (this.ChunkData.length) {
            case 1:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("significant = %d", this.ChunkData[0]))));
                break;

            case 2:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("significant source grayscale data = %d", this.ChunkData[0]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 1,
                        1,
                        String.format("significant source alpha data = %d", this.ChunkData[1]))));
                break;

            case 3:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("significant red = %d", this.ChunkData[0]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 1,
                        1,
                        String.format("significant green = %d", this.ChunkData[1]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 2,
                        1,
                        String.format("significant blue = %d", this.ChunkData[2]))));
                break;

            case 4:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("significant red = %d", this.ChunkData[0]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 1,
                        1,
                        String.format("significant green = %d", this.ChunkData[1]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 2,
                        1,
                        String.format("significant blue = %d", this.ChunkData[2]))));
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start + 3,
                        1,
                        String.format("significant alpha = %d", this.ChunkData[3]))));
                break;

            default:
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        this.ChunkData.length,
                        "Un-recognized")));
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_sPLT.java`:

```java
/**
 * Chunk_hIST.java    May 02, 2011, 11:33
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 * This chunk can be used to suggest a reduced palette to be used when the 
 * display device is not capable of displaying the full range of colors present
 * in the image.
 * <p>
 * If present, it provides a recommended set of colors, with alpha and frequency
 * information, that can be used to construct a reduced palette to which the 
 * PNG image can be quantized.
 * </p>
 * <p>
 * This chunk contains a null-terminated text string that names the palette and
 * a one-byte sample depth, followed by a series of palette entries, each a 
 * six-byte or ten-byte series containing five unsigned integers:
 * </p>
 * <pre>
 * Palette name:    1-79 bytes (character string)
 * Null terminator: 1 byte
 * Sample depth:    1 byte
 * Red:             1 or 2 bytes
 * Green:           1 or 2 bytes
 * Blue:            1 or 2 bytes
 * Alpha:           1 or 2 bytes
 * Frequency:       2 bytes
 * ...etc...
 * </pre>
 * <p>
 * There can be any number of entries; a decoder determines the number of 
 * entries from the remaining chunk length after the sample depth byte.
 * It is an error if this remaining length is not divisible by 6 (if the 
 * <span>sPLT</span> sample depth is 8) or by 10 (if the <span>sPLT</span> 
 * sample depth is 16).
 * Entries must appear in decreasing order of frequency.
 * There is no requirement that the entries all be used by the image, nor that
 * they all be different.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_sPLT extends Chunk {

    public static final String CHUNK_TYPE_NAME = "sPLT";
    /**
     * The palette name can be any convenient name for referring to the palette
     * (for example, "256 color including Macintosh default", "256 color
     * including Windows-3.1 default", "Optimal 512").
     * <p>
     * It may help applications or people to choose the appropriate suggested
     * palette when more than one appears in a PNG file.
     * The palette name is case-sensitive and subject to the same restrictions
     * as a text keyword: it must contain only printable Latin-1
     * [ISO/IEC-8859-1] characters (33-126 and 161-255) and spaces (32), but no
     * leading, trailing, or consecutive spaces.
     * </p>
     */
    public final String PaletteName;
    /**
     * The sPLT sample depth must be 8 or 16.
     */
    public final int SampleDepth;
    public final SuggestedPaletteEntry[] SuggestedPalette;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_sPLT(PosDataInputStream stream, PNGFile png) throws IOException, FileFormatException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.PaletteName = chunkDataStream.readASCII();
        this.SampleDepth = chunkDataStream.read();
        if (this.SampleDepth != 8 && this.SampleDepth != 16) {
            throw new FileFormatException(String.format(
                    "Invalid 'Sample depth' for sPLT chunk. value = %d, expected value = 8 or 16", this.SampleDepth));
        }

        int plteLength = this.Length - this.PaletteName.length() - 1 - 1;
        int plteCount;
        switch (this.SampleDepth) {
            case 8:
                if (plteLength % 6 != 0) {
                    throw new FileFormatException(String.format(
                            "Invalid sPLT chunk since palette lenth is not divisible by 6. value = %d", plteLength));
                }
                plteCount = plteLength / 6;
                if (plteCount > 0) {
                    this.SuggestedPalette = new SuggestedPaletteEntry[plteCount];
                    for (int i = 0; i < plteCount; i++) {
                        this.SuggestedPalette[i] = new SuggestedPaletteEntry(
                                chunkDataStream.read(),
                                chunkDataStream.read(),
                                chunkDataStream.read(),
                                chunkDataStream.read(),
                                chunkDataStream.readUnsignedShort());
                    }
                } else {
                    this.SuggestedPalette = null;
                }
                break;
            case 16:
                if (plteLength % 10 != 0) {
                    throw new FileFormatException(String.format(
                            "Invalid sPLT chunk since palette lenth is not divisible by 10. value = %d", plteLength));
                }
                plteCount = plteLength / 10;
                if (plteCount > 0) {
                    this.SuggestedPalette = new SuggestedPaletteEntry[plteCount];
                    for (int i = 0; i < plteCount; i++) {
                        this.SuggestedPalette[i] = new SuggestedPaletteEntry(
                                chunkDataStream.readUnsignedShort(),
                                chunkDataStream.readUnsignedShort(),
                                chunkDataStream.readUnsignedShort(),
                                chunkDataStream.readUnsignedShort(),
                                chunkDataStream.readUnsignedShort());
                    }
                } else {
                    this.SuggestedPalette = null;
                }
                break;
            default:
                this.SuggestedPalette = null;
                break;
        }
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                this.PaletteName.length(),
                String.format("Palette name = %s", this.PaletteName))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += this.PaletteName.length(),
                1,
                "Null terminator")));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 1,
                1,
                String.format("Sample depth = %d", this.SampleDepth))));
        start += 1;

        if (this.SuggestedPalette == null) {
            return;
        }

        DefaultMutableTreeNode entryNode;
        int i = 0;
        int entryLength = 0, entrySize = 0;
        for (SuggestedPaletteEntry entry : this.SuggestedPalette) {
            switch (this.SampleDepth) {
                case 8:
                    entryLength = 6;
                    entrySize = 1;
                    break;
                case 16:
                    entryLength = 10;
                    entrySize = 2;
                    break;
                default:
                    // Do nothing since not possible
                    break;
            }

            parent.add(entryNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    entryLength,
                    String.format("Suggested Palette entry [%d] = %s", i, entry.toString()))));

            entryNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    entrySize,
                    String.format("Red = %03d", entry.Red))));
            entryNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += entrySize,
                    entrySize,
                    String.format("Green = %03d", entry.Green))));
            entryNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += entrySize,
                    entrySize,
                    String.format("Blue = %03d", entry.Blue))));
            entryNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += entrySize,
                    entrySize,
                    String.format("Alpha = %03d", entry.Alpha))));
            entryNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += entrySize,
                    2,
                    String.format("Frequency = %03d", entry.Frequency))));
            start += 2;

            i++;
        }

    }

    public static class SuggestedPaletteEntry {

        /**
         * The red, green, blue, and alpha samples are either one or two bytes
         * each, depending on the <span>sPLT</span> sample depth, regardless of
         * the image bit depth.
         */
        public final int Red;
        /**
         * Refer to {@link #Red}.
         *
         * @see #Red
         */
        public final int Green;
        /**
         * Refer to {@link #Red}.
         *
         * @see #Red
         */
        public final int Blue;
        /**
         * The color samples are not premultiplied by alpha, nor are they
         * precomposited against any background.
         * <p>
         * An alpha value of 0 means fully transparent, while an alpha value of
         * 255 (when the <span>sPLT</span> sample depth is 8) or 65535 (when the
         * <span>sPLT</span> sample depth is 16) means fully opaque.
         * The palette samples have the same gamma and chromaticity values as
         * those of the PNG image.
         * </p>
         *
         * @see #Red
         */
        public final int Alpha;
        /**
         * Each frequency value is proportional to the fraction of pixels in
         * the image that are closest to that palette entry in RGBA space,
         * before the image has been composited against any background.
         * <p>
         * The exact scale factor is chosen by the encoder, but should be chosen
         * so that the range of individual values reasonably fills the range 0
         * to 65535.
         * It is acceptable to artificially inflate the frequencies for
         * "important" colors such as those in a company logo or in the facial
         * features of a portrait.
         * Zero is a valid frequency meaning the color is "least important" or
         * that it is rarely if ever used. But when all of the frequencies are
         * zero, they are meaningless (nothing may be inferred about the actual
         * frequencies of the colors).
         * </p>
         */
        public final int Frequency;

        public SuggestedPaletteEntry(int r, int g, int b, int a, int f) {
            this.Red = r;
            this.Green = g;
            this.Blue = b;
            this.Alpha = a;
            this.Frequency = f;
        }

        @Override
        public String toString() {
            return String.format("RGB: (%03d, %03d, %03d), Alpha = %03d, Frequency = %03d",
                    this.Red, this.Green, this.Blue,
                    this.Alpha, this.Frequency);
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_tEXt.java`:

```java
/**
 * Chunk_tEXt.java    Apr 30, 2011, 23:36
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * Textual information that the encoder wishes to record with the image can be 
 * stored in <span>tEXt</span> chunks.
 * <p>
 * Each <span class="cn">tEXt</span> chunk contains a keyword and a text string,
 * in the format:
 * </p>
 * <pre>
 * Keyword:        1-79 bytes (character string)
 * Null separator: 1 byte
 * Text:           n bytes (character string)
 * </pre>
 * <p>
 * The keyword and text string are separated by a zero byte (null character).  
 * Neither the keyword nor the text string can contain a null character.  
 * Note that the text string is <em>not</em> null-terminated (the length of the 
 * chunk is sufficient information to locate the ending).
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_tEXt extends Chunk {

    public static final String CHUNK_TYPE_NAME = "tEXt";
    /**
     * Each of the <span>text</span> chunks contains as its first field a
     * keyword that indicates the type of information represented by the text
     * string.
     * <p>
     * The following keywords are predefined and should be used where
     * appropriate:
     * </p>
     * <pre>
     *    Title            Short (one line) title or caption for image
     *    Author           Name of image's creator
     *    Description      Description of image (possibly long)
     *    Copyright        Copyright notice
     *    Creation Time    Time of original image creation
     *    Software         Software used to create the image
     *    Disclaimer       Legal disclaimer
     *    Warning          Warning of nature of content
     *    Source           Device used to create the image
     *    Comment          Miscellaneous comment; conversion from GIF comment
     * </pre>
     */
    public final String Keyword;
    /**
     * The text string can be of any length from zero bytes up to the maximum
     * permissible chunk size less the length of the keyword and separator.
     * <p>
     * The text is interpreted according to the ISO/IEC 8859-1 (Latin-1)
     * character set <span>ISO/IEC-8859-1</span>.
     * The text string can contain any Latin-1 character.
     * Newlines in the text string should be represented by a single linefeed
     * character (decimal 10); use of other control characters in the text is
     * discouraged.
     * </p>
     */
    public final String Text;
    // TODO - ISO/IEC 8859-1

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_tEXt(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Keyword = chunkDataStream.readASCII();

        int rest = this.ChunkData.length - this.Keyword.length() - 1;
        if (rest > 0) {
            this.Text = chunkDataStream.readASCII(rest);
        } else {
            this.Text = "";
        }
    }

    @Override
    public String toString() {
        return String.format("%s: %s", this.Keyword, this.Text);
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                this.Keyword.length(),
                String.format("Keyword = %s", this.Keyword))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + this.Keyword.length(),
                1,
                "Null separator")));
        if (this.Text.length() > 0) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start + 1,
                    this.Text.length(),
                    String.format("Text = %s", this.Text))));
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_tIME.java`:

```java
/**
 * Chunk_tIME.java    Apr 30, 2011, 23:01
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>tIME</span> chunk gives the time of the last image
 * modification (<em>not</em> the time of initial image creation).
 * <p>
 * Universal Time (UTC, also called GMT) should be specified rather than local
 * time.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_tIME extends Chunk {

    public static final String CHUNK_TYPE_NAME = "tIME";
    public final int Year;
    public final int Month;
    public final int Day;
    public final int Hour;
    public final int Minute;
    public final int Second;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_tIME(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Year = chunkDataStream.readShort();
        this.Month = chunkDataStream.read();
        this.Day = chunkDataStream.read();
        this.Hour = chunkDataStream.read();
        this.Minute = chunkDataStream.read();
        this.Second = chunkDataStream.read();
    }

    @Override
    public String toString(){
        return String.format("%04d-%02d-%02d %02d:%02d:%02d",
                this.Year, this.Month, this.Day,
                this.Hour, this.Minute, this.Second);
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                2,
                String.format("Year = %04d", this.Year))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 2,
                1,
                String.format("Month = %02d", this.Month))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Day = %02d", this.Day))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Hour = %02d", this.Hour))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Minute = %02d", this.Minute))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start = start + 1,
                1,
                String.format("Second = %02d", this.Second))));
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_tRNS.java`:

```java
/**
 * Chunk_tRNS.java    Apr 30, 2011, 23:36
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * The <span>tRNS</span> chunk specifies that the image uses simple
 * transparency: either alpha values associated with palette entries (for
 * indexed-color images) or a single transparent color (for gray scale and
 * true color images).
 * <p>
 * Although simple transparency is not as elegant as the full alpha channel,
 * it requires less storage space and is sufficient for many common cases.
 * </p>
 *
 * @author Amos Shi
 */
public class Chunk_tRNS extends Chunk {

    public static final String CHUNK_TYPE_NAME = "tRNS";
    /**
     * A copy of {@link Chunk_IHDR#ColorType}.
     * 
     * @see Chunk_IHDR#ColorType
     */
    public final int ColorType;
    /**
     * The transparency value for color type 0 (gray scale).
     * <p>
     * For color type 0 (gray scale), the <span>tRNS</span> chunk contains a
     * single gray level value, stored in the format:
     * </p>
     * <pre>
     *   Gray:  2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * </pre>
     * <p>
     * (If the image bit depth is less than 16, the least significant bits are
     * used and the others are 0.)  Pixels of the specified gray level are to be
     * treated as transparent (equivalent to alpha value 0); all other pixels
     * are to be treated as fully opaque
     * (alpha value <code>2<sup>bitdepth</sup>-1</code>).
     * </p>
     * <p>
     * This field is <code>-1</code> when the color type is not 0.
     * </p>
     */
    public final int Gray;
    /**
     * The transparency value for color type 2 (true color).
     * <p>For color type 2 (true color), the <span>tRNS</span> chunk contains a
     * single RGB color value, stored in the format:
     * </p>
     * <pre>
     *   Red:   2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     *   Green: 2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     *   Blue:  2 bytes, range <code>0 .. (2^bitdepth)-1</code>
     * </pre>
     * <p>
     * (If the image bit depth is less than 16, the least significant bits are
     * used and the others are 0.)  Pixels of the specified color value are to
     * be treated as transparent (equivalent to alpha value 0); all other pixels
     * are to be treated as fully opaque (alpha value
     * <code>2<sup>bitdepth</sup>-1</code>).
     * </p>
     * <p>
     * This field is <code>-1</code> when the color type is not 2.
     * </p>
     */
    public final int Red;
    /**
     * Refer to {@link #Red}.
     *
     * @see #Red
     */
    public final int Green;
    /**
     * Refer to {@link #Red}.
     *
     * @see #Red
     */
    public final int Blue;
    /**
     * The transparency value for color type 3 (indexed color).
     * <p>
     * For color type 3 (indexed color), the <span>tRNS</span> chunk contains
     * a series of one-byte alpha values, corresponding to entries in the
     * <span>PLTE</span> chunk:
     * </p>
     * <pre>
     *    Alpha for palette index 0:  1 byte
     *    Alpha for palette index 1:  1 byte
     *    ...etc...
     * </pre>
     * <p>
     * Each entry indicates that pixels of the corresponding palette index must
     * be treated as having the specified alpha value.
     * Alpha values have the same interpretation as in an 8-bit full alpha
     * channel: 0 is fully transparent, 255 is fully opaque, regardless of image
     * bit depth.
     * The <span>tRNS</span> chunk must not contain more alpha values than there
     * are palette entries, but <span>tRNS</span> <em>can contain fewer values
     * than there are palette entries</em>. In this case, the alpha value for
     * all remaining palette entries is assumed to be 255. In the common case in
     * which only palette index 0 need be made transparent, only a one-byte
     * <span>tRNS</span> chunk is needed.
     * </p>
     * <p>
     * This field is <code>nul</code> when the color type is not 3.
     * </p>
     */
    public final int[] Alpha;

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_tRNS(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        this.ColorType = this.getColorType(png);
        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        switch (this.ColorType) {
            case 0:
                this.Gray = chunkDataStream.readUnsignedShort();
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                this.Alpha = null;
                break;
            case 2:
                this.Gray = -1;
                this.Red = chunkDataStream.readUnsignedShort();
                this.Green = chunkDataStream.readUnsignedShort();
                this.Blue = chunkDataStream.readUnsignedShort();
                this.Alpha = null;
                break;
            case 3:
                this.Gray = -1;
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                this.Alpha = new int[this.Length];
                for (int i = 0; i < this.Length; i++) {
                    this.Alpha[i] = chunkDataStream.read();
                }
                break;
            default:
                this.Gray = -1;
                this.Red = -1;
                this.Green = -1;
                this.Blue = -1;
                this.Alpha = null;
        }
    }

    private int getColorType(PNGFile png) {
        int colorType = -1;
        for (FileComponent chunk : png.getFileComponents()) {
            if (chunk instanceof Chunk_IHDR) {
                colorType = ((Chunk_IHDR) chunk).ColorType;
                break;
            }
        }

        return colorType;
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        // Color type 0 - Gray Scale
        if (this.Gray != -1) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    2,
                    String.format("Gray = %d", this.Gray))));
        }

        // Color Type 2 - True Color
        if (this.Red != -1) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start,
                    2,
                    String.format("Red = %d", this.Red))));
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += 2,
                    2,
                    String.format("Green = %d", this.Green))));
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start += 2,
                    2,
                    String.format("Blue = %d", this.Blue))));
        }

        // Color Type 3 - Indexed Color
        if (this.Alpha != null) {
            for (int i = 0; i < this.Alpha.length; i++) {
                parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                        start,
                        1,
                        String.format("Alpha[%d] = %d", i, this.Alpha[i]))));
                start++;
            }
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/Chunk_zTXt.java`:

```java
/**
 * Chunk_zEXt.java    May 04, 2011, 16:06
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 *
 * @author Amos Shi
 * @see Chunk_tEXt
 */
public class Chunk_zTXt extends Chunk {

    public static final String CHUNK_TYPE_NAME = "zTXt";
    /**
     * Refer to {@link Chunk_tEXt#Keyword}.
     * 
     * @see Chunk_tEXt#Keyword
     */
    public final String Keyword;
    public final int CompressionMethod;
    public final byte[] CompressedText;
    public final String CompressedTextString = null;      // TODO - Un-compress the text

    /**
     * Get Chunk Type in binary format.
     */
    static byte[] GetChunkType() {
        return CHUNK_TYPE_NAME.getBytes(StandardCharsets.UTF_8);
    }

    public Chunk_zTXt(PosDataInputStream stream, PNGFile png) throws IOException {
        super(stream, png);

        PosDataInputStream chunkDataStream = super.getChunkDataStream();
        this.Keyword = chunkDataStream.readASCII();
        this.CompressionMethod = chunkDataStream.read();

        int rest = this.ChunkData.length - this.Keyword.length() - 1 - 1;
        if (rest > 0) {
            this.CompressedText = new byte[rest];
            for (int i = 0; i < this.CompressedText.length; i++) {
                this.CompressedText[i] = chunkDataStream.readByte();
            }
        } else {
            this.CompressedText = null;
        }
    }

    @Override
    protected void generateTreeNodeChunkData(DefaultMutableTreeNode parent) {
        int start = this.startPos + 4 + 4;

        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start,
                this.Keyword.length(),
                String.format("Keyword = %s", this.Keyword))));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += this.Keyword.length(),
                1,
                "Null separator")));
        parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                start += 1,
                1,
                String.format("Compression method = %d", this.CompressionMethod))));

        if (this.CompressedText != null) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    start = start + 1,
                    this.CompressedText.length,
                    "Compressed text")));
        }
    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/PNGFile.java`:

```java
/**
 * PNGFile.java    Apr 19, 2011, 07:58
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.png;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;

/**
 *
 * @author Amos Shi
 * @see <a href="http://www.LIBPNG.org">LIBPNG.org</a>
 */
public class PNGFile extends FileFormat {

    /**
     * The minimal <code>PNG</code> file length is 20.
     * <p>
     * In which: 8 bytes for magic number; 12 bytes (4 bytes
     * <code>Length</code>, 4 bytes <code>Chunk Type</code>, 4 bytes
     * <code>CRC</code>) for the fist chunk.
     * </p>
     */
    public static final int PNGFILE_MIN_LENGTH = 20;
    /**
     * The first eight bytes of a <code>PNG</code> file always contain the
     * <code>PNG</code> file signature.
     * <p>
     * The signature values are: <code>137 80 78 71 13 10 26 10</code>.
     * </p>
     */
    static final byte[] MAGIC = {(byte) 137, (byte) 80, (byte) 78, (byte) 71, (byte) 13, (byte) 10, (byte) 26, (byte) 10};
    
    /**
     * Size of chunk type.
     */
    static final int CHUNK_TYPE_SIZE = 4;
    /**
     * Chunk type classes.
     */
    private static List<Class> ChunkTypes;

    private static void LoadChunkTypes() {
        ChunkTypes = Collections.synchronizedList(new ArrayList<>(100));

        ChunkTypes.add(Chunk_IDAT.class);
        ChunkTypes.add(Chunk_IHDR.class);
        ChunkTypes.add(Chunk_IEND.class);
        ChunkTypes.add(Chunk_PLTE.class);

        ChunkTypes.add(Chunk_bKGD.class);
        ChunkTypes.add(Chunk_cHRM.class);
        ChunkTypes.add(Chunk_gAMA.class);
        ChunkTypes.add(Chunk_hIST.class);
        ChunkTypes.add(Chunk_iTXt.class);
        ChunkTypes.add(Chunk_pHYs.class);
        ChunkTypes.add(Chunk_sBIT.class);
        ChunkTypes.add(Chunk_sPLT.class);
        ChunkTypes.add(Chunk_tEXt.class);
        ChunkTypes.add(Chunk_tIME.class);
        ChunkTypes.add(Chunk_tRNS.class);
        ChunkTypes.add(Chunk_zTXt.class);
    }

    public PNGFile(final File file) throws IOException, FileFormatException {
        super(file);

        // Load the chunk types
        LoadChunkTypes();

        // Check the file length
        if (this.fileByteArray.length < PNGFILE_MIN_LENGTH) {
            throw new FileFormatException(String.format(
                    "The file length (%d) is less than the minimal allowed PNG file.", this.fileByteArray.length));
        }

        // Check the file signature
        byte[] magic = new byte[MAGIC.length];
        System.arraycopy(this.fileByteArray, 0, magic, 0, MAGIC.length);
        if (BytesTool.isByteArraySame(MAGIC, magic) == false) {
            throw new FileFormatException("This is not a valid PNG file, because the PNG file signature does not exist at the beginning of this file.");
        }

        // Parse Chunks
        PosDataInputStream stream = new PosDataInputStream(new PosByteArrayInputStream(this.fileByteArray));
        BytesTool.skip(stream, PNGFile.MAGIC.length);

        while (stream.getPos() < this.fileByteArray.length) {
            super.addFileComponent(this.parseChunk(stream));
        }

    }

    private Chunk parseChunk(PosDataInputStream stream) throws IOException, FileFormatException {
        Chunk chunk = null;

        int length;
        byte[] chunkType = new byte[CHUNK_TYPE_SIZE];

        // Read Chunk Length
        length = stream.readInt();

        // Read chunk Type
        if (stream.read(chunkType) != CHUNK_TYPE_SIZE) {
            throw new IOException("Read the chunk type field failed near position " + stream.getPos());
        }

        // Skip Chunk Data
        if (length > 0) {
            BytesTool.skip(stream, length);
        }

        // Skip CRC
        BytesTool.skip(stream, 4);

        // GetChunkType
        Method mtd;
        byte[] type;

        PosDataInputStream streamChunk = new PosDataInputStream(new PosByteArrayInputStream(this.fileByteArray));
        BytesTool.skip(streamChunk, stream.getPos() - length - 12);

        for (Class<?> cls : ChunkTypes) {
            try {
                mtd = cls.getDeclaredMethod("GetChunkType");
                type = (byte[]) mtd.invoke(null);
                if (BytesTool.isByteArraySame(chunkType, type) == true) {
                    Constructor c = cls.getConstructor(PosDataInputStream.class, PNGFile.class);
                    chunk = (Chunk) c.newInstance(streamChunk, this);
                    break;   // End the loop
                }
            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | InstantiationException ex) {
                Logger.getLogger(PNGFile.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        if (chunk == null) {
            chunk = new Chunk(streamChunk, this);
        }

        return chunk;
    }

    @Override
    public String getContentTabName() {
        return "PNG File";
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode root) {

        root.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                0,
                PNGFile.MAGIC.length,
                "PNG file signature")));

        DefaultMutableTreeNode node;
        for (FileComponent chunk : super.components.values()) {
            Chunk ck = (Chunk) chunk;
            root.add(node = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    ck.getStartPos(),
                    ck.getLength(),
                    ck.getChunkTypeName()
            )));

            ((GenerateTreeNode) chunk).generateTreeNode(node);
        } // End while

    }
}

```

`FormatPNG/src/main/java/org/binaryinternals/format/png/PluginDescriptorPNG.java`:

```java
/*
 * PluginDescriptorPNG.java    Apr 16, 2011, 20:14
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.png;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorPNG implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "Portable Network Graphic (*.png)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"png"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return PNGFile.class;
    }

}

```

`FormatZIP/pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.binaryinternals</groupId>
        <artifactId>binaryinternals</artifactId>
        <version>${revision}</version>
    </parent>

    <artifactId>binaryinternals.format.zip</artifactId>
    <version>0.8</version>
    <packaging>jar</packaging>

    <name>binaryinternals :: FormatZIP</name>
    <description>ZIP is an archive file format that supports lossless data compression.</description>

    <dependencies>
        <dependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>binaryinternals.commonlib</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <biv-plugin>org.binaryinternals.format.zip.PluginDescriptorZIP</biv-plugin>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>

```

`FormatZIP/src/main/java/module-info.java`:

```java
/*
 * Copyright 2022 Binary Internals.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module org.binaryinternals.formatzip {
    requires static org.binaryinternals.commonlib;

    exports org.binaryinternals.format.zip;
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/CentralDirectoryStructure.java`:

```java
/**
 * CentralDirectoryStructure.java    May 08, 2011, 09:40
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import java.io.IOException;
import java.nio.charset.Charset;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * File header of central directory structure.
 *
 * @author Amos Shi
 */
public class CentralDirectoryStructure extends FileComponent implements GenerateTreeNode {

    public final FileHeader header;

    CentralDirectoryStructure(PosDataInputStream stream) throws IOException, FileFormatException {
        this.startPos = stream.getPos();
        this.header = new FileHeader(stream);
        this.length = this.header.calcLength();
    }

    @Override
    @SuppressWarnings({"java:S1121"})
    public void generateTreeNode(DefaultMutableTreeNode parent) {
        int position = this.getStartPos();

        DefaultMutableTreeNode nodeCDS = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                this.getLength(),
                "Central Directory Structure: " + this.header.FileNameValue
        ));
        parent.add(nodeCDS);

        DefaultMutableTreeNode headerNode = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                this.header.calcLength(),
                "File header"));
        nodeCDS.add(headerNode);

        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                4,
                "central file header signature:" + BytesTool.getByteDataHexView(this.header.Signature),
                Icons.Signature
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format("version made by = %d", this.header.VersionMadeBy),
                Icons.Versions
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("version needed to extract = %d", this.header.VersionNeededToExtract),
                Icons.Versions
        )));

        DefaultMutableTreeNode nodeBigFlag = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("general purpose bit flag = %02X %02X",
                        this.header.GeneralPurposeBitFlag[0],
                        this.header.GeneralPurposeBitFlag[1])
        ));
        headerNode.add(nodeBigFlag);
        for (int i = 0; i < 16; i++) {
            nodeBigFlag.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position + ((i > 7) ? 1 : 0),
                    1,
                    String.format("Bit %02d = %d", i, this.header.getGeneralPurposeBitFlagBitValue(i)),
                    Icons.Tag
            )));
        }
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("compression method = %d", this.header.CompressionMethod))));

        DefaultMutableTreeNode nodeTime = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("last mod file time = %s", this.header.LastModFileTimeValue.toString()),
                Icons.Time
        ));
        headerNode.add(nodeTime);
        this.header.LastModFileTimeValue.generateTreeNode(nodeTime);

        DefaultMutableTreeNode nodeDate = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("last mod file date = %s", this.header.LastModFileDateValue.toString()),
                Icons.Calendar
        ));
        headerNode.add(nodeDate);
        this.header.LastModFileDateValue.generateTreeNode(nodeDate);

        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                4,
                "crc-32: " + BytesTool.getByteDataHexView(this.header.CRC32),
                Icons.Checksum
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("compressed size = %d", this.header.CompressedSize),
                Icons.Size
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("uncompressed size = %d", this.header.UncompressedSize),
                Icons.Size
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format("file name length = %d", this.header.FileNameLength),
                Icons.Length
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("extra field length = %d", this.header.ExtraFieldLength),
                Icons.Length
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("file comment length = %d", this.header.FileCommentLength),
                Icons.Length
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("disk number start = %d", this.header.DiskNumberStart))));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("internal file attributes = %02X %02X",
                        this.header.InternalFileAttributes[0],
                        this.header.InternalFileAttributes[1]),
                Icons.Annotations
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                4,
                String.format("external file attributes = %02X %02X %02X %02X",
                        this.header.ExternalFileAttributes[0],
                        this.header.ExternalFileAttributes[1],
                        this.header.ExternalFileAttributes[2],
                        this.header.ExternalFileAttributes[3]),
                Icons.Annotations
        )));
        headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("relative offset of local header = 0x%08X", this.header.RelativeOffsetOfLocalHeader),
                Icons.Offset
        )));
        position += 4;
        if (this.header.FileName != null) {
            headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    this.header.FileName.length,
                    String.format("file name = %s", this.header.FileNameValue),
                    Icons.Name
            )));
            position += this.header.FileName.length;
        }
        if (this.header.ExtraField != null) {
            headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    this.header.ExtraField.length,
                    "extra field")));
            position += this.header.ExtraField.length;
        }
        if (this.header.FileComment != null) {
            headerNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    this.header.FileComment.length,
                    "file comment")));
        }

    }

    /**
     * File header of central directory structure.
     * <pre>
     *  central file header signature   4 bytes  (0x02014b50)
     *  version made by                 2 bytes
     *  version needed to extract       2 bytes
     *  general purpose bit flag        2 bytes
     *  compression method              2 bytes
     *  last mod file time              2 bytes
     *  last mod file date              2 bytes
     *  crc-32                          4 bytes
     *  compressed size                 4 bytes
     *  uncompressed size               4 bytes
     *  file name length                2 bytes
     *  extra field length              2 bytes
     *  file comment length             2 bytes
     *  disk number start               2 bytes
     *  internal file attributes        2 bytes
     *  external file attributes        4 bytes
     *  relative offset of local header 4 bytes
     *
     *  file name (variable size)
     *  extra field (variable size)
     *  file comment (variable size)
     * </pre>
     */
    public static class FileHeader {

        public final byte[] Signature = new byte[4];
        public final int VersionMadeBy;
        public final int VersionNeededToExtract;
        public final byte[] GeneralPurposeBitFlag = new byte[2];
        public final int CompressionMethod;
        public final int LastModFileTime;
        /**
         * Parsed value of {@link #LastModFileTime}.
         *
         * @see #LastModFileTime
         */
        public final MSDosTime LastModFileTimeValue;
        public final int LastModFileDate;
        /**
         * Parsed value of {@link #LastModFileDate}.
         *
         * @see #LastModFileDate
         */
        public final MSDosDate LastModFileDateValue;
        public final byte[] CRC32 = new byte[4];
        public final long CompressedSize;
        public final long UncompressedSize;
        public final int FileNameLength;
        public final int ExtraFieldLength;
        public final int FileCommentLength;
        public final int DiskNumberStart;
        public final byte[] InternalFileAttributes = new byte[2];
        public final byte[] ExternalFileAttributes = new byte[4];
        public final long RelativeOffsetOfLocalHeader;
        /**
         * Contains the file name or <code>null</code> if
         * {@link #FileNameLength} is zero.
         *
         * @see #FileNameLength
         */
        public final byte[] FileName;
        /**
         * Parsed value of {@link #FileName}.
         *
         * @see #FileName
         */
        public final String FileNameValue;
        /**
         * Contains extra fields or <code>null</code> if
         * {@link #ExtraFieldLength} is zero.
         *
         * @see #ExtraFieldLength
         */
        public final byte[] ExtraField;
        /**
         * Contains comment of the file or <code>null</code> if
         * {@link #FileCommentLength} is zero.
         *
         * @see #FileCommentLength
         */
        public final byte[] FileComment;

        FileHeader(PosDataInputStream stream) throws IOException, FileFormatException {
            int readBytes = stream.read(this.Signature);
            if (readBytes != this.Signature.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.Signature.length, readBytes));
            }
            if (BytesTool.isByteArraySame(this.Signature, ZIPFile.CENTRAL_FILE_HEADER) == false) {
                throw new FileFormatException("Signature does not match for 'central file header signature' at 0x" + Integer.toHexString(stream.getPos()) + ": found =" + BytesTool.getByteDataHexView(this.Signature) + ", expected =" + BytesTool.getByteDataHexView(ZIPFile.CENTRAL_FILE_HEADER));
            }

            this.VersionMadeBy = stream.readUnsignedShortInLittleEndian();
            this.VersionNeededToExtract = stream.readUnsignedShortInLittleEndian();

            readBytes = stream.read(this.GeneralPurposeBitFlag);
            if (readBytes != this.GeneralPurposeBitFlag.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.GeneralPurposeBitFlag.length, readBytes));
            }

            this.CompressionMethod = stream.readUnsignedShortInLittleEndian();

            int lastModFileTimeStartPos = stream.getPos();
            this.LastModFileTime = stream.readUnsignedShortInLittleEndian();
            this.LastModFileTimeValue = new MSDosTime(this.LastModFileTime, lastModFileTimeStartPos, PosDataInputStream.USHORT_LENGTH);

            int lastModFileDateStartPos = stream.getPos();
            this.LastModFileDate = stream.readUnsignedShortInLittleEndian();
            this.LastModFileDateValue = new MSDosDate(this.LastModFileDate, lastModFileDateStartPos, PosDataInputStream.USHORT_LENGTH);

            readBytes = stream.read(this.CRC32);
            if (readBytes != this.CRC32.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.CRC32.length, readBytes));
            }

            this.CompressedSize = stream.readUnsignedIntInLittleEndian();
            this.UncompressedSize = stream.readUnsignedIntInLittleEndian();
            this.FileNameLength = stream.readUnsignedShortInLittleEndian();
            this.ExtraFieldLength = stream.readUnsignedShortInLittleEndian();
            this.FileCommentLength = stream.readUnsignedShortInLittleEndian();
            this.DiskNumberStart = stream.readUnsignedShortInLittleEndian();

            readBytes = stream.read(this.InternalFileAttributes);
            if (readBytes != this.InternalFileAttributes.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.InternalFileAttributes.length, readBytes));
            }

            readBytes = stream.read(this.ExternalFileAttributes);
            if (readBytes != this.ExternalFileAttributes.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.ExternalFileAttributes.length, readBytes));
            }

            this.RelativeOffsetOfLocalHeader = stream.readUnsignedIntInLittleEndian();

            if (this.FileNameLength > 0) {
                this.FileName = new byte[this.FileNameLength];
                readBytes = stream.read(this.FileName);
                if (readBytes != this.FileName.length) {
                    throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.FileName.length, readBytes));
                }

                this.FileNameValue = new String(this.FileName, Charset.forName("UTF-8")); // Not working for WinRAR zip Chinese file name
            } else {
                this.FileName = null;
                this.FileNameValue = "";  // We are not using NULL to avoid Exception
            }

            if (this.ExtraFieldLength > 0) {
                this.ExtraField = new byte[this.ExtraFieldLength];
                readBytes = stream.read(this.ExtraField);
                if (readBytes != this.ExtraField.length) {
                    throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.ExtraField.length, readBytes));
                }
            } else {
                this.ExtraField = null;
            }

            if (this.FileCommentLength > 0) {
                this.FileComment = new byte[this.FileCommentLength];
                readBytes = stream.read(this.FileComment);
                if (readBytes != this.FileComment.length) {
                    throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.FileComment.length, readBytes));
                }
            } else {
                this.FileComment = null;
            }
        }
        private int length = -1;

        public int calcLength() {
            if (this.length == -1) {
                this.length = 46 + this.FileNameLength + this.ExtraFieldLength + this.FileCommentLength;
            }

            return this.length;
        }

        /**
         * Get the corresponding bit value of <code>position</code>.
         *
         * @param position Bit position, from 1 to 15
         * @return The bit value, 0 or 1
         *
         * @see #GeneralPurposeBitFlag
         * @see LocalFileHeader#getGeneralPurposeBitFlagBitValue(int)
         */
        public int getGeneralPurposeBitFlagBitValue(int position) {
            return LocalFileHeader.parseGeneralPurposeBitFlag(this.GeneralPurposeBitFlag, position);
        }
    }
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/EndOfCentralDirectoryRecord.java`:

```java
/**
 * EndOfCentralDirectoryRecord.java    May 08, 2011, 11:24
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import java.io.IOException;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * End of central directory record.
 * <pre>
 *      end of central dir signature                                   4 bytes  (0x06054b50)
 *      number of this disk                                            2 bytes
 *      number of the disk with the start of the central directory     2 bytes
 *      total number of entries in the central directory on this disk  2 bytes
 *      total number of entries in the central directory               2 bytes
 *      size of the central directory                                  4 bytes
 *      offset of start of central directory with respect to the
 *        starting disk number                                         4 bytes
 *      .ZIP file comment length                                       2 bytes
 *      .ZIP file comment                                              (variable size)
 * </pre>
 *
 * @author Amos Shi
 */
public class EndOfCentralDirectoryRecord extends FileComponent implements GenerateTreeNode {

    /** End of central directory signature. */
    public final byte[] Signature = new byte[4];
    /** Number of this disk. */
    public final int DiskNumber;
    /** Number of the disk with the start of the central directory. */
    public final int DiskNumberWithSCD;
    /** Total number of entries in the central directory on this disk. */
    public final int EntryTotalNumberDisk;
    /** Total number of entries in the central directory. */
    public final int EntryTotalNumber;
    /** Size of the central directory. */
    public final long CentralDirectorySize;
    /** Offset of start of central directory with respect to the starting disk number. */
    public final long CentralDirectoryOffset;
    /** ZIP file comment length. */
    public final int ZipFileCommentLength;
    /** ZIP file comment. <code>null</code> of {@link #ZipFileCommentLength} is zero. */
    public final byte[] ZipFileComment;

    EndOfCentralDirectoryRecord(PosDataInputStream stream) throws IOException, FileFormatException {
        this.startPos = stream.getPos();

        int readBytes = stream.read(this.Signature);
        if (readBytes != this.Signature.length) {
            throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.Signature.length, readBytes));
        }

        if (BytesTool.isByteArraySame(this.Signature, ZIPFile.CENTRAL_END) == false) {
            throw new FileFormatException("Signature does not match for 'end of central directory signature'.");
        }
        this.DiskNumber = stream.readUnsignedShortInLittleEndian();
        this.DiskNumberWithSCD = stream.readUnsignedShortInLittleEndian();
        this.EntryTotalNumberDisk = stream.readUnsignedShortInLittleEndian();
        this.EntryTotalNumber = stream.readUnsignedShortInLittleEndian();
        this.CentralDirectorySize = stream.readUnsignedIntInLittleEndian();
        this.CentralDirectoryOffset = stream.readUnsignedIntInLittleEndian();
        this.ZipFileCommentLength = stream.readUnsignedShortInLittleEndian();
        if (this.ZipFileCommentLength > 0) {
            this.ZipFileComment = new byte[this.ZipFileCommentLength];

            readBytes = stream.read(this.ZipFileComment);
            if (readBytes != this.ZipFileComment.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.ZipFileComment.length, readBytes));
            }
        } else {
            this.ZipFileComment = null;
        }

        this.length = 22 + this.ZipFileCommentLength;
    }

    @Override
    @SuppressWarnings({"java:S1121"})
    public void generateTreeNode(DefaultMutableTreeNode parent) {
        int position = this.getStartPos();

        DefaultMutableTreeNode nodeCDE = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                this.getLength(),
                "End of central directory record"));
        parent.add(nodeCDE);

        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                4,
                "signature",
                Icons.Signature
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format("number of this disk = %d", this.DiskNumber),
                Icons.Counter
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("number of the disk with the start of the central directory = %d", this.DiskNumberWithSCD),
                Icons.Counter
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("total number of entries in the central directory on this disk = %d", this.EntryTotalNumberDisk),
                Icons.Counter
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("total number of entries in the central directory = %d", this.EntryTotalNumber),
                Icons.Counter
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                4,
                String.format("size of the central directory = %d", this.CentralDirectorySize),
                Icons.Size
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("offset of start of central directory with respect to the starting disk number = 0x%08X", this.CentralDirectoryOffset),
                Icons.Offset
        )));
        nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format(".ZIP file comment length = %d", this.ZipFileCommentLength),
                Icons.Length
        )));
        if (this.ZipFileComment != null) {
            nodeCDE.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position + 2,
                    this.ZipFileComment.length,
                    ".ZIP file comment",
                    Icons.Annotations
            )));
        }
    }
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/LocalFileHeader.java`:

```java
/**
 * LocalFileHeader.java    May 10, 2011, 22:16
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import java.io.IOException;
import java.nio.charset.Charset;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * Local file header.
 * <pre>
 *      local file header signature     4 bytes  (0x04034b50)
 *      version needed to extract       2 bytes
 *      general purpose bit flag        2 bytes
 *      compression method              2 bytes
 *      last mod file time              2 bytes
 *      last mod file date              2 bytes
 *      crc-32                          4 bytes
 *      compressed size                 4 bytes
 *      uncompressed size               4 bytes
 *      file name length                2 bytes
 *      extra field length              2 bytes
 *
 *      file name (variable size)
 *      extra field (variable size)
 * </pre>
 *
 * @author Amos Shi
 */
public class LocalFileHeader extends FileComponent implements GenerateTreeNode {

    /**
     * Local file header signature.
     */
    public final byte[] Signature = new byte[4];
    /**
     * Version needed to extract.
     */
    public final int VersionNeededToExtract;
    /**
     * General purpose bit flag.
     */
    public final byte[] GeneralPurposeBitFlag = new byte[2];
    /**
     * Compression method.
     */
    public final int CompressionMethod;
    /**
     * Last mod file time.
     */
    public final int LastModFileTime;
    /**
     * Parsed value of {@link #LastModFileTime}.
     *
     * @see #LastModFileTime
     */
    public final MSDosTime LastModFileTimeValue;
    /**
     * Last mod file date.
     */
    public final int LastModFileDate;
    /**
     * Parsed value of {@link #LastModFileDate}.
     *
     * @see #LastModFileDate
     */
    public final MSDosDate LastModFileDateValue;
    /**
     * CRC-32.
     */
    public final byte[] CRC32 = new byte[4];
    /**
     * Compressed size.
     */
    public final long CompressedSize;
    /**
     * Uncompressed size.
     */
    public final long UncompressedSize;
    /**
     * File name length.
     */
    public final int FileNameLength;
    /**
     * Extra field length.
     */
    public final int ExtraFieldLength;
    /**
     * File name. <code>null</code> when {@link #FileNameLength} is 0.
     */
    public final byte[] FileName;
    /**
     * Parsed value of {@link #FileName}.
     *
     * @see #FileName
     */
    public final String FileNameValue;
    /**
     * Extra field. <code>null</code> when {@link #ExtraFieldLength} is 0.
     */
    public final byte[] ExtraField;

    LocalFileHeader(PosDataInputStream stream) throws IOException, FileFormatException {
        this.startPos = stream.getPos();

        int readBytes = stream.read(this.Signature);
        if (readBytes != this.Signature.length) {
            throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.Signature.length, readBytes));
        }

        if (BytesTool.isByteArraySame(this.Signature, ZIPFile.LOCAL_FILE_HEADER) == false) {
            throw new FileFormatException("Signature does not match for 'local file header signature'.");
        }

        this.VersionNeededToExtract = stream.readUnsignedShortInLittleEndian();

        readBytes = stream.read(this.GeneralPurposeBitFlag);
        if (readBytes != this.GeneralPurposeBitFlag.length) {
            throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.GeneralPurposeBitFlag.length, readBytes));
        }

        this.CompressionMethod = stream.readUnsignedShortInLittleEndian();

        int lastModFileTimeStartPos = stream.getPos();
        this.LastModFileTime = stream.readUnsignedShortInLittleEndian();
        this.LastModFileTimeValue = new MSDosTime(this.LastModFileTime, lastModFileTimeStartPos, PosDataInputStream.USHORT_LENGTH);

        int lastModFileDateStartPos = stream.getPos();
        this.LastModFileDate = stream.readUnsignedShortInLittleEndian();
        this.LastModFileDateValue = new MSDosDate(this.LastModFileDate, lastModFileDateStartPos, PosDataInputStream.USHORT_LENGTH);

        readBytes = stream.read(this.CRC32);
        if (readBytes != this.CRC32.length) {
            throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.CRC32.length, readBytes));
        }

        this.CompressedSize = stream.readUnsignedIntInLittleEndian();
        this.UncompressedSize = stream.readUnsignedIntInLittleEndian();
        this.FileNameLength = stream.readUnsignedShortInLittleEndian();
        this.ExtraFieldLength = stream.readUnsignedShortInLittleEndian();
        if (this.FileNameLength > 0) {
            this.FileName = new byte[this.FileNameLength];
            readBytes = stream.read(this.FileName);
            if (readBytes != this.FileName.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.FileName.length, readBytes));
            }

            // PosDataInputStream utf8 = new PosDataInputStream(new PosByteArrayInputStream(this.FileName));
            // this.FileNameValue = utf8.readUTF();              // Failed: EOFException
            // this.FileNameValue = new String(this.FileName);   // TODO - This logic is not working for Chinese charactor
            // this.FileNameValue = new String(this.FileName, Charset.forName("ISO-8859-1"));// Not working for WinRAR zip Chinese file name
            this.FileNameValue = new String(this.FileName, Charset.forName("UTF-8")); // Not working for WinRAR zip Chinese file name
            // this.FileNameValue = new String(this.FileName, Charset.forName("UTF-16")); // Not
            // this.FileNameValue = new String(this.FileName, Charset.forName("UTF-16BE")); // Not
            // this.FileNameValue = new String(this.FileName, Charset.forName("UTF-16LE"));  // Not
        } else {
            this.FileName = null;
            this.FileNameValue = "";  // We are not using NULL to make smaller dump
        }
        if (this.ExtraFieldLength > 0) {
            this.ExtraField = new byte[this.ExtraFieldLength];
            readBytes = stream.read(this.ExtraField);
            if (readBytes != this.ExtraField.length) {
                throw new IOException(String.format("Failed to read %d bytes, actual bytes read %d", this.ExtraField.length, readBytes));
            }
        } else {
            this.ExtraField = null;
        }

        this.length = 30 + this.FileNameLength + this.ExtraFieldLength;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parent) {
        int position = this.getStartPos();

        // Local file header
        DefaultMutableTreeNode nodeLfh = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                this.getLength(),
                "Local file header - " + this.FileNameValue));
        parent.add(nodeLfh);

        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position,
                4,
                "signature:" + BytesTool.getByteDataHexView(this.Signature),
                Icons.Signature
        )));
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format("version needed to extract = %d", this.VersionNeededToExtract),
                Icons.Versions
        )));

        DefaultMutableTreeNode nodeBigFlag = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("general purpose bit flag = %02X %02X",
                        this.GeneralPurposeBitFlag[0],
                        this.GeneralPurposeBitFlag[1])
        ));
        nodeLfh.add(nodeBigFlag);
        for (int i = 0; i < 16; i++) {
            nodeBigFlag.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position + ((i > 7) ? 1 : 0),
                    1,
                    String.format("Bit %02d = %d", i, this.getGeneralPurposeBitFlagBitValue(i)),
                    Icons.Tag
            )));
        }
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("compression method = %d", this.CompressionMethod))));

        //
        DefaultMutableTreeNode nodeTime = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("last mod file time = %s", this.LastModFileTimeValue.toString()),
                Icons.Time
        ));
        nodeLfh.add(nodeTime);
        this.LastModFileTimeValue.generateTreeNode(nodeTime);

        //
        DefaultMutableTreeNode nodeDate = new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("last mod file date = %s", this.LastModFileDateValue.toString()),
                Icons.Calendar
        ));
        nodeLfh.add(nodeDate);
        this.LastModFileDateValue.generateTreeNode(nodeDate);

        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                4,
                "crc-32:" + BytesTool.getByteDataHexView(this.CRC32),
                Icons.Checksum
        )));
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("compressed size = %d", this.CompressedSize),
                Icons.Size
        )));
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                4,
                String.format("uncompressed size = %d", this.UncompressedSize),
                Icons.Size
        )));
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 4,
                2,
                String.format("file name length = %d", this.FileNameLength),
                Icons.Length
        )));
        nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                position += 2,
                2,
                String.format("extra field length = %d", this.ExtraFieldLength),
                Icons.Length
        )));
        position += 2;
        if (this.FileName != null) {
            nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    this.FileName.length,
                    String.format("file name = %s", this.FileNameValue),
                    Icons.Name
            )));
            position += this.FileName.length;
        }
        if (this.ExtraField != null) {
            nodeLfh.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    this.ExtraField.length,
                    "extra field")));
            position += this.ExtraField.length;
        }

        // File data
        if (this.CompressedSize > 0) {
            parent.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                    position,
                    (int) this.CompressedSize, // Note. We are in danger of very big file longer than int value size.
                    "File data",
                    Icons.Data,
                    ZIPFile.MESSAGES.getString("MSG_COMPRESSED_FILE")
            )));
        }
    }

    /**
     * Get the corresponding bit value of <code>position</code>.
     * <p>
     * There are two bytes in in the {@link #GeneralPurposeBitFlag} field, the
     * bit position is located as:
     * </p>
     * <pre>
     *   byte       :  [ byte left/0 ]    [ byte right/1]
     *   bit postion:  7 6 5 4 3 2 1 0    F E D C B A 9 8
     * </pre>
     *
     * @param position Bit position, from 1 to 15
     * @return The bit value, 0 or 1
     */
    public int getGeneralPurposeBitFlagBitValue(int position) {
        return LocalFileHeader.parseGeneralPurposeBitFlag(this.GeneralPurposeBitFlag, position);
    }

    static int parseGeneralPurposeBitFlag(byte[] buf, int position) {
        if (position < 0 || position > 15) {
            throw new IllegalArgumentException(String.format("Invalid postion value %d, [0, 15] is expeced.", position));
        }

        byte byteValue;
        int bitPos;
        if (position >= 0 && position <= 7) {
            byteValue = buf[0];
            bitPos = position;
        } else {
            byteValue = buf[1];
            bitPos = position - 8;
        }

        return (((byte) (((byte) (byteValue << (7 - bitPos))) >> 7)) & 0x0001);
    }
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/MSDosDate.java`:

```java
/**
 * MSDosDate.java    May 14, 2011, 12:35
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * A date in the format used by MS-DOS.
 * <p>
 * The date is a packed 16-bit (2 bytes) value in which bits in the value
 * represent the day, month, and year.
 * </p>
 * <pre>
 *   bit     00 - 04        05 - 08           09 - 15
 *   value   day (1 - 31)   month (1 - 12)    years from 1980
 *   max     31             15                127 (Year 2107)
 * </pre>
 *
 * @author Amos Shi
 * @see <a href="http://www.vsft.com/hal/dostime.htm">MS DOS Date Time
 * Format</a>
 */
public class MSDosDate extends FileComponent implements GenerateTreeNode {

    public final int Day;
    public final int Month;
    public final int Year;

    MSDosDate(int value, int start, int len) {
        this.Day = value & 0x0000001F;
        this.Month = (value & 0x000001E0) >> 5;
        this.Year = ((value & 0x0000FE00) >> 9) + 1980;

        super.startPos = start;
        super.length = len;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Year = %04d", this.Year))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Month = %02d", this.Month))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Day = %02d", this.Day))));
    }

    @Override
    public String toString() {
        return String.format("%04d-%02d-%02d", this.Year, this.Month, this.Day);
    }
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/MSDosTime.java`:

```java
/**
 * MSDosTime.java    May 14, 2011, 12:35
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.JTreeNodeFileComponent;

/**
 * A time in the format used by MS-DOS.
 * <p>
 * The time is a packed 16-bit (2 bytes) value in which bits in the value
 * represent the hour, minute, and second.
 * </p>
 * <pre>
 *   bit     00 - 04   05 - 10   11 - 15
 *   value   second    minute    hour
 *   max     31        63        31
 * </pre>
 *
 * @author Amos Shi
 * @see <a href="http://www.vsft.com/hal/dostime.htm">MS DOS Date Time
 * Format</a>
 */
public class MSDosTime extends FileComponent implements GenerateTreeNode {

    public final int Second;
    public final int Minute;
    public final int Hour;

    MSDosTime(int value, int start, int len) {
        this.Second = (value & 0x0000001F) * 2;  // Double the value, inaccurate for one second
        this.Minute = (value & 0x000007E0) >> 5;
        this.Hour = (value & 0x0000F800) >> 11;

        super.startPos = start;
        super.length = len;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode parentNode) {
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Hour = %02d", this.Hour))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Minute = %02d", this.Minute))));
        parentNode.add(new DefaultMutableTreeNode(new JTreeNodeFileComponent(
                super.startPos,
                super.length,
                String.format("Second = %02d (maybe inaccurate for one second)", this.Second))));
    }

    @Override
    public String toString() {
        return String.format("%02d:%02d:%02d", this.Hour, this.Minute, this.Second);
    }
}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/PluginDescriptorZIP.java`:

```java
/*
 * PluginDescriptorPNG.java    Apr 16, 2011, 20:14
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */

package org.binaryinternals.format.zip;

import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.PluginDescriptor;

/**
 *
 * @author Amos Shi
 */
public class PluginDescriptorZIP implements PluginDescriptor{

    @Override
    public String getExtensionDescription() {
        return "ZIP file (*.jar, *.zip)";
    }

    @Override
    public String[] getExtensions() {
        return new String[]{"jar", "zip"};
    }

    @Override
    public Class<? extends FileFormat> getFileFormatClass() {
        return ZIPFile.class;
    }

}

```

`FormatZIP/src/main/java/org/binaryinternals/format/zip/ZIPFile.java`:

```java
/**
 * ZIPFile.java Apr 19, 2011, 07:58
 *
 * Copyright 2011, BinaryInternals.org. All rights reserved.
 * Use is subject to license terms.
 */
package org.binaryinternals.format.zip;

import java.io.File;
import java.io.IOException;
import java.util.Locale;
import java.util.ResourceBundle;
import javax.swing.tree.DefaultMutableTreeNode;
import org.binaryinternals.commonlib.core.BytesTool;
import org.binaryinternals.commonlib.core.FileComponent;
import org.binaryinternals.commonlib.core.FileFormat;
import org.binaryinternals.commonlib.core.FileFormatException;
import org.binaryinternals.commonlib.core.PosByteArrayInputStream;
import org.binaryinternals.commonlib.core.PosDataInputStream;
import org.binaryinternals.commonlib.ui.GenerateTreeNode;
import org.binaryinternals.commonlib.ui.Icons;

/**
 *
 * @author Amos Shi
 */
public class ZIPFile extends FileFormat implements GenerateTreeNode {

    static final ResourceBundle MESSAGES = ResourceBundle.getBundle(ZIPFile.class.getPackageName() + ".MessagesBundle", Locale.ROOT);

    /**
     * Minimal size for a valid zip file.
     */
    public static final int ZIPFILE_MIN_LENGTH = 22;
    /**
     * Central file header signature of File header in Central directory
     * structure.
     */
    static final byte[] CENTRAL_FILE_HEADER = {(byte) 0x50, (byte) 0x4B, (byte) 0x01, (byte) 0x02};
    /**
     * Local file header signature in Local file header.
     */
    static final byte[] LOCAL_FILE_HEADER = {(byte) 0x50, (byte) 0x4B, (byte) 0x03, (byte) 0x04};
    /**
     * Header signature of Digital signature in Central directory structure.
     */
    public static final byte[] DIGITAL_SIG_HEADER = {(byte) 0x50, (byte) 0x4B, (byte) 0x05, (byte) 0x05};
    /**
     * End of central dir signature in End of central directory record.
     */
    static final byte[] CENTRAL_END = {(byte) 0x50, (byte) 0x4B, (byte) 0x05, (byte) 0x06};
    /**
     * Signature in Zip64 end of central directory record.
     */
    public static final byte[] CENTRAL_ZIP64_RECORD = {(byte) 0x50, (byte) 0x4B, (byte) 0x06, (byte) 0x06};
    /**
     * Signature in Zip64 end of central directory locator.
     */
    public static final byte[] CENTRAL_ZIP64_LOCATOR = {(byte) 0x50, (byte) 0x4B, (byte) 0x06, (byte) 0x07};
    /**
     * Archive extra data signature in Archive extra data record.
     */
    public static final byte[] ARCHIVE_EXTRA_DATA = {(byte) 0x50, (byte) 0x4B, (byte) 0x06, (byte) 0x08};

    EndOfCentralDirectoryRecord cde = null;
    CentralDirectoryStructure[] cds = null;
    LocalFileHeader[] lfh = null;

    public ZIPFile(final File file) throws IOException, FileFormatException {
        super(file);

        // Check the file length
        if (this.fileByteArray.length < ZIPFILE_MIN_LENGTH) {
            throw new FileFormatException(String.format(
                    "The file length (%d) is less than the minimal allowed size.", this.fileByteArray.length));
        }

        this.parse();
    }

    private void parse() throws IOException, FileFormatException {
        PosDataInputStream stream = new PosDataInputStream(new PosByteArrayInputStream(super.fileByteArray));

        // End of central directory record.
        stream.skipToEnd();
        int pos_cde = stream.backwardTo(ZIPFile.CENTRAL_END);
        if (pos_cde > -1) {
            this.cde = new EndOfCentralDirectoryRecord(stream);
        } else {
            throw new FileFormatException("This is not a valid zip file since cannot find 'end of central directory record'.");
        }
        super.components.put(Long.valueOf(pos_cde), this.cde);

        // If no entry, nothing to do
        if (this.cde.EntryTotalNumber < 1) {
            return;
        }

        // File header of central directory structure.
        stream.reset();
        BytesTool.skip(stream, this.cde.CentralDirectoryOffset);
        this.cds = new CentralDirectoryStructure[this.cde.EntryTotalNumber];
        for (int i = 0; i < this.cds.length; i++) {
            this.cds[i] = new CentralDirectoryStructure(stream);

            super.components.put(Long.valueOf(this.cds[i].getStartPos()), this.cds[i]);
        }

        // Local file header
        this.lfh = new LocalFileHeader[this.cds.length];
        for (int i = 0; i < this.cds.length; i++) {
            stream.reset();
            BytesTool.skip(stream, this.cds[i].header.RelativeOffsetOfLocalHeader);
            this.lfh[i] = new LocalFileHeader(stream);

            super.components.put(Long.valueOf(this.lfh[i].getStartPos()), this.lfh[i]);
        }
    }

    @Override
    public String getContentTabName() {
        return "ZIP File";
    }

    @Override
    public Icons getIcon() {
        return Icons.ZIP;
    }

    @Override
    public void generateTreeNode(DefaultMutableTreeNode root) {
        int lastPos = 0;

        for (FileComponent value : super.components.values()) {
            // Fill the gap first
            int gap = value.getStartPos() - lastPos;
            if (gap > 0) {
                generateTreeNodeGap(root, lastPos, gap);
            }

            // Generate the tree nodes
            if (value instanceof GenerateTreeNode) {
                ((GenerateTreeNode) value).generateTreeNode(root);
                lastPos = value.getStartPos() + value.getLength();

                if (value instanceof LocalFileHeader) {
                    lastPos += ((LocalFileHeader)value).CompressedSize;
                }
            }
        }
    }
}

```

`FormatZIP/src/main/resources/org/binaryinternals/format/zip/MessagesBundle.properties`:

```properties

MSG_COMPRESSED_FILE= Compressed file contents

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
## Binary Internals Viewer

An application to show binary file internals visually & interactively for the meaning of every bit.

Supported Formats

* [BMP](https://en.wikipedia.org/wiki/BMP_file_format) file
* [Class](https://docs.oracle.com/javase/specs/) file
  * Programming Logic: http://www.codeproject.com/Articles/35915/Java-Class-Viewer
  * Usage Sample: https://www.codeproject.com/Articles/762980/Inside-the-Hello-World-Application-via-Java-Class
* [JPEG](https://en.wikipedia.org/wiki/JPEG) file
* [PNG](https://en.wikipedia.org/wiki/Portable_Network_Graphics) file
* [ZIP](https://en.wikipedia.org/wiki/ZIP_(file_format)) file
  * [The structure of a PKZip file](https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html)
* Will supported formats
  * [DEX](https://en.wikipedia.org/wiki/Dalvik_(software)) file for Android (in progress)
  * [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) file for `*nix` systems (in progress)
 
Sample

* Here is a screen shot opening `java.lang.String.class` file

![Sample Class](docs/sample-class-string.png)


Download

* Download Application: https://github.com/amosshi/binaryinternals/releases

User guide

* We need the `java` command to run this tool
  * `java -jar BinaryInternalsViewer-3.6-timestamp.jar`
    * Where `timestamp` is the auto-generated build timestamp
  * Menu item: `File` > `Open...`
  * Choose the binary file to view

Build the Source Code

* Prerequisite
  * Java Version: `OpenJDK version 11` or higher
  * Set `JAVA_HOME` environment variable
    * If not set use the export statements in the `build.sh` script
  * Build Tool: `Apache Maven 3.6` or higher: because we are using the [Maven CI Friendly Versions](https://maven.apache.org/maven-ci-friendly.html) `${revision}` feature
* Build
  * Build via maven command
    * `mvn clean`
    * `mvn package`
    * `mvn install`
    * `mvn site:site`
    * `mvn site:stage`
  * Build with Script
    * `./build.sh` (Linux/MacOS/Windows Git Bash)
    * `build.cmd` (Windows CMD)

Structure

* This application does not have 3rd party dependency other than JDK, easy to add it to your existing project
* Show dependency tree for this project
  * `mvn dependency:tree`
* Graph of all dependencies aggregated
  *  Make sure [Graphviz](https://graphviz.org/) has been installed, `dot` command is available
  * `mvn com.github.ferstl:depgraph-maven-plugin:aggregate -DcreateImage -Dincludes=org.binaryinternals -DshowGroupIds -DshowVersions -DoutputDirectory=docs`

![Dependency Graph](docs/dependency-graph.png)

Legacy note

* The original `Java Class Viewer` has been retired and merged into `Binary Internals Viewer` since Apr 2021


## Standalone Libs

The `FormatXXXX.jar` files can be used in your project when needed.

```

`build.cmd`:

```cmd
@REM Build quickly on Windows
@REM
@REM We assume JAVA_HOME has been set
@REM

echo %JAVA_HOME%
java -version

mvn  clean package install dependency:tree versions:display-dependency-updates

```

`build.sh`:

```sh
#!/bin/bash
#
# Build quickly
#

# Please change the JAVA_HOME according to the current system settings

# Set java home on Ubuntu LTS Linux
#export JAVA_HOME=/usr/lib/jvm/default-java
#export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64

# Set java home on openSUSE Linux
#export JAVA_HOME=/usr/lib64/jvm/java

# Set java home on MacOS
#JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.0.3.1.jdk/Contents/Home

# Set java home on Windows
# - Reference: https://www.theserverside.com/feature/How-to-set-JAVA_HOME-in-Windows-and-echo-the-result
# - Example value: JAVA_HOME=C:\data\tools\jdk

java -version

mvn  clean
mvn  package
mvn  install
mvn  dependency:tree
mvn  versions:display-dependency-updates
#mvn source:aggregate javadoc:aggregate javadoc:aggregate-jar pdf:aggregate checkstyle:checkstyle-aggregate pmd:aggregate-pmd site:site site:deploy 
#mvn jdeps:jdkinternals
#mvn spotbugs:gui

```

`docs/dependency-graph.dot`:

```dot
digraph "binaryinternals" {
  node [shape="box",style="rounded",fontname="Helvetica",fontsize="14"]
  edge [fontsize="10",fontname="Helvetica"]

  // Node Definitions:
  "org.binaryinternals:binaryinternals.format.class:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.class<font point-size="10"><br/>21.0</font>>]
  "org.binaryinternals:binaryinternals.commonlib:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.commonlib<font point-size="10"><br/>3.6</font>>]
  "org.binaryinternals:binaryinternals.format.bmp:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.bmp<font point-size="10"><br/>1.1</font>>]
  "org.binaryinternals:binaryinternals.format.jpeg:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.jpeg<font point-size="10"><br/>2.1</font>>]
  "org.binaryinternals:binaryinternals.format.zip:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.zip<font point-size="10"><br/>0.8</font>>]
  "org.binaryinternals:binaryinternals.format.pdf:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.pdf<font point-size="10"><br/>0.6</font>>]
  "org.binaryinternals:binaryinternals.format.dex:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.dex<font point-size="10"><br/>0.8</font>>]
  "org.binaryinternals:binaryinternals.format.elf:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.elf<font point-size="10"><br/>0.3</font>>]
  "org.binaryinternals:binaryinternals.format.png:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>binaryinternals.format.png<font point-size="10"><br/>1.1</font>>]
  "org.binaryinternals:BinaryInternalsViewer:jar:compile"[label=<<font point-size="10">org.binaryinternals</font><br/>BinaryInternalsViewer<font point-size="10"><br/>3.6</font>>]

  // Edge Definitions:
  "org.binaryinternals:binaryinternals.format.class:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.bmp:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.jpeg:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.zip:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.pdf:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.dex:jar:compile" -> "org.binaryinternals:binaryinternals.format.class:jar:compile"
  "org.binaryinternals:binaryinternals.format.elf:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:binaryinternals.format.png:jar:compile" -> "org.binaryinternals:binaryinternals.commonlib:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.bmp:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.jpeg:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.zip:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.pdf:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.dex:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.elf:jar:compile"
  "org.binaryinternals:BinaryInternalsViewer:jar:compile" -> "org.binaryinternals:binaryinternals.format.png:jar:compile"
}
```

`format-class-masstest.sh`:

```sh
#!/bin/bash
#
# Mass test for Java Class Viewer
#   This script is trying to test on all the .class files in the JAVA_HOME/jmods/*.jmod files
#   This script is designed to execute on Ubuntu Linux
#
# Parameter
#   We can edit the JAVA_FOLDER variable in the script if want to test with other Java versions
#

# Java folder location, in Ubunut linux
JAVA_FOLDER="/usr/lib/jvm/default-java"


logtime() {
  retval=$(date '+%Y-%m-%d.%T.%3N')
  echo $retval
}

mkdir -p   target/masstest
cd         target/masstest && pwd
rm    -rf  *

touch      masstest.cmds
find "$JAVA_FOLDER/jmods/" -iname *.jmod | while read jmodfilename; do
  jmodfilename_nopath=$(basename -- "$jmodfilename")
  jmodfilename_short="${jmodfilename_nopath%.*}"

  echo "$(logtime) Processing $jmodfilename , filename=$jmodfilename_nopath shortfilename=$jmodfilename_short"

  # Get and Extract the file
  cp       $jmodfilename .
  unzip -q $jmodfilename_nopath -d $jmodfilename_short

  # Processing each .class file
  find $jmodfilename_short -iname *.class | while read classfilename; do
    echo "timeout 5 java -Dorg.binaryinternals.masstestmode=true -jar ../../BinaryInternalsViewer/target/BinaryInternalsViewer-3.6.jar '$classfilename'" >> masstest.cmds
  done

  # Clean up .jmod file
  rm       $jmodfilename_nopath
done

echo "$(logtime) Commands sample"
tail -10 masstest.cmds

echo "$(logtime) Mass Test Starts"

parallel --ungroup -j 50% < masstest.cmds

# Go back
cd ../../
echo "$(logtime) Finished"

```

`format-class.sh`:

```sh
#!/bin/bash
#
# Build one format only
#


export JAVA_HOME=/usr/lib/jvm/default-java
#export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
java -version

mvn  --projects CommonLib,FormatCLASS,BinaryInternalsViewer  clean package install

```

`format-dex.sh`:

```sh
#!/bin/bash
#
# Build one format only
#

export JAVA_HOME=/usr/lib/jvm/default-java
mvn  --projects CommonLib,FormatDEX,BinaryInternalsViewer  clean package install


```

`format-elf.sh`:

```sh
#!/bin/bash
#
# Build one format only
#

export JAVA_HOME=/usr/lib/jvm/default-java
mvn  --projects FormatELF,BinaryInternalsViewer  clean package install


```

`format-pdf.sh`:

```sh
#!/bin/bash
#
# Build one format only
#

export JAVA_HOME=/usr/lib/jvm/default-java
mvn  --projects FormatPDF,BinaryInternalsViewer  clean package install


```

`format-zip.sh`:

```sh
#!/bin/bash
#
# Build one format only
#

export JAVA_HOME=/usr/lib/jvm/default-java
mvn  --projects CommonLib,FormatZIP,BinaryInternalsViewer  clean package install


```

`pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.binaryinternals</groupId>
    <artifactId>binaryinternals</artifactId>
    <version>${revision}</version>
    <packaging>pom</packaging>

    <name>Binary Internals</name>
    <description>Show binary file internals visually and interactively for the meaning of every bit</description>
    <url>http://www.binaryinternals.org</url>

    <licenses>
        <license>
            <name>Apache License, Version 2.0</name>
            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
            <distribution>repo</distribution>
            <comments>A business-friendly OSS license</comments>
        </license>
    </licenses>

    <organization>
        <name>Binary Internals</name>
        <url>http://www.binaryinternals.org</url>
    </organization>

    <developers>
        <developer>
            <id>as</id>
            <name>Amos Shi</name>
            <url>https://github.com/amosshi</url>
        </developer>
    </developers>

    <scm>
        <connection>scm:git:git://github.com/amosshi/binaryinternals.git</connection>
        <url>https://github.com/amosshi/binaryinternals</url>
        <tag>HEAD</tag>
    </scm>

    <properties>
        <maven.compiler.release>17</maven.compiler.release>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <revision>3.6</revision>

        <buildnumber-maven-plugin.version>3.2.0</buildnumber-maven-plugin.version><!-- https://mvnrepository.com/artifact/org.codehaus.mojo/buildnumber-maven-plugin -->
        <git-commit-id-maven-plugin.version>6.0.0</git-commit-id-maven-plugin.version><!-- https://mvnrepository.com/artifact/io.github.git-commit-id/git-commit-id-maven-plugin -->
        <maven-assembly-plugin.version>3.6.0</maven-assembly-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-assembly-plugin -->
        <maven-checkstyle-plugin.version>3.3.0</maven-checkstyle-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-checkstyle-plugin -->
        <maven-dependency-plugin.version>3.6.0</maven-dependency-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-dependency-plugin -->
        <maven-jar-plugin.version>3.3.0</maven-jar-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-jar-plugin -->
        <maven-javadoc-plugin.version>3.6.0</maven-javadoc-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-javadoc-plugin -->
        <maven-jxr-plugin.version>3.3.0</maven-jxr-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-jxr-plugin -->
        <maven-pmd-plugin.version>3.21.0</maven-pmd-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-pmd-plugin -->
        <maven-surefire-report-plugin.version>3.1.2</maven-surefire-report-plugin.version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-surefire-report-plugin -->
        <spotbugs-maven-plugin.version>4.7.3.5</spotbugs-maven-plugin.version><!-- https://mvnrepository.com/artifact/com.github.spotbugs/spotbugs-maven-plugin -->
        <spotbugs.version>4.7.3</spotbugs.version><!-- https://mvnrepository.com/artifact/com.github.spotbugs/spotbugs-annotations -->
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.github.spotbugs</groupId>
            <artifactId>spotbugs-annotations</artifactId>
            <version>${spotbugs.version}</version>
            <type>jar</type>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <!-- Generate git.properties -->
            <plugin>
                <groupId>io.github.git-commit-id</groupId>
                <artifactId>git-commit-id-maven-plugin</artifactId>
                <version>${git-commit-id-maven-plugin.version}</version>
                <executions>
                    <execution>
                        <id>get-the-git-infos</id>
                        <goals>
                            <goal>revision</goal>
                        </goals>
                        <phase>initialize</phase>
                    </execution>
                </executions>
                <configuration>
                    <generateGitPropertiesFile>true</generateGitPropertiesFile>
                    <generateGitPropertiesFilename>${project.build.outputDirectory}/git.properties</generateGitPropertiesFilename>
                    <includeOnlyProperties>
                        <includeOnlyProperty>^git.build.(time|version)$</includeOnlyProperty>
                        <includeOnlyProperty>^git.commit.id.(abbrev|full)$</includeOnlyProperty>
                    </includeOnlyProperties>
                    <commitIdGenerationMode>full</commitIdGenerationMode>
                </configuration>
            </plugin>

            <!-- Add SCM versiont to manifest -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>buildnumber-maven-plugin</artifactId>
                <version>${buildnumber-maven-plugin.version}</version>
                <executions>
                    <execution>
                        <phase>validate</phase>
                        <goals>
                            <goal>create</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <getRevisionOnlyOnce>true</getRevisionOnlyOnce>
                    <attach>true</attach>
                    <addOutputDirectoryToResources>true</addOutputDirectoryToResources>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
                <configuration>
                    <archive>
                        <manifestEntries>
                            <Build-Time>${maven.build.timestamp}</Build-Time>
                        </manifestEntries>

                        <manifestSections>
                            <manifestSection>
                                <name>Versions</name>
                                <manifestEntries>
                                    <Implementation-Version>${project.version}</Implementation-Version>
                                    <Implementation-SCM-Revision>${buildNumber}</Implementation-SCM-Revision>
                                    <Implementation-SCM-Branch>${scmBranch}</Implementation-SCM-Branch>
                                </manifestEntries>
                            </manifestSection>
                        </manifestSections>
                    </archive>
                </configuration>
            </plugin>

            <!-- Java Compiler Show Deprecation and Warnings -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-compiler-plugin -->
                <configuration>
                    <showDeprecation>true</showDeprecation>
                    <showWarnings>true</showWarnings>
                    <compilerArgument>-Xlint:unchecked</compilerArgument>
                </configuration>
            </plugin>

            <!-- Check Style: https://maven.apache.org/plugins/maven-checkstyle-plugin/index.html -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>3.3.0</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-checkstyle-plugin -->
                <dependencies>
                    <dependency>
                        <groupId>com.puppycrawl.tools</groupId>
                        <artifactId>checkstyle</artifactId>
                        <version>10.12.3</version><!-- https://mvnrepository.com/artifact/com.puppycrawl.tools/checkstyle -->
                    </dependency>
                </dependencies>
                <configuration>
                    <!-- https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/sun_checks.xml -->
                    <!-- https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/google_checks.xml -->
                    <configLocation>google_checks.xml</configLocation>
                    <!--
                    <configLocation>sun_checks.xml</configLocation>
                    -->
                </configuration>
                <executions>
                    <execution>
                        <id>checkstyle</id>
                        <phase>validate</phase>
                        <configuration>
                            <failOnViolation>true</failOnViolation>
                        </configuration>
                        <goals>
                            <goal>check</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Spotbugs -->
            <plugin>
                <groupId>com.github.spotbugs</groupId>
                <artifactId>spotbugs-maven-plugin</artifactId>
                <version>${spotbugs-maven-plugin.version}</version>
                <dependencies>
                    <dependency>
                        <groupId>com.github.spotbugs</groupId>
                        <artifactId>spotbugs</artifactId>
                        <version>${spotbugs.version}</version>
                    </dependency>
                </dependencies>

                <executions>
                    <execution>
                        <id>spotbugs</id>
                        <phase>validate</phase>
                        <configuration>
                            <xmlOutput>true</xmlOutput>
                        </configuration>
                        <goals>
                            <goal>check</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-pmd-plugin</artifactId>
                <version>${maven-pmd-plugin.version}</version>
            </plugin>

            <!-- Make sure we did not call JDK internal APIs -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jdeps-plugin</artifactId>
                <version>3.1.2</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-jdeps-plugin -->
                <executions>
                    <execution>
                        <goals>
                            <goal>jdkinternals</goal> <!-- verify main classes -->
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Generate Javadocs -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>${maven-javadoc-plugin.version}</version>
                <configuration>
                    <additionalJOption>-J-Xmx4g </additionalJOption>
                    <additionalOptions>-html5</additionalOptions>
                    <detectJavaApiLink>true</detectJavaApiLink>
                    <detectLinks>true</detectLinks>
                    <doclint>all,-missing</doclint><!-- Ignore Javadoc warning as of now -->
                    <header>Binary Internals &lt;br&gt; View Internals of Binary File</header>
                    <show>private</show>
                    <links>
                        <link>https://docs.oracle.com/en/java/javase/17/docs/api</link>
                    </links>
                </configuration>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Creates a jar archive of the source files of the current project -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.3.0</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-source-plugin -->
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-pdf-plugin</artifactId>
                <version>1.6.1</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-pdf-plugin -->
                <executions>
                    <execution>
                        <id>pdf</id>
                        <phase>site</phase>
                        <goals>
                            <goal>pdf</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.reporting.outputDirectory}</outputDirectory>
                            <includeReports>false</includeReports>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <!-- Site -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-site-plugin</artifactId>
                <version>3.12.1</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-site-plugin -->
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-deploy-plugin</artifactId>
                <version>3.1.1</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-deploy-plugin -->
                <executions>
                    <execution>
                        <id>default-deploy</id>
                        <phase>deploy</phase>
                        <goals>
                            <goal>deploy</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- https://maven.apache.org/maven-ci-friendly.html -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>flatten-maven-plugin</artifactId>
                <version>1.5.0</version><!-- https://mvnrepository.com/artifact/org.codehaus.mojo/flatten-maven-plugin -->
                <configuration>
                    <updatePomFile>true</updatePomFile>
                    <flattenMode>resolveCiFriendliesOnly</flattenMode>
                </configuration>
                <executions>
                    <execution>
                        <id>flatten</id>
                        <phase>process-resources</phase>
                        <goals>
                            <goal>flatten</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>flatten.clean</id>
                        <phase>clean</phase>
                        <goals>
                            <goal>clean</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

        </plugins>
    </build>

    <distributionManagement>
        <site>
            <id>site-local</id>
            <url>file:target/site-local</url>
        </site>
    </distributionManagement>

    <reporting>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-project-info-reports-plugin</artifactId>
                <version>3.4.5</version><!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-project-info-reports-plugin -->
                <reportSets>
                    <reportSet>
                        <reports><!-- select reports -->
                            <report>index</report>
                        </reports>
                    </reportSet>
                </reportSets>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>${maven-javadoc-plugin.version}</version>
                <reportSets>
                    <reportSet><!-- aggregate reportSet, to define in poms having modules -->
                        <id>aggregate</id>
                        <inherited>false</inherited><!-- don't run aggregate in child modules -->
                        <reports>
                            <report>aggregate</report>
                        </reports>
                    </reportSet>
                </reportSets>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jxr-plugin</artifactId>
                <version>${maven-jxr-plugin.version}</version>
                <reportSets>
                    <reportSet>
                        <id>aggregate</id>
                        <inherited>false</inherited>
                        <reports>
                            <report>aggregate</report>
                        </reports>
                    </reportSet>
                </reportSets>                
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>${maven-checkstyle-plugin.version}</version>
                <reportSets>
                    <reportSet>
                        <reports>
                            <report>checkstyle</report>
                        </reports>
                    </reportSet>
                </reportSets>
            </plugin>

            <plugin>
                <groupId>com.github.spotbugs</groupId>
                <artifactId>spotbugs-maven-plugin</artifactId>
                <version>${spotbugs-maven-plugin.version}</version>
                <configuration>
                    <xmlOutput>true</xmlOutput>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-pmd-plugin</artifactId>
                <version>${maven-pmd-plugin.version}</version>
                <configuration>
                    <linkXref>true</linkXref>
                    <inputEncoding>utf-8</inputEncoding>
                </configuration>
                <reportSets>
                    <reportSet><!-- by default, id = "default" -->
                        <reports><!-- select non-aggregate reports -->
                            <report>pmd</report>
                            <report>cpd</report>
                        </reports>
                    </reportSet>
                    <reportSet><!-- aggregate reportSet, to define in poms having modules -->
                        <id>aggregate</id>
                        <inherited>false</inherited> <!-- don't run aggregate in child modules -->
                        <reports>
                            <report>aggregate-pmd</report>
                            <report>aggregate-cpd</report>
                        </reports>
                    </reportSet>
                </reportSets>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-report-plugin</artifactId>
                <version>${maven-surefire-report-plugin.version}</version>
            </plugin>
        </plugins>
    </reporting>

    <modules>
        <module>CommonLib</module>
        <module>BinaryInternalsViewer</module>

        <!-- Libs ready to use -->
        <module>FormatBMP</module>
        <module>FormatCLASS</module>
        <module>FormatJPEG</module>
        <module>FormatPNG</module>
        <module>FormatZIP</module>

        <!-- Libs still in development -->
        <module>FormatDEX</module>
        <module>FormatELF</module>

        <!-- Libs on hold -->
        <module>FormatPDF</module>
    </modules>
</project>

```