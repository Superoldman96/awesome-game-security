Project Path: arc_gmh5225_McDota_bevnhbm9

Source Tree:

```txt
arc_gmh5225_McDota_bevnhbm9
├── CMakeLists.txt
├── LICENSE.txt
├── README.md
├── debug
├── debug_user
├── dotaparticleblacklist.txt.example
├── dotaparticletracker.txt.example
├── gdb_debug_attach.txt
├── gdb_debug_inject.txt
├── load
├── load-stealth
├── load_carto
├── rebuildprotos.sh
├── src
│   ├── GUI
│   │   ├── Callbacks.cpp
│   │   ├── Callbacks.h
│   │   ├── Gui.cpp
│   │   ├── Gui.h
│   │   └── Main.xml
│   ├── Hacks
│   │   ├── Esp.cpp
│   │   ├── Esp.h
│   │   ├── Zoom.cpp
│   │   └── Zoom.h
│   ├── Hooks
│   │   ├── CreateEvent.cpp
│   │   ├── CreateMove.cpp
│   │   ├── CreateNetChannel.cpp
│   │   ├── CreateParticleCollection.cpp
│   │   ├── DeleteParticleCollection.cpp
│   │   ├── FireEventClientSide.cpp
│   │   ├── FrameStageNotify.cpp
│   │   ├── GetFoWAmount.cpp
│   │   ├── GetFogEnd.cpp
│   │   ├── GetZFar.cpp
│   │   ├── HardHooks.h
│   │   ├── Hard_BAsyncSendProto.cpp
│   │   ├── Hard_DispatchPacket.cpp
│   │   ├── Hooks.h
│   │   ├── LevelInit.cpp
│   │   ├── PaintTraverse.cpp
│   │   ├── PostReceivedNetMessage.cpp
│   │   ├── RunScript.cpp
│   │   ├── SendNetMessage.cpp
│   │   ├── SetKeyCodeState.cpp
│   │   └── StartSoundEvent.cpp
│   ├── Interfaces.cpp
│   ├── Interfaces.h
│   ├── McDota.cpp
│   ├── Netvars.cpp
│   ├── Netvars.h
│   ├── SDK
│   │   ├── CBaseCombatCharacter.h
│   │   ├── CBaseEntity.h
│   │   ├── CBaseFileSystem.h
│   │   ├── CCollisionProperty.h
│   │   ├── CDOTAPlayerResource.h
│   │   ├── CDOTARichPresence.h
│   │   ├── CDOTAWearableItem.h
│   │   ├── CDotaBaseNPC.h
│   │   ├── CDotaCamera.h
│   │   ├── CDotaFogOfWarSystem.h
│   │   ├── CDotaPlayer.h
│   │   ├── CEngineServiceMgr.h
│   │   ├── CFontManager.h
│   │   ├── CGCClient.h
│   │   ├── CGameEntitySystem.h
│   │   ├── CGameEventManager.h
│   │   ├── CGameEventSystem.h
│   │   ├── CGlobalVars.h
│   │   ├── CNetworkGameClient.h
│   │   ├── CNetworkMessages.h
│   │   ├── CNetworkStringTableContainer.h
│   │   ├── CNetworkSystem.h
│   │   ├── CPanoramaGameScriptScope.h
│   │   ├── CParticleCollection.h
│   │   ├── CParticleSystemMgr.h
│   │   ├── CRenderDeviceGL.h
│   │   ├── CRenderGameSystem.h
│   │   ├── CSoundOPSystem.h
│   │   ├── CSource2Client.h
│   │   ├── CSplitScreenService.h
│   │   ├── CUtlMemory.h
│   │   ├── CUtlString.h
│   │   ├── CUtlVector.h
│   │   ├── CVPhys2World.h
│   │   ├── CVScriptGameSystem.h
│   │   ├── CViewRender.h
│   │   ├── CViewSetup.h
│   │   ├── ConMsg.h
│   │   ├── Convar.h
│   │   ├── Datamap.h
│   │   ├── IAppSystem.h
│   │   ├── IClientMode.h
│   │   ├── ICvar.h
│   │   ├── IEngineClient.h
│   │   ├── IInputSystem.h
│   │   ├── IMaterial.h
│   │   ├── IMaterialSystem.h
│   │   ├── INetChannel.h
│   │   ├── INetSupport.h
│   │   ├── INetworkClientService.h
│   │   ├── IVGuiPaintSurface.h
│   │   ├── IVPanel.h
│   │   ├── SDK.h
│   │   ├── Schema.h
│   │   ├── Valve
│   │   │   ├── tier0
│   │   │   │   ├── memoverride.cpp
│   │   │   │   └── memoverride.h
│   │   │   └── tier1
│   │   │       └── utldelegateimpl.h
│   │   ├── bf_read.h
│   │   ├── bf_write.h
│   │   ├── color.h
│   │   ├── common.h
│   │   ├── definitions.h
│   │   ├── panorama
│   │   │   ├── CPanel2D.h
│   │   │   ├── IUIEvent.h
│   │   │   ├── IUIPanel.h
│   │   │   ├── PanoramaUIEngine.h
│   │   │   └── types.h
│   │   ├── vector.h
│   │   └── vmatrix.h
│   ├── Scanner.cpp
│   ├── Scanner.h
│   ├── Settings.cpp
│   ├── Settings.h
│   ├── Utils
│   │   ├── Crc32.h
│   │   ├── Draw.cpp
│   │   ├── Draw.h
│   │   ├── Integritycheck.cpp
│   │   ├── Integritycheck.h
│   │   ├── Keyvalue.cpp
│   │   ├── Keyvalue.h
│   │   ├── Logger.h
│   │   ├── Math.cpp
│   │   ├── Math.h
│   │   ├── Memory.cpp
│   │   ├── Memory.h
│   │   ├── Patternfinder.cpp
│   │   ├── Patternfinder.h
│   │   ├── Protobuf.cpp
│   │   ├── Protobuf.h
│   │   ├── Util.cpp
│   │   ├── Util.h
│   │   ├── Util_sdk.cpp
│   │   ├── Util_sdk.h
│   │   ├── Vmt.h
│   │   └── subhook
│   │       ├── CMakeLists.txt
│   │       ├── LICENSE.txt
│   │       ├── README.md
│   │       ├── appveyor.yml
│   │       ├── cmake
│   │       │   └── FindYasm.cmake
│   │       ├── subhook.c
│   │       ├── subhook.h
│   │       ├── subhook_private.h
│   │       ├── subhook_unix.c
│   │       └── subhook_x86.c
│   └── protos
│       └── mcdota.proto
├── uload
├── uload-stealth
├── uload_force
└── zombies

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0) #3.0 for multi-line strings
project(McDota)
include(FindProtobuf)

if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
	if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.1)
		message(FATAL_ERROR "Your GCC seems outdated. ( Requires >=7.1 for C++17 support )")
	endif()
else()
	message(FATAL_ERROR "You must have GCC >= 7.1 installed in order to compile")
endif()

FUNCTION (EXCLUDE_FILES_FROM_DIR_IN_LIST _InFileList _excludeDirName _verbose)
	foreach (ITR ${_InFileList})
		if ("${_verbose}")
			message(STATUS "ITR=${ITR}")
		endif ("${_verbose}")

		if ("${ITR}" MATCHES "(.*)${_excludeDirName}(.*)") # Check if the item matches the directory name in _excludeDirName
			message(STATUS "Remove Item from List:${ITR}")
			list (REMOVE_ITEM _InFileList ${ITR}) # Remove the item from the list
		endif ("${ITR}" MATCHES "(.*)${_excludeDirName}(.*)")

	endforeach(ITR)
	set(SOURCE_FILES ${_InFileList} PARENT_SCOPE) # Return the SOURCE_FILES variable to the calling parent
ENDFUNCTION (EXCLUDE_FILES_FROM_DIR_IN_LIST)

find_package(Protobuf REQUIRED)
message("Found Protobuf Version ${Protobuf_VERSION}")

#unfortunately shit will randomly segfault if you're on a different version.
if( NOT ${Protobuf_VERSION} VERSION_EQUAL "3.15.3" )
	message(FATAL_ERROR "ERROR! ERROR! Your Protobuf is the WRONG VERSION!\nRequired Version is: 3.15.3\nBecause Valve uses Pre-2011 std::string ABI (as of dota-anime update) You need to build protobufs from Source!\nSee the README!")
endif()

add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)

#no-pmf-conversions warning for deducing vtable offsets from our class prototypes sdk
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}\
 -O3 \
 -std=c++17 \
 -Wall \
 -Wextra \
 -Wformat \
 -Wno-unused-parameter \
 -Wno-implicit-fallthrough \
 --no-gnu-unique \
 -Wno-pmf-conversions \
 -fno-exceptions \
 -fPIC \
 -shared \
 -ffast-math \
 -fno-math-errno \
 -fno-ident \
 -fno-stack-protector \
 -ffunction-sections \
 -fdata-sections \
 -fno-threadsafe-statics \
 -Wl,-z,now \
 -Wl,-z,norelro \
 -pipe \
 -Wl,--hash-style=gnu")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -ggdb ")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s -fvisibility=hidden -fvisibility-inlines-hidden")

# Depending on system/updates, you may need to statically link libstdc++
set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}")# -static-libstdc++")

if(NOT CMAKE_BUILD_TYPE)
	message(STATUS "No build type selected, default to Release")
	set(CMAKE_BUILD_TYPE RELEASE)
endif(NOT CMAKE_BUILD_TYPE)

file(GLOB_RECURSE SOURCE_FILES "${CMAKE_SOURCE_DIR}/src/*.cpp"
		"${CMAKE_SOURCE_DIR}/src/Utils/subhook/subhook.c")
EXCLUDE_FILES_FROM_DIR_IN_LIST("${SOURCE_FILES}" "${CMAKE_SOURCE_DIR}/src/Utils/subhook/tests" FALSE)

include_directories(${INCLUDE_DIRS} ${PROTOBUF_INCLUDE_DIR})

add_library(McDota SHARED ${SOURCE_FILES} src/SDK/Valve/tier0/memoverride.cpp)
target_link_libraries(McDota dl pthread ${PROTOBUF_LIBRARY})

```

`LICENSE.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# McDota 

[![Gitter](https://badges.gitter.im/McDota/community.svg)](https://gitter.im/McDota/community?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)

![Bugboy](https://i.imgur.com/qC9hz14.png)

McDota is a Cheat and tinker tool for Dota 2 on Linux.

It has been built from the ground-up to be faster and better than previous cheats.

## Features
* Fully Dynamic Panorama UI that is created on runtime and modifies no files.
* Integrity System that tries to detect when and where updates break the cheat.
* All features are native C++
* No ConVars are changed ever
* Lua Execution ( implemented but not used, see `vscriptSystem->RunScript` )
* Camera Zoom, pitch/yaw
* ESP, spotted ESP ( when seen by enemy team ), info.
* No Fog / No Fog of War ( not a maphack )
* Full Protobuf packet interception/inspection/editing.
* More...
## System Requirements
* CMake
* a C++17 compiler ( like `clang` or `gcc` )
* Build essentials( make, `gdb`, etc.. )
* [google protobufs](https://github.com/protocolbuffers/protobuf/archive/v3.7.0.tar.gz) development library - Version 3.7.0 is recommended! The Newest versions are not compatible and will segfault even in proto2 mode!
## Build Instructions
####**Update:** Dota Anime-Patch has Introduced Pre-2011 String ABI into the game. This means you Need to build protobufs from Source!
#### (Pre-Requisite)Building Protobufs
```
First, uninstall any protobuf-devel package your distro may have. (Just the headers/libs don't remove Gnome)

git clone https://github.com/protocolbuffers/protobuf
git checkout v3.15.3
./autogen.sh && ./configure
make -j8 CFLAGS=-D_GLIBCXX_USE_CXX11_ABI=0 CXXFLAGS=-D_GLIBCXX_USE_CXX11_ABI=0
cd src
sudo make install
sudo ldconfig #refresh .so cache

Check in the terminal the Version is correct.
[gamer@localhost McDota-Master]$ protoc --version
libprotoc 3.15.3
```


First Build Protobufs
`./rebuildprotos.sh`

Now you can build the project 
`cmake . && make -j`


*For a Debug Build*
`cmake . -DCMAKE_BUILD_TYPE="Debug" . && make -j`

## Usage Instructions
There are 3 different load scripts.
 **#2 is the Recommended way to load for online play**


 1. `load` will load "libMcDota.so" normally into the game. I normally use this just for development and don't recommend that you use it online because it is easy to detect.
 2. `load_carto` has Cartographer Integration(R) and will first check for [Cartographer](https://github.com/LWSS/Cartographer) to be loaded, then it will set the Cartographer settings for you, and finally inject McDota into the game. 
 3. `load-stealth` Will rename and move"libMcdota.so" into a file that looks legit and then load it into the Game. ( Originally made by [Marc](https://github.com/Marc3842h) for Spookware ). This is a good compromise if you don't want to install or use Cartographer.


Each script also has a corresponding unload script.  
#1 uses no spaces, #2 uses underscores, and #3 uses dashes. I use this format to tab autocomplete

Press `Insert` to Open/Close the in-game Menu ( works in-game and in-menu )
## Screenshots
![Main](https://i.imgur.com/k3HGweu.png)
![Visuals](https://i.imgur.com/MrkXw9Q.png)
## Known Issues
* There is a very rare tcmalloc bug I have encountered that will just crash your game. I can't seem to reproduce it when it happens.
* Sometimes the UI will not open on the first time, I think I have fixed this, but if this happens to you, check the console and just try again.
* Debug builds do not unload
* SELinux might cause a problem with hardhooks

## Credits
LWSS(me) - Founder

[praydog](https://github.com/praydog) - His [research](http://praydog.com/index.php/2015/06/24/an-analysis-of-the-source-2-engine-part-1-the-schema-system/) into the SchemaSystem helped me especially when I was starting the project.

[subhook](https://github.com/Zeex/subhook) - I Use a modified version of this library to do the Hard Hooks used for GC msgs ( changing .code section )

## License
GPL3 - 
see LICENSE.txt

```

`debug`:

```
#!/bin/bash
# Starts a GDB session on Dota, injects cheat if it is not already present.
# Send SIGINT to Dota with: "kill -2 "$(pidof dota2)"".

dota_pid=$(pidof dota2)
if [ -z "$dota_pid" ]; then
    /bin/echo -e "\\e[31mDota needs to be open before you can inject...\\e[0m"
    exit 1
fi

# pBypass for crash dumps being sent
# You may also want to consider using -nobreakpad in your launch options.
sudo rm -rf /tmp/dumps # Remove if it exists
sudo mkdir /tmp/dumps # Make it as root
sudo chmod 000 /tmp/dumps # No permissions

filename="libMcDota.so"

# https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to inject code. This is temporary until reboot.

# dlopen method Credits: Aixxe @ aixxe.net
if grep -q "$filename" /proc/"$dota_pid"/maps; then
    sudo gdb -p "$dota_pid" -x ./gdb_debug_attach.txt
else
	  path="$(pwd)/$filename"
	  #put library name on first line
	  sed -i "1cset \$library = \"$path\"" ./gdb_debug_inject.txt
    echo "Injecting build $path"
    sudo gdb -p "$dota_pid" -x ./gdb_debug_inject.txt
fi

```

`debug_user`:

```
#!/bin/bash
# Attach GDB with User-defined settings

dota_pid=$(pidof dota2)
if [ -z "$dota_pid" ]; then
    /bin/echo -e "\\e[31mDota needs to be open before you can inject...\\e[0m"
    exit 1
fi

# pBypass for crash dumps being sent
# You may also want to consider using -nobreakpad in your launch options.
sudo rm -rf /tmp/dumps # Remove if it exists
sudo mkdir /tmp/dumps # Make it as root
sudo chmod 000 /tmp/dumps # No permissions

filename="libMcDota.so"

# https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "0" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to inject code. This is temporary until reboot.

# dlopen method Credits: Aixxe @ aixxe.net
if grep -q "$filename" /proc/"$dota_pid"/maps; then
    gdb -p "$dota_pid"
else
	path="$(pwd)/$filename"
    echo "Injecting build $path"
    gdb -p "$dota_pid"
fi

```

`dotaparticleblacklist.txt.example`:

```example
particles/generic_gameplay/generic_hit_blood.vpcf
particles/generic_gameplay/water_splash.vpcf
```

`dotaparticletracker.txt.example`:

```example
particles/units/heroes/hero_mirana/mirana_spell_arrow.vpcf
```

`gdb_debug_attach.txt`:

```txt
set $dlopen = (void*(*)(char*, int)) dlopen
set $dlmopen = (void* (*)(long int, char*, int)) dlmopen
set $dlinfo = (int (*)(void*, int, void*)) dlinfo
set $malloc = (void* (*)(long long)) malloc
set $dlerror = (char* (*)(void)) dlerror
set confirm off
set disassembly-flavor intel
set  disassemble-next-line on
show disassemble-next-line
layout asm

```

`gdb_debug_inject.txt`:

```txt
set $library = "/home/blackops/Documents/McDota-Master/libMcDota.so"
set $dlopen = (void*(*)(char*, int)) dlopen
set $dlmopen = (void* (*)(long int, char*, int)) dlmopen
set $dlinfo = (int (*)(void*, int, void*)) dlinfo
set $malloc = (void* (*)(long long)) malloc
set $dlerror = (char* (*)(void)) dlerror
set confirm off
set disassembly-flavor intel
set  disassemble-next-line on
show disassemble-next-line
layout asm
call $dlopen($library, 2)
```

`load`:

```
#!/bin/bash

dota_pid=$(pidof dota2)
if [ -z "$dota_pid" ]; then
    /bin/echo -e "\\e[31mDota2 needs to be open before you can inject...\\e[0m"
    exit 1
fi

# pBypass for crash dumps being sent
# You may also want to consider using -nobreakpad in your launch options.
sudo rm -rf /tmp/dumps # Remove if it exists
sudo mkdir /tmp/dumps # Make it as root
sudo chmod 000 /tmp/dumps # No permissions

filename="libMcDota.so"

# Credit: Aixxe @ aixxe.net
if grep -q "$filename" /proc/"$dota_pid"/maps; then
    /bin/echo -e "\\e[33mMcDota is already injected... Aborting...\\e[0m"
    exit
fi
echo "Injecting Build ID: $filename"

# https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to ptrace. This is temporary until reboot.

sudo killall -19 steam
sudo killall -19 steamwebhelper

input="$(
sudo gdb -n -q -batch-silent \
  -ex "set logging on" \
  -ex "set logging file /dev/null" \
  -ex "set logging redirect on" \
  -ex "attach $dota_pid" \
  -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
  -ex "call \$dlopen(\"$(pwd)/$filename\", 2)" \
  -ex "detach" \
  -ex "quit"
)"

last_line="${input##*$'\n'}"

sleep 0.2
sudo killall -18 steamwebhelper
sudo killall -18 steam

if [ "$last_line" != "\$1 = (void *) 0x0" ]; then
    /bin/echo -e "\\e[32mSuccessfully injected!\\e[0m"
else
    /bin/echo -e "\\e[31mInjection failed, make sure you have compiled...\\e[0m"
fi

```

`load-stealth`:

```
#!/usr/bin/env bash

#skidded from Marc @ spookware

prefix="\e[34m\e[1mMcDota >\e[0m"
error_prefix="\e[91m\e[1mMcDota >\e[0m"
success_prefix="\e[32m\e[1mMcDota >\e[0m"

dota=$(pidof dota2)

if [ -z "dota" ]; then
    echo -e "$error_prefix Dota is not open!."
    exit -1
fi

last_library=""

if [ -e "/tmp/.mcdota" ]; then
    last_library=$(cat /tmp/.mcdota)
fi

# Credit to aixxe from AimTuxOfficial
if [ "$last_library" != "" ] && grep -q "$last_library" /proc/${dota}/maps; then
    echo -e "$error_prefix McDota has already been injected."
    exit -1
else
    rm -rf /tmp/.mcdota
fi

# Get the full path of the .so that we'll be faking
victim_lib=$(cat /proc/${dota}/maps | grep /usr/lib64/ | shuf -n 1)
victim_lib=${victim_lib##* }

# Some magic that I copied straight from Stackoverflow
victim_lib_array=(${victim_lib//./ })
number_to_spoof=${victim_lib_array[-1]}
library_path=$(IFS=. ; echo "${victim_lib_array[*]}")

if ! [[ "$number_to_spoof" =~ ^[0-9]+$ ]]; then
    # If the shared library doesn't have multiple versions, let's just append .0 at the end.
    number_to_spoof="$number_to_spoof.0"
else
    # else we'll increase the found version by one
    number_to_spoof=$(($number_to_spoof + 1))
fi

victim_lib_array[-1]="$number_to_spoof"
library_path=$(IFS=. ; echo "${victim_lib_array[*]}")

if [ -e "$library_path" ]; then
    echo -e "$error_prefix McDota refuses to overwrite existing library files. Please re-run the script."
    exit -1
else
    sudo cp "libMcDota.so" "$library_path"
    sudo patchelf --set-soname "$library_path" "$library_path"
fi

echo "$library_path" > /tmp/.mcdota

echo -e "$prefix Attaching McDota spoofed as $library_path to PID dota"

# Allows only root to use ptrace. This is temporary until the user reboots the machine.
ptrace_input=$(sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope)

ptrace_last_line="${ptrace_input##*$'\n'}"

if [ "$ptrace_last_line" != "2" ]; then
    echo -e "$error_prefix Failed to set ptrace scope to root only. This \e[4mmay\e[24m be unsafe."
    while true; do
        echo -e -n "$error_prefix "
        read -p $'Do you wish to continue? (y/N) ' yn
        case $yn in
            [Yy]* ) break;;
            [Nn]* ) exit -1;;
            * ) echo -e "$error_prefix Please answer yes or no.";;
        esac
    done
fi

# Prevent crash dumps from being sent to kisak
sudo rm -rf /tmp/dumps
sudo mkdir /tmp/dumps
sudo chmod 000 /tmp/dumps

sudo killall -19 steam
sudo killall -19 steamwebhelper

# Uses dlmopen instead of normal dlopen - Credit to LWSS
input="$(
sudo gdb -n -q -batch \
  -ex "set logging on" \
  -ex "set logging file /dev/null" \
  -ex "attach $dota" \
  -ex "set \$linkMapID = (long int)0" \
  -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
  -ex "set \$dlmopen = (void*(*)(long int, char*, int)) dlmopen" \
  -ex "set \$dlinfo = (int (*)(void*, int, void*)) dlinfo" \
  -ex "set \$malloc = (void*(*)(long long)) malloc" \
  -ex "set \$dlerror = (char*(*)(void)) dlerror" \
  -ex "set \$target = \$dlopen(\"$library_path\", 2)" \
  -ex "p \$target" \
  -ex "p \$linkMapID" \
  -ex "call \$dlmopen(0, \"$library_path\", 1)" \
  -ex "set \$error = call dlerror()" \
  -ex "x/s \$error" \
  -ex "detach" \
  -ex "quit"
)"

sleep 1
sudo killall -18 steamwebhelper
sudo killall -18 steam

sudo rm -f "$library_path"

last_line="${input}"

if grep -q "$library_path" /proc/${dota}/maps; then
    echo -e "$success_prefix McDota has been successfully injected."
else
    echo -e ${last_line}
    echo -e "$error_prefix McDota has failed to inject. See the above GDB Spew."
fi

if [ -f "$(pwd)/gdb.txt" ]; then
    sudo rm -f gdb.txt
fi

```

`load_carto`:

```
#!/bin/bash

prefix="\e[34m\e[1mMcDota >\e[0m"
error_prefix="\e[91m\e[1mMcDota >\e[0m"
success_prefix="\e[32m\e[1mMcDota >\e[0m"

dota_pid=$(pidof dota2)
if [ -z "$dota_pid" ]; then
    /bin/echo -e "\\e[31mDota2 needs to be open before you can inject...\\e[0m"
    exit 1
fi

# pBypass for crash dumps being sent
# You may also want to consider using -nobreakpad in your launch options.
sudo rm -rf /tmp/dumps # Remove if it exists
sudo mkdir /tmp/dumps # Make it as root
sudo chmod 000 /tmp/dumps # No permissions

filename="libMcDota.so"

# Credit: Aixxe @ aixxe.net
if grep -q "$filename" /proc/"$dota_pid"/maps; then
    /bin/echo -e "\\e[33mMcDota is already injected... Aborting...\\e[0m"
    exit
fi

if grep -Rq "cartographer" /proc/modules
then
	sudo echo "turnoff allsettings" | sudo tee /proc/cartographer
        sudo echo "settarget libMcDota.so" | sudo tee /proc/cartographer
	sudo echo "removeentry" | sudo tee /proc/cartographer
else
    echo -e "$error_prefix Cartographer doesn't seem to be loaded. VAC will see McDota in the m-maps"
    while true; do
        echo -e -n "$error_prefix "
        read -p $'Do you wish to continue? (y/N) ' yn
        case $yn in
            [Yy]* ) break;;
            [Nn]* ) exit -1;;
            * ) echo -e "$error_prefix Please answer yes or no.";;
        esac
    done
fi

echo "Injecting Build ID: $filename"

# https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to ptrace. This is temporary until reboot.

sudo killall -19 steam
sudo killall -19 steamwebhelper

input="$(
sudo gdb -n -q -batch-silent \
  -ex "set logging on" \
  -ex "set logging file /dev/null" \
  -ex "set logging redirect on" \
  -ex "attach $dota_pid" \
  -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
  -ex "call \$dlopen(\"$(pwd)/$filename\", 1)" \
  -ex "detach" \
  -ex "quit"
)"

sleep 1
sudo killall -18 steamwebhelper
sudo killall -18 steam

last_line="${input##*$'\n'}"

if [ "$last_line" != "\$1 = (void *) 0x0" ]; then
    /bin/echo -e "\\e[32mSuccessfully injected!\\e[0m"
else
    /bin/echo -e "\\e[31mInjection failed, make sure you have compiled...\\e[0m"
fi

```

`rebuildprotos.sh`:

```sh
#!/usr/bin/env bash

cd ./src/protos/
rm mcdota.pb.cpp
rm mcdota.pb.cc
rm mcdota.pb.h
protoc --cpp_out=$(pwd) mcdota.proto
mv mcdota.pb.cc mcdota.pb.cpp
```

`src/GUI/Callbacks.cpp`:

```cpp
#include "Callbacks.h"

#include "../Hooks/Hooks.h"
#include "../Interfaces.h"
#include "../protos/mcdota.pb.h"

```

`src/GUI/Callbacks.h`:

```h
#pragma once


namespace UI
{
    namespace Callbacks
    {
        // Action 1

    }
}
```

`src/GUI/Gui.cpp`:

```cpp
#include "Gui.h"

#include <algorithm>
#include <fstream>

#include "../Interfaces.h"

std::string mainXML =
#include "Main.xml"
;

// https://stackoverflow.com/questions/440133/how-do-i-create-a-random-alpha-numeric-string-in-c
std::string gen_random(const int len)
{
    std::string tmp_s;
    static const char alphanum[] =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";

    srand((unsigned) time(NULL));

    tmp_s.reserve(len);

    for (int i = 0; i < len; ++i)
        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];


    return tmp_s;
}

static panorama::IUIPanel* GetHudRoot( ){
    panorama::IUIPanel *itr = nullptr;

    for( int i = 0; i < 4096; i++ ) {
        itr = panoramaEngine->AccessUIEngine( )->GetPanelArray( )->slots[i].panel;

        if ( !panoramaEngine->AccessUIEngine( )->IsValidPanelPointer( itr ) )
            continue;

        while ( itr && panoramaEngine->AccessUIEngine( )->IsValidPanelPointer( itr ) ) {
            if ( !strcasecmp( itr->GetID( ), "DOTAHud" ) ) {
                return itr;
            }
            itr = itr->GetParent();
        }
    }
    return nullptr;
}

static bool SetupAndCheckPanels()
{
    static std::string xmlFile = "/tmp/";
    static bool bFirst = true;
    // Dump our XML to file, then make the game load it, nice and EZ
    if( bFirst )
    {
        xmlFile += gen_random(6);
        xmlFile += ".xml";

        std::ofstream out(xmlFile);
        out << mainXML;
        out.close();

        bFirst = false;
    }
    /* Grab needed root panel if we don't have it already */
    if( engine->IsInGame() ){
        panorama::IUIPanel* panel = GetHudRoot();
        if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer( panel ) ){
            MC_PRINTF_WARN( "Could not Get HUD Root Panel! Invalid! (%p)\n", (void*)UI::hudRoot );
            return false;
        }
        UI::hudRoot = panel;
    } else if( !UI::dashRoot ){
        panorama::IUIPanel *panel = panoramaEngine->AccessUIEngine()->GetPanelArray()->slots[0].panel; // 0 = DotaDashboard
        if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer( panel ) ){
            MC_PRINTF_WARN( "Could not Get Dashboard Root Panel! Invalid! (%p)\n", (void*)UI::dashRoot );
            return false;
        }
        UI::dashRoot = panel;
    }
    /* Are we in-game? The Root panel is different */
    panorama::IUIPanel *root = ( engine->IsInGame() ? UI::hudRoot : UI::dashRoot );

    if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer(root) ){
        MC_PRINTF_WARN("Root panel pointer Invalid(%p)\n", (void*)root);
        return false;
    }
    if( !root->HasBeenLayedOut() ){
        MC_PRINTF_WARN("Root panel has not been layed out yet!\n");
        return false;
    }
    /* Going from menu->In-game OR Vice versa, set the pointer to NULL so we re-grab it below */
    if( panoramaEngine->AccessUIEngine()->IsValidPanelPointer( UI::mcDota ) ){
        if( (engine->IsInGame() && UI::mcDota->GetParent() != UI::hudRoot) ||
            (!engine->IsInGame() && UI::mcDota->GetParent() != UI::dashRoot) ){
            UI::mcDota = nullptr;
        }
    }
    /* Going from in-game back to menu, change the pointer to our existing panel if it is there. */
    if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer( UI::mcDota ) && !engine->IsInGame() ){
        panorama::IUIPanel* child = UI::dashRoot->GetLastChild();
        if( panoramaEngine->AccessUIEngine()->IsValidPanelPointer( child ) && strcmp(child->GetID(), "McDotaMain") == 0 ){
            MC_PRINTF("Grabbing existing child McDotaMain\n");
            UI::mcDota = child;
        }
    }
    /* Create our custom panel */
    if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer( UI::mcDota ) ){
        MC_PRINTF("Creating McDota Panel...\n");

        panorama::CPanoramaSymbol type = panoramaEngine->AccessUIEngine()->MakeSymbol("Panel");
        UI::mcDota = panoramaEngine->AccessUIEngine()->CreatePanel(&type, "McDotaMain", root)->panel;
        MC_PRINTF("Root ID: %s\n", root->GetID());
        UI::mcDota->SetParent( root );
    }
    // Load the file, then delete it
    if( !UI::mcDota->HasBeenLayedOut() )
    {
        std::string fileStr = "file://" + xmlFile;
        UI::mcDota->LoadLayoutFile(fileStr.c_str(), true);
        remove(xmlFile.c_str());
    }

    return true;
}

void UI::ToggleUI()
{
    SetupAndCheckPanels();

    if( !panoramaEngine->AccessUIEngine()->IsValidPanelPointer(UI::mcDota) ){
        MC_PRINTF_WARN("Something is wrong with our mcDota Panel Pointer(%p)\n", (void*)UI::mcDota);
        return;
    }
    if( !UI::mcDota->HasBeenLayedOut() ){
        MC_PRINTF_WARN("mcDota Panel not layed out yet. Try again.\n");
        return;
    }

    UI::mcDota->SetVisible(!UI::mcDota->IsVisible());

    /* Play Menu Open/Close sounds */
    if( UI::mcDota->IsVisible() )
        panoramaEngine->AccessUIEngine()->RunScript(UI::mcDota, "$.DispatchEvent( 'PlaySoundEffect', 'ui_menu_activate_open' );", engine->IsInGame() ? "panorama/layout/base_hud.xml" : "panorama/layout/base.xml", 8, 10, false );
    else
        panoramaEngine->AccessUIEngine()->RunScript(UI::mcDota, "$.DispatchEvent( 'PlaySoundEffect', 'ui_menu_activate_close' );", engine->IsInGame() ? "panorama/layout/base_hud.xml" : "panorama/layout/base.xml", 8, 10, false );

}
```

`src/GUI/Gui.h`:

```h
#pragma once

#include "../SDK/panorama/IUIPanel.h"

namespace UI
{
	/* Dota Panels */
	inline panorama::IUIPanel* dashRoot = nullptr;
	inline panorama::IUIPanel* hudRoot = nullptr;

	/* Custom Panels */
	inline panorama::IUIPanel* mcDota = nullptr;

	void ToggleUI();
}
```

`src/GUI/Main.xml`:

```xml
R"zz(
<root>
	<styles>
		<include src='s2r://panorama/styles/dotastyles.vcss_c' />
		<include src='s2r://panorama/styles/popups/popups_shared.vcss_c' />
		<include src='s2r://panorama/styles/battle_pass/current_battle_pass.vcss_c' />
		<include src='s2r://panorama/styles/popups/popup_settings.vcss_c' />
	</styles>

	<script>
		function changeTab( nTab ){
			/* All tabs set invis first */
			$( '#McTabGeneral' ).visible = false;
			$( '#McTabAbout' ).visible = false;
			$( '#McTabVisuals' ).visible = false;
			$( '#McTabMisc' ).visible = false;
			$( '#McTabPerf' ).visible = false;

			switch( nTab ){
				case 0:
					$( '#McTabGeneral' ).visible = true;
					break;
				case 1:
					$( '#McTabVisuals' ).visible = true;
					break;
				case 2:
					$( '#McTabMisc' ).visible = true;
					break;
				case 3:
					$( '#McTabPerf' ).visible = true;
					break;
				case 10:
					$( '#McTabAbout' ).visible = true;
					break;
			}
		}

		function closeSelf(){
			$( '#McDotaMain' ).visible = false;
		}

		function setAboutText( nContributor ){
			switch( nContributor ){
				case 0:
					$( '#aboutText' ).text = 'LWSS: Main Developer and Founder';
					break;
				case 1:
					$( '#aboutText' ).text = 'Praydog: Dota 2 Schemasystem Research';
					break;
			}
		}

		function clearAboutText(){
			$( '#aboutText' ).text = '';
		}

		function clickSound(){
            $.DispatchEvent( 'PlaySoundEffect', 'ui_team_select_pick_team' );
		}

		function executeJS(){
			/* eval - It just werks */
			eval( $( '#JSText' ).text );
		}

		function addWarning( text ){
			/* broken */
		}

		function removeWarning( ){
			$('#McDotaMain').FindChild('McToolTip').visible = false;
		}
	</script>

	<!-- Empty onactivate prevents clicking panels beneath this one -->
	<Panel class='McMain' onactivate='' style='width: 640px; height: 480px; horizontal-align: center; vertical-align: center; background-color: gradient( linear, 0% 0%, 0% 25%, from( #232326 ), to( #1c1d20 ) );'>

		<!-- Nav Bar -->
		<Panel id='SettingsNavBar'>
			<Button id='DOTACloseSettingsButton' class='ControlIconButton' onactivate='closeSelf()' />
			<RadioButton class='SettingsNavBarButton' group='SettingsTopMenu' onactivate='changeTab( 0 )' >
				<Label text='General' />
			</RadioButton>
			<Label class='SettingsTabSeparator'	text='/' />
			<RadioButton class='SettingsNavBarButton' group='SettingsTopMenu' onactivate='changeTab( 1 )' >
				<Label text='Visuals' />
			</RadioButton>
			<Label class='SettingsTabSeparator'	text='/' />
			<RadioButton class='SettingsNavBarButton' group='SettingsTopMenu' onactivate='changeTab( 2 )' >
				<Label text='Misc' />
			</RadioButton>
			<Label class='SettingsTabSeparator'	text='/' />
			<RadioButton class='SettingsNavBarButton' group='SettingsTopMenu' onactivate='changeTab( 3 )' >
				<Label text='Perf' />
			</RadioButton>

			<Panel class='SettingsTabFiller' />
			<RadioButton class='SettingsNavBarButton' group='SettingsTopMenu' onactivate='changeTab( 10 )' >
				<Label text='McDota' />
			</RadioButton>
		</Panel>


		<!-- TABS -->
		<!-- General -->
		<Panel id='McTabGeneral' style='width: 640px; height: 430px; horizontal-align: center; vertical-align: bottom;'>
			<Panel id='BasicOptions' class='SettingsColumnContainer FullHeight'>
				<Panel id='LeftColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_airstuck_on' text='Airstuck' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_autoaccept_on' text='AutoAccept' onactivate='clickSound()'/>
						<DOTASettingsSlider convar='mc_camera_pitch_add' min='-1.0' max='360.0' text='Pitch' />
						<DOTASettingsSlider convar='mc_camera_yaw_add' min='0.0' max='360.0' text='Yaw Add' />
						<DOTASettingsSlider convar='mc_camera_distance' min='1200.0' max='4000.0' text='Camera Distance' />
						<!--<Button id='btnTest' class='ButtonBevel' onactivate='executeQuarantine()' > <Label text='Mid Lane Party!' /></Button>-->
					</Panel>
				</Panel>
				<Panel id='RightColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<TextEntry id='JSText' maxchars='1000' class='TextEntryNormal' style='height: 300px; font-size: 14;' placeholder='Execute Panorama JS here' multiline='true' />
						<Button id='JSExecute' class='ControlIconButton' text='execute' onactivate='executeJS()'/>
						<DOTASettingsCheckbox convar='mc_anti_mute' text='Anti-Mute(allies)' onactivate='clickSound()'/>
					</Panel>
				</Panel>
			</Panel>
		</Panel>
		<!-- Visuals -->
		<Panel id='McTabVisuals' style='width: 640px; height: 430px; horizontal-align: center; vertical-align: bottom;'>
			<Panel id='BasicOptions' class='SettingsColumnContainer FullHeight'>
				<Panel id='LeftColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_esp_type_bbox' text='BBox' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_absbox' text='AbsBox' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_rbox' text='RBox' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_entbounds' text='Entity bounds' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_entattachments' text='Entity attachments' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_entjointinfo' text='Entity joint info' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_entskele' text='Entity skeleton(Lag!)' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_enthitboxes' text='Entity Hitboxes' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_entviewoffset' text='Entity ViewOffset' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_type_infotext' text='Info Text' onactivate='clickSound()'/>
					</Panel>
				</Panel>
				<Panel id='RightColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_esp_filter_all' text='All' onactivate='clickSound()' />
						<Label text='Allied'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_heroes_friend' text='Heroes' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_heroes_friend_seenby_enemy' text='Spotted Heroes' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_creeps_friend' text='Creeps' onactivate='clickSound()'/>

						<Label text='Enemy'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_heroes_enemy' text='Heroes' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_illusions_enemy' text='Illusions' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_esp_filter_creeps_enemy' text='Creeps' onactivate='clickSound()'/>
					</Panel>
				</Panel>
			</Panel>
		</Panel>
		<!-- Misc -->
		<Panel id='McTabMisc' style='width: 640px; height: 430px; horizontal-align: center; vertical-align: bottom;'>
			<Panel id='BasicOptions' class='SettingsColumnContainer FullHeight'>
				<Panel id='LeftColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_log_createmove' text='Log CreateMove' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_clientevents' text='Log ClientEvents' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_runscript' text='Log RunScript' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_send_voice' text='Kisak voice' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_send_status' text='Send Status' onactivate='clickSound()' />
						<DOTASettingsSlider convar='mc_send_freq' min='5.0' max='2000.0' text='Send Freq' />
					</Panel>
				</Panel>
				<Panel id='RightColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_log_recvnetmsg' text='Log RecvNetMsg' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_recvnetmsg_filter_commons' text='^ Filter Commons' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_recvnetmsg_to_string' text='^^ ToString' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_sendnetmsg' text='Log SendNetMsg' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_sendnetmsg_filter_commons' text='^ Filter Commons' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_sendnetmsg_to_string' text='^^ To String' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_log_GC_client_recv' text='Log GC Recv' onactivate='clickSound()' onmouseover='addWarning("GC Logs use Hard Hooks. Hard Hooks are not safe. They are not detected but may be in the future. Restart your game after Enabling.")' onmouseout='removeWarning()'/>
						<DOTASettingsCheckbox convar='mc_log_GC_client_send' text='Log GC Send' onactivate='clickSound()' onmouseover='addWarning("GC Logs use Hard Hooks. Hard Hooks are not safe. They are not detected but may be in the future. Restart your game after Enabling.")' onmouseout='removeWarning()'/>
					</Panel>
				</Panel>
			</Panel>
		</Panel>
		<!-- Performance -->
		<Panel id='McTabPerf' style='width: 640px; height: 430px; horizontal-align: center; vertical-align: bottom;'>
			<Panel id='BasicOptions' class='SettingsColumnContainer FullHeight'>
				<Panel id='LeftColumn' class='SettingsColumn' style='width: 50%;'>
					<Panel class='SettingsSection'>
						<DOTASettingsCheckbox convar='mc_mute_creeps' text='Mute Creep Sfx' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_end_createmove' text='End CreateMove' onactivate='clickSound()' />
						<DOTASettingsCheckbox convar='mc_fog_disable' text='No Fog' onactivate='clickSound()'/>
						<DOTASettingsCheckbox convar='mc_fow_disable' text='No FoW' onactivate='clickSound()'/>
					</Panel>
				</Panel>
				<Panel id='RightColumn' class='SettingsColumn' style='width: 50%;'>

				</Panel>
			</Panel>
		</Panel>
		<!-- About -->
		<Panel id='McTabAbout' style='width: 640px; height: 430px; horizontal-align: center; vertical-align: bottom; background-color: gradient( linear, 0% 0%, 0% 25%, from( #232326 ), to( #1c1d20 ) );'>
			<Label id='aboutText' text=''/>
			<Panel style='vertical-align: middle; horizontal-align: middle; flow-children: right;'>
				<Panel style='vertical-align: middle; horizontal-align: middle; flow-children: down; margin-right: 25px;'>
					<Image src='https://avatars0.githubusercontent.com/u/8827133' style='width: 92px; height: 92px;' onmouseover='setAboutText(0)' onmouseout='clearAboutText()'/>
				</Panel>
				<Panel style='vertical-align: middle; horizontal-align: middle; flow-children: down; margin-right: 25px;'>
					<Image src='https://avatars3.githubusercontent.com/u/2909949' style='width: 92px; height: 92px;' onmouseover='setAboutText(1)' onmouseout='clearAboutText()'/>
				</Panel>
			</Panel>
		</Panel>

	</Panel>
</root>

)zz"
```

`src/Hacks/Esp.cpp`:

```cpp
#include "Esp.h"

#include "../Interfaces.h"
#include "../Settings.h"
#include "../Utils/Draw.h"

static bool GetBox( CBaseEntity* entity, int* x, int* y, int* w, int* h )
{
    CCollisionProperty *collision = entity->C_BaseModelEntity__GetCollideable();
    if( !collision )
        return false;

    const Vector * const originPtr = entity->C_BaseEntity__WorldSpaceCenter();
    const Vector * const minPtr = collision->GetMins();
    const Vector * const maxPtr = collision->GetMaxs();

    if( !originPtr || !minPtr || !maxPtr )
        return false;

    Vector min = *minPtr + *originPtr;
    Vector max = *maxPtr + *originPtr;

    Vector points[] = { Vector(min.x, min.y, min.z),
                        Vector(min.x, max.y, min.z),
                        Vector(max.x, max.y, min.z),
                        Vector(max.x, min.y, min.z),
                        Vector(min.x, min.y, max.z),
                        Vector(min.x, max.y, max.z),
                        Vector(max.x, max.y, max.z),
                        Vector(max.x, min.y, max.z) };

    int maxX, maxY;
    engine->GetScreenSize( maxX, maxY );
    int leftMost = maxX, rightMost = 0, topMost = maxX, bottomMost = 0;

    for( const auto &vec : points ){
        int screenX = 0, screenY = 0;

        if( Draw::WorldToScreen( vec, screenX, screenY, *g_WorldToScreen ) ){
            return false;
        }

        if( screenX < leftMost )
            leftMost = screenX;
        if( screenX > rightMost )
            rightMost = screenX;

        if( screenY < topMost )
            topMost = screenY;
        if( screenY > bottomMost )
            bottomMost = screenY;
    }

    *x = leftMost;
    *y = topMost;
    *w = rightMost - leftMost;
    *h = bottomMost - topMost;

    return true;
}


void ESP::PaintTraverse( IVPanel *thisptr, IVGuiPaintSurface *surface, VPANEL panel, bool force_repaint, bool allow_force ) {

    int max = entitySystem->GetHighestEntityIndex();
    std::vector<Vector> drawSpots = {};

    for( int i = 1; i <=max; i++ ){
        bool goodToGo = false;
        CBaseEntity *entity = entitySystem->GetBaseEntity(i);

        if( !entity )
            continue;

        if( mc_esp_filter_all->GetBool() )
            goodToGo = true;

        if( entity->C_BaseEntity__InLocalTeam() ){
            if( strstr(entity->Schema_DynamicBinding()->binaryName, "DOTA_Unit_Hero") != nullptr ){
                if( mc_esp_filter_heroes_friend->GetBool() ) {
                    goodToGo = true;
                }
                if( mc_esp_filter_heroes_friend_seenby_enemy->GetBool() ){
                    DOTATeam_t enemyTeam = (entity->GetTeam() == DOTATeam_t::DOTA_TEAM_GOODGUYS) ? DOTATeam_t::DOTA_TEAM_BADGUYS : DOTA_TEAM_GOODGUYS;
                    if( entity->C_BaseModelEntity__CanBeSeenByTeam( enemyTeam ) )
                        goodToGo = true;
                }
            } else if( strstr(entity->Schema_DynamicBinding()->binaryName, "C_DOTA_BaseNPC_Creep") != nullptr ){
                if( mc_esp_filter_creeps_friend->GetBool() )
                    goodToGo = true;
            }
        } else {
            if( strstr(entity->Schema_DynamicBinding()->binaryName, "DOTA_Unit_Hero") != nullptr ){
                if( mc_esp_filter_heroes_enemy->GetBool() ){
                    goodToGo = true;
                }
                if( mc_esp_filter_illusions_enemy->GetBool() ){
                    auto *npc = (CDotaBaseNPC*)entity;
                    if( npc->IsIllusion() ){
                        goodToGo = true;
                    }
                }
            }
            if( mc_esp_filter_creeps_enemy->GetBool() && strstr(entity->Schema_DynamicBinding()->binaryName, "C_DOTA_BaseNPC_Creep") != nullptr )
                goodToGo = true;
        }

        if( !goodToGo )
            continue;

        if( mc_esp_type_infotext->GetBool() ){
            if( !entity->Schema_DynamicBinding() || !entity->Schema_DynamicBinding()->binaryName )
                continue;

            int x, y, w, h;
            if( !GetBox(entity, &x, &y, &w, &h) ){
                continue;
            }

            int sizeX, sizeY;
            const int bufferLen = 512;
            wchar_t buffer[bufferLen];
            int strLen = 0;

            strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L"(%d)%s", i, entity->Schema_DynamicBinding()->binaryName );


            if( strstr( entity->Schema_DynamicBinding()->binaryName, "C_DOTAPlayer" ) != nullptr ){
                auto *player = (CDotaPlayer*)entity;
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" - %s", "GetPlayerName Broke :)"/*player->C_DOTAPlayer__GetPlayerName()*/ );
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" - (%p)", (void*)player );
            }

            if( strstr( entity->Schema_DynamicBinding()->binaryName, "DOTA_Unit_Hero" ) ){
                auto *npc = (CDotaBaseNPC*)entity;
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" -Mana: (%g/%g)", npc->C_DOTA_BaseNPC__GetMana(), npc->C_DOTA_BaseNPC__GetMaxMana() );
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" -Dmg Min(%d)/Max(%d)", npc->C_DOTA_BaseNPC__GetDamageMin(), npc->C_DOTA_BaseNPC__GetDamageMax() );
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" -MagicImm?(%s)", npc->C_DOTA_BaseNPC__IsMagicImmune() ? "yes" : "no" );
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" -Illu?(%s)", npc->IsIllusion() ? "yes" : "no" );
                strLen += swprintf( buffer + strLen, std::max( 0, bufferLen - strLen ), L" -Pos(%f,%f,%f)", npc->C_BaseEntity__WorldSpaceCenter()->x,
                                    npc->C_BaseEntity__WorldSpaceCenter()->y,
                                    npc->C_BaseEntity__WorldSpaceCenter()->z);
            }

            surface->DrawSetTextFont(ESP::paintFont);
            surface->DrawSetTextColor(255, 255, 255, 255);
            surface->GetTextSize(ESP::paintFont, buffer, sizeX, sizeY);

            int objectsInArea = 1;

            for( const auto &spot : drawSpots ){
                if( entity->C_BaseEntity__WorldSpaceCenter() && entity->C_BaseEntity__WorldSpaceCenter()->DistTo(spot) < 50.0f){
                    objectsInArea++;
                }
            }

            surface->DrawSetTextPos(x + (w / 2) - (sizeX / 2), y + ( sizeY * objectsInArea ) + h);
            surface->DrawPrintText(buffer, strLen);

            if( entity->C_BaseEntity__WorldSpaceCenter() ){
                drawSpots.push_back( *(entity->C_BaseEntity__WorldSpaceCenter()) );
            }
        }

        auto *npc = (CDotaBaseNPC*)entity;

        if( mc_esp_type_bbox->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::BBOX);
        if( mc_esp_type_absbox->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ABSBOX);
        if( mc_esp_type_rbox->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::RBOX);
        if( mc_esp_type_entbounds->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYBOUNDS);
        if( mc_esp_type_entattachments->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYATTACHMENTS);
        if( mc_esp_type_entjointinfo->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYJOINTINFO);
        if( mc_esp_type_entskele->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYSKELETON);
        if( mc_esp_type_enthitboxes->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYHITBOXES);
        if( mc_esp_type_entviewoffset->GetBool() )
            npc->C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t::ENTITYVIEWOFFSET);
    }

}
```

`src/Hacks/Esp.h`:

```h
#pragma once

#include "../SDK/IVPanel.h"

namespace ESP
{
    inline HFont paintFont = 0;

    //Hooks
    void PaintTraverse( IVPanel *thisptr, IVGuiPaintSurface *surface, VPANEL panel, bool force_repaint, bool allow_force );
}
```

`src/Hacks/Zoom.cpp`:

```cpp
#include "Zoom.h"

#include "../Interfaces.h"
#include "../Settings.h"

void Zoom::FrameStageNotify(CSource2Client *thisptr, ClientFrameStage_t stage) {
    if( stage != ClientFrameStage_t::FRAME_START || !engine->IsInGame() )
        return;

    if( mc_camera_distance->GetFloat() > 49.0f )
        camera->SetDistanceToLookAtPos( mc_camera_distance->GetFloat() );

    if( mc_camera_yaw_add->GetFloat() > 0.1f )
        camera->SetExtraYaw( mc_camera_yaw_add->GetFloat() );
    else
        camera->SetExtraYaw( 0.0f );


    if( mc_camera_pitch_add->GetFloat() > 1.0f || mc_camera_pitch_add->GetFloat() < 0.1f ){
        camera->SetMinPitch( mc_camera_pitch_add->GetFloat() );
        camera->SetMaxPitch( mc_camera_pitch_add->GetFloat() );
    }
}
```

`src/Hacks/Zoom.h`:

```h
#pragma once

#include "../SDK/CSource2Client.h"

/* Zoom-out hack and camera related hacks */
namespace Zoom
{
    //Hooks
    void FrameStageNotify( CSource2Client *thisptr, ClientFrameStage_t stage );
}
```

`src/Hooks/CreateEvent.cpp`:

```cpp
#include "Hooks.h"

typedef CGameEvent* (* CreateEventFn)( CGameEventManager*, const char *, bool, int * );

// This needs to be hooked to force allow event creation from panorama "GameEvents.SendEventClientSide()"
// Used w/ FireEventClientSide hook to communicate from panorama.
CGameEvent* Hooks::CreateEvent( CGameEventManager *thisptr, const char *name, bool force, int *cookie ) {
    force = true;
    return gameEventManagerVMT->GetOriginalMethod<CreateEventFn>( 7 )( thisptr, name, force, cookie );
}
```

`src/Hooks/CreateMove.cpp`:

```cpp
#include "Hooks.h"

#include <sstream>

#include "../Settings.h"
#include "../protos/mcdota.pb.h"
#include "../Utils/Logger.h"

typedef bool (* CreateMoveFn)( IClientMode*, CUserCmd*, QAngle&, Vector& );

std::stringstream ss;
static std::string Buttons2ButtonStr( int32_t buttons ) {

    ss.str("");
    ss.clear();
    if( buttons & IN_ATTACK )
        ss << "| IN_ATTACK ";
    if( buttons & IN_JUMP )
        ss << "| IN_JUMP ";
    if( buttons & IN_DUCK )
        ss << "| IN_DUCK ";
    if( buttons & IN_FORWARD )
        ss << "| IN_FORWARD ";
    if( buttons & IN_BACK )
        ss << "| IN_BACK ";
    if( buttons & IN_USE )
        ss << "| IN_USE ";
    if( buttons & IN_CANCEL )
        ss << "| IN_CANCEL ";
    if( buttons & IN_LEFT )
        ss << "| IN_LEFT ";
    if( buttons & IN_RIGHT )
        ss << "| IN_RIGHT ";
    if( buttons & IN_MOVELEFT )
        ss << "| IN_MOVELEFT ";
    if( buttons & IN_MOVERIGHT )
        ss << "| IN_MOVERIGHT ";
    if( buttons & IN_ATTACK2 )
        ss << "| IN_ATTACK2 ";
    if( buttons & IN_RUN )
        ss << "| IN_RUN ";
    if( buttons & IN_RELOAD )
        ss << "| IN_RELOAD ";
    if( buttons & IN_ALT1 )
        ss << "| IN_ALT1 ";
    if( buttons & IN_ALT2 )
        ss << "| IN_ALT2 ";
    if( buttons & IN_SCORE )
        ss << "| IN_SCORE ";
    if( buttons & IN_SPEED )
        ss << "| IN_SPEED ";
    if( buttons & IN_WALK )
        ss << "| IN_WALK ";
    if( buttons & IN_ZOOM )
        ss << "| IN_ZOOM ";
    if( buttons & IN_WEAPON1 )
        ss << "| IN_WEAPON1 ";
    if( buttons & IN_WEAPON2 )
        ss << "| IN_WEAPON2 ";
    if( buttons & IN_BULLRUSH )
        ss << "| IN_BULLRUSH ";
    if( buttons & IN_GRENADE1 )
        ss << "| IN_GRENADE1 ";
    if( buttons & IN_GRENADE2 )
        ss << "| IN_GRENADE2 ";
    if( buttons & IN_ATTACK3 )
        ss << "| IN_ATTACK3 ";

    return ss.str();
}

//angle changed with +left/right stays the same.
//position is a delta, changes with arrow keys
bool Hooks::CreateMove( IClientMode *thisptr, CUserCmd* cmd, QAngle &angle, Vector &pos ) {
    bool ret;

    if( mc_send_status->GetBool() ){
        engine->ClientCmd_Unrestricted("status");
    }

    if( mc_end_createmove->GetBool() ){
        cmd->tick_count = 0;
        return true;
    }

    if( mc_airstuck_on->GetBool() ){
        MC_PRINTF("Airstucking...\n");
        //cmd->command_number = 16777216;
        cmd->tick_count = 16777216;
    }
    if( mc_log_createmove->GetBool() ){
        MC_LOGF("CreateMove: UserCmd @ %p, "
                          "\n-Viewangle(%f,%f,%f)"
                          "\n-CommandNum: %d"
                          "\n-TickCount: %d"
                          "\n-AimDirection(%f,%f,%f)"
                          "\n-buttons: (%d)%s"
                          "\n-impulse: %d"
                          "\nAngle(%f,%f,%f) - Pos(%f,%f,%f)\n\n",
                  (void*)cmd,
                  cmd->viewangles.x, cmd->viewangles.y, cmd->viewangles.z,
                  cmd->command_number,
                  cmd->tick_count,
                  cmd->aimdirection.x, cmd->aimdirection.y, cmd->aimdirection.z,
                  cmd->buttons, Buttons2ButtonStr(cmd->buttons).c_str(),
                  cmd->impulse,
                  angle.x, angle.y, angle.z, pos.x, pos.y, pos.z);

    }

    ret = clientModeVMT->GetOriginalMethod<CreateMoveFn>( 27 )( thisptr, cmd, angle, pos );
    CreateMove::lastMouse3D = cmd->CursorRay;
    return ret;
}

```

`src/Hooks/CreateNetChannel.cpp`:

```cpp
#include "Hooks.h"

#include "../Interfaces.h"
#include "../Utils/Util.h"

typedef INetChannel* (* CreateNetChannelFn)( CNetworkSystem*, int, void *, const char *, unsigned int, unsigned int );

// This will not work for splitscreen slots ( if somehow this code needs to be used for that )
INetChannel* Hooks::CreateNetChannel( CNetworkSystem *thisptr, int unk, void *ns_addr, const char *str, unsigned int uUnk, unsigned int uUnk2 ) {
    netChannelVMT.reset();
    INetChannel *ret = networkSystemVMT->GetOriginalMethod<CreateNetChannelFn>( 26 )( thisptr, unk, ns_addr, str, uUnk, uUnk2 );

    MC_PRINTF( "Grabbing new NetChannel VMT - %p\n", (void*)ret );
    netChannelVMT = std::unique_ptr<VMT>(new VMT( ret ));
    netChannelVMT->HookVM( Hooks::SendNetMessage, 70 );
    netChannelVMT->HookVM( Hooks::PostReceivedNetMessage, 88 );
    netChannelVMT->ApplyVMT();

    return ret;
}
```

`src/Hooks/CreateParticleCollection.cpp`:

```cpp
#include "Hooks.h"

#include "../Utils/Util_sdk.h"

#include <csignal>

typedef CParticleCollection* ( *CreateParticleCollectionFn)( CParticleSystemMgr *, CWeakHandle_InfoForResourceTypeIParticleSystemDefinition *, void *, IParticleSystemQuery *, bool, float, int );

CParticleCollection* Hooks::CreateParticleCollection( CParticleSystemMgr *thisptr, CWeakHandle_InfoForResourceTypeIParticleSystemDefinition *info, void *unk, IParticleSystemQuery *query, bool bUnk, float fUnk, int iUnk ) {
    CParticleCollection *ret = particleSystemVMT->GetOriginalMethod<CreateParticleCollectionFn>( 18 )( thisptr, info, unk, query, bUnk, fUnk, iUnk );

    /*
    Util::Log("CreateParticleCollection called - name(%s) -info(%p) - unk(%p) - query(%p) - bool(%s) - float(%f) - int(%d) - ret(%p)\n",
              info->contents->info->name, (void*)info, unk, (void*)query, bUnk ? "true" : "false", fUnk, iUnk, ret);
    std::raise(SIGINT); */

    /*
    if( !strcmp( info->contents->info->name, "particles/units/heroes/hero_tinker/tinker_machine.vpcf" ) ){
        //ret->SetRenderingEnabled( false );
        ret->SetDormant( true );
    }*/

    for ( size_t i = 0; i < Util::blacklistedParticles.size(); i++ ){
        if( !strcmp( Util::blacklistedParticles[i].c_str(), info->contents->info->name ) ){
            ret->SetDormant( true );
            return ret;
        }
    }

    for ( size_t i = 0; i < Util::trackedParticles.size(); i++ ){
        if( !strcmp( Util::trackedParticles[i].c_str(), info->contents->info->name ) ){
            std::lock_guard<std::mutex> lock( CreateParticleCollection::particleRemoveGuard );
            CreateParticleCollection::particlesTracked.push_back( ret );
        }
    }

    return ret;
}
```

`src/Hooks/DeleteParticleCollection.cpp`:

```cpp
#include "Hooks.h"

typedef void ( *DeleteParticleCollectionFn)( CParticleSystemMgr *, CParticleCollection * );

void Hooks::DeleteParticleCollection( CParticleSystemMgr *thisptr, CParticleCollection *collectionToDelete ) {

    {
        const std::lock_guard<std::mutex> lock( CreateParticleCollection::particleRemoveGuard );
        for( size_t i = CreateParticleCollection::particlesTracked.size(); i-- > 0 ; ){
            if( CreateParticleCollection::particlesTracked[i] == collectionToDelete ){
                CreateParticleCollection::particlesTracked.erase( CreateParticleCollection::particlesTracked.begin() + i );
            }
        }
    }

    particleSystemVMT->GetOriginalMethod< DeleteParticleCollectionFn >( 19 )( thisptr, collectionToDelete );
}
```

`src/Hooks/FireEventClientSide.cpp`:

```cpp
#include "Hooks.h"

#include "../Settings.h"
#include "../GUI/Callbacks.h"

#include "../Utils/Logger.h"

typedef bool (* FireEventClientSideFn)( CGameEventManager*, CGameEvent * );

static const char *GameState2String( int state ){
    switch( state ){
        CASE_STRING( GameState::DOTA_GAMERULES_STATE_INIT );
        CASE_STRING( GameState::DOTA_GAMERULES_WAIT_FOR_PLAYERS_TO_LOAD );
        CASE_STRING( GameState::DOTA_GAMERULES_HERO_SELECTION );
        CASE_STRING( GameState::DOTA_GAMERULES_STRATEGY_TIME );
        CASE_STRING( GameState::DOTA_GAMERULES_PREGAME );
        CASE_STRING( GameState::DOTA_GAMERULES_GAME_IN_PROGRESS );
        CASE_STRING( GameState::DOTA_GAMERULES_POSTGAME );
        CASE_STRING( GameState::DOTA_GAMERULES_DISCONNECT );
        CASE_STRING( GameState::DOTA_GAMERULES_TEAM_SHOWCASE );
        CASE_STRING( GameState::DOTA_GAMERULES_CUSTOM_GAME_SETUP );
        CASE_STRING( GameState::DOTA_GAMERULES_WAIT_FOR_MAP_TO_LOAD );
        default:
            return "gaaaa";
    }
}

// `tree_cut` is an event that we hijack to communicate from panorama.
// It is normally never used in the game, even when cutting a tree.
// Why resort to this semi-ghetto method? Well I didn't want to include v8, especially when it needs to be version matched to the game's old version (5.8.283 - Feb 25 2017)
// IUIEvent would be more appropriate but calling the custom events didn't want to work.
bool Hooks::FireEventClientSide( CGameEventManager *thisptr, CGameEvent *event ) {
    const char *eventName;
    int actionID = 0;

    if( mc_log_clientevents->GetBool() ){
        eventName = event->GetName();
        MC_LOGF("Event[%d] Fired! (%s)", event->GetID(), eventName);
        if( !strcmp( eventName, "dota_game_state_change" ) ){
            MC_LOGF("\n    Transitioning from State (%s) -> (%s)", GameState2String( event->GetInt("old_state") ), GameState2String( event->GetInt("new_state") ) );
        }
        MC_LOGF("\n");
    }

    // tree_cut
    if( event->GetID() == 281 ){
        actionID = event->GetInt( "action", 0 );
        if( !actionID ){
            MC_LOGF("tree_cut: No \"action\" supplied!\n");
            return true;
        }
        switch( actionID ){
            case 1:
                break;
            default:
                break;
        }

        return true;
    }

    return gameEventManagerVMT->GetOriginalMethod<FireEventClientSideFn>(9)( thisptr, event );
}
```

`src/Hooks/FrameStageNotify.cpp`:

```cpp
#include "Hooks.h"

#include "../Hacks/Zoom.h"
#include "../Settings.h"
#include "../Hooks/HardHooks.h"

typedef void (* FrameStageNotifyFn)( CSource2Client*, ClientFrameStage_t );

//looks like they added stages 7 and 9
static const char* Stage2String( ClientFrameStage_t stage ){
    switch( stage ){
        CASE_STRING( FRAME_UNDEFINED );
        CASE_STRING( FRAME_START );
        CASE_STRING( FRAME_NET_UPDATE_START );
        CASE_STRING( FRAME_NET_UPDATE_POSTDATAUPDATE_START );
        CASE_STRING( FRAME_NET_UPDATE_POSTDATAUPDATE_END );
        CASE_STRING( FRAME_NET_UPDATE_END );
        CASE_STRING( FRAME_RENDER_START );
        CASE_STRING( FRAME_RENDER_END );
        default:
            return "gaaaa";
    }
}
void Hooks::FrameStageNotify( CSource2Client *thisptr, ClientFrameStage_t stage ) {
    //MC_PRINTF("FSN: %s\n", Stage2String(stage));
    Zoom::FrameStageNotify( thisptr, stage );
    return clientVMT->GetOriginalMethod<FrameStageNotifyFn>(29)( thisptr, stage );
}
```

`src/Hooks/GetFoWAmount.cpp`:

```cpp
#include "Hooks.h"

#include "../Settings.h"

typedef float (* GetFoWAmountFn)( CDotaCamera* );

float Hooks::GetFoWAmount( CDotaCamera *thisptr ) {
    if( mc_fow_disable->GetBool() ){
        return 0.0f;
    }
    return cameraVMT->GetOriginalMethod<GetFoWAmountFn>( 29 )( thisptr );
}
```

`src/Hooks/GetFogEnd.cpp`:

```cpp
#include "Hooks.h"

#include "../Settings.h"

float Hooks::GetFogEnd( CDotaCamera *thisptr, float unk ) {
    if( mc_fog_disable->GetBool() ){
        return 0.0f;
    }
    return mc_camera_distance->GetFloat() * 4.0f;
}
```

`src/Hooks/GetZFar.cpp`:

```cpp
#include "Hooks.h"
#include "../Settings.h"

typedef float (* GetZFarFn)( CDotaCamera*, float );

/* Normally when u zoom out, the edges of the camera do the source engine render blur thing; fixes that */
float Hooks::GetZFar( CDotaCamera *thisptr, float unk ) {
    /* 2500 is normal zfar, 1134 is regular camera distance. 1134 * 2.204 = 2500; */
    return mc_camera_distance->GetFloat() * 2.204f;
}
```

`src/Hooks/HardHooks.h`:

```h
#pragma once

#include "../Utils/subhook/subhook.h"
#include "../Interfaces.h"

// (libclient)
//GCSDK::CGCClient::DispatchPacket(GCSDK::IMsgNetPacket *)
//GCSDK::CGCClient::BSendMessage(GCSDK::CProtoBufMsgBase const&)

namespace HardHooks
{
    inline subhook::Hook DispatchPacket;
    inline subhook::Hook BAsyncSendProto;

    typedef bool ( *DispatchPacketFn)( void *, IMsgNetPacket * );
    typedef bool ( *BAsyncSendProtoFn)( IProtoBufSendHandler &, unsigned int, CMsgProtoBufHeader const&, google::protobuf::Message * );

    bool MyDispatchPacket( void* thisptr, IMsgNetPacket *netPacket );
    bool MyBAsyncSendProto( IProtoBufSendHandler &, unsigned int, CMsgProtoBufHeader const&, google::protobuf::Message * );
}
```

`src/Hooks/Hard_BAsyncSendProto.cpp`:

```cpp
#include "HardHooks.h"

#include "../Utils/Protobuf.h"
#include "../Utils/Logger.h"
#include "../protos/mcdota.pb.h"

bool HardHooks::MyBAsyncSendProto( IProtoBufSendHandler &handler, unsigned int unk,
                                    CMsgProtoBufHeader const &header, google::protobuf::Message *msg ) {
    MC_LOGF("[GC]Send - Msg(%p)\n", (void*)msg);
    google::protobuf::Message *copy = msg->New();
    copy->CopyFrom( *msg );

    const google::protobuf::Descriptor* desc = copy->GetDescriptor();
    if( !desc ){
        MC_LOGF("No Descriptor!\n");
        goto end;
    }

    MC_LOGF("TypeName: %s\n", desc->name().c_str());
    Util::Protobuf::LogMessageContents( copy );

    //if( strstr( desc->name().c_str(), "CMsgDOTAChatMessage" ) ){
    //    Util::Protobuf::EditFieldTraverseUInt32( msg, "battle_cup_streak", 5 );
    //}
    //std::raise(SIGINT);
end:
    HardHooks::BAsyncSendProto.Remove();
    bool ret = ((BAsyncSendProtoFn)BAsyncSendProtoFnAddr)( handler, unk, header, msg );
    HardHooks::BAsyncSendProto.Install();

    delete copy;
    return ret;
}
```

`src/Hooks/Hard_DispatchPacket.cpp`:

```cpp
#include "HardHooks.h"

#include "../Utils/Protobuf.h"
#include "../Utils/Logger.h"
#include "../protos/mcdota.pb.h"

#include <csignal>


bool HardHooks::MyDispatchPacket( void *thisptr, IMsgNetPacket *netPacket ) {
    MC_LOGF("[GC]Recv(%p) - type(%s) - len(%d)\n", (void*)netPacket, EDOTAGCMsg2String( netPacket->GetEMsg() ).c_str(), netPacket->CubData());
    std::raise(SIGINT);
    //msg.ParseFromArray( IMsgNetPacket->PubData(), IMsgNetPacket->CubData() );

    bool rv;
    HardHooks::DispatchPacket.Remove();
    rv = ((DispatchPacketFn)DispatchPacketFnAddr)( thisptr, netPacket );
    HardHooks::DispatchPacket.Install();
    return rv;
}
```

`src/Hooks/Hooks.h`:

```h
#pragma once
#include "../SDK/SDK.h"
#include "../Interfaces.h" // all hooks can use interfaces

#include <mutex>

namespace Hooks
{
    // CDotaCamera
    float GetFogEnd( CDotaCamera *thisptr, float unk );
    float GetFoWAmount( CDotaCamera *thisptr );
    float GetZFar( CDotaCamera *thisptr, float unk );
    // client
    void FrameStageNotify( CSource2Client* thisptr, ClientFrameStage_t stage );
    // clientMode
    bool CreateMove( IClientMode* thisptr, CUserCmd *cmd, QAngle &angle, Vector &pos );
    void LevelInit( IClientMode* thisptr, const char *newmap );
    // cnetworksystem
    INetChannel* CreateNetChannel( CNetworkSystem * thisptr, int, void *, const char *, unsigned int, unsigned int );
    // gameEventManager
    CGameEvent* CreateEvent( CGameEventManager *thisptr, const char *name, bool force, int *cookie );
    bool FireEventClientSide( CGameEventManager *thisptr, CGameEvent *event );
    // inputInternal
    void SetKeyCodeState( IInputInternal* thisptr, ButtonCode_t code, bool bPressed );
    // INetChannel
    void PostReceivedNetMessage( INetChannel *thisptr, NetMessageHandle_t * messageHandle, google::protobuf::Message* msg, NetChannelBufType_t const* type, int bits );
    bool SendNetMessage( INetChannel *thisptr, NetMessageHandle_t * messageHandle, google::protobuf::Message* msg, NetChannelBufType_t type );
    // ParticleSystemMgr
    CParticleCollection* CreateParticleCollection( CParticleSystemMgr *thisptr, CWeakHandle_InfoForResourceTypeIParticleSystemDefinition *info, void *unk, IParticleSystemQuery *query, bool bUnk, float fUnk, int iUnk );
    void DeleteParticleCollection( CParticleSystemMgr *thisptr, CParticleCollection *collectionToDelete );
    // panel
    void PaintTraverse( IVPanel* thisptr, IVGuiPaintSurface* surface, VPANEL panel, bool force_repaint, bool allow_force );
    // panorama
    int RunScript( panorama::UIEngine* thisptr, panorama::IUIPanel *panel, const char* str1, const char* str2, int int1, int int2, bool bool1 );
    // CSoundOpSystem
    void StartSoundEvent( CSoundOpSystem *thisptr, const char *name, int entIndex, short unk, void const *something, int unk2 );
    void StartSoundEvent2( CSoundOpSystem *thisptr, unsigned int unk, int entIndex, sound_voice_layer_t voiceLayer, short unk2, const char *name, void const * something, int unk3, SoundEventGuid_t guid);
}

namespace SetKeyCodeState
{
    inline bool shouldListen = false;
    inline ButtonCode_t* keyOutput = nullptr;
}

namespace PaintTraverse
{
    bool InitFonts();
}

namespace CreateMove
{
    inline Vector lastMouse3D;
}

namespace CreateParticleCollection
{
    inline std::vector<CParticleCollection*> particlesTracked;
    inline std::mutex particleRemoveGuard;
}
```

`src/Hooks/LevelInit.cpp`:

```cpp
#include "Hooks.h"

#include "../Interfaces.h"
#include "../Utils/Util.h"

typedef void ( *LevelInitFn )( IClientMode*, const char * );

void Hooks::LevelInit( IClientMode *thisptr, const char *newmap ) {
    Interfaces::HookDynamicVMTs();

    clientModeVMT->GetOriginalMethod<LevelInitFn>( 28 )( thisptr, newmap );
}
```

`src/Hooks/PaintTraverse.cpp`:

```cpp
#include "Hooks.h"

#include "../Hacks/Esp.h"
#include "../Utils/Draw.h"

static VPANEL topPanel = 0;

typedef void (* PaintTraverseFn)( IVPanel*, IVGuiPaintSurface*, VPANEL, bool, bool );


bool PaintTraverse::InitFonts( ){
    //ESP::paintFont = fontManager->FindOrLoadFont("Courier New", "MaterialSystem2DefaultDebugFontOutline", 20, 20, true, 20, 20, 20, 20, 0x200, NULL);
    //MC_PRINTF("ESP paintFont is now: %llu\n", ESP::paintFont);
    //fontManager->SpewFonts(NULL, 1.0f);

    /* Handle 2 is always this */
    /* 1: FontHandle:0x00000002, Courier New, MaterialSystem2DefaultDebugFontDefaultFontAliasGroup-no, font:Courier New, tall:15.000000.0, LoadFont used */
    ESP::paintFont = 2;
    return true;
}

void Hooks::PaintTraverse( IVPanel *thisptr, IVGuiPaintSurface *surface, VPANEL panel, bool force_repaint, bool allow_force ) {
    if( !engine->IsInGame() )
        return panelVMT->GetOriginalMethod<PaintTraverseFn>( 55 )( thisptr, surface, panel, force_repaint, allow_force );

    if( !topPanel ){
        if( !strcmp(thisptr->GetName(panel), "RenderSystemTopPanel" ) ){
            topPanel = panel;
        } else {
            return panelVMT->GetOriginalMethod<PaintTraverseFn>( 55 )( thisptr, surface, panel, force_repaint, allow_force );
        }
    }

    /*
    surface->PushMakeCurrent(panel, false);
    int width, height;
    engine->GetScreenSize( width, height );
    surface->DrawSetColor( ColorRGBA(10, 225, 10) );
    surface->DrawLine( width / 2, height / 2, width, height );
    surface->PopMakeCurrent(panel);
    */

    surface->PushMakeCurrent(panel, false);

    ESP::PaintTraverse( thisptr, surface, panel, force_repaint, allow_force );

    surface->DrawSetColor( ColorRGBA( 225, 5, 5 ) );

    {
        std::lock_guard<std::mutex> lock( CreateParticleCollection::particleRemoveGuard );

        size_t size = CreateParticleCollection::particlesTracked.size();
        for( size_t i = 0; i < size; i++ ){
            int minX, minY, maxX, maxY;
#define particle CreateParticleCollection::particlesTracked[i]
            if( !particle || !particle->IsBoundsValid() ){
                continue;
            }
            if( Draw::WorldToScreen( *particle->GetMinBounds(), minX, minY, *g_WorldToScreen ) ||
                Draw::WorldToScreen( *particle->GetMaxBounds(), maxX, maxY, *g_WorldToScreen ) ){
                continue;
            }
            surface->DrawLine( minX, minY, minX, maxY );
            surface->DrawLine( minX, maxY, maxX, maxY );
            surface->DrawLine( maxX, maxY, maxX, minY );
            surface->DrawLine( maxX, minY, minX, minY );
#undef particle
        }
    }
    surface->PopMakeCurrent(panel);

    return panelVMT->GetOriginalMethod<PaintTraverseFn>( 55 )( thisptr, surface, panel, force_repaint, allow_force );
}
```

`src/Hooks/PostReceivedNetMessage.cpp`:

```cpp
#include "Hooks.h"

#include "../Utils/Protobuf.h"
#include "../Utils/Logger.h"
#include "../Settings.h"

typedef void (* PostReceivedNetMessageFn)( INetChannel *, NetMessageHandle_t *, google::protobuf::Message*, NetChannelBufType_t const *, int );

uint32_t biggestSignon = 0;
uint32_t latestSpawnCount = 0;

void Hooks::PostReceivedNetMessage( INetChannel *thisptr, NetMessageHandle_t *messageHandle, google::protobuf::Message *msg, NetChannelBufType_t const *type, int bits ) {

    NetMessageInfo_t *info;
    const char *name;

    if( mc_log_recvnetmsg->GetBool() ){
        info = networkMessages->GetNetMessageInfo( messageHandle );
        name = info->pProtobufBinding->GetName();

        if( mc_log_recvnetmsg_filter_commons->GetBool() ){
            if( strstr(name, "CNETMsg_Tick") ||
                strstr(name, "CSVCMsg_PacketEntities") ){
                goto end;
            }
        }
        MC_LOGF( "Recv Msg: (%s)\n", name );

        if( mc_log_recvnetmsg_to_string->GetBool() ){
            CUtlString string;
            string.m_Memory.m_pMemory = new uint8_t[4096];
            string.m_Memory.m_nAllocationCount = 4096;
            string.m_Memory.m_nGrowSize = 4096;
            MC_LOGF( "Net Msg[%d] Received: (%s)\n", messageHandle->messageID, info->pProtobufBinding->ToString( msg, &string ) );
            delete[] string.m_Memory.m_pMemory;
        }
    }

    if( mc_hide_tips->GetBool() ){
        if( messageHandle->messageID == 577 ) { // CDOTAUserMsg_TipAlert
            MC_LOGF("Suppressing a tipalert\n");
            return;
        }
    }

    /*
    if( strstr( name, "CNETMsg_SignonState" ) ){
        uint32_t signon = Util::Protobuf::GetFieldTraverseUInt32( msg, "signon_state" ).value();
        if( signon > biggestSignon ){
            biggestSignon = signon;
        } else {
            return;
        }
    }*/

end:
    return netChannelVMT->GetOriginalMethod<PostReceivedNetMessageFn>(88)( thisptr, messageHandle, msg, type, bits );
}
```

`src/Hooks/RunScript.cpp`:

```cpp
#include "Hooks.h"
#include "../Settings.h"

#include "../Utils/Logger.h"

typedef int (* RunScriptFn)( panorama::UIEngine*, panorama::IUIPanel *,char const*,char const*,int,int,bool );

int Hooks::RunScript( panorama::UIEngine *thisptr, panorama::IUIPanel *panel, const char *entireJSCode, const char *pathToXMLContext, int int1, int int2, bool alreadyCompiled ) {
    if ( mc_log_runscript->GetBool() ){
        MC_LOGF( "--RunScript--\n Panel: %s Str1: %s, Str2: (%s), int1: %d, int2: %d, bool1(%s)\n", panel->GetID(), entireJSCode, pathToXMLContext, int1, int2, alreadyCompiled? "yes" : "no" );
    }

    /* AutoAccept */
    if( mc_autoaccept_on->GetBool() ){

        if( strstr( pathToXMLContext, "popup_accept_match.xml" ) ){
            if( OnAcceptMatch ){
                MC_PRINTF("Match Found! Attempting to AutoAccept...\n");
                OnAcceptMatch( gDBPlayPanel );
            } else {
                MC_PRINTF_ERROR("Tried to Accept Match but OnMatchAccept() is NULL!\n");
            }
        }
    }

    return uiEngineVMT->GetOriginalMethod<RunScriptFn>(111)( thisptr, panel, entireJSCode, pathToXMLContext, int1, int2, alreadyCompiled );
}
```

`src/Hooks/SendNetMessage.cpp`:

```cpp
#include "Hooks.h"
#include <csignal>

#include "../Utils/Protobuf.h"
#include "../Utils/Logger.h"

#include "../Settings.h"

#include "../protos/mcdota.pb.h"

typedef bool (* SendNetMessageFn)( INetChannel *thisptr, NetMessageHandle_t *, google::protobuf::Message*, NetChannelBufType_t );

static const char* Type2String( NetChannelBufType_t type )
{
    switch( type )
    {
        CASE_STRING( BUF_DEFAULT );
        CASE_STRING( BUF_RELIABLE );
        CASE_STRING( BUF_UNRELIABLE );
        CASE_STRING( BUF_VOICE );
        default:
            return "UNKNOWN Type!";
    }
}

long lastSetConVarMsg = 0;
bool Hooks::SendNetMessage( INetChannel *thisptr, NetMessageHandle_t *messageHandle, google::protobuf::Message* msg, NetChannelBufType_t type ) {
    std::string scratch;
    NetMessageInfo_t *info;
    const char *name;
    /*
    if( mc_crash_server->GetBool() && strstr( name, "CNETMsg_SignonState" ) ){
        uint32_t signon = Util::Protobuf::GetFieldTraverseUInt32(msg, "signon_state").value();
        if( signon == (uint32_t)SignonState_t::SIGNONSTATE_PRESPAWN ){
            mc_crash_server->SetValue(false);
            int32_t value = 0xADADADAD;//mc_custom_int->GetInt();
            MC_LOGF("Changing localID from %d to %d\n", *(networkClientService->GetIGameClient()->GetLocalDOTAPlayerID()), value);
            *(networkClientService->GetIGameClient()->GetLocalDOTAPlayerID()) = value;
            netChannelVMT->GetOriginalMethod<SendNetMessageFn>(70)( thisptr, messageHandle, msg, type );
            return true;
        }
    }*/

    if( mc_stall_connect->GetBool() && messageHandle->messageID == 7 ) { //CNETMsg_SignonState [7]
        uint32_t signon = Util::Protobuf::GetFieldTraverseUInt32( msg, "signon_state" ).value( );
        if ( signon >= ( uint32_t )SignonState_t::SIGNONSTATE_SPAWN ) {
            return true;
        }
    }

    if( mc_anti_mute->GetBool() && messageHandle->messageID == 394 ){ //CDOTAClientMsg_ChatMessage [394]
        CDOTAClientMsg_ChatMessage *chat = static_cast<CDOTAClientMsg_ChatMessage*>( msg );
        CDOTAClientMsg_TipAlert tip;
        tip.set_tip_text(chat->message_text().c_str());
        netChannelVMT->GetOriginalMethod<SendNetMessageFn>(70)( thisptr, networkMessages->FindNetworkMessage2("CDOTAClientMsg_TipAlert"), &tip, BUF_DEFAULT );
        return true;
    }

    if( mc_send_status->GetBool() ){
        if( messageHandle->messageID == 31 ){ // CCLCMsg_ServerStatus [31]
            for( int i = 0; i < mc_send_freq->GetInt(); i++ ){
                engine->GetNetChannelInfo()->SetMaxRoutablePayloadSize(99999999);
                engine->GetNetChannelInfo()->SetMaxBufferSize(NetChannelBufType_t::BUF_DEFAULT, 99999999);
                netChannelVMT->GetOriginalMethod<SendNetMessageFn>(70)( thisptr, messageHandle, msg, type );
            }
        }
    }

    if( mc_send_voice->GetBool() ){
        if( messageHandle->messageID == 22 ){ // CCLCMsg_VoiceData [22]
            for( int i = 0; i < mc_send_freq->GetInt(); i++ ){
                engine->GetNetChannelInfo()->SetMaxRoutablePayloadSize(99999999);
                engine->GetNetChannelInfo()->SetMaxBufferSize(NetChannelBufType_t::BUF_DEFAULT, 99999999);
                netChannelVMT->GetOriginalMethod<SendNetMessageFn>(70)( thisptr, messageHandle, msg, type );
            }
        }
    }

    if( mc_log_sendnetmsg->GetBool() ){
        info = networkMessages->GetNetMessageInfo(messageHandle);
        name = info->pProtobufBinding->GetName();

        if( mc_log_sendnetmsg_filter_commons->GetBool() ){
            if( strstr(name, "CNETMsg_Tick")
                || strstr(name, "CCLCMsg_Move")
                || strstr(name, "CCLCMsg_BaselineAck") ){
                goto end;
            }
        }

        MC_LOGF( "NetMessage: Type(%d-%s) - Handle(%p) - Message@: (%p) - info@: (%p) - name(%s) -type(%d)\n", type, Type2String(type), messageHandle, msg, info, info->pProtobufBinding->GetName(), info->pProtobufBinding->GetBufType() );

        if( mc_log_sendnetmsg_to_string->GetBool() ){

            CUtlString string;
            string.m_Memory.m_pMemory = new uint8_t[4096];
            string.m_Memory.m_nAllocationCount = 4096;
            string.m_Memory.m_nGrowSize = 0;
            MC_LOGF( "ToString[%d]: (%s)\n", messageHandle->messageID, info->pProtobufBinding->ToString( msg, &string ) );
            delete[] string.m_Memory.m_pMemory;
            //Util::Protobuf::LogMessageContents(msg);

            std::raise(SIGINT);
        }
    }

end:
    return netChannelVMT->GetOriginalMethod<SendNetMessageFn>(70)( thisptr, messageHandle, msg, type );
}
```

`src/Hooks/SetKeyCodeState.cpp`:

```cpp
#include "Hooks.h"

#include "../Settings.h"
#include "../GUI/Gui.h"
#include "../protos/mcdota.pb.h"
#include "../Utils/Logger.h"

#include <csignal>

typedef void (* SetKeyCodeStateFn)( IInputInternal*, ButtonCode_t, bool );
typedef bool (* SendNetMessageFn)( INetChannel *thisptr, NetMessageHandle_t *, google::protobuf::Message*, NetChannelBufType_t );

bool EntHitHandler( void *IHandleEntity, int unk )
{
    MC_LOGF("Ent hit handler REEEE ent(%p) - int(%d)\n", IHandleEntity, unk);
    std::raise(SIGINT);
    return true;
}

bool ShouldDrawParticleSystems( void )
{
    MC_LOGF("Should draw particle callback\n");
    return false;
}


void Hooks::SetKeyCodeState(IInputInternal* thisptr, ButtonCode_t code, bool pressed)
{
    Vector attachment;
    CBaseEntity* entity;
    CDOTAWearableItem* cosmetic;
    INetworkStringTable *stringTable;
    CDOTAClientMsg_TipAlert tip;
    CNETMsg_SetConVar convar;
    CMsg_CVars_CVar* newConVar;// = convar.mutable_convars()->add_cvars();
    CNETMsg_StringCmd stringCmd;
    CDOTAClientMsg_GuideSelectOption option;
    CDOTAClientMsg_GuideSelected guide;
    static CDOTAClientMsg_MatchMetadata metadataMsg;
    static bool cacheMetaData = false;
    static int cachedSize = -1;
    CDOTAMatchMetadata metadata;
    std::string meme;
    CDOTAPlayerResource *playerResource;
    CUtlVector< PlayerResourcePlayerTeamData_t > *teamData;

    RnQueryTerrain traceFilter;
    CGameTrace traceOut;
    Ray_t ray;
    Vector temp;

    VMT *entityVMT;

    if( !pressed )
        return inputInternalVMT->GetOriginalMethod<SetKeyCodeStateFn>(96)(thisptr, code, pressed);

    switch( code ){
        case ButtonCode_t::INSERT:
            UI::ToggleUI();
            break;
        case ButtonCode_t::HOME:
            MC_PRINTF("TickCount: %d\n", globalVars->tickcount);
            MC_PRINTF("Curtime: %f\n", globalVars->curtime);
            MC_PRINTF("Seconds since start: %f\n", (float(globalVars->tickcount) * globalVars->intervalPerTick) );
            for( int i = 0; i <= entitySystem->GetHighestEntityIndex(); i++ ){
                entity = entitySystem->GetBaseEntity(i);
                if( entity ){
                    MC_PRINTF("Entity#%d(%p) - Name:(%s)", i, (void*)entity, entity->Schema_DynamicBinding()->binaryName );
                    if( entity->GetOwnerID() >= 0 ){
                        MC_PRINTF(" - Owner:(%d)", entity->GetOwnerID());
                    }
                    MC_PRINTF("\n");
                }
            }
            break;
        case ButtonCode_t::PGUP:
            //vscriptSystem->RunScript("bazinga", false);
            //MC_PRINTF("Local Player ID(%d)\n", *(networkClientService->GetIGameClient()->GetLocalDOTAPlayerID()));
            //newConVar->set_name(mc_custom_str->strValue);
            //newConVar->set_value(mc_custom_str_alt->strValue);
            MC_PRINTF("findnetworkmessage (%p)\n", (void*)networkMessages->FindNetworkMessage( mc_custom_str->m_Value.m_pszString ) );
            MC_PRINTF("findnetworkmessage2 (%p)\n", (void*)networkMessages->FindNetworkMessage2( mc_custom_str->m_Value.m_pszString ) );
            break;
        case ButtonCode_t::PGDN:
            /*
            guide.set_guide_workshop_id( 0 );
            guide.set_is_plus_guide( true );
            for( int i = 0; i < mc_send_freq->GetInt(); i++ ) {
                Hooks::SendNetMessage( engine->GetNetChannelInfo( ), networkMessages->GetMessageHandleByName( "CDOTAClientMsg_GuideSelected" ), &guide, BUF_DEFAULT );
            }*/
            tip.set_tip_text("Yeah I'm a gamer, you got a problem with that?");
            Hooks::SendNetMessage( engine->GetNetChannelInfo( ), (NetMessageHandle_t *)networkMessages->FindNetworkMessage2( "CDOTAClientMsg_TipAlert" ), &tip, BUF_DEFAULT );
            break;
        case ButtonCode_t::END:
            for( int i = 0; i <= entitySystem->GetHighestEntityIndex(); i++ ){
                entity = entitySystem->GetBaseEntity(i);
                if( !entity ) continue;
                if( strstr( entity->Schema_DynamicBinding()->binaryName, "C_DOTA_PlayerResource" ) ){
                    playerResource = reinterpret_cast<CDOTAPlayerResource*>( entity );
                    teamData = playerResource->GetPlayerTeamData();
                    if( teamData ) {
                        MC_PRINTF( "TeamData @ %p - num(%d)\n", (void*)playerResource->GetPlayerTeamData(), playerResource->GetPlayerTeamData()->Count() );
                        MC_PRINTF("elements @ %p\n", (void*)teamData->m_pElements);
                        for( int i = 0; i < teamData->Count(); i++ ){
                            MC_PRINTF("element %d @ %p\n", i, (void*)&teamData->operator[](i) );
                            MC_PRINTF( "player %d is level %d - has %d kills - %d deaths\n", i, teamData->operator[](i).m_iLevel, teamData->operator[](i).m_iKills, teamData->operator[](i).m_iDeaths);
                        }
                    }
                }
            }
            break;
        case ButtonCode_t::DELETE:
            //networkClientService->GetIGameClient()->ForceFullUpdate("unnamed");
            break;
        case ButtonCode_t::SCROLLLOCK:
            //richPresence->SetStatus(mc_custom_str->strValue);
            break;
        case ButtonCode_t::PAUSE:
            //Util::SpewScriptScopes( GetPanoramaScriptScopes(), true );
            //MC_PRINTF("Sending metadata\n");
            //static uint32_t id = 0;
            //id++;
            //metadataMsg.set_match_id( id );
            //if( !cacheMetaData || cachedSize != mc_send_freq->GetInt() ){
            //    for( int i = 0; i < mc_send_freq->GetInt(); i++ ){
            //        CDOTAMatchMetadata_Team *team = metadata.add_teams();
            //        team->Clear();
            //        for( int j = 0; j < mc_send_freq->GetInt(); j++ ){
            //            CDOTAMatchMetadata_Team_Player *player = team->add_players();
            //            player->Clear();
            //            for( int k = 0; k < mc_send_freq->GetInt(); k++ ){
            //                CSOEconItem *econItem = player->add_equipped_econ_items();
            //                econItem->Clear();
            //            }
            //        }
            //    }
            //    metadataMsg.set_metadata( metadata.SerializeAsString() );
            //    MC_PRINTF("cached metadata msg\n");
            //    cacheMetaData = true;
            //    cachedSize = mc_send_freq->GetInt();
            //}
            //Hooks::SendNetMessage( engine->GetNetChannelInfo( ), networkMessages->GetMessageHandleByName( "CDOTAClientMsg_MatchMetadata" ), &metadataMsg, BUF_DEFAULT );
            break;
        case ButtonCode_t::PRINTSCREEN:
            MC_LOGF("Tracing a ray good luck!\n");
            //CTraceFilter_Constructor( &traceFilter, nullptr, 0x69696969, EntHitHandler );
            ray.Init( Vector(100.0f, 200.0f, 300.0f), Vector(100.0f, 200.0f, -1200.0f) );
            traceFilter.Init( 0, 0xFFFFFFFF, EntHitHandler );

            GameTrace_Init( &traceOut );
            client->TraceRay( ray, traceFilter, &traceOut );

            MC_LOGF("Traceout(%p) - filter(%p) - fraction(%f)\n", &traceOut, &traceFilter, traceOut.fraction);
            std::raise(SIGINT);
            /*
             * CVoiceGamerMgrHelper::CanPlayerHearPlayer()
             - calls CEngineServer::GetClientConvarValue(index, "dota_mute_cobroastcasters") every tick i think
             */
            //MC_PRINTF("null convar/value\n");
            //newConVar = convar.mutable_convars()->add_cvars();
            //newConVar->set_name("\0");
            //newConVar->set_value("\0");

            //Hooks::SendNetMessage( engine->GetNetChannelInfo(), networkMessages->GetMessageHandleByName("CNETMsg_SetConVar"), &convar, BUF_DEFAULT );
            break;
        default:
            return inputInternalVMT->GetOriginalMethod<SetKeyCodeStateFn>(96)(thisptr, code, pressed);
    }
}
```

`src/Hooks/StartSoundEvent.cpp`:

```cpp
#include "Hooks.h"

#include "../Settings.h"

typedef void (* StartSoundEventFn)( CSoundOpSystem *, const char*, int, short, void const *, int );
typedef void (* StartSoundEvent2Fn)( CSoundOpSystem *, unsigned int, int, sound_voice_layer_t, short, const char *, void const *, int, SoundEventGuid_t ) ;

//"Stinger.MatchReady" not always played.... Depends on gamemode

/* Menu Sounds */
void Hooks::StartSoundEvent( CSoundOpSystem *thisptr, const char *name, int entIndex, short unk, void const *something, int unk2 ) {
    //cvar->ConsoleDPrintf( "Sound played: %s\n", name );
    return soundOpSystemVMT->GetOriginalMethod<StartSoundEventFn>( 11 )( thisptr, name, entIndex, unk, something, unk2 );
}

/* In Game Sounds */
void Hooks::StartSoundEvent2( CSoundOpSystem *thisptr, unsigned int unk, int entIndex, sound_voice_layer_t voiceLayer, short unk2, const char *name, void const *something,
                              int unk3, SoundEventGuid_t guid ) {
    //cvar->ConsoleDPrintf( "Sound2 played: %s\n", name );
    CBaseEntity *entity;
    if( mc_mute_creeps->GetBool() ){
        entity = entitySystem->GetBaseEntity( entIndex );
        if( entity && entity->GetOwnerID() <= 0 ){
            return;
        }
    }
    return soundOpSystemVMT->GetOriginalMethod<StartSoundEvent2Fn>( 12 )( thisptr, unk, entIndex, voiceLayer, unk2, name, something, unk3, guid );
}
```

`src/Interfaces.cpp`:

```cpp
#include "Interfaces.h"

#include "Utils/Patternfinder.h" //dlinfo_t
#include "Utils/Logger.h"
#include "Hooks/Hooks.h"

#include <link.h> // dl_iterate_phdr
#include <sys/stat.h>

bool Interfaces::FindExportedInterfaces( )
{
    client = GetInterface<CSource2Client>("../../dota/bin/linuxsteamrt64/libclient.so", "Source2Client002", 139 );
    cvar = GetInterface<ICvar>( "./libtier0.so", "VEngineCvar007", 41 );
    engine = GetInterface<IEngineClient>( "./libengine2.so", "Source2EngineToClient001", 173 );
    inputSystem = GetInterface<IInputSystem>( "./libinputsystem.so", "InputSystemVersion001", 92 );
    inputInternal = GetInterface<IInputInternal>("./libvgui2.so", "VGUI_InputInternal001", 101 );
    networkClientService = GetInterface<INetworkClientService>("./libengine2.so", "NetworkClientService_001", 68 );
    panel = GetInterface<IVPanel>("./libvgui2.so", "VGUI_Panel010", 80 );
    splitScreenService = GetInterface<CSplitScreenService>("./libengine2.so", "SplitScreenService_001", 47 );
    panoramaEngine = GetInterface<IPanoramaUIEngine>("./libpanorama.so", "PanoramaUIEngine001", 17 );
    fontManager = GetInterface<CFontManager>("./libmaterialsystem2.so", "FontManager_001", 45 );
    engineServiceMgr = GetInterface<CEngineServiceMgr>("./libengine2.so", "EngineServiceMgr001", 51 );
    particleSystemMgr = GetInterface<CParticleSystemMgr>("./libparticles.so", "ParticleSystemMgr003", 49 );
    networkMessages = GetInterface<CNetworkMessages>("./libnetworksystem.so", "NetworkMessagesVersion001", 35 );
    gameEventSystem = GetInterface<CGameEventSystem>("./libengine2.so", "GameEventSystemClientV001", 21 );
    networkStrings = GetInterface<CNetworkStringTableContainer>("./libengine2.so", "Source2EngineToClientStringTable001", 19);
    materialSystem = GetInterface<IMaterialSystem>("./libmaterialsystem2.so", "VMaterialSystem2_001", 39);
    networkSystem = GetInterface<CNetworkSystem>("./libnetworksystem.so", "NetworkSystemVersion001", 65);
    fileSystem = GetInterface<CBaseFileSystem>( "./libfilesystem_stdio.so", "VFileSystem017", 148);
    soundOpSystem = GetInterface<CSoundOpSystem>( "./libsoundsystem.so", "SoundOpSystem001", 157);
    fs = fileSystem;

    if( !requestedInterfaces.empty() ){
        for(auto & requestedInterface : requestedInterfaces){
            if( !requestedInterface.interface ){
                ConMsg( "Interface: (%s) is Null!\n", requestedInterface.name );
            }
        }
        return false;
    }
    return true;
}

void Interfaces::DumpInterfaces( const char *fileName )
{
    static std::vector<dlinfo_t> modules;
    struct stat buffer;

    // already exists? skip
    if( stat( fileName, &buffer ) == 0 ) {
        return;
    }

    dl_iterate_phdr([] (struct dl_phdr_info* info, size_t, void*) {
        dlinfo_t library_info = {};

        library_info.library = info->dlpi_name;
        library_info.address = info->dlpi_addr + info->dlpi_phdr[0].p_vaddr;
        library_info.size = info->dlpi_phdr[0].p_memsz;

        modules.push_back(library_info);

        return 0;
    }, nullptr);

    FILE *logFile;
    logFile = fopen(fileName, "a");
    setbuf( logFile, nullptr ); // turn off buffered I/O so it writes even if a crash occurs soon after.
    fprintf(logFile, "\n\n***************** Start of Log *****************\n");
    for ( const dlinfo_t& module: modules )
    {
        if( !module.library )
            continue;
        if( !strcasestr( module.library, "dota" ) ) // want dota to be in filepath
            continue;
        if( strcasestr( module.library, "libsteam_api.so" ) )
            continue;
        if( strcasestr( module.library, "libvideo.so" ) )
            continue;

        fprintf(logFile, "-- Module Name: %s --\n", module.library);

        void *library = dlopen(module.library, RTLD_NOLOAD | RTLD_NOW);
        if ( library == nullptr ){
            fprintf(logFile, "**Couldn't open library**\n");
            continue;
        }

        void *createInterfaceSym = dlsym(library, "CreateInterface");
        if ( createInterfaceSym == nullptr ) {
            fprintf( logFile, "**Couldn't find CreateInterface**\n" );
            dlclose(library);
            continue;
        }

        uintptr_t jump_instruction_addr = uintptr_t(createInterfaceSym) + 5;
        int32_t jump_displacement = *reinterpret_cast<int32_t*>(jump_instruction_addr + 1);
        uintptr_t createinterfaceinternal_addr = (jump_instruction_addr + 5) + jump_displacement;

        uintptr_t interface_list = createinterfaceinternal_addr;
        interface_list += *reinterpret_cast<int32_t*>(createinterfaceinternal_addr + 19); // relative offset to list
        interface_list += 23; // RIP after the address.

        dlclose(library);
        if( !interface_list )
        {
            fprintf(logFile, "ERROR: Couldn't find Interface List in Module: %s\n", module.library);
            continue;
        }

        InterfaceReg* interface_head = *reinterpret_cast<InterfaceReg**>(interface_list);

        std::vector<const char*> interface_name;

        for (InterfaceReg *cur_interface = interface_head; cur_interface; cur_interface = cur_interface->m_pNext)
            interface_name.push_back(cur_interface->m_pName);

        if ( interface_name.empty() ){
            fprintf(logFile, "Interface List is Empty!\n");
            continue;
        }


        for (auto interface : interface_name)
            fprintf(logFile, "\t%s\n", interface);

        fprintf(logFile, "\n");
    }
    fclose(logFile);
}

// Hook VMTs for interfaces that are not static (in-game entities, etc.)
void Interfaces::HookDynamicVMTs( ) {
    camera = GetCurrentCamera();

    if( camera ){
        cameraVMT.reset();
        MC_PRINTF("Grabbing new Camera VMT - (%p)\n", (void*)camera);
        cameraVMT = std::unique_ptr<VMT>(new VMT( camera ));
        cameraVMT->HookVM( Hooks::GetFogEnd, 19 );
        cameraVMT->HookVM( Hooks::GetZFar, 20 );
        cameraVMT->HookVM( Hooks::GetFoWAmount, 29 );
        cameraVMT->ApplyVMT();
    } else {
        MC_PRINTF_WARN("GetCurrentCamera() returned null! Aborting CameraVMT.\n");
    }
}
```

`src/Interfaces.h`:

```h
#pragma once

#include "SDK/SDK.h"
#include "Utils/Vmt.h"

// Interfaces
inline CGlobalVars* globalVars;
inline IVPanel* panel;
inline CSource2Client* client;
inline ICvar* cvar;
inline IEngineClient* engine;
inline IInputInternal* inputInternal;
inline IInputSystem* inputSystem;
inline INetworkClientService* networkClientService;
inline CSplitScreenService* splitScreenService;
inline CGameEntitySystem* entitySystem;
inline CVScriptGameSystem* vscriptSystem;
inline IPanoramaUIEngine* panoramaEngine;
inline CNetworkMessages* networkMessages;
inline CViewRender* viewRender;
inline IClientMode* clientMode;
inline CDotaCamera* camera;
inline CGameEventManager* gameEventManager;
inline CSoundOpSystem* soundOpSystem;
inline CFontManager* fontManager;
inline CEngineServiceMgr* engineServiceMgr;
inline CDOTARichPresence* richPresence;
inline CParticleSystemMgr* particleSystemMgr;
inline CGameEventSystem* gameEventSystem;
inline CNetworkStringTableContainer* networkStrings;
inline IMaterialSystem* materialSystem;
inline CVPhys2World* phys2World;
inline CRenderGameSystem* renderGameSystem;
inline CNetworkSystem* networkSystem;
inline CGCClient* gcClient;
inline CBaseFileSystem* fileSystem; // there is another pointer to this in Logger

// VMT's - these get deleted on module unload.
inline std::unique_ptr<VMT> cameraVMT;
inline std::unique_ptr<VMT> clientVMT;
inline std::unique_ptr<VMT> inputInternalVMT;
inline std::unique_ptr<VMT> panelVMT;
inline std::unique_ptr<VMT> uiEngineVMT;
inline std::unique_ptr<VMT> networkSystemVMT;
inline std::unique_ptr<VMT> netChannelVMT;
inline std::unique_ptr<VMT> clientModeVMT;
inline std::unique_ptr<VMT> soundOpSystemVMT;
inline std::unique_ptr<VMT> gameEventManagerVMT;
inline std::unique_ptr<VMT> particleSystemVMT;

// HardHook Addresses
inline uintptr_t DispatchPacketFnAddr;
inline uintptr_t BAsyncSendProtoFnAddr;

// Functions Types
typedef GameScriptScopesWrapper* (* GetPanoramaScriptScopesFn)( void );
typedef void (* OnAcceptMatchFn)( panorama::CPanel2D* );
typedef void (* GetMatricesForViewFn)( CRenderGameSystem *thisptr, CViewSetup &view, VMatrix *worldToView, VMatrix *viewToProjection, VMatrix *worldToProjection, VMatrix *worldToScreen );
typedef void (* CGameTraceInitFn)( void *thisGameTrace );
typedef void (* CTraceFilterConstructorFn)( void *thisTraceFilter, const void *IHandleEntity_Ignore, int, bool (* handler)( void *IHandleEntity, int ) );
typedef void (* SendMessageGenericClientToGCFn)( const google::protobuf::Message * const msg, EDOTAGCMsg nMsgID );

// Function Pointers
inline GetPanoramaScriptScopesFn GetPanoramaScriptScopes;
inline OnAcceptMatchFn OnAcceptMatch;
inline GetMatricesForViewFn GetMatricesForView;
inline CGameTraceInitFn GameTrace_Init;
inline CTraceFilterConstructorFn CTraceFilter_Constructor;
inline SendMessageGenericClientToGCFn SendMessageGenericClientToGC;

// Viewmatrixes
inline VMatrix *g_WorldToView;
inline VMatrix *g_WorldToScreen;
inline VMatrix *g_WorldToProjection;
inline VMatrix *g_ViewToProjection;

// Other
inline panorama::CPanel2D* gDBPlayPanel; // Special Panel

#define MC_PRINTF(f_, ...) ConColorMsg(Color( 255, 140, 5 ), ("[McDota] " f_), ##__VA_ARGS__)
#define MC_PRINTF(f_, ...) ConColorMsg(Color( 255, 140, 5 ), ("[McDota] " f_), ##__VA_ARGS__)
#define MC_PRINTF_PLAIN(f_, ...) ConColorMsg(Color( 255, 140, 5 ), ("" f_), ##__VA_ARGS__)
#define MC_PRINTF_ERROR(f_, ...) ConColorMsg(Color( 255, 20, 140 ), ("[McDota:%s] " f_ ), __FUNCTION__, ##__VA_ARGS__)
#define MC_PRINTF_WARN(f_, ...) ConColorMsg(Color( 255, 223, 0 ), ("[McDota:%s] " f_ ), __FUNCTION__, ##__VA_ARGS__)

namespace Interfaces
{
	bool FindExportedInterfaces( );
	void DumpInterfaces( const char *fileName );
	void HookDynamicVMTs();
}

```

`src/McDota.cpp`:

```cpp
#include "GUI/Gui.h"
#include "Hooks/HardHooks.h"
#include "Hooks/Hooks.h"
#include "Interfaces.h"
#include "Netvars.h"
#include "SDK/ConMsg.h"
#include "Scanner.h"
#include "Settings.h"
#include "Utils/Integritycheck.h"
#include "Utils/Util_sdk.h"
#include "Utils/Memory.h"
#include "Utils/Logger.h"

#include <dlfcn.h> //dlopen
#include <link.h> // link map
#include <signal.h>

struct sigaction sa;
struct sigaction oldSa;

void *mcPrev, *mcCurr, *mcNext;

/* We need to restore the linkmap before our unloading will work.
 * The unload script will send a signal that we intercept here */
static void RestoreLinkMapEntry( int sigNum, siginfo_t *si, void * uContext )
{
    if( mcPrev )
    {
        auto *previousEntry = reinterpret_cast<link_map*>(mcPrev);
        previousEntry->l_next = reinterpret_cast<link_map*>(mcCurr);
    }
    if( mcNext )
    {
        auto *nextEntry = reinterpret_cast<link_map*>(mcNext);
        nextEntry->l_prev = reinterpret_cast<link_map*>(mcCurr);
    }
}

/* Removes McDota from Library-Level dynamic library linked list
 * saves the prev/curr/next void ptrs for unloading. */
static void RemoveLinkMapEntry()
{
    auto *map = reinterpret_cast<struct link_map*>(dlopen(nullptr, RTLD_NOW));
    map = map->l_next->l_next;
    while (map) {
        if( strstr( map->l_name, "libMcDota.so" ) != nullptr ){
            mcPrev = map->l_prev;
            mcCurr = map;
            mcNext = map->l_next;
            if( map->l_prev ){
                map->l_prev->l_next = map->l_next;
            }
            if( map->l_next ){
                map->l_next->l_prev = map->l_prev;
            }
            return;
        }
        map = map->l_next;
    }
}

/* Entrypoint to the Library. Called when loading */
int __attribute__((constructor)) Startup()
{
    /* Setup new Signal Handler */
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sa.sa_sigaction = RestoreLinkMapEntry;
    sigaction(SIGXCPU, &sa, &oldSa); // set ours and backup the old one at the same time.

    Interfaces::DumpInterfaces( "/tmp/dotainterfaces.txt" );

    if( !Interfaces::FindExportedInterfaces( ) ){
        ConMsg( "[McDota] FindExportedInterfaces() Failed. Stopping...\n" );
        return 1;
    }
    if( !Integrity::CheckInterfaceVMs() ){
        ConMsg( "[McDota] CheckInterfaceVMs() Failed. Stopping...\n" );
        return 2;
    }
    /* The filesystem interface will only look in search paths. Add one so we can write in /tmp/. */
    fileSystem->AddSearchPath( "/tmp/", "TMPDIR", SearchPathAdd_t::PATH_ADD_TO_TAIL, 1 );
    /* Create our logfile in /tmp/ */
    Logger::logFile = fileSystem->Open("dota.log", "a+", "TMPDIR" );
    if( !Logger::logFile ){
        MC_PRINTF_ERROR("Couldn't create the logfile! Stopping...\n");
        return 3;
    }
    if( !Scanner::FindAllSigs() ){
        MC_PRINTF_ERROR("Failed to find one of the Signatures. Stopping...\n");
        return 4;
    }
    if( Integrity::VMTsHaveMisMatch() ){
        MC_PRINTF_ERROR("One of the VMs has had a Mismatch. Stopping...\n");
        return 5;
    }
    if( !Settings::RegisterCustomConvars() ){
        MC_PRINTF_ERROR("Error Registering ConVars, Stopping...\n");
        return 6;
    }
    if( !PaintTraverse::InitFonts() ){
        MC_PRINTF_ERROR("Paint Fonts Failed to Initialize, Stopping...\n");
        return 7;
    }


    ConColorMsg( Color(10, 210, 10), "[McDota] I'm in like Flynn.\n" );

    int width, height;
    engine->GetScreenSize( width, height );
    MC_PRINTF( "Your Dota 2 was Built on - %s - %sPST\n", engine->GetBuildDateString(), engine->GetBuildTimeString() );
    MC_PRINTF( "ScreenSize: %dx%d - Max Clients: %d\n", width, height, engine->GetMaxClients() );
    MC_PRINTF( "globalVars @ %p - [%s]\n", (void*)globalVars, Memory::GetModuleName(uintptr_t(globalVars)) );
    MC_PRINTF( "client @ %p - [%s]\n", (void*)client, Memory::GetModuleName((uintptr_t(client))) );
    MC_PRINTF( "viewRender @ %p - [%s]\n", (void*)viewRender, Memory::GetModuleName((uintptr_t(viewRender))) );
    MC_PRINTF( "clientMode @ %p - [%s]\n", (void*)clientMode, Memory::GetModuleName((uintptr_t(clientMode))) );
    MC_PRINTF( "Camera @ %p - [%s]\n", (void*)camera, Memory::GetModuleName((uintptr_t(camera))) );
    MC_PRINTF( "GameEventManger @ %p - [%s]\n", (void*)gameEventManager, Memory::GetModuleName((uintptr_t(gameEventManager))) );
    MC_PRINTF( "SoundOpSystem @ %p - [%s]\n", (void*)soundOpSystem, Memory::GetModuleName((uintptr_t(soundOpSystem))) );
    MC_PRINTF( "VScriptSystem @ %p - [%s]\n", (void*)vscriptSystem, Memory::GetModuleName((uintptr_t(vscriptSystem))) );
    MC_PRINTF( "CFontManager @ %p - [%s]\n", (void*)fontManager, Memory::GetModuleName((uintptr_t(fontManager))) );
    MC_PRINTF( "CEngineServiceMgr @ %p - [%s]\n", (void*)engineServiceMgr, Memory::GetModuleName((uintptr_t(engineServiceMgr))) );
    MC_PRINTF( "RichPresence @ %p - [%s]\n", (void*)richPresence, Memory::GetModuleName((uintptr_t(richPresence))) );
    MC_PRINTF( "ParticleSystemMgr @ %p - [%s]\n", (void*)particleSystemMgr, Memory::GetModuleName((uintptr_t(particleSystemMgr))) );
    MC_PRINTF( "CNetworkMessages @ %p - [%s]\n", (void*)networkMessages, Memory::GetModuleName((uintptr_t(networkMessages))) );
    MC_PRINTF( "CGameEventSystem @ %p - [%s]\n", (void*)gameEventSystem, Memory::GetModuleName((uintptr_t(gameEventSystem))) );
    MC_PRINTF( "CVPhys2World @ %p - [%s]\n", (void*)phys2World, Memory::GetModuleName((uintptr_t(phys2World))) );
    MC_PRINTF( "UI Engine @(%p) | Running? (%s)\n", (void*)panoramaEngine->AccessUIEngine(), panoramaEngine->AccessUIEngine()->IsRunning() ? "yes" : "no" );
    MC_PRINTF( "Active Loop Name: (%s) | Addon String: (%s)\n", engineServiceMgr->GetActiveLoopName(), engineServiceMgr->GetAddonsString() );
    MC_PRINTF( "NetworkGameClient @ %p - [%s]\n",(void*)networkClientService->GetIGameClient(), Memory::GetModuleName( uintptr_t(networkClientService->GetIGameClient()) ) );
    MC_PRINTF( "GetAllClasses @ %p - [%s]\n", (void*)client->GetAllClasses(), Memory::GetModuleName( uintptr_t(client->GetAllClasses()) ) );
    MC_PRINTF( "World2Screen @ %p - RenderGameSystem @ %p\n", g_WorldToScreen, renderGameSystem);
    MC_PRINTF( "Camera @ %p\n", (void*)camera );

    clientVMT = std::unique_ptr<VMT>(new VMT(client));
    clientVMT->HookVM(Hooks::FrameStageNotify, 29);
    clientVMT->ApplyVMT();

    clientModeVMT = std::unique_ptr<VMT>(new VMT(clientMode));
    clientModeVMT->HookVM(Hooks::CreateMove, 27);
    clientModeVMT->HookVM(Hooks::LevelInit, 28);
    clientModeVMT->ApplyVMT();

    gameEventManagerVMT = std::unique_ptr<VMT>(new VMT(gameEventManager));
    gameEventManagerVMT->HookVM(Hooks::CreateEvent, 7);
    gameEventManagerVMT->HookVM(Hooks::FireEventClientSide, 9);
    gameEventManagerVMT->ApplyVMT();

    soundOpSystemVMT = std::unique_ptr<VMT>(new VMT(soundOpSystem));
    soundOpSystemVMT->HookVM(Hooks::StartSoundEvent, 11);
    soundOpSystemVMT->HookVM(Hooks::StartSoundEvent2, 12);
    soundOpSystemVMT->ApplyVMT();

    panelVMT = std::unique_ptr<VMT>(new VMT(panel));
    panelVMT->HookVM(Hooks::PaintTraverse, 55);
    panelVMT->ApplyVMT();

	inputInternalVMT = std::unique_ptr<VMT>(new VMT(inputInternal));
    inputInternalVMT->HookVM(Hooks::SetKeyCodeState, 96);
    inputInternalVMT->ApplyVMT();

    uiEngineVMT = std::unique_ptr<VMT>(new VMT(panoramaEngine->AccessUIEngine()));
    uiEngineVMT->HookVM(Hooks::RunScript, 111);
    uiEngineVMT->ApplyVMT();

    particleSystemVMT = std::unique_ptr<VMT>(new VMT( particleSystemMgr ));
    particleSystemVMT->HookVM(Hooks::CreateParticleCollection, 18);
    particleSystemVMT->HookVM(Hooks::DeleteParticleCollection, 19);
    particleSystemVMT->ApplyVMT();

    networkSystemVMT = std::unique_ptr<VMT>(new VMT( networkSystem ));
    networkSystemVMT->HookVM(Hooks::CreateNetChannel, 26);
    networkSystemVMT->ApplyVMT();

    Netvars::DumpNetvars( client, "/tmp/dotanetvars.txt" );
    Netvars::CacheNetvars( client );

    if( engine->IsInGame() ){
        Interfaces::HookDynamicVMTs();

        if( engine->GetNetChannelInfo() ) {
            MC_PRINTF( "Grabbing new NetChannel VMT - %p\n", (void*)engine->GetNetChannelInfo() );
            netChannelVMT = std::unique_ptr<VMT>(new VMT( engine->GetNetChannelInfo( ) ));
            netChannelVMT->HookVM( Hooks::SendNetMessage, 70 );
            netChannelVMT->HookVM( Hooks::PostReceivedNetMessage, 88 );
            netChannelVMT->ApplyVMT( );
        } else {
            MC_PRINTF_WARN("GetNetChannelInfo returned null! Aborting NetChannel VMT!\n");
        }
    }

    if( !Util::ReadParticleFiles( "TMPDIR", "dotaparticleblacklist.txt", "dotaparticletracker.txt" ) ){
        MC_PRINTF_WARN("Specified particle file/s was missing or empty - Particle filters may not be set.\n");
    }

    RemoveLinkMapEntry();

    return 0;
}
/* Called when un-injecting the library */
void __attribute__((destructor)) Shutdown()
{
    /* Remove Hard Hooks (if any) */
    HardHooks::BAsyncSendProto.Remove();
    HardHooks::DispatchPacket.Remove();

    /* Reset camera mods */
    if( camera && engine && engine->IsInGame() ){
        camera->SetMinPitch( -1.0f );
        camera->SetMaxPitch( -1.0f );
        camera->SetExtraYaw( 0.0f );
        camera->SetDistanceToLookAtPos( 1200.0f );
    }

    /* Cleanup panels */
    if( panoramaEngine ){
        if( panoramaEngine->AccessUIEngine()->IsValidPanelPointer( UI::mcDota ) ){
            UI::mcDota->RemoveAndDeleteChildren();
            panorama::IUIPanel *root = UI::mcDota->GetParent();
            if( panoramaEngine->AccessUIEngine()->IsValidPanelPointer( root ) ){
                root->RemoveChild( UI::mcDota );
            } else {
                MC_PRINTF("ERROR unloading, root panel is invalid! (%p)\n", root );
            }
        }
    }

    /* Cleanup ConVars we have made */
    if( cvar ){
        for( ConVar* var : Util::createdConvars ){
            cvar->UnregisterConCommand(var);
                delete[] var->m_pszName;
                delete[] var->m_Value.m_pszString;
                delete[] var->m_pszDefaultValue;
                delete[] var->m_pszHelpString;
                delete[] var->m_fnChangeCallbacks.m_pElements;
            delete (char*)var; // cast so we dont invoke destructor
        }
        ConColorMsg(Color(255, 0, 0), "[McDota] I'm outta here.\n");
    } else {
        ConMsg( "[McDota] I'm outta here.\n" );
    }

    /* Close logfile */
    fileSystem->Close( Logger::logFile );
    /* Remove our added filesystem search path. */
    fileSystem->RemoveSearchPath( "/tmp/", "TMPDIR" );

    /* Restore previous signal handler */
    /* SIGXCPU actually just normally kills the game lol */
    sigaction(SIGXCPU, &oldSa, nullptr );
}

```

`src/Netvars.cpp`:

```cpp
#include "Netvars.h"

#include "Utils/Logger.h"

void Netvars::DumpNetvars( CSource2Client *client, const char *fileName ) {
    FileHandle_t dumpFile = fs->Open( "dotanetvars.txt", "w", "TMPDIR" );

    if( !dumpFile ){
        return;
    }


    fs->FPrintf(dumpFile, "\n\n***************** Start of Log *****************\n");

    for( ClientClass *classes = client->GetAllClasses(); classes; classes = classes->m_pNext ){
        if( !classes->recvTable || !classes->recvTable->netVarsArray || !classes->m_pClassName )
            continue;

        fs->FPrintf(dumpFile,  "%s - NumOfVars: %d\n", classes->m_pClassName, classes->recvTable->numOfVars );
        for( int i = 0; i < classes->recvTable->numOfVars; i++ ){
            Netvar *var = classes->recvTable->netVarsArray[i].netVar;
            if( !var
                || !var->netvarName
                || !var->typeName )
                break;

            fs->FPrintf(dumpFile,  "\t(%d)%s -> %s @ 0x%x\n", i + 1, var->netvarName, var->typeName, var->offset );
        }
    }

    fs->FPrintf(dumpFile, "\n\n***************** End of Log *****************\n");

    fs->Close( dumpFile );
}

void Netvars::CacheNetvars( CSource2Client *client ) {

    for( ClientClass *classes = client->GetAllClasses(); classes; classes = classes->m_pNext ){
        if( !classes->recvTable || !classes->recvTable->netVarsArray || !classes->m_pClassName )
            continue;

        for( int i = 0; i < classes->recvTable->numOfVars; i++ ){
            Netvar *var = classes->recvTable->netVarsArray[i].netVar;
            if( !var
                || !var->netvarName
                || !var->typeName )
                break;

            netvars[classes->m_pClassName][var->netvarName] = var->offset;
        }
    }

}
```

`src/Netvars.h`:

```h
#pragma once
#include <unordered_map>
#include <string>
#include <cstdint>

#include "SDK/CSource2Client.h"

namespace Netvars
{
    void DumpNetvars( CSource2Client *clientInterface, const char *fileName );
    void CacheNetvars( CSource2Client *client );

    inline std::unordered_map<std::string, std::unordered_map<std::string, uint32_t>> netvars;
}
```

`src/SDK/CBaseCombatCharacter.h`:

```h
#pragma once

#include "CBaseEntity.h"


class CBaseCombatCharacter : public CBaseEntity
{
    virtual bool C_BaseCombatCharacter__AreFootstepsAudible(float unk, bool unk2);
    virtual bool C_BaseCombatCharacter__IsFootstepAudible(float unk, bool unk2);
    virtual float C_BaseCombatCharacter__GetFootstepRunThreshold(void);
    virtual bool C_BasePlayer__IsGhost(void);
};
```

`src/SDK/CBaseEntity.h`:

```h
#pragma once

#include "Schema.h"
#include "vector.h"
#include "CCollisionProperty.h"
#include "Datamap.h"


enum OverlayFlags_t : unsigned long long
{
    BBOX = (1 << 2), //4
    ABSBOX = (1 << 5),//32
    RBOX = (1 << 6), //64
    ENTITYBOUNDS = (1 << 7), //128 - Looks like it depends on a byte being set in the class.
    ENTITYATTACHMENTS = (3 << 8), //BYTE1(flags) & 3
    ENTITYJOINTINFO = 0x40000,
    ENTITYSKELETON = (24 << 8), //BYTE1(flags) & 24 // kinda slow.
    ENTITYHITBOXES = (192 << 8), //BYTE1(flags) & 192
    BUDDHA = 0x40000000,
    ENTITYVIEWOFFSET = 0x800000000
};

enum DOTATeam_t : int {
    DOTA_TEAM_INVALID = -1,
    DOTA_TEAM_FIRST = 2,
    DOTA_TEAM_GOODGUYS = 2, //Radiant team.
    DOTA_TEAM_BADGUYS = 3, 	//Dire team.
    DOTA_TEAM_NEUTRALS = 4, //Neutral.
    DOTA_TEAM_NOTEAM = 5,
    DOTA_TEAM_CUSTOM_1 = 6,
    DOTA_TEAM_CUSTOM_MIN = 6,
    DOTA_TEAM_CUSTOM_2 = 7,
    DOTA_TEAM_CUSTOM_3 = 8,
    DOTA_TEAM_CUSTOM_COUNT = 8,
    DOTA_TEAM_CUSTOM_4 = 9,
    DOTA_TEAM_CUSTOM_5 = 10,
    DOTA_TEAM_CUSTOM_6 = 11,
    DOTA_TEAM_CUSTOM_7 = 12,
    DOTA_TEAM_CUSTOM_8 = 13,
    DOTA_TEAM_CUSTOM_MAX = 13,
    DOTA_TEAM_COUNT = 14
};

struct RenderableInstance_t{
    uint8_t m_nAlpha;
};


class ClientClass;
//xref "SUB_Remove called on entity" to SUB_Remove()
class CBaseEntity
{
public:
    inline DOTATeam_t GetTeam( )
    {
        static int offset = Util::FindDataMapElementOffset( this->C_DOTAPlayer__GetPredDescMap(), "m_iTeamNum" );
        if( !offset ){
            return DOTA_TEAM_INVALID;
        }
        return *( DOTATeam_t* )( ((uintptr_t)this) + offset );
    }
    inline QAngle* GetNetworkAngles( )
    {
        static int offset = Util::FindDataMapElementOffset( this->C_DOTAPlayer__GetPredDescMap(), "m_angNetworkAngles" );
        if( !offset ){
            return nullptr;
        }
        return ( QAngle* )( ((uintptr_t)this) + offset );
    }
    inline Vector* GetNetworkOrigin( )
    {
        static int offset = Util::FindDataMapElementOffset( this->C_DOTAPlayer__GetPredDescMap(), "m_vecNetworkOrigin" );
        if( !offset ){
            return nullptr;
        }
        return ( Vector* )( ((uintptr_t)this) + offset );
    }
    inline int GetOwnerID( )
    {
        static int offset = Util::FindDataMapElementOffset( this->C_DOTAPlayer__GetPredDescMap(), "m_hOwnerEntity" );
        if( !offset ){
            return -1;
        }
        int *ptr = ( int* )( ((uintptr_t)this) + offset );
        if( *ptr < 0 ){
            return -1;
        }
        return *ptr & 0xFFF;
    }
    virtual CSchemaClassBinding* Schema_DynamicBinding(void);
    virtual void DESTROY();
    virtual void DESTROY2();
    virtual int CEntityInstance__GetRefEHandle(void);
    virtual void* C_BaseCombatCharacter__GetScriptDesc(void);
    virtual void C_BaseFlex__Connect(void);
    virtual void PreCache() = 0;
    virtual void C_BaseAnimating__AddedToEntityDatabase(void);
    virtual void C_DOTAPlayer__Spawn(void* CEntityKeyValues);
    virtual void C_DOTAPlayer__PostDataUpdate(int DataUpdateType_t);
    virtual void C_BaseFlex__Activate(void);
    virtual void C_BasePlayer__UpdateOnRemove(void);
    virtual void C_BaseAnimating__OnSetDormant(void); // 0FFFFFFFEh
    virtual void C_BasePlayer__PreDataUpdate(int DataUpdateType_t);
    virtual void C_BaseEntity__DrawEntityDebugOverlays(OverlayFlags_t flags);
    virtual void sub_2F95420(); // added with dota-anime
    virtual void C_BaseEntity__Save( void* ISave ); // miner54
    virtual void C_BaseEntity__Restore( void* IRestore );
    virtual void C_BaseEntity__OnSave(void);
    virtual void C_BasePlayer__OnRestore(void);
    virtual void C_BaseEntity__ObjectCaps(void); // miner50
    virtual int CEntityInstance__RequiredEdictIndex(void);
    virtual void C_BaseEntity__NetworkStateChanged(void);
    virtual void C_BaseEntity__NetworkStateChanged2(unsigned int unk, int unk2, int ChangeAccessorFieldPathIndex_t);
    virtual void sub_273BE20();
    virtual void CEntityInstance__AddChangeAccessorPath(void* CFieldPath);
    virtual void CEntityInstance__ReloadPrivateScripts(void);
    virtual Datamap* C_DOTAPlayer__GetPredDescMap(void);
    virtual void YouForgotToImplementOrDeclareClientClass();
    virtual ClientClass* C_DOTAPlayer__GetClientClass(void);
    virtual void* datamap_maybe(); // might be the missing datamap from above. unsure - diretide 2020
    virtual void C_BaseModelEntity__SpawnShared(void* CEntityKeyValues);
    virtual void C_BaseModelEntity__PopulatePoseParameters(void);
    virtual void C_BasePlayer__PreFirstNetworkUpdate(void);
    virtual void* C_BaseModelEntity__GetBaseModelEntity(void);
    virtual void* C_BaseModelEntity__GetBaseModelEntity2(void);
    virtual void* C_BaseAnimating__GetBaseAnimating(void);
    virtual void* C_BaseAnimating__GetBaseAnimating2(void); // +38
    virtual void sub_285FB30();
    virtual void sub_285FB40();
    virtual bool C_BasePlayer__Classify(void);
    virtual CCollisionProperty* C_BaseModelEntity__GetCollideable(void); // moved w/ diretide 2020
    virtual void C_BaseEntity__ModifyEconParticles(int unk);
    virtual bool C_BaseEntity__ShouldSavePhysics(void);
    virtual bool C_BaseEntity__CreateVPhysics(void);
    virtual void C_BaseAnimating__DrawVCollide(void);
    virtual void C_BaseEntity__VPhysicsDestroyObject(void);
    virtual void C_BaseEntity__VPhysicsUpdate(void* IPhysicsObject);
    virtual void C_BaseAnimating__VPhysicsGetObjectList(void** IPhysicsObject, int unk);
    virtual bool C_BaseEntity__VPhysicsIsFlesh(void);
    virtual int sub_32BD9A0() = 0; // Added with TI10
    virtual int sub_35A2D60() = 0; // Added with TI10
    virtual void* C_BaseEntity__GetShadowDrawMaterial(void);
    virtual bool C_BaseEntity__IsAbleToHaveFireEffect(void); // Checks for low violence mode, kek.
    virtual bool C_BaseEntity__IsSelectable(void);
    virtual bool C_BaseEntity__ReceivesMouseoverButNotSelection(void);
    virtual float C_BaseEntity__GetRingRadius(void);
    virtual void sub_2A7EEE0();
    virtual void sub_2A5E4E0();
    virtual void C_BaseFlex__SetupWeights(matrix3x4_t * matrix, int unk, float *unk2, float *unk3);
    virtual void C_BaseEntity__GetVectors(Vector *outForward, Vector *outRight, Vector *outUp);
    virtual const Vector* C_BaseEntity__WorldAlignMins(void);
    virtual const Vector* C_BaseEntity__WorldAlignMaxs(void);
    virtual const Vector* C_BaseEntity__WorldSpaceCenter(void);
    virtual void sub_2A5E2D0();
    virtual void sub_2739BE0();
    virtual void C_BaseEntity__ValidateModelIndex(void);
    virtual void C_BaseCombatCharacter__OnNewParticleEffect(const char* name, void* CNewParticleEffect);
    virtual void C_BaseCombatCharacter__OnParticleEffectDeleted(void *CNewParticleEffect);
    virtual void* C_BaseAnimating__GetMouth(void);
    virtual void C_BaseEntity__OnBoneTransformsChanged(void);
    virtual void C_BaseEntity__ChangeTeam(DOTATeam_t team);
    virtual bool C_BaseEntity__InSameTeam(CBaseEntity *otherEnt); // double edi
    virtual bool C_BaseEntity__InLocalTeam(void);
    virtual bool C_BaseEntity__IsValidIDTarget(void);
    virtual const char* C_BaseEntity__GetIDString(void); // haystack
    virtual bool C_BaseEntity__IsPotentiallyUsable(void);
    virtual int C_BaseEntity__GetUseType(CBaseEntity *ent);
    virtual void* C_BaseModelEntity__GetGlowEntity(void);
    virtual bool C_BaseEntity__IsSaveNonNetworkable(void);
    virtual void sub_2A65970();
    virtual bool C_DOTAPlayer__ShouldDraw(void); // "vr_hmd_tracking_passthrough"
    virtual void C_DOTAPlayer__Simulate(void);
    virtual void sub_2A97C00();
    virtual void sub_2CDAE91();
    virtual void sub_2CDAD10();
    virtual void* C_BaseEntity__GetClientVehicle(void);
    virtual void sub_26F5240();
    virtual void C_BaseEntity__OverrideAlphaModulation(unsigned char alpha);
    virtual void C_BaseEntity__OverrideShadowAlphaModulation(unsigned char alpha);
    virtual void sub_26F5250();
    virtual void loc_2A93EF0();
    virtual void sub_2A7C7A0();
    virtual void C_BaseModelEntity__Clear(void);
    virtual float C_BaseEntity__GetTextureAnimationStartTime(void);
    virtual bool C_BaseEntity__TextureAnimationWrapped(void);
    virtual void loc_2A7A330();
    virtual void C_BaseEntity__OnTakeDamage(void* CTakeDamageInfo);
    virtual void C_BaseEntity__TakeDamage(void* CTakeDamageInfo);
    virtual void sub_26F57E0();
    virtual void sub_2E1E560(); // added with aghanim's labyrinth. xor eax, eax.
    virtual void unk_newFuncHashBucket(); // added with summer scrub pt2 - elf_gnu_hash_bucket
    virtual void sub_2907330();
    virtual void unk_elfshit(); //  rax, qword ptr ds:stru_D90.st_name - added 7-17-19
    virtual void* C_BasePlayer__GetPredictionOwner(void);
    virtual void unk_NewFunc(); // added with summer scrub pt2
    virtual void C_BaseEntity__InitPredictable(void* C_BasePlayer);
    virtual void C_BaseAnimating__SetPredictable(bool predictable);
    virtual int sub_2F50EC0(void); // added with nemestice - returns 1
    virtual void C_BaseEntity__DecalTrace(void* CGameTrace, const char* unk);
    virtual void C_BaseEntity__ImpactTrace(void* CGameTrace, int unk, const char* unk2);
    virtual bool C_DOTAPlayer__ShouldPredict(void);
    virtual void C_BasePlayer__PreRender(int splitScreenSlot);
    virtual const char* C_BaseEntity__GetPlayerName(void); // This function doesn't really do jack
    virtual int C_BaseEntity__GetUsePriority(void* C_BaseEntity); //returns 1
    virtual void C_BaseEntity__EstimateAbsVelocity(Vector &out);
    virtual bool C_BaseEntity__CanBePoweredUp(void);
    virtual void C_BaseEntity__AttemptToPowerup(int unk, float unk2, float unk3, void* C_BaseEntity, void* CDamageModifier);
    virtual void C_BaseEntity__StartTouch(void* C_BaseEntity);
    virtual void C_BaseEntity__Touch(void* C_BaseEntity);
    virtual void C_BaseEntity__EndTouch(void* C_BaseEntity);
    virtual void C_BaseEntity__Think(void);
    virtual void sub_2CCC210();
    virtual void C_BasePlayer__PhysicsSimulate(void);
    virtual void C_BaseEntity__SimulateThinkInternal(void);
    virtual void* C_BaseEntity__ClothGetEntityInstanceSettings(void);
    virtual void C_BaseEntity__NotifySystemEvent(void* C_BaseEntity, int notify_system_event_t, void* notify_system_event_params_t);
    virtual void C_BaseEntity__SUB_Remove(void); // "SUB_Remove"
    virtual void sub_2903930();
    virtual void sub_2F56F60(); // added with dota-anime
    virtual void sub_2F2C540(); // added with dota-anime
    virtual void sub_273A9D0(); // cmp qword ptr [rsi+50h], 0
    virtual void C_BaseEntity__DispatchTraceAttack(void* CTakeDamageInfo, const Vector &direction, void* CGameTrace);
    virtual void C_BaseEntity__TraceAttack(void* CTakeDamageInfo, const Vector &direction, void* CGameTrace);
    virtual bool C_BaseEntity__ShouldDrawWaterImpacts(void);
    virtual bool C_BaseEntity__ShouldDrawUnderwaterBulletBubbles(void);
    virtual ColorRGBA C_BaseCombatCharacter__BloodColor(void);
    virtual bool unk_something_new(void); //added with TI2019 battlepass, setz al // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_DOTAPlayer__IsPlayer(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_BaseEntity__IsHMDAvatar(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual void sub_26F5350(); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual void sub_25DDBB0(); //added with sept 26 dota+ update. // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_BaseCombatCharacter__IsBaseCombatCharacter(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual void* C_BaseCombatCharacter__MyCombatCharacterPointer(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual void* C_BaseCombatCharacter__MyCombatCharacterPointer2(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_BaseEntity__IsBaseObject(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_BaseEntity__IsBaseTrain(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual bool C_BaseEntity__IsNextBot(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual void* C_BaseEntity__MyInfectedPointer(void); // Note: One of these is missing, couldn't tell which one, they all return 0 --- //virtual void* C_BaseEntity__MyInfectedRagdollPointer(void); Removed this one
    virtual bool C_BaseEntity__IsSprite(void); // Note: One of these is missing, couldn't tell which one, they all return 0
    virtual int C_BaseEntity__GetMaxHealth(void);
    virtual void C_BaseEntity__SetHealth(int health);
    virtual int C_BaseEntity__GetHealth(void);
    virtual int C_BaseEntity__GetActualHealth(void);
    virtual void C_BaseEntity__ModifyOrAppendCriteria(void* CResponseCriteriaSet); // "unitname"
    virtual void sub_3310EF0() = 0; // added or moved with TI10
    virtual bool C_BaseEntity__WantSpawnCallOnPreData(void); // 1
    virtual Vector* C_DOTAPlayer__EyePosition(void);
    virtual QAngle* C_DOTAPlayer__EyeAngles(void);
    virtual QAngle* C_BasePlayer__LocalEyeAngles(void);
    virtual Vector* C_BasePlayer__EarPosition(void);
    virtual float C_BaseEntity__GetFriction(void);
    virtual Vector* C_BaseModelEntity__GetViewOffset(void);
    virtual void C_BaseEntity__GetVelocity(Vector *out1, Vector *out2);
    virtual bool C_BaseEntity__IsMoving(void);
    virtual void C_BaseEntity__OnGroundChanged(void* C_BaseEntity, void* C_BaseEntity2);
    virtual void C_BasedEntity__GetGroundVelocityToApply(Vector &out);
    virtual float C_BaseEntity__GetAttackDamageScale(void);
    virtual void C_BaseEntity__InternalSetEffects(int unk);
    virtual bool C_DOTAPlayer__ShouldInterpolate(void);
    virtual void* C_BaseEntity__GetS1Skin(void);
    virtual void sub_2739EE0();
    virtual void sub_2D7A100(); // added with furry hero
    virtual void sub_2D7A110(); // added with furry hero
    virtual void sub_2D7A120(); // added with furry hero
    virtual void C_BaseEntity__AddRagdollToFadeQueue();
    virtual void C_BaseEntity__OnLeftClick(void* C_BasePlayer, bool unk);
    virtual void C_BaseEntity__OnRightClick(void* C_BasePlayer);
    virtual void C_BaseEntity__OnCursorEntered(void);
    virtual void C_BaseEntity__OnCursorExited(void);
    virtual void* C_BaseEntity__GetSelection(void);
    virtual void C_BaseEntity__GenericSelectionGetClickValidBehaviors(void); //0x0FFFFFFFFh
    virtual void sub_2B6C440();
    virtual void sub_2BAEE50(); // added in outlanders update.
    virtual const Vector* C_BaseEntity__GetRenderOrigin(void);
    virtual const QAngle& C_BaseEntity__GetRenderAngles(void);
    virtual Vector C_BaseEntity__GetObserverCamOrigin(void);
    virtual void C_BaseEntity__RenderableToWorldTransform(void);
    virtual void C_BasePlayer__DrawModel(int flags, RenderableInstance_t*);
    virtual void C_BaseEntity__GetRenderBounds(Vector &out1, Vector &out2);
    virtual void C_BaseEntity__GetRenderBoundsWorldSpace(Vector &out1, Vector &out2);
    virtual void sub_2739E80();
    virtual void sub_2739E90();
    virtual void sub_2739F00();
    virtual void sub_2739EA0();
    virtual void sub_2739EB0();
    virtual void sub_2739F30();
    virtual void sub_2739ED0();
    virtual void sub_2B50A80(); //empty func - diretide 2020
    virtual void sub_2739F10();
    virtual void sub_2739F20();
    virtual void C_BaseCombatCharacter__OnNewModel_0();
    virtual void sub_diretide_stinker(); // added w/ diretide 2020
    virtual void sub_diretide_stinker1();// added w/ diretide 2020
    virtual void sub_diretide_stinker2();// added w/ diretide 2020
    virtual void C_BaseModelEntity__GetColorModulation(float *out);
    virtual void C_BaseModelEntity__DamageDecal(int unk, int unk2);
    virtual void sub_26F56F0();
    virtual void sub_26F5700(); // added sept 26 dota+ update -- empty function.
    virtual void sub_30C20C0(); // added with nemestice update.
    virtual void sub_25DDF10(); // "m_vecX" quantizedfloat meme
    virtual bool C_BaseModelEntity__CanBeSeenByTeam(DOTATeam_t team) = 0;
    virtual bool C_BaseModelEntity__IsPartOfFOWSystem(void); // F.O.W. = Fog Of War
    virtual void C_BaseAnimating__SetTransmit(void* CCheckTransmitInfo, bool unk);
    virtual void C_BaseAnimating__GetRenderData(void* unk, int ModelDataCategory_t); // StudioFrameAdvance wrapper
    virtual void C_BaseAnimating__UpdateClientSideAnimation(void);
    virtual void C_BaseAnimating__ComputeClientSideAnimationFlags(void);
    virtual void PlayPlayerFootstep(); // a guess
    virtual void sub_26F57A0();
    virtual void sub_2910170(); // 0x80000000h
    virtual void sub_26F57B0();
    virtual void no_idea_how_this_pad_happened();
    virtual void sub_26F6A90();
    virtual void sub_2902760(); // returns 0
    virtual void sub_26F57C0();
    virtual void sub_2912B60();
    virtual void sub_26F57D0();
    virtual void sub_2902720(); // floater
    virtual void sub_26F5800();
    virtual void sub_2902630(); // mov 3
    virtual void sub_29F9230(); //added w/ new bloom extension 2020
    virtual void sub_29F9500(); //added w/ new bloom extension 2020 cmp byte 2
    virtual void sub_29D23B0(); //added w/ shader update march 3 2020 - test80
    virtual void sub_32BE010(); //added w/ TI10
    virtual void sub_32BE020(); //added w/ TI10
    virtual void sub_32BE030(); //added w/ TI10
    virtual void sub_32BE040(); //added w/ TI10
    virtual void sub_292A800(); //samey
    virtual void sub_292A800_grug();
    virtual void sub_292A800_grug2(); // mouther -5
    virtual void C_BaseAnimating__HandleScriptedAnimEvent(void* animevent_t);
    virtual void C_BaseAnimating__HandleBehaviorAnimEvent(void* animevent_t);
    virtual void C_BaseAnimating__SpeechAnimEvent(const char* unk);
    virtual void unk_animEvent(); // added 7-17-19
    virtual void C_BaseAnimating__ControlMouth(const void* CModel); //"mouth"
    virtual bool C_BaseAnimating__IsViewModelOrAttachment(void);
    virtual void sub_2902780();
    virtual bool C_BaseAnimating__IsClientRagdoll(void);
    virtual void loc_2929160();
    virtual void C_BaseAnimating__CreateClientRagdoll(bool unk); //"client_ragdoll"
    virtual void sub_2A68210();
    virtual void C_BaseAnimating__DispatchMuzzleEffect(const char* effectNameMaybe, bool unk); // "weaponType"
    virtual void C_BaseAnimating__EjectParticleBrass(const char* brassNameMaybe, int unk);
    virtual bool C_BaseAnimating__IsViewModel(void);
    virtual void C_BaseAnimating__FormatViewModelAttachment(int unk, matrix3x4_t &matrix);
    virtual bool C_BaseAnimating__IsMenuModel(void);
    virtual void C_BaseAnimating__ComputeStencilState(void* ShaderStencilState_t);
    virtual bool C_BaseAnimating__WantsInterpolatedVars(void);
    virtual void sub_29025F0();
    virtual void sub_26F5880();
    virtual void sub_26F5890();
    virtual void C_BaseFlex__InitPhonemeMappings(void); //"phonemes"
    virtual void sub_empty(); // empty function added with furry hero
    virtual void C_BaseFlex__OverrideBlinkWeight(float weight);
    virtual void C_BaseFlex__StartSceneEvent();
    virtual void C_BaseFlex__ProcessSequenceSceneEvent();
    virtual void C_BaseFlex__ClearSceneEvent();
};
```

`src/SDK/CBaseFileSystem.h`:

```h
#pragma once

#include "IAppSystem.h"

enum SearchPathAdd_t
{
    PATH_ADD_TO_HEAD,		// First path searched
    PATH_ADD_TO_TAIL,		// Last path searched
};

enum FileWarningLevel_t
{
    // A problem!
    FILESYSTEM_WARNING = -1,

    // Don't print anything
    FILESYSTEM_WARNING_QUIET = 0,

    // On shutdown, report names of files left unclosed
    FILESYSTEM_WARNING_REPORTUNCLOSED,

    // Report number of times a file was opened, closed
    FILESYSTEM_WARNING_REPORTUSAGE,

    // Report all open/close events to console ( !slow! )
    FILESYSTEM_WARNING_REPORTALLACCESSES,

    // Report all open/close/read events to the console ( !slower! )
    FILESYSTEM_WARNING_REPORTALLACCESSES_READ,

    // Report all open/close/read/write events to the console ( !slower! )
    FILESYSTEM_WARNING_REPORTALLACCESSES_READWRITE,

    // Report all open/close/read/write events and all async I/O file events to the console ( !slower(est)! )
    FILESYSTEM_WARNING_REPORTALLACCESSES_ASYNC,
};

enum DVDMode_t
{
    DVDMODE_OFF    = 0, // not using dvd
    DVDMODE_STRICT = 1, // dvd device only
    DVDMODE_DEV    = 2, // dev mode, mutiple devices ok
};

enum KeyValuesPreloadType_t
{
    TYPE_VMT,
    TYPE_SOUNDEMITTER,
    TYPE_SOUNDSCAPE,
    NUM_PRELOAD_TYPES
};

enum FilesystemOpenExFlags_t
{
    FSOPEN_UNBUFFERED		= (1 << 0),
    FSOPEN_FORCE_TRACK_CRC	= (1 << 1),		// This makes it calculate a CRC for the file (if the file came from disk) regardless
    // of the IFileList passed to RegisterFileWhitelist.
    FSOPEN_NEVERINPACK	    = (1 << 2),		// 360 only, hint to FS that file is not allowed to be in pack file
};

enum EFileCRCStatus
{
    k_eFileCRCStatus_CantOpenFile,		// We don't have this file.
    k_eFileCRCStatus_GotCRC
};

enum ECacheCRCType
{
    k_eCacheCRCType_SingleFile,
    k_eCacheCRCType_Directory,
    k_eCacheCRCType_Directory_Recursive
};

enum FileSystemSeek_t
{
    FILESYSTEM_SEEK_HEAD	= 0,
    FILESYSTEM_SEEK_CURRENT = 1,
    FILESYSTEM_SEEK_TAIL	= 2,
};

typedef unsigned long CRC32_t;

#define MAX_PATH        4096 // no clue if this is correct, MAX_PATH doesn't have a linux equivalent. (yes I know about PATH_MAX, but it can vary which is an issue).
class CUnverifiedCRCFile
{
public:
    char m_PathID[MAX_PATH];
    char m_Filename[MAX_PATH];
    CRC32_t m_CRC;
};

typedef void* FileHandle_t;
typedef int FileFindHandle_t;
typedef void* FileNameHandle_t;

class IFileList;
class CSysModule;
class KeyValues;
class CUtlBuffer;

// xref "fs_debug" to CBaseFileSystem::Init() - (libfilesystem_stdio)
class CBaseFileSystem : IAppSystem
{
public:
    virtual void sub_12AD0() = 0;
    virtual void sub_11330() = 0;
    virtual FileHandle_t Open( const char *pFileName, const char *pOptions, const char *pathID = 0 ) = 0;     // if pathID is NULL, all paths will be searched for the file
    virtual void Close( FileHandle_t file ) = 0;
    virtual void Seek( FileHandle_t file, int pos, FileSystemSeek_t seekType ) = 0;
    virtual unsigned int Tell( FileHandle_t file ) = 0;
    virtual unsigned int Size( FileHandle_t file ) = 0;
    virtual unsigned int Size( const char *pFileName, const char *pPathID = 0 ) = 0; // "FS:  Tried to Size NULL filename!"
    virtual void Flush( FileHandle_t file ) = 0;
    virtual bool Precache( const char *pFileName, const char *pPathID = 0 ) = 0;
    virtual void loc_2A870() = 0;
    virtual void loc_2ABE0() = 0;
    virtual int Read( void* pOutput, int size, FileHandle_t file ) = 0;
    virtual int	Write( void const* pInput, int size, FileHandle_t file ) = 0;
    virtual bool ReadFile() = 0;//const char *pFileName, const char *pPath, CUtlBuffer &buf, int nMaxBytes = 0, int nStartingByte = 0, FSAllocFunc_t pfnAlloc = NULL ) = 0;
    virtual bool WriteFile( const char *pFileName, const char *pPath, CUtlBuffer &buf ) = 0;
    virtual bool UnzipFile( const char *pFileName, const char *pPath, const char *pDestination ) = 0;    // zip stuff Not "hooked up" for linux
    virtual bool CopyAFile( const char *pFileName, const char *pPath, const char *pDestination, bool unk ) = 0;
    virtual void sub_19350() = 0;
    virtual void sub_29580() = 0;
    virtual void AddSearchPath( const char *pPath, const char *pathID, SearchPathAdd_t addType, int searchPathPriority ) = 0;// 11
    virtual void RemoveSearchPath( const char *pPath, const char *pathID ) = 0;
    virtual void SaveSearchPathState( const char * ) = 0;
    virtual void RestoreSearchPathState( void * SearchPathStateHandle_t__ ) = 0;
    virtual void DestroySearchPathState( void * SearchPathStateHandle_t__ ) = 0;
    virtual void RemoveAllSearchPaths( void ) = 0;
    virtual void RemoveSearchPaths( const char * ) = 0;
    virtual void MarkPathIDByRequestOnly( const char *, bool ) = 0;
    virtual void loc_27BA0() = 0;
    virtual void loc_280E0() = 0;
    virtual void loc_27610() = 0;
    virtual void sub_11F20() = 0;
    virtual void sub_19F30() = 0;
    virtual void sub_232E0() = 0;
    virtual void sub_11E60() = 0;
    virtual void sub_1BFC0() = 0;
    virtual void sub_1EDC0() = 0;
    virtual void RemoveFile( char const* pRelativePath, const char *pathID = 0 ) = 0;
    virtual bool RenameFile( char const *pOldPath, char const *pNewPath, const char *pathID = 0 ) = 0;
    virtual bool IsDirectory( const char *pFileName, const char *pathID = 0  ) = 0; // 30
    virtual void FileTimeToString( char* pStrip, int maxCharsIncludingTerminator, long long fileTime ) = 0;
    virtual void SetBufferSize( FileHandle_t, unsigned int nBytes ) = 0; //"FS:  Tried to SetBufferSize NULL file"
    virtual bool IsOK( FileHandle_t file ) = 0;
    virtual bool EndOfFile( FileHandle_t file ) = 0;
    virtual char* ReadLine( char *pOutput, int maxChars, FileHandle_t file ) = 0;
    virtual int FPrintf( FileHandle_t file, const char *pFormat, ... ) = 0;
    virtual CSysModule* LoadModule( const char *pFileName, const char *pPathID = 0, bool bValidatedDllOnly = true ) = 0;
    virtual void UnloadModule( CSysModule *pModule ) = 0;
    virtual const char* FindFirst( const char *pWildCard, FileFindHandle_t *pHandle ) = 0;
    virtual const char* FindNext( FileFindHandle_t &handle ) = 0;
    virtual bool FindIsDirectory( const FileFindHandle_t &handle ) = 0;
    virtual void FindClose( FileFindHandle_t &handle ) = 0;
    virtual const char* FindFirstEx( const char *pWildCard, const char *pPathID, FileFindHandle_t *pHandle ) = 0;
    virtual void FindFileAbsoluteList() = 0;//CUtlVector<CUtlString,CUtlMemory<CUtlString,int>> &,char const*,char const* ) = 0;
    virtual const char* GetLocalPath( const char *pFileName, char *pLocalPath, int localPathBufferSize ) = 0;
    virtual bool GetCurrentDirectory( char* pDirectory, int maxlen ) = 0;
    virtual FileNameHandle_t FindOrAddFileName( const char *pFileName ) = 0;
    virtual bool String( const FileNameHandle_t& handle, char *buf, int buflen ) = 0;
    virtual void pure1() = 0;
    virtual void pure2() = 0;
    virtual void pure3() = 0;
    virtual void pure4() = 0;
    virtual void pure5() = 0;
    virtual void GetLocalCopy( const char *pFileName ) = 0;
    virtual void PrintOpenedFiles( void ) = 0;
    virtual void PrintSearchPaths( void ) = 0;
    virtual void SetWarningFunc( void (*pfnWarning)( const char *fmt, ... ) ) = 0;
    virtual void SetWarningLevel( FileWarningLevel_t level ) = 0;
    virtual void AddLoggingFunc( void (*pfnLogFunc)( const char *fileName, const char *accessType ) ) = 0;
    virtual void RemoveLoggingFunc( void (*pfnLogFunc)( const char *fileName, const char *accessType ) ) = 0;
    virtual void* GetFilesystemStatistics( void ) = 0;
    virtual FileHandle_t OpenEx( const char *pFileName, const char *pOptions, unsigned int flags = 0, const char *pathID = 0 ) = 0;
    virtual int	ReadEx( void* pOutput, int sizeDest, int size, FileHandle_t file ) = 0;
    virtual int	ReadFileEx() = 0;// const char *pFileName, const char *pPath, void **ppBuf, bool bNullTerminate = false, bool bOptimalAlloc = false, int nMaxBytes = 0, int nStartingByte = 0, FSAllocFunc_t pfnAlloc = NULL ) = 0;
    virtual FileNameHandle_t FindFilename( char const *pFileName ) = 0;
    virtual KeyValues	*LoadKeyValues( KeyValuesPreloadType_t type, char const *filename, char const *pPathID = 0 ) = 0;
    virtual void loc_16F30() = 0;
    virtual bool GetFileTypeForFullPath( char const *pFullPath, wchar_t *buf, int bufSizeInBytes ) = 0;
    virtual bool ReadToBuffer() = 0;//void *,CUtlBuffer &,int,void * (*)(char const*,uint)
    virtual bool GetOptimalIOConstraints( FileHandle_t hFile, unsigned *pOffsetAlign, unsigned *pSizeAlign, unsigned *pBufferAlign ) = 0;
    virtual void *AllocOptimalReadBuffer( FileHandle_t hFile, unsigned nSize = 0, unsigned nOffset = 0 ) = 0;
    virtual void FreeOptimalReadBuffer( void * ) = 0;
    virtual int	GetPathIndex( const FileNameHandle_t &handle ) = 0;
    virtual long long GetPathTime( const char *pPath, const char *pPathID ) = 0;
    virtual DVDMode_t GetDVDMode() = 0;
    virtual void EnableWhitelistFileTracking( bool bEnable ) = 0;
    virtual void RegisterFileWhitelist( IFileList *pWantCRCList, IFileList *pAllowFromDiskList, IFileList **pFilesToReload ) = 0;
    virtual void MarkAllCRCsUnverified() = 0;
    virtual void CacheFileCRCs( const char *pPathname, ECacheCRCType eType, IFileList *pFilter ) = 0;
    virtual EFileCRCStatus	CheckCachedFileCRC( const char *pPathID, const char *pRelativeFilename, CRC32_t *pCRC ) = 0;
    virtual int GetUnverifiedCRCFiles( CUnverifiedCRCFile *pFiles, int nMaxFiles ) = 0;
    virtual int GetWhitelistSpewFlags(void) = 0;
    virtual void SetWhitelistSpewFlags( int flags ) = 0;
    virtual void InstallDirtyDiskReportFunc(void (*)(void)) = 0;
    virtual bool IsLaunchedFromXboxHDD(void) = 0;
    virtual bool IsInstalledToXboxHDDCache(void) = 0;
    virtual bool IsDVDHosted(void) = 0;
    virtual bool IsInstallAllowed(void) = 0;
    virtual void GetSearchPathID(char *, int) = 0;
    virtual void FixupSearchPathsAfterInstall() = 0;
    virtual void GetDirtyDiskReportFunc() = 0;
    virtual void AddVPKFile() = 0;
    virtual void RemoveVPKFile() = 0;
    virtual void IsVPKFileLoaded() = 0;
    virtual void EnableAutoVPKFileLoading() = 0;
    virtual void GetAutoVPKFileLoading() = 0;
    virtual void AddUGCVPKFile() = 0;
    virtual void RemoveUGCVPKFile() = 0;
    virtual void IsUGCVPKFileLoaded() = 0;
    virtual void ParseUGCHandleFromFilename() = 0;
    virtual void CreateFilenameforUGCFile() = 0;
    virtual void OpenUGCFile() = 0;
    virtual void sub_10E00() = 0; // DLC-related functions. Changed with battlepass 2020
    virtual void DeleteDirectory() = 0;
    virtual void DeleteDirectoryAndContents() = 0;
    virtual void IsPathInvalidForFilesystem() = 0; //strLener
    virtual void GetAvailableDrives() = 0;
    virtual void Readline() = 0;
    virtual void sub_238A0() = 0;
    virtual void loc_26460() = 0; // "WARNING: Local content might be corrupt"
    virtual void loc_25B30() = 0;
    virtual void unk_26910() = 0;
    virtual void unk_26D50() = 0;
    virtual void pure6() = 0;
    virtual void pure7() = 0;
    virtual void pure8() = 0;
    virtual void pure9() = 0;
    virtual void pure10() = 0;
    virtual void pure11() = 0;
    virtual void pure12() = 0;
    virtual void pure13() = 0;
    virtual void pure14() = 0;
    virtual void pure15() = 0;
    virtual void pure16() = 0;
    virtual void pure17() = 0;
    virtual void sub_10DE0() = 0;
    virtual void pure18() = 0;
};
```

`src/SDK/CCollisionProperty.h`:

```h
#pragma once
#include "vector.h"
#include "Schema.h"
#include "Datamap.h"
#include "../Utils/Util_sdk.h"

struct RnCollisionAttr_t
{
    int64_t nInteractAs;
    int64_t nInteractsWith;
    int64_t nInteractsExclude;
    int nEntityId;
    short nHierarchyId;
    unsigned char nCollisionGroup;
    unsigned char nCollisionFunctionMask;
};

struct SolidType_t;
struct ChangeAccessorFieldPathIndex_t
{
    short value;
};

class CCollisionProperty
{
public:
    virtual CSchemaClassBinding* Schema_DynamicBinding(void);
    virtual Datamap* GetPredDescMap();


    /* Use CBaseEntity->WorldAlignMins/Maxs Instead of this crap I reversed for no reason */
    inline const Vector * GetMins()
    {
        static int offset = Util::FindDataMapElementOffset( this->GetPredDescMap(), "m_vecMins" );
        if( !offset )
            return nullptr;
        return (const Vector *)((uintptr_t)this + offset);
    }

    inline const Vector * GetMaxs()
    {
        static int offset = Util::FindDataMapElementOffset( this->GetPredDescMap(), "m_vecMaxs" );
        if( !offset )
            return nullptr;
        return (const Vector *)((uintptr_t)this + offset);
    }



    /* This all changed when the valve nation attacked(rubick arcana), only one person, the last dota bender could restore order to CCollisionProperty

    virtual uint64_t GetEntityHandle(void) = 0;
    virtual const Vector& OBBMins(void) = 0;
    virtual const Vector& OBBMaxs(void) = 0;
    virtual void WorldSpaceTriggerBounds(Vector *pVecWorldMins, Vector *pVecWorldMaxs) = 0;
    virtual const Vector& GetCollisionOrigin(void) = 0;
    virtual const QAngle& GetCollisionAngles(void) = 0;
    virtual const matrix3x4_t& CollisionToWorldTransform(void) = 0;
    virtual SolidType_t GetSolid(void) = 0;
    virtual int GetSolidFlags(void) = 0;
    virtual int GetCollisionGroup(void) = 0;
    virtual void WorldSpaceSurroundingBounds(Vector *pVecMins, Vector *pVecMaxs) = 0;
    virtual bool ShouldTouchTrigger(const RnCollisionAttr_t &) = 0;
    virtual void* GetVPhysicsObject(void) = 0;
    virtual void* GetCollisionAttribute(void) = 0;
    virtual bool IsCollisionEnabled(void) = 0;
    virtual void EnableAllCollisions(void) = 0;
    virtual void DisableAllCollisoins(void) = 0;
    virtual void EnableSolidCollisions(void) = 0;
    virtual void DisableSolidCollisions(void) = 0;
    virtual const Vector& OBBCenter(void) = 0;
    virtual void UpdateCollisionAttribute(void) = 0;
    virtual void MarkPartitionHandleDirty(void) = 0;
    virtual bool DoesRotationInvalidateSurroundingBox(void) = 0;
    virtual bool DoesVPhysicsInvalidateSurroundingBox(void) = 0;
    virtual bool DoesSequenceChangeInvalidateSurroundingBox(void) = 0;
    virtual void MarkSurroundingBoundsDirty(void) = 0;
    virtual void SetSolid(SolidType_t) = 0;
    virtual void sub_2DF1510() = 0;
    virtual CSchemaClassBinding* Schema_DynamicBinding() = 0;
    virtual void* GetPredDescMap(void) = 0;
    virtual void NetworkStateChanged(void) = 0;
    virtual void NetworkStateChanged2(unsigned int, int, ChangeAccessorFieldPathIndex_t) = 0;
    virtual void sub_2BE1070() = 0; // UseTriggerBounds?
     */
};
```

`src/SDK/CDOTAPlayerResource.h`:

```h
#pragma once

#include "CBaseEntity.h"
#include "CUtlVector.h"
#include "../Netvars.h"

struct PlayerResourcePlayerTeamData_t
{
    void *vtable;
    void *SmartPointer_pChainEntity;
    ChangeAccessorFieldPathIndex_t m_PathIndex;
    char _pad[2];
    int m_nSelectedHeroID; // ex: 48 = luna
    int m_iKills;
    int m_iAssists;
    int m_iDeaths;
    int m_iStreak; // how many kills wo/ dying
    int m_iLevel;
    int m_iRespawnSeconds; // seconds until respawn. -1 if alive.
    int m_iLastBuybackTime; // last buyback time in seconds since game started
    int m_hSelectedHero;
    void *_pad2[32];
};

class CDOTAPlayerResource : CBaseEntity
{
public:
    CUtlVector< PlayerResourcePlayerTeamData_t > * GetPlayerTeamData( ){
        static uint32_t offset = Netvars::netvars["C_DOTA_PlayerResource"]["m_vecPlayerTeamData"];
        if( !offset )
            return nullptr;
        return reinterpret_cast<CUtlVector< PlayerResourcePlayerTeamData_t > *>( ( uintptr_t(this) + offset ) );
    }
};
```

`src/SDK/CDOTARichPresence.h`:

```h
#pragma once

class CDOTARichPresence;

typedef void (* SetRPStatusFn)( CDOTARichPresence *, const char * );
inline SetRPStatusFn SetRPStatus;

class CDOTARichPresence
{
public:
    // Sets Rich Status ( normally: finding game/in-game/lvl )
    // Will crash the program if you pass something it doesn't like.
    // Most of the time it requires a '#' as the first character
    //
    // Check out the english localization txt file ( dota_english.txt )
    // OR you can write your own like this "#Bazinga one two three"
    void SetStatus( const char *text )
    {
        SetRPStatus( this, text );
    }
};



```

`src/SDK/CDOTAWearableItem.h`:

```h
#pragma once

#include "CBaseEntity.h"
#include "CBaseCombatCharacter.h"
#include "vector.h"

struct ClientModelRenderInfo_t;
struct animevent_t;

class C_BaseViewModel;
class CModel;

// xref "idle_to_run" to C_DOTA_BaseNPC::OnNewModel()
// 2nd to last function call is CSkeletonInstance::ForceLOD()
// xref it to short function with 4 call's. This is C_DOTAWearableItem::OnNewModel()
class CDOTAWearableItem : CBaseEntity
{
public:
    virtual void C_EconWearable__GiveTo(CBaseEntity *entity) = 0;
    virtual bool C_EconEntity__ShouldShowToolTip(void) = 0;
    virtual void C_EconEntity__InternalDrawModel(int flags, const RenderableInstance_t &) = 0;
    virtual void C_EconEntity__OnInternalDrawModel(ClientModelRenderInfo_t *) = 0;
    virtual void C_EconEntity__OnHandleAnimEvent(C_BaseViewModel *, animevent_t *) = 0;
    virtual void C_EconEntity__UseFlexDelayedWeights(void) = 0;
    virtual bool C_DOTAWearableItem__ShouldDrawParticleSystems(void) = 0;
    virtual bool C_EconEntity__AttachmentModelsShouldBeVisible(void) = 0;
    virtual void sub_36C4FA0() = 0;
    virtual bool C_EconEntity__IsTransparent(void) = 0;
    virtual bool C_EconEntity__IsUsingFBTexture(void) = 0;
    virtual void C_EconEntity__DrawOverriddenViewmodel(C_BaseViewModel *, int) = 0;
    virtual int C_EconEntity__LookupAttachment(const char *) = 0; // check out entity attachments in the visuals section of the cheat
    // These GetAttachment Functions return true if the attachment was found, false if not.
    // Also if not found, it will just set the Vector to the origin or something default.
    virtual bool C_EconEntity__GetAttachment(const char *, Vector &) = 0;
    virtual bool C_EconEntity__GetAttachment(const char *, Vector &, QAngle &) = 0;
    virtual bool C_EconEntity__GetAttachment(int, matrix3x4_t &) = 0;
    virtual bool C_EconEntity__GetAttachment(int, Vector &) = 0;
    virtual bool C_EconEntity__GetAttachment(int, Vector &, QAngle &) = 0;

    virtual void C_EconEntity__GetAttachmentVelocity(int, Vector &, Quaternion &) = 0;
    virtual void C_EconEntity__ViewModelAttachmentBlending(const CModel *, Vector *, Quaternion *, float, int) = 0;
    virtual void C_EconEntity__SetMaterialOverride(const char *) = 0;
    virtual void* C_EconEntity__GetAttributeManager(void) = 0; // these return the same thing
    virtual void* C_EconEntity__GetAttributeContainer(void) = 0; // ^^
    virtual void* C_EconEntity__GetAttributeOwner(void) = 0;
    virtual void* C_EconEntity__GetAttributeList(void) = 0;
    virtual void C_EconEntity__ReapplyProvision(void) = 0;
    virtual void C_EconWearable__UpdateBodyGroups(CBaseCombatCharacter *, int) = 0;
    virtual void C_EconWearable__TranslateViewmodelHandActivityInternal(int) = 0;
    virtual void sub_368A270() = 0;
    virtual bool C_EconWearable__IsWearable(void) = 0;
    virtual void C_EconWearable__RemoveFrom(CBaseEntity *) = 0;
    virtual bool C_EconWearable__CanEquip(CBaseEntity *) = 0;
    virtual void CDOTAWearableItem__Equip(CBaseCombatCharacter *) = 0;
    virtual void CDOTAWearableItem__UnEquip(CBaseCombatCharacter *) = 0;
    virtual void C_EconWearable__OnWearerDeath(void) = 0;
    virtual int C_EconWearable__GetDropType(void) = 0;
    // maybe GetDrawWearable/SetDrawWearable.
    virtual void sub_367E3C0() = 0;
    virtual void sub_36C26A0() = 0;
};
```

`src/SDK/CDotaBaseNPC.h`:

```h
#pragma once

#include "CBaseCombatCharacter.h"
#include "../Netvars.h"
/*
..........................,,,,______...........................
.....................*&(***************\(%&(...................
................./&%*************************%%,...............
..............&|*******************************\&(.............
............,&|***********************************(%...........
...........#|***************************************\&,........
...........&******************************************((.......
..........&********************************************(#......
.........#|*********************************************(*.....
.........&***********************************************&.....
........((***********************************************&.....
........#*************************************************&....
........&*************************************************|#...
........&**************************************************&...
........&**************************************************#/..
........&***********************@@@@***************@@@#****&,..
......../#**********************#@@@**********\****@@@@****&...      _______________________
.........%|**********************************#@@***********%/..     |                       |
..........&***********************************@@\***********%..    /      Buy Valve Games!  |
..........,&********&*************************\@@***********(*.   /      ___________________|
...........,&*******%**************************&@#**********(*.  /     /
.............&******&**************************\@@**********&,. /    /
.............,&******@**************************&@#********%,../   /
..............&******&|***************@@@@@@@@@@@@@*******&.../  /
..............&*******#(*********************************&.../ /
..............&********\&|******************************)&,./ /
..............&**********&\********%@@@@@@@@@@@@@@#****&..../..
............./#************\*************************]%........
.............%*******(********(%*********************(.........
............*(*****************\&******************)#..........
...........*%**********************&%************%%*...........
..........*#**************************\/((((@//,//.............
 */


class C_DOTABaseAbility;
// xref "%s_Abilities" to CreateDictionaries() OR "-herorecorder" to ParsePortraitInfo
class CDotaBaseNPC : public CBaseCombatCharacter
{
public:
    inline bool IsIllusion() {
        static uint32_t offset = Netvars::netvars["C_DOTA_BaseNPC_Hero"]["m_hReplicatingOtherHeroModel"]; //credits to hollow @UC
        if( !offset )
            return false;
        uintptr_t handle = *(uintptr_t*)((uintptr_t)this + offset);
        return (handle != 0xffffffff);
    }
    virtual void sub_2B07D70() = 0; // 308
    virtual void sub_2B08240() = 0;
    virtual void sub_2B08940() = 0;
    virtual void sub_290E410() = 0;
    virtual void sub_290E430() = 0; //subby20
    virtual void sub_290E450() = 0;
    virtual void sub_290E470() = 0;
    virtual void sub_290E471() = 0;
    virtual void sub_2D38700() = 0; //floaty54
    virtual void sub_2A99C60() = 0;
    virtual void sub_2CBFE80() = 0;
    virtual float C_DOTA_BaseNPC__GetZChangeSpeed(void) = 0;
    virtual float C_DOTA_BaseNPC__GetBonusFlyHeight(void) = 0; // 320
    virtual bool C_DOTA_BaseNPC__ShouldDoFlyHeightVisual(void) = 0;
    virtual void sub_2ED6660() = 0;
    virtual bool C_DOTA_BaseNPC__IsPortraitEntity(void) = 0;
    virtual int C_DOTA_BaseNPC__GetHealthPercent(void) = 0;
    virtual float C_DOTA_BaseNPC__GetHealthThinkRegen(void) = 0;
    virtual float C_DOTA_BaseNPC__GetMana(void) = 0;
    virtual float C_DOTA_BaseNPC__GetMaxMana(void) = 0;
    virtual float C_DOTA_BaseNPC__GetManaThinkRegen(void) = 0; //floater_same
    virtual void unk_29ae2c0() = 0;
    virtual void unk_29ae2f0() = 0;
    virtual float C_DOTA_BaseNPC__GetPhysicalArmorBaseValue() = 0;
    virtual void sub_2EAF5C0() = 0;
    virtual void sub_2EAF8A0() = 0;
    virtual void sub_2ED6700() = 0;
    virtual void sub_2EAF460() = 0;
    virtual void sub_2EB0140() = 0;
    virtual void sub_2F67100() = 0;
    virtual void sub_2F673B0() = 0;
    virtual void sub_2EAF550() = 0;
    virtual void sub_2EB6610() = 0;
    virtual void sub_2F67470() = 0;
    virtual float C_DOTA_BaseNPC__GetBaseMagicalResistanceValue(void) = 0;
    virtual float C_DOTA_BaseNPC__IncreasedAttackSpeed() = 0;
    virtual float C_DOTA_BaseNPC__GetBaseMoveSpeed() = 0;
    virtual float C_DOTA_BaseNPC__GetIdealSpeed() = 0;
    virtual void sub_2D10A70() = 0;
    virtual void C_DOTA_BaseNPC__LoadVoiceResources( void const *CEntityPrecacheContext ) = 0;
    virtual void sub_2D15050() = 0;
    virtual bool C_DOTA_BaseNPC__IsValidAbilityToCast( C_DOTABaseAbility *ability ) = 0;
    virtual void sub_27F8410() = 0;
    virtual void loc_2B523C0() = 0;
    virtual void sub_2E9B4A0() = 0;
    virtual void loc_2E978C0() = 0; //same_still
    virtual void sub_2E978F0() = 0;
    virtual void sub_2ED6760() = 0;
    virtual void sub_2ED6790() = 0;
    virtual void sub_2E97920() = 0;
    virtual void loc_2ED67E0() = 0;
    virtual void loc_2ED6810() = 0;
    virtual void sub_2ED6850() = 0;
    virtual void sub_2ED6860() = 0;
    virtual void sub_2ED6870() = 0;
    virtual void sub_2ED6890() = 0;
    virtual void sub_2ED6891() = 0;
    virtual void sub_287ADD0() = 0; // added w/ 2020 new bloom extender. returns 0
    virtual void sub_2CAED50() = 0; // added w/ battlepass 2020. returns 0
    virtual float sub_2E7D090() = 0; // added w/ WR Arcana, returns a float from outside the object
    virtual bool C_DOTA_BaseNPC__IsDemon(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsRoshan(void) = 0;
    virtual bool C_DOTA_BaseNPC__ShouldForwardPurchaseRequest(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsZombie(void) = 0;
    virtual bool C_DOTA_BaseNPC__CanAcceptTargetToAttack(CBaseEntity* target) = 0;
    virtual void sub_2ED6910() = 0;
    virtual void C_DOTA_BaseNPC__UpdateSelectionRing(void) = 0;
    virtual void C_DOTA_BaseNPC__OverrideSelectionPriority(int priority) = 0;
    virtual void C_DOTA_BaseNPC__UpdateBasedOnDormancy(bool) = 0;
    virtual bool C_DOTA_BaseNPC__CanBeSelected(void) = 0;
    virtual int C_DOTA_BaseNPC__GetEffectiveInvisibilityLevel(void) = 0;
    virtual void C_DOTA_BaseNPC__ComputeTranslucencyType(void) = 0;
    virtual const char* C_DOTA_BaseNPC__GetUnitLabel(void) = 0;
    virtual void loc_2E97990() = 0;
    virtual void sub_2ED6960() = 0;
    virtual void sub_2ED6980() = 0;
    virtual void sub_2EB9C60() = 0;
    virtual CDotaBaseNPC* C_DOTA_BaseNPC__GetChosenTarget(void) = 0;
    virtual int C_DOTA_BaseNPC__GetDamageMin(void) = 0;
    virtual int C_DOTA_BaseNPC__GetDamageMax(void) = 0; //27
    virtual float C_DOTA_BaseNPC__GetDamageBonus(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsRooted(void) = 0;
    virtual void sub_2ED6A30() = 0;
    virtual void sub_2EDBCA0() = 0;
    virtual bool C_DOTA_BaseNPC__IsDisarmed(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsAttackImmune(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsSilenced(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsMuted(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsStunned(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsHexed(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsInvisible(void) = 0; // not usable on enemies
    virtual bool C_DOTA_BaseNPC__IsInvulnerable(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsMagicImmune(void) = 0;
    virtual bool C_DOTA_BaseNPC__NoUnitCollision(void) = 0;
    virtual bool C_DOTA_BaseNPC__ProvidesVision(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsNightmared(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsEvadeDisabled(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsUnselectable(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsSpeciallyDeniable(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsFrozen(void) = 0; //fourteen
    virtual bool C_DOTA_BaseNPC__IsCommandRestricted(void) = 0;
    virtual bool C_DOTA_BaseNPC__NotOnMiniMap(void) = 0;
    virtual bool C_DOTA_BaseNPC__NotOnMiniMapForEnemies(void) = 0;
    virtual void sub_2ED6C30() = 0;
    virtual bool C_DOTA_BaseNPC__IsLowAttackPriority(void) = 0;
    virtual bool C_DOTA_BaseNPC__NoHealthBar(void) = 0;
    virtual bool C_DOTA_BaseNPC__NoTeamMoveTo(void) = 0;
    virtual bool C_DOTA_BaseNPC__NoTeamSelect(void) = 0;
    virtual bool C_DOTA_BaseNPC__PassivesDisabled(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsDominated(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsBlind(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsOutOfGame(void) = 0;
    virtual bool C_DOTA_BaseNPC__IsFakeAlly(void) = 0;
    virtual bool sub_2D3B320() = 0; // shr 0x22
    virtual bool sub_3194720() = 0; // shr 0x2D - added with furry hero
    virtual void sub_2D3B321() = 0;
    virtual void sub_2D3F810() = 0;
    virtual void C_DOTA_BaseNPC__OnStatesAdded(unsigned long long unk) = 0;
    virtual void C_DOTA_BaseNPC__OnStatesRemoved(unsigned long long unk) = 0;
    virtual void C_DOTA_BaseNPC__OnDebuffStateAdded( unsigned int ) = 0;
    virtual void C_DOTA_BaseNPC__OnDebuffStateRemoved( unsigned int ) = 0;
    virtual bool C_DOTA_BaseNPC__HasMovementCapability(void) = 0;
    virtual bool C_DOTA_BaseNPC__HasFlyingVision(void) = 0;
    virtual bool sub_31947C0() = 0; // added with furry hero
    virtual bool C_DOTA_BaseNPC__IsFlyingVisually(void) = 0;
    virtual void sub_2D3B770() = 0;
    virtual void C_DOTA_BaseNPC__CalculateActivityModifiers(int) = 0;
    virtual bool C_DOTA_BaseNPC__IsInventoryEnabled(void) = 0;
    virtual void C_DOTA_BaseNPC__GetSoundSet(void) = 0;
    virtual void C_DOTA_BaseNPC__GetSelectionGroup(void) = 0;
    virtual void C_DOTA_BaseNPC__GainedModifier(void* CDOTA_Buff) = 0;
    virtual void C_DOTA_BaseNPC__LostModifier(void* CDOTA_Buff) = 0;
    virtual bool C_DOTA_BaseNPC__IsIllusion(void) = 0; // not usable on enemies
    virtual void sub_2EDC3A0() = 0;
    virtual bool C_DOTA_BaseNPC__UnitStatsNeedsRefresh() = 0;
    virtual void sub_2D3F930() = 0;
    virtual int C_DOTA_BaseNPC__GetSpeechPitchLevel(void) = 0;
    virtual bool C_DOTA_BaseNPC__ShouldTranslateResponse(void) = 0;
    virtual bool C_DOTA_BaseNPC__CanSpeak(int unk) = 0;
    virtual bool C_DOTA_BaseNPC__UsesCustomSpeechOperatorStack(void) = 0;
    virtual void sub_2D10110() = 0;
    virtual void sub_2D0EF60() = 0;
    virtual void sub_2D100C0() = 0;
    virtual void sub_2D13940() = 0;
    virtual void sub_2D139A0() = 0;
    virtual void sub_2D3B7F0() = 0;
    virtual void sub_2D13A10() = 0;
    virtual void sub_2D3B490() = 0;
    virtual void sub_2ED6EF0() = 0;
    virtual void C_DOTA_BaseNPC__UsesConstantGesture(bool) = 0;
    virtual void C_DOTA_BaseNPC__GetConstantGestureWeight() = 0;
    virtual void C_DOTA_BaseNPC__GetConstantGestureCycle() = 0;
    virtual void C_DOTA_BaseNPC__GestureCycleComplete() = 0;
    virtual void C_DOTA_BaseNPC__ParsePortraitInfo(void *KeyValues) = 0;
    virtual CDotaPlayer* C_DOTA_BaseNPC__GetPlayerOwner(void) = 0;
    virtual int C_DOTA_BaseNPC__GetPlayerOwnerID(void) = 0;
    virtual bool C_DOTA_BaseNPC__HasModifiedAbilityParticleName(const char* abilityMaybe) = 0;
    virtual const char* C_DOTA_BaseNPC__GetModifiedAbilityParticleName(const char* abilityMaybe) = 0;
    virtual const char*  C_DOTA_BaseNPC__GetVoiceFile(void) = 0;
    virtual ColorRGBA C_DOTA_BaseNPC__GetUnitColor(void) = 0;
    virtual void C_DOTA_BaseNPC__GetAbilityLayout(void) = 0;
    virtual void C_DOTA_BaseNPC_Hero__IsModelIndexOriginalModel() = 0;
    virtual void C_DOTA_BaseNPC__UpdateAttributesForArcanaLevel() = 0;
    virtual void C_DOTA_BaseNPC__ApplyAdditionalPortraitParticles() = 0;
    virtual void sub_2D0FFE0() = 0;
    virtual void sub_2D0FFF0() = 0;
    virtual void C_DOTA_BaseNPC__BuildAttachedParticleFilter() = 0;
    virtual void sub_2D156C0() = 0;
    virtual void sub_310C670() = 0; // added with 2020 battlepass. Returns zero.
    virtual void sub_2DE04E0() = 0;
    virtual void C_DOTA_BaseNPC__UpdateNonCacheableWearableData() = 0;
    virtual void C_DOTA_BaseNPC_Hero__CreateDictionaries() = 0;
    virtual void C_DOTA_BaseNPC_Hero__PopulateDictionaries() = 0;
    virtual void C_DOTA_BaseNPC__SharedLoadNPCData() = 0;
    virtual void C_DOTA_BaseNPC__ComputeOverriddenGeneratingItem() = 0;

    /*
    virtual void sub_2D3B580() = 0;
    virtual void C_DOTA_BaseNPC_Hero__NotifyResourceStatusChange() = 0;
    virtual float C_DOTA_BaseNPC_Hero__GetHeroSpecialStrength(void) = 0;
    virtual float C_DOTA_BaseNPC_Hero__GetHeroSpecialAgility(void) = 0;
    virtual float C_DOTA_BaseNPC_Hero__GetHeroSpecialIntellect(void) = 0;
    virtual int C_DOTA_BaseNPC_Hero__GetGold(void) = 0;
    virtual void sub_2D391B0() = 0;
    virtual bool C_DOTA_BaseNPC_Hero__SetupBones(matrix3x4_t *pBoneToWorldOut, int maxBones, float boneMask, float currentTime) = 0;
    virtual void sub_2FA8B50() = 0;
    virtual void C_DOTA_BaseNPC_Hero__PostModelCombinerParticleUpdate() = 0;
    virtual void C_DOTA_BaseNPC_Hero__ModelCombineFinished() = 0;
    virtual void C_DOTA_BaseNPC_Hero__ModelCombineAbort() = 0;
    */
};
```

`src/SDK/CDotaCamera.h`:

```h
#pragma once

#include "vector.h"

// xref "camera_dota_default" to sub_I__unity_dota_05. Look nearby for a function being lea'd into rsi ( it should have operator new - CDOTA_Camera_Factory::Create )
// go into the function, then the next function(CDOTA_Camera::CDOTA_Camera), then vtable will be first offset address.
class CDotaCamera
{
public:
    virtual void DESTROY(void) = 0;
    virtual void DESTROY2(void) = 0;
    virtual void Init(void) = 0;
    virtual void PreThink(void) = 0;
    virtual void Think(void) = 0;
    virtual void PostThink(void) = 0;
    virtual void AddObserver(void *ICameraObserver) = 0;
    virtual void OnTransitionIn(void const *ICamera) = 0;
    virtual void OnTransitionOut(void) = 0;
    virtual void OnDemoSkip(void *IGameEvent) = 0;
    virtual void OnMouseWheeled(int) = 0;
    virtual void SetForwardMove(float value) = 0; // for moving camera
    virtual void SetSideMove(float value) = 0; // ^^
    virtual Vector* GetPosition(void) = 0; // 13
    virtual void* UnkPosition() = 0; // Calls GetPosition() - Added sometime in mid 2019
    virtual QAngle* GetAngles(void) = 0;
    virtual float GetFOV(void) = 0;
    virtual Vector GetEyeVector(void) = 0; // 17
    virtual float GetFogStart(float) = 0;
    virtual float GetFogEnd(float) = 0;
    virtual float GetZFar(float) = 0; // 20
    virtual float GetZNear(float) = 0;
    virtual bool ShouldHideCursor(void) = 0;
    virtual void SetLODOverride(int) = 0;
    virtual int GetLODOverride(void) = 0;
    virtual float sub_3633640(void) = 0; // added with TI10
    virtual float sub_3633650(void) = 0; // added with TI10
    virtual float sub_3633660(void) = 0; // added with TI10 - returns global float
    virtual float GetShadowDepthBiasOverrideFadeAmount(void) = 0;
    virtual float GetFOWAmount(void) = 0;
    virtual bool ShouldAllowUnitSelectionOnMouseDown(void) = 0;
    virtual bool ShouldAllowUnitSelectionOnMouseRelease(void) = 0;
    virtual bool ShouldSuppressGlows(void) = 0;
    virtual bool ShouldHideHealthBars(void) = 0; // 30
    virtual void sub_2FDFEB0() = 0;
    virtual void sub_2DB7F30() = 0;
    virtual void sub_2DB7F40() = 0;
    virtual void sub_2DB7F50() = 0;
    virtual void sub_2FDFE70() = 0;
    virtual void sub_2DB7F70() = 0;
    virtual void sub_2DB7F80() = 0;
    virtual void sub_2DB7F90() = 0;
    virtual void sub_2DB7FA0() = 0;
    virtual void sub_2DB7FB0() = 0; // 40
    virtual void sub_28F7270() = 0;
    virtual void sub_28F7290() = 0;
    virtual void sub_28F72A0() = 0;
    virtual void sub_28F72B0() = 0;
    virtual void sub_28F72C0() = 0;
    virtual void sub_28F72D0() = 0;
    virtual void sub_28F72E0() = 0;
    virtual void sub_28F72F0() = 0;
    virtual void sub_28F7300() = 0;
    virtual void sub_28F7170() = 0;
    virtual float GetTime(void) = 0; // 51


    // Xref "SetCameraYaw", CDOTA_PanoramaScript_GameUI::SetCameraYaw() will be right above it
    // Function CDOTA_Camera::SetExtraYaw() jmp'd at the end.
    void SetExtraYaw( float amount )
    {
        auto *extraYaw = (float*)((uintptr_t)this + 0x26C);
        *extraYaw = amount;
    }

    void SetMinPitch( float amount )
    {
        auto *minPitch = (float*)((uintptr_t)this + 0x268);
        *minPitch = amount;
    }

    void SetMaxPitch( float amount )
    {
        auto *maxPitch = (float*)((uintptr_t)this + 0x264);
        *maxPitch = amount;
    }

    float GetMinPitch( )
    {
        auto *minPitch = (float*)((uintptr_t)this + 0x268);
        return *minPitch;
    }

    float GetMaxPitch( )
    {
        auto *maxPitch = (float*)((uintptr_t)this + 0x264);
        return *maxPitch;
    }

    void SetDistanceToLookAtPos( float dist )
    {
        auto *distance = (float*)((uintptr_t)this + 0x270);
        *distance = dist;
    }

    // "Camera look-at position: %f %f %f\n"
    const Vector *GetLookAtPos( void )
    {
        auto *lookAtPos = (const Vector*)((uintptr_t)this + 0x278);
        return lookAtPos;
    }

    void SetLookAtPos( Vector &input )
    {
        auto *lookatPos = (Vector*)((uintptr_t)this + 0x278 );
        *lookatPos = input;
    }

    void SetFOWAmount( float amount )
    {
        auto *fowAmount = (float*)((uintptr_t)this + 0x70);
        *fowAmount = amount;
    }
};


typedef CDotaCamera* (* GetCameraFn)( void );

inline GetCameraFn GetCurrentCamera;
```

`src/SDK/CDotaFogOfWarSystem.h`:

```h
#pragma once

class CFoW
{
public:
    virtual void Init() = 0;
    virtual void PostInit() = 0;
    virtual void Shutdown() = 0;
    virtual void GameInit() = 0;
    virtual void GameShutdown() = 0;
    virtual void GamePostInit() = 0;
    virtual void BuildGameSessionManifest() = 0;
    virtual void sub_297A790() = 0;
    virtual void sub_297A7A0() = 0; // These are all empty functions,
    virtual void sub_297A7B0() = 0; // derived from IGameSystem with a couple extras.
    virtual void sub_297A7C0() = 0;
    virtual void sub_297A7D0() = 0;
    virtual void sub_297A7E0() = 0;
    virtual void sub_297A7F0() = 0;
    virtual void sub_3086650() = 0;
    virtual void sub_297A810() = 0;
    virtual void sub_297A820() = 0;
    virtual void sub_30813F0() = 0;
    virtual void sub_297A840() = 0;
    virtual void sub_297A850() = 0;
    virtual void PreRender() = 0;
    virtual void sub_297A870() = 0;
    virtual void sub_297A880() = 0;
    virtual void sub_297A890() = 0;
    virtual void sub_297A8A0() = 0;
    virtual void sub_297A8B0() = 0;
    virtual void sub_297A8C0() = 0;
    virtual void sub_297A8D0() = 0;
    virtual void sub_297A8E0() = 0;
    virtual void sub_297A8F0() = 0;
    virtual void sub_297A900() = 0;
    virtual void sub_297A910() = 0;
    virtual void sub_297A920() = 0;
    virtual const char* GetName() = 0;
    virtual void SetGameSystemGlobalPtrs( void* ) = 0;
    virtual void SetName(const char *) = 0;
    virtual bool DoesGameSystemReallocate() = 0;
    virtual void DESTROY1() = 0;
    virtual void DESTROY2() = 0;
};

```

`src/SDK/CDotaPlayer.h`:

```h
#pragma once

#include "CDotaBaseNPC.h"

enum class DotaUnitOrder_t : int {
    DOTA_UNIT_ORDER_NONE = 0,
    DOTA_UNIT_ORDER_MOVE_TO_POSITION = 1,
    DOTA_UNIT_ORDER_MOVE_TO_TARGET = 2,
    DOTA_UNIT_ORDER_ATTACK_MOVE = 3,
    DOTA_UNIT_ORDER_ATTACK_TARGET = 4,
    DOTA_UNIT_ORDER_CAST_POSITION = 5,
    DOTA_UNIT_ORDER_CAST_TARGET = 6,
    DOTA_UNIT_ORDER_CAST_TARGET_TREE = 7,
    DOTA_UNIT_ORDER_CAST_NO_TARGET = 8,
    DOTA_UNIT_ORDER_CAST_TOGGLE = 9,
    DOTA_UNIT_ORDER_HOLD_POSITION = 10,
    DOTA_UNIT_ORDER_TRAIN_ABILITY = 11,
    DOTA_UNIT_ORDER_DROP_ITEM = 12,
    DOTA_UNIT_ORDER_GIVE_ITEM = 13,
    DOTA_UNIT_ORDER_PICKUP_ITEM = 14,
    DOTA_UNIT_ORDER_PICKUP_RUNE = 15,
    DOTA_UNIT_ORDER_PURCHASE_ITEM = 16,
    DOTA_UNIT_ORDER_SELL_ITEM = 17,
    DOTA_UNIT_ORDER_DISASSEMBLE_ITEM = 18,
    DOTA_UNIT_ORDER_MOVE_ITEM = 19,
    DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO = 20,
    DOTA_UNIT_ORDER_STOP = 21,
    DOTA_UNIT_ORDER_TAUNT = 22,
    DOTA_UNIT_ORDER_BUYBACK = 23,
    DOTA_UNIT_ORDER_GLYPH = 24,
    DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH = 25,
    DOTA_UNIT_ORDER_CAST_RUNE = 26,
    DOTA_UNIT_ORDER_PING_ABILITY = 27,
    DOTA_UNIT_ORDER_MOVE_TO_DIRECTION = 28,
    DOTA_UNIT_ORDER_PATROL = 29,
    DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION = 30,
    DOTA_UNIT_ORDER_RADAR = 31,
    DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK = 32,
    DOTA_UNIT_ORDER_CONTINUE = 33,
    DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED = 34,
    DOTA_UNIT_ORDER_CAST_RIVER_PAINT = 35,
    DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT = 36,
};
enum PlayerOrderIssuer_t : int {
    DOTA_ORDER_ISSUER_SELECTED_UNITS = 0,
    DOTA_ORDER_ISSUER_CURRENT_UNIT_ONLY = 1,
    DOTA_ORDER_ISSUER_HERO_ONLY = 2,
    DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY = 3
};
enum OrderQueueBehavior_t : int {
    DOTA_ORDER_QUEUE_DEFAULT = 0,
    DOTA_ORDER_QUEUE_NEVER = 1,
    DOTA_ORDER_QUEUE_ALWAYS = 2,
};

// find SetPlayerUnderwater with "Player.AmbientUnderWater"
class CDotaPlayer : public CBaseCombatCharacter
{
public:
    virtual void sub_2A5EB10(); // 315
    virtual void sub_2A5EB12();
    virtual void sub_2A5EB13();
    virtual void sub_2A5EB14();
    virtual void sub_2A5F750();
    virtual void sub_285FCF0();
    virtual void C_BasePlayer__OnBecomeLocalPlayer(void);
    virtual void unk_newEmptyFunc(); // added with summer scrub pt2
    virtual void C_BasePlayer__CalcView(Vector &eyeOrigin, QAngle &eyeAngles, float &zNear, float &zFar, float &fov);
    virtual void C_BasePlayer__CalcViewModelView(const Vector& eyeOrigin, const QAngle& eyeAngles);
    virtual void C_BasePlayer__CalcRoll(const QAngle& angles, const Vector& velocity, float rollangle, float rollspeed);
    virtual bool C_BasePlayer__IsInThirdPersonView(void);
    virtual void C_BasePlayer__SetPlayerUnderwater(bool underwater);
    virtual void sub_2A5DCC0();
    virtual void sub_2A5DCA0();
    virtual void sub_2A5DD70();
    virtual bool C_BasePlayer__Weapon_CanUse(void* C_BaseCombatWeapon);
    virtual void C_BasePlayer__Weapon_DropPrimary(void);
    virtual void C_DOTAPlayer__SendMove(int unk);
    virtual void unk_EmptyFunc(); // added with summer scrub pt2
    virtual void* C_BasePlayer__FindUseEntity(float unk, float unk2, float unk3, bool *unk4, bool unk5);
    virtual bool C_BasePlayer__IsUsableEntity(void* C_BaseEntity, unsigned int unk);
    virtual void sub_28646E0();
    virtual int CDOTAPlayer__GetObserverMode(void); // realunderwater+20
    virtual void* C_BasePlayer__GetObserverTarget(void);
    virtual bool C_BasePlayer__IsBot(void);
    virtual void C_BasePlayer__TeamChange(DOTATeam_t team);
    virtual const char* C_BasePlayer__GetFlashlightTextureName(void);
    virtual float C_BasePlayer__GetFlashlightFOV(void);
    virtual float C_BasePlayer__GetFlashlightFarZ(void);
    virtual void C_BasePlayer__GetFlashlightLinearAtten(void);
    virtual bool C_BasePlayer__CastsFlashlightShadows(void);
    virtual Vector* C_BasePlayer__GetFlashlightOffset(void); //realunderwater+30
    virtual bool C_BasePlayer__IsAllowedToSwitchWeapons(void);
    virtual void unknown(); // added around 5/13/18. Returns 0 by default.
    virtual void*C_BasePlayer__GetRenderedWeaponModel(void);
    virtual bool C_BasePlayer__IsOverridingViewModel(void);
    virtual void C_BasePlayer__ThirdPersonSwitch(bool thirdperson);
    virtual void sub_2CAF2C0(); // added mid-july 2018. Possibly related to CViewAngleAnimation::RunAnimation
    virtual int C_DOTAPlayer__GetPlayerID(void);
    virtual bool C_BasePlayer__CanSetSoundMixer(void); //comp2
    virtual void C_BasePlayer__PlayerSolidMask(bool unk); // 83011h
    virtual void C_BasePlayer__PreThink(void);
    virtual void C_BasePlayer__PostThink(void);
    virtual void C_BasePlayer__ItemPreFrame(void);
    virtual void C_BasePlayer__ItemPostFrame(void);
    virtual void C_BasePlayer__AbortReload(void);
    virtual void C_BasePlayer__SelectLastItem(void);
    virtual void C_BasePlayer__Weapon_SetLast(void* C_BaseCombatWeapon);
    virtual bool C_BasePlayer__Weapon_ShouldSetLast(void* C_BaseCombatWeapon, void* C_BaseCombatWeapon2);
    virtual bool C_BasePlayer__Weapon_ShouldSelectItem(void* C_BaseCombatWeapon);
    virtual void* C_BasePlayer__GetLastWeapon(void);
    virtual void* C_BasePlayer__SelectItem(const char* name, int unk);
    virtual void* C_BasePlayer__SelectItem(void* C_BaseCombatWeapon);
    virtual void C_BasePlayer__UpdateClientData(void);
    virtual float C_DOTAPlayer__GetFOV(void);
    virtual float C_DOTAPlayer__GetDefaultFOV(void);
    virtual bool C_BasePlayer__IsZoomed(void);
    virtual float C_DOTAPlayer__GetNearZ(void);
    virtual float C_DOTAPlayer__GetFarZ(void); //floatZero
    virtual void ViewPunch( const QAngle& out );
    virtual void sub_2C8F980(); // added late June 2018, takes 2 args, sets them in class.
    virtual void C_BasePlayer__OverrideView(void* CViewSetup);
    virtual Vector* C_BasePlayer__GetPlayerMins(void);
    virtual Vector* C_BasePlayer__GetPlayerMaxs(void);
    virtual ColorRGBA C_DOTAPlayer__GetPlayerColor(void);
    virtual CBaseEntity* C_BasePlayer__GetUseEntity(void);
    virtual CBaseEntity* C_BasePlayer__GetHeldEntity(void);
    virtual void C_BasePlayer__SetAnimation(int PLAYER_ANIM);
    virtual QAngle* C_BasePlayer__GetPunchAngle(void);
    virtual bool sub_2AF93E0(); // added after ti8 - returns 1 by default.
    virtual float C_BasePlayer__GetMinFOV(void);
    virtual void C_BasePlayer__UpdateStepSound(void* CPhysSurfaceProperties, const Vector &pos, const Vector &unk);
    virtual void C_BasePlayer__PlayStepSound(Vector &pos, void* CPhysSurfaceProperties, float unk, bool unk2);
    virtual void C_BasePlayer__GetFootstepSurface(const Vector &pos, const char* unk); // RegisterStringToken0
    virtual void C_BasePlayer__GetStepSoundVelocities(float *outSpeedX, float *outSpeedY);
    virtual void C_BasePlayer__OnAchievementAchieved(int iAchievement);
    virtual void sub_2AF9440(); // added after ti8
    virtual void sub_2AF9450(); // ^^
    virtual void sub_2860060();
    virtual void sub_2F8BA00(); // added with battlepass 2020
    virtual void C_BasePlayer__CalcPlayerView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual int loc_2DCC4F0(); //diretide 2020 - returns 0
    virtual float sub_2C339B0(); //diretide 2020 - returns a float from inside.
    virtual void C_DOTAPlayer__CalcObserverView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov); //switch: 7 cases
    virtual void C_BasePlayer__GetChaseCamViewOffset(void *targetC_BaseEntity );
    virtual void C_BasePlayer__CalcChaseCamView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual void C_BasePlayer__CalcInEyeCamView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual void C_BasePlayer__CalcDeathCamView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual void C_BasePlayer__CalcRoamingView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual void C_BasePlayer__CalcFreezeCamView(Vector& eyeOrigin, QAngle& eyeAngles, float& fov);
    virtual void C_BasePlayer__SetLocalViewAngles(const QAngle &viewAngles);
    virtual void C_BasePlayer__SetViewAngles(const QAngle& ang);
    virtual bool C_BasePlayer__IsDucked(void);
    virtual bool C_BasePlayer__IsDucking(void);
    virtual float C_BasePlayer__GetFallVelocity(void);
    virtual CBaseEntity* C_BasePlayer__FindEntityClassForward(char* className);// Return C_BaseEntity*
    virtual CBaseEntity* C_BasePlayer__FindEntityForward(bool fHull);          // ^^
    virtual CBaseEntity* C_BasePlayer__FindPickerEntityClass(char* className); // ^^
    virtual CBaseEntity* C_BasePlayer__FindPickerEntity(void);                 // ^^
    virtual void C_BasePlayer__FindEntityInheritingFromForward(void* CSchemaClassBindingBase);
    virtual void C_DOTAPlayer__FindPickerEntityInheritingFrom(void* CSchemaClassBindingBase);
    virtual void C_DOTAPlayer__ProcessMouseclick(ButtonCode_t button, bool unk, bool unk2);
    /* Valve made this non-virtual jan 2020 :^) */
    //virtual void C_DotaPlayer__PrepareUnitOrders(DotaUnitOrder_t order, int entHandle, Vector movePosition, int abilityIndex,PlayerOrderIssuer_t orderIssuer, CDotaBaseNPC* entity, OrderQueueBehavior_t queueBehavior, bool showEffects);
    virtual void* C_DOTAPlayer__GetValidCursor(void);
    virtual bool C_DOTAPlayer__ShouldRegenerateOriginFromCellBits(void);
};
```

`src/SDK/CEngineServiceMgr.h`:

```h
#pragma once

#include "IAppSystem.h"

class ILoopModeFactory;
class IEngineService;
class ISwitchLoopModeStatusNotify;
class IAddonListChangeNotify;
class IPrerequisite;
struct ActiveLoop_t;
struct EventClientOutput_t;
struct RenderDeviceInfo_t;

// xref "Duplicate engine service named" to CEngineServiceMgr::RegisterEngineService()
class CEngineServiceMgr : IAppSystem
{
public:
    virtual void RegisterEngineService( const char *, IEngineService * ) = 0; // 11
    virtual void UnregisterEngineService( const char *, IEngineService * ) = 0;
    virtual void RegisterLoopMode( const char *, ILoopModeFactory *, void ** ) = 0;
    virtual void UnregisterLoopMode( const char *, ILoopModeFactory *, void ** ) = 0;
    virtual void SwitchToLoop( const char *, void *KeyValues, unsigned int, const char *, bool ) = 0;
    virtual const char *GetActiveLoopName( void ) = 0;
    virtual IEngineService *FindService( const char * ) = 0;
    virtual void *GetEngineWindow( void ) = 0;
    virtual void *GetEngineSwapChain( void ) = 0;
    virtual void *GetEngineInputContext( void ) = 0;
    virtual void *GetEngineDeviceInfo( void ) = 0;
    virtual void *GetEngineDeviceWidth( void ) = 0;
    virtual void *GetEngineDeviceHeight( void ) = 0;
    virtual void GetEngineSwapChainSize( int *width, int *height ) = 0;
    virtual void *Plat_GetWindowSafeAreaInsets( void ) = 0; // (NEW) added with 2019 TI battlepass
    virtual bool IsLoopSwitchQueued( void ) = 0;
    virtual bool IsLoopSwitchRequested( void ) = 0;
    virtual void *GetEventDispatcher( void ) = 0;
    virtual void *GetDebugVisualizerMgr( void ) = 0;
    virtual int GetActiveLoopClientServerMode( void ) = 0;
    virtual void PrintStatus( void ) = 0;
    virtual void GetActiveLoop( ActiveLoop_t & ) = 0;
    virtual bool IsLoadingLevel( void ) = 0;
    virtual bool IsInGameLoop( void ) = 0;
    virtual void OnFrameRenderingFinished( bool, EventClientOutput_t const & ) = 0;
    virtual void ChangeVideoMode( RenderDeviceInfo_t & ) = 0;
    virtual void GetVideoModeChange( void ) = 0;
    virtual int GetAddonCount( void ) = 0;
    virtual void *GetAddon( int ) = 0;
    virtual bool IsAddonMounted( const char * ) = 0;
    virtual const char *GetAddonsString( void ) = 0;
    virtual void InstallSwitchLoopModeStatusNotify( ISwitchLoopModeStatusNotify * ) = 0;
    virtual void UninstallSwitchLoopModeStatusNotify( ISwitchLoopModeStatusNotify * ) = 0;
    virtual void InstallAddonListChangeNotify( IAddonListChangeNotify * ) = 0;
    virtual void UninstallAddonListChangeNotify( IAddonListChangeNotify * ) = 0;
    virtual void StartEngineWatchDogThread() = 0; // (NEW) added jan 2020
    virtual void ExitMainLoop( void ) = 0;
    virtual void RegisterPrerequisite( IPrerequisite * ) = 0;
    virtual void *LookupLocalizationToken( const char * ) = 0;
    virtual void UnregisterPrerequisite( IPrerequisite * ) = 0;
};
```

`src/SDK/CFontManager.h`:

```h
#pragma once
#include "IAppSystem.h"

typedef unsigned long long HFont;

enum class FontFeature : int
{
    FONT_FEATURE_ANTIALIASED_FONTS = 1,
    FONT_FEATURE_DROPSHADOW_FONTS = 2,
    FONT_FEATURE_OUTLINE_FONTS = 6
};

enum class FontFlags : int
{
    FONTFLAG_NONE = 0,
    FONTFLAG_ITALIC = 0x1,
    FONTFLAG_UNDERLINE = 0x2,
    FONTFLAG_STRIKEOUT = 0x4,
    FONTFLAG_SYMBOL = 0x8,
    FONTFLAG_ANTIALIAS = 0x10,
    FONTFLAG_GAUSSIANBLUR = 0x20,
    FONTFLAG_ROTARY = 0x40,
    FONTFLAG_DROPSHADOW = 0x80,
    FONTFLAG_ADDITIVE = 0x100,
    FONTFLAG_OUTLINE = 0x200,
    FONTFLAG_CUSTOM = 0x400,
    FONTFLAG_BITMAP = 0x800,
};

enum class FontDrawType_t : int
{
    // Use the "additive" value from the scheme file
    FONT_DRAW_DEFAULT = 0,

    // Overrides
    FONT_DRAW_NONADDITIVE,
    FONT_DRAW_ADDITIVE,

    FONT_DRAW_TYPE_COUNT = 2,
};

// "DefaultFontAliasGroup" xref to the one that's by a bunch of `mov dword ptr [rax+xx], 0` - this is Init()
// or xref "Tag: %s \n" back to SpewFonts
class CFontManager : IAppSystem
{
public:
    virtual HFont CreateFont(void) = 0;
    virtual void ClearAllFonts(void) = 0;
    virtual void SetLanguage(const char *language) = 0;
    virtual const char* GetLanguage(void) = 0;
    virtual void RegisterCustomFont() = 0; // new function, a guess.
    virtual void FindFontAliasList(void *CUtlStringToken) = 0;
    virtual void RemoveFontAliasList(const char*) = 0;
    virtual void GetFontAliases(const char*) = 0;
    virtual void CreateFontAlias(const char*, const char*, bool) = 0;
    virtual HFont GetFont(const char* name, const char* unk, bool unk2) = 0;  // 20
    virtual void LoadFont(const char*, const char*, int, int, bool, int, int, int, int, int, const char*) = 0;
    virtual HFont FindFont(const char*, bool, const char*) = 0;
    virtual HFont FindOrLoadFont(const char*, const char*, int, int, bool, int, int, int, int, int, const char*) = 0;
    virtual void GetTrueFontName(void const * FontAlias_t) = 0;
    virtual void GetFontRange(const char*, int &, int &, const char*) = 0;
    virtual void SetFontRange(const char*, int, int, const char*) = 0;
    virtual bool SetFontGlyphSet(HFont, const char* windowsFontName, int size, int, int, int, int, int, int flags) = 0;
    virtual void GetFontName(HFont) = 0;
    virtual void GetFontTall(HFont) = 0;
    virtual void GetCharacterWidth(HFont, int) = 0;
    virtual void GetKernedCharWidth(HFont, wchar_t, wchar_t, wchar_t, float &, float &, float &) = 0;
    virtual void GetCharABCwide(HFont, int, int &, int &, int &) = 0;
    virtual void GetTextSize(HFont, const wchar_t*, int &, int &) = 0;
    virtual void GetTextureHandle(int) = 0;
    virtual void GetFontAscent(HFont, wchar_t) = 0;
    virtual void GetFontUnderlined(HFont) = 0;
    virtual bool IsFontAdditive(HFont) = 0;
    virtual void PrecacheFontCharacters(HFont, wchar_t *) = 0;
    virtual void ClearFontTextureCache(void) = 0;
    virtual void GetTextureForChar(HFont, int FontDrawType_t, wchar_t, int *, float **) = 0;
    virtual void ClearTemporaryFontCache(void) = 0;
    virtual void SpewFonts(const char *, float) = 0;
    virtual void DESTROY1() = 0;
    virtual void DESTROY2() = 0;
};

// disabled bitmap fonts with the Ti2019 battlepass
// some threading changes with Diretide 2020
```

`src/SDK/CGCClient.h`:

```h
#pragma once

// Game Coordinator Client
class CGCClient
{
public:

};
```

`src/SDK/CGameEntitySystem.h`:

```h
#pragma once

#include "CBaseEntity.h"

#define MAX_ENTITIES_IN_LIST 512
#define MAX_ENTITY_LISTS 64 // 0x3F
#define MAX_TOTAL_ENTITIES MAX_ENTITIES_IN_LIST * MAX_ENTITY_LISTS // 0x8000

#define LOWORD(a) ((uint16_t)(a))
#define HIWORD(a) ((uint16_t)(((uint32_t)(a) >> 16) & 0xFFFF))

inline uint32_t highestEntIndexOffset;

class CEntityIdentity {

public:
    CBaseEntity *entity;
    void *dunno;
    int entHandle; // LOWORD(handle) & 0x7FFF = entID
    int unk2; // always seems to be -1
    const char* internalName; // these two strings are optional!
    const char* entityName; // ex: item_tpscroll
    void *unkChunk[5];
    CEntityIdentity *prevValid;
    CEntityIdentity *nextValid;
    void *unkptr;
    void *unkptr2;
    void *unkptr3;
};

class CEntityIdentities
{
public:
    CEntityIdentity m_pIdentities[MAX_ENTITIES_IN_LIST];
};

class CGameEntitySystem
{
public:
    // rebuilt from CGameEntitySystem::GetBaseEntity()
    CBaseEntity* GetBaseEntity( int index )
    {
        if ( index <= -1 || index >= ( MAX_TOTAL_ENTITIES - 1 ) )
            return nullptr;

        CEntityIdentities *chunkToUse = m_pIdentityChunks[(index / MAX_ENTITIES_IN_LIST)]; // equal to ( index >> 9 )

        if( !chunkToUse )
            return nullptr;

        CEntityIdentity *identity = &chunkToUse->m_pIdentities[ index % MAX_ENTITIES_IN_LIST ]; // equal to ( index & 1FF )

        if( !identity )
            return nullptr;

        // This is an extra check in the official implementation that I am omitting for speed
        //if( (LOWORD( identity->entHandle ) & 0x7FFF) == index ){
        //    return identity->entity;
        //}

        return identity->entity;
    }

    unsigned int GetEntHandle( int index )
    {
        if ( index <= -1 || index >= ( MAX_TOTAL_ENTITIES - 1 ) )
            return -1;

        CEntityIdentities *chunkToUse = m_pIdentityChunks[(index / MAX_ENTITIES_IN_LIST)]; // equal to ( index >> 9 )

        if( !chunkToUse )
            return -1;

        CEntityIdentity *identity = &chunkToUse->m_pIdentities[ index % MAX_ENTITIES_IN_LIST ]; // equal to ( index & 1FF )

        if( !identity )
            return -1;

        return identity->entHandle;
    }

    int GetHighestEntityIndex()
    {
        return *(int*)((uintptr_t)this + highestEntIndexOffset);
    }

    void* unk;
    void* unk2;
    CEntityIdentities* m_pIdentityChunks[MAX_ENTITY_LISTS];
};
```

`src/SDK/CGameEventManager.h`:

```h
#pragma once

enum class GameState : int
{
    DOTA_GAMERULES_STATE_INIT = 0,
    DOTA_GAMERULES_WAIT_FOR_PLAYERS_TO_LOAD,
    DOTA_GAMERULES_HERO_SELECTION,
    DOTA_GAMERULES_STRATEGY_TIME,
    DOTA_GAMERULES_PREGAME,
    DOTA_GAMERULES_GAME_IN_PROGRESS,
    DOTA_GAMERULES_POSTGAME,
    DOTA_GAMERULES_DISCONNECT,
    DOTA_GAMERULES_TEAM_SHOWCASE,
    DOTA_GAMERULES_CUSTOM_GAME_SETUP,
    DOTA_GAMERULES_WAIT_FOR_MAP_TO_LOAD
};

// xref "splitscreenplayer" to some function, double click `off_xxxxxxxx` to get to vtable
class CGameEvent
{
public:
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;

    virtual const char* GetName( void ) = 0;
    virtual int GetID( void ) = 0;

    virtual bool IsReliable( void ) = 0;
    virtual bool IsLocal( void ) = 0;
    virtual bool IsEmpty( char const* keyname = nullptr ) = 0;

    virtual bool GetBool( char const* keyname = nullptr, bool defaultValue = false ) = 0;
    virtual int GetInt( char const* keyname = nullptr, int defaultValue = 0 ) = 0;
    virtual uint64_t GetUint64( char const* keyname = nullptr, uint64_t DefaultValue = 0 ) = 0;
    virtual float GetFloat( char const* keyname = nullptr, float defaultValue = 0.0f ) = 0;
    virtual const char* GetString( char const* keyname = nullptr, char const* defaultValue = nullptr ) = 0;
    virtual const void* GetPtr( char const* keyname = nullptr ) = 0;

    virtual void SetBool( char const* keyname, bool value ) = 0;
    virtual void SetInt( char const* keyname, int value ) = 0;
    virtual void SetUint64( char const* keyname, uint64_t value ) = 0;
    virtual void SetFloat( char const* keyname, float value ) = 0;
    virtual void SetString( char const* keyname, char const* value ) = 0;
    virtual void SetPtr( char const* keyname, void const* value ) = 0;

    virtual void* GetDataKeys( void ) = 0;
};

class CGameEventListener2
{
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;

    virtual void FireGameEvent( CGameEvent* event ) = 0;
};

// xref "CGameEventManager::AddListener" to AddListener()
class CGameEventManager
{
public:
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;
    virtual int LoadEventsFromFile( const char *filename ) = 0;
    virtual void Reset(void) = 0;
    virtual bool AddListener( CGameEventListener2 *listener, const char *eventName, bool serverSide ) = 0;
    virtual bool FindListener( CGameEventListener2 *listener, const char *eventName ) = 0;
    virtual void RemoveListener( CGameEventListener2 *listener ) = 0;
    virtual CGameEvent* CreateEvent( const char* name, bool force = false, int *cookie = nullptr ) = 0;
    virtual bool FireEvent( CGameEvent *event, bool dontBroadcast ) = 0;
    virtual bool FireEventClientSide( CGameEvent *event ) = 0;
    virtual CGameEvent* DuplicateEvent( CGameEvent *event ) = 0;
    virtual void FreeEvent( CGameEvent *event ) = 0;
    virtual bool SerializeEvent( CGameEvent *event, void *Source1LegacyGameEvent ) = 0;
    virtual CGameEvent* UnserializeEvent( void const *Source1LegacyGameEvent ) = 0;
    virtual bool LookupEventId( const char *id ) = 0;
    virtual void sub_2C16A80() = 0;
    virtual void sub_2C69980() = 0;
};
```

`src/SDK/CGameEventSystem.h`:

```h
#pragma once
#include "IAppSystem.h"
#include "Valve/tier1/utldelegateimpl.h"
#include "INetChannel.h"

struct CUtlSlot;
struct IRecipientFilter;

// xref "Attempted to post a message to a NULL" to CGameEventSystem::PostEntityEventAbstract
class CGameEventSystem : IAppSystem
{
public:
    virtual void RegisterGameEvent( GameEventHandle_t * ); // 11
    virtual void RegisterGameEventHandlerAbstract(CUtlSlot *,CUtlAbstractDelegate const&,GameEventHandle_t *,int);
    virtual void UnregisterGameEventHandlerAbstract(CUtlSlot *,CUtlAbstractDelegate const&,GameEventHandle_t *);
    virtual void PostEventAbstract_Local(int splitScreenSlot,GameEventHandle_t *,void const*,unsigned long);
    virtual void PostEventAbstract(int splitScreenSlot,bool,int,unsigned char const*,GameEventHandle_t *,void const*,unsigned long,NetChannelBufType_t);
    virtual void PostEventAbstract(int splitScreenSlot,bool,IRecipientFilter *,GameEventHandle_t *,void const*,unsigned long);
    virtual void PostEntityEventAbstract(const int& CEntityHandle,GameEventHandle_t *,void const*,unsigned long,NetChannelBufType_t);
    virtual void ProcessQueuedEvents(void);
    virtual void GetEventSource(void);
    virtual void PurgeQueuedEvents(void);
};
```

`src/SDK/CGlobalVars.h`:

```h
#pragma once
class CGlobalVars
{
public:
	float realtime; //0x0000
	int32_t framecount; //0x0004
	float absoluteFrametime; //0x0008
	float curtime; //0x000C
	float frametime; //0x0010
	int32_t maxClients; //0x0014
	int32_t tickcount; //0x0018
	float intervalPerTick; //0x001C
	float unk; //0x0020
	float interpAmount; //0x0024
	char pad_0028[4]; //0x0028
	bool somebool; //0x002C
	bool somebool2; //0x002D
	char pad_0030[362]; //0x0030
	char* currentMap; //0x0198
	char* currentMapName; //0x01A0
};
```

`src/SDK/CNetworkGameClient.h`:

```h
#pragma once

#include "INetChannel.h"

struct EventClientSimulate_t;
struct EventClientPollNetworking_t;
struct EventClientProcessNetworking_t;
struct EventClientSendInput_t;
struct EventClientProcessGameInput_t;
struct EventClientFrameSimulate_t;
struct EventClientAdvanceTick_t;
struct EventClientPostAdvanceTick_t;
struct EventClientOutput_t;
struct InputCommandSource_t;
struct CCommand;
struct AudioState_t;
struct C2S_CONNECT_Message_t;
struct HGameResourceManifest;
class CClientChangeLevelState;
class CCallQueue;

//Net Messages
struct CNETMsg_Tick_t;
struct CNETMsg_StringCmd_t;
struct CNETMsg_SetConVar_t;
struct CNETMsg_SignonState_t;
struct CNETMsg_SpawnGroup_Load_t;
struct CNETMsg_SpawnGroup_ManifestUpdate_t;
struct CNETMsg_SpawnGroup_Unload_t;
struct CNETMsg_SpawnGroup_SetCreationTick_t;
struct CSVCMsg_VoiceInit_t;
struct CSVCMsg_VoiceData_t;
struct CSVCMsg_ServerInfo_t;
struct CSVCMsg_ClassInfo_t;
struct CSVCMsg_FlattenedSerializer_t;
struct CSVCMsg_Menu_t;
struct CSVCMsg_GetCvarValue_t;
struct CSVCMsg_SetPause_t;
struct CSVCMsg_ClearAllStringTables_t;
struct CSVCMsg_CreateStringTable_t;
struct CSVCMsg_UpdateStringTable_t;
struct CSVCMsg_SetView_t;
struct CSVCMsg_PacketEntities_t;
struct CSVCMsg_SplitScreen_t;
struct CSVCMsg_CmdKeyValues_t;
struct CSVCMsg_Sounds_t;
struct CSVCMsg_BSPDecal_t;
struct CSVCMsg_Prefetch_t;
struct CSVCMsg_PacketReliable_t;
struct CSVCMsg_FullFrameSplit_t;
struct CSVCMsg_HLTVStatus_t;

struct NetMessageConnectionClosed_t;
struct NetMessageConnectionCrashed_t;
struct NetMessageSplitscreenUserChanged_t;
struct NetMessagePacketStart_t;
struct NetMessagePacketEnd_t;


// (libengine2)
// xref "Connection lost" to ProcessConnectionCrashed()
// or "CNetworkGameClientBase::FullConnect" to FullConnect()
class CNetworkGameClient // AKA: CNetworkGameClientBase
{
public:
    virtual void Init(void) = 0;
    virtual void SetGameSpawnGroupMgr(void *IGameSpawnGroupMgr) = 0;
    virtual void AddRef(void) = 0;
    virtual void Release(void) = 0;
    virtual void* GetGlobals(void) = 0;
    virtual int GetClientTickCount(void) = 0;
    virtual int GetServerTickCount(void) = 0;
    virtual void SetFrameTime(float value) = 0;
    virtual void SetTickRemainder(float value) = 0;
    virtual void ApplyClockDrift(int, int) = 0;
    virtual void Connect(int splitScreenslot, int unk, void const * ns_address) = 0;
    virtual void DisconnectGame(int ENetworkDisconnectionReason) = 0;
    virtual bool IsActive(void) = 0;
    virtual bool IsConnected(void) = 0;
    virtual bool IsConnecting(void) = 0;
    virtual bool IsPaused(void) = 0;
    virtual bool IsSomething(void) = 0; // added Dec 2018
    virtual bool IsInGame(void) = 0;
    virtual bool IsBackgroundMap(void) = 0;
    virtual int GetMaxClients(void) = 0;
    virtual void* GetPrerequisiteStatus(void) = 0;
    virtual void ClientPollNetworking(EventClientPollNetworking_t const&) = 0;
    virtual void ClientProcessNetworking(EventClientProcessNetworking_t const&) = 0;
    virtual void OnClientSendInput(EventClientSendInput_t const&) = 0;
    virtual void OnClientProcessGameInput(EventClientProcessGameInput_t const&) = 0;
    virtual void sub_356C10() = 0; // Added with Nemestice update (empty func)
    virtual void OnClientFrameSimulate(EventClientFrameSimulate_t const&) = 0;
    virtual void OnClientAdvanceTick(EventClientAdvanceTick_t const&) = 0;
    virtual void OnClientPostAdvanceTick(EventClientPostAdvanceTick_t const&) = 0;
    virtual void OnClientOutput(EventClientOutput_t const&) = 0;
    virtual void RequestServerStatus(int splitScreenSlot) = 0;
    virtual void ForceFullUpdate(const char *reasonIThink) = 0;
    virtual void PrintSpawnGroupStatus(void) = 0;
    virtual void GetCameraPosition(int splitScreenSlot, void *CTransform) = 0;
    virtual int GetLocalPlayer(int splitScreenSlot) = 0;
    virtual void ServerCmd(InputCommandSource_t, const char* cmd) = 0;
    virtual void ServerCmd(InputCommandSource_t, CCommand const&) = 0;
    virtual void SendStringCmd(int splitScreenSlot, const char* cmd) = 0;
    virtual void SplitScreenConnect(int splitScreenSlot) = 0;
    virtual int GetMaxSplitScreenPlayers(void) = 0;
    virtual void* GetViewEntity(void) = 0;
    virtual INetChannel* GetNetChannel(int splitScreenSlot) = 0;
    virtual void UpdateAudioState(AudioState_t *, int splitScreenSlot) = 0;
    virtual void ClockDrift_AdjustFrameTime(float) = 0;
    virtual float GetTickInterval(void) = 0;
    virtual void ComputeNextRenderTime(float) = 0;
    virtual void ReencodeForVConsole(int entIndex) = 0;
    virtual void PrepareSteamConnectResponse(unsigned long long, bool, void const * ns_address, C2S_CONNECT_Message_t &) = 0;
    virtual bool IsLowViolence(void) = 0;
    virtual void* GetHostVersion(void) = 0;
    virtual float GetLastTimestamp(void) = 0;
    virtual int GetLastServerTick(void) = 0;
    virtual void SetGameSessionManifest(HGameResourceManifest *, HGameResourceManifest *) = 0;
    virtual void SpewSerializer(const char *) = 0;
    virtual void EntityClassCompletion();//char const*,CUtlVector<CUtlString,CUtlMemory<CUtlString,int>> &)
    virtual void ConsistencyCheck(bool) = 0;
    virtual bool IsSpawnGroupAsyncLoaded(unsigned int) = 0;
    virtual void* GetWorldSession(void) = 0;
    virtual const char*  GetSpawnGroupName(unsigned int) = 0;
    virtual void StartChangeLevel(void) = 0;
    virtual void FinishChangeLevel(CClientChangeLevelState *) = 0; // "CNetworkGameClientBase::FinishChan"
    virtual bool IsChangeLevelPending(void) = 0;
    virtual void GetAllLoadingSpawnGroups();//(CUtlVector<uint,CUtlMemory<uint,int>> *)
    virtual void ProcessConnectionlessPacket(void *a2) = 0; //virtual void ProcessConnectionlessPacket(void const * ns_address, void * bf_read) = 0;
    virtual void BlockDisconnectionTracking(bool) = 0;
    virtual void TransmitNetChannel() = 0; // "CL:  TransmitNetChannel"
    virtual void* sub_35CBD0() = 0; // lea     rax, [rdi+244h]
    virtual void sub_37A6A0(float arg) = 0;
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;
    virtual bool sub_35C5C0() = 0; // Added with Nemestice update
    virtual void FilterMessage(NetMessageHandle_t *, void const *) = 0;
    virtual void OnShutdownChannel(INetChannel const *, bool) = 0;
    virtual void OnGameEventReceived(NetMessageHandle_t *, NetMessageInfo_t const *, void const *) = 0;
    virtual void sub_5BBB50() = 0;
    virtual void sub_5BBE40() = 0;
    virtual void sub_5C24E0() = 0;
    virtual void ProcessTick(CNETMsg_Tick_t const&) = 0;
    virtual void ProcessStringCmd(CNETMsg_StringCmd_t const&) = 0;
    virtual void ProcessSetConVar(CNETMsg_SetConVar_t const&) = 0;
    virtual void ProcessSignonState(CNETMsg_SignonState_t const&) = 0;
    virtual void ProcessSpawnGroupLoad(CNETMsg_SpawnGroup_Load_t const &) = 0;
    virtual void ProcessSpawnGroup_ManifestUpdate(CNETMsg_SpawnGroup_ManifestUpdate_t const &) = 0;
    virtual void ProcessSpawnGroup_Unload(CNETMsg_SpawnGroup_Unload_t const &) = 0;
    virtual void ProcessSpawnGroup_SetCreationTick(CNETMsg_SpawnGroup_SetCreationTick_t const &) = 0;
    virtual void sub_5A68F0() = 0;
    virtual void ProcessVoiceInit(CSVCMsg_VoiceInit_t const &) = 0;
    virtual void ProcessVoiceData(CSVCMsg_VoiceData_t const &) = 0;
    virtual void sub_5A8180() = 0;
    virtual void ProcessServerInfo(CSVCMsg_ServerInfo_t const &) = 0;
    virtual void ProcessClassInfo(CSVCMsg_ClassInfo_t const &) = 0;
    virtual void ProcessFlattenedSerializer(CSVCMsg_FlattenedSerializer_t const &) = 0;
    virtual void ProcessMenu(CSVCMsg_Menu_t const &) = 0;
    virtual void ProcessGetCvarValue(CSVCMsg_GetCvarValue_t const &) = 0;
    virtual void ProcessSetPause(CSVCMsg_SetPause_t const &) = 0;
    virtual void ProcessClearAllStringTables(CSVCMsg_ClearAllStringTables_t const &) = 0;
    virtual void ProcessCreateStringTable(CSVCMsg_CreateStringTable_t const &) = 0;
    virtual void ProcessUpdateStringTable(CSVCMsg_UpdateStringTable_t const &) = 0;
    virtual void ProcessSetView(CSVCMsg_SetView_t const &) = 0;
    virtual void ProcessPacketEntities(CSVCMsg_PacketEntities_t const &) = 0;
    virtual void ProcessSplitScreen(CSVCMsg_SplitScreen_t const &) = 0;
    virtual void ProcessCmdKeyValues(CSVCMsg_CmdKeyValues_t const &) = 0;
    virtual int sub_356310() = 0; // added with dota-anime - CUtlBuffer::Put() x3
    virtual void ProcessSounds(CSVCMsg_Sounds_t const &) = 0;
    //virtual void ProcessBSPDecal(CSVCMsg_BSPDecal_t const &) = 0; //
    virtual void ProcessPrefetch(CSVCMsg_Prefetch_t const &) = 0;   // this function is either Prefetch or the above BSPDecal. 50/50
    virtual void sub_5A5D50() = 0;
    virtual void ProcessPacketReliable(CSVCMsg_PacketReliable_t const &) = 0;
    virtual void ProcessFullFrameSplit(CSVCMsg_FullFrameSplit_t const &) = 0;
    virtual void ProcessHLTVStatus(CSVCMsg_HLTVStatus_t const &) = 0;
    virtual void sub_5A6180() = 0;
    virtual void ProcessConnectionClosed(NetMessageConnectionClosed_t const &) = 0;
    virtual void ProcessConnectionCrashed(NetMessageConnectionCrashed_t const &) = 0;
    virtual void ProcessChangeSplitScreenUser(NetMessageSplitscreenUserChanged_t const &) = 0;
    virtual void ProcessPacketStart(NetMessagePacketStart_t const &) = 0;
    virtual void ProcessPacketEnd(NetMessagePacketEnd_t const &) = 0;
    virtual void sub_361A00() = 0; // Added with Road2TI10
    virtual void Clear(bool) = 0;
    virtual void FullConnect(void const * ns_address) = 0;
    virtual void SetSignonState(SignonState_t, int, CNETMsg_SignonState_t const *) = 0;
    virtual void RunFrame(void) = 0;
    virtual void InstallStringTableCallback(const char *tableName) = 0;
    virtual void HookClientStringTable(const char *) = 0;
    virtual void GetClientName(int splitScreenSlot) = 0;
    virtual void loc_348070() = 0; //something to do with eventdispatcher
    virtual void OnPreserveEntity(void * CEntityReadInfo) = 0;
    virtual void CopyNewEntity(void *IEntityReport, void *CEntityReadInfo, void *ClientClass, int, unsigned int) = 0;
    virtual void CopyExistingEntity(void *IEntityReport, void *CEntityReadInfo) = 0;
    virtual void CL_ClearState(bool) = 0;
    virtual void OnSwitchLoopModeFinished(const char*, unsigned int, bool) = 0;

    int32_t *GetLocalDOTAPlayerID() {
        return (int32_t*)((uintptr_t)this + 0xAC);
    }
};
```

`src/SDK/CNetworkMessages.h`:

```h
#pragma once

#include "bf_read.h"
#include "bf_write.h"
#include "CUtlString.h"

#include <google/protobuf/message.h>
#include <google/protobuf/io/coded_stream.h>

#define CASE_STRING( x ) case static_cast<int>( x ) : return #x

struct NetMessageInfo_t;

enum NetChannelBufType_t : int
{
    BUF_DEFAULT = -1,
    BUF_UNRELIABLE = 0,
    BUF_RELIABLE = 1,
    BUF_VOICE = 2,
};

enum class SignonState_t : uint32_t {
    SIGNONSTATE_NONE = 0,
    SIGNONSTATE_CHALLENGE = 1,
    SIGNONSTATE_CONNECTED = 2,
    SIGNONSTATE_NEW = 3,
    SIGNONSTATE_PRESPAWN = 4,
    SIGNONSTATE_SPAWN = 5,
    SIGNONSTATE_FULL = 6,
    SIGNONSTATE_CHANGELEVEL = 7,
};

enum class NetMessageTypes : short
{
    CNETMsg_NOP = 0,
    CNETMsg_Disconnect = 1,
    CNETMsg_SplitScreenUser = 3,
    CNETMsg_Tick = 4,
    CNETMsg_StringCmd = 5,
    CNETMsg_SetConVar = 6,
    CNETMsg_SignonState = 7,
    CNETMsg_SpawnGroup_Load = 8,
    CNETMsg_SpawnGroup_ManifestUpdate = 9,
    CNETMsg_SpawnGroup_SetCreationTick = 11,
    CNETMsg_SpawnGroup_Unload = 12,
    CNETMsg_SpawnGroup_LoadCompleted = 13,
    CBidirMsg_RebroadcastGameEvent = 16,
    CBidirMsg_RebroadcastSource = 17,
    CCLCMsg_ClientInfo = 20,
    CCLCMsg_Move = 21,
    CCLCMsg_VoiceData = 22,
    CCLCMsg_BaselineAck = 23,
    CCLCMsg_RespondCvarValue = 25,
    CCLCMsg_FileCRCCheck = 26,
    CCLCMsg_LoadingProgress = 27,
    CCLCMsg_SplitPlayerConnect = 28,
    CCLCMsg_SplitPlayerDisconnect = 30,
    CCLCMsg_ServerStatus = 31,
    CCLCMsg_ServerPing = 32,
    CCLCMsg_RequestPause = 33,
    CCLCMsg_CmdKeyValues = 34,
    CSVCMsg_ServerInfo = 40,
    CSVCMsg_FlattenedSerializer = 41,
    CSVCMsg_ClassInfo = 42,
    CSVCMsg_SetPause = 43,
    CSVCMsg_CreateStringTable = 44,
    CSVCMsg_UpdateStringTable = 45,
    CSVCMsg_VoiceInit = 46,
    CSVCMsg_VoiceData = 47,
    CSVCMsg_Print = 48,
    CSVCMsg_Sounds = 49,
    CSVCMsg_SetView = 50,
    CSVCMsg_ClearAllStringTables = 51,
    CSVCMsg_CmdKeyValues = 52,
    CSVCMsg_BSPDecal = 53,
    CSVCMsg_SplitScreen = 54,
    CSVCMsg_PacketEntities = 55,
    CSVCMsg_Prefetch = 56,
    CSVCMsg_Menu = 57,
    CSVCMsg_GetCvarValue = 58,
    CSVCMsg_StopSound = 59,
    CSVCMsg_PeerList = 60,
    CSVCMsg_PacketReliable = 61,
    CSVCMsg_HLTVStatus = 62,
    CSVCMsg_ServerSteamID = 63,
    CSVCMsg_FullFrameSplit = 70,
    CUserMessageAchievementEvent = 101,
    CUserMessageCloseCaption = 102,
    CUserMessageCloseCaptionDirect = 103,
    CUserMessageCurrentTimescale = 104,
    CUserMessageDesiredTimescale = 105,
    CUserMessageFade = 106,
    CUserMessageGameTitle = 107,
    CUserMessageHintText = 109,
    CUserMessageHudMsg = 110,
    CUserMessageHudText = 111,
    CUserMessageKeyHintText = 112,
    CUserMessageColoredText = 113,
    CUserMessageRequestState = 114,
    CUserMessageResetHUD = 115,
    CUserMessageRumble = 116,
    CUserMessageSayText = 117,
    CUserMessageSayText2 = 118,
    CUserMessageSayTextChannel = 119,
    CUserMessageShake = 120,
    CUserMessageShakeDir = 121,
    CUserMessageTextMsg = 124,
    CUserMessageScreenTilt = 125,
    CUserMessageTrain = 126,
    CUserMessageVGUIMenu = 127,
    CUserMessageVoiceMask = 128,
    CUserMessageVoiceSubtitle = 129,
    CUserMessageSendAudio = 130,
    CUserMessageItemPickup = 131,
    CUserMessageAmmoDenied = 132,
    CUserMessageCrosshairAngle = 133,
    CUserMessageShowMenu = 134,
    CUserMessageCreditsMsg = 135,
    CEntityMessagePlayJingle = 136,
    CEntityMessageScreenOverlay = 137,
    CEntityMessageRemoveAllDecals = 138,
    CEntityMessagePropagateForce = 139,
    CEntityMessageDoSpark = 140,
    CEntityMessageFixAngle = 141,
    CUserMessageCloseCaptionPlaceholder = 142,
    CUserMessageCameraTransition = 143,
    CUserMessageAudioParameter = 144,
    CUserMsg_ParticleManager = 145,
    CUserMsg_HudError = 146,
    CUserMsg_CustomGameEvent = 148,
    CUserMessageHapticPulse = 149,
    CUserMessageHapticPulsePrecise = 151,
    CMsgPlaceDecalEvent = 201,
    CMsgClearWorldDecalsEvent = 202,
    CMsgClearEntityDecalsEvent = 203,
    CMsgClearDecalsForSkeletonInstanceEvent = 204,
    CMsgSource1LegacyGameEventList = 205,
    CMsgSource1LegacyListenEvents = 206,
    CMsgSource1LegacyGameEvent = 207,
    CMsgSosStartSoundEvent = 208,
    CMsgSosStopSoundEvent = 209,
    CMsgSosSetSoundEventParams = 210,
    CMsgSosSetLibraryStackFields = 211,
    CMsgSosStopSoundEventHash = 212,
    CP2P_TextMessage = 256,
    CP2P_Voice = 257,
    CP2P_Ping = 258,
    CP2P_VRAvatarPosition = 259,
    CP2P_WatchSynchronization = 260,
    CClientMsg_CustomGameEvent = 280,
    CClientMsg_CustomGameEventBounce = 281,
    CClientMsg_ClientUIEvent = 282,
    CClientMsg_RotateAnchor = 285,
    CDOTAClientMsg_MapLine = 301,
    CDOTAClientMsg_AspectRatio = 302,
    CDOTAClientMsg_MapPing = 303,
    CDOTAClientMsg_UnitsAutoAttackMode = 304,
    CDOTAClientMsg_SearchString = 307,
    CDOTAClientMsg_Pause = 308,
    CDOTAClientMsg_ShopViewMode = 309,
    CDOTAClientMsg_SetUnitShareFlag = 310,  // needs more testing
    CDOTAClientMsg_SwapRequest = 311,
    CDOTAClientMsg_SwapAccept = 312,
    CDOTAClientMsg_WorldLine = 313,
    CDOTAClientMsg_RequestGraphUpdate = 314,
    CDOTAClientMsg_ItemAlert = 315,
    CDOTAClientMsg_ChatWheel = 316,
    CDOTAClientMsg_SendStatPopup = 317, // the messages sent by those in the casting slot
    CDOTAClientMsg_BeginLastHitChallenge = 318,
    CDOTAClientMsg_UpdateQuickBuy = 319,
    CDOTAClientMsg_UpdateCoachListen = 320,
    CDOTAClientMsg_CoachHUDPing = 321,
    CDOTAClientMsg_RecordVote = 322,
    CDOTAClientMSg_UnitsAutoAttackAfterSpell = 323,
    CDOTAClientMsg_WillPurchaseAlert = 324,
    CDOTAClientMsg_PlayerShowCase = 325,
    CDOTAClientMsg_TeleportRequiresHalt = 326,
    CDOTAClientMsg_CameraZoomAmount = 327,
    CDOTAClientMsg_BroadcasterUsingCameraman = 328,
    CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator = 329,
    CDOTAClientMsg_EnemyItemAlert = 330,
    CDOTAClientMsg_FreeInventory = 331,
    CDOTAClientMsg_BuyBackStateAlert = 332,
    CDOTAClientMsg_QuickBuyAlert = 333,
    CDOTAClientMsg_HeroStatueLike = 334,
    CDOTAClientMsg_ModifierAlert = 335,
    CDOTAClientMsg_TeamShowcaseEditor = 336,
    CDOTAClientMsg_HPManaAlert = 337,
    CDOTAClientMsg_GlyphAlert = 338,
    CDOTAClientMsg_TeamShowcaseClientData = 339,
    CDOTAClientMsg_PlayTeamShowcase = 340,
    CDOTAClientMsg_EventCNY2015Cmd = 341,
    CDOTAClientMsg_FillEmptySlotsWithBots = 342,
    CDOTAClientMsg_DemoHero = 343,
    CDOTAClientMsg_AbilityLearnModeToggled = 344,
    CDOTAClientMsg_AbilityStartUse = 345,
    CDOTAClientMsg_ChallengeSelect = 346,
    CDOTAClientMsg_ChallengeReroll = 347,
    CDOTAClientMsg_ClickedBuff = 348,
    CDOTAClientMsg_CoinWager = 349,
    CDOTAClientMsg_ExecuteOrders = 350,
    CDOTAClientMsg_XPAlert = 351,
    CDOTAClientMsg_EventPointsTip = 353,
    CDOTAClientMsg_MatchMetadata = 354,
    CDOTAClientMsg_KillMyHero = 355,
    CDOTAClientMsg_QuestStatus = 356,
    CDOTAClientMsg_ToggleAutoattack = 357,
    CDOTAClientMsg_SpecialAbility = 358,
    CDOTAClientMsg_KillcamDamageTaken = 359,
    CDOTAClientMsg_SetEnemyStartingPosition = 360,
    CDOTAClientMsg_SetDesiredWardPlacement = 361,
    CDOTAClientMsg_RollDice = 362,
    CDOTAClientMsg_FlipCoin = 363,
    CDOTAClientMsg_RequestItemSuggestions = 364,
    CDOTAClientMsg_MakeTeamCaptain = 365,
    CDOTAClientMsg_CoinWagerToken = 366,
    CDOTAClientMsg_RankWager = 367,
    CDOTAClientMsg_DismissAllStatPopups = 368,
    CDOTAClientMsg_HelpTipSystemStateChanged = 369,
    CDOTAClientMsg_ChannelRequiresHalt = 370,
    CDOTAClientMsg_RequestBulkCombatLog = 371,
    CDOTAClientMsg_AbilityDraftRequestAbility = 372,
    CDOTAClientMsg_GuideSelectOption = 373,
    CDOTAClientMsg_GuideSelected = 374,
    CDOTAClientMsg_DamageReport = 375,
    CDOTAClientMsg_SalutePlayer = 376,
    CDOTAClientMsg_SprayWheel = 377,
    CDOTAClientMsg_TipAlert = 378, // https://github.com/SteamDatabase/GameTracking-Dota2/blob/3e4fc846f4a99669a9bdd045f23698991b5ab529/game/dota/pak01_dir/scripts/tips.txt
    CDOTAClientMsg_EmptyTeleportAlert = 379,
    CMsgTEEffectDispatch = 400,
    CMsgTEArmorRicochet = 401,
    CMsgTEBeamEntPoint = 402,
    CMsgTEBeamEnts = 403,
    CMsgTEBeamPoints = 404,
    CMsgTEBeamRing = 405,
    CMsgTEBSPDecal = 407,
    CMsgTEBubbles = 408,
    CMsgTEBubbleTrail = 409,
    CMsgTEDecal = 410,
    CMsgTEWorldDecal = 411,
    CMsgTEEnergySplash = 412,
    CMsgTEFizz = 413,
    CMsgTEShatterSurface = 414,
    CMsgTEGlowSprite = 415,
    CMsgTEImpact = 416,
    CMsgTEMuzzleFlash = 417,
    CMsgTEBloodStream = 418,
    CMsgTEExplosion = 419,
    CMsgTEDust = 420,
    CMsgTELargeFunnel = 421,
    CMsgTESparks = 422,
    CMsgTEPhysicsProp = 423,
    CMsgTEPlayerDecal = 424,
    CMsgTEProjectedDecal = 425,
    CMsgTESmoke = 426,
    CDOTAUserMsg_AIDebugLine = 465,
    CDOTAUserMsg_ChatEvent = 466,
    CDOTAUserMsg_CombatHeroPositions = 467,
    CMsgDOTACombatLogEntry = 468,
    CDOTAUserMsg_CombatLogBulkData = 470,
    CDOTAUserMsg_CreateLinearProjectile = 471,
    CDOTAUserMsg_DestroyLinearProjectile = 472,
    CDOTAUserMsg_DodgeTrackingProjectiles = 473,
    CDOTAUserMsg_GlobalLightColor = 474,
    CDOTAUserMsg_GlobalLightDirection = 475,
    CDOTAUserMsg_InvalidCommand = 476,
    CDOTAUserMsg_LocationPing = 477,
    CDOTAUserMsg_MapLine = 478,
    CDOTAUserMsg_MiniKillCamInfo = 479,
    CDOTAUserMsg_MinimapDebugPoint = 480,
    CDOTAUserMsg_MinimapEvent = 481,
    CDOTAUserMsg_NevermoreRequiem = 482,
    CDOTAUserMsg_OverheadEvent = 483,
    CDOTAUserMsg_SetNextAutobuyItem = 484,
    CDOTAUserMsg_SharedCooldown = 485,
    CDOTAUserMsg_SpectatorPlayerClick = 486,
    CDOTAUserMsg_TutorialTipInfo = 487,
    CDOTAUserMsg_UnitEvent = 488,
    CUserMsg_ParticleManager2 = 489,
    CDOTAUserMsg_BotChat = 490,
    CDOTAUserMsg_HudError = 491,
    CDOTAUserMsg_ItemPurchased = 492,
    CDOTAUserMsg_Ping = 493,
    CDOTAUserMsg_ItemFound = 494,
    CDOTAUserMsg_SwapVerify = 496,
    CDOTAUserMsg_WorldLine = 497,
    CDOTAUserMsg_ItemAlert = 499,
    CDOTAUserMsg_HalloweenDrops = 500,
    CDOTAUserMsg_ChatWheel = 501,
    CDOTAUserMsg_ReceivedXmasGift = 502,
    CDOTAUserMsg_UpdateSharedContent = 503,
    CDOTAUserMsg_TutorialRequestExp = 504,
    CDOTAUserMsg_TutorialPingMinimap = 505,
    CDOTAUserMsg_GamerulesStateChanged = 506,
    CDOTAUserMsg_ShowSurvey = 507,
    CDOTAUserMsg_TutorialFade = 508,
    CDOTAUserMsg_AddQuestLogEntry = 509,
    CDOTAUserMsg_SendStatPopup = 510,
    CDOTAUserMsg_TutorialFinish = 511,
    CDOTAUserMsg_SendRoshanPopup = 512,
    CDOTAUserMsg_SendGenericToolTip = 513,
    CDOTAUserMsg_SendFinalGold = 514,
    CDOTAUserMsg_CustomMsg = 515,
    CDOTAUserMsg_CoachHUDPing = 516,
    CDOTAUserMsg_ClientLoadGridNav = 517,
    CDOTAUserMsg_TE_Projectile = 518,
    CDOTAUserMsg_TE_ProjectileLoc = 519,
    CDOTAUserMsg_TE_DotaBloodImpact = 520,
    CDOTAUserMsg_TE_UnitAnimation = 521,
    CDOTAUserMsg_TE_UnitAnimationEnd = 522,
    CDOTAUserMsg_AbilityPing = 523,
    CDOTAUserMsg_ShowGenericPopup = 524,
    CDOTAUserMsg_VoteStart = 525,
    CDOTAUserMsg_VoteUpdate = 526,
    CDOTAUserMsg_VoteEnd = 527,
    CDOTAUserMsg_BoosterState = 528,
    CDOTAUserMsg_WillPurchaseAlert = 529,
    CDOTAUserMsg_TutorialMinimapPosition = 530,
    CDOTAUserMsg_PlayerMMR = 531,
    CDOTAUserMsg_AbilitySteal = 532,
    CDOTAUserMsg_CourierKilledAlert = 533,
    CDOTAUserMsg_EnemyItemAlert = 534,
    CDOTAUserMsg_StatsMatchDetails = 535,
    CDOTAUserMsg_MiniTaunt = 536,
    CDOTAUserMsg_BuyBackStateAlert = 537,
    CDOTAUserMsg_SpeechBubble = 538,
    CDOTAUserMsg_CustomHeaderMessage = 539,
    CDOTAUserMsg_QuickBuyAlert = 540,
    CMsgCombatAnalyzerStats = 541,
    CDOTAUserMsg_PredictionResult = 542,
    CDOTAUserMsg_ModifierAlert = 543,
    CDOTAUserMsg_HPManaAlert = 544,
    CDOTAUserMsg_GlyphAlert = 545,
    CDOTAUserMsg_BeastChat = 546,
    CDOTAUserMsg_SpectatorPlayerUnitOrders = 547,
    CDOTAUserMsg_CustomHudElement_Create = 548,
    CDOTAUserMsg_CustomHudElement_Modify = 549,
    CDOTAUserMsg_CustomHudElement_Destroy = 550,
    CDOTAUserMsg_CompendiumState = 551,
    CDOTAUserMsg_ProjectionAbility = 552,
    CDOTAUserMsg_ProjectionEvent = 553,
    CMsgDOTACombatLogEntry2 = 554,
    CDOTAUserMsg_XPAlert = 555,
    CDOTAUserMsg_UpdateQuestProgress = 556,
    CDOTAMatchMetadataFile = 557,
    CMsgDOTAMatch = 558,
    CDOTAUserMsg_QuestStatus = 559,
    CDOTAUserMsg_SuggestHeroPick = 560,
    CDOTAUserMsg_SuggestHeroRole = 561,
    CDOTAUserMsg_KillcamDamageTaken = 562,
    CDOTAUserMsg_SelectPenaltyGold = 563,
    CDOTAUserMsg_RollDiceResult = 564,
    CDOTAUserMsg_FlipCoinResult = 565,
    CDOTAUserMessage_RequestItemSuggestions = 566,
    CDOTAUserMessage_TeamCaptainChanged = 567,
    CDOTAUserMsg_SendRoshanSpectatorPhase = 568,
    CDOTAUserMsg_ChatWheelCooldown = 569,
    CDOTAUserMsg_DismissAllStatPopups = 570,
    CDOTAUserMsg_TE_DestroyProjectile = 571,
    CDOTAUserMsg_HeroRelicProgress = 572,
    CDOTAUserMsg_AbilityDraftRequestAbility = 573,
    CDOTAUserMsg_ItemSold = 574,
    CDOTAUserMsg_DamageReport = 575,
    CDOTAUserMsg_SalutePlayer = 576,
    CDOTAUserMsg_MarsArenaOfBloodAttack = 580,
    CDOTAUserMsg_TipAlert = 577,
    CDOTAUserMsg_EmptyTeleportAlert = 579,
    CDOTAUserMsg_ReplaceQueryUnit = 578,
};

enum EDOTAGCMsg : int {
    k_EMsgGCDOTABase = 7000,
    k_EMsgGCGeneralResponse = 7001,
    k_EMsgGCGameMatchSignOut = 7004,
    k_EMsgGCGameMatchSignOutResponse = 7005,
    k_EMsgGCJoinChatChannel = 7009,
    k_EMsgGCJoinChatChannelResponse = 7010,
    k_EMsgGCOtherJoinedChannel = 7013,
    k_EMsgGCOtherLeftChannel = 7014,
    k_EMsgGCMatchHistoryList = 7017,
    k_EMsgServerToGCRequestStatus = 7026,
    k_EMsgGCGetRecentMatches = 7027,
    k_EMsgGCRecentMatchesResponse = 7028,
    k_EMsgGCStartFindingMatch = 7033,
    k_EMsgGCConnectedPlayers = 7034,
    k_EMsgGCAbandonCurrentGame = 7035,
    k_EMsgGCStopFindingMatch = 7036,
    k_EMsgGCPracticeLobbyCreate = 7038,
    k_EMsgGCPracticeLobbyLeave = 7040,
    k_EMsgGCPracticeLobbyLaunch = 7041,
    k_EMsgGCPracticeLobbyList = 7042,
    k_EMsgGCPracticeLobbyListResponse = 7043,
    k_EMsgGCPracticeLobbyJoin = 7044,
    k_EMsgGCPracticeLobbySetDetails = 7046,
    k_EMsgGCPracticeLobbySetTeamSlot = 7047,
    k_EMsgGCInitialQuestionnaireResponse = 7049,
    k_EMsgGCPracticeLobbyResponse = 7055,
    k_EMsgGCBroadcastNotification = 7056,
    k_EMsgGCLiveScoreboardUpdate = 7057,
    k_EMsgGCRequestChatChannelList = 7060,
    k_EMsgGCRequestChatChannelListResponse = 7061,
    k_EMsgGCRequestMatches = 7064,
    k_EMsgGCRequestMatchesResponse = 7065,
    k_EMsgGCRequestPlayerResources = 7068,
    k_EMsgGCRequestPlayerResourcesResponse = 7069,
    k_EMsgGCReadyUp = 7070,
    k_EMsgGCKickedFromMatchmakingQueue = 7071,
    k_EMsgGCLeaverDetected = 7072,
    k_EMsgGCSpectateFriendGame = 7073,
    k_EMsgGCSpectateFriendGameResponse = 7074,
    k_EMsgGCPlayerReports = 7075,
    k_EMsgGCReportsRemainingRequest = 7076,
    k_EMsgGCReportsRemainingResponse = 7077,
    k_EMsgGCSubmitPlayerReport = 7078,
    k_EMsgGCSubmitPlayerReportResponse = 7079,
    k_EMsgGCPracticeLobbyKick = 7081,
    k_EMsgGCReportCountsRequest = 7082,
    k_EMsgGCReportCountsResponse = 7083,
    k_EMsgGCRequestSaveGames = 7084,
    k_EMsgGCRequestSaveGamesServer = 7085,
    k_EMsgGCRequestSaveGamesResponse = 7086,
    k_EMsgGCLeaverDetectedResponse = 7087,
    k_EMsgGCPlayerFailedToConnect = 7088,
    k_EMsgGCGCToRelayConnect = 7089,
    k_EMsgGCGCToRelayConnectresponse = 7090,
    k_EMsgGCWatchGame = 7091,
    k_EMsgGCWatchGameResponse = 7092,
    k_EMsgGCBanStatusRequest = 7093,
    k_EMsgGCBanStatusResponse = 7094,
    k_EMsgGCMatchDetailsRequest = 7095,
    k_EMsgGCMatchDetailsResponse = 7096,
    k_EMsgGCCancelWatchGame = 7097,
    k_EMsgGCPopup = 7102,
    k_EMsgGCDOTAClearNotifySuccessfulReport = 7104,
    k_EMsgGCFriendPracticeLobbyListRequest = 7111,
    k_EMsgGCFriendPracticeLobbyListResponse = 7112,
    k_EMsgGCPracticeLobbyJoinResponse = 7113,
    k_EMsgClientEconNotification_Job = 7114,
    k_EMsgGCCreateTeam = 7115,
    k_EMsgGCCreateTeamResponse = 7116,
    k_EMsgGCTeamData = 7121,
    k_EMsgGCTeamInvite_InviterToGC = 7122,
    k_EMsgGCTeamInvite_GCImmediateResponseToInviter = 7123,
    k_EMsgGCTeamInvite_GCRequestToInvitee = 7124,
    k_EMsgGCTeamInvite_InviteeResponseToGC = 7125,
    k_EMsgGCTeamInvite_GCResponseToInviter = 7126,
    k_EMsgGCTeamInvite_GCResponseToInvitee = 7127,
    k_EMsgGCKickTeamMember = 7128,
    k_EMsgGCKickTeamMemberResponse = 7129,
    k_EMsgGCLeaveTeam = 7130,
    k_EMsgGCLeaveTeamResponse = 7131,
    k_EMsgGCSuggestTeamMatchmaking = 7132,
    k_EMsgGCPlayerHeroesFavoritesAdd = 7133,
    k_EMsgGCPlayerHeroesFavoritesRemove = 7134,
    k_EMsgGCApplyTeamToPracticeLobby = 7142,
    k_EMsgGCTransferTeamAdmin = 7144,
    k_EMsgGCPracticeLobbyJoinBroadcastChannel = 7149,
    k_EMsgGC_TournamentItemEvent = 7150,
    k_EMsgGC_TournamentItemEventResponse = 7151,
    k_EMsgCastMatchVote = 7152,
    k_EMsgCastMatchVoteResponse = 7153,
    k_EMsgRetrieveMatchVote = 7154,
    k_EMsgRetrieveMatchVoteResponse = 7155,
    k_EMsgTeamFanfare = 7156,
    k_EMsgResponseTeamFanfare = 7157,
    k_EMsgGC_GameServerUploadSaveGame = 7158,
    k_EMsgGC_GameServerSaveGameResult = 7159,
    k_EMsgGC_GameServerGetLoadGame = 7160,
    k_EMsgGC_GameServerGetLoadGameResult = 7161,
    k_EMsgGCEditTeamDetails = 7166,
    k_EMsgGCEditTeamDetailsResponse = 7167,
    k_EMsgGCProTeamListRequest = 7168,
    k_EMsgGCProTeamListResponse = 7169,
    k_EMsgGCReadyUpStatus = 7170,
    k_EMsgGCHallOfFame = 7171,
    k_EMsgGCHallOfFameRequest = 7172,
    k_EMsgGCHallOfFameResponse = 7173,
    k_EMsgGCGenerateDiretidePrizeList = 7174,
    k_EMsgGCRewardDiretidePrizes = 7176,
    k_EMsgGCDiretidePrizesRewardedResponse = 7177,
    k_EMsgGCHalloweenHighScoreRequest = 7178,
    k_EMsgGCHalloweenHighScoreResponse = 7179,
    k_EMsgGCGenerateDiretidePrizeListResponse = 7180,
    k_EMsgGCStorePromoPagesRequest = 7182,
    k_EMsgGCStorePromoPagesResponse = 7183,
    k_EMsgGCToGCMatchCompleted = 7186,
    k_EMsgGCBalancedShuffleLobby = 7188,
    k_EMsgGCToGCCheckLeaguePermission = 7189,
    k_EMsgGCToGCCheckLeaguePermissionResponse = 7190,
    k_EMsgGCMatchmakingStatsRequest = 7197,
    k_EMsgGCMatchmakingStatsResponse = 7198,
    k_EMsgGCBotGameCreate = 7199,
    k_EMsgGCSetMatchHistoryAccess = 7200,
    k_EMsgGCSetMatchHistoryAccessResponse = 7201,
    k_EMsgUpgradeLeagueItem = 7203,
    k_EMsgUpgradeLeagueItemResponse = 7204,
    k_EMsgGCTeamMemberProfileRequest = 7205,
    k_EMsgGCWatchDownloadedReplay = 7206,
    k_EMsgGCSetMapLocationState = 7207,
    k_EMsgGCSetMapLocationStateResponse = 7208,
    k_EMsgGCResetMapLocations = 7209,
    k_EMsgGCResetMapLocationsResponse = 7210,
    k_EMsgRefreshPartnerAccountLink = 7216,
    k_EMsgClientsRejoinChatChannels = 7217,
    k_EMsgGCToGCGetUserChatInfo = 7218,
    k_EMsgGCToGCGetUserChatInfoResponse = 7219,
    k_EMsgGCToGCLeaveAllChatChannels = 7220,
    k_EMsgGCToGCUpdateAccountChatBan = 7221,
    k_EMsgGCGuildCreateRequest = 7222,
    k_EMsgGCGuildCreateResponse = 7223,
    k_EMsgGCGuildSetAccountRoleRequest = 7224,
    k_EMsgGCGuildSetAccountRoleResponse = 7225,
    k_EMsgGCRequestGuildData = 7226,
    k_EMsgGCGuildData = 7227,
    k_EMsgGCGuildInviteAccountRequest = 7228,
    k_EMsgGCGuildInviteAccountResponse = 7229,
    k_EMsgGCGuildCancelInviteRequest = 7230,
    k_EMsgGCGuildCancelInviteResponse = 7231,
    k_EMsgGCGuildUpdateDetailsRequest = 7232,
    k_EMsgGCGuildUpdateDetailsResponse = 7233,
    k_EMsgGCToGCCanInviteUserToTeam = 7234,
    k_EMsgGCToGCCanInviteUserToTeamResponse = 7235,
    k_EMsgGCToGCGetUserRank = 7236,
    k_EMsgGCToGCGetUserRankResponse = 7237,
    k_EMsgGCToGCUpdateTeamStats = 7240,
    k_EMsgGCToGCValidateTeam = 7241,
    k_EMsgGCToGCValidateTeamResponse = 7242,
    k_EMsgGCPassportDataRequest = 7248,
    k_EMsgGCPassportDataResponse = 7249,
    k_EMsgGCNotInGuildData = 7251,
    k_EMsgGCGuildInviteData = 7254,
    k_EMsgGCToGCGetLeagueAdmin = 7255,
    k_EMsgGCToGCGetLeagueAdminResponse = 7256,
    k_EMsgGCRequestLeaguePrizePool = 7258,
    k_EMsgGCRequestLeaguePrizePoolResponse = 7259,
    k_EMsgGCToGCUpdateOpenGuildPartyRequest = 7261,
    k_EMsgGCToGCUpdateOpenGuildPartyResponse = 7262,
    k_EMsgGCToGCDestroyOpenGuildPartyRequest = 7263,
    k_EMsgGCToGCDestroyOpenGuildPartyResponse = 7264,
    k_EMsgGCGuildUpdateMessage = 7265,
    k_EMsgGCPartySetOpenGuildRequest = 7266,
    k_EMsgGCPartySetOpenGuildResponse = 7267,
    k_EMsgGCGuildOpenPartyRefresh = 7268,
    k_EMsgGCJoinOpenGuildPartyRequest = 7269,
    k_EMsgGCJoinOpenGuildPartyResponse = 7270,
    k_EMsgGCLeaveChatChannel = 7272,
    k_EMsgGCChatMessage = 7273,
    k_EMsgGCGetHeroStandings = 7274,
    k_EMsgGCGetHeroStandingsResponse = 7275,
    k_EMsgGCGuildEditLogoRequest = 7279,
    k_EMsgGCGuildEditLogoResponse = 7280,
    k_EMsgGCGuildmatePracticeLobbyListRequest = 7281,
    k_EMsgGCGuildmatePracticeLobbyListResponse = 7282,
    k_EMsgGCItemEditorReservationsRequest = 7283,
    k_EMsgGCItemEditorReservationsResponse = 7284,
    k_EMsgGCItemEditorReserveItemDef = 7285,
    k_EMsgGCItemEditorReserveItemDefResponse = 7286,
    k_EMsgGCItemEditorReleaseReservation = 7287,
    k_EMsgGCItemEditorReleaseReservationResponse = 7288,
    k_EMsgGCRewardTutorialPrizes = 7289,
    k_EMsgGCLastHitChallengeHighScorePost = 7290,
    k_EMsgGCLastHitChallengeHighScoreRequest = 7291,
    k_EMsgGCLastHitChallengeHighScoreResponse = 7292,
    k_EMsgGCCreateFantasyLeagueRequest = 7293,
    k_EMsgGCCreateFantasyLeagueResponse = 7294,
    k_EMsgGCFantasyLeagueInfoRequest = 7297,
    k_EMsgGCFantasyLeagueInfoResponse = 7298,
    k_EMsgGCFantasyLeagueInfo = 7299,
    k_EMsgGCCreateFantasyTeamRequest = 7300,
    k_EMsgGCCreateFantasyTeamResponse = 7301,
    k_EMsgGCEditFantasyTeamRequest = 7302,
    k_EMsgGCEditFantasyTeamResponse = 7303,
    k_EMsgGCFantasyTeamInfoRequestByFantasyLeagueID = 7304,
    k_EMsgGCFantasyTeamInfoRequestByOwnerAccountID = 7305,
    k_EMsgGCFantasyTeamInfoResponse = 7306,
    k_EMsgGCFantasyTeamInfo = 7307,
    k_EMsgGCFantasyLivePlayerStats = 7308,
    k_EMsgGCFantasyFinalPlayerStats = 7309,
    k_EMsgGCFantasyMatch = 7310,
    k_EMsgGCFantasyTeamScoreRequest = 7312,
    k_EMsgGCFantasyTeamScoreResponse = 7313,
    k_EMsgGCFantasyTeamStandingsRequest = 7314,
    k_EMsgGCFantasyTeamStandingsResponse = 7315,
    k_EMsgGCFantasyPlayerScoreRequest = 7316,
    k_EMsgGCFantasyPlayerScoreResponse = 7317,
    k_EMsgGCFantasyPlayerStandingsRequest = 7318,
    k_EMsgGCFantasyPlayerStandingsResponse = 7319,
    k_EMsgGCFlipLobbyTeams = 7320,
    k_EMsgGCCustomGameCreate = 7321,
    k_EMsgGCToGCProcessPlayerReportForTarget = 7324,
    k_EMsgGCToGCProcessReportSuccess = 7325,
    k_EMsgGCNotifyAccountFlagsChange = 7326,
    k_EMsgGCSetProfilePrivacy = 7327,
    k_EMsgGCSetProfilePrivacyResponse = 7328,
    k_EMsgGCFantasyLeagueCreateInfoRequest = 7331,
    k_EMsgGCFantasyLeagueCreateInfoResponse = 7332,
    k_EMsgGCFantasyLeagueInviteInfoRequest = 7333,
    k_EMsgGCFantasyLeagueInviteInfoResponse = 7334,
    k_EMsgGCClientIgnoredUser = 7335,
    k_EMsgGCFantasyLeagueCreateRequest = 7336,
    k_EMsgGCFantasyLeagueCreateResponse = 7337,
    k_EMsgGCFantasyTeamCreateRequest = 7338,
    k_EMsgGCFantasyTeamCreateResponse = 7339,
    k_EMsgGCFantasyLeagueFriendJoinListRequest = 7340,
    k_EMsgGCFantasyLeagueFriendJoinListResponse = 7341,
    k_EMsgGCClientSuspended = 7342,
    k_EMsgGCPartyMemberSetCoach = 7343,
    k_EMsgGCFantasyLeagueEditInvitesRequest = 7344,
    k_EMsgGCFantasyLeagueEditInvitesResponse = 7345,
    k_EMsgGCPracticeLobbySetCoach = 7346,
    k_EMsgGCFantasyLeagueEditInfoRequest = 7347,
    k_EMsgGCFantasyLeagueEditInfoResponse = 7348,
    k_EMsgGCFantasyLeagueDraftStatusRequest = 7349,
    k_EMsgGCFantasyLeagueDraftStatus = 7350,
    k_EMsgGCFantasyLeagueDraftPlayerRequest = 7351,
    k_EMsgGCFantasyLeagueDraftPlayerResponse = 7352,
    k_EMsgGCFantasyLeagueMatchupsRequest = 7353,
    k_EMsgGCFantasyLeagueMatchupsResponse = 7354,
    k_EMsgGCFantasyTeamRosterSwapRequest = 7355,
    k_EMsgGCFantasyTeamRosterSwapResponse = 7356,
    k_EMsgGCFantasyTeamRosterRequest = 7357,
    k_EMsgGCFantasyTeamRosterResponse = 7358,
    k_EMsgGCFantasyTeamRosterAddDropRequest = 7361,
    k_EMsgGCFantasyTeamRosterAddDropResponse = 7362,
    k_EMsgPresentedClientTerminateDlg = 7363,
    k_EMsgGCFantasyPlayerHisoricalStatsRequest = 7364,
    k_EMsgGCFantasyPlayerHisoricalStatsResponse = 7365,
    k_EMsgGCPCBangTimedRewardMessage = 7366,
    k_EMsgGCLobbyUpdateBroadcastChannelInfo = 7367,
    k_EMsgGCFantasyTeamTradesRequest = 7368,
    k_EMsgGCFantasyTeamTradesResponse = 7369,
    k_EMsgGCFantasyTeamTradeCancelRequest = 7370,
    k_EMsgGCFantasyTeamTradeCancelResponse = 7371,
    k_EMsgGCToGCGrantTournamentItem = 7372,
    k_EMsgGCProcessFantasyScheduledEvent = 7373,
    k_EMsgGCToGCUpgradeTwitchViewerItems = 7375,
    k_EMsgGCToGCGetLiveMatchAffiliates = 7376,
    k_EMsgGCToGCGetLiveMatchAffiliatesResponse = 7377,
    k_EMsgGCToGCUpdatePlayerPennantCounts = 7378,
    k_EMsgGCToGCGetPlayerPennantCounts = 7379,
    k_EMsgGCToGCGetPlayerPennantCountsResponse = 7380,
    k_EMsgGCGameMatchSignOutPermissionRequest = 7381,
    k_EMsgGCGameMatchSignOutPermissionResponse = 7382,
    k_EMsgDOTAChatChannelMemberUpdate = 7383,
    k_EMsgDOTAAwardEventPoints = 7384,
    k_EMsgDOTAGetEventPoints = 7387,
    k_EMsgDOTAGetEventPointsResponse = 7388,
    k_EMsgDOTASendFriendRecruits = 7393,
    k_EMsgDOTAFriendRecruitsRequest = 7394,
    k_EMsgDOTAFriendRecruitsResponse = 7395,
    k_EMsgDOTAFriendRecruitInviteAcceptDecline = 7396,
    k_EMsgGCPartyLeaderWatchGamePrompt = 7397,
    k_EMsgDOTAFrostivusTimeElapsed = 7398,
    k_EMsgDOTALiveLeagueGameUpdate = 7402,
    k_EMsgDOTAChatGetUserList = 7403,
    k_EMsgDOTAChatGetUserListResponse = 7404,
    k_EMsgGCCompendiumSetSelection = 7405,
    k_EMsgGCCompendiumDataRequest = 7406,
    k_EMsgGCCompendiumDataResponse = 7407,
    k_EMsgDOTAGetPlayerMatchHistory = 7408,
    k_EMsgDOTAGetPlayerMatchHistoryResponse = 7409,
    k_EMsgGCToGCMatchmakingAddParty = 7410,
    k_EMsgGCToGCMatchmakingRemoveParty = 7411,
    k_EMsgGCToGCMatchmakingRemoveAllParties = 7412,
    k_EMsgGCToGCMatchmakingMatchFound = 7413,
    k_EMsgGCToGCUpdateMatchManagementStats = 7414,
    k_EMsgGCToGCUpdateMatchmakingStats = 7415,
    k_EMsgGCToServerPingRequest = 7416,
    k_EMsgGCToServerPingResponse = 7417,
    k_EMsgGCToServerConsoleCommand = 7418,
    k_EMsgGCMakeOffering = 7423,
    k_EMsgGCRequestOfferings = 7424,
    k_EMsgGCRequestOfferingsResponse = 7425,
    k_EMsgGCToGCProcessMatchLeaver = 7426,
    k_EMsgGCNotificationsRequest = 7427,
    k_EMsgGCNotificationsResponse = 7428,
    k_EMsgGCToGCModifyNotification = 7429,
    k_EMsgGCToGCSetNewNotifications = 7430,
    k_EMsgGCLeagueAdminList = 7434,
    k_EMsgGCNotificationsMarkReadRequest = 7435,
    k_EMsgGCFantasyMessageAdd = 7436,
    k_EMsgGCFantasyMessagesRequest = 7437,
    k_EMsgGCFantasyMessagesResponse = 7438,
    k_EMsgGCFantasyScheduledMatchesRequest = 7439,
    k_EMsgGCFantasyScheduledMatchesResponse = 7440,
    k_EMsgGCEventGameCreate = 7443,
    k_EMsgGCPerfectWorldUserLookupRequest = 7444,
    k_EMsgGCPerfectWorldUserLookupResponse = 7445,
    k_EMsgGCFantasyRemoveOwner = 7448,
    k_EMsgGCFantasyRemoveOwnerResponse = 7449,
    k_EMsgGCRequestBatchPlayerResources = 7450,
    k_EMsgGCRequestBatchPlayerResourcesResponse = 7451,
    k_EMsgGCToGCSendUpdateLeagues = 7452,
    k_EMsgGCCompendiumSetSelectionResponse = 7453,
    k_EMsgGCPlayerInfoRequest = 7454,
    k_EMsgGCPlayerInfo = 7455,
    k_EMsgGCPlayerInfoSubmit = 7456,
    k_EMsgGCPlayerInfoSubmitResponse = 7457,
    k_EMsgGCToGCGetAccountLevel = 7458,
    k_EMsgGCToGCGetAccountLevelResponse = 7459,
    k_EMsgGCToGCGetAccountPartner = 7460,
    k_EMsgGCToGCGetAccountPartnerResponse = 7461,
    k_EMsgDOTAGetWeekendTourneySchedule = 7464,
    k_EMsgDOTAWeekendTourneySchedule = 7465,
    k_EMsgGCJoinableCustomGameModesRequest = 7466,
    k_EMsgGCJoinableCustomGameModesResponse = 7467,
    k_EMsgGCJoinableCustomLobbiesRequest = 7468,
    k_EMsgGCJoinableCustomLobbiesResponse = 7469,
    k_EMsgGCQuickJoinCustomLobby = 7470,
    k_EMsgGCQuickJoinCustomLobbyResponse = 7471,
    k_EMsgGCToGCGrantEventPointAction = 7472,
    k_EMsgServerGrantSurveyPermission = 7475,
    k_EMsgServerGrantSurveyPermissionResponse = 7476,
    k_EMsgClientProvideSurveyResult = 7477,
    k_EMsgGCToGCSetCompendiumSelection = 7478,
    k_EMsgGCToGCUpdateTI4HeroQuest = 7480,
    k_EMsgGCCompendiumDataChanged = 7481,
    k_EMsgDOTAFantasyLeagueFindRequest = 7482,
    k_EMsgDOTAFantasyLeagueFindResponse = 7483,
    k_EMsgGCHasItemQuery = 7484,
    k_EMsgGCHasItemResponse = 7485,
    k_EMsgGCConsumeFantasyTicket = 7486,
    k_EMsgGCConsumeFantasyTicketFailure = 7487,
    k_EMsgGCToGCGrantEventPointActionMsg = 7488,
    k_EMsgClientToGCTrackDialogResult = 7489,
    k_EMsgGCFantasyLeaveLeagueRequest = 7490,
    k_EMsgGCFantasyLeaveLeagueResponse = 7491,
    k_EMsgGCToGCGetCompendiumSelections = 7492,
    k_EMsgGCToGCGetCompendiumSelectionsResponse = 7493,
    k_EMsgServerToGCMatchConnectionStats = 7494,
    k_EMsgGCToClientTournamentItemDrop = 7495,
    k_EMsgSQLDelayedGrantLeagueDrop = 7496,
    k_EMsgServerGCUpdateSpectatorCount = 7497,
    k_EMsgGCFantasyPlayerScoreDetailsRequest = 7499,
    k_EMsgGCFantasyPlayerScoreDetailsResponse = 7500,
    k_EMsgGCToGCEmoticonUnlock = 7501,
    k_EMsgSignOutDraftInfo = 7502,
    k_EMsgClientToGCEmoticonDataRequest = 7503,
    k_EMsgGCToClientEmoticonData = 7504,
    k_EMsgGCPracticeLobbyToggleBroadcastChannelCameramanStatus = 7505,
    k_EMsgGCToGCCreateWeekendTourneyRequest = 7506,
    k_EMsgGCToGCCreateWeekendTourneyResponse = 7507,
    k_EMsgClientToGCSetAdditionalEquips = 7513,
    k_EMsgClientToGCGetAdditionalEquips = 7514,
    k_EMsgClientToGCGetAdditionalEquipsResponse = 7515,
    k_EMsgServerToGCGetAdditionalEquips = 7516,
    k_EMsgServerToGCGetAdditionalEquipsResponse = 7517,
    k_EMsgDOTARedeemItem = 7518,
    k_EMsgDOTARedeemItemResponse = 7519,
    k_EMsgSQLGCToGCGrantAllHeroProgress = 7520,
    k_EMsgClientToGCGetAllHeroProgress = 7521,
    k_EMsgClientToGCGetAllHeroProgressResponse = 7522,
    k_EMsgGCToGCGetServerForClient = 7523,
    k_EMsgGCToGCGetServerForClientResponse = 7524,
    k_EMsgSQLProcessTournamentGameOutcome = 7525,
    k_EMsgSQLGrantTrophyToAccount = 7526,
    k_EMsgClientToGCGetTrophyList = 7527,
    k_EMsgClientToGCGetTrophyListResponse = 7528,
    k_EMsgGCToClientTrophyAwarded = 7529,
    k_EMsgGCGameBotMatchSignOut = 7530,
    k_EMsgGCGameBotMatchSignOutPermissionRequest = 7531,
    k_EMsgSignOutBotInfo = 7532,
    k_EMsgGCToGCUpdateProfileCards = 7533,
    k_EMsgClientToGCGetProfileCard = 7534,
    k_EMsgClientToGCGetProfileCardResponse = 7535,
    k_EMsgServerToGCGetProfileCard = 7536,
    k_EMsgServerToGCGetProfileCardResponse = 7537,
    k_EMsgClientToGCSetProfileCardSlots = 7538,
    k_EMsgGCToClientProfileCardUpdated = 7539,
    k_EMsgServerToGCVictoryPredictions = 7540,
    k_EMsgClientToGCMarkNotificationListRead = 7542,
    k_EMsgServerToGCSuspiciousActivity = 7544,
    k_EMsgSignOutCommunicationSummary = 7545,
    k_EMsgServerToGCRequestStatus_Response = 7546,
    k_EMsgClientToGCCreateHeroStatue = 7547,
    k_EMsgGCToClientHeroStatueCreateResult = 7548,
    k_EMsgGCGCToLANServerRelayConnect = 7549,
    k_EMsgServerToGCGetIngameEventData = 7551,
    k_EMsgGCToGCUpdateIngameEventDataBroadcast = 7552,
    k_EMsgGCToServerIngameEventData_OraclePA = 7553,
    k_EMsgServerToGCReportKillSummaries = 7554,
    k_EMsgGCToGCReportKillSummaries = 7555,
    k_EMsgGCToGCUpdateAssassinMinigame = 7556,
    k_EMsgGCToGCFantasySetMatchLeague = 7557,
    k_EMsgGCToGCUpdatePlayerPredictions = 7561,
    k_EMsgGCToServerPredictionResult = 7562,
    k_EMsgServerToGCSignoutAwardAdditionalDrops = 7563,
    k_EMsgGCToGCSignoutAwardAdditionalDrops = 7564,
    k_EMsgGCToClientEventStatusChanged = 7565,
    k_EMsgGCHasItemDefsQuery = 7566,
    k_EMsgGCHasItemDefsResponse = 7567,
    k_EMsgGCToGCReplayMonitorValidateReplay = 7569,
    k_EMsgLobbyEventPoints = 7572,
    k_EMsgGCToGCGetCustomGameTickets = 7573,
    k_EMsgGCToGCGetCustomGameTicketsResponse = 7574,
    k_EMsgGCToGCCustomGamePlayed = 7576,
    k_EMsgGCToGCGrantEventPointsToUser = 7577,
    k_EMsgGCToGCSetEventMMPanicFlushTime = 7578,
    k_EMsgGameserverCrashReport = 7579,
    k_EMsgGameserverCrashReportResponse = 7580,
    k_EMsgGCToClientSteamDatagramTicket = 7581,
    k_EMsgGCToGCGrantEventOwnership = 7582,
    k_EMsgGCToGCSendAccountsEventPoints = 7583,
    k_EMsgClientToGCRerollPlayerChallenge = 7584,
    k_EMsgServerToGCRerollPlayerChallenge = 7585,
    k_EMsgGCRerollPlayerChallengeResponse = 7586,
    k_EMsgSignOutUpdatePlayerChallenge = 7587,
    k_EMsgClientToGCSetPartyLeader = 7588,
    k_EMsgClientToGCCancelPartyInvites = 7589,
    k_EMsgGCToGCMasterReloadAccount = 7590,
    k_EMsgSQLGrantLeagueMatchToTicketHolders = 7592,
    k_EMsgClientToGCSetAdditionalEquipsResponse = 7593,
    k_EMsgGCToGCEmoticonUnlockNoRollback = 7594,
    k_EMsgGCToGCGetCompendiumFanfare = 7595,
    k_EMsgGCToGCChatNewUserSession = 7598,
    k_EMsgClientToGCApplyGemCombiner = 7603,
    k_EMsgClientToGCDOTACreateStaticRecipe = 7604,
    k_EMsgClientToGCDOTACreateStaticRecipeResponse = 7605,
    k_EMsgClientToGCGetAllHeroOrder = 7606,
    k_EMsgClientToGCGetAllHeroOrderResponse = 7607,
    k_EMsgSQLGCToGCGrantBadgePoints = 7608,
    k_EMsgGCToGCGetAccountMatchStatus = 7609,
    k_EMsgGCToGCGetAccountMatchStatusResponse = 7610,
    k_EMsgGCToGCCheckOwnsEntireEmoticonRange = 7611,
    k_EMsgGCToGCCheckOwnsEntireEmoticonRangeResponse = 7612,
    k_EMsgClientToGCRecycleHeroRelic = 7619,
    k_EMsgClientToGCRecycleHeroRelicResponse = 7620,
    k_EMsgGCToGCRevokeEventOwnership = 7621,
    k_EMsgGCToGCUnlockEventPointSpending = 7622,
    k_EMsgGCToClientRequestLaneSelection = 7623,
    k_EMsgGCToClientRequestLaneSelectionResponse = 7624,
    k_EMsgServerToGCCavernCrawlIsHeroActive = 7625,
    k_EMsgServerToGCCavernCrawlIsHeroActiveResponse = 7626,
    k_EMsgClientToGCPlayerCardSpecificPurchaseRequest = 7627,
    k_EMsgClientToGCPlayerCardSpecificPurchaseResponse = 7628,
    k_EMsgGCtoServerTensorflowInstance = 7629,
    k_EMsgSQLSetIsLeagueAdmin = 7630,
    k_EMsgGCToGCGetLiveLeagueMatches = 7631,
    k_EMsgGCToGCGetLiveLeagueMatchesResponse = 7632,
    k_EMsgDOTALeagueInfoListAdminsRequest = 7633,
    k_EMsgDOTALeagueInfoListAdminsReponse = 7634,
    k_EMsgGCToGCLeagueMatchStarted = 7645,
    k_EMsgGCToGCLeagueMatchCompleted = 7646,
    k_EMsgGCToGCLeagueMatchStartedResponse = 7647,
    k_EMsgDOTALeagueNodeRequest = 7648,
    k_EMsgDOTALeagueNodeResponse = 7649,
    k_EMsgDOTALeagueAvailableLobbyNodesRequest = 7650,
    k_EMsgDOTALeagueAvailableLobbyNodes = 7651,
    k_EMsgGCToGCLeagueRequest = 7652,
    k_EMsgGCToGCLeagueResponse = 7653,
    k_EMsgGCToGCLeagueNodeGroupRequest = 7654,
    k_EMsgGCToGCLeagueNodeGroupResponse = 7655,
    k_EMsgGCToGCLeagueNodeRequest = 7656,
    k_EMsgGCToGCLeagueNodeResponse = 7657,
    k_EMsgGCToGCRealtimeStatsTerseRequest = 7658,
    k_EMsgGCToGCRealtimeStatsTerseResponse = 7659,
    k_EMsgGCToGCGetTopMatchesRequest = 7660,
    k_EMsgGCToGCGetTopMatchesResponse = 7661,
    k_EMsgClientToGCGetFilteredPlayers = 7662,
    k_EMsgGCToClientGetFilteredPlayersResponse = 7663,
    k_EMsgClientToGCRemoveFilteredPlayer = 7664,
    k_EMsgGCToClientRemoveFilteredPlayerResponse = 7665,
    k_EMsgGCToClientPlayerBeaconState = 7666,
    k_EMsgGCToClientPartyBeaconUpdate = 7667,
    k_EMsgGCToClientPartySearchInvite = 7668,
    k_EMsgClientToGCUpdatePartyBeacon = 7669,
    k_EMsgClientToGCRequestActiveBeaconParties = 7670,
    k_EMsgGCToClientRequestActiveBeaconPartiesResponse = 7671,
    k_EMsgClientToGCManageFavorites = 7672,
    k_EMsgGCToClientManageFavoritesResponse = 7673,
    k_EMsgClientToGCJoinPartyFromBeacon = 7674,
    k_EMsgGCToClientJoinPartyFromBeaconResponse = 7675,
    k_EMsgClientToGCGetFavoritePlayers = 7676,
    k_EMsgGCToClientGetFavoritePlayersResponse = 7677,
    k_EMsgClientToGCVerifyFavoritePlayers = 7678,
    k_EMsgGCToClientVerifyFavoritePlayersResponse = 7679,
    k_EMsgGCToClientPartySearchInvites = 7680,
    k_EMsgGCToClientRequestMMInfo = 7681,
    k_EMsgClientToGCMMInfo = 7682,
    k_EMsgGCDev_GrantWarKill = 8001,
    k_EMsgServerToGCLockCharmTrading = 8004,
    k_EMsgClientToGCPlayerStatsRequest = 8006,
    k_EMsgGCToClientPlayerStatsResponse = 8007,
    k_EMsgGCClearPracticeLobbyTeam = 8008,
    k_EMsgClientToGCFindTopSourceTVGames = 8009,
    k_EMsgGCToClientFindTopSourceTVGamesResponse = 8010,
    k_EMsgGCLobbyList = 8011,
    k_EMsgGCLobbyListResponse = 8012,
    k_EMsgGCPlayerStatsMatchSignOut = 8013,
    k_EMsgClientToGCCustomGamePlayerCountRequest = 8014,
    k_EMsgGCToClientCustomGamePlayerCountResponse = 8015,
    k_EMsgClientToGCSocialFeedPostCommentRequest = 8016,
    k_EMsgGCToClientSocialFeedPostCommentResponse = 8017,
    k_EMsgClientToGCCustomGamesFriendsPlayedRequest = 8018,
    k_EMsgGCToClientCustomGamesFriendsPlayedResponse = 8019,
    k_EMsgClientToGCFriendsPlayedCustomGameRequest = 8020,
    k_EMsgGCToClientFriendsPlayedCustomGameResponse = 8021,
    k_EMsgGCTopCustomGamesList = 8024,
    k_EMsgClientToGCSocialMatchPostCommentRequest = 8025,
    k_EMsgGCToClientSocialMatchPostCommentResponse = 8026,
    k_EMsgClientToGCSocialMatchDetailsRequest = 8027,
    k_EMsgGCToClientSocialMatchDetailsResponse = 8028,
    k_EMsgClientToGCSetPartyOpen = 8029,
    k_EMsgClientToGCMergePartyInvite = 8030,
    k_EMsgGCToClientMergeGroupInviteReply = 8031,
    k_EMsgClientToGCMergePartyResponse = 8032,
    k_EMsgGCToClientMergePartyResponseReply = 8033,
    k_EMsgClientToGCGetProfileCardStats = 8034,
    k_EMsgClientToGCGetProfileCardStatsResponse = 8035,
    k_EMsgClientToGCTopLeagueMatchesRequest = 8036,
    k_EMsgClientToGCTopFriendMatchesRequest = 8037,
    k_EMsgGCToClientProfileCardStatsUpdated = 8040,
    k_EMsgServerToGCRealtimeStats = 8041,
    k_EMsgGCToServerRealtimeStatsStartStop = 8042,
    k_EMsgGCToGCGetServersForClients = 8045,
    k_EMsgGCToGCGetServersForClientsResponse = 8046,
    k_EMsgGCPracticeLobbyKickFromTeam = 8047,
    k_EMsgDOTAChatGetMemberCount = 8048,
    k_EMsgDOTAChatGetMemberCountResponse = 8049,
    k_EMsgClientToGCSocialFeedPostMessageRequest = 8050,
    k_EMsgGCToClientSocialFeedPostMessageResponse = 8051,
    k_EMsgCustomGameListenServerStartedLoading = 8052,
    k_EMsgCustomGameClientFinishedLoading = 8053,
    k_EMsgGCPracticeLobbyCloseBroadcastChannel = 8054,
    k_EMsgGCStartFindingMatchResponse = 8055,
    k_EMsgSQLGCToGCGrantAccountFlag = 8057,
    k_EMsgGCToGCGetAccountFlags = 8058,
    k_EMsgGCToGCGetAccountFlagsResponse = 8059,
    k_EMsgSignOutWagerStats = 8060,
    k_EMsgGCToClientTopLeagueMatchesResponse = 8061,
    k_EMsgGCToClientTopFriendMatchesResponse = 8062,
    k_EMsgClientToGCMatchesMinimalRequest = 8063,
    k_EMsgClientToGCMatchesMinimalResponse = 8064,
    k_EMsgGCToGCGetProfileBadgePoints = 8065,
    k_EMsgGCToGCGetProfileBadgePointsResponse = 8066,
    k_EMsgGCToClientChatRegionsEnabled = 8067,
    k_EMsgClientToGCPingData = 8068,
    k_EMsgServerToGCMatchDetailsRequest = 8069,
    k_EMsgGCToServerMatchDetailsResponse = 8070,
    k_EMsgGCToGCEnsureAccountInParty = 8071,
    k_EMsgGCToGCEnsureAccountInPartyResponse = 8072,
    k_EMsgClientToGCGetProfileTickets = 8073,
    k_EMsgClientToGCGetProfileTicketsResponse = 8074,
    k_EMsgGCToClientMatchGroupsVersion = 8075,
    k_EMsgClientToGCH264Unsupported = 8076,
    k_EMsgClientToGCRequestH264Support = 8077,
    k_EMsgClientToGCGetQuestProgress = 8078,
    k_EMsgClientToGCGetQuestProgressResponse = 8079,
    k_EMsgSignOutXPCoins = 8080,
    k_EMsgGCToClientMatchSignedOut = 8081,
    k_EMsgGCGetHeroStatsHistory = 8082,
    k_EMsgGCGetHeroStatsHistoryResponse = 8083,
    k_EMsgClientToGCPrivateChatInvite = 8084,
    k_EMsgClientToGCPrivateChatKick = 8088,
    k_EMsgClientToGCPrivateChatPromote = 8089,
    k_EMsgClientToGCPrivateChatDemote = 8090,
    k_EMsgGCToClientPrivateChatResponse = 8091,
    k_EMsgClientToGCPrivateChatInfoRequest = 8092,
    k_EMsgGCToClientPrivateChatInfoResponse = 8093,
    k_EMsgClientToGCLatestConductScorecardRequest = 8095,
    k_EMsgClientToGCLatestConductScorecard = 8096,
    k_EMsgServerToGCPostMatchTip = 8097,
    k_EMsgServerToGCPostMatchTipResponse = 8098,
    k_EMsgClientToGCWageringRequest = 8099,
    k_EMsgGCToClientWageringResponse = 8100,
    k_EMsgClientToGCEventGoalsRequest = 8103,
    k_EMsgClientToGCEventGoalsResponse = 8104,
    k_EMsgClientToGCLeaguePredictions = 8106,
    k_EMsgGCToClientLeaguePredictionsResponse = 8107,
    k_EMsgGCToGCLeaguePredictionsUpdate = 8108,
    k_EMsgClientToGCSuspiciousActivity = 8109,
    k_EMsgGCToGCAddUserToPostGameChat = 8110,
    k_EMsgClientToGCHasPlayerVotedForMVP = 8111,
    k_EMsgClientToGCHasPlayerVotedForMVPResponse = 8112,
    k_EMsgClientToGCVoteForMVP = 8113,
    k_EMsgClientToGCVoteForMVPResponse = 8114,
    k_EMsgGCToGCGetEventOwnership = 8115,
    k_EMsgGCToGCGetEventOwnershipResponse = 8116,
    k_EMsgGCToClientAutomatedTournamentStateChange = 8117,
    k_EMsgClientToGCWeekendTourneyOpts = 8118,
    k_EMsgClientToGCWeekendTourneyOptsResponse = 8119,
    k_EMsgClientToGCWeekendTourneyLeave = 8120,
    k_EMsgClientToGCWeekendTourneyLeaveResponse = 8121,
    k_EMsgClientToGCTeammateStatsRequest = 8124,
    k_EMsgClientToGCTeammateStatsResponse = 8125,
    k_EMsgClientToGCGetGiftPermissions = 8126,
    k_EMsgClientToGCGetGiftPermissionsResponse = 8127,
    k_EMsgClientToGCVoteForArcana = 8128,
    k_EMsgClientToGCVoteForArcanaResponse = 8129,
    k_EMsgClientToGCRequestArcanaVotesRemaining = 8130,
    k_EMsgClientToGCRequestArcanaVotesRemainingResponse = 8131,
    k_EMsgGCTransferTeamAdminResponse = 8132,
    k_EMsgGCToClientTeamInfo = 8135,
    k_EMsgGCToClientTeamsInfo = 8136,
    k_EMsgClientToGCMyTeamInfoRequest = 8137,
    k_EMsgClientToGCPublishUserStat = 8140,
    k_EMsgGCToGCSignoutSpendWager = 8141,
    k_EMsgGCSubmitLobbyMVPVote = 8144,
    k_EMsgGCSubmitLobbyMVPVoteResponse = 8145,
    k_EMsgSignOutCommunityGoalProgress = 8150,
    k_EMsgGCToClientLobbyMVPNotifyRecipient = 8151,
    k_EMsgGCToClientLobbyMVPAwarded = 8152,
    k_EMsgGCToClientQuestProgressUpdated = 8153,
    k_EMsgGCToClientWageringUpdate = 8154,
    k_EMsgGCToClientArcanaVotesUpdate = 8155,
    k_EMsgClientToGCAddTI6TreeProgress = 8156,
    k_EMsgClientToGCSetSpectatorLobbyDetails = 8157,
    k_EMsgClientToGCSetSpectatorLobbyDetailsResponse = 8158,
    k_EMsgClientToGCCreateSpectatorLobby = 8159,
    k_EMsgClientToGCCreateSpectatorLobbyResponse = 8160,
    k_EMsgClientToGCSpectatorLobbyList = 8161,
    k_EMsgClientToGCSpectatorLobbyListResponse = 8162,
    k_EMsgSpectatorLobbyGameDetails = 8163,
    k_EMsgServerToGCCompendiumInGamePredictionResults = 8166,
    k_EMsgServerToGCCloseCompendiumInGamePredictionVoting = 8167,
    k_EMsgClientToGCOpenPlayerCardPack = 8168,
    k_EMsgClientToGCOpenPlayerCardPackResponse = 8169,
    k_EMsgClientToGCSelectCompendiumInGamePrediction = 8170,
    k_EMsgClientToGCSelectCompendiumInGamePredictionResponse = 8171,
    k_EMsgClientToGCWeekendTourneyGetPlayerStats = 8172,
    k_EMsgClientToGCWeekendTourneyGetPlayerStatsResponse = 8173,
    k_EMsgClientToGCRecyclePlayerCard = 8174,
    k_EMsgClientToGCRecyclePlayerCardResponse = 8175,
    k_EMsgClientToGCCreatePlayerCardPack = 8176,
    k_EMsgClientToGCCreatePlayerCardPackResponse = 8177,
    k_EMsgClientToGCGetPlayerCardRosterRequest = 8178,
    k_EMsgClientToGCGetPlayerCardRosterResponse = 8179,
    k_EMsgClientToGCSetPlayerCardRosterRequest = 8180,
    k_EMsgClientToGCSetPlayerCardRosterResponse = 8181,
    k_EMsgServerToGCCloseCompendiumInGamePredictionVotingResponse = 8183,
    k_EMsgServerToGCCompendiumInGamePredictionResultsResponse = 8185,
    k_EMsgLobbyBattleCupVictory = 8186,
    k_EMsgGCGetPlayerCardItemInfo = 8187,
    k_EMsgGCGetPlayerCardItemInfoResponse = 8188,
    k_EMsgClientToGCRequestSteamDatagramTicket = 8189,
    k_EMsgClientToGCRequestSteamDatagramTicketResponse = 8190,
    k_EMsgGCToClientBattlePassRollupRequest = 8191,
    k_EMsgGCToClientBattlePassRollupResponse = 8192,
    k_EMsgClientToGCTransferSeasonalMMRRequest = 8193,
    k_EMsgClientToGCTransferSeasonalMMRResponse = 8194,
    k_EMsgGCToGCPublicChatCommunicationBan = 8195,
    k_EMsgGCToGCUpdateAccountPublicChatBan = 8196,
    k_EMsgGCChatReportPublicSpam = 8197,
    k_EMsgClientToGCSetPartyBuilderOptions = 8198,
    k_EMsgClientToGCSetPartyBuilderOptionsResponse = 8199,
    k_EMsgGCToClientPlaytestStatus = 8200,
    k_EMsgClientToGCJoinPlaytest = 8201,
    k_EMsgClientToGCJoinPlaytestResponse = 8202,
    k_EMsgLobbyPlaytestDetails = 8203,
    k_EMsgDOTASetFavoriteTeam = 8204,
    k_EMsgGCToClientBattlePassRollupListRequest = 8205,
    k_EMsgGCToClientBattlePassRollupListResponse = 8206,
    k_EMsgGCIsProQuery = 8207,
    k_EMsgGCIsProResponse = 8208,
    k_EMsgDOTAClaimEventAction = 8209,
    k_EMsgDOTAClaimEventActionResponse = 8210,
    k_EMsgDOTAGetPeriodicResource = 8211,
    k_EMsgDOTAGetPeriodicResourceResponse = 8212,
    k_EMsgDOTAPeriodicResourceUpdated = 8213,
    k_EMsgServerToGCSpendWager = 8214,
    k_EMsgGCToGCSignoutSpendWagerToken = 8215,
    k_EMsgSubmitTriviaQuestionAnswer = 8216,
    k_EMsgSubmitTriviaQuestionAnswerResponse = 8217,
    k_EMsgClientToGCGiveTip = 8218,
    k_EMsgClientToGCGiveTipResponse = 8219,
    k_EMsgStartTriviaSession = 8220,
    k_EMsgStartTriviaSessionResponse = 8221,
    k_EMsgAnchorPhoneNumberRequest = 8222,
    k_EMsgAnchorPhoneNumberResponse = 8223,
    k_EMsgUnanchorPhoneNumberRequest = 8224,
    k_EMsgUnanchorPhoneNumberResponse = 8225,
    k_EMsgGCToClientTipNotification = 8226,
    k_EMsgClientToGCRequestSlarkGameResult = 8227,
    k_EMsgClientToGCRequestSlarkGameResultResponse = 8228,
    k_EMsgGCToGCSignoutSpendRankWager = 8229,
    k_EMsgGCToGCGetFavoriteTeam = 8230,
    k_EMsgGCToGCGetFavoriteTeamResponse = 8231,
    k_EMsgSignOutEventGameData = 8232,
    k_EMsgGCToClientAllStarVotesRequest = 8233,
    k_EMsgGCToClientAllStarVotesReply = 8234,
    k_EMsgGCToClientAllStarVotesSubmit = 8236,
    k_EMsgGCToClientAllStarVotesSubmitReply = 8237,
    k_EMsgClientToGCQuickStatsRequest = 8238,
    k_EMsgClientToGCQuickStatsResponse = 8239,
    k_EMsgGCToGCSubtractEventPointsFromUser = 8240,
    k_EMsgSelectionPriorityChoiceRequest = 8241,
    k_EMsgSelectionPriorityChoiceResponse = 8242,
    k_EMsgGCToGCCompendiumInGamePredictionResults = 8243,
    k_EMsgGameAutographReward = 8244,
    k_EMsgGameAutographRewardResponse = 8245,
    k_EMsgDestroyLobbyRequest = 8246,
    k_EMsgDestroyLobbyResponse = 8247,
    k_EMsgPurchaseItemWithEventPoints = 8248,
    k_EMsgPurchaseItemWithEventPointsResponse = 8249,
    k_EMsgServerToGCMatchPlayerItemPurchaseHistory = 8250,
    k_EMsgGCToGCGrantPlusHeroMatchResults = 8251,
    k_EMsgGCGetHeroTimedStats = 8252,
    k_EMsgGCGetHeroTimedStatsResponse = 8253,
    k_EMsgLobbyPlayerPlusSubscriptionData = 8254,
    k_EMsgServerToGCMatchStateHistory = 8255,
    k_EMsgPurchaseHeroRelic = 8256,
    k_EMsgPurchaseHeroRelicResponse = 8257,
    k_EMsgPurchaseHeroRandomRelic = 8258,
    k_EMsgPurchaseHeroRandomRelicResponse = 8259,
    k_EMsgClientToGCClaimEventActionUsingItem = 8260,
    k_EMsgClientToGCClaimEventActionUsingItemResponse = 8261,
    k_EMsgPartyReadyCheckRequest = 8262,
    k_EMsgPartyReadyCheckResponse = 8263,
    k_EMsgPartyReadyCheckAcknowledge = 8264,
    k_EMsgGetRecentPlayTimeFriendsRequest = 8265,
    k_EMsgGetRecentPlayTimeFriendsResponse = 8266,
    k_EMsgGCToClientCommendNotification = 8267,
    k_EMsgProfileRequest = 8268,
    k_EMsgProfileResponse = 8269,
    k_EMsgProfileUpdate = 8270,
    k_EMsgProfileUpdateResponse = 8271,
    k_EMsgSuccessfulHero = 8273,
    k_EMsgHeroGlobalDataRequest = 8274,
    k_EMsgHeroGlobalDataResponse = 8275,
    k_EMsgClientToGCRequestPlusWeeklyChallengeResult = 8276,
    k_EMsgClientToGCRequestPlusWeeklyChallengeResultResponse = 8277,
    k_EMsgGCToGCGrantPlusPrepaidTime = 8278,
    k_EMsgPrivateMetadataKeyRequest = 8279,
    k_EMsgPrivateMetadataKeyResponse = 8280,
    k_EMsgGCToGCReconcilePlusStatus = 8281,
    k_EMsgGCToGCCheckPlusStatus = 8282,
    k_EMsgGCToGCCheckPlusStatusResponse = 8283,
    k_EMsgGCToGCReconcilePlusAutoGrantItems = 8284,
    k_EMsgGCToGCReconcilePlusStatusUnreliable = 8285,
    k_EMsgActivatePlusFreeTrialRequest = 8286,
    k_EMsgActivatePlusFreeTrialResponse = 8287,
    k_EMsgGCToClientCavernCrawlMapPathCompleted = 8288,
    k_EMsgClientToGCCavernCrawlClaimRoom = 8289,
    k_EMsgClientToGCCavernCrawlClaimRoomResponse = 8290,
    k_EMsgClientToGCCavernCrawlUseItemOnRoom = 8291,
    k_EMsgClientToGCCavernCrawlUseItemOnRoomResponse = 8292,
    k_EMsgClientToGCCavernCrawlUseItemOnPath = 8293,
    k_EMsgClientToGCCavernCrawlUseItemOnPathResponse = 8294,
    k_EMsgClientToGCCavernCrawlRequestMapState = 8295,
    k_EMsgClientToGCCavernCrawlRequestMapStateResponse = 8296,
    k_EMsgSignOutTips = 8297,
    k_EMsgClientToGCRequestEventPointLogV2 = 8298,
    k_EMsgClientToGCRequestEventPointLogResponseV2 = 8299,
    k_EMsgClientToGCRequestEventTipsSummary = 8300,
    k_EMsgClientToGCRequestEventTipsSummaryResponse = 8301,
    k_EMsgHeroGlobalDataAllHeroes = 8302,
    k_EMsgClientToGCRequestSocialFeed = 8303,
    k_EMsgClientToGCRequestSocialFeedResponse = 8304,
    k_EMsgClientToGCRequestSocialFeedComments = 8305,
    k_EMsgClientToGCRequestSocialFeedCommentsResponse = 8306,
    k_EMsgClientToGCCavernCrawlGetClaimedRoomCount = 8308,
    k_EMsgClientToGCCavernCrawlGetClaimedRoomCountResponse = 8309,
    k_EMsgGCToGCReconcilePlusAutoGrantItemsUnreliable = 8310,
    k_EMsgServerToGCAddBroadcastTimelineEvent = 8311,
    k_EMsgGCToServerUpdateSteamBroadcasting = 8312,
    k_EMsgClientToGCRecordContestVote = 8313,
    k_EMsgGCToClientRecordContestVoteResponse = 8314,
    k_EMsgGCToGCGrantAutograph = 8315,
    k_EMsgGCToGCGrantAutographResponse = 8316,
    k_EMsgSignOutConsumableUsage = 8317,
    k_EMsgLobbyEventGameDetails = 8318,
    k_EMsgDevGrantEventPoints = 8319,
    k_EMsgDevGrantEventPointsResponse = 8320,
    k_EMsgDevGrantEventAction = 8321,
    k_EMsgDevGrantEventActionResponse = 8322,
    k_EMsgDevResetEventState = 8323,
    k_EMsgDevResetEventStateResponse = 8324,
    k_EMsgGCToGCReconcileEventOwnership = 8325,
    k_EMsgConsumeEventSupportGrantItem = 8326,
    k_EMsgConsumeEventSupportGrantItemResponse = 8327,
    k_EMsgGCToClientClaimEventActionUsingItemCompleted = 8328,
    k_EMsgGCToClientCavernCrawlMapUpdated = 8329,
    k_EMsgServerToGCRequestPlayerRecentAccomplishments = 8330,
    k_EMsgServerToGCRequestPlayerRecentAccomplishmentsResponse = 8331,
    k_EMsgClientToGCRequestPlayerRecentAccomplishments = 8332,
    k_EMsgClientToGCRequestPlayerRecentAccomplishmentsResponse = 8333,
    k_EMsgClientToGCRequestPlayerHeroRecentAccomplishments = 8334,
    k_EMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse = 8335,
    k_EMsgSignOutEventActionGrants = 8336,
    k_EMsgClientToGCRequestPlayerCoachMatches = 8337,
    k_EMsgClientToGCRequestPlayerCoachMatchesResponse = 8338,
    k_EMsgClientToGCGetTicketCodesRequest = 8339,
    k_EMsgClientToGCGetTicketCodesResponse = 8340,
    k_EMsgClientToGCSubmitCoachTeammateRating = 8341,
    k_EMsgClientToGCSubmitCoachTeammateRatingResponse = 8342,
    k_EMsgGCToClientCoachTeammateRatingsChanged = 8343,
    k_EMsgClientToGCVoteForLeagueGameMVP = 8344,
    k_EMsgClientToGCRequestPlayerCoachMatch = 8345,
    k_EMsgClientToGCRequestPlayerCoachMatchResponse = 8346,
    k_EMsgClientToGCRequestContestVotes = 8347,
    k_EMsgClientToGCRequestContestVotesResponse = 8348,
    k_EMsgClientToGCMVPVoteTimeout = 8349,
    k_EMsgClientToGCMVPVoteTimeoutResponse = 8350,
    k_EMsgClientToGCGetUnderlordsCDKeyRequest = 8351,
    k_EMsgClientToGCGetUnderlordsCDKeyResponse = 8352,
    k_EMsgDetailedGameStats = 8353,
    k_EMsgClientToGCSetFavoriteAllStarPlayer = 8354,
    k_EMsgClientToGCSetFavoriteAllStarPlayerResponse = 8355,
    k_EMsgAllStarStats = 8356,
    k_EMsgClientToGCGetFavoriteAllStarPlayerRequest = 8357,
    k_EMsgClientToGCGetFavoriteAllStarPlayerResponse = 8358,
    k_EMsgClientToGCVerifyIntegrity = 8359,
    k_EMsgMatchMatchmakingStats = 8360,
    k_EMsgClientToGCSubmitPlayerMatchSurvey = 8361,
    k_EMsgClientToGCSubmitPlayerMatchSurveyResponse = 8362,
    k_EMsgSQLGCToGCGrantAllHeroProgressAccount = 8363,
    k_EMsgSQLGCToGCGrantAllHeroProgressVictory = 8364,
    k_eMsgGCToGCGetAllHeroCurrent = 8635,
    k_eMsgGCToGCGetAllHeroCurrentResponse = 8636,
    k_EMsgGCSubmitPlayerAvoidRequest = 8637,
    k_EMsgGCSubmitPlayerAvoidRequestResponse = 8638,
    k_EMsgGCToClientNotificationsUpdated = 8639,
    k_EMsgGCtoGCAssociatedExploiterAccountInfo = 8640,
    k_EMsgGCtoGCAssociatedExploiterAccountInfoResponse = 8641,
    k_EMsgGCtoGCRequestRecalibrationCheck = 8642,
};

inline std::string EDOTAGCMsg2String( EDOTAGCMsg msg )
{
    switch( msg ){
        CASE_STD_STRING(k_EMsgGCDOTABase);
        CASE_STD_STRING(k_EMsgGCGeneralResponse);
        CASE_STD_STRING(k_EMsgGCGameMatchSignOut);
        CASE_STD_STRING(k_EMsgGCGameMatchSignOutResponse);
        CASE_STD_STRING(k_EMsgGCJoinChatChannel);
        CASE_STD_STRING(k_EMsgGCJoinChatChannelResponse);
        CASE_STD_STRING(k_EMsgGCOtherJoinedChannel);
        CASE_STD_STRING(k_EMsgGCOtherLeftChannel);
        CASE_STD_STRING(k_EMsgGCMatchHistoryList);
        CASE_STD_STRING(k_EMsgServerToGCRequestStatus);
        CASE_STD_STRING(k_EMsgGCGetRecentMatches);
        CASE_STD_STRING(k_EMsgGCRecentMatchesResponse);
        CASE_STD_STRING(k_EMsgGCStartFindingMatch);
        CASE_STD_STRING(k_EMsgGCConnectedPlayers);
        CASE_STD_STRING(k_EMsgGCAbandonCurrentGame);
        CASE_STD_STRING(k_EMsgGCStopFindingMatch);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyCreate);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyLeave);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyLaunch);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyList);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyListResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyJoin);
        CASE_STD_STRING(k_EMsgGCPracticeLobbySetDetails);
        CASE_STD_STRING(k_EMsgGCPracticeLobbySetTeamSlot);
        CASE_STD_STRING(k_EMsgGCInitialQuestionnaireResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyResponse);
        CASE_STD_STRING(k_EMsgGCBroadcastNotification);
        CASE_STD_STRING(k_EMsgGCLiveScoreboardUpdate);
        CASE_STD_STRING(k_EMsgGCRequestChatChannelList);
        CASE_STD_STRING(k_EMsgGCRequestChatChannelListResponse);
        CASE_STD_STRING(k_EMsgGCRequestMatches);
        CASE_STD_STRING(k_EMsgGCRequestMatchesResponse);
        CASE_STD_STRING(k_EMsgGCRequestPlayerResources);
        CASE_STD_STRING(k_EMsgGCRequestPlayerResourcesResponse);
        CASE_STD_STRING(k_EMsgGCReadyUp);
        CASE_STD_STRING(k_EMsgGCKickedFromMatchmakingQueue);
        CASE_STD_STRING(k_EMsgGCLeaverDetected);
        CASE_STD_STRING(k_EMsgGCSpectateFriendGame);
        CASE_STD_STRING(k_EMsgGCSpectateFriendGameResponse);
        CASE_STD_STRING(k_EMsgGCPlayerReports);
        CASE_STD_STRING(k_EMsgGCReportsRemainingRequest);
        CASE_STD_STRING(k_EMsgGCReportsRemainingResponse);
        CASE_STD_STRING(k_EMsgGCSubmitPlayerReport);
        CASE_STD_STRING(k_EMsgGCSubmitPlayerReportResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyKick);
        CASE_STD_STRING(k_EMsgGCReportCountsRequest);
        CASE_STD_STRING(k_EMsgGCReportCountsResponse);
        CASE_STD_STRING(k_EMsgGCRequestSaveGames);
        CASE_STD_STRING(k_EMsgGCRequestSaveGamesServer);
        CASE_STD_STRING(k_EMsgGCRequestSaveGamesResponse);
        CASE_STD_STRING(k_EMsgGCLeaverDetectedResponse);
        CASE_STD_STRING(k_EMsgGCPlayerFailedToConnect);
        CASE_STD_STRING(k_EMsgGCGCToRelayConnect);
        CASE_STD_STRING(k_EMsgGCGCToRelayConnectresponse);
        CASE_STD_STRING(k_EMsgGCWatchGame);
        CASE_STD_STRING(k_EMsgGCWatchGameResponse);
        CASE_STD_STRING(k_EMsgGCBanStatusRequest);
        CASE_STD_STRING(k_EMsgGCBanStatusResponse);
        CASE_STD_STRING(k_EMsgGCMatchDetailsRequest);
        CASE_STD_STRING(k_EMsgGCMatchDetailsResponse);
        CASE_STD_STRING(k_EMsgGCCancelWatchGame);
        CASE_STD_STRING(k_EMsgGCPopup);
        CASE_STD_STRING(k_EMsgGCDOTAClearNotifySuccessfulReport);
        CASE_STD_STRING(k_EMsgGCFriendPracticeLobbyListRequest);
        CASE_STD_STRING(k_EMsgGCFriendPracticeLobbyListResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyJoinResponse);
        CASE_STD_STRING(k_EMsgClientEconNotification_Job);
        CASE_STD_STRING(k_EMsgGCCreateTeam);
        CASE_STD_STRING(k_EMsgGCCreateTeamResponse);
        CASE_STD_STRING(k_EMsgGCTeamData);
        CASE_STD_STRING(k_EMsgGCTeamInvite_InviterToGC);
        CASE_STD_STRING(k_EMsgGCTeamInvite_GCImmediateResponseToInviter);
        CASE_STD_STRING(k_EMsgGCTeamInvite_GCRequestToInvitee);
        CASE_STD_STRING(k_EMsgGCTeamInvite_InviteeResponseToGC);
        CASE_STD_STRING(k_EMsgGCTeamInvite_GCResponseToInviter);
        CASE_STD_STRING(k_EMsgGCTeamInvite_GCResponseToInvitee);
        CASE_STD_STRING(k_EMsgGCKickTeamMember);
        CASE_STD_STRING(k_EMsgGCKickTeamMemberResponse);
        CASE_STD_STRING(k_EMsgGCLeaveTeam);
        CASE_STD_STRING(k_EMsgGCLeaveTeamResponse);
        CASE_STD_STRING(k_EMsgGCSuggestTeamMatchmaking);
        CASE_STD_STRING(k_EMsgGCPlayerHeroesFavoritesAdd);
        CASE_STD_STRING(k_EMsgGCPlayerHeroesFavoritesRemove);
        CASE_STD_STRING(k_EMsgGCApplyTeamToPracticeLobby);
        CASE_STD_STRING(k_EMsgGCTransferTeamAdmin);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyJoinBroadcastChannel);
        CASE_STD_STRING(k_EMsgGC_TournamentItemEvent);
        CASE_STD_STRING(k_EMsgGC_TournamentItemEventResponse);
        CASE_STD_STRING(k_EMsgCastMatchVote);
        CASE_STD_STRING(k_EMsgCastMatchVoteResponse);
        CASE_STD_STRING(k_EMsgRetrieveMatchVote);
        CASE_STD_STRING(k_EMsgRetrieveMatchVoteResponse);
        CASE_STD_STRING(k_EMsgTeamFanfare);
        CASE_STD_STRING(k_EMsgResponseTeamFanfare);
        CASE_STD_STRING(k_EMsgGC_GameServerUploadSaveGame);
        CASE_STD_STRING(k_EMsgGC_GameServerSaveGameResult);
        CASE_STD_STRING(k_EMsgGC_GameServerGetLoadGame);
        CASE_STD_STRING(k_EMsgGC_GameServerGetLoadGameResult);
        CASE_STD_STRING(k_EMsgGCEditTeamDetails);
        CASE_STD_STRING(k_EMsgGCEditTeamDetailsResponse);
        CASE_STD_STRING(k_EMsgGCProTeamListRequest);
        CASE_STD_STRING(k_EMsgGCProTeamListResponse);
        CASE_STD_STRING(k_EMsgGCReadyUpStatus);
        CASE_STD_STRING(k_EMsgGCHallOfFame);
        CASE_STD_STRING(k_EMsgGCHallOfFameRequest);
        CASE_STD_STRING(k_EMsgGCHallOfFameResponse);
        CASE_STD_STRING(k_EMsgGCGenerateDiretidePrizeList);
        CASE_STD_STRING(k_EMsgGCRewardDiretidePrizes);
        CASE_STD_STRING(k_EMsgGCDiretidePrizesRewardedResponse);
        CASE_STD_STRING(k_EMsgGCHalloweenHighScoreRequest);
        CASE_STD_STRING(k_EMsgGCHalloweenHighScoreResponse);
        CASE_STD_STRING(k_EMsgGCGenerateDiretidePrizeListResponse);
        CASE_STD_STRING(k_EMsgGCStorePromoPagesRequest);
        CASE_STD_STRING(k_EMsgGCStorePromoPagesResponse);
        CASE_STD_STRING(k_EMsgGCToGCMatchCompleted);
        CASE_STD_STRING(k_EMsgGCBalancedShuffleLobby);
        CASE_STD_STRING(k_EMsgGCToGCCheckLeaguePermission);
        CASE_STD_STRING(k_EMsgGCToGCCheckLeaguePermissionResponse);
        CASE_STD_STRING(k_EMsgGCMatchmakingStatsRequest);
        CASE_STD_STRING(k_EMsgGCMatchmakingStatsResponse);
        CASE_STD_STRING(k_EMsgGCBotGameCreate);
        CASE_STD_STRING(k_EMsgGCSetMatchHistoryAccess);
        CASE_STD_STRING(k_EMsgGCSetMatchHistoryAccessResponse);
        CASE_STD_STRING(k_EMsgUpgradeLeagueItem);
        CASE_STD_STRING(k_EMsgUpgradeLeagueItemResponse);
        CASE_STD_STRING(k_EMsgGCTeamMemberProfileRequest);
        CASE_STD_STRING(k_EMsgGCWatchDownloadedReplay);
        CASE_STD_STRING(k_EMsgGCSetMapLocationState);
        CASE_STD_STRING(k_EMsgGCSetMapLocationStateResponse);
        CASE_STD_STRING(k_EMsgGCResetMapLocations);
        CASE_STD_STRING(k_EMsgGCResetMapLocationsResponse);
        CASE_STD_STRING(k_EMsgRefreshPartnerAccountLink);
        CASE_STD_STRING(k_EMsgClientsRejoinChatChannels);
        CASE_STD_STRING(k_EMsgGCToGCGetUserChatInfo);
        CASE_STD_STRING(k_EMsgGCToGCGetUserChatInfoResponse);
        CASE_STD_STRING(k_EMsgGCToGCLeaveAllChatChannels);
        CASE_STD_STRING(k_EMsgGCToGCUpdateAccountChatBan);
        CASE_STD_STRING(k_EMsgGCGuildCreateRequest);
        CASE_STD_STRING(k_EMsgGCGuildCreateResponse);
        CASE_STD_STRING(k_EMsgGCGuildSetAccountRoleRequest);
        CASE_STD_STRING(k_EMsgGCGuildSetAccountRoleResponse);
        CASE_STD_STRING(k_EMsgGCRequestGuildData);
        CASE_STD_STRING(k_EMsgGCGuildData);
        CASE_STD_STRING(k_EMsgGCGuildInviteAccountRequest);
        CASE_STD_STRING(k_EMsgGCGuildInviteAccountResponse);
        CASE_STD_STRING(k_EMsgGCGuildCancelInviteRequest);
        CASE_STD_STRING(k_EMsgGCGuildCancelInviteResponse);
        CASE_STD_STRING(k_EMsgGCGuildUpdateDetailsRequest);
        CASE_STD_STRING(k_EMsgGCGuildUpdateDetailsResponse);
        CASE_STD_STRING(k_EMsgGCToGCCanInviteUserToTeam);
        CASE_STD_STRING(k_EMsgGCToGCCanInviteUserToTeamResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetUserRank);
        CASE_STD_STRING(k_EMsgGCToGCGetUserRankResponse);
        CASE_STD_STRING(k_EMsgGCToGCUpdateTeamStats);
        CASE_STD_STRING(k_EMsgGCToGCValidateTeam);
        CASE_STD_STRING(k_EMsgGCToGCValidateTeamResponse);
        CASE_STD_STRING(k_EMsgGCPassportDataRequest);
        CASE_STD_STRING(k_EMsgGCPassportDataResponse);
        CASE_STD_STRING(k_EMsgGCNotInGuildData);
        CASE_STD_STRING(k_EMsgGCGuildInviteData);
        CASE_STD_STRING(k_EMsgGCToGCGetLeagueAdmin);
        CASE_STD_STRING(k_EMsgGCToGCGetLeagueAdminResponse);
        CASE_STD_STRING(k_EMsgGCRequestLeaguePrizePool);
        CASE_STD_STRING(k_EMsgGCRequestLeaguePrizePoolResponse);
        CASE_STD_STRING(k_EMsgGCToGCUpdateOpenGuildPartyRequest);
        CASE_STD_STRING(k_EMsgGCToGCUpdateOpenGuildPartyResponse);
        CASE_STD_STRING(k_EMsgGCToGCDestroyOpenGuildPartyRequest);
        CASE_STD_STRING(k_EMsgGCToGCDestroyOpenGuildPartyResponse);
        CASE_STD_STRING(k_EMsgGCGuildUpdateMessage);
        CASE_STD_STRING(k_EMsgGCPartySetOpenGuildRequest);
        CASE_STD_STRING(k_EMsgGCPartySetOpenGuildResponse);
        CASE_STD_STRING(k_EMsgGCGuildOpenPartyRefresh);
        CASE_STD_STRING(k_EMsgGCJoinOpenGuildPartyRequest);
        CASE_STD_STRING(k_EMsgGCJoinOpenGuildPartyResponse);
        CASE_STD_STRING(k_EMsgGCLeaveChatChannel);
        CASE_STD_STRING(k_EMsgGCChatMessage);
        CASE_STD_STRING(k_EMsgGCGetHeroStandings);
        CASE_STD_STRING(k_EMsgGCGetHeroStandingsResponse);
        CASE_STD_STRING(k_EMsgGCGuildEditLogoRequest);
        CASE_STD_STRING(k_EMsgGCGuildEditLogoResponse);
        CASE_STD_STRING(k_EMsgGCGuildmatePracticeLobbyListRequest);
        CASE_STD_STRING(k_EMsgGCGuildmatePracticeLobbyListResponse);
        CASE_STD_STRING(k_EMsgGCItemEditorReservationsRequest);
        CASE_STD_STRING(k_EMsgGCItemEditorReservationsResponse);
        CASE_STD_STRING(k_EMsgGCItemEditorReserveItemDef);
        CASE_STD_STRING(k_EMsgGCItemEditorReserveItemDefResponse);
        CASE_STD_STRING(k_EMsgGCItemEditorReleaseReservation);
        CASE_STD_STRING(k_EMsgGCItemEditorReleaseReservationResponse);
        CASE_STD_STRING(k_EMsgGCRewardTutorialPrizes);
        CASE_STD_STRING(k_EMsgGCLastHitChallengeHighScorePost);
        CASE_STD_STRING(k_EMsgGCLastHitChallengeHighScoreRequest);
        CASE_STD_STRING(k_EMsgGCLastHitChallengeHighScoreResponse);
        CASE_STD_STRING(k_EMsgGCCreateFantasyLeagueRequest);
        CASE_STD_STRING(k_EMsgGCCreateFantasyLeagueResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueInfoRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueInfoResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueInfo);
        CASE_STD_STRING(k_EMsgGCCreateFantasyTeamRequest);
        CASE_STD_STRING(k_EMsgGCCreateFantasyTeamResponse);
        CASE_STD_STRING(k_EMsgGCEditFantasyTeamRequest);
        CASE_STD_STRING(k_EMsgGCEditFantasyTeamResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamInfoRequestByFantasyLeagueID);
        CASE_STD_STRING(k_EMsgGCFantasyTeamInfoRequestByOwnerAccountID);
        CASE_STD_STRING(k_EMsgGCFantasyTeamInfoResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamInfo);
        CASE_STD_STRING(k_EMsgGCFantasyLivePlayerStats);
        CASE_STD_STRING(k_EMsgGCFantasyFinalPlayerStats);
        CASE_STD_STRING(k_EMsgGCFantasyMatch);
        CASE_STD_STRING(k_EMsgGCFantasyTeamScoreRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamScoreResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamStandingsRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamStandingsResponse);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerScoreRequest);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerScoreResponse);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerStandingsRequest);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerStandingsResponse);
        CASE_STD_STRING(k_EMsgGCFlipLobbyTeams);
        CASE_STD_STRING(k_EMsgGCCustomGameCreate);
        CASE_STD_STRING(k_EMsgGCToGCProcessPlayerReportForTarget);
        CASE_STD_STRING(k_EMsgGCToGCProcessReportSuccess);
        CASE_STD_STRING(k_EMsgGCNotifyAccountFlagsChange);
        CASE_STD_STRING(k_EMsgGCSetProfilePrivacy);
        CASE_STD_STRING(k_EMsgGCSetProfilePrivacyResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueCreateInfoRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueCreateInfoResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueInviteInfoRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueInviteInfoResponse);
        CASE_STD_STRING(k_EMsgGCClientIgnoredUser);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueCreateRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueCreateResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamCreateRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamCreateResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueFriendJoinListRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueFriendJoinListResponse);
        CASE_STD_STRING(k_EMsgGCClientSuspended);
        CASE_STD_STRING(k_EMsgGCPartyMemberSetCoach);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueEditInvitesRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueEditInvitesResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbySetCoach);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueEditInfoRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueEditInfoResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueDraftStatusRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueDraftStatus);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueDraftPlayerRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueDraftPlayerResponse);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueMatchupsRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeagueMatchupsResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterSwapRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterSwapResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterAddDropRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamRosterAddDropResponse);
        CASE_STD_STRING(k_EMsgPresentedClientTerminateDlg);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerHisoricalStatsRequest);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerHisoricalStatsResponse);
        CASE_STD_STRING(k_EMsgGCPCBangTimedRewardMessage);
        CASE_STD_STRING(k_EMsgGCLobbyUpdateBroadcastChannelInfo);
        CASE_STD_STRING(k_EMsgGCFantasyTeamTradesRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamTradesResponse);
        CASE_STD_STRING(k_EMsgGCFantasyTeamTradeCancelRequest);
        CASE_STD_STRING(k_EMsgGCFantasyTeamTradeCancelResponse);
        CASE_STD_STRING(k_EMsgGCToGCGrantTournamentItem);
        CASE_STD_STRING(k_EMsgGCProcessFantasyScheduledEvent);
        CASE_STD_STRING(k_EMsgGCToGCUpgradeTwitchViewerItems);
        CASE_STD_STRING(k_EMsgGCToGCGetLiveMatchAffiliates);
        CASE_STD_STRING(k_EMsgGCToGCGetLiveMatchAffiliatesResponse);
        CASE_STD_STRING(k_EMsgGCToGCUpdatePlayerPennantCounts);
        CASE_STD_STRING(k_EMsgGCToGCGetPlayerPennantCounts);
        CASE_STD_STRING(k_EMsgGCToGCGetPlayerPennantCountsResponse);
        CASE_STD_STRING(k_EMsgGCGameMatchSignOutPermissionRequest);
        CASE_STD_STRING(k_EMsgGCGameMatchSignOutPermissionResponse);
        CASE_STD_STRING(k_EMsgDOTAChatChannelMemberUpdate);
        CASE_STD_STRING(k_EMsgDOTAAwardEventPoints);
        CASE_STD_STRING(k_EMsgDOTAGetEventPoints);
        CASE_STD_STRING(k_EMsgDOTAGetEventPointsResponse);
        CASE_STD_STRING(k_EMsgDOTASendFriendRecruits);
        CASE_STD_STRING(k_EMsgDOTAFriendRecruitsRequest);
        CASE_STD_STRING(k_EMsgDOTAFriendRecruitsResponse);
        CASE_STD_STRING(k_EMsgDOTAFriendRecruitInviteAcceptDecline);
        CASE_STD_STRING(k_EMsgGCPartyLeaderWatchGamePrompt);
        CASE_STD_STRING(k_EMsgDOTAFrostivusTimeElapsed);
        CASE_STD_STRING(k_EMsgDOTALiveLeagueGameUpdate);
        CASE_STD_STRING(k_EMsgDOTAChatGetUserList);
        CASE_STD_STRING(k_EMsgDOTAChatGetUserListResponse);
        CASE_STD_STRING(k_EMsgGCCompendiumSetSelection);
        CASE_STD_STRING(k_EMsgGCCompendiumDataRequest);
        CASE_STD_STRING(k_EMsgGCCompendiumDataResponse);
        CASE_STD_STRING(k_EMsgDOTAGetPlayerMatchHistory);
        CASE_STD_STRING(k_EMsgDOTAGetPlayerMatchHistoryResponse);
        CASE_STD_STRING(k_EMsgGCToGCMatchmakingAddParty);
        CASE_STD_STRING(k_EMsgGCToGCMatchmakingRemoveParty);
        CASE_STD_STRING(k_EMsgGCToGCMatchmakingRemoveAllParties);
        CASE_STD_STRING(k_EMsgGCToGCMatchmakingMatchFound);
        CASE_STD_STRING(k_EMsgGCToGCUpdateMatchManagementStats);
        CASE_STD_STRING(k_EMsgGCToGCUpdateMatchmakingStats);
        CASE_STD_STRING(k_EMsgGCToServerPingRequest);
        CASE_STD_STRING(k_EMsgGCToServerPingResponse);
        CASE_STD_STRING(k_EMsgGCToServerConsoleCommand);
        CASE_STD_STRING(k_EMsgGCMakeOffering);
        CASE_STD_STRING(k_EMsgGCRequestOfferings);
        CASE_STD_STRING(k_EMsgGCRequestOfferingsResponse);
        CASE_STD_STRING(k_EMsgGCToGCProcessMatchLeaver);
        CASE_STD_STRING(k_EMsgGCNotificationsRequest);
        CASE_STD_STRING(k_EMsgGCNotificationsResponse);
        CASE_STD_STRING(k_EMsgGCToGCModifyNotification);
        CASE_STD_STRING(k_EMsgGCToGCSetNewNotifications);
        CASE_STD_STRING(k_EMsgGCLeagueAdminList);
        CASE_STD_STRING(k_EMsgGCNotificationsMarkReadRequest);
        CASE_STD_STRING(k_EMsgGCFantasyMessageAdd);
        CASE_STD_STRING(k_EMsgGCFantasyMessagesRequest);
        CASE_STD_STRING(k_EMsgGCFantasyMessagesResponse);
        CASE_STD_STRING(k_EMsgGCFantasyScheduledMatchesRequest);
        CASE_STD_STRING(k_EMsgGCFantasyScheduledMatchesResponse);
        CASE_STD_STRING(k_EMsgGCEventGameCreate);
        CASE_STD_STRING(k_EMsgGCPerfectWorldUserLookupRequest);
        CASE_STD_STRING(k_EMsgGCPerfectWorldUserLookupResponse);
        CASE_STD_STRING(k_EMsgGCFantasyRemoveOwner);
        CASE_STD_STRING(k_EMsgGCFantasyRemoveOwnerResponse);
        CASE_STD_STRING(k_EMsgGCRequestBatchPlayerResources);
        CASE_STD_STRING(k_EMsgGCRequestBatchPlayerResourcesResponse);
        CASE_STD_STRING(k_EMsgGCToGCSendUpdateLeagues);
        CASE_STD_STRING(k_EMsgGCCompendiumSetSelectionResponse);
        CASE_STD_STRING(k_EMsgGCPlayerInfoRequest);
        CASE_STD_STRING(k_EMsgGCPlayerInfo);
        CASE_STD_STRING(k_EMsgGCPlayerInfoSubmit);
        CASE_STD_STRING(k_EMsgGCPlayerInfoSubmitResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountLevel);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountLevelResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountPartner);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountPartnerResponse);
        CASE_STD_STRING(k_EMsgDOTAGetWeekendTourneySchedule);
        CASE_STD_STRING(k_EMsgDOTAWeekendTourneySchedule);
        CASE_STD_STRING(k_EMsgGCJoinableCustomGameModesRequest);
        CASE_STD_STRING(k_EMsgGCJoinableCustomGameModesResponse);
        CASE_STD_STRING(k_EMsgGCJoinableCustomLobbiesRequest);
        CASE_STD_STRING(k_EMsgGCJoinableCustomLobbiesResponse);
        CASE_STD_STRING(k_EMsgGCQuickJoinCustomLobby);
        CASE_STD_STRING(k_EMsgGCQuickJoinCustomLobbyResponse);
        CASE_STD_STRING(k_EMsgGCToGCGrantEventPointAction);
        CASE_STD_STRING(k_EMsgServerGrantSurveyPermission);
        CASE_STD_STRING(k_EMsgServerGrantSurveyPermissionResponse);
        CASE_STD_STRING(k_EMsgClientProvideSurveyResult);
        CASE_STD_STRING(k_EMsgGCToGCSetCompendiumSelection);
        CASE_STD_STRING(k_EMsgGCToGCUpdateTI4HeroQuest);
        CASE_STD_STRING(k_EMsgGCCompendiumDataChanged);
        CASE_STD_STRING(k_EMsgDOTAFantasyLeagueFindRequest);
        CASE_STD_STRING(k_EMsgDOTAFantasyLeagueFindResponse);
        CASE_STD_STRING(k_EMsgGCHasItemQuery);
        CASE_STD_STRING(k_EMsgGCHasItemResponse);
        CASE_STD_STRING(k_EMsgGCConsumeFantasyTicket);
        CASE_STD_STRING(k_EMsgGCConsumeFantasyTicketFailure);
        CASE_STD_STRING(k_EMsgGCToGCGrantEventPointActionMsg);
        CASE_STD_STRING(k_EMsgClientToGCTrackDialogResult);
        CASE_STD_STRING(k_EMsgGCFantasyLeaveLeagueRequest);
        CASE_STD_STRING(k_EMsgGCFantasyLeaveLeagueResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetCompendiumSelections);
        CASE_STD_STRING(k_EMsgGCToGCGetCompendiumSelectionsResponse);
        CASE_STD_STRING(k_EMsgServerToGCMatchConnectionStats);
        CASE_STD_STRING(k_EMsgGCToClientTournamentItemDrop);
        CASE_STD_STRING(k_EMsgSQLDelayedGrantLeagueDrop);
        CASE_STD_STRING(k_EMsgServerGCUpdateSpectatorCount);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerScoreDetailsRequest);
        CASE_STD_STRING(k_EMsgGCFantasyPlayerScoreDetailsResponse);
        CASE_STD_STRING(k_EMsgGCToGCEmoticonUnlock);
        CASE_STD_STRING(k_EMsgSignOutDraftInfo);
        CASE_STD_STRING(k_EMsgClientToGCEmoticonDataRequest);
        CASE_STD_STRING(k_EMsgGCToClientEmoticonData);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyToggleBroadcastChannelCameramanStatus);
        CASE_STD_STRING(k_EMsgGCToGCCreateWeekendTourneyRequest);
        CASE_STD_STRING(k_EMsgGCToGCCreateWeekendTourneyResponse);
        CASE_STD_STRING(k_EMsgClientToGCSetAdditionalEquips);
        CASE_STD_STRING(k_EMsgClientToGCGetAdditionalEquips);
        CASE_STD_STRING(k_EMsgClientToGCGetAdditionalEquipsResponse);
        CASE_STD_STRING(k_EMsgServerToGCGetAdditionalEquips);
        CASE_STD_STRING(k_EMsgServerToGCGetAdditionalEquipsResponse);
        CASE_STD_STRING(k_EMsgDOTARedeemItem);
        CASE_STD_STRING(k_EMsgDOTARedeemItemResponse);
        CASE_STD_STRING(k_EMsgSQLGCToGCGrantAllHeroProgress);
        CASE_STD_STRING(k_EMsgClientToGCGetAllHeroProgress);
        CASE_STD_STRING(k_EMsgClientToGCGetAllHeroProgressResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetServerForClient);
        CASE_STD_STRING(k_EMsgGCToGCGetServerForClientResponse);
        CASE_STD_STRING(k_EMsgSQLProcessTournamentGameOutcome);
        CASE_STD_STRING(k_EMsgSQLGrantTrophyToAccount);
        CASE_STD_STRING(k_EMsgClientToGCGetTrophyList);
        CASE_STD_STRING(k_EMsgClientToGCGetTrophyListResponse);
        CASE_STD_STRING(k_EMsgGCToClientTrophyAwarded);
        CASE_STD_STRING(k_EMsgGCGameBotMatchSignOut);
        CASE_STD_STRING(k_EMsgGCGameBotMatchSignOutPermissionRequest);
        CASE_STD_STRING(k_EMsgSignOutBotInfo);
        CASE_STD_STRING(k_EMsgGCToGCUpdateProfileCards);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileCard);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileCardResponse);
        CASE_STD_STRING(k_EMsgServerToGCGetProfileCard);
        CASE_STD_STRING(k_EMsgServerToGCGetProfileCardResponse);
        CASE_STD_STRING(k_EMsgClientToGCSetProfileCardSlots);
        CASE_STD_STRING(k_EMsgGCToClientProfileCardUpdated);
        CASE_STD_STRING(k_EMsgServerToGCVictoryPredictions);
        CASE_STD_STRING(k_EMsgClientToGCMarkNotificationListRead);
        CASE_STD_STRING(k_EMsgServerToGCSuspiciousActivity);
        CASE_STD_STRING(k_EMsgSignOutCommunicationSummary);
        CASE_STD_STRING(k_EMsgServerToGCRequestStatus_Response);
        CASE_STD_STRING(k_EMsgClientToGCCreateHeroStatue);
        CASE_STD_STRING(k_EMsgGCToClientHeroStatueCreateResult);
        CASE_STD_STRING(k_EMsgGCGCToLANServerRelayConnect);
        CASE_STD_STRING(k_EMsgServerToGCGetIngameEventData);
        CASE_STD_STRING(k_EMsgGCToGCUpdateIngameEventDataBroadcast);
        CASE_STD_STRING(k_EMsgGCToServerIngameEventData_OraclePA);
        CASE_STD_STRING(k_EMsgServerToGCReportKillSummaries);
        CASE_STD_STRING(k_EMsgGCToGCReportKillSummaries);
        CASE_STD_STRING(k_EMsgGCToGCUpdateAssassinMinigame);
        CASE_STD_STRING(k_EMsgGCToGCFantasySetMatchLeague);
        CASE_STD_STRING(k_EMsgGCToGCUpdatePlayerPredictions);
        CASE_STD_STRING(k_EMsgGCToServerPredictionResult);
        CASE_STD_STRING(k_EMsgServerToGCSignoutAwardAdditionalDrops);
        CASE_STD_STRING(k_EMsgGCToGCSignoutAwardAdditionalDrops);
        CASE_STD_STRING(k_EMsgGCToClientEventStatusChanged);
        CASE_STD_STRING(k_EMsgGCHasItemDefsQuery);
        CASE_STD_STRING(k_EMsgGCHasItemDefsResponse);
        CASE_STD_STRING(k_EMsgGCToGCReplayMonitorValidateReplay);
        CASE_STD_STRING(k_EMsgLobbyEventPoints);
        CASE_STD_STRING(k_EMsgGCToGCGetCustomGameTickets);
        CASE_STD_STRING(k_EMsgGCToGCGetCustomGameTicketsResponse);
        CASE_STD_STRING(k_EMsgGCToGCCustomGamePlayed);
        CASE_STD_STRING(k_EMsgGCToGCGrantEventPointsToUser);
        CASE_STD_STRING(k_EMsgGCToGCSetEventMMPanicFlushTime);
        CASE_STD_STRING(k_EMsgGameserverCrashReport);
        CASE_STD_STRING(k_EMsgGameserverCrashReportResponse);
        CASE_STD_STRING(k_EMsgGCToClientSteamDatagramTicket);
        CASE_STD_STRING(k_EMsgGCToGCGrantEventOwnership);
        CASE_STD_STRING(k_EMsgGCToGCSendAccountsEventPoints);
        CASE_STD_STRING(k_EMsgClientToGCRerollPlayerChallenge);
        CASE_STD_STRING(k_EMsgServerToGCRerollPlayerChallenge);
        CASE_STD_STRING(k_EMsgGCRerollPlayerChallengeResponse);
        CASE_STD_STRING(k_EMsgSignOutUpdatePlayerChallenge);
        CASE_STD_STRING(k_EMsgClientToGCSetPartyLeader);
        CASE_STD_STRING(k_EMsgClientToGCCancelPartyInvites);
        CASE_STD_STRING(k_EMsgGCToGCMasterReloadAccount);
        CASE_STD_STRING(k_EMsgSQLGrantLeagueMatchToTicketHolders);
        CASE_STD_STRING(k_EMsgClientToGCSetAdditionalEquipsResponse);
        CASE_STD_STRING(k_EMsgGCToGCEmoticonUnlockNoRollback);
        CASE_STD_STRING(k_EMsgGCToGCGetCompendiumFanfare);
        CASE_STD_STRING(k_EMsgGCToGCChatNewUserSession);
        CASE_STD_STRING(k_EMsgClientToGCApplyGemCombiner);
        CASE_STD_STRING(k_EMsgClientToGCDOTACreateStaticRecipe);
        CASE_STD_STRING(k_EMsgClientToGCDOTACreateStaticRecipeResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetAllHeroOrder);
        CASE_STD_STRING(k_EMsgClientToGCGetAllHeroOrderResponse);
        CASE_STD_STRING(k_EMsgSQLGCToGCGrantBadgePoints);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountMatchStatus);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountMatchStatusResponse);
        CASE_STD_STRING(k_EMsgGCToGCCheckOwnsEntireEmoticonRange);
        CASE_STD_STRING(k_EMsgGCToGCCheckOwnsEntireEmoticonRangeResponse);
        CASE_STD_STRING(k_EMsgClientToGCRecycleHeroRelic);
        CASE_STD_STRING(k_EMsgClientToGCRecycleHeroRelicResponse);
        CASE_STD_STRING(k_EMsgGCToGCRevokeEventOwnership);
        CASE_STD_STRING(k_EMsgGCToGCUnlockEventPointSpending);
        CASE_STD_STRING(k_EMsgGCToClientRequestLaneSelection);
        CASE_STD_STRING(k_EMsgGCToClientRequestLaneSelectionResponse);
        CASE_STD_STRING(k_EMsgServerToGCCavernCrawlIsHeroActive);
        CASE_STD_STRING(k_EMsgServerToGCCavernCrawlIsHeroActiveResponse);
        CASE_STD_STRING(k_EMsgClientToGCPlayerCardSpecificPurchaseRequest);
        CASE_STD_STRING(k_EMsgClientToGCPlayerCardSpecificPurchaseResponse);
        CASE_STD_STRING(k_EMsgGCtoServerTensorflowInstance);
        CASE_STD_STRING(k_EMsgSQLSetIsLeagueAdmin);
        CASE_STD_STRING(k_EMsgGCToGCGetLiveLeagueMatches);
        CASE_STD_STRING(k_EMsgGCToGCGetLiveLeagueMatchesResponse);
        CASE_STD_STRING(k_EMsgDOTALeagueInfoListAdminsRequest);
        CASE_STD_STRING(k_EMsgDOTALeagueInfoListAdminsReponse);
        CASE_STD_STRING(k_EMsgGCToGCLeagueMatchStarted);
        CASE_STD_STRING(k_EMsgGCToGCLeagueMatchCompleted);
        CASE_STD_STRING(k_EMsgGCToGCLeagueMatchStartedResponse);
        CASE_STD_STRING(k_EMsgDOTALeagueNodeRequest);
        CASE_STD_STRING(k_EMsgDOTALeagueNodeResponse);
        CASE_STD_STRING(k_EMsgDOTALeagueAvailableLobbyNodesRequest);
        CASE_STD_STRING(k_EMsgDOTALeagueAvailableLobbyNodes);
        CASE_STD_STRING(k_EMsgGCToGCLeagueRequest);
        CASE_STD_STRING(k_EMsgGCToGCLeagueResponse);
        CASE_STD_STRING(k_EMsgGCToGCLeagueNodeGroupRequest);
        CASE_STD_STRING(k_EMsgGCToGCLeagueNodeGroupResponse);
        CASE_STD_STRING(k_EMsgGCToGCLeagueNodeRequest);
        CASE_STD_STRING(k_EMsgGCToGCLeagueNodeResponse);
        CASE_STD_STRING(k_EMsgGCToGCRealtimeStatsTerseRequest);
        CASE_STD_STRING(k_EMsgGCToGCRealtimeStatsTerseResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetTopMatchesRequest);
        CASE_STD_STRING(k_EMsgGCToGCGetTopMatchesResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetFilteredPlayers);
        CASE_STD_STRING(k_EMsgGCToClientGetFilteredPlayersResponse);
        CASE_STD_STRING(k_EMsgClientToGCRemoveFilteredPlayer);
        CASE_STD_STRING(k_EMsgGCToClientRemoveFilteredPlayerResponse);
        CASE_STD_STRING(k_EMsgGCToClientPlayerBeaconState);
        CASE_STD_STRING(k_EMsgGCToClientPartyBeaconUpdate);
        CASE_STD_STRING(k_EMsgGCToClientPartySearchInvite);
        CASE_STD_STRING(k_EMsgClientToGCUpdatePartyBeacon);
        CASE_STD_STRING(k_EMsgClientToGCRequestActiveBeaconParties);
        CASE_STD_STRING(k_EMsgGCToClientRequestActiveBeaconPartiesResponse);
        CASE_STD_STRING(k_EMsgClientToGCManageFavorites);
        CASE_STD_STRING(k_EMsgGCToClientManageFavoritesResponse);
        CASE_STD_STRING(k_EMsgClientToGCJoinPartyFromBeacon);
        CASE_STD_STRING(k_EMsgGCToClientJoinPartyFromBeaconResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetFavoritePlayers);
        CASE_STD_STRING(k_EMsgGCToClientGetFavoritePlayersResponse);
        CASE_STD_STRING(k_EMsgClientToGCVerifyFavoritePlayers);
        CASE_STD_STRING(k_EMsgGCToClientVerifyFavoritePlayersResponse);
        CASE_STD_STRING(k_EMsgGCToClientPartySearchInvites);
        CASE_STD_STRING(k_EMsgGCToClientRequestMMInfo);
        CASE_STD_STRING(k_EMsgClientToGCMMInfo);
        CASE_STD_STRING(k_EMsgGCDev_GrantWarKill);
        CASE_STD_STRING(k_EMsgServerToGCLockCharmTrading);
        CASE_STD_STRING(k_EMsgClientToGCPlayerStatsRequest);
        CASE_STD_STRING(k_EMsgGCToClientPlayerStatsResponse);
        CASE_STD_STRING(k_EMsgGCClearPracticeLobbyTeam);
        CASE_STD_STRING(k_EMsgClientToGCFindTopSourceTVGames);
        CASE_STD_STRING(k_EMsgGCToClientFindTopSourceTVGamesResponse);
        CASE_STD_STRING(k_EMsgGCLobbyList);
        CASE_STD_STRING(k_EMsgGCLobbyListResponse);
        CASE_STD_STRING(k_EMsgGCPlayerStatsMatchSignOut);
        CASE_STD_STRING(k_EMsgClientToGCCustomGamePlayerCountRequest);
        CASE_STD_STRING(k_EMsgGCToClientCustomGamePlayerCountResponse);
        CASE_STD_STRING(k_EMsgClientToGCSocialFeedPostCommentRequest);
        CASE_STD_STRING(k_EMsgGCToClientSocialFeedPostCommentResponse);
        CASE_STD_STRING(k_EMsgClientToGCCustomGamesFriendsPlayedRequest);
        CASE_STD_STRING(k_EMsgGCToClientCustomGamesFriendsPlayedResponse);
        CASE_STD_STRING(k_EMsgClientToGCFriendsPlayedCustomGameRequest);
        CASE_STD_STRING(k_EMsgGCToClientFriendsPlayedCustomGameResponse);
        CASE_STD_STRING(k_EMsgGCTopCustomGamesList);
        CASE_STD_STRING(k_EMsgClientToGCSocialMatchPostCommentRequest);
        CASE_STD_STRING(k_EMsgGCToClientSocialMatchPostCommentResponse);
        CASE_STD_STRING(k_EMsgClientToGCSocialMatchDetailsRequest);
        CASE_STD_STRING(k_EMsgGCToClientSocialMatchDetailsResponse);
        CASE_STD_STRING(k_EMsgClientToGCSetPartyOpen);
        CASE_STD_STRING(k_EMsgClientToGCMergePartyInvite);
        CASE_STD_STRING(k_EMsgGCToClientMergeGroupInviteReply);
        CASE_STD_STRING(k_EMsgClientToGCMergePartyResponse);
        CASE_STD_STRING(k_EMsgGCToClientMergePartyResponseReply);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileCardStats);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileCardStatsResponse);
        CASE_STD_STRING(k_EMsgClientToGCTopLeagueMatchesRequest);
        CASE_STD_STRING(k_EMsgClientToGCTopFriendMatchesRequest);
        CASE_STD_STRING(k_EMsgGCToClientProfileCardStatsUpdated);
        CASE_STD_STRING(k_EMsgServerToGCRealtimeStats);
        CASE_STD_STRING(k_EMsgGCToServerRealtimeStatsStartStop);
        CASE_STD_STRING(k_EMsgGCToGCGetServersForClients);
        CASE_STD_STRING(k_EMsgGCToGCGetServersForClientsResponse);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyKickFromTeam);
        CASE_STD_STRING(k_EMsgDOTAChatGetMemberCount);
        CASE_STD_STRING(k_EMsgDOTAChatGetMemberCountResponse);
        CASE_STD_STRING(k_EMsgClientToGCSocialFeedPostMessageRequest);
        CASE_STD_STRING(k_EMsgGCToClientSocialFeedPostMessageResponse);
        CASE_STD_STRING(k_EMsgCustomGameListenServerStartedLoading);
        CASE_STD_STRING(k_EMsgCustomGameClientFinishedLoading);
        CASE_STD_STRING(k_EMsgGCPracticeLobbyCloseBroadcastChannel);
        CASE_STD_STRING(k_EMsgGCStartFindingMatchResponse);
        CASE_STD_STRING(k_EMsgSQLGCToGCGrantAccountFlag);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountFlags);
        CASE_STD_STRING(k_EMsgGCToGCGetAccountFlagsResponse);
        CASE_STD_STRING(k_EMsgSignOutWagerStats);
        CASE_STD_STRING(k_EMsgGCToClientTopLeagueMatchesResponse);
        CASE_STD_STRING(k_EMsgGCToClientTopFriendMatchesResponse);
        CASE_STD_STRING(k_EMsgClientToGCMatchesMinimalRequest);
        CASE_STD_STRING(k_EMsgClientToGCMatchesMinimalResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetProfileBadgePoints);
        CASE_STD_STRING(k_EMsgGCToGCGetProfileBadgePointsResponse);
        CASE_STD_STRING(k_EMsgGCToClientChatRegionsEnabled);
        CASE_STD_STRING(k_EMsgClientToGCPingData);
        CASE_STD_STRING(k_EMsgServerToGCMatchDetailsRequest);
        CASE_STD_STRING(k_EMsgGCToServerMatchDetailsResponse);
        CASE_STD_STRING(k_EMsgGCToGCEnsureAccountInParty);
        CASE_STD_STRING(k_EMsgGCToGCEnsureAccountInPartyResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileTickets);
        CASE_STD_STRING(k_EMsgClientToGCGetProfileTicketsResponse);
        CASE_STD_STRING(k_EMsgGCToClientMatchGroupsVersion);
        CASE_STD_STRING(k_EMsgClientToGCH264Unsupported);
        CASE_STD_STRING(k_EMsgClientToGCRequestH264Support);
        CASE_STD_STRING(k_EMsgClientToGCGetQuestProgress);
        CASE_STD_STRING(k_EMsgClientToGCGetQuestProgressResponse);
        CASE_STD_STRING(k_EMsgSignOutXPCoins);
        CASE_STD_STRING(k_EMsgGCToClientMatchSignedOut);
        CASE_STD_STRING(k_EMsgGCGetHeroStatsHistory);
        CASE_STD_STRING(k_EMsgGCGetHeroStatsHistoryResponse);
        CASE_STD_STRING(k_EMsgClientToGCPrivateChatInvite);
        CASE_STD_STRING(k_EMsgClientToGCPrivateChatKick);
        CASE_STD_STRING(k_EMsgClientToGCPrivateChatPromote);
        CASE_STD_STRING(k_EMsgClientToGCPrivateChatDemote);
        CASE_STD_STRING(k_EMsgGCToClientPrivateChatResponse);
        CASE_STD_STRING(k_EMsgClientToGCPrivateChatInfoRequest);
        CASE_STD_STRING(k_EMsgGCToClientPrivateChatInfoResponse);
        CASE_STD_STRING(k_EMsgClientToGCLatestConductScorecardRequest);
        CASE_STD_STRING(k_EMsgClientToGCLatestConductScorecard);
        CASE_STD_STRING(k_EMsgServerToGCPostMatchTip);
        CASE_STD_STRING(k_EMsgServerToGCPostMatchTipResponse);
        CASE_STD_STRING(k_EMsgClientToGCWageringRequest);
        CASE_STD_STRING(k_EMsgGCToClientWageringResponse);
        CASE_STD_STRING(k_EMsgClientToGCEventGoalsRequest);
        CASE_STD_STRING(k_EMsgClientToGCEventGoalsResponse);
        CASE_STD_STRING(k_EMsgClientToGCLeaguePredictions);
        CASE_STD_STRING(k_EMsgGCToClientLeaguePredictionsResponse);
        CASE_STD_STRING(k_EMsgGCToGCLeaguePredictionsUpdate);
        CASE_STD_STRING(k_EMsgClientToGCSuspiciousActivity);
        CASE_STD_STRING(k_EMsgGCToGCAddUserToPostGameChat);
        CASE_STD_STRING(k_EMsgClientToGCHasPlayerVotedForMVP);
        CASE_STD_STRING(k_EMsgClientToGCHasPlayerVotedForMVPResponse);
        CASE_STD_STRING(k_EMsgClientToGCVoteForMVP);
        CASE_STD_STRING(k_EMsgClientToGCVoteForMVPResponse);
        CASE_STD_STRING(k_EMsgGCToGCGetEventOwnership);
        CASE_STD_STRING(k_EMsgGCToGCGetEventOwnershipResponse);
        CASE_STD_STRING(k_EMsgGCToClientAutomatedTournamentStateChange);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyOpts);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyOptsResponse);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyLeave);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyLeaveResponse);
        CASE_STD_STRING(k_EMsgClientToGCTeammateStatsRequest);
        CASE_STD_STRING(k_EMsgClientToGCTeammateStatsResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetGiftPermissions);
        CASE_STD_STRING(k_EMsgClientToGCGetGiftPermissionsResponse);
        CASE_STD_STRING(k_EMsgClientToGCVoteForArcana);
        CASE_STD_STRING(k_EMsgClientToGCVoteForArcanaResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestArcanaVotesRemaining);
        CASE_STD_STRING(k_EMsgClientToGCRequestArcanaVotesRemainingResponse);
        CASE_STD_STRING(k_EMsgGCTransferTeamAdminResponse);
        CASE_STD_STRING(k_EMsgGCToClientTeamInfo);
        CASE_STD_STRING(k_EMsgGCToClientTeamsInfo);
        CASE_STD_STRING(k_EMsgClientToGCMyTeamInfoRequest);
        CASE_STD_STRING(k_EMsgClientToGCPublishUserStat);
        CASE_STD_STRING(k_EMsgGCToGCSignoutSpendWager);
        CASE_STD_STRING(k_EMsgGCSubmitLobbyMVPVote);
        CASE_STD_STRING(k_EMsgGCSubmitLobbyMVPVoteResponse);
        CASE_STD_STRING(k_EMsgSignOutCommunityGoalProgress);
        CASE_STD_STRING(k_EMsgGCToClientLobbyMVPNotifyRecipient);
        CASE_STD_STRING(k_EMsgGCToClientLobbyMVPAwarded);
        CASE_STD_STRING(k_EMsgGCToClientQuestProgressUpdated);
        CASE_STD_STRING(k_EMsgGCToClientWageringUpdate);
        CASE_STD_STRING(k_EMsgGCToClientArcanaVotesUpdate);
        CASE_STD_STRING(k_EMsgClientToGCAddTI6TreeProgress);
        CASE_STD_STRING(k_EMsgClientToGCSetSpectatorLobbyDetails);
        CASE_STD_STRING(k_EMsgClientToGCSetSpectatorLobbyDetailsResponse);
        CASE_STD_STRING(k_EMsgClientToGCCreateSpectatorLobby);
        CASE_STD_STRING(k_EMsgClientToGCCreateSpectatorLobbyResponse);
        CASE_STD_STRING(k_EMsgClientToGCSpectatorLobbyList);
        CASE_STD_STRING(k_EMsgClientToGCSpectatorLobbyListResponse);
        CASE_STD_STRING(k_EMsgSpectatorLobbyGameDetails);
        CASE_STD_STRING(k_EMsgServerToGCCompendiumInGamePredictionResults);
        CASE_STD_STRING(k_EMsgServerToGCCloseCompendiumInGamePredictionVoting);
        CASE_STD_STRING(k_EMsgClientToGCOpenPlayerCardPack);
        CASE_STD_STRING(k_EMsgClientToGCOpenPlayerCardPackResponse);
        CASE_STD_STRING(k_EMsgClientToGCSelectCompendiumInGamePrediction);
        CASE_STD_STRING(k_EMsgClientToGCSelectCompendiumInGamePredictionResponse);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyGetPlayerStats);
        CASE_STD_STRING(k_EMsgClientToGCWeekendTourneyGetPlayerStatsResponse);
        CASE_STD_STRING(k_EMsgClientToGCRecyclePlayerCard);
        CASE_STD_STRING(k_EMsgClientToGCRecyclePlayerCardResponse);
        CASE_STD_STRING(k_EMsgClientToGCCreatePlayerCardPack);
        CASE_STD_STRING(k_EMsgClientToGCCreatePlayerCardPackResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetPlayerCardRosterRequest);
        CASE_STD_STRING(k_EMsgClientToGCGetPlayerCardRosterResponse);
        CASE_STD_STRING(k_EMsgClientToGCSetPlayerCardRosterRequest);
        CASE_STD_STRING(k_EMsgClientToGCSetPlayerCardRosterResponse);
        CASE_STD_STRING(k_EMsgServerToGCCloseCompendiumInGamePredictionVotingResponse);
        CASE_STD_STRING(k_EMsgServerToGCCompendiumInGamePredictionResultsResponse);
        CASE_STD_STRING(k_EMsgLobbyBattleCupVictory);
        CASE_STD_STRING(k_EMsgGCGetPlayerCardItemInfo);
        CASE_STD_STRING(k_EMsgGCGetPlayerCardItemInfoResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestSteamDatagramTicket);
        CASE_STD_STRING(k_EMsgClientToGCRequestSteamDatagramTicketResponse);
        CASE_STD_STRING(k_EMsgGCToClientBattlePassRollupRequest);
        CASE_STD_STRING(k_EMsgGCToClientBattlePassRollupResponse);
        CASE_STD_STRING(k_EMsgClientToGCTransferSeasonalMMRRequest);
        CASE_STD_STRING(k_EMsgClientToGCTransferSeasonalMMRResponse);
        CASE_STD_STRING(k_EMsgGCToGCPublicChatCommunicationBan);
        CASE_STD_STRING(k_EMsgGCToGCUpdateAccountPublicChatBan);
        CASE_STD_STRING(k_EMsgGCChatReportPublicSpam);
        CASE_STD_STRING(k_EMsgClientToGCSetPartyBuilderOptions);
        CASE_STD_STRING(k_EMsgClientToGCSetPartyBuilderOptionsResponse);
        CASE_STD_STRING(k_EMsgGCToClientPlaytestStatus);
        CASE_STD_STRING(k_EMsgClientToGCJoinPlaytest);
        CASE_STD_STRING(k_EMsgClientToGCJoinPlaytestResponse);
        CASE_STD_STRING(k_EMsgLobbyPlaytestDetails);
        CASE_STD_STRING(k_EMsgDOTASetFavoriteTeam);
        CASE_STD_STRING(k_EMsgGCToClientBattlePassRollupListRequest);
        CASE_STD_STRING(k_EMsgGCToClientBattlePassRollupListResponse);
        CASE_STD_STRING(k_EMsgGCIsProQuery);
        CASE_STD_STRING(k_EMsgGCIsProResponse);
        CASE_STD_STRING(k_EMsgDOTAClaimEventAction);
        CASE_STD_STRING(k_EMsgDOTAClaimEventActionResponse);
        CASE_STD_STRING(k_EMsgDOTAGetPeriodicResource);
        CASE_STD_STRING(k_EMsgDOTAGetPeriodicResourceResponse);
        CASE_STD_STRING(k_EMsgDOTAPeriodicResourceUpdated);
        CASE_STD_STRING(k_EMsgServerToGCSpendWager);
        CASE_STD_STRING(k_EMsgGCToGCSignoutSpendWagerToken);
        CASE_STD_STRING(k_EMsgSubmitTriviaQuestionAnswer);
        CASE_STD_STRING(k_EMsgSubmitTriviaQuestionAnswerResponse);
        CASE_STD_STRING(k_EMsgClientToGCGiveTip);
        CASE_STD_STRING(k_EMsgClientToGCGiveTipResponse);
        CASE_STD_STRING(k_EMsgStartTriviaSession);
        CASE_STD_STRING(k_EMsgStartTriviaSessionResponse);
        CASE_STD_STRING(k_EMsgAnchorPhoneNumberRequest);
        CASE_STD_STRING(k_EMsgAnchorPhoneNumberResponse);
        CASE_STD_STRING(k_EMsgUnanchorPhoneNumberRequest);
        CASE_STD_STRING(k_EMsgUnanchorPhoneNumberResponse);
        CASE_STD_STRING(k_EMsgGCToClientTipNotification);
        CASE_STD_STRING(k_EMsgClientToGCRequestSlarkGameResult);
        CASE_STD_STRING(k_EMsgClientToGCRequestSlarkGameResultResponse);
        CASE_STD_STRING(k_EMsgGCToGCSignoutSpendRankWager);
        CASE_STD_STRING(k_EMsgGCToGCGetFavoriteTeam);
        CASE_STD_STRING(k_EMsgGCToGCGetFavoriteTeamResponse);
        CASE_STD_STRING(k_EMsgSignOutEventGameData);
        CASE_STD_STRING(k_EMsgGCToClientAllStarVotesRequest);
        CASE_STD_STRING(k_EMsgGCToClientAllStarVotesReply);
        CASE_STD_STRING(k_EMsgGCToClientAllStarVotesSubmit);
        CASE_STD_STRING(k_EMsgGCToClientAllStarVotesSubmitReply);
        CASE_STD_STRING(k_EMsgClientToGCQuickStatsRequest);
        CASE_STD_STRING(k_EMsgClientToGCQuickStatsResponse);
        CASE_STD_STRING(k_EMsgGCToGCSubtractEventPointsFromUser);
        CASE_STD_STRING(k_EMsgSelectionPriorityChoiceRequest);
        CASE_STD_STRING(k_EMsgSelectionPriorityChoiceResponse);
        CASE_STD_STRING(k_EMsgGCToGCCompendiumInGamePredictionResults);
        CASE_STD_STRING(k_EMsgGameAutographReward);
        CASE_STD_STRING(k_EMsgGameAutographRewardResponse);
        CASE_STD_STRING(k_EMsgDestroyLobbyRequest);
        CASE_STD_STRING(k_EMsgDestroyLobbyResponse);
        CASE_STD_STRING(k_EMsgPurchaseItemWithEventPoints);
        CASE_STD_STRING(k_EMsgPurchaseItemWithEventPointsResponse);
        CASE_STD_STRING(k_EMsgServerToGCMatchPlayerItemPurchaseHistory);
        CASE_STD_STRING(k_EMsgGCToGCGrantPlusHeroMatchResults);
        CASE_STD_STRING(k_EMsgGCGetHeroTimedStats);
        CASE_STD_STRING(k_EMsgGCGetHeroTimedStatsResponse);
        CASE_STD_STRING(k_EMsgLobbyPlayerPlusSubscriptionData);
        CASE_STD_STRING(k_EMsgServerToGCMatchStateHistory);
        CASE_STD_STRING(k_EMsgPurchaseHeroRelic);
        CASE_STD_STRING(k_EMsgPurchaseHeroRelicResponse);
        CASE_STD_STRING(k_EMsgPurchaseHeroRandomRelic);
        CASE_STD_STRING(k_EMsgPurchaseHeroRandomRelicResponse);
        CASE_STD_STRING(k_EMsgClientToGCClaimEventActionUsingItem);
        CASE_STD_STRING(k_EMsgClientToGCClaimEventActionUsingItemResponse);
        CASE_STD_STRING(k_EMsgPartyReadyCheckRequest);
        CASE_STD_STRING(k_EMsgPartyReadyCheckResponse);
        CASE_STD_STRING(k_EMsgPartyReadyCheckAcknowledge);
        CASE_STD_STRING(k_EMsgGetRecentPlayTimeFriendsRequest);
        CASE_STD_STRING(k_EMsgGetRecentPlayTimeFriendsResponse);
        CASE_STD_STRING(k_EMsgGCToClientCommendNotification);
        CASE_STD_STRING(k_EMsgProfileRequest);
        CASE_STD_STRING(k_EMsgProfileResponse);
        CASE_STD_STRING(k_EMsgProfileUpdate);
        CASE_STD_STRING(k_EMsgProfileUpdateResponse);
        CASE_STD_STRING(k_EMsgSuccessfulHero);
        CASE_STD_STRING(k_EMsgHeroGlobalDataRequest);
        CASE_STD_STRING(k_EMsgHeroGlobalDataResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlusWeeklyChallengeResult);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlusWeeklyChallengeResultResponse);
        CASE_STD_STRING(k_EMsgGCToGCGrantPlusPrepaidTime);
        CASE_STD_STRING(k_EMsgPrivateMetadataKeyRequest);
        CASE_STD_STRING(k_EMsgPrivateMetadataKeyResponse);
        CASE_STD_STRING(k_EMsgGCToGCReconcilePlusStatus);
        CASE_STD_STRING(k_EMsgGCToGCCheckPlusStatus);
        CASE_STD_STRING(k_EMsgGCToGCCheckPlusStatusResponse);
        CASE_STD_STRING(k_EMsgGCToGCReconcilePlusAutoGrantItems);
        CASE_STD_STRING(k_EMsgGCToGCReconcilePlusStatusUnreliable);
        CASE_STD_STRING(k_EMsgActivatePlusFreeTrialRequest);
        CASE_STD_STRING(k_EMsgActivatePlusFreeTrialResponse);
        CASE_STD_STRING(k_EMsgGCToClientCavernCrawlMapPathCompleted);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlClaimRoom);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlClaimRoomResponse);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlUseItemOnRoom);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlUseItemOnRoomResponse);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlUseItemOnPath);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlUseItemOnPathResponse);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlRequestMapState);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlRequestMapStateResponse);
        CASE_STD_STRING(k_EMsgSignOutTips);
        CASE_STD_STRING(k_EMsgClientToGCRequestEventPointLogV2);
        CASE_STD_STRING(k_EMsgClientToGCRequestEventPointLogResponseV2);
        CASE_STD_STRING(k_EMsgClientToGCRequestEventTipsSummary);
        CASE_STD_STRING(k_EMsgClientToGCRequestEventTipsSummaryResponse);
        CASE_STD_STRING(k_EMsgHeroGlobalDataAllHeroes);
        CASE_STD_STRING(k_EMsgClientToGCRequestSocialFeed);
        CASE_STD_STRING(k_EMsgClientToGCRequestSocialFeedResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestSocialFeedComments);
        CASE_STD_STRING(k_EMsgClientToGCRequestSocialFeedCommentsResponse);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlGetClaimedRoomCount);
        CASE_STD_STRING(k_EMsgClientToGCCavernCrawlGetClaimedRoomCountResponse);
        CASE_STD_STRING(k_EMsgGCToGCReconcilePlusAutoGrantItemsUnreliable);
        CASE_STD_STRING(k_EMsgServerToGCAddBroadcastTimelineEvent);
        CASE_STD_STRING(k_EMsgGCToServerUpdateSteamBroadcasting);
        CASE_STD_STRING(k_EMsgClientToGCRecordContestVote);
        CASE_STD_STRING(k_EMsgGCToClientRecordContestVoteResponse);
        CASE_STD_STRING(k_EMsgGCToGCGrantAutograph);
        CASE_STD_STRING(k_EMsgGCToGCGrantAutographResponse);
        CASE_STD_STRING(k_EMsgSignOutConsumableUsage);
        CASE_STD_STRING(k_EMsgLobbyEventGameDetails);
        CASE_STD_STRING(k_EMsgDevGrantEventPoints);
        CASE_STD_STRING(k_EMsgDevGrantEventPointsResponse);
        CASE_STD_STRING(k_EMsgDevGrantEventAction);
        CASE_STD_STRING(k_EMsgDevGrantEventActionResponse);
        CASE_STD_STRING(k_EMsgDevResetEventState);
        CASE_STD_STRING(k_EMsgDevResetEventStateResponse);
        CASE_STD_STRING(k_EMsgGCToGCReconcileEventOwnership);
        CASE_STD_STRING(k_EMsgConsumeEventSupportGrantItem);
        CASE_STD_STRING(k_EMsgConsumeEventSupportGrantItemResponse);
        CASE_STD_STRING(k_EMsgGCToClientClaimEventActionUsingItemCompleted);
        CASE_STD_STRING(k_EMsgGCToClientCavernCrawlMapUpdated);
        CASE_STD_STRING(k_EMsgServerToGCRequestPlayerRecentAccomplishments);
        CASE_STD_STRING(k_EMsgServerToGCRequestPlayerRecentAccomplishmentsResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerRecentAccomplishments);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerRecentAccomplishmentsResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerHeroRecentAccomplishments);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse);
        CASE_STD_STRING(k_EMsgSignOutEventActionGrants);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerCoachMatches);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerCoachMatchesResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetTicketCodesRequest);
        CASE_STD_STRING(k_EMsgClientToGCGetTicketCodesResponse);
        CASE_STD_STRING(k_EMsgClientToGCSubmitCoachTeammateRating);
        CASE_STD_STRING(k_EMsgClientToGCSubmitCoachTeammateRatingResponse);
        CASE_STD_STRING(k_EMsgGCToClientCoachTeammateRatingsChanged);
        CASE_STD_STRING(k_EMsgClientToGCVoteForLeagueGameMVP);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerCoachMatch);
        CASE_STD_STRING(k_EMsgClientToGCRequestPlayerCoachMatchResponse);
        CASE_STD_STRING(k_EMsgClientToGCRequestContestVotes);
        CASE_STD_STRING(k_EMsgClientToGCRequestContestVotesResponse);
        CASE_STD_STRING(k_EMsgClientToGCMVPVoteTimeout);
        CASE_STD_STRING(k_EMsgClientToGCMVPVoteTimeoutResponse);
        CASE_STD_STRING(k_EMsgClientToGCGetUnderlordsCDKeyRequest);
        CASE_STD_STRING(k_EMsgClientToGCGetUnderlordsCDKeyResponse);
        CASE_STD_STRING(k_EMsgDetailedGameStats);
        CASE_STD_STRING(k_EMsgClientToGCSetFavoriteAllStarPlayer);
        CASE_STD_STRING(k_EMsgClientToGCSetFavoriteAllStarPlayerResponse);
        CASE_STD_STRING(k_EMsgAllStarStats);
        CASE_STD_STRING(k_EMsgClientToGCGetFavoriteAllStarPlayerRequest);
        CASE_STD_STRING(k_EMsgClientToGCGetFavoriteAllStarPlayerResponse);
        CASE_STD_STRING(k_EMsgClientToGCVerifyIntegrity);
        CASE_STD_STRING(k_EMsgMatchMatchmakingStats);
        CASE_STD_STRING(k_EMsgClientToGCSubmitPlayerMatchSurvey);
        CASE_STD_STRING(k_EMsgClientToGCSubmitPlayerMatchSurveyResponse);
        CASE_STD_STRING(k_EMsgSQLGCToGCGrantAllHeroProgressAccount);
        CASE_STD_STRING(k_EMsgSQLGCToGCGrantAllHeroProgressVictory);
        CASE_STD_STRING(k_eMsgGCToGCGetAllHeroCurrent);
        CASE_STD_STRING(k_eMsgGCToGCGetAllHeroCurrentResponse);
        CASE_STD_STRING(k_EMsgGCSubmitPlayerAvoidRequest);
        CASE_STD_STRING(k_EMsgGCSubmitPlayerAvoidRequestResponse);
        CASE_STD_STRING(k_EMsgGCToClientNotificationsUpdated);
        CASE_STD_STRING(k_EMsgGCtoGCAssociatedExploiterAccountInfo);
        CASE_STD_STRING(k_EMsgGCtoGCAssociatedExploiterAccountInfoResponse);
        default:
            return std::string( std::to_string(int(msg)) );
    }
}
enum NetMessageGroups : int
{
    SYSTEM = 0,
    ENTITIES = 1,
    STRING_COMMAND = 2,
    SIGNON = 3,
    SPAWNGROUPS = 4,
    MOVE = 5,
    VOICE = 6,
    GENERIC = 7,
    STRING_TABLE = 8,
    SOUNDS = 9,

    EVENTS = 12,
    CLIENT_MESSAGES = 13,
    USER_MESSAGES = 14,
    DECALS = 15,
};

enum NetworkSerializationMode_t : int
{
    NET_SERIALIZATION_MODE_0  = 0,
    NET_SERIALIZATION_MODE_DEFAULT  = 0,
    NET_SERIALIZATION_MODE_SERVER  = 0,
    NET_SERIALIZATION_MODE_1  = 1,
    NET_SERIALIZATION_MODE_CLIENT  = 1,
    NET_SERIALIZATION_MODE_COUNT  = 2,
};

/*
 * derived from google::protobuf:Message
class CMsg_Base
{
public:
    virtual void DESTROY1() = 0;
    virtual void DESTROY2() = 0;
    virtual std::string GetTypeName(void) = 0; // google::protobuf::Message::GetTypeName
    virtual void New(void) = 0;
    virtual void New2(void *arena) = 0;
    virtual void sub_1FE1A60() = 0;
    virtual void sub_1FE1A70() = 0;
    virtual void sub_23E6980() = 0;
    virtual bool IsInitialized(void) = 0;
    virtual std::string InitializationErrorString(void) = 0;
    virtual void CheckTypeAndMergeFrom(const google::protobuf::MessageLite &other) = 0;
    virtual bool MergePartialFromCodedStream(google::protobuf::io::CodedInputStream *input) = 0;
    virtual size_t ByteSize(void) = 0; // calls google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize
    virtual void SerializeWithCachedSizes(google::protobuf::io::CodedOutputStream *output) = 0;
    virtual void SerializeWithCachedSizesToArray(unsigned char *) = 0; // calls  google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray
    virtual int GetCachedSize(void) = 0;
    virtual void sub_23CBBB0() = 0;
    virtual void sub_1FE1A80() = 0;
    virtual void CopyFrom(const google::protobuf::Message &other) = 0;
    virtual void MergeFrom(const google::protobuf::Message &other) = 0;
    virtual void DiscardUnknownFields(void) = 0;
    virtual int SpaceUsed(void) = 0;
    virtual void SetCachedSize(int) = 0;
    virtual google::protobuf::Reflection* GetReflection(void) = 0;
    virtual google::protobuf::Metadata* GetMetaData(void) = 0;
};
*/

class CNetPacket
{
public:
    int notsure;
    int cubData;
    void *pubData;
};

class IMsgNetPacket
{
public:
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;
    virtual void DestroyThis(void) = 0;
    virtual int GetEMsgFormatType(void) = 0;
    virtual CNetPacket* GetCNetPacket(void) = 0;
    virtual const uint8_t *PubData(void) = 0; // Pointer-Unsigned-Byte Data
    virtual uint32_t CubData(void) = 0; // Count-Unsigned-Byte Data - u can find some of this in the steamworks sdk
    virtual EDOTAGCMsg GetEMsg(void) = 0;
    virtual int GetSourceJobID(void) = 0;
    virtual unsigned long long GetTargetJobID(void) = 0;
    virtual void SetTargetJobID(unsigned long long) = 0;
    virtual int64_t GetSteamID(void) = 0;
    virtual void SetSteamID(int64_t CSteamID) = 0;
    virtual unsigned int GetSourceAppID(void) = 0;
    virtual void SetSourceAppID(unsigned int) = 0;
    virtual bool BHasTargetJobName(void) = 0;
    virtual const char *GetTargetJobName(void) = 0;

    inline void GetMsgBody( const uint8_t **msg, uint32_t *msgSize )
    {
        unsigned int messageSize = *(unsigned int*)(this->PubData() + 4);
        messageSize += 8; // min size
        *msg = this->PubData() + messageSize;
        *msgSize = this->CubData() - messageSize;
    }
};

class CMsgProtoBufHeader;
class IProtoBufSendHandler
{
public:
    virtual bool BAsyncSend( EDOTAGCMsg eMsg, const uint8_t *pubMsgBytes, uint32 cubSize ) = 0;
};

class CProtoBufMsgBase
{
public:
    virtual ~CProtoBufMsgBase() = 0;
    virtual void DESTROY2() = 0;
    virtual google::protobuf::Message *GetGenericBody(void) = 0;

    void *pNetPacket;
    CMsgProtoBufHeader *pProtoBufHdr;
    EDOTAGCMsg eMsg;
    char _pad[4];
};

template<typename T>
class CProtoBufMsg : CProtoBufMsgBase
{
public:

    T *pProtoBufBody;
};

class CProtobuffBinding // AKA CNetMessagePB
{
public:
    virtual const char* GetName(void) = 0;
    virtual int GetSize(void) = 0;
    virtual const char* ToString(google::protobuf::Message *msg, CUtlString *storage) = 0;
    virtual const char *GetGroup(void) = 0;
    virtual ColorRGBA GetGroupColor(void) = 0;
    virtual NetChannelBufType_t GetBufType(void) = 0;
    virtual bool ReadFromBuffer(google::protobuf::Message *msg, bf_read &) = 0; // true if parsing O = 0K
    virtual bool WriteToBuffer(google::protobuf::Message *msg, bf_write &) = 0; // true if parsing O = 0K
    virtual void* AllocateMessage(void) = 0;
    virtual void DeallocateMessage(void *) = 0;
    virtual void* AllocateAndCopyConstructNetMessage(void const* otherProtobufMsg) = 0;
    virtual bool OkToRedispatch(void) = 0;
    virtual void Copy(void const*,void *) = 0;
};

class CNetworkSerializerPB // PB must = protobuf
{
public:
    virtual void DESTROY1() = 0;
    virtual void DESTROY2() = 0;
    virtual const char* GetUnscopedName(void) = 0;
    virtual void* GetNetMessageInfo(void) = 0;
    virtual void SetMessageID(unsigned int) = 0;
    virtual void AddCategoryMask(unsigned int bitflag, bool applyToAnotherMember) = 0;
    virtual void SwitchMode(int networkValidationMode_t) = 0;
    virtual void AllocateMessage(void) = 0;
    virtual void DeallocateMessage(void *unk) = 0;
    virtual void AllocateAndCopyConstructNetMessage(void const *) = 0;
    virtual void Serialize(bf_write &, void const *, NetworkSerializationMode_t) = 0;
    virtual void UnSerialize(bf_read &, void *, NetworkSerializationMode_t) = 0;

    const char *unscopedName;
    uint32_t categoryMask;
    int unk;
    CProtobuffBinding *protobufBinding;
    const char *groupName;
    int16_t messageID;
    uint8_t groupID;
    uint8_t defaultBufferType;
    char _pad[28];
};

typedef CNetworkSerializerPB GameEventHandle_t;
typedef CNetworkSerializerPB NetMessageHandle_t;

struct MessageEntryWrapper {
    void *unk[2];
    CNetworkSerializerPB *entry;
};

struct MessageEntries {
    std::array<MessageEntryWrapper, 334> messages;
};

struct NetMessageInfo_t
{
    void* pad;
    CProtobuffBinding* pProtobufBinding;
};

//"NetworkMessages::FindOrCreateNetMessage" (libnetworksystem)
class CNetworkMessages
{
public:
    virtual void RegisterNetworkCategory( unsigned int, const char* ) = 0;
    virtual void AssociateNetMessageWithChannelCategoryAbstract( NetMessageHandle_t *, unsigned int, bool) = 0;
    virtual NetMessageHandle_t* FindOrCreateNetMessage(int, void const* IProtobufBinding, unsigned int, void* INetworkSerializerBindingBuildFilter, bool, bool) = 0;
    virtual bool SerializeAbstract(bf_read &buffer, NetMessageHandle_t *, void const*) = 0;
    virtual void UnserializeAbstract(bf_read &buffer, NetMessageHandle_t *, void*) = 0;
    virtual void UnserializeAbstract(bf_read &buffer, NetMessageHandle_t **, void **) = 0;
    virtual void* AllocateUnserializedMessage(NetMessageHandle_t *) = 0;
    virtual void AllocateAndCopyConstructNetMessageAbstract(NetMessageHandle_t *, void const*) = 0;
    virtual void DeallocateUnserializedMessage(NetMessageHandle_t *, void*) = 0;
    virtual void RegisterNetworkFieldSerializer() = 0; // (char const*,NetworkSerializationMode_t,NetworkableDataType_t,int,NetworkFieldResult_t (*)(NetworkSerializerInfo_t const&,int,NetworkableData_t *),NetworkFieldResult_t (*)(NetworkUnserializerInfo_t const&,int,NetworkableData_t const*),ulong (*)(NetworkFieldInfo_t const&),bool (*)(FieldMetaInfo_t const&,CSchemaClassBindingBase const*,NetworkFieldInfo_t const&,void *),bool (*)(NetworkableData_t const*,CUtlString &),char const* (*)(void),NetworkFieldResult_t (*)(NetworkSerializerInfo_t const&,int,NetworkableData_t *),NetworkFieldResult_t (*)(NetworkUnserializerInfo_t const&,int,NetworkableData_t const*))
    virtual void RegisterNetworkArrayFieldSerializer() = 0; // (char const*,NetworkSerializationMode_t,NetworkFieldResult_t (*)(NetworkSerializerInfo_t const&,bf_write &,int *,void const**,bool),NetworkFieldResult_t (*)(NetworkUnserializerInfo_t const&,bf_read &,int *,void **,bool,CSchemaClassBindingBase const*),ulong (*)(NetworkFieldInfo_t const&),bool (*)(FieldMetaInfo_t const&,CSchemaClassBindingBase const*,NetworkFieldInfo_t const&,void *),NetworkFieldResult_t (*)(NetworkSerializerInfo_t const&,bf_write &,int *,void const**,bool),NetworkFieldResult_t (*)(NetworkUnserializerInfo_t const&,bf_read &,int *,void **,bool,CSchemaClassBindingBase const*))
    virtual NetMessageInfo_t* GetNetMessageInfo(NetMessageHandle_t *) = 0;
    virtual void* FindNetworkMessage(const char*) = 0;
    virtual NetMessageHandle_t* FindNetworkMessage2(const char*) = 0; // Be Sure to use the Full Name! Only this one works! these 2 are literally the exact same from what I can tell, no idea.  string used in V_Stricmp()
    virtual void FindGroupId(void *unk, bool createIfNotFound) = 0;
    virtual int GetNetworkGroupCount(void) = 0;
    virtual const char* GetNetworkGroupName(int groupId) = 0;
    virtual int FindNetworkGroup(const char*, bool) = 0;
    virtual void AssociateNetMessageGroupIdWithChannelCategory(unsigned int, const char*) = 0; // "AssociateNetMessageGroupIdWithChannelCategory: Trying to use"
    virtual void RegisterSchemaAtomicTypeOverride(unsigned int, void *CSchemaType) = 0;
    virtual void SetNetworkSerializationContextData(const char*, NetworkSerializationMode_t, void*) = 0;
    virtual void sub_1E1570() = 0;
    virtual void sub_1E1070() = 0;
    virtual void RegisterNetworkFieldChangeCallback() = 0; //(char const*,NetworkFieldChangedDelegateType_t,CUtlAbstractDelegate,NetworkFieldChangeCallbackPerformType_t,int)
    virtual void AllowAdditionalMessageRegistration(bool allow) = 0;
    virtual int GetFieldChangeCallbackOrderCount(void) = 0;
    virtual void GetFieldChangeCallbackPriorities(int, int*) = 0;
    virtual void RegisterFieldChangeCallbackPriority(int) = 0;
    virtual void* FindNetworkMessageByID(int) = 0;
    virtual void SetIsForServer(bool isForServer) = 0;
    virtual bool IsForServer(void) = 0;
    virtual void RegisterSchemaTypeOverride(unsigned int, const char*) = 0;
    virtual void sub_1E2170() = 0;
    virtual void sub_1E4020() = 0;
    virtual void sub_1E4C50() = 0;

    char _pad[0x1F0 - sizeof(void*)];
    MessageEntries *messageList; // usermessage list @ +0x1F0
    // @ +0x420 some sort of protobuf descriptions
};
```

`src/SDK/CNetworkStringTableContainer.h`:

```h
#pragma once

#include "IAppSystem.h"


//xref "CNetworkStringTable::AddString"
class INetworkStringTable
{
public:
    virtual void DESTROY1();
    virtual void DESTROY2();

    // Table Info
    virtual const char *GetTableName( void );
    virtual int GetTableID( void );
    virtual int GetNumStrings( void );

    // Networking
    virtual void SetTick( int tick );
    virtual int GetTick( void );
    virtual bool ChangedSinceTick( int tick );

    // Accessors (length -1 means don't change user data if string already exits)
    virtual int AddString( bool isServer, const char * value, int length = -1, void const * userData = nullptr );
    virtual const char *GetString( int stringNumber, bool );
    virtual void SetStringUserData( int stringNumber, int length, void const *userData, bool );
    virtual const void *GetStringUserData( int stringNumber, int *length );
    virtual int FindStringIndex( const char *string );
    virtual void SetStringChangedCallback( void *object,void (*)(void *object,INetworkStringTable *stringTable,int stringNumber,char const *newString,void const* newData) );
};

//xref "Tried to create string table '%s'" to CreateStringTable()
class CNetworkStringTableContainer : IAppSystem
{
public:
    virtual void DESTROY();
    virtual void DESTROY2();
    virtual INetworkStringTable* CreateStringTable( const char *tableName, int,int, int ENetworkStringtableFlags );
    virtual void RemoveAllTables( void );
    
    virtual INetworkStringTable* FindTable( const char *tableName );
    virtual INetworkStringTable* GetTable( int tableID );
    virtual int GetNumTables( void );
    
    virtual void SetAllowClientSideAddString( INetworkStringTable *table, bool allow );
};
```

`src/SDK/CNetworkSystem.h`:

```h
#pragma once

#include "IAppSystem.h"
#include "INetChannel.h"

class IPeerToPeerCallbacks;
class IConnectionlessPacketHandler;

// xref "Leaked channel %s remote %s\n" to Shutdown()
// or xref "CNetworkSystem::ShutdownGameServer" to ShutdownGameServer()
class CNetworkSystem : IAppSystem
{
public:
    // this one is kinda tough, they changed a lot of their networking
    virtual void CNetworkSystem__InitGameServer(void) = 0; // 11
    virtual void ShutdownGameServer(void) = 0;
    virtual void sub_1E95A0() = 0;
    virtual void loc_1E6B50() = 0;
    virtual void loc_1F5210() = 0;
    virtual void sub_1E4ED0() = 0;
    virtual void sub_1F1EF0() = 0;
    virtual void InitP2PNetworking(IPeerToPeerCallbacks *) = 0; // "Can't connectloopback"
    virtual void ShutdownP2PNetworking(int) = 0;
    virtual void TerminateP2PSockets(int) = 0;
    virtual void sub_1E3CC0() = 0;
    virtual void loc_1F45C0() = 0;
    virtual void SetDefaultBroadcastPort(int) = 0;
    virtual void sub_1E8990() = 0;
    virtual void FlushP2PChannels(int) = 0;
    virtual INetChannel* CreateNetChannel(int, void *ns_address, const char *, unsigned int, unsigned int) = 0; // "netchan_t::reliabledata" xref all the way back
    virtual void sub_1F0D40() = 0;
    virtual void ProcessSocket(int, IConnectionlessPacketHandler *) = 0;
    virtual void loc_1F1CB0() = 0;
    virtual void sub_1F1A00() = 0;
    virtual void loc_1F3BA0() = 0;
    virtual void sub_1ED1B0() = 0;
    virtual void loc_1ED530() = 0;
    virtual void loc_1ECEE0() = 0;
    /*
    virtual void sub_1F0140() = 0;
    virtual void CloseNetworkSocket(int, int) = 0;
    virtual void OutOfBandPrintf(int, const void *ns_address, const char *, ...) = 0;
    virtual void SetTime(double) = 0;
    virtual void SetTimeScale(float) = 0;
    virtual double GetNetTime(void) = 0;
    virtual void DescribeSocket(int) = 0;
    virtual void sub_1E3500() = 0;
     */
    virtual void BufferToBufferCompress(char *, unsigned int *, const char *, unsigned int) = 0;
    virtual void BufferToBufferDecompress(char *, unsigned int *, const char *, unsigned int) = 0;
    /*
    virtual void *GetPublicAdr(void) = 0;
    virtual void *GetLocalAdr(void) = 0;
    virtual void GetUDPPort(int) = 0;
    virtual void sub_1E4150() = 0;
    virtual void sub_1E46D0() = 0;
    virtual void sub_1E3DD0() = 0;
    virtual void sub_1E4DB0() = 0;
    virtual void loc_1EB5F0() = 0;
    virtual void loc_1EB570() = 0;
    virtual void loc_1EB7A0() = 0;
    virtual void loc_1EB720() = 0;
    virtual void loc_1EB950() = 0;
    virtual void loc_1EB8D0() = 0;
    virtual void loc_1EBB00() = 0;
    virtual void loc_1EBA80() = 0;
    virtual void loc_1EBCB0() = 0;
    virtual void loc_1EBC30() = 0;
    virtual void sub_1F20B0() = 0;
    virtual void sub_1E51D0() = 0;
    virtual void sub_1E4FF0() = 0;
    virtual void sub_1F53F0() = 0;
    virtual void sub_1F5400() = 0;
    virtual void sub_1F5E80() = 0;
    virtual void sub_1E41A0() = 0;
    virtual void sub_1E3400() = 0;
    virtual void sub_1E49A0() = 0;
    virtual void sub_1E49D0() = 0;
    virtual void sub_1E3530() = 0;
    virtual void sub_1F0A70() = 0;
    virtual void DESTROY1(void) = 0;
    virtual void DESTROY2(void) = 0;
    virtual void MessageData(unsigned int, unsigned short, unsigned int, unsigned char *) = 0;
    */
};
```

`src/SDK/CPanoramaGameScriptScope.h`:

```h
#pragma once

#include "definitions.h"

enum ArgTypes_t : uint8_t
{
    VOID = 0x0,
    FLOAT = 0x1,
    _UNK1 = 0x2, // These unknown are so-called "unknown_variant_type" in the game engine as well.
    VECTOR = 0x3,
    QUATERNION = 0x4,
    INTEGER = 0x5,
    BOOLEAN = 0x6,
    _UNK2 = 0x7,
    CHARACTER = 0x8,
    COLOR = 0x9,
    _UNK3 = 0xA,
    _UNK4 = 0xB,
    _UNK5 = 0xC,
    EHANDLE = 0xD,
    _UNK6 = 0xE,
    _UNK7 = 0xF,
    _UNK8 = 0x10,
    _UNK9 = 0x11,
    _UNK10 = 0x12,
    _UNK11= 0x13,
    _UNK12 = 0x14,
    _UNK13 = 0x15,
    _UNK14 = 0x16,
    _UNK15 = 0x17,
    _UNK16 = 0x18,
    VECTOR2D = 0x19,
    INT64 = 0x1A,
    VECTOR4D = 0x1B,
    RESOURCE_HANDLE = 0x1C,
    _UNK17 = 0x1D,
    CSTRING = 0x1E,
    H_SCRIPT = 0x1F,
    VARIANT = 0x20,
    UINT64 = 0x21,
    FLOAT64 = 0x22,
    _UNK18 = 0x23,
    _UNK19 = 0x24,
    UNSIGNED = 0x25,
    UTLSTRINGTOKEN = 0x26,
    QANGLE = 0x27,
    _UNK20 = 0x28,
    _UNK21 = 0x29,
    _UNK22 = 0x2A,
    _UNK23 = 0x2B,
    _UNK24 = 0x2C,
    _UNK25 = 0x2D,
    _UNK26 = 0x2E,
    _UNK27 = 0x2F,
    HSCRIPT_LIGHTBINDING = 0x30,
    JS_VALUE = 0x31,
    JS_OBJECT = 0x32,
    JS_ARRAY = 0x33,
    JS_RAW_ARGS = 0x34,
};

inline const char *GetArgTypeString( ArgTypes_t argType ){
    switch( argType ){
        CASE_STRING(VOID);
        CASE_STRING(FLOAT);
        CASE_STRING(VECTOR);
        CASE_STRING(QUATERNION);
        CASE_STRING(INTEGER);
        CASE_STRING(BOOLEAN);
        CASE_STRING(CHARACTER);
        CASE_STRING(COLOR);
        CASE_STRING(EHANDLE);
        CASE_STRING(VECTOR2D);
        CASE_STRING(INT64);
        CASE_STRING(VECTOR4D);
        CASE_STRING(RESOURCE_HANDLE);
        CASE_STRING(CSTRING);
        CASE_STRING(H_SCRIPT);
        CASE_STRING(VARIANT);
        CASE_STRING(UINT64);
        CASE_STRING(FLOAT64);
        CASE_STRING(UNSIGNED);
        CASE_STRING(UTLSTRINGTOKEN);
        CASE_STRING(QANGLE);
        CASE_STRING(HSCRIPT_LIGHTBINDING);
        CASE_STRING(JS_VALUE);
        CASE_STRING(JS_OBJECT);
        CASE_STRING(JS_ARRAY);
        CASE_STRING(JS_RAW_ARGS);
        default:
            return "UNKNOWN_TYPE_REEEE!";
    }
}

class ScopeFunction
{
public:
    const char *name;
    const char *internalName; // same as above it seems
    const char *description;
    ArgTypes_t returnType;
    uint8_t unkbyte2;
    uint8_t argNum;
    ArgTypes_t argTypes[5];
    void *unk2;
    const char *argNames; // separated by \0's
    void *unk3;
    void *v8WrapperFunc; // maybe a function to get more info?
    void *function; // The actual function
    int _pad;
    int iUnk;
}__attribute__((packed));

class CPanoramaGameScriptScope
{
public:
    const char *name;
    const char *fullName;
    const char *description;
    void *unk;
    uint32_t numFuncs;
    char _pad[4];
    ScopeFunction *funcs;
};

class GameScriptScopesWrapper
{
public:
    CPanoramaGameScriptScope **scopes;
    size_t numScopes;
};
```

`src/SDK/CParticleCollection.h`:

```h
#pragma once

#include "Schema.h"

// xref "CParticleCollection::CParticleCollection [%p]" to constructor. (libparticles)
// vtable is first offset in function.

class CParticleControlPoint;

class CParticleCollection
{
public:
    virtual CSchemaClassBinding* Schema_DynamicBinding(void) = 0;
    virtual void* GetOwner(void) = 0;
    virtual void SetAssociatedObj( void * )= 0;
    virtual void* GetAssociatedObj()= 0;
    virtual void SetSomethingElse( void* )= 0;
    virtual void* GetSomethingElse()= 0;
    virtual bool IsValid(void)= 0;
    virtual bool IsFullyValid(void)= 0;
    virtual void* GetDefinition(void)= 0;
    virtual CParticleCollection* GetParentCollection(void) = 0;
    virtual CParticleCollection* GetFirstChildCollection(void) = 0;
    virtual CParticleCollection* GetNextSiblingCollection(void) = 0;
    virtual CParticleCollection* GetNextCollectionUsingSameDef(void) = 0;
    virtual bool UsesPowerOfTwoFrameBufferTexture(bool) = 0;
    virtual void sub_105ED0() = 0;
    virtual void sub_1062B0() = 0;
    virtual void sub_1064A0() = 0; // confirmed void
    virtual void SetOrientationFLU() = 0;
    virtual void sub_105C60() = 0;
    virtual void sub_107C90() = 0;
    virtual void sub_1073F0() = 0;
    virtual Vector* GetControlPointPosition(int index) = 0; // ***think this is it***
    virtual void sub_105861() = 0;
    virtual CParticleControlPoint* GetControlPointObject(int index) = 0;
    virtual void sub_105D00() = 0;
    virtual void sub_105740() = 0;
    virtual void sub_1056B0() = 0;
    virtual void sub_105700() = 0;
    virtual void sub_12DDA0() = 0;
    virtual void FullRestart(void) = 0;
    virtual void Simulate( float dt ) = 0;
    virtual void SleepingSimulate( float dt ) = 0;
    virtual void SkipToTime( float time ) = 0;
    virtual float GetSimulationTime(void) = 0;
    virtual bool IsFinished(void) = 0;
    virtual float GetNextSleepTime(void) = 0;
    virtual void UpdateNextSleepTime(void) = 0;
    virtual void sub_106350() = 0;
    virtual void sub_106390() = 0;
    virtual void sub_106450() = 0;
    virtual void sub_1063D0() = 0;
    virtual void sub_106410() = 0;
    virtual void sub_105F40() = 0;
    virtual void sub_124A80() = 0;
    virtual void sub_1249B0() = 0;
    virtual void sub_126AA0() = 0;
    virtual bool IsBoundsValid(void) = 0;
    virtual Vector* GetMinBounds(void) = 0;
    virtual Vector* GetMaxBounds(void) = 0;
    virtual void sub_105830() = 0;
    virtual void sub_105840() = 0;
    virtual void SetMinBounds(Vector min) = 0;
    virtual void SetMaxBounds(Vector max) = 0;
    virtual void BloatBoundsUsingControlPoint(void) = 0;
    virtual void DrawDebug(void *IRenderContext, void const * CSceneObject, void *ISceneView, void *ISceneLayer, int, int) = 0;
    virtual void StartEmission(bool) = 0;
    virtual void StopEmission(bool, bool, bool, bool) = 0; // first one if false, particles at 0,0,0  -- last one if false, renders them normally
    virtual bool IsEmissionStopped(void) = 0;
    virtual bool IsEmitting(void) = 0;
    virtual float GetMinimumTimeStepModifier(void) = 0;
    virtual void StartQueuedEmission(void) = 0;
    virtual void SetDormant(bool state) = 0;
    virtual bool IsDormant(void) = 0;
    virtual void sub_105950() = 0;
    virtual void sub_105980() = 0;
    virtual void sub_105990() = 0;
    virtual void sub_133E00() = 0;
    virtual void sub_12E910() = 0;
    virtual void sub_12A3E0() = 0;
    virtual void sub_12A420() = 0;
    virtual void SetQueuedStartEmission(bool state) = 0;
    virtual bool GetQueuedStartEmission(void) = 0;
    virtual bool IsFrozen(void) = 0;
    virtual void SetFrozen(bool state) = 0;
    virtual void sub_12FCD0() = 0;
    virtual void sub_130990() = 0;
    virtual void sub_1241D0() = 0;
    virtual void DESTRUCTOR() = 0;
    virtual void DESTRUCTOR_2() = 0;
    virtual void sub_123F70() = 0;
    virtual void sub_105770() = 0;
    virtual void sub_1057A0() = 0;
    virtual void sub_12A290() = 0;
    virtual void SetOwningSceneObject( void *CSceneParticleObject) = 0;
    virtual void* GetOwningSceneObject(void) = 0;
    virtual void SetMaterialOverride() = 0; // (CWeakHandle<InfoForResourceTypeIMaterial2>)
    virtual bool GetRenderingEnabled(void) = 0;
    virtual void SetRenderingEnabled(bool state) = 0;
    virtual bool InEndCap(void) = 0;
    virtual int GetFlags(void) = 0;
    virtual void SetFlags(int ParticleCollectionFlags_t) = 0; // these flags are tricky, no clue what they do except crash ur game and make particles spawn at the origin.
    virtual void RemoveFlags(int ParticleCollectionFlags_t) = 0;
    virtual void GetSecondarySceneObjects() = 0;// (CUtlVector<CSceneObject *,CUtlMemory<CSceneObject *,int>> &)
    virtual bool HasAttribute(int) = 0;
    virtual void SetMinimumTimeStepModifier(float min) = 0;
    virtual void GetPerformanceData(void **ParticleCollectionPerf_t) = 0;
    virtual void OnSleepingStateChanged(bool) = 0;
    virtual void ValidateSystem(bool *, void *CUtlString) = 0;
    virtual int GetSystemParticleCount(void) = 0;
    virtual int GetSystemMaxParticleCount(void) = 0;
    virtual int GetTotalSystemCount(void) = 0;
    virtual void sub_1248F0() = 0;
    virtual void sub_1244B0() = 0;
    virtual void sub_124040() = 0;
    virtual void sub_1056F0() = 0;

    size_t GetHighestControlPoint( void )
    {
        return *(int*)(uintptr_t(this) + 0xEC);
    }
};
```

`src/SDK/CParticleSystemMgr.h`:

```h
#pragma once

#include "IAppSystem.h"
#include "CParticleCollection.h"

struct ParticleFilterType_t;
struct ParticleFunctionType_t;

struct ParticleFullRenderData_Scalar_View;

class CParticleVisibilityData;
class IParticleSnapshot;
class IParticleSystemQuery;
class ISceneWorld;
class CParticleSystemDefinition;

struct InfoStruct
{
    const char *name;
    //....
};
struct WeakHandleContents_InfoForResourceTypeIParticleSystemDefinition
{
    CParticleSystemDefinition* systemDefinition;
    InfoStruct *info;
    char _pad[0x200];
};
// this is real sloppy :(
struct CWeakHandle_InfoForResourceTypeIParticleSystemDefinition
{
    WeakHandleContents_InfoForResourceTypeIParticleSystemDefinition *contents;
};

// Xref "New Particle Systems Matching '%s':\n" to DumpParticleList (libparticles.so)
// OR "CParticleSystemMgr::CreateParticleCollection( Handle )" to CreateParticleCollection2
class CParticleSystemMgr : IAppSystem
{
public:
    virtual void SetFallbackParameters( float, float, float, float ) = 0; // 11
    virtual void SetSystemLevel( int, int ) = 0;
    virtual void SetLowViolence( bool status ) = 0;
    virtual bool IsLowViolence( void ) = 0;
    virtual void* FindParticleSystem( const char *, bool ) = 0;
    virtual void* GetParticleSystemDefinitionBinding( void ) = 0;
    virtual CParticleCollection* CreateParticleCollection( const char *, void *, IParticleSystemQuery *, bool, float, int ) = 0; // might be changed.
    virtual CParticleCollection* CreateParticleCollection_Handle( CWeakHandle_InfoForResourceTypeIParticleSystemDefinition *info, void *, IParticleSystemQuery *, bool, float, int ) = 0;
    virtual void DestroyParticleCollection( CParticleCollection * ) = 0;
    virtual void sub_135CC0() = 0;
    virtual void sub_135CC0_2() = 0;
    virtual void sub_135CD0() = 0;
    virtual const char *GetParticleFieldName( ParticleFilterType_t ) = 0;
    virtual int  GetParticleOperatorCount( ParticleFunctionType_t ) = 0;
    virtual void* GetParticleOperator(ParticleFunctionType_t, int) = 0;
    virtual void SetLastSimulationTime( float time ) = 0;
    virtual float GetLastSimulationTime( void ) = 0;
    virtual void SetLastSimulationDuration( float duration ) = 0;
    virtual float GetLastSimulationDuration( void ) = 0;
    virtual void DumpParticleList( const char * ) = 0; // 30
    virtual void CreateParticleSceneObject( const char *, ISceneWorld *, IParticleSystemQuery *, float, int ) = 0;
    virtual void CreateParticleSceneObject2( void *CWeakHandle_InfoForResourceTypeIParticleSystemDefinition, ISceneWorld *, IParticleSystemQuery *, float, int ) = 0;
    virtual void CreateParticleSceneObject3( CParticleCollection *, ISceneWorld *, bool ) = 0;
    virtual void GenerateExtendedSortedIndexList( Vector, const Vector *, CParticleVisibilityData *, CParticleCollection *, bool, void *, ParticleFullRenderData_Scalar_View **, bool ) = 0;
    virtual int ParticleRandomInt( CParticleCollection *, int min, int max ) = 0;
    virtual float ParticleRandomFloat( CParticleCollection *, float min, float max ) = 0;
    virtual const char *GetParticleAttributeName( int ) = 0; // "unknown"
    virtual void sub_135B00() = 0;
    virtual void sub_1362F0() = 0;
    virtual void sub_135AB0() = 0;
    virtual void sub_1183B0() = 0;
    virtual void sub_135B20() = 0;
    virtual void sub_144660() = 0; // added post-anime
    virtual IParticleSnapshot CreateParticleSnapshot( void ) = 0;
    virtual void DestroyParticleSnapshot( IParticleSnapshot * ) = 0;
    virtual void sub_135A80() = 0;
    virtual void sub_135A90() = 0;
    virtual void sub_135D60() = 0;
};
```

`src/SDK/CRenderDeviceGL.h`:

```h
#pragma once

class CRenderDeviceBase;

//xref "Shader API Driver Info:\n\n" to CRenderDeviceGL::SpewDriverInfo() (librendersystemgl)
class CRenderDeviceGL
{
public:

};
```

`src/SDK/CRenderGameSystem.h`:

```h
#pragma once

#include "vmatrix.h"

class CViewSetup;
class CRenderGameSystem;

class CRenderGameSystem // : IGameSystem
{
public:
// really isn't that interesting. ( not mapped )
   // EnableSplitscreenRendering(SceneObjectUpdaterHandle_t__ *,uint)
   // Push3DView(CViewSetup const&,int,ITexture *,VPlane *)
   // Push2DView(CViewSetup const&,int,ITexture *,VPlane *)
   // PopView(VPlane *)
   // ViewMatrix(void)
   // WorldToProjectionMatrix(int)
};
```

`src/SDK/CSoundOPSystem.h`:

```h
#pragma once

#include "IAppSystem.h"

typedef void* sound_voice_layer_t;
typedef void* SoundEventGuid_t;


//xref "SoundOpSystem001" to ::QueryInterface() - [libsoundsystem]
// function will be short and only contains a stricmp()
class CSoundOpSystem : IAppSystem
{
public:
    /* This one is for Menu Sounds */
    virtual void StartSoundEvent(const char *, int entIndex, short, void const *, int) = 0;
    virtual void unk() = 0; //added around the time the furry hero came out, maybe earlier. -- I imagine this is just another StartSoundEvent() with different params
    /* This one is for In-Game Sounds */
    //virtual void StartSoundEvent2(unsigned int, int entIndex, sound_voice_layer_t, short, const char *, void const *, int, SoundEventGuid_t) = 0;
    virtual void StartSoundEvent2(void *unkParamStruct) = 0;

    /* This class is Incomplete! This one is a pain */

    //virtual void StopSoundEvent(SoundEventGuid_t) = 0;
    //virtual void StopSoundEvent2(unsigned int, int entIndex) = 0;
    //virtual void StopSoundEvent3(const char*, int entIndex) = 0;
};
```

`src/SDK/CSource2Client.h`:

```h
#pragma once
#include "IAppSystem.h"
#include "IInputSystem.h"
#include "vector.h"
#include "definitions.h"
#include "Schema.h"
#include "CViewSetup.h"

#include "../Utils/Util.h"

class ClientClass
{
public:
	char* m_pNetworkName; //0x0000 //EX: CDOTAPlayer
	char* m_pClassName; //0x0008 //EX: C_DOTAPlayer
	ClientClass* m_pNext; //0x0010
	void* m_pCreateFn; //0x0018
	//void* m_pCreateEventFn; //0x0020 // seems to be removed in dota-anime function.
	void* m_pDestroyFn; //0x0028
	char pad_0030[8]; //0x0030
	char* m_pLibNameAndClassName; //0x0038 //EX: libclient.so!C_DOTAPlayer
	SchemaRecvTable* recvTable; //0x0040
	char pad_0048[20]; //0x0048
	EClassIds m_ClassID; //0x005C
	void* N00000046; //0x0060
	void* N00000047; //0x0068
};

class RnQueryAttr_t
{
public:
	/*
    virtual bool ShouldHitEntity( void *CEntityInstance )
    {
        Util::Log("Uhhh Should Hit Entity called!\n");
        return true;
    }*/
    void *unk; // defo a pointer
    void *unk2;
    void *unk3;
    int entskipHandle; // 0x18 - 0FFFFFFFFh -1 for none
    unsigned int maskMaybe; // 0x1C
    int type; // 0x20 - have seen 7 and 1.
    int unk4; // 0x24
    bool (* HandleHitEnt)( void *IHandleEntity, int unk ); // 0x28
    unsigned int mask;
    float maxDist; // BIG GUESS 1.0f
};
class RnQueryTerrain : public RnQueryAttr_t
{
public:
	void Init(unsigned int uMask, int entitySkipHandle = 0xFFFFFFFF, bool (* HitEntHandler)( void *, int ) = nullptr )
	{
		unk = 0;
		unk2 = 0;
		unk3 = 0;
		unk4 = 0;
		type = 1;
		entskipHandle = entitySkipHandle;
		maskMaybe = 0x9040000;
		mask = uMask;
		HandleHitEnt = HitEntHandler;
		maxDist = 1.0f;
	}
};

struct Ray_t
{
	VectorAligned start;
	VectorAligned delta;
	VectorAligned startOffset; // zero unless using mins/maxs
	VectorAligned extents;     // ^^
    int _unk;

	bool isRay;
	bool isSwept;
    bool unkBool;
    bool unkBool2;

    void *_unk2;

    void Init(Vector vecStart, Vector vecEnd)
	{
		delta = vecEnd - vecStart;
        delta.w = 0.0f;
		isSwept = (delta.LengthSqr() != 0);
		extents.x = extents.y = extents.z = extents.w = 0.0f;
        isRay = true;
		startOffset.x = startOffset.y = startOffset.z = startOffset.w = 0.0f;
		start = vecStart;
        start.w = 0.0f;
        _unk = 0;
        unkBool = false;
        unkBool2 = false;
        _unk2 = 0;
	}
};

struct CGameTrace
{
    Vector start;
    Vector end;
    Vector normal;
    void *unks[2];
    float fraction;
    char _pad[0x300];
};

/* xref "-pressdemo" to CSource2Client::Init */
class CSource2Client : IAppSystem
{
public:
	virtual void SetGlobals(void* CGlobalVarsBase); // 11
	virtual void InstallStringTableCallback(const char *tableName);
	virtual void PlayerInfoChanged(int entIndex);
	virtual void ClearInstancedBaselineFromClientClasses(void);
	virtual void CreateMove(int splitScreenSlot, int unk, bool unk2);
	virtual void sub_2B5FF10();
	virtual void sub_2B5FF30();
	virtual void SendMove(int splitScreenSlot, int unk);
	virtual void ProcessInput(int splitScreenSlot, float unk, bool unk2);
	virtual void WriteUsercmdDeltaToBuffer(int splitScreenSlot, void* bf_write, int from, int to, bool isnewcommand); // 20
	virtual void EncodeUserCmdToBuffer(int splitScreenSlot, void* bf_write, int slot);
	virtual void DecodeIUserCmdFromBuffer(int splitScreenSlot, void* bf_read, int slot);
	virtual void GetEntity2Networkable(int entIndex, void* Entity2Networkable_t);
	virtual const char* GetEntity2ClassName(int entIndex);
	virtual void GetNetworkFieldChangeCallbackQueue(void);
	virtual void NotifyShouldTransmit();
	virtual ClientClass* GetAllClasses(void);
	virtual void ReceivedServerInfo(void* GameSessionConfiguration_t, void* ILoopModePrerequisiteRegistry);
	virtual void FrameStageNotify(ClientFrameStage_t stage);
	virtual void HudVidInit(void); // 30
	virtual void HudUpdate(bool bActive);
	virtual void HudReset(void);
	virtual void IN_ClearStates(void);
	virtual bool IN_IsKeyDown(const char *name, bool isDown);
	virtual void OnLevelLoadingStarted(void);
	virtual void CenterStringOff(void);
	virtual void View_Fade(void* ScreenFade_t);
	virtual void OnSplitScreenStateChanged(void);
	virtual int GetPlayerTeamIndex(int entIndex);
	virtual void sub_2B60070();
	virtual bool CanVoiceChat(void);
	virtual void OnFullEntityUpdate(void);
	virtual void OnServerConnectionTimedOut(void const * ns_address);
	virtual void sub_2B60080();
	virtual void UpdateAudioState(void* AudioState_t, int splitScreenSlot);
	virtual void sub_2B60040();
	virtual void sub_2B6E830();
	virtual void View_Render(void* vrect_t);
	virtual void SetBlurFade(float blurFade);
	virtual void* GetSoundSpatialization(int entIndex, void* SpatializationInfo_t);
	virtual void sub_2E35350( void *rsi ); // Added with diretide-2020, sets some sort of utlstring.
	virtual void NotifyClientSignon(int unk);
	virtual int unk_30A6910(); // Added with Furry fetish hero - CUtlString::IsEqual_CaseSensitive
	virtual bool CanRecordDemo(char * unk, int unk2);
	virtual void OnDemoRecordStart(const char* name);
	virtual void OnDemoRecordStop(void);
	virtual void OnDemoPlaybackStart(const char* name, const char*** unk);
	virtual void OnDemoPlaybackStop(void);
	virtual void OnDemoPlaybackGoto();
	virtual void SetupScrubbingData();
	virtual void sub_2B7D850();
	virtual void OnScrubDemo(int unk);
	virtual void OnDemoSkip(int unk, int unk2, bool unk3);
	virtual bool ShouldNopCmdDuringDemoSkip(int unk);
	virtual void InitInstantReplayData(void* InstantReplayMessage_t, int unk);
	virtual void ClearInstantReplayData(void);
	virtual void UpdateProgressBar(float unk, const char* unk2);
	virtual bool ShouldPauseForToolUI(void);
	virtual void UpdateVguiPanels(void);
	virtual void* GetFullscreenClientDLLVPanel(void);
	virtual bool ShouldHideLoadingPlaque(void);
	virtual void GetBugReportInfo(int unk, void* CUtlBuffer, void* CUtlString, void* CUtlString2);
	virtual void OnKeyBindingChanged(ButtonCode_t key, const char* unk, const char* unk2);
	virtual void Source2MouseAccumulationPassThrough(int unk, int unk2);
	virtual void GetCameraPosition(int entIndex, int splitScreenSlot, void* CTransform);
	virtual void GetEyeAngles(int splitScreenSlot, QAngle *out);
	virtual void SnapEyeAngles(int splitScreenSlot, const QAngle &viewAngles);
	virtual void sub_30F5A80(); // added with dota-anime
	virtual void sub_2B65490();
	virtual void GetEntity2AbsOrigin(int entIndex, Vector *out);
	virtual void sub_2B65510();
	virtual void GetEntity2AbsAngles(int entIndex, QAngle *out);
	virtual void sub_2B65710();
	virtual void sub_30F6250(); // added with dota-anime
    virtual void sub_30F5780(); // added with dota-anime
	virtual void sub_2B65AA0();
	virtual void* GetEntityInfo(void);
	virtual void DescribeNetworkedField();
	virtual void PerformClientSpecificSetupForPlayerViews();
	virtual CViewSetup* GetPlayerViewSetup(int splitScreenSlot);
	virtual void GetBugReportLaunchURLParameters(void* KeyValues);
	virtual void sub_2B61BB0();
	virtual void sub_2B600F0();
	virtual void UpdateProjectedTexture();
	virtual void DeleteProjectedTexture();
	virtual void UpdateDeferredLight();
	virtual void DeleteDeferredLight();
	virtual int TraceRay(const Ray_t &ray, RnQueryAttr_t filter, CGameTrace* traceOut);
	virtual void GetPointContents(Vector unk, int unk2);
	virtual void LaunchApplicationOnExit(const char* pathMaybe);
	virtual void DotaEconGetSoundReplacement(const char* pathMaybe);
	virtual void sub_2B61B10();
	virtual void sub_2B630A0();
	virtual void NotifyPreSteamRunCallbacks(void);
	virtual bool VoiceReliable(void);
	virtual void UpdateWhenNotInGame(float unk);
	virtual void UpdateGlobalLightFromLightInfos();
	virtual void GetGlobalLightParameters();
	virtual void OnReceivedUpdatedServerPeerList();
	virtual void UpdateEventListeners();
	virtual void GetEconItemSystem();
	virtual void GameCreateNetworkStringTables();
	virtual void NotifyDisconnect();
	virtual void GetModelCombineInfo();
	virtual void sub_2B5FF40();
	virtual void sub_2B60190();
	virtual void sub_2B601A0();
	virtual void sub_2B61460();
	virtual void sub_2B5FF80();
	virtual void sub_2B5FFA0();
	virtual void sub_2B61940();
    virtual void sub_2E32F90(); // added with Diretide-2020
    virtual void sub_2E359D0(); // added with Diretide-2020
    virtual void sub_358E350(); // added with Road to TI10
    virtual void sub_3591680(); // added with Road to TI10
    virtual void sub_35959C0(); // added with Road to TI10
	virtual void sub_2B65BD0(); // guard_acquire
	virtual void sub_someDebugShit(); //%5d: %8.6f msec change ',27h,'%s()',27h,' on field %s(path=%s) fo' db 'r ent %s(%s) name=',27h,'%s',27h,0Ah
};

```

`src/SDK/CSplitScreenService.h`:

```h
#pragma once
#include "IAppSystem.h"
#include "CDotaPlayer.h"

class CBaseEngineService : IAppSystem
{
public:
    virtual void GetServiceDependencies(); // 11
    virtual const char* GetName();
    virtual bool ShouldActivate();
    virtual void OnLoopActivate();
    virtual void OnLoopDeactivate();
    virtual bool IsActive();
    virtual void SetActive(bool active);
    virtual void SetName(const char* name);
    virtual void RegisterEventMap();
    virtual int GetServiceIndex(); // 20
    virtual void SetServiceIndex(int index); // 21
};

// "OnEngineSplitscreenClientAdded" to AddSplitScreenUser
class CSplitScreenService : CBaseEngineService
{
public:
    virtual void Destroy() = 0; // 22
    virtual void Destroy2()= 0;
    virtual void AddSplitScreenUser(int splitScreenSlot, void* SplitScreenClient_t) = 0; // 24
    virtual void AddBaseUser(int splitScreenSlot, void* SplitScreenClient_t)= 0;
    virtual void RemoveSplitScreenUser(int splitScreenSlot)= 0;
    virtual int GetActiveSplitScreenPlayerSlot(void)= 0;
    virtual void SetActiveSplitScreenPlayerSlot(int splitScreenSlot)= 0;
    virtual bool IsValidSplitScreenSlot(int splitScreenSlot)= 0;
    virtual int FirstValidSplitScreenSlot(void)= 0;
    virtual int NextValidSplitScreenSlot(int splitScreenSlot)= 0;
    virtual int GetNumSplitScreenPlayers(void)= 0;
    virtual int GetSplitScreenPlayerEntity(int splitScreenSlot)= 0;
    virtual void* GetSplitScreenPlayerNetChan(int splitScreenSlot)= 0;
    virtual bool IsDisconnecting(int splitScreenSlot)= 0;
    virtual void SetDisconnecting(int splitScreenSlot, bool disconnecting)= 0;
    virtual void SetLocalPlayerIsResolvable(const char* unk, int unk2, bool resolvable)= 0;
    virtual bool IsLocalPlayerResolvable(void)= 0;
    virtual int GetMaxSplitScreenPlayers(void)= 0;
    virtual bool IsSplitScreenPlayerEntity(int entIndex)= 0;
    virtual int FindSplitPlayerSlot(int entIndex)= 0;
    virtual void ReadSomethingFromSteamCloud()= 0;
    virtual void WriteSomethingToSteamCloud()= 0;
    virtual void GenerateSomeUserConfigurationFile()= 0;
    virtual void EmptyFunc()= 0;
    virtual void EmptyFunc2()= 0;
};
```

`src/SDK/CUtlMemory.h`:

```h
#pragma once

template <class T, class I = int>
class CUtlMemory
{
	public:
		T& operator[](I i)
		{
			return m_pMemory[i];
		}

		T* m_pMemory;
		int m_nAllocationCount;
		int m_nGrowSize;
};

```

`src/SDK/CUtlString.h`:

```h
#pragma once

#include "CUtlMemory.h"

class CUtlString
{
public:

    const char* Get()
    {
        return reinterpret_cast<const char*>( m_Memory.m_pMemory );
    }

    CUtlMemory<uint8_t> m_Memory;
    int m_nActualLength;
};
```

`src/SDK/CUtlVector.h`:

```h
#pragma once

template <class T>
class CUtlVector
{
	public:
		T& operator[](int i)
		{
			return m_pElements[i];
		}

		[[nodiscard]] int Count() const
		{
			return m_Size;
		}
		int m_Size;
		T* m_pElements;
};
```

`src/SDK/CVPhys2World.h`:

```h
#pragma once

class CVPhys2World
{
public:


};
```

`src/SDK/CVScriptGameSystem.h`:

```h
#pragma once

typedef unsigned long long HSCRIPT ; // looks to be used for script scope.
class CVScriptGameSystem
{
public:
    virtual void IGameSystem__Init(void) = 0;
	virtual void IGameSystem__PostInit(void) = 0;
	virtual void IGameSystem__Shutdown(void) = 0;
	virtual void CVScriptGameSystem__GameInit(void* const EventGameInit_t) = 0;
	virtual void CVScriptGameSystem__GameShutdown(void* const EventGameShutdown_t) = 0;
	virtual void sub_27924A0() = 0;// All these functions are empty void functions.
	virtual void sub_27924B0() = 0;// they aren't that great
	virtual void sub_285D370() = 0;
	virtual void sub_27924D0() = 0;
	virtual void sub_27924E0() = 0;
	virtual void sub_27924F0() = 0;
	virtual void sub_2792500() = 0;
	virtual void sub_2792510() = 0;
	virtual void sub_2792520() = 0;
	virtual void sub_2792530() = 0;
	virtual void sub_2792540() = 0;
	virtual void sub_2792550() = 0;
	virtual void sub_2792560() = 0;
	virtual void sub_2792570() = 0;
	virtual void sub_2792580() = 0;
	virtual void sub_2792590() = 0;
	virtual void sub_27925A0() = 0;
	virtual void sub_27925B0() = 0;
	virtual void sub_27925C0() = 0;
	virtual void sub_27925D0() = 0;
	virtual void sub_27925E0() = 0;
	virtual void sub_27925F0() = 0;
	virtual void OnServerGamePostSimulate(void* EventServerGamePostSimulate_t) = 0;
	virtual void OnClientGamePostSimulate(void* EventClientGamePostSimulate_t) = 0;
	virtual void FrameBoundary(void* EventGameFrameBoundary_t) = 0;
	virtual void OutOfGameFrameBoundary(void* EventOutOfGameFrameBoundary_t) = 0;
	virtual void SaveGame(void* EventSaveGame_t) = 0;
	virtual void RestoreGame(void* EventRestoreGame_t) = 0;
	virtual const char* GetName(void) = 0;
	virtual void SetGameSystemGlobalPtrs(void* addr) = 0;
	virtual void SetName(const char* name) = 0;
	virtual bool DoesGameSystemReallocate(void) = 0;
	virtual void Destroy1() = 0;
	virtual void Destroy2() = 0;
	virtual void YouForgot_DECLARE_GAME_SYSTEM_InYourClassDefinition() = 0;
	virtual void VScriptInit(void) = 0;
	virtual void VScriptTerm(void) = 0;
	virtual bool IsVScriptInitialized(void) = 0;
	virtual bool IsEntityCreationAllowedInScripts(void) = 0;
	virtual void* GetVM(void) = 0;
	virtual void CompileScript(const char* name, bool unk) = 0;
	virtual void RunScript(const char* name, HSCRIPT scope, bool unk) = 0;
	virtual void RunScript(const char* name, bool unk) = 0;
	virtual void RunScript(const char* name) = 0;
	virtual HSCRIPT FetchCachedScriptScope(const char* name) = 0;
	virtual void ClearCachedScripts(void) = 0;
	virtual void ReloadCachedScripts(void) = 0;
	virtual void RegisterGameEventListenersInScope(HSCRIPT scope) = 0;
	virtual void UnRegisterGameEventListenersInScope(HSCRIPT scope) = 0;
	virtual void ClearScriptGameEventListeners(void) = 0;
	virtual int GetScriptLanguage(void) = 0; // I think lua is #1?
	virtual void InstallScriptBindings(void) = 0; // Registers all the available commands the scripting language can use.
	virtual void RemoveScriptBindings(void) = 0; // unregisters all commands. ^^
};
```

`src/SDK/CViewRender.h`:

```h
#pragma once

class CViewSetup;
struct SceneFogParams_t;

/* not sure if accurate for source2 */
struct vrect_t
{
    int				x,y,width,height;
    vrect_t			*pnext;
};

//xref "screenfademinsize" to the constructor of this class. The Vtable should be the first off_xxxxx pointer in the section.
// Warning: not at the top, the caller is inlined.
class CViewRender
{
public:
    // SETUP
    // Initialize view renderer
    virtual void Init(void);
    // Clear any systems between levels
	virtual void LevelInit(void);
	virtual void LevelShutdown(void);
    // Shutdown
	virtual void Shutdown(void);

    // RENDERING
    // Called right before simulation. It must setup the view model origins and angles here so
    // the correct attachment points can be used during simulation.
	virtual void OnRenderStart(void);
    virtual void unk();

    // Called to render the entire scene
	virtual void Render(vrect_t *);
    // Called to render just a particular setup ( for timerefresh and envmap creation )
	virtual void RenderView(CViewSetup const&,CViewSetup const&,int clearFlags,int whatToDraw); // 7
	virtual const CViewSetup* GetPlayerViewSetup(int CSplitScreenSlot);
	virtual void CullBox();//VectorAligned const&,VectorAligned const&,CSplitScreenSlot);
	virtual const CViewSetup* GetViewSetup(void);
	virtual void RestoreLastViewSetups(void);
	virtual void DisableVis(void);
	virtual void SetScreenOverlayMaterial();//CWeakHandle<InfoForResourceTypeIMaterial2>);
	virtual void* GetScreenOverlayMaterial(void);
	virtual void GetScreenFadeDistances(float *min,float *max); // 15
	virtual bool AllowScreenspaceFade(void);
	virtual void InitFadeData(void);
	virtual void ComputeViewSetupForPlayer(int CSplitScreenSlot);
	virtual void GetFogStart(SceneFogParams_t *);
	virtual void GetFogEnd(SceneFogParams_t *); // 20
	virtual float GetZNear(void);
	virtual float GetZFar(void);
	virtual float GetLODOverride(void);
    virtual bool unk2();
	virtual void DESTROY1();
	virtual void DESTROY2();
	virtual void Render2DEffectsPreHUD(CViewSetup const&);
	virtual void Render2DEffectsPostHUD(CViewSetup const&);
	virtual void ShouldForceNoVis(void);
	virtual void PreViewDrawScene(CViewSetup const&);
	virtual void PostViewDrawScene(CViewSetup const&);
	// couple more empty funcs..
};
```

`src/SDK/CViewSetup.h`:

```h
#pragma once

#include "vector.h"
class CViewSetup
{
public:
    Vector position;
    Vector angle;
    float fov; //0x0018
    float aspectRatio; //0x001C
    float zNear; //0x0020
    float zFar; //0x0024
    char _pad[0x18C];
    float cameraX;
    float unk[3];
    float cameraY;
    float unk2[3];
    float cameraZ; // 0x01D4
    char _pad2[0x218];
    Vector camPos; // 0x3F0
    char _pad3[0x150];
};
```

`src/SDK/ConMsg.h`:

```h
#pragma once

#include "color.h"

// Calls tier0.dll's export to output a message to the console. Uses printf style parameters.
// Gets resolved at run-time

// This is a nice safe way to output to the console without any requirements.
void ConMsg( const char *format, ... );

// Update with Aghanim's Labyrinth - Valve has removed the printing functions in ICvar.
// Use exported ConColorMsg in tier0
void ConColorMsg( const Color &color, const char *format, ... );
```

`src/SDK/Convar.h`:

```h
#pragma once

#include "color.h"
#include "CUtlMemory.h"
#include "CUtlVector.h"

#include <cstdint>

// findflags in console
#define FCVAR_UNREGISTERED	            (1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY           (1<<1)  // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL                   (1<<2)
#define FCVAR_CLIENTDLL                 (1<<3)

#define FCVAR_PROTECTED                 (1<<5)
#define FCVAR_SPONLY                    (1<<6)
#define FCVAR_ARCHIVE                   (1<<7)
#define FCVAR_NOTIFY                    (1<<8)
#define FCVAR_USERINFO                  (1<<9)

#define FCVAR_PRINTABLEONLY             (1<<10)
#define FCVAR_UNLOGGED                  (1<<11)
#define FCVAR_NEVER_AS_STRING           (1<<12)

#define FCVAR_REPLICATED                (1<<13)
#define FCVAR_CHEAT                     (1<<14)
#define FCVAR_SS                        (1<<15)
#define FCVAR_DEMO                      (1<<16)
#define FCVAR_DONTRECORD                (1<<17)
#define FCVAR_SS_ADDED                  (1<<18)
#define FCVAR_RELEASE                   (1<<19)
#define FCVAR_RELOAD_MATERIALS          (1<<20)
#define FCVAR_RELOAD_TEXTURES           (1<<21)
#define FCVAR_NOT_CONNECTED             (1<<22)
#define FCVAR_MATERIAL_SYSTEM_THREAD    (1<<23)
#define FCVAR_ARCHIVE_XBOX              (1<<24)

#define FCVAR_ACCESSIBLE_FROM_THREADS   (1<<25)

#define FCVAR_LINKED_CONCOMMAND         (1<<26)
#define FCVAR_VCONSOLE_FUZZY_MATCHING   (1<<27)

#define FCVAR_SERVER_CAN_EXECUTE        (1<<28)
#define FCVAR_SERVER_CANNOT_QUERY       (1<<28)
#define FCVAR_VCONSOLE_SET_FOCUS        (1<<29)
#define FCVAR_CLIENTCMD_CAN_EXECUTE     (1<<30)
#define FCVAR_EXECUTE_PER_TICK          (1<<31)


// This ConVar class is now p90
// The vtable is unimplemented and grabbed from an existing convar

struct CVValue_t
{
    char *m_pszString;
    int m_stringLength;
    float m_fValue;
    int m_nValue;
    int _pad4;
};

class ConCommandBase
{
public:
    virtual void DESTROY1() = 0;
    virtual void DESTROY2()= 0;
    virtual bool IsCommand(void)= 0;
    virtual	bool IsBoundedVar(void)= 0;
    virtual	bool IsFlagSet(long long)= 0;
    virtual	void AddFlags(long long)= 0;
    virtual	void RemoveFlags(long long)= 0;
    virtual	long long GetFlags(void)= 0;
    virtual	const char* GetName(void)= 0;
    virtual	const char* GetHelpText(void)= 0;
    virtual	bool IsRegistered(void)= 0;
    virtual	void* GetDLLIdentifier(void)= 0;
    virtual	void Create(char const*,char const*,long long)= 0;
    virtual	void Init(void)= 0;
    virtual	const char* GetBaseName(void)= 0;
    virtual	int GetSplitScreenPlayerSlot(void)= 0;
    virtual	void SetValue(char const*)= 0;
    virtual	void SetValue(float)= 0;
    virtual	void SetValue(int)= 0;
    virtual	void SetValue(ColorRGBA)= 0;
    virtual	float GetFloat(void)= 0;
    virtual	int GetInt(void)= 0;
    virtual	bool GetBool(void)= 0;
    virtual	void InternalSetValue(char const*)= 0;
    virtual	void InternalSetFloatValue(float)= 0;
    virtual	void InternalSetIntValue(int)= 0;
    virtual	void InternalSetColorValue(ColorRGBA)= 0;
    virtual	void ClampValue(float &)= 0;
    virtual	void ChangeStringValue(char const*,float)= 0;
    virtual	void Create()= 0;//char const*,char const*,long long,char const*,bool,float,bool,float,void (*)(IConVar *,char const*,float)) = 0;

    ConCommandBase *m_pNext;
    bool m_bRegistered;
    char _pad[7];
    char *m_pszName;
    char *m_pszHelpString;
    uint32_t m_nFlags;
    char _padflags[4]; //alignment
};

class ConVar;
typedef void (*ConVarHandlerFn)(ConVar*,char const*,float);

class ConVar : public ConCommandBase
{
public:
    void *ConVar_vtable;
    ConVar *parent;
    char *m_pszDefaultValue;
    CVValue_t m_Value;
    /// this section has changed, dont expect it to work.
    bool bHasMin;
    char _pad1[3];
    float m_fMinVal;
    bool bHasMax;
    char _pad2[3];
    float m_fMaxVal;
    /// end
    CUtlVector<ConVarHandlerFn> m_fnChangeCallbacks;

    inline bool AddChangeCallback( ConVarHandlerFn callback )
    {
        // only support 1 callback, don't see a reason for more.
        if( this->m_fnChangeCallbacks.m_Size > 0 || this->m_fnChangeCallbacks.m_pElements ){
            return false;
        }
        this->m_fnChangeCallbacks.m_Size++;
        this->m_fnChangeCallbacks.m_pElements = new ConVarHandlerFn[1];
        this->m_fnChangeCallbacks[0] = callback;
        return true;
    }
};
```

`src/SDK/Datamap.h`:

```h
#pragma once

typedef enum _fieldtypes : uint64_t
{
    FIELD_VOID = 0,			// No type or value
    FIELD_FLOAT,			// Any floating point value
    FIELD_STRING,			// A string ID (return from ALLOC_STRING)
    FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
    FIELD_QUATERNION,		// A quaternion
    FIELD_INTEGER,			// Any integer or enum
    FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
    FIELD_SHORT,			// 2 byte integer
    FIELD_CHARACTER,		// a byte
    FIELD_COLOR32,
    FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
    FIELD_CUSTOM,

    FIELD_CLASSPTR   = 0x0C,
    FIELD_EHANDLE    = 0x0D,

    FIELD_POSITION_VECTOR  = 0x0E,
    FIELD_TIME       = 0x0F,
    FIELD_TICK       = 0x10,
    FIELD_SOUNDNAME  = 0x11,

    FIELD_INPUT      = 0x12,
    FIELD_FUNCTION   = 0x13,

    FIELD_VMATRIX    = 0x14,

    FIELD_VMATRIX_WORLDSPACE  = 0x15,
    FIELD_MATRIX3X4_WORLDSPACE  = 0x16,

    FIELD_INTERVAL   = 0x17,
    FIELD_UNUSED     = 0x18,
    FIELD_VECTOR2D   = 0x19,
    FIELD_INTEGER64  = 0x1A,
    FIELD_VECTOR4D   = 0x1B,
    FIELD_RESOURCE   = 0x1C,
    FIELD_TYPEUNKNOWN  = 0x1D,
    FIELD_CSTRING    = 0x1E,
    FIELD_HSCRIPT    = 0x1F,
    FIELD_VARIANT    = 0x20,
    FIELD_UINT64     = 0x21,
    FIELD_FLOAT64    = 0x22,
    FIELD_POSITIVEINTEGER_OR_NULL  = 0x23,
    FIELD_HSCRIPT_NEW_INSTANCE  = 0x24,
    FIELD_UINT       = 0x25,
    FIELD_UTLSTRINGTOKEN  = 0x26,
    FIELD_QANGLE     = 0x27,
    FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_VECTOR  = 0x28,
    FIELD_HMATERIAL  = 0x29,
    FIELD_HMODEL     = 0x2A,
    FIELD_NETWORK_QUANTIZED_VECTOR  = 0x2B,
    FIELD_NETWORK_QUANTIZED_FLOAT  = 0x2C,
    FIELD_DIRECTION_VECTOR_WORLDSPACE  = 0x2D,
    FIELD_QANGLE_WORLDSPACE  = 0x2E,
    FIELD_QUATERNION_WORLDSPACE  = 0x2F,
    FIELD_HSCRIPT_LIGHTBINDING  = 0x30,

    FIELD_V8_VALUE   = 0x31,
    FIELD_V8_OBJECT  = 0x32,
    FIELD_V8_ARRAY   = 0x33,
    FIELD_V8_CALLBACK_INFO  = 0x34,

    FIELD_UTLSTRING  = 0x35,
    FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_POSITION_VECTOR  = 0x36,
    FIELD_HRENDERTEXTURE  = 0x37,
    FIELD_TYPECOUNT  = 0x38,
} fieldtype_t;

enum
{
    TD_OFFSET_NORMAL = 0,
    TD_OFFSET_PACKED = 1,

    // Must be last
    TD_OFFSET_COUNT,
};

class TypeDescription;

class Datamap
{
public:
    TypeDescription *dataDesc;
    uint64_t numFields;
    const char *className; // Ex: C_DOTAPlayer
    Datamap *baseMap; // Ex: For C_DOTAPlayer it would be next baseclass C_BasePlayer, can be NULL
};

class TypeDescription
{
public:
    fieldtype_t type;
    const char *fieldName;
    int fieldOffset[TD_OFFSET_COUNT];
    void *_unk[5];
    Datamap * td;
    void *_unk2[5];
};


```

`src/SDK/IAppSystem.h`:

```h
#pragma once

struct AppSystemInfo_t
{
    const char* m_pModuleName;
    const char* m_pInterfaceName;
};

enum InitReturnVal_t
{
    INIT_FAILED = 0,
    INIT_OK,

    INIT_LAST_VAL,
};

enum AppSystemTier_t
{
    APP_SYSTEM_TIER0 = 0,
    APP_SYSTEM_TIER1,
    APP_SYSTEM_TIER2,
    APP_SYSTEM_TIER3,

    APP_SYSTEM_TIER_OTHER,
};

typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);

/* Things that at the start of the Officially exported Interfaces */
/* Note that some classes may not include all of these */
class IAppSystem
{
public:
    virtual void Connect( CreateInterfaceFn factory ) = 0;
    virtual void Disconnect() = 0;
    // Here's where systems can access other interfaces implemented by this object
    // Returns NULL if it doesn't implement the requested interface
    virtual void* QueryInterface(const char* interfaceName) = 0; // normally has string of interface in it. EX: "PanoramaUIEngine001"
    virtual InitReturnVal_t Init() = 0;
    virtual void Shutdown() = 0;
    virtual void Preshutdown() = 0;
    // Returns all dependent libraries
    virtual const AppSystemInfo_t* GetDependencies() = 0;
    virtual AppSystemTier_t GetTier() = 0;
    // Reconnect to a particular interface
    virtual void Reconnect(void* factory, const char* pInterfaceName) = 0;
    virtual bool IsSingleton() = 0;
    virtual void GetBuildType() = 0; // 10
};
```

`src/SDK/IClientMode.h`:

```h
#pragma once
#include "CBaseEntity.h"
#include "vector.h"
#include "IInputSystem.h"

/* xref "dota_chat_ban_notification" to get to ClientModeDOTANormal::CanVoiceChat() (libclient) - 1st one, has "userid", is short */
class IClientMode
{
public:
    virtual void DESTROY1(void) = 0;
    virtual void DESTROY2(void) = 0;
    virtual void InitViewport(void) = 0;
    virtual void Init(int CSplitScreenSlot) = 0;
    virtual void VGUIShutdown(void) = 0;
    virtual void Shutdown(void) = 0;
    virtual void GameActivate(void) = 0;
    virtual void GameDeactivate(void) = 0;
    virtual void sub_2DE8190() = 0;
    virtual void sub_2DC3C50() = 0;
    virtual void sub_2DC3C60() = 0;
    virtual void sub_2DC3C80() = 0;
    virtual void sub_2DC61D0() = 0;
    virtual bool ShouldDrawDetailObjects(void) = 0;
    virtual bool ShouldDrawEntity(CBaseEntity *) = 0;
    virtual bool ShouldDrawLocalPlayer(CBaseEntity *) = 0;
    virtual bool ShouldDrawParticles(void) = 0;
    virtual bool ShouldDrawFog(void) = 0;
    virtual void OverrideView(void *CViewSetup) = 0;
    virtual void OverrideRenderBounds(int &,int &,int &,int &,int &,int &) = 0;
    virtual void OverrideAudioState(void* audioState_t) = 0;
    virtual void KeyInput(int, int buttonCode_t, const char*) = 0;
    virtual void GetSlotForKeyInput(void) = 0;
    virtual void StartMessageMode(int) = 0;
    virtual void sub_2DC5F20() = 0;
    virtual void sub_2DC4A00() = 0;
    virtual void sub_28DF9F0() = 0;
    virtual bool CreateMove(CUserCmd *cmd, QAngle &, Vector &) = 0;
    virtual void LevelInit(const char *newmap) = 0;
    virtual void LevelShutdown(void) = 0;
    virtual bool ShouldDrawViewModel(void) = 0;
    virtual bool ShouldDrawCrosshair(void) = 0;
    virtual void PreRender(void *CViewSetup) = 0;
    virtual void PostRenderVGui(void) = 0;
    virtual void DoPostScreenSpaceEffects(void const * CViewSetup) = 0;
    virtual void ActivateInGameVguiContext(void *vguiPanel) = 0;
    virtual void DeactivateInGameVGuiContext(void) = 0;
    virtual float GetViewModelFOV(void) = 0;
    virtual bool CanRecordDemo(void) = 0;
    virtual void OnColorCorrectionWeightsReset(void) = 0;
    virtual void OnRemoveColorCorrectionEntity(void* CColorCorrection) = 0;
    virtual void GetColorCorrectionScale(void) = 0;
    virtual void OnResetHUD(void) = 0;
    virtual void HudElementKeyInput(int, int buttonCode_t, const char*) = 0;
    virtual Color2 GetPropGlowColor(CBaseEntity const *) = 0;
    virtual int GetSplitScreenPlayerSlot(void) = 0;
    virtual void GetInputCommandSource(void) = 0;
    virtual bool CanVoiceChat(void) = 0;
    virtual const char* GetLoadingScreenImageName(char *argArr, int sizeOfArr, const char *) = 0;
    virtual void sub_2DE8160() = 0;
    virtual void sub_2DE8170() = 0;
    virtual void sub_2DC5E80() = 0;
    virtual void SetBlurFade(float) = 0;
    virtual float GetBlurFade(void) = 0;
    virtual void ClearBlurFade(void) = 0;
    virtual void OnLevelLoadingStarted(void) = 0;
    virtual void ReloadScheme(void) = 0;
    virtual void ReloadSchemeWithRoot(unsigned long long) = 0;
    virtual void FireGameEvent(void *IGameEvent) = 0;
    virtual void HandleSpectatorKeyInput(int, int buttonCode_t, const char *) = 0;
    virtual void InitChatHudElement(void) = 0;
    virtual void InitWeaponSelectionHudElement(void) = 0;
    virtual void InitCursors(void) = 0;

};
```

`src/SDK/ICvar.h`:

```h
#pragma once
#include <cstring>
#include "IAppSystem.h"
#include "Convar.h"

//xref "VEngineCvar007" to ::QueryInterface() - should be 1st one (moved to libtier0.so)
class ICvar : public IAppSystem
{
public:
	typedef int CVarDLLIdentifier_t;

	virtual CVarDLLIdentifier_t AllocateDLLIdentifier(void) = 0;
	virtual void RegisterConCommand(ConCommandBase *) = 0;
	virtual void UnregisterConCommand(ConCommandBase *) = 0;
	virtual void UnregisterConCommands(int) = 0;
	virtual const char* GetCommandLineValue(char const*) = 0;
	virtual ConCommandBase* FindCommandBase(char const*) = 0;
	virtual const ConCommandBase* FindCommandBase2(char const*) = 0;
	virtual ConVar* FindVar(char const*) = 0;
	virtual const ConVar* FindVar2(char const*) = 0;
	virtual void* FindCommand(char const*) = 0;
	virtual const void* FindCommand2(char const*) = 0;
	virtual void InstallGlobalChangeCallback() = 0;//void (*)(IConVar *,char const*,float)) = 0;
	virtual void RemoveGlobalChangeCallback() = 0;//void (*)(IConVar *,char const*,float)) = 0;
	virtual void CallGlobalChangeCallbacks(ConVar *,char const*,float) = 0;
	virtual void RevertFlaggedConVars(long long) = 0;
	virtual void InstallCVarQuery(void *ICvarQuery) = 0;
	virtual void SetMaxSplitScreenSlots(int) = 0;
	virtual int GetMaxSplitScreenSlots(void) = 0;
	virtual void AddSplitScreenConVars(void) = 0;
	virtual void RemoveSplitScreenConVars(int) = 0;
	virtual void FactoryInternalIterator(void) = 0;
	virtual void InstallConVarListener(void *IConVarListener) = 0;
	virtual void RemoveConVarListener(void *IConVarListener) = 0;
	virtual void GetConVarDetails() = 0;//CUtlVector<CConVarDetail,CUtlMemory<CConVarDetail,int>> &) = 0;
	virtual void ResetConVarsToDefaultValues(char const*) = 0;
	virtual void TakeConVarSnapshot(void) = 0;
	virtual void ResetConVarsToSnapshot(void* ConVarSnapshot_t__ ) = 0;
	virtual void DestroyConVarSnapshot(void* ConVarSnapshot_t__ ) = 0;
	virtual bool IsValid(void) = 0; // added march 2 2020
	virtual void* GetSomething(void) = 0; // added sept 4 2020 - returns [rdi+100h]
};

```

`src/SDK/IEngineClient.h`:

```h
#pragma once

#include "IAppSystem.h"
#include "CDotaPlayer.h"
#include "INetChannel.h"


// find Function IEngineClient::HideLoadingPlaque with string "OnEngineLevelLoadingFinished"
class NetChannelInfo;
class IEngineClient : IAppSystem
{
public:
	typedef struct player_info_s
	{
		int64_t __pad0;
		union {
			int64_t xuid;
			struct {
				int xuidlow;
				int xuidhigh;
			};
		};
		char name[128];
		int userid;
		char guid[33];
		unsigned int friendsid;
		char friendsname[128];
		bool fakeplayer;
		bool ishltv;
		unsigned int customfiles[4];
		unsigned char filesdownloaded;
	} player_info_t;

    virtual bool IsPaused(void) = 0; // 11
    virtual float GetTimeScale(void) = 0;
    virtual void FindOrCreateWorldSession(void) = 0;
    virtual void GetEntityLumpForTemplate(void) = 0;
    virtual void GetStatsAppID(void) = 0;
    virtual void* GetGameClientFactory(void) = 0;
	virtual void* GetSteamUniverse(void) = 0; // Added Late June 2018
    virtual void ServerCmd( int inputCommandSrc, const char* command ) = 0;
    virtual void ClientCmd( int inputCommandSrc, const char* command ) = 0;
    virtual bool GetPlayerInfo( int iIndex, player_info_t *pInfo ) = 0; // 20
    virtual int GetPlayerForUserID( int ID ) = 0;
    virtual int GetLocalPlayer( int splitScreenSlot = 0 ) = 0;
    virtual long GetLastTimestamp(void) = 0;
    virtual int GetLastServertick(void) = 0;
    virtual int GetMaxClients(void) = 0;
    virtual bool IsInGame(void) = 0;
    virtual bool IsConnected(void) = 0;
    virtual INetChannel* GetNetChannelInfo( int splitScreenSlot = 0 ) = 0;
    virtual bool IsPlayingDemo(void) = 0;
    virtual void sub_37C290(void) = 0; // added post-overwatch on Feb 11, 2021
    virtual bool IsRecordingDemo(void) = 0;
    virtual bool IsPlayingTimeDemo(void) = 0;
    virtual void ExecuteClientCmd( const char* command ) = 0;
    virtual void ClientCmd_Unrestricted( const char* command ) = 0;
    virtual void __unknown(void) = 0;
    virtual void SetRestrictServerCommands( bool restrict ) = 0;
    virtual void SetRestrictClientCommands( bool restrict ) = 0;
    virtual bool IsLowViolence(void) = 0;
    virtual int GetSplitScreenPlayer( int splitScreenSlot ) = 0;
    virtual bool IsSplitScreenActive(void) = 0;
    virtual bool IsValidSplitScreenSlot( int splitScreenSlot ) = 0;
    virtual int FirstValidSplitScreenSlot(void) = 0;
    virtual int NextValidSplitScreenSlot( int splitScreenSlot ) = 0;
    virtual void GetAvailableAsyncThread(void) = 0;
    virtual void GetScreenSize( int &width, int &height ) = 0;
    virtual bool IsDrawingLoadingImage(void) = 0;
    virtual void HideLoadingPlaque(void) = 0; // 47
    virtual const char* GetLevelName(void) = 0;
    virtual const char* GetLevelNameShort(void) = 0;
    virtual void* GetVoiceTweakAPI(void) = 0;
    virtual void CheckPoint( const char* unknown ) = 0;
    // Demo Recording and Playback related functions
    virtual bool IsDemoPaused(void) = 0;
    virtual bool IsDemoSkipping(void) = 0;
    virtual int GetDemoRecordingTick(void) = 0;
    virtual int GetDemoPlaybackTick(void) = 0;
    virtual int GetDemoPlaybackStartTick(void) = 0;
    virtual float GetDemoPlaybackTimeScale(void) = 0;
    virtual int GetDemoPlaybackTotalTicks(void) = 0;
    virtual const char* GetDemoPlaybackFileName(void) = 0;
    // New! Overwatch related functions. Added with Dota Overwatch.
    virtual void sub_379EA0() = 0; // Snuck in a small update a few days after overwatch update.
    virtual void sub_379D40() = 0;
    virtual bool sub_379D90() = 0;
    virtual void sub_379DE0() = 0;
    virtual void sub_379E30() = 0;
    virtual void sub_379E80() = 0;
    virtual void sub_387190() = 0; // added w/ Road to TI10
    virtual bool IsHLTV(void) = 0;
    //
    virtual void GetUILanguage( char** buffer, int bufferLen ) = 0;
    virtual float GetScreenAspectRatio( int width, int height ) = 0;
    virtual int GetEngineBuildNumber(void) = 0;
    virtual const char* GetProductVersionString(void) = 0; // eg "47"
    virtual int GetBuildVersion(void) = 0;
	virtual const char* GetBuildDateString() = 0; // ex: "Aug 3 2018"
	virtual const char* GetBuildTimeString() = 0; // ex: "14:00:13"
    virtual int GetConnectedServerNetworkVersion(void) = 0;
	virtual int GetAppID(void) = 0; // steam App ID (570)
	virtual void ReadConfiguration( int splitScreenSlot ) = 0;
	virtual void SetAchievementMgr( void* achievementMgr ) = 0;
	virtual void* GetAchivementMgr( void ) = 0;
	/* Xbox-Related */
	virtual void OnStorageDeviceAttached( int ) = 0;
	virtual void OnStorageDeviceDetached( int ) = 0;

	virtual void SetLocalPlayerIsResolvable( const char*, int slot, bool state ) = 0;
	virtual bool IsLocalPlayerResolvable( void ) = 0;
	virtual void RegisterDemoCustomDataCallback() = 0; //(CUtlSymbolLarge,void (*)(uchar *,ulong) = 0)
	virtual void RecordDemoCustomData(void (*)(unsigned char *,unsigned long),void const*,unsigned long) = 0; //"IEngineClient::RecordDemoCustomData(): "
	virtual void SetPitchScale( float pitch ) = 0;
	virtual float GetPitchScale( void ) = 0;
	virtual void* DSPGetCurrentDASRoomNew(void) = 0;
	virtual void* DSPGetCurrentDASRoomChanged(void) = 0;
	virtual void* DSPGetCurrentDASRoomSkyAbove(void) = 0;
	virtual bool IsRecordingVoice( void ) = 0;
	virtual void SetTimeScale( float timescale ) = 0;
	virtual void SetGameStatsData( void* CGameStatsData ) = 0;
	virtual void* GetGameStatsData( void ) = 0;
	virtual int GetBugSubmissionsCount( void ) = 0;
	virtual void ClearBugSubmissionsCount( void ) = 0;
	virtual float GetServerSimulationFrameTime( void ) = 0;
	virtual float GetServerTickTimes( ) = 0; //(ulong long,CUtlVector<IVEngineClient2::ServerTickTime_t,CUtlMemory<IVEngineClient2::ServerTickTime_t,int>> &)
	virtual bool IsInCommentaryMode( void ) = 0;
	virtual bool IsTransitioningToLoad( void ) = 0;
	virtual void SetConnectionPassword( const char* password ) = 0;
	virtual void* GetSteamAPIContext( void ) = 0;
	virtual void ServerCmdKeyValues( void* KeyValues ) = 0;
	virtual void TickProgressBar( void ) = 0;
	virtual void* GetMainWindow( void ) = 0;
	virtual void DrawSelectedPanel( int panelHandle ) = 0;
	virtual bool IsPanelInFocusList( unsigned long long ) = 0;
	virtual bool IsViewEntity( int entIndex ) = 0;
	virtual int GetViewEntity( int splitScreenSlot = 0 ) = 0; // returns ent index I think.
	virtual void TouchLight( void* dlight_t ) = 0;

	/* SOUP START */
	virtual void SetAreaState( unsigned char*, unsigned char* ) = 0;
	virtual void SetDemoTime( float time ) = 0;
	virtual void FlashWindow( void ) = 0;
	virtual void DesktopNotify( const char*, const char* ) = 0;
	virtual void AlertUser() = 0;
	virtual void GetDemoGameInfo() = 0; //(google::protobuf::Message &)
	virtual void GetDemoFileGameInfo() = 0; //(char const*,google::protobuf::Message &)
	virtual void DecompressBZipFile( const char*, const char* ) = 0;
	/* SOUP END */

	virtual void UnzipZip( const char*, const char*, const char*, bool, bool, bool) = 0;
	/* Functions only for Windows */
	virtual void SOSSetOpvarFloat() = 0;
	virtual void SOSGetOpvarFloat() = 0;

	virtual bool GameLoadFailed( void ) = 0;
	virtual void SetGameLoadFailed( bool state ) = 0;
	/* Soup after this point */
	virtual void LoadSpawnGroup( void* SpawnGroupDesc_t ) = 0;
	virtual void UnloadSpawnGroup( unsigned int, int ESpawnGroupUnloadOption ) = 0;
	virtual void SetSpawnGroupDescription( unsigned int, const char* ) = 0;
	virtual void _pad() = 0;
	virtual void _pad2() = 0;
	virtual void _pad3() = 0;
	virtual void _pad4() = 0;
	virtual void _pad5() = 0;
	virtual void _pad6() = 0;
	virtual void _pad7() = 0;
	virtual void _pad8() = 0;
	virtual void _pad9() = 0;
	virtual void _pad10() = 0;
	virtual void _pad11() = 0;

	virtual bool IsClientLocalToActiveServer( void ) = 0;
	virtual void PostReceivedNetMessage() = 0; //(NetMessageHandle_t__ *,void const*,NetChannelBufType_t)
    virtual void sub_36BAB0() = 0;
    virtual void sub_36BAA0() = 0;
    virtual void sub_36BA90() = 0;
    virtual void sub_36BA80() = 0;
    virtual void sub_36BA70() = 0;
    virtual void RenderSystemOptionFlags() = 0;
    virtual void sub_36BA50() = 0;
    virtual void sub_36BA40() = 0;
    virtual void sub_36BA20() = 0; // hlp 100
    virtual void sub_36BA00() = 0;
    virtual void sub_36B9F0() = 0;
    virtual void sub_36B9E0() = 0;
    virtual void sub_36B9D0() = 0;
    virtual void sub_36B9C0() = 0;
    virtual void sub_36B9B0() = 0;
    virtual void sub_36B9A0() = 0;
    virtual void sub_36B990() = 0;
    virtual void sub_36B980() = 0;
    virtual void sub_36B970() = 0;
    virtual void sub_36B960() = 0;
    virtual void sub_36B950() = 0;
    virtual void sub_36B940() = 0;
    virtual void CreateMinidump() = 0;
    virtual void LowViolence() = 0;
    virtual void LowViolence2() = 0;
    virtual void sub_36B890() = 0;
    virtual void sub_36B8B0() = 0;
    virtual void sub_3828E0() = 0;
    virtual void hlp_120() = 0;
    virtual void sub_3828D0() = 0;
    virtual void NEW_NEMESTICE() = 0; // added with nemestice
    virtual void sub_3819C0() = 0;
    virtual void sub_381C50() = 0;
};

```

`src/SDK/IInputSystem.h`:

```h
#pragma once
#include "vector.h"
#include "IAppSystem.h"

#define MAX_SPLITSCREEN_CLIENT_BITS 2
// this should == MAX_JOYSTICKS in InputEnums.h
#define MAX_SPLITSCREEN_CLIENTS	( 1 << MAX_SPLITSCREEN_CLIENT_BITS ) // 4

#define JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_BUTTON + ((_joystick) * JOYSTICK_MAX_BUTTON_COUNT) + (_button) )
#define JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_POV_BUTTON + ((_joystick) * JOYSTICK_POV_BUTTON_COUNT) + (_button) )
#define JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_AXIS_BUTTON + ((_joystick) * JOYSTICK_AXIS_BUTTON_COUNT) + (_button) )

#define JOYSTICK_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_POV_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_AXIS_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) )

#define IN_ATTACK		(1 << 0)
#define IN_JUMP			(1 << 1)
#define IN_DUCK			(1 << 2)
#define IN_FORWARD		(1 << 3)
#define IN_BACK			(1 << 4)
#define IN_USE			(1 << 5)
#define IN_CANCEL		(1 << 6)
#define IN_LEFT			(1 << 7)
#define IN_RIGHT		(1 << 8)
#define IN_MOVELEFT		(1 << 9)
#define IN_MOVERIGHT	(1 << 10)
#define IN_ATTACK2		(1 << 11)
#define IN_RUN			(1 << 12)
#define IN_RELOAD		(1 << 13)
#define IN_ALT1			(1 << 14)
#define IN_ALT2			(1 << 15)
#define IN_SCORE		(1 << 16)
#define IN_SPEED		(1 << 17)
#define IN_WALK			(1 << 18)
#define IN_ZOOM			(1 << 19)
#define IN_WEAPON1		(1 << 20)
#define IN_WEAPON2		(1 << 21)
#define IN_BULLRUSH		(1 << 22)
#define IN_GRENADE1		(1 << 23)
#define IN_GRENADE2		(1 << 24)
#define	IN_ATTACK3		(1 << 25)

enum
{
	MAX_JOYSTICKS = MAX_SPLITSCREEN_CLIENTS,
	MOUSE_BUTTON_COUNT = 5,
};

enum JoystickAxis_t
{
	JOY_AXIS_X = 0,
	JOY_AXIS_Y,
	JOY_AXIS_Z,
	JOY_AXIS_R,
	JOY_AXIS_U,
	JOY_AXIS_V,
	MAX_JOYSTICK_AXES,
};

enum
{
	JOYSTICK_MAX_BUTTON_COUNT = 32,
	JOYSTICK_POV_BUTTON_COUNT = 4,
	JOYSTICK_AXIS_BUTTON_COUNT = MAX_JOYSTICK_AXES * 2,
};

enum InputEventType_t : int
{
    IE_ButtonPressed = 0,	// m_nData contains a ButtonCode_t
    IE_ButtonReleased,		// m_nData contains a ButtonCode_t
    IE_ButtonDoubleClicked,	// m_nData contains a ButtonCode_t
    IE_AnalogValueChanged,	// m_nData contains an AnalogCode_t, m_nData2 contains the value

    IE_FirstSystemEvent = 100,
    IE_Quit = IE_FirstSystemEvent,
    IE_ControllerInserted,	// m_nData contains the controller ID
    IE_ControllerUnplugged,	// m_nData contains the controller ID

    IE_FirstVguiEvent = 1000,	// Assign ranges for other systems that post user events here
    IE_FirstAppEvent = 2000,
};

struct InputEvent_t
{
    InputEventType_t m_nType;   // Type of the event (see InputEventType_t)
    int m_nTick;				// Tick on which the event occurred
    int m_nData;				// Generic 32-bit data, what it contains depends on the event
    int m_nData2;				// Generic 32-bit data, what it contains depends on the event
    int m_nData3;				// Generic 32-bit data, what it contains depends on the event
};

/* Updated for Source 2
 * Generated with
 * for( int key = ButtonCode_t::KEY_FIRST; key <= 512; key++ ) // ( note: values too high cause crash )
        cvar->ConsoleDPrintf( "%s = %d,\n",inputSystem->ButtonCodeToString( (ButtonCode_t)key ), key );
 */
enum ButtonCode_t
{
	BUTTON_CODE_INVALID = -1,
	BUTTON_CODE_NONE = 0,

	KEY_FIRST = 0,

    KEY_0 = 1,
    KEY_1 = 2,
    KEY_2 = 3,
    KEY_3 = 4,
    KEY_4 = 5,
    KEY_5 = 6,
    KEY_6 = 7,
    KEY_7 = 8,
    KEY_8 = 9,
    KEY_9 = 10,
    A = 11,
    B = 12,
    C = 13,
    D = 14,
    E = 15,
    F = 16,
    G = 17,
    H = 18,
    I = 19,
    J = 20,
    K = 21,
    L = 22,
    M = 23,
    N = 24,
    O = 25,
    P = 26,
    Q = 27,
    R = 28,
    S = 29,
    T = 30,
    U = 31,
    V = 32,
    W = 33,
    X = 34,
    Y = 35,
    Z = 36,
    KP_0 = 37,
    KP_1 = 38,
    KP_2 = 39,
    KP_3 = 40,
    KP_4 = 41,
    KP_5 = 42,
    KP_6 = 43,
    KP_7 = 44,
    KP_8 = 45,
    KP_9 = 46,
    KP_DIVIDE = 47,
    KP_MULTIPLY = 48,
    KP_MINUS = 49,
    KP_PLUS = 50,
    KP_ENTER = 51,
    KP_DEL = 52,
    LESSTHAN = 53,
    LBRACKET = 54,
    RBRACKET = 55,
    SEMICOLON = 56,
    APOSTROPHE = 57,
    BACKQUOTE = 58,
    COMMA = 59,
    PERIOD = 60,
    SLASH = 61,
    BACKSLASH = 62,
    MINUS = 63,
    EQUAL = 64,
    ENTER = 65,
    SPACE = 66,
    BACKSPACE = 67,
    TAB = 68,
    CAPSLOCK = 69,
    NUMLOCK = 70,
    ESCAPE = 71,
    SCROLLLOCK = 72,
    INSERT = 73,
    DELETE = 74,
    HOME = 75,
    END = 76,
    PGUP = 77,
    PGDN = 78,
    PAUSE = 79,
    SHIFT = 80,
    RSHIFT = 81,
    ALT = 82,
    RALT = 83,
    CTRL = 84,
    RCTRL = 85,
    LWIN = 86,
    RWIN = 87,
    APP = 88,
    UPARROW = 89,
    LEFTARROW = 90,
    DOWNARROW = 91,
    RIGHTARROW = 92,
    F1 = 93,
    F2 = 94,
    F3 = 95,
    F4 = 96,
    F5 = 97,
    F6 = 98,
    F7 = 99,
    F8 = 100,
    F9 = 101,
    F10 = 102,
    F11 = 103,
    F12 = 104,
    CAPSLOCKTOGGLE = 105,
    NUMLOCKTOGGLE = 106,
    SCROLLLOCKTOGGLE = 107,
    AC_BACK = 108,
    AC_BOOKMARKS = 109,
    AC_FORWARD = 110,
    AC_HOME = 111,
    AC_REFRESH = 112,
    AC_SEARCH = 113,
    AC_STOP = 114,
    AGAIN = 115,
    ALTERASE = 116,
    AMPERSAND = 117,
    ASTERISK = 118,
    AT = 119,
    AUDIOMUTE = 120,
    AUDIONEXT = 121,
    AUDIOPLAY = 122,
    AUDIOPREV = 123,
    AUDIOSTOP = 124,
    BRIGHTNESSDOWN = 125,
    BRIGHTNESSUP = 126,
    CALCULATOR = 127,
    CANCEL = 128,
    CARET = 129,
    CLEAR = 130,
    CLEARAGAIN = 131,
    COLON = 132,
    COMPUTER = 133,
    COPY = 134,
    CRSEL = 135,
    CURRENCYSUBUNIT = 136,
    CURRENCYUNIT = 137,
    CUT = 138,
    DECIMALSEPARATOR = 139,
    DISPLAYSWITCH = 140,
    DOLLAR = 141,
    EJECT = 142,
    EXCLAIM = 143,
    EXECUTE = 144,
    EXSEL = 145,
    F13 = 146,
    F14 = 147,
    F15 = 148,
    F16 = 149,
    F17 = 150,
    F18 = 151,
    F19 = 152,
    F20 = 153,
    F21 = 154,
    F22 = 155,
    F23 = 156,
    F24 = 157,
    FIND = 158,
    GREATER = 159,
    HASH = 160,
    HELP = 161,
    KBDILLUMDOWN = 162,
    KBDILLUMTOGGLE = 163,
    KBDILLUMUP = 164,
    KP_00 = 165,
    KP_000 = 166,
    KP_A = 167,
    KP_AMPERSAND = 168,
    KP_AT = 169,
    KP_B = 170,
    KP_BACKSPACE = 171,
    KP_BINARY = 172,
    KP_C = 173,
    KP_CLEAR = 174,
    KP_CLEARENTRY = 175,
    KP_COLON = 176,
    KP_COMMA = 177,
    KP_D = 178,
    KP_DBLAMPERSAND = 179,
    KP_DBLVERTICALBAR = 180,
    KP_DECIMAL = 181,
    KP_E = 182,
    KP_EQUALS = 183,
    KP_EQUALSAS400 = 184,
    KP_EXCLAM = 185,
    KP_F = 186,
    KP_GREATER = 187,
    KP_HASH = 188,
    KP_HEXADECIMAL = 189,
    KP_LEFTBRACE = 190,
    KP_LEFTPAREN = 191,
    KP_LESS = 192,
    KP_MEMADD = 193,
    KP_MEMCLEAR = 194,
    KP_MEMDIVIDE = 195,
    KP_MEMMULTIPLY = 196,
    KP_MEMRECALL = 197,
    KP_MEMSTORE = 198,
    KP_MEMSUBTRACT = 199,
    KP_OCTAL = 200,
    KP_PERCENT = 201,
    KP_PLUSMINUS = 202,
    KP_POWER = 203,
    KP_RIGHTBRACE = 204,
    KP_RIGHTPAREN = 205,
    KP_SPACE = 206,
    KP_TAB = 207,
    KP_VERTICALBAR = 208,
    KP_XOR = 209,
    LEFTPAREN = 210,
    MAIL = 211,
    MEDIASELECT = 212,
    MODE = 213,
    MUTE = 214,
    OPER = 215,
    OUT = 216,
    PASTE = 217,
    PERCENT = 218,
    PLUS = 219,
    POWER = 220,
    PRINTSCREEN = 221,
    PRIOR = 222,
    QUESTION = 223,
    QUOTEDBL = 224,
    RETURN2 = 225,
    RIGHTPAREN = 226,
    SELECT = 227,
    SEPARATOR = 228,
    SLEEP = 229,
    STOP = 230,
    SYSREQ = 231,
    THOUSANDSSEPARATOR = 232,
    UNDERSCORE = 233,
    UNDO = 234,
    VOLUMEDOWN = 235,
    VOLUMEUP = 236,
    WWW = 237,
    INVERTED_EXCLAMATION_MARK = 238,
    CENT_SIGN = 239,
    POUND_SIGN = 240,
    CURRENCY_SIGN = 241,
    YEN_SIGN = 242,
    BROKEN_BAR = 243,
    SECTION_SIGN = 244,
    DIAERESIS = 245,
    COPYRIGHT_SIGN = 246,
    FEMININE_ORDINAL_INDICATOR = 247,
    LEFT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK = 248,
    NOT_SIGN = 249,
    REGISTERED_SIGN = 250,
    MACRON = 251,
    DEGREE_SIGN = 252,
    DEGREE_SYMBOL = 253,
    PLUS_MINUS_SIGN = 254,
    SUPERSCRIPT_TWO = 255,
    SUPERSCRIPT_THREE = 256,
    ACUTE_ACCENT = 257,
    MICRO_SIGN = 258,
    PILCROW_SIGN = 259,
    MIDDLE_DOT = 260,
    CEDILLA = 261,
    SUPERSCRIPT_ONE = 262,
    MASCULINE_ORDINAL_INDICATOR = 263,
    RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK = 264,
    VULGAR_FRACTION_ONE_QUARTER = 265,
    VULGAR_FRACTION_ONE_HALF = 266,
    VULGAR_FRACTION_THREE_QUARTERS = 267,
    INVERTED_QUESTION_MARK = 268,
    MULTIPLICATION_SIGN = 269,
    SHARP_S = 270,
    A_WITH_GRAVE = 271,
    A_WITH_ACUTE = 272,
    A_WITH_CIRCUMFLEX = 273,
    A_WITH_TILDE = 274,
    A_WITH_DIAERESIS = 275,
    A_WITH_RING_ABOVE = 276,
    AE = 277,
    C_WITH_CEDILLA = 278,
    E_WITH_GRAVE = 279,
    E_WITH_ACUTE = 280,
    E_WITH_CIRCUMFLEX = 281,
    E_WITH_DIAERESIS = 282,
    I_WITH_GRAVE = 283,
    I_WITH_ACUTE = 284,
    I_WITH_CIRCUMFLEX = 285,
    I_WITH_DIAERESIS = 286,
    ETH = 287,
    N_WITH_TILDE = 288,
    O_WITH_GRAVE = 289,
    O_WITH_ACUTE = 290,
    O_WITH_CIRCUMFLEX = 291,
    O_WITH_TILDE = 292,
    O_WITH_DIAERESIS = 293,
    DIVISION_SIGN = 294,
    O_WITH_STROKE = 295,
    U_WITH_GRAVE = 296,
    U_WITH_ACUTE = 297,
    U_WITH_CIRCUMFLEX = 298,
    U_WITH_DIAERESIS = 299,
    Y_WITH_ACUTE = 300,
    THORN = 301,
    Y_WITH_DIAERESIS = 302,
    EURO_SIGN = 303,
    TILDE = 304,
    LEFT_CURLY_BRACKET = 305,
    RIGHT_CURLY_BRACKET = 306,
    VERTICAL_BAR = 307,
    KEY_CYRILLIC_YU = 308,
    KEY_CYRILLIC_E = 309,
    KEY_CYRILLIC_HARD_SIGN = 310,
    KEY_CYRILLIC_HA = 311,
    KEY_CYRILLIC_IO = 312,
    KEY_CYRILLIC_ZHE = 313,
    KEY_CYRILLIC_BE = 314,
    MOUSE1 = 315,
    MOUSE2 = 316,
    MOUSE3 = 317,
    MOUSE4 = 318,
    MOUSE5 = 319,
    MWHEELUP = 320,
    MWHEELDOWN = 321,
    JOY1 = 322,
    JOY2 = 323,
    JOY3 = 324,
    JOY4 = 325,
    JOY5 = 326,
    JOY6 = 327,
    JOY7 = 328,
    JOY8 = 329,
    JOY9 = 330,
    JOY10 = 331,
    JOY11 = 332,
    JOY12 = 333,
    JOY13 = 334,
    JOY14 = 335,
    JOY15 = 336,
    JOY16 = 337,
    JOY17 = 338,
    JOY18 = 339,
    JOY19 = 340,
    JOY20 = 341,
    JOY21 = 342,
    JOY22 = 343,
    JOY23 = 344,
    JOY24 = 345,
    JOY25 = 346,
    JOY26 = 347,
    JOY27 = 348,
    JOY28 = 349,
    JOY29 = 350,
    JOY30 = 351,
    JOY31 = 352,
    JOY32 = 353,

	LAST_KEY_VALUE
};

enum MouseCodeState_t
{
	BUTTON_RELEASED = 0,
	BUTTON_PRESSED,
	BUTTON_DOUBLECLICKED,
};

struct CUserCmd
{
	void *vtable;
	int32_t command_number;
	int32_t tick_count;
	Vector viewangles;
	Vector aimdirection; // sidemove/forwardmove for camera
	int32_t buttons;
    int32_t unk;
	unsigned char impulse;
	int32_t weaponselect; //0x0034
	int32_t weaponsubtype; //0x0038
	int32_t randomSeed; //0x003C
	short mouseX; //left-right [0->512)
	short mouseY; //up-down [0->384)
	short _pad;
	short cameraWorldX; // left-right camera pos in world
	short cameraWorldY; // forward-back camera pos in world.
	char _pad2[6]; // some scoreboard/shop stuff
	Vector CursorRay; // where cursor hits in world
};

struct PlatWindow_t__;
struct OsSpecificWindowHandle_t__;
struct InputStandardCursor_t;
struct InputCursorHandle_t;
typedef int AnalogCode_t;
struct InputEvent_t;

// xref "CInputSystem::AttachToWindow" to AttachToWindow()
class IInputSystem : public IAppSystem
{
public:
	// Attach, detach input system from a particular window
	// This window should be the root window for the application
	// Only 1 window should be attached at any given time.
	virtual void AttachToWindow( OsSpecificWindowHandle_t__* ) = 0;
	virtual void DetachFromWindow( OsSpecificWindowHandle_t__ * ) = 0;

	// Enables/disables input. PollInputState will not update current
	// button/analog states when it is called if the system is disabled.
	virtual void EnableInput( bool state ) = 0;

	// Enables/disables the windows message pump. PollInputState will not
	// Peek/Dispatch messages if this is disabled
	virtual void EnableMessagePump( bool state ) = 0;

	virtual void PollInputState( bool ) = 0;
	// Gets time of last polling in ms
	[[nodiscard]] virtual int GetPollTick( void ) const = 0;

	virtual bool IsButtonDown( ButtonCode_t code ) = 0;

	virtual int GetButtonPressedTick( ButtonCode_t code ) = 0;
	virtual int GetButtonReleasedTick( ButtonCode_t code ) = 0;
	// Gets the value of an analog input device this frame
	// Includes joysticks, mousewheel, mouse
	virtual int GetAnalogValue( AnalogCode_t code ) = 0;
	virtual int GetAnalogDelta( AnalogCode_t code ) = 0;

	virtual void sub_10920() = 0;
	virtual void sub_108F0() = 0;
	virtual void sub_10900() = 0;

	// Returns the input events since the last poll
	virtual int GetEventCount( void ) = 0;
	virtual InputEvent_t* GetEventData( void ) = 0;
	virtual void* GetEvents( void ) = 0;

	// Posts a user-defined event into the event queue; this is expected
	// to be called in overridden wndprocs connected to the root panel.
	virtual void PostUserEvent( const InputEvent_t &) = 0;
	virtual int GetJoystickCount( void ) = 0;

	// Enable/disable joystick, it has perf costs
	virtual void EnableJoystickInput( int nJoystick, bool state ) = 0;

	// Enable/disable diagonal joystick POV (simultaneous POV buttons down)
	virtual void EnableJoystickDiagonalPOV( int nJoystick, bool state ) = 0;

	// Sample the joystick and append events to the input queue
	virtual void SampleDevices( void ) = 0;

	virtual void SetRumble( float leftMotor, float rightMotor, int userId ) = 0;
	virtual void StopRumble( int userId ) = 0;

	virtual void ResetInputState( void ) = 0;
	// Sets a player as the primary user - all other controllers will be ignored.
	virtual void SetPrimaryUserID( int userId ) = 0;

	// Convert back + forth between ButtonCode/AnalogCode + strings
	virtual const char* CodeToString( ButtonCode_t code ) = 0;
	virtual const char* CodeToStringAnalog( AnalogCode_t code ) = 0;
	virtual ButtonCode_t StringToButtonCode( const char *) = 0;
	virtual AnalogCode_t StringToAnalogCode( const char *) = 0;

	// Sleeps until input happens. Pass a negative number to sleep infinitely
	virtual void SleepUntilInput( int maxSleepTimeMS = -1 ) = 0;

	virtual void VirtualKeyToButtonCode( int nVirtKey ) = 0;
	virtual int ButtonCodeToVirtualKey( ButtonCode_t code ) = 0;

	// How many times have we called PollInputState?
	virtual int GetPollCount( void ) = 0;

	virtual void SetCursorPosition( int x, int y, PlatWindow_t__ *window ) = 0;
	virtual void IsWindowAttached( PlatWindow_t__ * ) = 0;
	virtual void GetStandardCursor( InputStandardCursor_t ) = 0;
	virtual void SetStandardCursor( InputStandardCursor_t, InputCursorHandle_t *) = 0; // 50
	virtual void sub_10A00() = 0;
	virtual void sub_10A20() = 0;
	virtual void sub_10A30() = 0;
	virtual void sub_11920() = 0;
	virtual void sub_11BC0() = 0;
	virtual void sub_15910() = 0;
	virtual void sub_12C50() = 0;
	virtual void sub_10B20() = 0;
	virtual void sub_11AC0() = 0;
	virtual void sub_10960() = 0;
	virtual void sub_13B40() = 0;
	virtual void sub_10A50() = 0;
	virtual void sub_11A80() = 0;
	virtual bool sub_E5B0() = 0; // added with dota-anime
	virtual bool HasMouseFocus( void ) = 0;
	virtual void GetInputEventName( InputEventType_t ) = 0;
	virtual bool IsAppActive( void ) = 0;
	virtual bool IsXBoxControllerConnected( void ) = 0;
	virtual void StartDraggingWindow( OsSpecificWindowHandle_t__ *) = 0;
	virtual void SetCursorClip( PlatWindow_t__ * ) = 0;
	virtual void EnablePowerManagement( bool state ) = 0;
	virtual void EnableSystemCommands( unsigned int, bool ) = 0;
	virtual void SetMouseParams( const int *, int ) = 0;
	virtual void GetMouseParams( int *, int ) = 0;
	virtual void SetRelativeMouseMode( bool ) = 0; // 75
	virtual void DebugSpew( void ) = 0;
	virtual char GetASCIICharForButtonPressed( const InputEvent_t & ) = 0;
	virtual unsigned int ButtonCodeToSDLKey( ButtonCode_t code ) = 0;
	virtual ButtonCode_t SDLKeyToButtonCode( unsigned int ) = 0;
	virtual void* CodeToLocalKeyNameUTF8( ButtonCode_t code ) = 0;
	virtual bool GetButtonCodeIsScanCode( void ) = 0;
	virtual void SetButtonCodeIsScanCode( bool state ) = 0;
	virtual void sub_117F0() = 0;
	virtual void sub_10A90() = 0;
	virtual void IME_Stuff() = 0;
	virtual void sub_10E30() = 0;
	virtual void sub_10E90() = 0;
	virtual void sub_10AA0() = 0; // Added with nemestice
	virtual void sub_11D60() = 0; // Added with nemestice
	virtual void DESTROY() = 0;
	virtual void DESTROY2() = 0;

};

class IInputInternal;
```

`src/SDK/IMaterial.h`:

```h
#pragma once

class IMaterialVar;
typedef uint64_t VertexFormat_t;

enum MaterialVarFlags_t
{
	MATERIAL_VAR_DEBUG = ( 1 << 0 ),
	MATERIAL_VAR_NO_DEBUG_OVERRIDE = ( 1 << 1 ),
	MATERIAL_VAR_NO_DRAW = ( 1 << 2 ),
	MATERIAL_VAR_USE_IN_FILLRATE_MODE = ( 1 << 3 ),

	MATERIAL_VAR_VERTEXCOLOR = ( 1 << 4 ),
	MATERIAL_VAR_VERTEXALPHA = ( 1 << 5 ),
	MATERIAL_VAR_SELFILLUM = ( 1 << 6 ),
	MATERIAL_VAR_ADDITIVE = ( 1 << 7 ),
	MATERIAL_VAR_ALPHATEST = ( 1 << 8 ),
	//	MATERIAL_VAR_UNUSED					  = (1 << 9),
	MATERIAL_VAR_ZNEARER = ( 1 << 10 ),
	MATERIAL_VAR_MODEL = ( 1 << 11 ),
	MATERIAL_VAR_FLAT = ( 1 << 12 ),
	MATERIAL_VAR_NOCULL = ( 1 << 13 ),
	MATERIAL_VAR_NOFOG = ( 1 << 14 ),
	MATERIAL_VAR_IGNOREZ = ( 1 << 15 ),
	MATERIAL_VAR_DECAL = ( 1 << 16 ),
	MATERIAL_VAR_ENVMAPSPHERE = ( 1 << 17 ), // OBSOLETE
	//	MATERIAL_VAR_UNUSED					  = (1 << 18),
	MATERIAL_VAR_ENVMAPCAMERASPACE = ( 1 << 19 ), // OBSOLETE
	MATERIAL_VAR_BASEALPHAENVMAPMASK = ( 1 << 20 ),
	MATERIAL_VAR_TRANSLUCENT = ( 1 << 21 ),
	MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = ( 1 << 22 ),
	MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = ( 1 << 23 ), // OBSOLETE
	MATERIAL_VAR_OPAQUETEXTURE = ( 1 << 24 ),
	MATERIAL_VAR_ENVMAPMODE = ( 1 << 25 ), // OBSOLETE
	MATERIAL_VAR_SUPPRESS_DECALS = ( 1 << 26 ),
	MATERIAL_VAR_HALFLAMBERT = ( 1 << 27 ),
	MATERIAL_VAR_WIREFRAME = ( 1 << 28 ),
	MATERIAL_VAR_ALLOWALPHATOCOVERAGE = ( 1 << 29 ),
	MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = ( 1 << 30 ),
	MATERIAL_VAR_VERTEXFOG = ( 1 << 31 ),

	// NOTE: Only add flags here that either should be read from
	// .vmts or can be set directly from client code. Other, internal
	// flags should to into the flag enum in IMaterialInternal.h
};

enum PreviewImageRetVal_t
{
	MATERIAL_PREVIEW_IMAGE_BAD = 0,
	MATERIAL_PREVIEW_IMAGE_OK,
	MATERIAL_NO_PREVIEW_IMAGE,
};

enum ImageFormat {
	IMAGE_FORMAT_UNKNOWN = -1,
	IMAGE_FORMAT_RGBA8888 = 0,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_R32F,            // Single-channel 32-bit floating point
	IMAGE_FORMAT_RGB323232F,    // NOTE: D3D9 does not have this format
	IMAGE_FORMAT_RGBA32323232F,
	IMAGE_FORMAT_RG1616F,
	IMAGE_FORMAT_RG3232F,
	IMAGE_FORMAT_RGBX8888,

	IMAGE_FORMAT_NULL,            // Dummy format which takes no video memory

	// Compressed normal map formats
	IMAGE_FORMAT_ATI2N,            // One-surface ATI2N / DXN format
	IMAGE_FORMAT_ATI1N,            // Two-surface ATI1N format

	IMAGE_FORMAT_RGBA1010102,    // 10 bit-per component render targets
	IMAGE_FORMAT_BGRA1010102,
	IMAGE_FORMAT_R16F,            // 16 bit FP format

	// Depth-stencil texture formats
	IMAGE_FORMAT_D16,
	IMAGE_FORMAT_D15S1,
	IMAGE_FORMAT_D32,
	IMAGE_FORMAT_D24S8,
	IMAGE_FORMAT_LINEAR_D24S8,
	IMAGE_FORMAT_D24X8,
	IMAGE_FORMAT_D24X4S4,
	IMAGE_FORMAT_D24FS8,
	IMAGE_FORMAT_D16_SHADOW,    // Specific formats for shadow mapping
	IMAGE_FORMAT_D24X8_SHADOW,    // Specific formats for shadow mapping

	// supporting these specific formats as non-tiled for procedural cpu access (360-specific)
	IMAGE_FORMAT_LINEAR_BGRX8888,
	IMAGE_FORMAT_LINEAR_RGBA8888,
	IMAGE_FORMAT_LINEAR_ABGR8888,
	IMAGE_FORMAT_LINEAR_ARGB8888,
	IMAGE_FORMAT_LINEAR_BGRA8888,
	IMAGE_FORMAT_LINEAR_RGB888,
	IMAGE_FORMAT_LINEAR_BGR888,
	IMAGE_FORMAT_LINEAR_BGRX5551,
	IMAGE_FORMAT_LINEAR_I8,
	IMAGE_FORMAT_LINEAR_RGBA16161616,

	IMAGE_FORMAT_LE_BGRX8888,
	IMAGE_FORMAT_LE_BGRA8888,

	NUM_IMAGE_FORMATS
};

enum MaterialPropertyTypes_t
{
	MATERIAL_PROPERTY_NEEDS_LIGHTMAP = 0,					// bool
	MATERIAL_PROPERTY_OPACITY,								// int (enum MaterialPropertyOpacityTypes_t)
	MATERIAL_PROPERTY_REFLECTIVITY,							// vec3_t
	MATERIAL_PROPERTY_NEEDS_BUMPED_LIGHTMAPS				// bool
};

class IMaterial
{
public:
	const char* GetName()
	{
		typedef const char* (* oGetName)(void*);
		return getvfunc<oGetName>(this, 0)(this);
	}

	const char* GetTextureGroupName()
	{
		typedef const char* (* oGetTextureGroupName)(void*);
		return getvfunc<oGetTextureGroupName>(this, 1)(this);
	}

	void AlphaModulate(float alpha)
	{
		typedef void (* oAlphaModulate)(void*, float);
		return getvfunc<oAlphaModulate>(this, 27)(this, alpha);
	}

	void ColorModulate(float r, float g, float b)
	{
		typedef void (* oColorModulate)(void*, float, float, float);
		return getvfunc<oColorModulate>(this, 28)(this, r, g, b);
	}

	void ColorModulate(Color2 color)
	{
		typedef void (* oColorModulate)(void*, float, float, float);
		return getvfunc<oColorModulate>(this, 28)(this, color.r / 255.0f, color.g / 255.0f, color.b / 255.0f);
	}

	void SetMaterialVarFlag(MaterialVarFlags_t flag, bool on)
	{
		typedef void (* oSetMaterialVarFlag)(void*, MaterialVarFlags_t, bool);
		return getvfunc<oSetMaterialVarFlag>(this, 29)(this, flag, on);
	}

	float GetAlphaModulation()
	{
		typedef float (* oGetAlphaModulation)(void*);
		return getvfunc<oGetAlphaModulation>(this, 44)(this);
	}

	void GetColorModulate(float *r, float *g, float *b)
	{
		typedef void (* oGetColorModulate)(void*, float*, float*, float*);
		return getvfunc<oGetColorModulate>(this, 45)(this, r, g, b);
	}
};
```

`src/SDK/IMaterialSystem.h`:

```h
#pragma once

#include "IAppSystem.h"

class CMaterial2
{
public:

};

//xref "*** UNKNOWN ***" to GetModeString()
class IMaterialSystem : public IAppSystem
{
public:
	virtual const char* GetModeString(void const *CUtlStringToken) = 0;
	virtual void EnableExtendedMaterialInfo(void) = 0;
	virtual void EnableHeadlessMode(void) = 0;
	virtual CMaterial2* FindOrCreateMaterialFromResource( const char* ) = 0; // invalid name should give the classic checkbox material.
	virtual void SetRenderStateForRenderablePass() = 0;//(CRenderAttributes const*,IRenderContext *,CIntHandle32<RenderInputLayout_t__handle *>,MaterialRenderablePass_t const&,RsStencilStateOverride_t const*,int) = 0;
	virtual void sub_20A50() = 0;
	virtual void sub_20A90() = 0;
	virtual void sub_20AB0() = 0;
    virtual void sub_1E7F0() = 0; // Added with dota anime
	virtual void loc_2BAD0() = 0;
	virtual void DynamicShaderCompile_ReloadAllShaders(void) = 0;
	virtual void sub_SomeShaderStuff() = 0; // added sept 2019 dota+ update.
	virtual bool IsDynamicShaderCompileEnabled(void) = 0;
	virtual void SetMaterialParam_MaterialEditor() = 0;//(CWeakHandle<InfoForResourceTypeIMaterial2>,char const*,char const*)
	virtual void AddFrameUpdateFunc( void (*)(void) ) = 0;
	virtual void RemoveFrameUpdateFunc( void (*)(void) ) = 0;
	virtual void QueueMaterialRefreshAfterConfigChange(void) = 0;
	virtual void sub_21A20() = 0;
	virtual void loc_22390() = 0;
	virtual void loc_22660() = 0;
	virtual void* GetShaderQuality(void) = 0;
	virtual void sub_206C0() = 0;
	virtual void sub_20440() = 0;
	virtual void sub_20450() = 0;
	virtual void sub_20AD0() = 0;
	virtual void sub_222E0() = 0; // Added with aghanim's labyrinth - something to do with shaders.
	virtual void DESTROY() = 0;
	virtual void DESTROY2() = 0;
};
```

`src/SDK/INetChannel.h`:

```h
#pragma once

#include "CNetworkMessages.h"

// Find SetMaxRoutablePayloadSize with "Setting max routable payload" (libnetworksystem)
// Or "CNetChan::SendNetMessage" to SendNetMessage()
class INetChannel
{
public:
    virtual const char* GetName(void) = 0;// get channel name
    virtual const char* GetAddress(void) = 0;// get channel IP address as string
    virtual float GetTime(void) = 0;// current net time
    virtual float GetTimeConnected(void) = 0;// get connection time in seconds
    virtual int GetBufferSize(void) = 0;// netchannel packet history size
    virtual int GetDataRate(void) = 0;// send data rate in byte/sec
    virtual bool IsLocalHost(void) = 0;
    virtual bool IsLoopback(void) = 0;// true if loopback channel
    virtual bool IsTimingOut(void) = 0;// true if timing out
    virtual bool IsPlayback(void) = 0;// true if demo playback
    virtual float GetLatency(int) = 0;// current latency (RTT), more accurate but jittering
    virtual float GetAvgLatency(int) = 0;// average packet latency in seconds
    virtual float GetStdDevLatency(int) = 0;
    virtual void* GetLatencyBreakdown(void *NetChanStat_t,void *NetChanStat_t2, void *NetChanStat_t3, void *NetChanStat_t4) = 0;
    virtual float _unk() = 0;
    virtual float _unk1() = 0;
    virtual float _unk2() = 0;
    virtual void* GetTotalData(int) = 0;
    virtual void* GetTotalPackets(int) = 0;
    virtual int GetSequenceNr(int) = 0;
    virtual bool  IsValidPacket(int,int) = 0;
    virtual float  GetPacketTime(int,int) = 0;
    virtual void* GetPacketBits(int flow,int frameNum,int group,bool) = 0;
    virtual float GetTimeSinceLastReceived(void) = 0;
    virtual float GetCommandInterpolationAmount(int,int) = 0;
    virtual void GetPacketResponseLatency(int,int,int *,int *) = 0;
    virtual void GetRemoteFramerate(float *,float *,float *) = 0;
    virtual float GetTimeoutSeconds(void) = 0;
    virtual void _unknown(); //added w/ rubick arcana
    virtual void ResetLatencyStats(int) = 0;
    virtual void* GetLatencyStats(int) = 0;
    virtual void SetLatencyStats(int, void const * SNetChannelLatencyStats) = 0;
    virtual void SetInterpolationAmount(float) = 0;
    virtual void sub_C7980() = 0;
    virtual void sub_CC680() = 0; // added with 2020 BP
    virtual void sub_CC840() = 0; // added with 2020 BP
    virtual void sub_CC650() = 0; // added with 2020 BP
    virtual void sub_CC300() = 0; // added with 2020 BP
    virtual void sub_CC330() = 0; // added with 2020 BP
    virtual void sub_C2220(bool state) = 0; // added post-nemestice, 09-01-21, Sets bool this+0x57
    virtual void DESTROY() = 0;
    virtual void DESTROY2() = 0;
    virtual int GetTotalPacketBytes(int,int) = 0;
    virtual int GetTotalPacketReliableBytes(int,int) = 0;
    virtual int GetTotalPacketSomething();
    virtual void Reset(void) = 0;
    virtual void Clear(void) = 0;
    virtual void Shutdown(int ENetworkDisconnectionReason) = 0;
    virtual void SendData(void *bf_write, NetChannelBufType_t type) = 0;
    virtual void _unk3() = 0; // this is Transmit()
    virtual const char* GetRemoteAddress(void) = 0;
    virtual void _unk4() = 0;
    virtual void sub_C4AC0() = 0; // added with Road2TI10
    virtual void CanPacket() = 0;
    virtual bool IsOverflowed(void) = 0;
    virtual bool HasPendingReliableData(void) = 0;
    virtual void SetMaxBufferSize(NetChannelBufType_t type,int) = 0; // "CNetChan::SetMaxBufferSize"
    virtual void SetActiveChannel(INetChannel *) = 0;
    virtual void AttachSplitPlayer(int CSplitScreenSlot,INetChannel *) = 0;
    virtual void DetachSplitPlayer(int CSplitScreenSlot) = 0;
    virtual void SetUsesMaxRoutablePayload(bool state) = 0;
    virtual void Setup(void) = 0;
    virtual void _unk6() = 0;
    virtual void SetTimeout(float,bool) = 0;
    virtual bool IsTimedOut(void) = 0;
    virtual void SomethingTimeOut() = 0;
    virtual void SetRemoteFramerate(float,float,float) = 0;
    virtual bool IsRemoteDisconnected(void) = 0;
    virtual void SetNetMessageDispatcher(void *INetMessageDispatcher) = 0;
    virtual void GetNetMessageDispatcher(void) = 0;
    virtual void SendNetMessage(NetMessageHandle_t *messageHandle, google::protobuf::Message *message, NetChannelBufType_t type) = 0;
    virtual void StartRegisteringMessageHandlers(void) = 0;
    virtual void FinishRegisteringMessageHandlers(void) = 0;
    virtual void RegisterNetMessageHandlerAbstract();//CUtlSlot *,CUtlAbstractDelegate const&,int,NetMessageHandle_t__ *,int) = 0;
    virtual void UnregisterNetMessageHandlerAbstract();//CUtlSlot *,CUtlAbstractDelegate const&,NetMessageHandle_t__ *) = 0;
    virtual void SetChallengeNr(unsigned int) = 0;
    virtual void GetNumBitsWritten(NetChannelBufType_t type) = 0;
    virtual void SetCompressionMode(bool) = 0;
    virtual void SetMaxRoutablePayloadSize(int) = 0;
    virtual int GetMaxRoutablePayloadSize(void) = 0;
    virtual void SetDemoRecorder(void *IDemoRecorderBase) = 0;
    virtual void SetInstantReplayIntercept(void *IInstantReplayIntercept) = 0;
    virtual void SetFileTransmissionMode(bool) = 0;
    virtual bool IsNull(void) = 0;
    virtual void ProcessDemoPacket(void *NetPacket_t) = 0;
    virtual bool WasLastMessageReliable(void) = 0;
    virtual void InstallMessageFilter(void *INetworkMessageProcessingPreFilter) = 0;
    virtual void UninstallMessageFilter(void *INetworkMessageProcessingPreFilter) = 0;
    virtual void PostReceivedNetMessage(NetMessageHandle_t *, google::protobuf::Message* ,NetChannelBufType_t const*, int) = 0;
    virtual void InsertReplayMessage(void *InstantReplayMessage_t) = 0;
    virtual bool HasQueuedPackets(void) = 0;
    virtual void _unk8() = 0;
    virtual void SetPendingDisconnect(int ENetworkDisconnectionReason) = 0;
    virtual void GetPendingDisconnect(void) = 0;
    virtual void SuppressTransmit(bool) = 0;
    virtual bool IsSuppressingTransmit(void) = 0;
    virtual void unkExtra(); // steam networking socket related
    virtual bool unkExtra2(); //returns bool
};
```

`src/SDK/INetSupport.h`:

```h
#pragma once

#include "IAppSystem.h"

//xref "INETSUPPORT_001" back to QueryInterface(), it should be right before a stricmp(), the function is small.
class INetSupport : IAppSystem
{
public:
    virtual int GetEngineBuildNumber( void ) = 0;
    virtual void GetBaseServerInfo( void *NetSupport__BaseServerInfo_t ) = 0;
    virtual void GetExtendedServerInfo( void *NetSupport__ExtendedServerInfo_t ) = 0;
    virtual void GetServerInfo( void *NetSupport__ServerInfo_t ) = 0;
    virtual void GetClientInfo( void *NetSupport__ClientInfo_t ) = 0;
    virtual void UpdateServerReservation( unsigned long long reservation ) = 0;
    virtual void UpdateClientReservation( unsigned long long reservation, unsigned long long machineIdHost ) = 0;
    virtual void ReserveServer( ) = 0;//netadr_t const&,netadr_t const&,ulong long,KeyValues *,IMatchAsyncOperationCallback *,IMatchAsyncOperation **
    virtual void OnMatchEvent( void *KeyValues ) = 0;
};
```

`src/SDK/INetworkClientService.h`:

```h
#pragma once
#include "IAppSystem.h"
#include "CNetworkGameClient.h"
#include "CNetworkMessages.h"

// XREF "loopback" back to the first function. It should be right next to another string "address" in the function "AllocateRemoteConnectionClient"
class INetworkClientService : IAppSystem
{
public:
    virtual void GetServiceDependencies() = 0; // 11
    virtual const char* GetName() = 0;
    virtual bool ShouldActivate() = 0;
    virtual void OnLoopActivate() = 0;
    virtual void OnLoopDeactivate() = 0;
    virtual bool IsActive() = 0;
    virtual void SetActive( bool active ) = 0;
    virtual void SetName( const char* name ) = 0;
    virtual void RegisterEventMap() = 0;
    virtual int GetServiceIndex() = 0; // 20
    virtual void SetServiceIndex( int index ) = 0;
    virtual void DESTROY1() = 0;
    virtual void DESTROY2() = 0;
    virtual CNetworkGameClient* GetIGameClient() = 0;
    virtual void SetGameSpawnGroupMgr( void* groupMgr ) = 0;
    virtual void __dunno3() = 0;
    virtual void AllocateRemoteConnectionClient( void* keyValues ) = 0; // 27
    virtual void SetClientSocket( int socket ) = 0;
    virtual void DisconnectGameNow( int disconnectReasonEnum ) = 0;
    virtual void DisconnectGameQueued( int disconnectReasonEnum ) = 0; // 30
    virtual void PrintSpawnGroupStatus( void ) = 0;
    virtual void GetCameraPosition( int splitScreenSlot, void * cTransform ) = 0;
    virtual bool IsActiveInGame( void ) = 0;
    virtual bool IsConnected( void ) = 0;
    virtual bool IsMultiplayer( void ) = 0;
    virtual bool IsPaused( void ) = 0;
    virtual bool IsDisconnecting( void ) = 0;
    virtual int GetDisconnectReason( void ) = 0;
    virtual int GetLocalPlayer( int splitScreenSlot ) = 0; // 40
    virtual void SendStringCmd( int splitScreenSlot, const char* command ) = 0; // el crasho
    virtual void SplitScreenConnect( int splitScreenSlot ) = 0; // function bound to ss_add
    virtual int GetMaxSplitScreenPlayers( void ) = 0;
    virtual void* GetNetChannel( void ) = 0;
    virtual void ClockDriftAdjustFrameTime( double diff ) = 0;
    virtual void* GetViewEntity( int splitScreenSlot ) = 0;
    virtual long GetClientTime( void ) = 0;
    virtual long ComputeNextRenderTime( float mightBeFrameDiff ) = 0; // 49
    virtual bool IsEntityReportActive( void ) = 0; // 50
    virtual void* GetEntityReport( void ) = 0;
    virtual void EntityReportTrack() = 0; // lots of classes as params
    virtual bool SendNetMessage( int splitScreenSlot, NetMessageHandle_t *handle, void const * something,  NetChannelBufType_t type ) = 0; // This function is trash and never gets called
    virtual void ReceivedServerInfo() = 0;
    virtual void GetGameSessionInitPrerequisites() = 0;
    virtual void StartChangelevel( void ) = 0;
    virtual int GetClientChangeLevelState( void ) = 0;
    virtual bool IsChangelevelPending( void ) = 0;
    virtual int GetTotalTicks( void ) = 0; // might be long?
    virtual bool SteamIDAllowedToP2PConnect( void* CSteamID ) = 0; // 60
    virtual bool OnLevelLoadingStarted( void ) = 0;
    virtual void* GetNetMessageRelayDispatcher( void ) = 0;
    virtual void __dunno4() = 0; // might be RegisterNetMessage()
    virtual void PrintConnectionStatus( void ) = 0; // same as doing status in console
    virtual void __dunno5() = 0; // might be ProcessConnectionlessPacket()
    virtual void sub_2F15E0() = 0; // added with aghanim's labyrinth
    virtual void MessageData( unsigned int dunno, unsigned short something, unsigned int somethinElse, unsigned char* someBytes ) = 0;
};
```

`src/SDK/IVGuiPaintSurface.h`:

```h
#pragma once

#include "color.h"
#include "vector.h"
#include "CFontManager.h"

typedef unsigned long long VPANEL;

// (libvguirendersurface) - xref "DrawFilledRectFastFade" to ::DrawFilledRectFastFade()
class IVGuiPaintSurface
{
public:
    virtual void destroy();
	virtual void destroy2();
	virtual void Paint3D(void* VguiPaint3DInfo_t ,int n);
	virtual void DisableClipping(bool state);
	virtual void Set3DPaintTempRenderTarget(char const* targetString);
	virtual void Reset3DPaintTempRenderTarget(void);
	virtual void UpdateRefractTexture(bool state);
	virtual void DrawColoredCircle(int x, int y, float radius, int r, int g, int b, int a);
	virtual void DrawFilledRectFastFade(int,int,int,int,int,int,uint,uint,bool);
	virtual void DrawFilledRectFade(int,int,int,int,uint,uint,bool);
	virtual void DrawOutlinedCircle(int x,int y,int radius,int segments);
	virtual void DrawTexturedPolyLine(void* vguiVertex_t, int n);
	virtual void DrawTexturedSubRect(int x0,int y0,int x1,int y1,float texs0,float text0,float texs1,float text1);
	virtual void DrawSetTextFont(HFont font);
	virtual void DrawColoredText(HFont font,int x,int y,int r,int g,int b,int a,char const* text,...);
	virtual void DrawColoredTextRect(HFont font,int x0,int y0,int x1,int y1,int r,int g,int b,int a,char const* text,...);

	virtual void DrawSetColor(int r, int g, int b, int a);
	virtual void DrawSetColor(ColorRGBA color);
	virtual void DrawSetAlphaMultiplier(float alpha);

	virtual void DrawFilledRect(int x0, int y0, int x1, int y1);
	virtual void DrawFilledRectArray(void* vguiIntRect,int n);
	virtual void DrawOutlinedRect(int x0, int y0, int x1, int y1);
	virtual void DrawLine(int x0, int y0, int x1, int y1);
	virtual void DrawPolyLine(int n, void* VGuiPoint_t);

	virtual void DrawSetTextColor(int r, int g, int b, int a);
	virtual void DrawSetTextColor(Color2 color);
	virtual void DrawSetTextPos(int x, int y);

	virtual void DrawPrintText(wchar_t const* text,int textLen, int vguiFontDrawType_t = 0); //FONT_DRAW_DEFAULT
	virtual void DrawUnicodeChar(wchar_t wch, int vguiFontDrawType_t = 0); //FONT_DRAW_DEFAULT
	virtual void DrawRenderCharFromInfo(void* vguiCharRenderInfo);
	virtual void DrawUnicodeString(wchar_t const* text, int vguiFontDrawType_t = 0);
	virtual void DrawFlushText(void);
	virtual void DrawWordBubble(int,int,int,int,int,Color2,Color2,bool,int,int,int);
	virtual void DrawSetTexture(int id);
	virtual void DrawTexturedRect(int x0,int y0,int x1,int y1);
	virtual void DrawTexturedRectEx(void* vguiDrawTexturedRectParms_t);
	virtual void DrawTexturedLine(void* vguiVertex_tStart, void* vguiVertex_tEnd);
	virtual void DrawSetTextureFrame(int id,int nFrame,unsigned int * pFrameCache);
	virtual void DrawTexturedPolygon(int n,void* vguiVertex_t,bool clipVertices = true);
	virtual void DrawGradientFilledRect(int x0,int y0,int x1,int y1, int IVGuiPaintSurfaceEGradientDirection,Color2 one,Color2 two);
	virtual void PlaySound(const char* filename);
	virtual void SetClipRect(int x0,int x1,int y0,int y1);
	virtual void SetZPos(float zPos);
	virtual float GetZPos(void);
	virtual void SetStencilReference(int ref);
	virtual void* DrawGetTextureHandle(int id);
	virtual void PushMakeCurrent(VPANEL panel,bool useInsets);
	virtual void PopMakeCurrent(VPANEL panel);
	virtual float DrawGetAlphaMultiplier(void);
	virtual void DrawGetTextPos(int &x,int &y);
	virtual void DrawGetUnicodeCharRenderInfo(wchar_t ch, void* vguiCharRenderInfo);
	virtual int GetFontTall(HFont font);
	virtual int GetFontAscent(HFont font ,wchar_t wch);
	virtual bool IsFontAdditive(HFont font);
	virtual void GetCharABCwide(HFont font, int ch, int &a, int &b, int &c);
	virtual void GetCharacterWidth(HFont font, int ch);
	virtual void GetKernedCharWidth();
	virtual void GetTextSize(HFont font,wchar_t const* text,int &wide,int &tall);
	virtual int GetTextHeight(HFont font,int x,int &y,char *text,...);
	virtual size_t GetTextLen(HFont font,char const*,...);
	virtual int CreateNewTextureID(bool procedural = false);
	virtual int DrawGetTextureId(char const* filename);
	virtual void DrawSetTextureFile(int id,char const* filename,int hardwareFilter,bool forceReload);
	virtual void DrawGetTextureFile(int id,char * filename,int maxLen);
	virtual void DrawSetTextureRGBA(int id,const unsigned char* rgba,int wide,int tall);
	virtual void DrawGetTextureSize(int id,int &wide,int &tall,bool unk);
	virtual bool IsTextureIDValid(int id);
	virtual void* DrawGetTextureMatInfoFactory(int id);
	virtual void GetScreenSize(int &wide,int &tall);
	virtual bool IsMinimized(VPANEL panel);
	virtual void FlashWindow(VPANEL panel,bool state);
	virtual void SetTitle(VPANEL panel, const wchar_t * title);
	virtual const wchar_t *GetTitle(VPANEL panel);
	virtual void SurfaceGetCursorPos(int &x,int &y);
	virtual void SwapBuffers(VPANEL panel);
	virtual void Invalidate(VPANEL panel);
	virtual bool IsCursorVisible(void);
	virtual bool IsWithin(int x,int y);
	virtual bool HasFocus(void);
	virtual void SolveTraverse(VPANEL panel,bool forceApplySchemeSettings = false);
	virtual void PaintTraverse(IVGuiPaintSurface * surface,VPANEL panel);
	virtual void* GetIconImageForFullPath(char const* pFullPath);
	virtual const char* GetResolutionKey(void);
	virtual int GetTextureNumFrames(int id);
	virtual void GetClipRect(int &x0,int &y0,int &x1,int &y1);
	virtual void Paint3D(void* VguiPaint3DInfo_t);
	virtual void DrawTexturedQuadArray(int n,void* VGuiTexturedQuad_t,bool clip = true);
	virtual void QueueCustomPaintCallbackInternal(void* IVGuiCustomPaintCallback ,int unk);

};
```

`src/SDK/IVPanel.h`:

```h
#pragma once

#include "IAppSystem.h"
#include "IVGuiPaintSurface.h"


enum RenderMode_t : unsigned char
{
	kRenderNormal = 0,
	kRenderTransColor,
	kRenderTransTexture,
	kRenderGlow,
	kRenderTransAlpha,
	kRenderTransAdd,
	kRenderEnvironmental,
	kRenderTransAddFrameBlend,
	kRenderTransAlphaAdd,
	kRenderWorldGlow,
	kRenderNone,
	kRenderDevVisualizer,
	kRenderModeCount
};

enum RenderFx_t : unsigned char
{
	kRenderFxNone = 0,
	kRenderFxPulseSlow,
	kRenderFxPulseFast,
	kRenderFxPulseSlowWide,
	kRenderFxPulseFastWide,
	kRenderFxFadeSlow,
	kRenderFxFadeFast,
	kRenderFxSolidSlow,
	kRenderFxSolidFast,
	kRenderFxStrobeSlow,
	kRenderFxStrobeFast,
	kRenderFxStrobeFaster,
	kRenderFxFlickerSlow,
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxFadeOut,
	kRenderFxFadeIn,
	kRenderFxPulseFastWider,
	kRenderFxGlowShell,
	kRenderFxMax,
};

// Xref "ShutdownRequest" to CVGui::ShutdownMessage() - xref it back to vtable.
// Go down 1 vfunc, this is CVGui::AllocPanel()
// AllocPanel() will make a VPanel. First Function after operator new() is VPanel::VPanel() (vtable is inside)
class IVPanel : IAppSystem
{
public:
	virtual void Init(VPANEL panel, void *clientPanel);
	virtual void SetPos(VPANEL panel,int x,int y);
	virtual void GetPos(VPANEL panel,int &x,int &y);
	virtual void SetSize(VPANEL panel,int wide,int tall);
	virtual void SetSizeNoCallback(VPANEL panel,int wide, int tall);
	virtual void GetSize(VPANEL panel,int &wide,int &tall);
	virtual void SetMinimumSize(VPANEL panel,int wide, int tall);
	virtual void GetMinimumSize(VPANEL panel,int &wide, int &tall);
	virtual void SetZPos(VPANEL panel,int z);
	virtual int GetZPos(VPANEL panel);

	virtual void GetAbsPos(VPANEL panel,int &x,int &y);
	virtual void GetClipRect(VPANEL panel,int &x0,int &y0,int &x1 ,int &y1);
	virtual void NarrowClipRect(VPANEL panel,int &x0,int &y0,int &x1,int &y1);
	virtual void ExpandClipRect(VPANEL panel,int &x0,int &y0,int &x1,int &y1);
	virtual void SetInset(VPANEL panel,int x0,int y0,int x1,int y1);
	virtual void GetInset(VPANEL panel,int &x0,int &y0,int &x1,int &y1);

	virtual void SetVisible(VPANEL panel,bool visible);
	virtual bool IsVisible(VPANEL panel);
	virtual void SetParent(VPANEL panel,VPANEL newParent);
	virtual int GetChildCount(VPANEL panel);
	virtual VPANEL GetChild(VPANEL panel,int index);
	virtual void GetChildren(VPANEL panel); // returns a CUtlVector< VPANEL > &GetChildre
	virtual VPANEL GetParent(VPANEL panel);
	virtual void MoveToFront(VPANEL panel);
	virtual void MoveToBack(VPANEL panel);
	virtual bool HasParent(VPANEL panel,VPANEL potentialParent);
	virtual bool IsPopup(VPANEL panel);
	virtual void SetPopup(VPANEL panel,bool popup);
	virtual bool IsFullyVisible(VPANEL panel);

    // gets the scheme this panel uses
	virtual void GetScheme(VPANEL panel); // returns HScheme
	virtual void GetLayoutFile(VPANEL panel);
    // gets whether or not this panel should scale with screen resolution
	virtual bool IsProportional(VPANEL panel);
    // returns true if auto-deletion flag is set
	virtual bool IsAutoDeleteSet(VPANEL panel);
    // deletes the Panel * associated with the vpanel
	virtual void DeletePanel(VPANEL panel);

	virtual void SetKeyBoardInputEnabled(VPANEL panel,bool enabled);
	virtual void SetMouseInputEnabled(VPANEL panel,bool enabled);
	virtual bool IsKeyBoardInputEnabled(VPANEL panel);
	virtual bool IsMouseInputEnabled(VPANEL panel);

    // calculates the panels current position within the hierarchy
	virtual void Solve(VPANEL panel);

    // gets names of the object (for debugging purposes)
	virtual const char* GetName(VPANEL panel);
	virtual const char* GetClassName(VPANEL panel);

    // delivers a message to the panel
	virtual void SendMessage(VPANEL panel,void* KeyValues,VPANEL panel2);

    // these pass through to the IClientPanel
	virtual void Think(VPANEL panel);
	virtual void PerformApplySchemeSettings(VPANEL panel);
	virtual void PaintTraverse(IVGuiPaintSurface* surface, VPANEL panel, bool force_repaint, bool allow_force);
	virtual void Repaint(VPANEL panel);
	virtual VPANEL IsWithinTraverse(VPANEL panel,int x,int y,bool traversePopups);
	virtual void OnChildAdded(VPANEL panel,VPANEL panel2);
	virtual void OnSizeChanged(VPANEL panel,int newWide,int newTall);


	virtual void InternalFocusChanged(VPANEL panel,bool lost);
	virtual bool RequestInfo(VPANEL panel,void * KeyValues);
	virtual void RequestFocus(VPANEL panel,int direction = 0);
	virtual bool RequestFocusPrev(VPANEL panel,VPANEL existingPanel);
	virtual bool RequestFocusNext(VPANEL panel,VPANEL existingPanel);
	virtual VPANEL GetCurrentKeyFocus(VPANEL panel);
	virtual int GetTabPosition(VPANEL panel);

    // used by ISurface to store platform-specific data
	virtual void Plat(VPANEL panel);
	virtual void SetPlat(VPANEL panel, void* vgui__SurfacePlat);

    // returns a pointer to the vgui controls baseclass Panel *
    // destinationModule needs to be passed in to verify that the returned Panel * is from the same module
    // it must be from the same module since Panel * vtbl may be different in each module
	virtual void* GetPanel(VPANEL panel,char const* destinationModule);

	virtual bool IsEnabled(VPANEL panel);
	virtual void SetEnabled(VPANEL panel,bool enabled);

	virtual bool IsTopmostPopup(VPANEL panel);
	virtual void SetTopmostPopup(VPANEL panel,bool topMost);

	virtual void SetMessageContextId(VPANEL panel,int msgContextID);
	virtual int GetMessageContextId(VPANEL panel);
	virtual void GetUnpackStructure(VPANEL panel);
	virtual void SetSiblingPin(VPANEL panel,VPANEL panel2,unsigned char unk,unsigned char unk2);
	virtual void MoveBehindSibling(VPANEL panel,VPANEL sibling);
	virtual void Client(VPANEL panel);
	virtual const char* GetModuleName(VPANEL panel);
};
```

`src/SDK/SDK.h`:

```h
#pragma once

#include <cstdint>
#include <dlfcn.h>
#include "definitions.h"
#include "common.h"
#include "color.h"
#include "CUtlMemory.h"
#include "CUtlVector.h"
#include "CGlobalVars.h"
#include "IAppSystem.h"
#include "CSource2Client.h"
#include "IInputSystem.h"
#include "IMaterial.h"
#include "IMaterialSystem.h"
#include "IEngineClient.h"
#include "IVPanel.h"
#include "ICvar.h"
#include "INetworkClientService.h"
#include "CSplitScreenService.h"
#include "CGameEntitySystem.h"
#include "CBaseEntity.h"
#include "CDotaBaseNPC.h"
#include "CVScriptGameSystem.h"
#include "panorama/PanoramaUIEngine.h"
#include "INetChannel.h"
#include "CNetworkMessages.h"
#include "CViewRender.h"
#include "IClientMode.h"
#include "CViewSetup.h"
#include "CDotaFogOfWarSystem.h"
#include "CDotaCamera.h"
#include "CGameEventManager.h"
#include "CNetworkGameClient.h"
#include "CSoundOPSystem.h"
#include "CEngineServiceMgr.h"
#include "CDOTARichPresence.h"
#include "CNetworkSystem.h"
#include "CDOTAWearableItem.h"
#include "CParticleSystemMgr.h"
#include "CGameEventSystem.h"
#include "CNetworkStringTableContainer.h"
#include "CVPhys2World.h"
#include "Valve/tier0/memoverride.h"
#include "CRenderGameSystem.h"
#include "CPanoramaGameScriptScope.h"
#include "CDOTAPlayerResource.h"
#include "CGCClient.h"
#include "CBaseFileSystem.h"
```

`src/SDK/Schema.h`:

```h
#pragma once

#include <cstdint>
#include <array>

struct CSchemaClassBinding {
    CSchemaClassBinding* parent;
    const char* binaryName; // ex: C_World
    const char* projectName; // ex: libclient.so
    const char* className; // ex: client
    void *classInfoOldSynthesized;
    void *classInfoN;
    void *thisModuleBindingPointer;
    void *pSchemaType;
};


struct Netvar // Size: 0x138
{
    const char *netvarName; // ex: m_nMinGPULevel
    void *_pad[2]; // 0x8
    uint32_t offset; // 0x18
    uint32_t something; // 0x1C
    void *_pad2[10];
    const char *typeName; // ex: uint8
    void *_pad3[5];
};

struct NetvarWrapper
{
    Netvar *netVar;
    char sevenByteSwag[7];
} __attribute__((__packed__));

struct SchemaRecvTable {
    const char *varName;
    void *_pad;
    int32_t numOfVars;
    int32_t something;
    NetvarWrapper *netVarsArray;
};
```

`src/SDK/Valve/tier0/memoverride.cpp`:

```cpp
#include "memoverride.h"

void * operator new(size_t size)
{
    void * p = g_pMemAlloc->Alloc(size);
    return p;
}

void operator delete(void * p)
{
    g_pMemAlloc->Free(p);
}

void operator delete(void*p, std::size_t size)
{
    g_pMemAlloc->Free(p);
}

```

`src/SDK/Valve/tier0/memoverride.h`:

```h
#pragma once

#include <cstddef>

class IMemAlloc
{
public:
    virtual void *Alloc( unsigned long size ) = 0;
    virtual void *Realloc( const void *pMem, unsigned long size ) = 0;
    virtual void Free( const void *pMem ) = 0;
    virtual void sub_466F0() = 0;
    virtual void sub_465B0() = 0;
    virtual void sub_457C0() = 0;
    virtual void sub_46510() = 0;
    virtual void sub_463B0() = 0;
    virtual void sub_457E0() = 0;
    virtual void sub_46310() = 0;
    virtual void sub_45880() = 0;
    virtual void sub_45000() = 0;
    virtual void sub_45010() = 0;
    virtual void sub_45020() = 0;
    virtual void sub_45030() = 0;
    virtual void sub_458C0() = 0;
    virtual void sub_45040() = 0;
    virtual void sub_45050() = 0;
    virtual void sub_45060() = 0;
    virtual void sub_45070() = 0;
    virtual void sub_45080() = 0;
    virtual size_t GetSize( const void *pMem ) = 0;
};

// Resolved at runtime in tier0
extern "C" IMemAlloc *g_pMemAlloc;

// Should override for all of McDota
void * operator new(size_t size);
void operator delete(void * p);
void operator delete(void*p, std::size_t size);
```

`src/SDK/Valve/tier1/utldelegateimpl.h`:

```h
//========= Copyright Valve Corporation, All rights reserved. ============//
//						FastDelegate.h
//	Efficient delegates in C++ that generate only two lines of asm code!
//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
//
//						- Don Clugston, Mar 2004.
//		Major contributions were made by Jody Hagins.
// History:
// 24-Apr-04 1.0  * Submitted to CodeProject.
// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.
//				  * Improved syntax for horrible_cast (thanks Paul Bludov).
//				  * Tested on Metrowerks MWCC and Intel ICL (IA32)
//				  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.
//	27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5
//				  * Now works on /clr "managed C++" code on VC7, VC7.1
//				  * Comeau C++ now compiles without warnings.
//				  * Prevent the virtual inheritance case from being used on
//					  VC6 and earlier, which generate incorrect code.
//				  * Improved warning and error messages. Non-standard hacks
//					 now have compile-time checks to make them safer.
//				  * implicit_cast used instead of static_cast in many cases.
//				  * If calling a const member function, a const class pointer can be used.
//				  * UtlMakeDelegate() global helper function added to simplify pass-by-value.
//				  * Added fastdelegate.Clear()
// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)
// 30-Oct-04 1.3  * Support for (non-void) return values.
//				  * No more workarounds in client code!
//					 MSVC and Intel now use a clever hack invented by John Dlugosz:
//				     - The FASTDELEGATEDECLARE workaround is no longer necessary.
//					 - No more warning messages for VC6
//				  * Less use of macros. Error messages should be more comprehensible.
//				  * Added include guards
//				  * Added FastDelegate::IsEmpty() to test if invocation is safe (Thanks Neville Franks).
//				  * Now tested on VS 2005 Express Beta, PGI C++
// 24-Dec-04 1.4  * Added CUtlAbstractDelegate, to allow collections of disparate delegates.
//                * <,>,<=,>= comparison operators to allow storage in ordered containers.
//				  * Substantial reduction of code size, especially the 'Closure' class.
//				  * Standardised all the compiler-specific workarounds.
//                * MFP conversion now works for CodePlay (but not yet supported in the full code).
//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1
//				  * New syntax: FastDelegate< int (char *, double) >.
// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .Clear(), ==0 as equivalent to .IsEmpty(). (Thanks elfric).
//				  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.
// 30-Mar-05 1.5  * Safebool idiom: "if (dg)" is now equivalent to "if (!dg.IsEmpty())"
//				  * Fully supported by CodePlay VectorC
//                * Bugfix for Metrowerks: IsEmpty() was buggy because a valid MFP can be 0 on MWCC!
//                * More optimal assignment,== and != operators for static function pointers.
// 22-Jul-10 xxx  * Reformatted + renamed to match valve coding standards
//				  * Added UtlMakeDelegate for static functions

#ifndef UTLDELEGATEIMPL_H
#define UTLDELEGATEIMPL_H
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <memory.h> // to allow <,> comparisons

////////////////////////////////////////////////////////////////////////////////
//						Configuration options
//
////////////////////////////////////////////////////////////////////////////////

// Uncomment the following #define for optimally-sized delegates.
// In this case, the generated asm code is almost identical to the code you'd get
// if the compiler had native support for delegates.
// It will not work on systems where sizeof(dataptr) < sizeof(codeptr).
// Thus, it will not work for DOS compilers using the medium model.
// It will also probably fail on some DSP systems.
#define FASTDELEGATE_USESTATICFUNCTIONHACK

// Uncomment the next line to allow function declarator syntax.
// It is automatically enabled for those compilers where it is known to work.
//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

////////////////////////////////////////////////////////////////////////////////
//						Compiler identification for workarounds
//
////////////////////////////////////////////////////////////////////////////////

// Compiler identification. It's not easy to identify Visual C++ because
// many vendors fraudulently define Microsoft's identifiers.
#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)
#define FASTDLGT_ISMSVC

#if (_MSC_VER <1300) // Many workarounds are required for VC6.
#define FASTDLGT_VC6
#pragma warning(disable:4786) // disable this ridiculous warning
#endif

#endif

// Does the compiler uses Microsoft's member function pointer structure?
// If so, it needs special treatment.
// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's
// identifier, _MSC_VER. We need to filter Metrowerks out.
#if defined(_MSC_VER) && !defined(__MWERKS__)
#define FASTDLGT_MICROSOFT_MFP

#if !defined(__VECTOR_C)
// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
#define FASTDLGT_HASINHERITANCE_KEYWORDS
#endif
#endif

// Does it allow function declarator syntax? The following compilers are known to work:
#if defined(FASTDLGT_ISMSVC) && (_MSC_VER >=1310) // VC 7.1
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.
#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.
#if defined (__MWERKS__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif

#ifdef __GNUC__ // Workaround GCC bug #8271
// At present, GCC doesn't recognize constness of MFPs in templates
#define FASTDELEGATE_GCC_BUG_8271
#endif



////////////////////////////////////////////////////////////////////////////////
//						General tricks used in this code
//
// (a) Error messages are generated by typdefing an array of negative size to
//     generate compile-time errors.
// (b) Warning messages on MSVC are generated by declaring unused variables, and
//	    enabling the "variable XXX is never used" warning.
// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
//     (char *) first to ensure that the correct number of *bytes* are added.
//
////////////////////////////////////////////////////////////////////////////////
//						Helper templates
//
////////////////////////////////////////////////////////////////////////////////


namespace detail // we'll hide the implementation details in a nested namespace.
{

//		implicit_cast< >
// I believe this was originally going to be in the C++ standard but
// was left out by accident. It's even milder than static_cast.
// I use it instead of static_cast<> to emphasize that I'm not doing
// anything nasty.
// Usage is identical to static_cast<>
    template <class OutputClass, class InputClass>
    inline OutputClass implicit_cast(InputClass input)
    {
        return input;
    }

//		horrible_cast< >
// This is truly evil. It completely subverts C++'s type system, allowing you
// to cast from any class to any other class. Technically, using a union
// to perform the cast is undefined behaviour (even in C). But we can see if
// it is OK by checking that the union is the same size as each of its members.
// horrible_cast<> should only be used for compiler-specific workarounds.
// Usage is identical to reinterpret_cast<>.

// This union is declared outside the horrible_cast because BCC 5.5.1
// can't inline a function with a nested class, and gives a warning.
    template <class OutputClass, class InputClass>
    union horrible_union
    {
        OutputClass out;
        InputClass in;
    };

    template <class OutputClass, class InputClass>
    inline OutputClass horrible_cast(const InputClass input)
    {
        horrible_union<OutputClass, InputClass> u;
        // Cause a compile-time error if in, out and u are not the same size.
        // If the compile fails here, it means the compiler has peculiar
        // unions which would prevent the cast from working.
        typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u)
                                               && sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
        u.in = input;
        return u.out;
    }

////////////////////////////////////////////////////////////////////////////////
//						Workarounds
//
////////////////////////////////////////////////////////////////////////////////

// Backwards compatibility: This macro used to be necessary in the virtual inheritance
// case for Intel and Microsoft. Now it just forward-declares the class.
#define FASTDELEGATEDECLARE(CLASSNAME)	class CLASSNAME;

// Prevent use of the static function hack with the DOS medium model.
#ifdef __MEDIUM__
#undef FASTDELEGATE_USESTATICFUNCTIONHACK
#endif

//			DefaultVoid - a workaround for 'void' templates in VC6.
//
//  (1) VC6 and earlier do not allow 'void' as a default template argument.
//  (2) They also doesn't allow you to return 'void' from a function.
//
// Workaround for (1): Declare a dummy type 'DefaultVoid' which we use
//   when we'd like to use 'void'. We convert it into 'void' and back
//   using the templates DefaultVoidToVoid<> and VoidToDefaultVoid<>.
// Workaround for (2): On VC6, the code for calling a void function is
//   identical to the code for calling a non-void function in which the
//   return value is never used, provided the return value is returned
//   in the EAX register, rather than on the stack.
//   This is true for most fundamental types such as int, enum, void *.
//   Const void * is the safest option since it doesn't participate
//   in any automatic conversions. But on a 16-bit compiler it might
//   cause extra code to be generated, so we disable it for all compilers
//   except for VC6 (and VC5).
#ifdef FASTDLGT_VC6
    // VC6 workaround
typedef const void * DefaultVoid;
#else
// On any other compiler, just use a normal void.
    typedef void DefaultVoid;
#endif

// Translate from 'DefaultVoid' to 'void'.
// Everything else is unchanged
    template <class T>
    struct DefaultVoidToVoid { typedef T type; };

    template <>
    struct DefaultVoidToVoid<DefaultVoid> {	typedef void type; };

// Translate from 'void' into 'DefaultVoid'
// Everything else is unchanged
    template <class T>
    struct VoidToDefaultVoid { typedef T type; };

    template <>
    struct VoidToDefaultVoid<void> { typedef DefaultVoid type; };



////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 1:
//
//		Conversion of member function pointer to a standard form
//
////////////////////////////////////////////////////////////////////////////////

// GenericClass is a fake class, ONLY used to provide a type.
// It is vitally important that it is never defined, so that the compiler doesn't
// think it can optimize the invocation. For example, Borland generates simpler
// code if it knows the class only uses single inheritance.

// Compilers using Microsoft's structure need to be treated as a special case.
#ifdef  FASTDLGT_MICROSOFT_MFP

    #ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
	// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP
	// (4 bytes), even when the /vmg option is used. Declaring an empty class
	// would give 16 byte pointers in this case....
	class __single_inheritance GenericClass;
#endif
	// ...but for Codeplay, an empty class *always* gives 4 byte pointers.
	// If compiled with the /clr option ("managed C++"), the JIT compiler thinks
	// it needs to load GenericClass before it can call any of its functions,
	// (compiles OK but crashes at runtime!), so we need to declare an
	// empty class to make it happy.
	// Codeplay and VC4 can't cope with the unknown_inheritance case either.
	class GenericClass {};
#else
    class GenericClass;
#endif

// The size of a single inheritance member function pointer.
    const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());

//						SimplifyMemFunc< >::Convert()
//
//	A template function that converts an arbitrary member function pointer into the
//	simplest possible form of member function pointer, using a supplied 'this' pointer.
//  According to the standard, this can be done legally with reinterpret_cast<>.
//	For (non-standard) compilers which use member function pointers which vary in size
//  depending on the class, we need to use	knowledge of the internal structure of a
//  member function pointer, as used by the compiler. Template specialization is used
//  to distinguish between the sizes. Because some compilers don't support partial
//	template specialisation, I use full specialisation of a wrapper struct.

// general case -- don't know how to convert it. Force a compile failure
    template <int N>
    struct SimplifyMemFunc
    {
        template <class X, class XFuncType, class GenericMemFuncType>
        inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
                                            GenericMemFuncType &bound_func)
        {
            // Unsupported member function type -- force a compile failure.
            // (it's illegal to have a array with negative size).
            typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
            return nullptr;
        }
    };

// For compilers where all member func ptrs are the same size, everything goes here.
// For non-standard compilers, only single_inheritance classes go here.
    template <>
    struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE>
    {
        template <class X, class XFuncType, class GenericMemFuncType>
        inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
                                            GenericMemFuncType &bound_func)
        {
#if defined __DMC__
            // Digital Mars doesn't allow you to cast between abitrary PMF's,
		// even though the standard says you can. The 32-bit compiler lets you
		// static_cast through an int, but the DOS compiler doesn't.
		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
#else
            bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);
#endif
            return reinterpret_cast<GenericClass *>(pthis);
        }
    };

////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 1b:
//
//					Workarounds for Microsoft and Intel
//
////////////////////////////////////////////////////////////////////////////////


// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
// need to be treated as a special case.
#ifdef FASTDLGT_MICROSOFT_MFP

    // We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
// at the start of each function for extra safety, but VC6 seems to ICE
// intermittently if you do this inside a template.

// __multiple_inheritance classes go here
// Nasty hack for Microsoft and Intel (IA32 and Itanium)
template<>
struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
		GenericMemFuncType &bound_func)
	{
		// We need to use a horrible_cast to do this conversion.
		// In MSVC, a multiple inheritance member pointer is internally defined as:
        union
		{
			XFuncType func;
			struct
			{
				GenericMemFuncType funcaddress; // points to the actual member function
				int delta;	     // #BYTES to be added to the 'this' pointer
			}s;
        } u;
		// Check that the horrible_cast will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)? 1 : -1];
        u.func = function_to_bind;
		bound_func = u.s.funcaddress;
		return reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta);
	}
};

// virtual inheritance is a real nuisance. It's inefficient and complicated.
// On MSVC and Intel, there isn't enough information in the pointer itself to
// enable conversion to a closure pointer. Earlier versions of this code didn't
// work for all cases, and generated a compile-time error instead.
// But a very clever hack invented by John M. Dlugosz solves this problem.
// My code is somewhat different to his: I have no asm code, and I make no
// assumptions about the calling convention that is used.

// In VC++ and ICL, a virtual_inheritance member pointer
// is internally defined as:
struct MicrosoftVirtualMFP
{
	void (GenericClass::*codeptr)(); // points to the actual member function
	int delta;		// #bytes to be added to the 'this' pointer
	int vtable_index; // or 0 if no virtual inheritance
};
// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
// m_codeptr member is *always* called, regardless of the values of the other
// members. (This is *not* true for other compilers, eg GCC, which obtain the
// function address from the vtable if a virtual function is being called).
// Dlugosz's trick is to make the codeptr point to a probe function which
// returns the 'this' pointer that was used.

// Define a generic class that uses virtual inheritance.
// It has a trival member function that returns the value of the 'this' pointer.
struct GenericVirtualClass : virtual public GenericClass
{
	typedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
	GenericVirtualClass * GetThis() { return this; }
};

// __virtual_inheritance classes go here
#ifdef _MSC_VER
#pragma warning( disable : 4121 )
#endif

template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
		GenericMemFuncType &bound_func)
	{
		union
		{
			XFuncType func;
			GenericClass* (X::*ProbeFunc)();
			MicrosoftVirtualMFP s;
		} u;
		u.func = function_to_bind;
		bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);
		union
		{
			GenericVirtualClass::ProbePtrType virtfunc;
			MicrosoftVirtualMFP s;
		} u2;
		// Check that the horrible_cast<>s will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)
			&& sizeof(function_to_bind)==sizeof(u.ProbeFunc)
			&& sizeof(u2.virtfunc)==sizeof(u2.s) ? 1 : -1];
   // Unfortunately, taking the address of a MF prevents it from being inlined, so
   // this next line can't be completely optimised away by the compiler.
		u2.virtfunc = &GenericVirtualClass::GetThis;
		u.s.codeptr = u2.s.codeptr;
		return (pthis->*u.ProbeFunc)();
	}
};
#ifdef _MSC_VER
#pragma warning( default : 4121 )
#endif

#if (_MSC_VER <1300)

// Nasty hack for Microsoft Visual C++ 6.0
// unknown_inheritance classes go here
// There is a compiler bug in MSVC6 which generates incorrect code in this case!!
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
		GenericMemFuncType &bound_func)
	{
		// There is an apalling but obscure compiler bug in MSVC6 and earlier:
		// vtable_index and 'vtordisp' are always set to 0 in the
		// unknown_inheritance case!
		// This means that an incorrect function could be called!!!
		// Compiling with the /vmg option leads to potentially incorrect code.
		// This is probably the reason that the IDE has a user interface for specifying
		// the /vmg option, but it is disabled -  you can only specify /vmg on
		// the command line. In VC1.5 and earlier, the compiler would ICE if it ever
		// encountered this situation.
		// It is OK to use the /vmg option if /vmm or /vms is specified.

		// Fortunately, the wrong function is only called in very obscure cases.
		// It only occurs when a derived class overrides a virtual function declared
		// in a virtual base class, and the member function
		// points to the *Derived* version of that function. The problem can be
		// completely averted in 100% of cases by using the *Base class* for the
		// member fpointer. Ie, if you use the base class as an interface, you'll
		// stay out of trouble.
		// Occasionally, you might want to point directly to a derived class function
		// that isn't an override of a base class. In this case, both vtable_index
		// and 'vtordisp' are zero, but a virtual_inheritance pointer will be generated.
		// We can generate correct code in this case. To prevent an incorrect call from
		// ever being made, on MSVC6 we generate a warning, and call a function to
		// make the program crash instantly.
		typedef char ERROR_VC6CompilerBug[-100];
		return 0;
	}
};


#else

// Nasty hack for Microsoft and Intel (IA32 and Itanium)
// unknown_inheritance classes go here
// This is probably the ugliest bit of code I've ever written. Look at the casts!
// There is a compiler bug in MSVC6 which prevents it from using this code.
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
			GenericMemFuncType &bound_func)
	{
		// The member function pointer is 16 bytes long. We can't use a normal cast, but
		// we can use a union to do the conversion.
		union
		{
			XFuncType func;
			// In VC++ and ICL, an unknown_inheritance member pointer
			// is internally defined as:
			struct
			{
				GenericMemFuncType funcaddress; // points to the actual member function
				int delta;		// #bytes to be added to the 'this' pointer
				int vtordisp;		// #bytes to add to 'this' to find the vtable
				int vtable_index; // or 0 if no virtual inheritance
			} s;
		} u;
		// Check that the horrible_cast will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType)==sizeof(u.s)? 1 : -1];
		u.func = function_to_bind;
		bound_func = u.s.funcaddress;
		int virtual_delta = 0;
		if (u.s.vtable_index)
		{	// Virtual inheritance is used
			// First, get to the vtable.
			// It is 'vtordisp' bytes from the start of the class.
			const int * vtable = *reinterpret_cast<const int *const*>(
				reinterpret_cast<const char *>(pthis) + u.s.vtordisp );

			// 'vtable_index' tells us where in the table we should be looking.
			virtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>(
				reinterpret_cast<const char *>(vtable) + u.s.vtable_index);
		}
		// The int at 'virtual_delta' gives us the amount to add to 'this'.
        // Finally we can add the three components together. Phew!
        return reinterpret_cast<GenericClass *>(
			reinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);
	};
};
#endif // MSVC 7 and greater

#endif // MS/Intel hacks

}  // namespace detail

////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 2:
//
//	Define the delegate storage, and cope with static functions
//
////////////////////////////////////////////////////////////////////////////////

// CUtlAbstractDelegate -- an opaque structure which can hold an arbitary delegate.
// It knows nothing about the calling convention or number of arguments used by
// the function pointed to.
// It supplies comparison operators so that it can be stored in STL collections.
// It cannot be set to anything other than null, nor invoked directly:
//   it must be converted to a specific delegate.

// Implementation:
// There are two possible implementations: the Safe method and the Evil method.
//				CUtlAbstractDelegate - Safe version
//
// This implementation is standard-compliant, but a bit tricky.
// A static function pointer is stored inside the class.
// Here are the valid values:
// +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+
// |   0				|  0       |   0        | Empty          |
// |   !=0              |(dontcare)|  Invoker   | Static function|
// |   0                |  !=0     |  !=0*      | Method call    |
// +--------------------+----------+------------+----------------+
//  * For Metrowerks, this can be 0. (first virtual function in a
//       single_inheritance class).
// When stored stored inside a specific delegate, the 'dontcare' entries are replaced
// with a reference to the delegate itself. This complicates the = and == operators
// for the delegate class.

//				CUtlAbstractDelegate - Evil version
//
// For compilers where data pointers are at least as big as code pointers, it is
// possible to store the function pointer in the this pointer, using another
// horrible_cast. In this case the CUtlAbstractDelegate implementation is simple:
// +--pThis --+-- pMemFunc-+-- Meaning---------------------+
// |    0     |  0         | Empty                         |
// |  !=0     |  !=0*      | Static function or method call|
// +----------+------------+-------------------------------+
//  * For Metrowerks, this can be 0. (first virtual function in a
//       single_inheritance class).
// Note that the Sun C++ and MSVC documentation explicitly state that they
// support static_cast between void * and function pointers.

class CUtlAbstractDelegate
{
protected:
    // the data is protected, not private, because many
    // compilers have problems with template friends.
    typedef void (detail::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
    detail::GenericClass *m_pthis;
    GenericMemFuncType m_pFunction;

#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
    typedef void (*GenericFuncPtr)(); // arbitrary code pointer
	GenericFuncPtr m_pStaticFunction;
#endif

public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
    CUtlAbstractDelegate() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};
	void Clear()
	{
		m_pthis=0; m_pFunction=0; m_pStaticFunction=0;
	}
#else
    CUtlAbstractDelegate() : m_pthis(nullptr), m_pFunction(nullptr) {};
    void Clear() {	m_pthis=nullptr; m_pFunction=nullptr;	}
#endif
public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
    inline bool IsEqual (const CUtlAbstractDelegate &x) const
	{
	    // We have to cope with the static function pointers as a special case
		if (m_pFunction!=x.m_pFunction)
			return false;
		// the static function ptrs must either both be equal, or both be 0.
		if (m_pStaticFunction!=x.m_pStaticFunction)
			return false;
		if (m_pStaticFunction!=0)
			return m_pthis==x.m_pthis;
		else
			return true;
	}
#else // Evil Method
    [[nodiscard]] inline bool IsEqual (const CUtlAbstractDelegate &x) const
    {
        return m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;
    }
#endif
    // Provide a strict weak ordering for DelegateMementos.
    [[nodiscard]] inline bool IsLess(const CUtlAbstractDelegate &right) const
    {
        // deal with static function pointers first
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
        if (m_pStaticFunction !=0 || right.m_pStaticFunction!=0)
			return m_pStaticFunction < right.m_pStaticFunction;
#endif
        if (m_pthis !=right.m_pthis)
            return m_pthis < right.m_pthis;
        // There are no ordering operators for member function pointers,
        // but we can fake one by comparing each byte. The resulting ordering is
        // arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
        return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;

    }
    // BUGFIX (Mar 2005):
    // We can't just compare m_pFunction because on Metrowerks,
    // m_pFunction can be zero even if the delegate is not empty!
    inline bool operator ! () const		// Is it bound to anything?
    {
        return m_pthis==nullptr && m_pFunction==nullptr;
    }
    [[nodiscard]] inline bool IsEmpty() const		// Is it bound to anything?
    {
        return m_pthis==nullptr && m_pFunction==nullptr;
    }
public:
    CUtlAbstractDelegate & operator = (const CUtlAbstractDelegate &right)
    {
        SetMementoFrom(right);
        return *this;
    }
    inline bool operator <(const CUtlAbstractDelegate &right)
    {
        return IsLess(right);
    }
    inline bool operator >(const CUtlAbstractDelegate &right)
    {
        return right.IsLess(*this);
    }
    CUtlAbstractDelegate (const CUtlAbstractDelegate &right)  :
            m_pFunction(right.m_pFunction), m_pthis(right.m_pthis)
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
    , m_pStaticFunction (right.m_pStaticFunction)
#endif
    {}

    // Only use this if you really know what you're doing.
    // It's used in cases where I've cached off a delegate previously
    void UnsafeThisPointerSlam( void *pThis )
    {
        m_pthis = (detail::GenericClass*)( pThis );
    }

    void *UnsafeGetThisPtr()
    {
        return m_pthis;
    }

protected:
    void SetMementoFrom(const CUtlAbstractDelegate &right)
    {
        m_pFunction = right.m_pFunction;
        m_pthis = right.m_pthis;
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
        m_pStaticFunction = right.m_pStaticFunction;
#endif
    }
};


//						ClosurePtr<>
//
// A private wrapper class that adds function signatures to CUtlAbstractDelegate.
// It's the class that does most of the actual work.
// The signatures are specified by:
// GenericMemFunc: must be a type of GenericClass member function pointer.
// StaticFuncPtr:  must be a type of function pointer with the same signature
//                 as GenericMemFunc.
// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
//                 where it never returns void (returns DefaultVoid instead).

// An outer class, FastDelegateN<>, handles the invoking and creates the
// necessary typedefs.
// This class does everything else.

namespace detail
{

    template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>
    class ClosurePtr : public CUtlAbstractDelegate
    {
    public:
        // These functions are for setting the delegate to a member function.

        // Here's the clever bit: we convert an arbitrary member function into a
        // standard form. XMemFunc should be a member function of class X, but I can't
        // enforce that here. It needs to be enforced by the wrapper class.
        template < class X, class XMemFunc >
        inline void bindmemfunc(X *pthis, XMemFunc function_to_bind )
        {
            m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
            ::Convert(pthis, function_to_bind, m_pFunction);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            m_pStaticFunction = 0;
#endif
        }
        // For const member functions, we only need a const class pointer.
        // Since we know that the member function is const, it's safe to
        // remove the const qualifier from the 'this' pointer with a const_cast.
        // VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
        template < class X, class XMemFunc>
        inline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind)
        {
            m_pthis= SimplifyMemFunc< sizeof(function_to_bind) >
            ::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            m_pStaticFunction = 0;
#endif
        }
#ifdef FASTDELEGATE_GCC_BUG_8271	// At present, GCC doesn't recognize constness of MFPs in templates
        template < class X, class XMemFunc>
        inline void bindmemfunc(const X *pthis, XMemFunc function_to_bind)
        {
            bindconstmemfunc(pthis, function_to_bind);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            m_pStaticFunction = 0;
#endif
        }
#endif
        // These functions are required for invoking the stored function
        [[nodiscard]] inline GenericClass *GetClosureThis() const { return m_pthis; }
        inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

// There are a few ways of dealing with static function pointers.
// There's a standard-compliant, but tricky method.
// There's also a straightforward hack, that won't work on DOS compilers using the
// medium memory model. It's so evil that I can't recommend it, but I've
// implemented it anyway because it produces very nice asm code.

#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

        //				ClosurePtr<> - Safe version
//
// This implementation is standard-compliant, but a bit tricky.
// I store the function pointer inside the class, and the delegate then
// points to itself. Whenever the delegate is copied, these self-references
// must be transformed, and this complicates the = and == operators.
public:
	// The next two functions are for operator ==, =, and the copy constructor.
	// We may need to convert the m_pthis pointers, so that
	// they remain as self-references.
	template< class DerivedClass >
	inline void CopyFrom (DerivedClass *pParent, const CUtlAbstractDelegate &x)
	{
		SetMementoFrom(x);
		if (m_pStaticFunction!=0)
		{
			// transform self references...
			m_pthis=reinterpret_cast<GenericClass *>(pParent);
		}
	}
	// For static functions, the 'static_function_invoker' class in the parent
	// will be called. The parent then needs to call GetStaticFunction() to find out
	// the actual function to invoke.
	template < class DerivedClass, class ParentInvokerSig >
	inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
				StaticFuncPtr function_to_bind )
	{
		if (function_to_bind==0)
		{	// cope with assignment to 0
			m_pFunction=0;
		}
		else
		{
			bindmemfunc(pParent, static_function_invoker);
        }
		m_pStaticFunction=reinterpret_cast<GenericFuncPtr>(function_to_bind);
	}
	inline UnvoidStaticFuncPtr GetStaticFunction() const
	{
		return reinterpret_cast<UnvoidStaticFuncPtr>(m_pStaticFunction);
	}
#else

//				ClosurePtr<> - Evil version
//
// For compilers where data pointers are at least as big as code pointers, it is
// possible to store the function pointer in the this pointer, using another
// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
// speeds up comparison and assignment. If C++ provided direct language support
// for delegates, they would produce asm code that was almost identical to this.
// Note that the Sun C++ and MSVC documentation explicitly state that they
// support static_cast between void * and function pointers.

        template< class DerivedClass >
        inline void CopyFrom (DerivedClass *pParent, const CUtlAbstractDelegate &right)
        {
            pParent;
            SetMementoFrom(right);
        }
        // For static functions, the 'static_function_invoker' class in the parent
        // will be called. The parent then needs to call GetStaticFunction() to find out
        // the actual function to invoke.
        // ******** EVIL, EVIL CODE! *******
        template < 	class DerivedClass, class ParentInvokerSig>
        inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
                                   StaticFuncPtr function_to_bind)
        {
            if (function_to_bind==0)
            {	// cope with assignment to 0
                m_pFunction=0;
            }
            else
            {
                // We'll be ignoring the 'this' pointer, but we need to make sure we pass
                // a valid value to bindmemfunc().
                bindmemfunc(pParent, static_function_invoker);
            }

            // WARNING! Evil hack. We store the function in the 'this' pointer!
            // Ensure that there's a compilation failure if function pointers
            // and data pointers have different sizes.
            // If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
            typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];
            m_pthis = horrible_cast<GenericClass *>(function_to_bind);
            // MSVC, SunC++ and DMC accept the following (non-standard) code:
//		m_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));
            // BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
//		m_pthis = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(function_to_bind));
        }
        // ******** EVIL, EVIL CODE! *******
        // This function will be called with an invalid 'this' pointer!!
        // We're just returning the 'this' pointer, converted into
        // a function pointer!
        inline UnvoidStaticFuncPtr GetStaticFunction() const
        {
            // Ensure that there's a compilation failure if function pointers
            // and data pointers have different sizes.
            // If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
            typedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr)==sizeof(this) ? 1 : -1];
            return horrible_cast<UnvoidStaticFuncPtr>(this);
        }
#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

        // Does the closure contain this static function?
        inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr)
        {
            if (funcptr==0) return IsEmpty();
                // For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
                // value that is not equal to any valid function pointer.
            else return funcptr==reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
        }
    };


} // namespace detail

////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 3:
//
//				Wrapper classes to ensure type safety
//
////////////////////////////////////////////////////////////////////////////////


// Once we have the member function conversion templates, it's easy to make the
// wrapper classes. So that they will work with as many compilers as possible,
// the classes are of the form
//   FastDelegate3<int, char *, double>
// They can cope with any combination of parameters. The max number of parameters
// allowed is 8, but it is trivial to increase this limit.
// Note that we need to treat const member functions seperately.
// All this class does is to enforce type safety, and invoke the delegate with
// the correct list of parameters.

// Because of the weird rule about the class of derived member function pointers,
// you sometimes need to apply a downcast to the 'this' pointer.
// This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below.
// If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
// without this trick you'd need to write:
//		MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
// but with the trick you can write
//		MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);

// RetType is the type the compiler uses in compiling the template. For VC6,
// it cannot be void. DesiredRetType is the real type which is returned from
// all of the functions. It can be void.

// Implicit conversion to "bool" is achieved using the safe_bool idiom,
// using member data pointers (MDP). This allows "if (dg)..." syntax
// Because some compilers (eg codeplay) don't have a unique value for a zero
// MDP, an extra padding member is added to the SafeBool struct.
// Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
// in that case the static function constructor is not made explicit; this
// allows "if (dg==0) ..." to compile.

//N=0
template<class RetType=detail::DefaultVoid>
class FastDelegate0
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)();
    typedef RetType (*UnvoidStaticFunctionPtr)();
    typedef RetType (detail::GenericClass::*GenericMemFn)();
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate0 type;

    // Construction and comparison functions
    FastDelegate0() { Clear(); }
    FastDelegate0(const FastDelegate0 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate0 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate0 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate0 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate0 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate0 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate0(Y *pthis, DesiredRetType (X::* function_to_bind)() )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)())
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate0(const Y *pthis, DesiredRetType (X::* function_to_bind)() const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)() const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate0(DesiredRetType (*function_to_bind)() )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)() )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)())
    {
        m_Closure.bindstaticfunc(this, &FastDelegate0::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() () const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))();
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction() const
    {
        return (*(m_Closure.GetStaticFunction()))();
    }
};

//N=1
template<class Param1, class RetType=detail::DefaultVoid>
class FastDelegate1
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate1 type;

    // Construction and comparison functions
    FastDelegate1() { Clear(); }
    FastDelegate1(const FastDelegate1 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate1 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate1 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate1 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate1 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate1 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate1(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate1(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate1(DesiredRetType (*function_to_bind)(Param1 p1) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate1::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1);
    }
};

//N=2
template<class Param1, class Param2, class RetType=detail::DefaultVoid>
class FastDelegate2
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate2 type;

    // Construction and comparison functions
    FastDelegate2() { Clear(); }
    FastDelegate2(const FastDelegate2 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate2 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate2 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate2 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate2 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate2 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate2(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate2(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate2(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate2::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2);
    }
};

//N=3
template<class Param1, class Param2, class Param3, class RetType=detail::DefaultVoid>
class FastDelegate3
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate3 type;

    // Construction and comparison functions
    FastDelegate3() { Clear(); }
    FastDelegate3(const FastDelegate3 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate3 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate3 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate3 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate3 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate3 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate3(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate3(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate3(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate3::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3);
    }
};

//N=4
template<class Param1, class Param2, class Param3, class Param4, class RetType=detail::DefaultVoid>
class FastDelegate4
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate4 type;

    // Construction and comparison functions
    FastDelegate4() { Clear(); }
    FastDelegate4(const FastDelegate4 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate4 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate4 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate4 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate4 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate4 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate4(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate4(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate4(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate4::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4);
    }
};

//N=5
template<class Param1, class Param2, class Param3, class Param4, class Param5, class RetType=detail::DefaultVoid>
class FastDelegate5
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate5 type;

    // Construction and comparison functions
    FastDelegate5() { Clear(); }
    FastDelegate5(const FastDelegate5 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate5 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate5 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate5 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate5 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate5 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate5(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate5(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate5(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate5::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5);
    }
};

//N=6
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType=detail::DefaultVoid>
class FastDelegate6
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate6 type;

    // Construction and comparison functions
    FastDelegate6() { Clear(); }
    FastDelegate6(const FastDelegate6 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate6 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate6 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate6 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate6 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate6 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate6(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate6(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate6(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate6::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6);
    }
};

//N=7
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType=detail::DefaultVoid>
class FastDelegate7
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate7 type;

    // Construction and comparison functions
    FastDelegate7() { Clear(); }
    FastDelegate7(const FastDelegate7 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate7 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate7 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate7 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate7 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate7 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate7(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate7(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate7(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate7::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7);
    }
};

//N=8
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType=detail::DefaultVoid>
class FastDelegate8
{
private:
    typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
    typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
    typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
    typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
    typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
    ClosureType m_Closure;
public:
    // Typedefs to aid generic programming
    typedef FastDelegate8 type;

    // Construction and comparison functions
    FastDelegate8() { Clear(); }
    FastDelegate8(const FastDelegate8 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    void operator = (const FastDelegate8 &x)
    {
        m_Closure.CopyFrom(this, x.m_Closure);
    }
    bool operator ==(const FastDelegate8 &x) const
    {
        return m_Closure.IsEqual(x.m_Closure);
    }
    bool operator !=(const FastDelegate8 &x) const
    {
        return !m_Closure.IsEqual(x.m_Closure);
    }
    bool operator <(const FastDelegate8 &x) const
    {
        return m_Closure.IsLess(x.m_Closure);
    }
    bool operator >(const FastDelegate8 &x) const
    {
        return x.m_Closure.IsLess(m_Closure);
    }
    // Binding to non-const member functions
    template < class X, class Y >
    FastDelegate8(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) )
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
    {
        m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
    }
    // Binding to const member functions.
    template < class X, class Y >
    FastDelegate8(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
    }
    template < class X, class Y >
    inline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
    {
        m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
    }
    // Static functions. We convert them into a member function call.
    // This constructor also provides implicit conversion
    explicit FastDelegate8(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) )
    {
        Bind(function_to_bind);
    }
    // for efficiency, prevent creation of a temporary
    void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) )
    {
        Bind(function_to_bind);
    }
    inline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
    {
        m_Closure.bindstaticfunc(this, &FastDelegate8::InvokeStaticFunction,
                                 function_to_bind);
    }
    // Invoke the delegate
    RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
    {
        return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8);
    }
    // Implicit conversion to "bool" using the safe_bool idiom
private:
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
    explicit operator unspecified_bool_type() const
    {
        return IsEmpty()? 0: &SafeBoolStruct::m_nonzero;
    }
    // necessary to allow ==0 to work despite the safe_bool idiom
    inline bool operator==(StaticFunctionPtr funcptr)
    {
        return m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator!=(StaticFunctionPtr funcptr)
    {
        return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
    }
    inline bool operator ! () const
    {	// Is it bound to anything?
        return !m_Closure;
    }
    [[nodiscard]] inline bool IsEmpty() const
    {
        return !m_Closure;
    }
    void Clear() { m_Closure.Clear();}
    // Conversion to and from the CUtlAbstractDelegate storage class
    const CUtlAbstractDelegate & GetAbstractDelegate() { return m_Closure; }
    void SetAbstractDelegate(const CUtlAbstractDelegate &any) { m_Closure.CopyFrom(this, any); }

private:	// Invoker for static functions
    RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
    {
        return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8);
    }
};


////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 4:
//
//				CUtlDelegate<> class (Original author: Jody Hagins)
// Allows boost::function style syntax like:
//			CUtlDelegate< double (int, long) >
// instead of:
//			FastDelegate2< int, long, double >
//
////////////////////////////////////////////////////////////////////////////////

#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

// Declare CUtlDelegate as a class template.  It will be specialized
// later for all number of arguments.
template <typename Signature>
class CUtlDelegate;

//N=0
// Specialization to allow use of
// CUtlDelegate< R (  ) >
// instead of
// FastDelegate0 < R >
template<typename R>
class CUtlDelegate< R (  ) >
    // Inherit from FastDelegate0 so that it can be treated just like a FastDelegate0
        : public FastDelegate0 < R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate0 < R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)(  ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)(  ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)(  ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=1
// Specialization to allow use of
// CUtlDelegate< R ( Param1 ) >
// instead of
// FastDelegate1 < Param1, R >
template<typename R, class Param1>
class CUtlDelegate< R ( Param1 ) >
    // Inherit from FastDelegate1 so that it can be treated just like a FastDelegate1
        : public FastDelegate1 < Param1, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate1 < Param1, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=2
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2 ) >
// instead of
// FastDelegate2 < Param1, Param2, R >
template<typename R, class Param1, class Param2>
class CUtlDelegate< R ( Param1, Param2 ) >
    // Inherit from FastDelegate2 so that it can be treated just like a FastDelegate2
        : public FastDelegate2 < Param1, Param2, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate2 < Param1, Param2, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=3
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3 ) >
// instead of
// FastDelegate3 < Param1, Param2, Param3, R >
template<typename R, class Param1, class Param2, class Param3>
class CUtlDelegate< R ( Param1, Param2, Param3 ) >
    // Inherit from FastDelegate3 so that it can be treated just like a FastDelegate3
        : public FastDelegate3 < Param1, Param2, Param3, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate3 < Param1, Param2, Param3, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=4
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3, Param4 ) >
// instead of
// FastDelegate4 < Param1, Param2, Param3, Param4, R >
template<typename R, class Param1, class Param2, class Param3, class Param4>
class CUtlDelegate< R ( Param1, Param2, Param3, Param4 ) >
    // Inherit from FastDelegate4 so that it can be treated just like a FastDelegate4
        : public FastDelegate4 < Param1, Param2, Param3, Param4, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate4 < Param1, Param2, Param3, Param4, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=5
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >
// instead of
// FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>
class CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >
    // Inherit from FastDelegate5 so that it can be treated just like a FastDelegate5
        : public FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=6
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >
// instead of
// FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
class CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >
    // Inherit from FastDelegate6 so that it can be treated just like a FastDelegate6
        : public FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=7
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >
// instead of
// FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
class CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >
    // Inherit from FastDelegate7 so that it can be treated just like a FastDelegate7
        : public FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

//N=8
// Specialization to allow use of
// CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >
// instead of
// FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
class CUtlDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >
    // Inherit from FastDelegate8 so that it can be treated just like a FastDelegate8
        : public FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
{
public:
    // Make using the base type a bit easier via typedef.
    typedef FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R > BaseType;

    // Allow users access to the specific type of this delegate.
    typedef CUtlDelegate SelfType;

    // Mimic the base class constructors.
    CUtlDelegate() : BaseType() { }

    template < class X, class Y >
    CUtlDelegate(Y * pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
            : BaseType(pthis, function_to_bind)
    { }

    template < class X, class Y >
    CUtlDelegate(const Y *pthis, R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const)
            : BaseType(pthis, function_to_bind)
    { }

    explicit CUtlDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
            : BaseType(function_to_bind)
    { }

    void operator = (const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};


#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 5:
//
//				UtlMakeDelegate() helper function
//
//			UtlMakeDelegate(&x, &X::func) returns a fastdelegate of the type
//			necessary for calling x.func() with the correct number of arguments.
//			This makes it possible to eliminate many typedefs from user code.
//
////////////////////////////////////////////////////////////////////////////////

// Also declare overloads of a UtlMakeDelegate() global function to
// reduce the need for typedefs.
// We need seperate overloads for const and non-const member functions.
// Also, because of the weird rule about the class of derived member function pointers,
// implicit downcasts may need to be applied later to the 'this' pointer.
// That's why two classes (X and Y) appear in the definitions. Y must be implicitly
// castable to X.

// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.
// GCC 3.2 and later won't compile this unless it's preceded by 'typename',
// but VC6 doesn't allow 'typename' in this context.
// So, I have to use a macro.

#ifdef FASTDLGT_VC6
#define FASTDLGT_RETTYPE detail::VoidToDefaultVoid<RetType>::type
#else
#define FASTDLGT_RETTYPE RetType
#endif


//N=0
template <class X, class Y, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( ) > UtlMakeDelegate(Y* x, RetType (X::*func)())
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( ) >(x, func);
}

template <class X, class Y, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( ) > UtlMakeDelegate(Y* x, RetType (X::*func)() const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( ) >(x, func);
}

template < class RetType >
CUtlDelegate< FASTDLGT_RETTYPE ( ) > UtlMakeDelegate( RetType (*func)())
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( ) >( func );
}

//N=1
template <class X, class Y, class Param1, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) >(x, func);
}

template <class X, class Y, class Param1, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) >(x, func);
}

template < class Param1, class RetType >
CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) > UtlMakeDelegate( RetType (*func)(Param1 p1))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1 ) >( func );
}


//N=2
template <class X, class Y, class Param1, class Param2, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) >(x, func);
}

template <class Param1, class Param2, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) > UtlMakeDelegate( RetType (*func)(Param1 p1, Param2 p2))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2 ) >(func);
}

//N=3
template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) > UtlMakeDelegate( RetType (*func)(Param1 p1, Param2 p2, Param3 p3))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3 ) >(func);
}

//N=4
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) > UtlMakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4 ) >(func);
}

//N=5
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) > UtlMakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5 ) >(func);
}

//N=6
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) > UtlMakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6 ) >(func);
}

//N=7
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) > UtlMakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >(func);
}

//N=8
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) > UtlMakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) > UtlMakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
{
    return CUtlDelegate< FASTDLGT_RETTYPE ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >(func);
}


// clean up after ourselves...
#undef FASTDLGT_RETTYPE

#endif // !defined(UTLDELEGATEIMPL_H)


```

`src/SDK/bf_read.h`:

```h
#pragma once

#include <cstdint>

typedef int32_t int32;
typedef int64_t int64;
typedef uint32_t uint32;
typedef uint64_t uint64;

#define BITBUF_INLINE inline
#define RESTRICT __restrict

class bf_read
{
public:
    // The current buffer.
    const unsigned char* __restrict m_pData;
    int						m_nDataBytes;
    int						m_nDataBits;

    // Where we are in the buffer.
    int				m_iCurBit;


private:
    // Errors?
    bool			m_bOverflow;

    // For debugging..
    bool			m_bAssertOnOverflow;

    const char		*m_pDebugName;

public:
    bf_read()
    {
        m_pData = NULL;
        m_nDataBytes = 0;
        m_nDataBits = -1; // set to -1 so we overflow on any operation
        m_iCurBit = 0;
        m_bOverflow = false;
        m_bAssertOnOverflow = true;
        m_pDebugName = NULL;
    }

    // nMaxBits can be used as the number of bits in the buffer.
    // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
    bf_read( const void *pData, int nBytes, int nBits = -1 );
    bf_read( const char *pDebugName, const void *pData, int nBytes, int nBits = -1 );

    // Start reading from the specified buffer.
    // pData's start address must be dword-aligned.
    // nMaxBits can be used as the number of bits in the buffer.
    // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
    void			StartReading( const void *pData, int nBytes, int iStartBit = 0, int nBits = -1 );

    // Restart buffer reading.
    void			Reset();

    // Enable or disable assertion on overflow. 99% of the time, it's a bug that we need to catch,
    // but there may be the occasional buffer that is allowed to overflow gracefully.
    void			SetAssertOnOverflow( bool bAssert );

    // This can be set to assign a name that gets output if the buffer overflows.
    [[nodiscard]] const char*		GetDebugName() const { return m_pDebugName; }
    void			SetDebugName( const char *pName );

    void			ExciseBits( int startbit, int bitstoremove );


// Bit functions.
public:

    // Returns 0 or 1.
    int				ReadOneBit();


protected:

    unsigned int	CheckReadUBitLong(int numbits);		// For debugging.
    int				ReadOneBitNoCheck();				// Faster version, doesn't check bounds and is inlined.
    bool			CheckForOverflow(int nBits);


public:

    // Get the base pointer.
    const unsigned char*	GetBasePointer() { return m_pData; }

    [[nodiscard]] BITBUF_INLINE int TotalBytesAvailable( void ) const
    {
        return m_nDataBytes;
    }

    // Read a list of bits in.
    void            ReadBits(void *pOut, int nBits);
    // Read a list of bits in, but don't overrun the destination buffer.
    // Returns the number of bits read into the buffer. The remaining
    // bits are skipped over.
    int             ReadBitsClamped_ptr(void *pOut, size_t outSizeBytes, size_t nBits);
    // Helper 'safe' template function that infers the size of the destination
    // array. This version of the function should be preferred.
    // Usage: char databuffer[100];
    //        ReadBitsClamped( dataBuffer, msg->m_nLength );
    template <typename T, size_t N>
    int             ReadBitsClamped( T (&pOut)[N], size_t nBits )
    {
        return ReadBitsClamped_ptr( pOut, N * sizeof(T), nBits );
    }

    float			ReadBitAngle( int numbits );

    unsigned int	ReadUBitLong( int numbits ) RESTRICT;
    unsigned int	ReadUBitLongNoInline( int numbits ) RESTRICT;
    unsigned int	PeekUBitLong( int numbits );
    int				ReadSBitLong( int numbits );

    // reads an unsigned integer with variable bit length
    unsigned int	ReadUBitVar();
    unsigned int	ReadUBitVarInternal( int encodingType );

    // reads a varint encoded integer
    uint32			ReadVarInt32();
    uint64			ReadVarInt64();
    int32			ReadSignedVarInt32();
    int64			ReadSignedVarInt64();

    // You can read signed or unsigned data with this, just cast to
    // a signed int if necessary.
    unsigned int	ReadBitLong(int numbits, bool bSigned);

    float			ReadBitCoord();
    float			ReadBitCoordMP( bool bIntegral, bool bLowPrecision );
    float			ReadBitFloat();
    float			ReadBitNormal();
    void			ReadBitVec3Coord( Vector& fa );
    void			ReadBitVec3Normal( Vector& fa );
    void			ReadBitAngles( QAngle& fa );

    // Faster for comparisons but do not fully decode float values
    unsigned int	ReadBitCoordBits();
    unsigned int	ReadBitCoordMPBits( bool bIntegral, bool bLowPrecision );

// Byte functions (these still read data in bit-by-bit).
public:

    BITBUF_INLINE int	ReadChar() { return (char)ReadUBitLong(8); }
    BITBUF_INLINE int	ReadByte() { return ReadUBitLong(8); }
    BITBUF_INLINE int	ReadShort() { return (short)ReadUBitLong(16); }
    BITBUF_INLINE int	ReadWord() { return ReadUBitLong(16); }
    BITBUF_INLINE long ReadLong() { return ReadUBitLong(32); }
    int64			ReadLongLong();
    float			ReadFloat();
    bool			ReadBytes(void *pOut, int nBytes);

    // Returns false if bufLen isn't large enough to hold the
    // string in the buffer.
    //
    // Always reads to the end of the string (so you can read the
    // next piece of data waiting).
    //
    // If bLine is true, it stops when it reaches a '\n' or a null-terminator.
    //
    // pStr is always null-terminated (unless bufLen is 0).
    //
    // pOutNumChars is set to the number of characters left in pStr when the routine is
    // complete (this will never exceed bufLen-1).
    //
    bool			ReadString( char *pStr, int bufLen, bool bLine=false, int *pOutNumChars=NULL );

    // Reads a string and allocates memory for it. If the string in the buffer
    // is > 2048 bytes, then pOverflow is set to true (if it's not NULL).
    char*			ReadAndAllocateString( bool *pOverflow = nullptr );

    // Returns nonzero if any bits differ
    int				CompareBits( bf_read * RESTRICT other, int bits ) RESTRICT;
    int				CompareBitsAt( int offset, bf_read * RESTRICT other, int otherOffset, int bits ) RESTRICT;

// Status.
public:
    int				GetNumBytesLeft();
    int				GetNumBytesRead();
    int				GetNumBitsLeft();
    [[nodiscard]] int				GetNumBitsRead() const;

    // Has the buffer overflowed?
    [[nodiscard]] inline bool		IsOverflowed() const {return m_bOverflow;}

    inline bool		Seek(int iBit);					// Seek to a specific bit.
    inline bool		SeekRelative(int iBitDelta);	// Seek to an offset from the current position.

    // Called when the buffer is overflowed.
    void			SetOverflowFlag();
};
```

`src/SDK/bf_write.h`:

```h
#pragma once

#include <cstdint>

typedef int32_t int32;
typedef int64_t int64;
typedef uint32_t uint32;
typedef uint64_t uint64;

#define RESTRICT __restrict

class bf_write
{
public:
    // The current buffer.
    unsigned long*  RESTRICT m_pData;
    int				m_nDataBytes;
    int				m_nDataBits;

    // Where we are in the buffer.
    int				m_iCurBit;

private:

    // Errors?
    bool			m_bOverflow;

    bool			m_bAssertOnOverflow;
    const char		*m_pDebugName;

public:
    bf_write(){
        m_pData = NULL;
        m_nDataBytes = 0;
        m_nDataBits = -1; // set to -1 so we generate overflow on any operation
        m_iCurBit = 0;
        m_bOverflow = false;
        m_bAssertOnOverflow = true;
        m_pDebugName = NULL;
    }

    bf_write( const char *pDebugName, void *pData, int nBytes, int nBits = -1 )
    {
        m_bAssertOnOverflow = true;
        m_pDebugName = pDebugName;
        StartWriting( pData, nBytes, 0, nBits );
    }

    bf_write( void *pData, int nBytes, int nBits = -1 )
    {
        m_bAssertOnOverflow = true;
        m_pDebugName = NULL;
        StartWriting( pData, nBytes, 0, nBits );
    }

    // Start writing to the specified buffer.
    // nMaxBits can be used as the number of bits in the buffer.
    // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
    void			StartWriting( void *pData, int nBytes, int iStartBit = 0, int nMaxBits = -1 );

    // Restart buffer writing.
    void			Reset();

    // Get the base pointer.
    unsigned char*	GetBasePointer() { return (unsigned char*) m_pData; }

    // Enable or disable assertion on overflow. 99% of the time, it's a bug that we need to catch,
    // but there may be the occasional buffer that is allowed to overflow gracefully.
    void			SetAssertOnOverflow( bool bAssert );

    // This can be set to assign a name that gets output if the buffer overflows.
    const char*		GetDebugName();
    void			SetDebugName( const char *pDebugName );


// Seek to a specific position.
public:

    void			SeekToBit( int bitPos );


// Bit functions.
public:

    void			WriteOneBit(int nValue);
    void			WriteOneBitNoCheck(int nValue);
    void			WriteOneBitAt( int iBit, int nValue );

    // Write signed or unsigned. Range is only checked in debug.
    void			WriteUBitLong( unsigned int data, int numbits, bool bCheckRange=true );
    void			WriteSBitLong( int data, int numbits );

    // Tell it whether or not the data is unsigned. If it's signed,
    // cast to unsigned before passing in (it will cast back inside).
    void			WriteBitLong(unsigned int data, int numbits, bool bSigned);

    // Write a list of bits in.
    bool			WriteBits(const void *pIn, int nBits);

    // writes an unsigned integer with variable bit length
    void			WriteUBitVar( unsigned int data );

    // writes a varint encoded integer
    void			WriteVarInt32( uint32 data );
    void			WriteVarInt64( uint64 data );
    void			WriteSignedVarInt32( int32 data );
    void			WriteSignedVarInt64( int64 data );
    int				ByteSizeVarInt32( uint32 data );
    int				ByteSizeVarInt64( uint64 data );
    int				ByteSizeSignedVarInt32( int32 data );
    int				ByteSizeSignedVarInt64( int64 data );

    // Copy the bits straight out of pIn. This seeks pIn forward by nBits.
    // Returns an error if this buffer or the read buffer overflows.
    bool			WriteBitsFromBuffer( class bf_read *pIn, int nBits );

    void			WriteBitAngle( float fAngle, int numbits );
    void			WriteBitCoord (float f);
    void			WriteBitCoordMP( float f, bool bIntegral, bool bLowPrecision );
    void			WriteBitFloat(float val);
    void			WriteBitVec3Coord( const Vector& fa );
    void			WriteBitNormal( float f );
    void			WriteBitVec3Normal( const Vector& fa );
    void			WriteBitAngles( const QAngle& fa );


// Byte functions.
public:

    void			WriteChar(int val);
    void			WriteByte(int val);
    void			WriteShort(int val);
    void			WriteWord(int val);
    void			WriteLong(long val);
    void			WriteLongLong(int64 val);
    void			WriteFloat(float val);
    bool			WriteBytes( const void *pBuf, int nBytes );

    // Returns false if it overflows the buffer.
    bool			WriteString(const char *pStr);


// Status.
public:

    // How many bytes are filled in?
    [[nodiscard]] int				GetNumBytesWritten() const;
    [[nodiscard]] int				GetNumBitsWritten() const;
    int				GetMaxNumBits();
    int				GetNumBitsLeft();
    int				GetNumBytesLeft();
    unsigned char*	GetData();
    [[nodiscard]] const unsigned char*	GetData() const;

    // Has the buffer overflowed?
    bool			CheckForOverflow(int nBits);
    [[nodiscard]] inline bool		IsOverflowed() const {return m_bOverflow;}

    void			SetOverflowFlag();
};

inline void bf_write::StartWriting( void *pData, int nBytes, int iStartBit, int nBits )
{
    // Make sure it's dword aligned and padded.
    Assert( (nBytes % 4) == 0 );
    Assert(((unsigned long)pData & 3) == 0);

    // The writing code will overrun the end of the buffer if it isn't dword aligned, so truncate to force alignment
    nBytes &= ~3;

    m_pData = (unsigned long*)pData;
    m_nDataBytes = nBytes;

    if ( nBits == -1 )
    {
        m_nDataBits = nBytes << 3;
    }
    else
    {
        Assert( nBits <= nBytes*8 );
        m_nDataBits = nBits;
    }

    m_iCurBit = iStartBit;
    m_bOverflow = false;
}
```

`src/SDK/color.h`:

```h
#pragma once

// I dont remember where this color struct comes from but conflicts with the classic 4 unsigned bytes color that Source engine likes to use
struct Color2
{
	int r;
	int g;
	int b;
	int a;

	Color2()
	{
		this->r = 0;
		this->g = 0;
		this->b = 0;
		this->a = 255;
	}

	Color2(int r, int g, int b)
	{
		this->r = r;
		this->g = g;
		this->b = b;
		this->a = 255;
	}

	Color2(int r, int g, int b, int a)
	{
		this->r = r;
		this->g = g;
		this->b = b;
		this->a = a;
	}

	Color2 operator / (float div)
	{
		Color2 color = *this;
		color.r = color.r / div;
		color.g = color.g / div;
		color.b = color.b / div;
		return color;
	}

	Color2& operator /= (float div)
	{
		Color2& color = *this;
		color.r /= div;
		color.g /= div;
		color.b /= div;
		return color;
	}

	Color2& operator *= (float coeff)
	{
		Color2& color = *this;
		color.r *= coeff;
		color.g *= coeff;
		color.b *= coeff;
		return color;
	}

	static Color2 FromHSB(float hue, float saturation, float brightness)
	{
		float h = hue == 1.0f ? 0 : hue * 6.0f;
		float f = h - (int)h;
		float p = brightness * (1.0f - saturation);
		float q = brightness * (1.0f - saturation * f);
		float t = brightness * (1.0f - (saturation * (1.0f - f)));

		if (h < 1)
		{
			return Color2(
					(unsigned char)(brightness * 255),
					(unsigned char)(t * 255),
					(unsigned char)(p * 255)
			);
		}
		else if (h < 2)
		{
			return Color2(
					(unsigned char)(q * 255),
					(unsigned char)(brightness * 255),
					(unsigned char)(p * 255)
			);
		}
		else if (h < 3)
		{
			return Color2(
					(unsigned char)(p * 255),
					(unsigned char)(brightness * 255),
					(unsigned char)(t * 255)
			);
		}
		else if (h < 4)
		{
			return Color2(
					(unsigned char)(p * 255),
					(unsigned char)(q * 255),
					(unsigned char)(brightness * 255)
			);
		}
		else if (h < 5)
		{
			return Color2(
					(unsigned char)(t * 255),
					(unsigned char)(p * 255),
					(unsigned char)(brightness * 255)
			);
		}
		else
		{
			return Color2(
					(unsigned char)(brightness * 255),
					(unsigned char)(p * 255),
					(unsigned char)(q * 255)
			);
		}
	}
};

struct Color
{
    Color(unsigned char Red, unsigned char Green, unsigned char Blue, unsigned char Alpha = 255)
    {
        RGBA[0] = Red;
        RGBA[1] = Green;
        RGBA[2] = Blue;
        RGBA[3] = Alpha;
    }

    unsigned char RGBA[4];
};

struct ColorRGBA
{
	ColorRGBA(unsigned char Red, unsigned char Green, unsigned char Blue, unsigned char Alpha = 255)
	{
		RGBA[0] = Red;
		RGBA[1] = Green;
		RGBA[2] = Blue;
		RGBA[3] = Alpha;
	}

	unsigned char RGBA[4];
};
```

`src/SDK/common.h`:

```h
#pragma once
#include <cstring>
#include <vector>
#include "ConMsg.h"


struct InterfaceMetaData
{
	const char* name;
	uint32_t numVMs;
	void* interface;
};

inline std::vector<InterfaceMetaData> requestedInterfaces = {}; // requested but failed
inline std::vector<InterfaceMetaData> grabbedInterfaces = {}; // grabbed and can be used

typedef void* (*InstantiateInterfaceFn) ();

struct InterfaceReg
{
	InstantiateInterfaceFn m_CreateFn;
	const char *m_pName;
	InterfaceReg *m_pNext;
};

inline void**& getvtable(void* inst, size_t offset = 0)
{
	return *reinterpret_cast<void***>((size_t)inst + offset);
}

template< typename Fn >
inline Fn getvfunc( void* inst, size_t index, size_t offset = 0 ) {
	return reinterpret_cast<Fn>(getvtable( inst, offset )[index]);
}

template <typename interface>
interface* GetInterface(const char* filename, const char* version, uint32_t expectedVMs = 0)
{
	InterfaceMetaData data = {};
	data.name = version;
	data.numVMs = expectedVMs;

	void* library = dlopen(filename, RTLD_NOLOAD | RTLD_NOW | RTLD_LOCAL);

	if ( !library ){
		ConMsg( "%s: Could not open library: %s\n", __func__, filename );
		requestedInterfaces.push_back(data);
		return NULL;
	}

	void* createInterfaceSym = dlsym( library, "CreateInterface" );

	if ( !createInterfaceSym ) {
		dlclose(library);
		ConMsg( "%s: Could not find \"CreateInterface\" for library: %s\n", __func__, filename );
		requestedInterfaces.push_back(data);
		return NULL;
	}

	uintptr_t jump_instruction_addr = uintptr_t(createInterfaceSym) + 5;
	int32_t jump_displacement = *reinterpret_cast<int32_t*>(jump_instruction_addr + 1);
	uintptr_t createinterfaceinternal_addr = (jump_instruction_addr + 5) + jump_displacement;

	uintptr_t interface_list = createinterfaceinternal_addr;
	interface_list += *reinterpret_cast<int32_t*>(createinterfaceinternal_addr + 19); // relative offset to list
	interface_list += 23; // RIP after the address.

	dlclose(library);

	if( !interface_list ){
		ConMsg( "%s: Could not grab InterfaceList for library: %s\n", __func__,  filename );
		requestedInterfaces.push_back(data);
		return NULL;
	}

    for ( InterfaceReg *cur_interface = *reinterpret_cast<InterfaceReg**>(interface_list); cur_interface; cur_interface = cur_interface->m_pNext ){
		if ( strcmp( cur_interface->m_pName, version ) != 0 )
			continue;

		data.interface = cur_interface->m_CreateFn();
		grabbedInterfaces.push_back(data);
		return reinterpret_cast<interface*>(cur_interface->m_CreateFn());
    }

    ConMsg( "%s: Could not find Interface Named: %s in library %s\n", __func__, version, filename );
	requestedInterfaces.push_back(data);
	return NULL;
}

inline uintptr_t GetAbsoluteAddress(uintptr_t instruction_ptr, int offset, int size)
{
	return instruction_ptr + *reinterpret_cast<int32_t*>(instruction_ptr + offset) + size;
}

template <typename T>
T GetSymbolAddress(const char* filename, const char* symbol)
{
	void* handle = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
	T result = reinterpret_cast<T>(dlsym(handle, symbol));
	dlclose(handle);

	return result;
}
```

`src/SDK/definitions.h`:

```h
#pragma once

/* generic constants */
#define LIFE_ALIVE 0

/* Inspired by: https://github.com/DustinHLand/vkDOOM3/blob/master/neo/renderer/Vulkan/RenderBackend_VK.cpp#L91 */
#define CASE_STRING( x ) case static_cast<int>( x ) : return #x
#define CASE_STD_STRING( x ) case static_cast<int>( x ) : return std::string(#x)

typedef unsigned long long VPANEL;
typedef unsigned long long HFont;

class ICommandLine;
class KeyValues;
class CBaseClientState;
struct CGlowObjectManager;
class CDotaPlayer;

enum ClientFrameStage_t : int
{
	// (haven't run any frames yet)
	FRAME_UNDEFINED = -1,
	FRAME_START,
	// A network packet is being recieved
	FRAME_NET_UPDATE_START,
	// Data has been received and we're going to start calling PostDataUpdate
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	// Data has been received and we've called PostDataUpdate on all data recipients
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	// We've received all packets, we can now do interpolation, prediction, etc..
	FRAME_NET_UPDATE_END,
	// We're about to start rendering the scene
	FRAME_RENDER_START,
	// We've finished rendering the scene.
	FRAME_RENDER_END
};

enum class EClassIds : int
{
	CAdditionalWearable = 0,
	C_AI_BaseNPC = 1,
	C_BaseAnimating = 1,
	C_BaseAnimatingOverlay = 2,
	C_BaseAttributableItem = 3,
	C_BaseButton = 4,
	C_BaseClientUIEntity = 5,
	C_BaseCombatCharacter = 6,
	C_BaseCombatWeapon = 7,
	C_BaseDoor = 8,
	C_BaseEntity = 9,
	C_BaseFlex = 10,
	C_BaseModelEntity = 11,
	C_BasePlayer = 12,
	C_BasePropDoor = 13,
	C_BaseTeamObjectiveResource = 15,
	C_BaseToggle = 14,
	C_BaseTrigger = 15,
	C_BaseViewModel = 16,
	C_BaseVRHandAttachment = 17,
	C_Beam = 18,
	C_BeamSpotLight = 21,
	C_Breakable = 19,
	C_BreakableProp = 20,
	C_ButtonTimed = 21,
	C_ColorCorrection = 22,
	C_ColorCorrectionVolume = 23,
	C_DevtestHierarchy = 24,
	C_DOTA_Ability_Abaddon_DeathCoil = 25,
	CDOTA_Ability_AbyssalUnderlord_DarkRift = 26,
	CDOTA_Ability_AbyssalUnderlord_Firestorm = 27,
	CDOTA_Ability_AbyssalUnderlord_PitOfMalice = 28,
	CDOTA_Ability_Alchemist_AcidSpray = 29,
	C_DOTA_Ability_Alchemist_UnstableConcoction = 30,
	CDOTA_Ability_Alchemist_UnstableConcoctionThrow = 31,
	CDOTA_Ability_AncientApparition_ChillingTouch = 32,
	CDOTA_Ability_AncientApparition_ColdFeet = 33,
	CDOTA_Ability_AncientApparition_IceBlast = 34,
	CDOTA_Ability_AncientApparition_IceVortex = 35,
	C_DOTA_Ability_AntiMage_Blink = 36,
	C_DOTA_Ability_AntiMage_ManaVoid = 37,
	C_DOTA_Ability_AntiMage_SpellShield = 38,
	C_DOTA_Ability_ArcWarden_Flux = 39,
	C_DOTA_Ability_ArcWarden_MagneticField = 40,
	C_DOTA_Ability_ArcWarden_SparkWraith = 41,
	C_DOTA_Ability_ArcWarden_TempestDouble = 42,
	C_DOTA_Ability_AttributeBonus = 43,
	C_DOTA_Ability_Axe_BerserkersCall = 44,
	C_DOTA_Ability_Axe_CounterHelix = 45,
	C_DOTA_Ability_Axe_CullingBlade = 46,
	C_DOTA_Ability_Bane_BrainSap = 47,
	C_DOTA_Ability_Bane_FiendsGrip = 48,
	C_DOTA_Ability_Batrider_Flamebreak = 49,
	C_DOTA_Ability_Batrider_StickyNapalm = 50,
	CDOTA_Ability_Beastmaster_PrimalRoar = 51,
	C_DOTA_Ability_BlackDragon_Fireball = 52,
	CDOTA_Ability_Bloodseeker_Bloodbath = 53,
	C_DOTA_Ability_BountyHunter_Jinada = 54,
	C_DOTA_Ability_BountyHunter_ShurikenToss = 55,
	C_DOTA_Ability_Brewmaster_DispelMagic = 56,
	C_DOTA_Ability_Brewmaster_DrunkenBrawler = 57,
	C_DOTA_Ability_Brewmaster_DrunkenHaze = 58,
	C_DOTA_Ability_Brewmaster_PermanentImmolation = 59,
	C_DOTA_Ability_Brewmaster_PrimalSplit = 60,
	C_DOTA_Ability_Brewmaster_ThunderClap = 61,
	C_DOTA_Ability_Bristleback_QuillSpray = 62,
	C_DOTA_Ability_Bristleback_ViscousNasalGoo = 63,
	C_DOTA_Ability_Broodmother_SpinWeb = 64,
	C_DOTA_Ability_Centaur_HoofStomp = 65,
	CDOTA_Ability_Centaur_Stampede = 66,
	C_DOTA_Ability_ChaosKnight_Phantasm = 67,
	C_DOTA_Ability_ChaosKnight_Reality_Rift = 68,
	C_DOTA_Ability_Chen_HandOfGod = 69,
	C_DOTA_Ability_Chen_HolyPersuasion = 70,
	C_DOTA_Ability_Chen_TestOfFaith = 71,
	C_DOTA_Ability_Chen_TestOfFaithTeleport = 72,
	C_DOTA_Ability_Courier_TakeStashAndTransferItems = 73,
	C_DOTA_Ability_Courier_TakeStashItems = 74,
	C_DOTA_Ability_Courier_TransferItems = 75,
	C_DOTA_Ability_Courier_TransferItems_ToOtherPlayer = 76,
	C_DOTA_Ability_CrystalMaiden_CrystalNova = 77,
	C_DOTA_Ability_CrystalMaiden_FreezingField = 78,
	C_DOTA_Ability_DarkSeer_Surge = 79,
	C_DOTA_Ability_DarkSeer_Vacuum = 80,
	C_DOTA_Ability_DarkWillow_Bedlam = 81,
	C_DOTA_Ability_DarkWillow_BrambleMaze = 82,
	C_DOTA_Ability_DarkWillow_ShadowRealm = 83,
	C_DOTA_Ability_DarkWillow_Terrorize = 84,
	C_DOTA_Ability_DataDriven = 85,
	C_DOTA_Ability_Dazzle_Poison_Touch = 86,
	C_DOTA_Ability_Dazzle_ShadowWave = 87,
	C_DOTA_Ability_Dazzle_Shallow_Grave = 88,
	C_DOTA_Ability_Dazzle_Weave = 89,
	C_DOTA_Ability_DeathProphet_CarrionSwarm = 90,
	C_DOTA_Ability_DeathProphet_Exorcism = 91,
	C_DOTA_Ability_DeathProphet_Silence = 92,
	C_DOTA_Ability_Disruptor_Glimpse = 93,
	C_DOTA_Ability_Disruptor_KineticField = 94,
	C_DOTA_Ability_Disruptor_StaticStorm = 95,
	C_DOTA_Ability_DoomBringer_Devour = 96,
	C_DOTA_Ability_DoomBringer_InfernalBlade = 97,
	C_DOTA_Ability_DragonKnight_BreatheFire = 98,
	C_DOTA_Ability_DrowRanger_Silence = 99,
	C_DOTA_Ability_DrowRanger_WaveOfSilence = 100,
	C_DOTA_Ability_Earthshaker_Aftershock = 101,
	C_DOTA_Ability_Earthshaker_EnchantTotem = 102,
	C_DOTA_Ability_Earthshaker_Fissure = 103,
	C_DOTA_Ability_EarthSpirit_BoulderSmash = 104,
	C_DOTA_Ability_EarthSpirit_GeomagneticGrip = 105,
	CDOTA_Ability_EarthSpirit_Petrify = 106,
	C_DOTA_Ability_EarthSpirit_RollingBoulder = 107,
	C_DOTA_Ability_EarthSpirit_StoneCaller = 108,
	CDOTA_Ability_Elder_Titan_EarthSplitter = 109,
	C_DOTA_Ability_Elder_Titan_NaturalOrder = 110,
	C_DOTA_Ability_Elder_Titan_NaturalOrder_Spirit = 111,
	C_DOTA_Ability_EmberSpirit_Activate_FireRemnant = 112,
	C_DOTA_Ability_EmberSpirit_FireRemnant = 113,
	C_DOTA_Ability_EmberSpirit_SearingChains = 114,
	C_DOTA_Ability_EmberSpirit_SleightOfFist = 115,
	C_DOTA_Ability_Enchantress_Enchant = 116,
	C_DOTA_Ability_Enchantress_Impetus = 117,
	C_DOTA_Ability_Enchantress_NaturesAttendants = 118,
	C_DOTA_Ability_Enchantress_Untouchable = 119,
	C_DOTA_Ability_Enigma_BlackHole = 120,
	C_DOTA_Ability_Enigma_DemonicConversion = 121,
	C_DOTA_Ability_Enigma_MidnightPulse = 122,
	C_DOTA_Ability_FacelessVoid_Chronosphere = 123,
	C_DOTA_Ability_FacelessVoid_TimeDilation = 124,
	C_DOTA_Ability_FacelessVoid_TimeWalk = 125,
	C_DOTA_Ability_Furion_ForceOfNature = 126,
	C_DOTA_Ability_Furion_Sprout = 127,
	C_DOTA_Ability_Furion_Teleportation = 128,
	C_DOTA_Ability_Greevil_Miniboss_Black_BrainSap = 129,
	C_DOTA_Ability_Greevil_Miniboss_Black_Nightmare = 130,
	C_DOTA_Ability_Greevil_Miniboss_Blue_ColdFeet = 131,
	C_DOTA_Ability_Greevil_Miniboss_Blue_IceVortex = 132,
	C_DOTA_Ability_Greevil_Miniboss_Green_LivingArmor = 133,
	C_DOTA_Ability_Greevil_Miniboss_Green_Overgrowth = 134,
	C_DOTA_Ability_Greevil_Miniboss_Orange_DragonSlave = 135,
	C_DOTA_Ability_Greevil_Miniboss_Orange_LightStrikeArray = 136,
	C_DOTA_Ability_Greevil_Miniboss_Purple_PlagueWard = 137,
	C_DOTA_Ability_Greevil_Miniboss_Purple_VenomousGale = 138,
	C_DOTA_Ability_Greevil_Miniboss_Red_Earthshock = 139,
	C_DOTA_Ability_Greevil_Miniboss_Red_Overpower = 140,
	C_DOTA_Ability_Greevil_Miniboss_Sight = 141,
	C_DOTA_Ability_Greevil_Miniboss_White_Degen_Aura = 142,
	C_DOTA_Ability_Greevil_Miniboss_White_Purification = 143,
	C_DOTA_Ability_Greevil_Miniboss_Yellow_IonShell = 144,
	C_DOTA_Ability_Greevil_Miniboss_Yellow_Surge = 145,
	CDOTA_Ability_Gyrocopter_Call_Down = 146,
	C_DOTA_Ability_Gyrocopter_Flak_Cannon = 147,
	C_DOTA_Ability_Gyrocopter_Homing_Missile = 148,
	C_DOTA_Ability_Gyrocopter_Rocket_Barrage = 149,
	C_DOTA_Ability_Healing_Campfire = 150,
	C_DOTA_Ability_Holdout_CullingBlade = 151,
	C_DOTA_Ability_Holdout_GladiatorsUnite = 152,
	C_DOTA_Ability_Holdout_Multishot = 153,
	C_DOTA_Ability_Holdout_Omnislash = 154,
	C_DOTA_Ability_Huskar_Inner_Vitality = 155,
	C_DOTA_Ability_Huskar_Life_Break = 156,
	C_DOTA_Ability_Invoker_Alacrity = 157,
	C_DOTA_Ability_Invoker_AttributeBonus = 158,
	C_DOTA_Ability_Invoker_DeafeningBlast = 159,
	C_DOTA_Ability_Invoker_EMP = 160,
	C_DOTA_Ability_Invoker_GhostWalk = 161,
	C_DOTA_Ability_Invoker_Invoke = 162,
	CDOTA_Ability_Invoker_InvokedBase = 163,
	C_DOTA_Ability_Invoker_SunStrike = 164,
	C_DOTA_Ability_Invoker_Tornado = 165,
	C_DOTA_Ability_Jakiro_DualBreath = 166,
	C_DOTA_Ability_Jakiro_IcePath = 167,
	C_DOTA_Ability_Jakiro_Macropyre = 168,
	C_DOTA_Ability_Juggernaut_BladeFury = 169,
	C_DOTA_Ability_Juggernaut_HealingWard = 170,
	C_DOTA_Ability_Juggernaut_Omnislash = 171,
	C_DOTA_Ability_KeeperOfTheLight_BlindingLight = 172,
	C_DOTA_Ability_KeeperOfTheLight_Illuminate = 173,
	C_DOTA_Ability_KeeperOfTheLight_Recall = 174,
	C_DOTA_Ability_Kunkka_GhostShip = 175,
	C_DOTA_Ability_Kunkka_Tidebringer = 176,
	C_DOTA_Ability_Kunkka_Torrent = 177,
	C_DOTA_Ability_Legion_Commander_MomentOfCourage = 178,
	C_DOTA_Ability_Legion_Commander_OverwhelmingOdds = 179,
	C_DOTA_Ability_Legion_Commander_PressTheAttack = 180,
	C_DOTA_Ability_Leshrac_Diabolic_Edict = 181,
	C_DOTA_Ability_Leshrac_Pulse_Nova = 182,
	C_DOTA_Ability_Leshrac_Split_Earth = 183,
	C_DOTA_Ability_Lich_ChainFrost = 184,
	C_DOTA_Ability_Lich_FrostNova = 185,
	C_DOTA_Ability_Life_Stealer_Infest = 186,
	C_DOTA_Ability_Life_Stealer_Open_Wounds = 187,
	C_DOTA_Ability_Lina_DragonSlave = 188,
	C_DOTA_Ability_Lina_LagunaBlade = 189,
	C_DOTA_Ability_Lina_LightStrikeArray = 190,
	C_DOTA_Ability_Lion_FingerOfDeath = 191,
	C_DOTA_Ability_Lion_Impale = 192,
	C_DOTA_Ability_Lion_ManaDrain = 193,
	C_DOTA_Ability_Lion_Voodoo = 194,
	C_DOTA_Ability_LoneDruid_Rabid = 195,
	C_DOTA_Ability_LoneDruid_SavageRoar = 196,
	C_DOTA_Ability_LoneDruid_SavageRoar_Bear = 197,
	C_DOTA_Ability_LoneDruid_SpiritBear = 198,
	C_DOTA_Ability_LoneDruid_SpiritBear_Entangle = 199,
	C_DOTA_Ability_LoneDruid_SpiritBear_Return = 200,
	C_DOTA_Ability_LoneDruid_TrueForm_BattleCry = 201,
	C_DOTA_Ability_LoneDruid_TrueForm_Druid = 202,
	C_DOTA_Ability_Lua = 203,
	C_DOTA_Ability_Luna_Eclipse = 204,
	C_DOTA_Ability_Luna_LucentBeam = 205,
	C_DOTA_Ability_Luna_LunarBlessing = 206,
	C_DOTA_Ability_Lycan_FeralImpulse = 207,
	C_DOTA_Ability_Lycan_Howl = 208,
	C_DOTA_Ability_Lycan_SummonWolves = 209,
	C_DOTA_Ability_Magnataur_ReversePolarity = 210,
	C_DOTA_Ability_Magnataur_Shockwave = 211,
	C_DOTA_Ability_Magnataur_Skewer = 212,
	C_DOTA_Ability_Medusa_SplitShot = 213,
	C_DOTA_Ability_Meepo_DividedWeStand = 214,
	C_DOTA_Ability_Meepo_Earthbind = 215,
	CDOTA_Ability_Meepo_Poof = 216,
	C_DOTA_Ability_Mirana_Arrow = 217,
	C_DOTA_Ability_Mirana_Leap = 218,
	C_DOTA_Ability_Mirana_MoonlightShadow = 219,
	C_DOTA_Ability_Mirana_Starfall = 220,
	C_DOTA_Ability_MonkeyKing_FurArmy = 221,
	C_DOTA_Ability_MonkeyKing_Spring = 222,
	C_DOTA_Ability_MonkeyKing_TreeDance = 223,
	C_DOTA_Ability_Morphling_AdaptiveStrike_Agi = 224,
	C_DOTA_Ability_Morphling_AdaptiveStrike_Str = 225,
	CDOTA_Ability_Morphling_Hybrid = 226,
	C_DOTA_Ability_Morphling_Replicate = 227,
	C_DOTA_Ability_Morphling_Waveform = 228,
	C_DOTA_Ability_NagaSiren_Ensnare = 229,
	C_DOTA_Ability_NagaSiren_MirrorImage = 230,
	C_DOTA_Ability_NagaSiren_RipTide = 231,
	C_DOTA_Ability_Necrolyte_Death_Pulse = 232,
	C_DOTA_Ability_Necrolyte_ReapersScythe = 233,
	C_DOTA_Ability_Necrolyte_Sadist = 234,
	C_DOTA_Ability_Nevermore_Requiem = 235,
	C_DOTA_Ability_Nevermore_Shadowraze = 236,
	C_DOTA_Ability_Nian_Apocalypse = 237,
	C_DOTA_Ability_Nian_Eruption = 238,
	C_DOTA_Ability_Nian_Frenzy = 239,
	C_DOTA_Ability_Nian_Hurricane = 240,
	C_DOTA_Ability_Nian_Roar = 241,
	C_DOTA_Ability_Nian_Sigils = 242,
	C_DOTA_Ability_Nian_Tail_Swipe = 243,
	C_DOTA_Ability_Nian_Waterball = 244,
	C_DOTA_Ability_Nian_Whirlpool = 245,
	C_DOTA_Ability_NightStalker_CripplingFear = 246,
	C_DOTA_Ability_NightStalker_HunterInTheNight = 247,
	CDOTA_Ability_Nyx_Assassin_Burrow = 248,
	C_DOTA_Ability_Nyx_Assassin_Impale = 249,
	CDOTA_Ability_Nyx_Assassin_ManaBurn = 250,
	C_DOTA_Ability_Obsidian_Destroyer_ArcaneOrb = 251,
	C_DOTA_Ability_Obsidian_Destroyer_AstralImprisonment = 252,
	C_DOTA_Ability_Obsidian_Destroyer_SanityEclipse = 253,
	C_DOTA_Ability_Ogre_Magi_Bloodlust = 254,
	C_DOTA_Ability_Ogre_Magi_Fireblast = 255,
	C_DOTA_Ability_Ogre_Magi_Ignite = 256,
	C_DOTA_Ability_Ogre_Magi_Multicast = 257,
	C_DOTA_Ability_Ogre_Magi_Unrefined_Fireblast = 258,
	C_DOTA_Ability_Omniknight_GuardianAngel = 259,
	C_DOTA_Ability_Omniknight_Purification = 260,
	C_DOTA_Ability_Oracle_FatesEdict = 261,
	C_DOTA_Ability_Oracle_FortunesEnd = 262,
	C_DOTA_Ability_Oracle_PurifyingFlames = 263,
	C_DOTA_Ability_Pangolier_Gyroshell = 264,
	C_DOTA_Ability_Pangolier_GyroshellStop = 265,
	C_DOTA_Ability_Pangolier_ShieldCrash = 266,
	C_DOTA_Ability_Pangolier_Swashbuckle = 267,
	C_DOTA_Ability_PhantomAssassin_PhantomStrike = 268,
	C_DOTA_Ability_PhantomLancer_Doppelwalk = 269,
	C_DOTA_Ability_PhantomLancer_SpiritLance = 270,
	C_DOTA_Ability_Phoenix_LaunchFireSpirit = 271,
	C_DOTA_Ability_Phoenix_Supernova = 272,
	C_DOTA_Ability_Puck_DreamCoil = 273,
	C_DOTA_Ability_Puck_IllusoryOrb = 274,
	C_DOTA_Ability_Puck_WaningRift = 275,
	CDOTA_Ability_Pudge_Dismember = 276,
	C_DOTA_Ability_Pudge_FleshHeap = 277,
	CDOTA_Ability_Pudge_MeatHook = 278,
	C_DOTA_Ability_Pudge_Rot = 279,
	C_DOTA_Ability_Pugna_Decrepify = 280,
	C_DOTA_Ability_Pugna_LifeDrain = 281,
	C_DOTA_Ability_Pugna_NetherBlast = 282,
	C_DOTA_Ability_Pugna_NetherWard = 283,
	C_DOTA_Ability_QueenOfPain_Blink = 284,
	C_DOTA_Ability_QueenOfPain_ScreamOfPain = 285,
	C_DOTA_Ability_QueenOfPain_ShadowStrike = 286,
	C_DOTA_Ability_QueenOfPain_SonicWave = 287,
	C_DOTA_Ability_Rattletrap_BatteryAssault = 288,
	C_DOTA_Ability_Rattletrap_Hookshot = 289,
	C_DOTA_Ability_Rattletrap_PowerCogs = 290,
	C_DOTA_Ability_Rattletrap_RocketFlare = 291,
	C_DOTA_Ability_Razor_EyeOfTheStorm = 292,
	C_DOTA_Ability_Razor_PlasmaField = 293,
	C_DOTA_Ability_Razor_UnstableCurrent = 294,
	C_DOTA_Ability_Riki_BlinkStrike = 295,
	C_DOTA_Ability_Riki_SmokeScreen = 296,
	C_DOTA_Ability_Riki_TricksOfTheTrade = 297,
	C_DOTA_Ability_Rubick_NullField = 298,
	C_DOTA_Ability_Rubick_SpellSteal = 299,
	C_DOTA_Ability_Rubick_Telekinesis = 300,
	C_DOTA_Ability_Rubick_TelekinesisLand = 301,
	C_DOTA_Ability_SandKing_BurrowStrike = 302,
	C_DOTA_Ability_SandKing_Epicenter = 303,
	C_DOTA_Ability_SandKing_SandStorm = 304,
	C_DOTA_Ability_SatyrTrickster_Purge = 305,
	C_DOTA_Ability_Shadow_Demon_Disruption = 306,
	C_DOTA_Ability_Shadow_Demon_Shadow_Poison = 307,
	C_DOTA_Ability_Shadow_Demon_Soul_Catcher = 308,
	C_DOTA_Ability_ShadowShaman_Shackles = 309,
	C_DOTA_Ability_ShadowShamanVoodoo = 310,
	C_DOTA_Ability_Shredder_Chakram = 311,
	C_DOTA_Ability_Shredder_TimberChain = 312,
	C_DOTA_Ability_Silencer_CurseOfTheSilent = 313,
	C_DOTA_Ability_Silencer_GlaivesOfWisdom = 314,
	C_DOTA_Ability_Silencer_GlobalSilence = 315,
	C_DOTA_Ability_SkeletonKing_Reincarnation = 316,
	C_DOTA_Ability_SkeletonKing_VampiricAura = 317,
	C_DOTA_Ability_Skywrath_Mage_Ancient_Seal = 318,
	C_DOTA_Ability_Skywrath_Mage_Mystic_Flare = 319,
	C_DOTA_Ability_Slardar_Amplify_Damage = 320,
	C_DOTA_Ability_Slardar_Slithereen_Crush = 321,
	C_DOTA_Ability_Slark_EssenceShift = 322,
	C_DOTA_Ability_Slark_Pounce = 323,
	C_DOTA_Ability_Slark_ShadowDance = 324,
	C_DOTA_Ability_Sniper_Assassinate = 325,
	C_DOTA_Ability_Sniper_Shrapnel = 326,
	C_DOTA_Ability_Spawnlord_Master_Freeze = 327,
	C_DOTA_Ability_Spectre_Desolate = 328,
	C_DOTA_Ability_Spectre_Dispersion = 329,
	C_DOTA_Ability_Spectre_SpectralDagger = 330,
	C_DOTA_Ability_SpiritBreaker_EmpoweringHaste = 331,
	C_DOTA_Ability_SpiritBreaker_NetherStrike = 332,
	C_DOTA_Ability_StormSpirit_BallLightning = 333,
	C_DOTA_Ability_StormSpirit_ElectricVortex = 334,
	C_DOTA_Ability_StormSpirit_StaticRemnant = 335,
	C_DOTA_Ability_Sven_StormBolt = 336,
	C_DOTA_Ability_Sven_Warcry = 337,
	C_DOTA_Ability_Techies_FocusedDetonate = 338,
	CDOTA_Ability_Techies_LandMines = 339,
	CDOTA_Ability_Techies_Minefield_Sign = 340,
	CDOTA_Ability_Techies_RemoteMines = 341,
	CDOTA_Ability_Techies_RemoteMines_SelfDetonate = 342,
	CDOTA_Ability_Techies_StasisTrap = 343,
	C_DOTA_Ability_Techies_Suicide = 344,
	C_DOTA_Ability_Terrorblade_ConjureImage = 345,
	C_DOTA_Ability_Terrorblade_Reflection = 346,
	C_DOTA_Ability_Terrorblade_Sunder = 347,
	C_DOTA_Ability_Throw_Coal = 348,
	C_DOTA_Ability_Throw_Snowball = 349,
	C_DOTA_Ability_Tidehunter_AnchorSmash = 350,
	C_DOTA_Ability_Tidehunter_Gush = 351,
	C_DOTA_Ability_Tidehunter_Ravage = 352,
	C_DOTA_Ability_Tiny_Avalanche = 353,
	C_DOTA_Ability_Tiny_CraggyExterior = 354,
	C_DOTA_Ability_Tiny_Toss = 355,
	CDOTA_Ability_Treant_EyesInTheForest = 356,
	C_DOTA_Ability_Treant_LivingArmor = 357,
	C_DOTA_Ability_Treant_Overgrowth = 358,
	C_DOTA_Ability_TrollWarlord_BerserkersRage = 359,
	C_DOTA_Ability_TrollWarlord_Whirling_Axes_Melee = 360,
	C_DOTA_Ability_TrollWarlord_WhirlingAxes_Ranged = 361,
	C_DOTA_Ability_Tusk_FrozenSigil = 362,
	CDOTA_Ability_Tusk_WalrusKick = 363,
	C_DOTA_Ability_Tusk_WalrusPunch = 364,
	C_DOTA_Ability_Undying_Decay = 365,
	C_DOTA_Ability_Undying_FleshGolem = 366,
	C_DOTA_Ability_Undying_SoulRip = 367,
	C_DOTA_Ability_Ursa_Earthshock = 368,
	C_DOTA_Ability_Ursa_Enrage = 369,
	C_DOTA_Ability_VengefulSpirit_Magic_Missile = 370,
	C_DOTA_Ability_VengefulSpirit_Nether_Swap = 371,
	C_DOTA_Ability_VengefulSpirit_WaveOfTerror = 372,
	C_DOTA_Ability_Venomancer_PlagueWard = 373,
	C_DOTA_Ability_Venomancer_PoisonNova = 374,
	C_DOTA_Ability_Venomancer_VenomousGale = 375,
	C_DOTA_Ability_Viper_CorrosiveSkin = 376,
	CDOTA_Ability_Viper_Nethertoxin = 377,
	C_DOTA_Ability_Viper_PoisonAttack = 378,
	C_DOTA_Ability_Viper_ViperStrike = 379,
	C_DOTA_Ability_Visage_Stone_Form_Self_Cast = 380,
	C_DOTA_Ability_Visage_SummonFamiliars = 381,
	C_DOTA_Ability_Visage_SummonFamiliars_StoneForm = 382,
	C_DOTA_Ability_Warlock_RainOfChaos = 383,
	C_DOTA_Ability_Warlock_Shadow_Word = 384,
	C_DOTA_Ability_Warlock_Upheaval = 385,
	C_DOTA_Ability_Weaver_Shukuchi = 386,
	C_DOTA_Ability_Weaver_TheSwarm = 387,
	C_DOTA_Ability_Weaver_TimeLapse = 388,
	C_DOTA_Ability_Windrunner_FocusFire = 389,
	C_DOTA_Ability_Windrunner_Powershot = 390,
	C_DOTA_Ability_Windrunner_Windrun = 391,
	CDOTA_Ability_Winter_Wyvern_Arctic_Burn = 392,
	CDOTA_Ability_Winter_Wyvern_Cold_Embrace = 393,
	CDOTA_Ability_Winter_Wyvern_Splinter_Blast = 394,
	CDOTA_Ability_Winter_Wyvern_Winters_Curse = 395,
	C_DOTA_Ability_Wisp_Overcharge = 396,
	C_DOTA_Ability_Wisp_Relocate = 397,
	C_DOTA_Ability_Wisp_Spirits = 398,
	C_DOTA_Ability_Wisp_Tether = 399,
	C_DOTA_Ability_WitchDoctor_Maledict = 400,
	C_DOTA_Ability_WitchDoctor_ParalyzingCask = 401,
	C_DOTA_Ability_WitchDoctor_VoodooRestoration = 402,
	C_DOTA_Ability_Zuus_Cloud = 403,
	C_DOTA_Ability_Zuus_LightningBolt = 404,
	C_DOTA_BaseNPC = 405,
	C_DOTA_BaseNPC_Additive = 406,
	C_DOTA_BaseNPC_Barracks = 407,
	C_DOTA_BaseNPC_Building = 408,
	C_DOTA_BaseNPC_Creature = 409,
	C_DOTA_BaseNPC_Creep = 410,
	C_DOTA_BaseNPC_Creep_Lane = 411,
	C_DOTA_BaseNPC_Creep_Neutral = 412,
	C_DOTA_BaseNPC_Creep_Siege = 413,
	C_DOTA_BaseNPC_Creep_Talking = 414,
	C_DOTA_BaseNPC_Effigy_BattleCup = 415,
	C_DOTA_BaseNPC_Effigy_Statue = 416,
	C_DOTA_BaseNPC_Filler = 417,
	C_DOTA_BaseNPC_Fort = 418,
	C_DOTA_BaseNPC_HallofFame = 419,
	C_DOTA_BaseNPC_Healer = 420,
	C_DOTA_BaseNPC_Hero = 421,
	C_DOTA_BaseNPC_HoldoutTower = 422,
	C_DOTA_BaseNPC_HoldoutTower_HeavySlow = 423,
	C_DOTA_BaseNPC_HoldoutTower_LightFast = 424,
	C_DOTA_BaseNPC_HoldoutTower_ReduceSpeed = 425,
	C_DOTA_BaseNPC_Invoker_Forged_Spirit = 426,
	C_DOTA_BaseNPC_SDKTower = 427,
	C_DOTA_BaseNPC_ShadowShaman_SerpentWard = 428,
	C_DOTA_BaseNPC_Shop = 429,
	C_DOTA_BaseNPC_Tower = 430,
	C_DOTA_BaseNPC_Trap_Ward = 431,
	C_DOTA_BaseNPC_Tusk_Sigil = 432,
	C_DOTA_BaseNPC_Venomancer_PlagueWard = 433,
	C_DOTA_BaseNPC_Warlock_Golem = 434,
	C_DOTA_Beastmaster_Axe = 435,
	C_DOTA_DarkWillow_Creature = 436,
	C_DOTA_DataCustomTeam = 437,
	C_DOTA_DataDire = 438,
	C_DOTA_DataNonSpectator = 439,
	C_DOTA_DataRadiant = 440,
	C_DOTA_DataSpectator = 441,
	C_DOTA_DeathProphet_Exorcism_Spirit = 442,
	C_DOTA_DisplacementVisibility = 443,
	C_DOTA_Hero_Recorder = 444,
	C_DOTA_Item = 445,
	C_DOTA_Item_Aether_Lens = 446,
	C_DOTA_Item_Ancient_Janggo = 447,
	C_DOTA_Item_Arcane_Boots = 448,
	C_DOTA_Item_Armlet = 449,
	CDOTA_Item_Battlefury = 450,
	C_DOTA_Item_BlinkDagger = 451,
	C_DOTA_Item_Bloodstone = 452,
	C_DOTA_Item_BootsOfTravel = 453,
	CDOTA_Item_BootsOfTravel_2 = 454,
	C_DOTA_Item_Buckler = 455,
	C_DOTA_Item_Crimson_Guard = 456,
	C_DOTA_Item_Cyclone = 457,
	C_DOTA_Item_DataDriven = 458,
	C_DOTA_Item_DeathGoldDropped = 459,
	C_DOTA_Item_Diffusal_Blade = 460,
	C_DOTA_Item_Diffusal_Blade_Level2 = 461,
	C_DOTA_Item_EmptyBottle = 462,
	C_DOTA_Item_Ethereal_Blade = 463,
	CDOTA_Item_ForceStaff = 464,
	C_DOTA_Item_GemOfTrueSight = 465,
	CDOTA_Item_GlimmerCape = 466,
	CDOTA_Item_Guardian_Greaves = 467,
	CDOTA_Item_Hurricane_Pike = 468,
	C_DOTA_Item_Iron_Talon = 469,
	C_DOTA_Item_Lua = 470,
	C_DOTA_Item_MantaStyle = 471,
	CDOTA_Item_Medallion_Of_Courage = 472,
	C_DOTA_Item_Mekansm = 473,
	C_DOTA_Item_MeteorHammer = 474,
	CDOTA_Item_Moonshard = 475,
	C_DOTA_Item_Necronomicon = 476,
	C_DOTA_Item_Necronomicon_Level2 = 477,
	C_DOTA_Item_Necronomicon_Level3 = 478,
	C_DOTA_Item_Nian_Flag_Trap = 479,
	C_DOTA_Item_Nullifier = 480,
	CDOTA_Item_ObserverWard = 481,
	C_DOTA_Item_Physical = 482,
	C_DOTA_Item_Pipe = 483,
	C_DOTA_Item_PowerTreads = 484,
	C_DOTA_Item_QuellingBlade = 485,
	C_DOTA_Item_Radiance = 486,
	CDOTA_Item_Recipe_Guardian_Greaves = 487,
	C_DOTA_Item_Recipe_Veil_Of_Discord = 488,
	C_DOTA_Item_Ring_Of_Basilius = 489,
	C_DOTA_Item_RingOfAquila = 490,
	C_DOTA_Item_Rune = 491,
	C_DOTA_Item_RuneSpawner = 492,
	C_DOTA_Item_RuneSpawner_Bounty = 493,
	C_DOTA_Item_RuneSpawner_Powerup = 494,
	CDOTA_Item_SentryWard = 495,
	C_DOTA_Item_Shivas_Guard = 496,
	C_DOTA_Item_Smoke_Of_Deceit = 497,
	CDOTA_Item_Solar_Crest = 498,
	C_DOTA_Item_Spirit_Vessel = 499,
	C_DOTA_Item_Tango = 500,
	C_DOTA_Item_Tango_Single = 501,
	C_DOTA_Item_TeleportScroll = 502,
	C_DOTA_Item_Tome_Of_Knowledge = 503,
	C_DOTA_Item_TranquilBoots = 504,
	C_DOTA_Item_TranquilBoots2 = 505,
	C_DOTA_Item_UltimateScepter = 506,
	C_DOTA_Item_Urn_Of_Shadows = 507,
	C_DOTA_Item_Veil_Of_Discord = 508,
	C_DOTA_Item_Vladmir = 509,
	CDOTA_Item_Ward_Dispenser = 510,
	C_DOTA_NeutralSpawner = 511,
	C_DOTA_NPC_DataDriven = 512,
	CDOTA_NPC_Observer_Ward = 513,
	CDOTA_NPC_Observer_Ward_TrueSight = 514,
	C_DOTA_NPC_Techies_Minefield_Sign = 515,
	C_DOTA_NPC_TechiesMines = 516,
	C_DOTA_NPC_Treant_EyesInTheForest = 517,
	C_DOTA_NPC_WitchDoctor_Ward = 518,
	C_DOTA_PhantomAssassin_Gravestone = 519,
	C_DOTA_PlayerResource = 520,
	C_DOTA_RoshanSpawner = 521,
	C_DOTA_SimpleObstruction = 522,
	C_DOTA_TempTree = 523,
	C_DOTA_Tiny_ScepterTree = 524,
	CDOTA_Unit_Announcer = 525,
	CDOTA_Unit_Announcer_Killing_Spree = 526,
	C_DOTA_Unit_Brewmaster_PrimalEarth = 527,
	C_DOTA_Unit_Brewmaster_PrimalFire = 528,
	C_DOTA_Unit_Brewmaster_PrimalStorm = 529,
	C_DOTA_Unit_Broodmother_Spiderling = 530,
	C_DOTA_Unit_Broodmother_Web = 531,
	C_DOTA_Unit_Courier = 532,
	C_DOTA_Unit_Earth_Spirit_Stone = 533,
	CDOTA_Unit_Elder_Titan_AncestralSpirit = 534,
	C_DOTA_Unit_Fountain = 535,
	CDOTA_Unit_Hero_Abaddon = 536,
	CDOTA_Unit_Hero_AbyssalUnderlord = 537,
	CDOTA_Unit_Hero_Alchemist = 538,
	CDOTA_Unit_Hero_AncientApparition = 539,
	C_DOTA_Unit_Hero_AntiMage = 540,
	CDOTA_Unit_Hero_ArcWarden = 541,
	C_DOTA_Unit_Hero_Axe = 542,
	C_DOTA_Unit_Hero_Bane = 543,
	C_DOTA_Unit_Hero_Batrider = 544,
	C_DOTA_Unit_Hero_Beastmaster = 545,
	C_DOTA_Unit_Hero_Beastmaster_Beasts = 546,
	C_DOTA_Unit_Hero_Beastmaster_Boar = 547,
	C_DOTA_Unit_Hero_Beastmaster_Hawk = 548,
	C_DOTA_Unit_Hero_Bloodseeker = 549,
	C_DOTA_Unit_Hero_BountyHunter = 550,
	C_DOTA_Unit_Hero_Brewmaster = 551,
	C_DOTA_Unit_Hero_Bristleback = 552,
	C_DOTA_Unit_Hero_Broodmother = 553,
	CDOTA_Unit_Hero_Centaur = 554,
	C_DOTA_Unit_Hero_ChaosKnight = 555,
	C_DOTA_Unit_Hero_Chen = 556,
	C_DOTA_Unit_Hero_Clinkz = 557,
	C_DOTA_Unit_Hero_CrystalMaiden = 558,
	C_DOTA_Unit_Hero_DarkSeer = 559,
	C_DOTA_Unit_Hero_DarkWillow = 560,
	C_DOTA_Unit_Hero_Dazzle = 561,
	C_DOTA_Unit_Hero_DeathProphet = 562,
	C_DOTA_Unit_Hero_Disruptor = 563,
	C_DOTA_Unit_Hero_DoomBringer = 564,
	C_DOTA_Unit_Hero_DragonKnight = 565,
	C_DOTA_Unit_Hero_DrowRanger = 566,
	C_DOTA_Unit_Hero_Earthshaker = 567,
	C_DOTA_Unit_Hero_EarthSpirit = 568,
	CDOTA_Unit_Hero_Elder_Titan = 569,
	C_DOTA_Unit_Hero_EmberSpirit = 570,
	C_DOTA_Unit_Hero_Enchantress = 571,
	C_DOTA_Unit_Hero_Enigma = 572,
	C_DOTA_Unit_Hero_FacelessVoid = 573,
	C_DOTA_Unit_Hero_Furion = 574,
	CDOTA_Unit_Hero_Gyrocopter = 575,
	C_DOTA_Unit_Hero_Huskar = 576,
	C_DOTA_Unit_Hero_Invoker = 577,
	C_DOTA_Unit_Hero_Jakiro = 578,
	C_DOTA_Unit_Hero_Juggernaut = 579,
	C_DOTA_Unit_Hero_KeeperOfTheLight = 580,
	C_DOTA_Unit_Hero_Kunkka = 581,
	C_DOTA_Unit_Hero_Legion_Commander = 582,
	C_DOTA_Unit_Hero_Leshrac = 583,
	C_DOTA_Unit_Hero_Lich = 584,
	C_DOTA_Unit_Hero_Life_Stealer = 585,
	C_DOTA_Unit_Hero_Lina = 586,
	C_DOTA_Unit_Hero_Lion = 587,
	C_DOTA_Unit_Hero_LoneDruid = 588,
	C_DOTA_Unit_Hero_Luna = 589,
	C_DOTA_Unit_Hero_Lycan = 590,
	C_DOTA_Unit_Hero_Magnataur = 591,
	C_DOTA_Unit_Hero_Medusa = 592,
	C_DOTA_Unit_Hero_Meepo = 593,
	C_DOTA_Unit_Hero_Mirana = 594,
	C_DOTA_Unit_Hero_MonkeyKing = 595,
	C_DOTA_Unit_Hero_Morphling = 596,
	C_DOTA_Unit_Hero_Naga_Siren = 597,
	C_DOTA_Unit_Hero_Necrolyte = 598,
	C_DOTA_Unit_Hero_Nevermore = 599,
	C_DOTA_Unit_Hero_NightStalker = 600,
	C_DOTA_Unit_Hero_Nyx_Assassin = 601,
	C_DOTA_Unit_Hero_Obsidian_Destroyer = 602,
	C_DOTA_Unit_Hero_Ogre_Magi = 603,
	C_DOTA_Unit_Hero_Omniknight = 604,
	C_DOTA_Unit_Hero_Oracle = 605,
	C_DOTA_Unit_Hero_Pangolier = 606,
	C_DOTA_Unit_Hero_PhantomAssassin = 607,
	C_DOTA_Unit_Hero_PhantomLancer = 608,
	C_DOTA_Unit_Hero_Phoenix = 609,
	C_DOTA_Unit_Hero_Puck = 610,
	C_DOTA_Unit_Hero_Pudge = 611,
	C_DOTA_Unit_Hero_Pugna = 612,
	C_DOTA_Unit_Hero_QueenOfPain = 613,
	C_DOTA_Unit_Hero_Rattletrap = 614,
	C_DOTA_Unit_Hero_Razor = 615,
	C_DOTA_Unit_Hero_Riki = 616,
	C_DOTA_Unit_Hero_Rubick = 617,
	C_DOTA_Unit_Hero_SandKing = 618,
	C_DOTA_Unit_Hero_Shadow_Demon = 619,
	C_DOTA_Unit_Hero_ShadowShaman = 620,
	C_DOTA_Unit_Hero_Shredder = 621,
	C_DOTA_Unit_Hero_Silencer = 622,
	C_DOTA_Unit_Hero_SkeletonKing = 623,
	C_DOTA_Unit_Hero_Skywrath_Mage = 624,
	C_DOTA_Unit_Hero_Slardar = 625,
	C_DOTA_Unit_Hero_Slark = 626,
	C_DOTA_Unit_Hero_Sniper = 627,
	C_DOTA_Unit_Hero_Spectre = 628,
	C_DOTA_Unit_Hero_SpiritBreaker = 629,
	C_DOTA_Unit_Hero_StormSpirit = 630,
	C_DOTA_Unit_Hero_Sven = 631,
	C_DOTA_Unit_Hero_Techies = 632,
	C_DOTA_Unit_Hero_TemplarAssassin = 633,
	C_DOTA_Unit_Hero_Terrorblade = 634,
	C_DOTA_Unit_Hero_Tidehunter = 635,
	C_DOTA_Unit_Hero_Tinker = 636,
	C_DOTA_Unit_Hero_Tiny = 637,
	C_DOTA_Unit_Hero_Treant = 638,
	C_DOTA_Unit_Hero_TrollWarlord = 639,
	C_DOTA_Unit_Hero_Tusk = 640,
	C_DOTA_Unit_Hero_Undying = 641,
	C_DOTA_Unit_Hero_Ursa = 642,
	C_DOTA_Unit_Hero_VengefulSpirit = 643,
	C_DOTA_Unit_Hero_Venomancer = 644,
	C_DOTA_Unit_Hero_Viper = 645,
	C_DOTA_Unit_Hero_Visage = 646,
	C_DOTA_Unit_Hero_Warlock = 647,
	C_DOTA_Unit_Hero_Weaver = 648,
	C_DOTA_Unit_Hero_Windrunner = 649,
	C_DOTA_Unit_Hero_Winter_Wyvern = 650,
	C_DOTA_Unit_Hero_Wisp = 651,
	C_DOTA_Unit_Hero_WitchDoctor = 652,
	C_DOTA_Unit_Hero_Zuus = 653,
	C_DOTA_Unit_LoopingSound = 654,
	C_DOTA_Unit_Nian = 655,
	C_DOTA_Unit_Roshan = 656,
	C_DOTA_Unit_SpiritBear = 657,
	C_DOTA_Unit_TargetDummy = 658,
	C_DOTA_Unit_Undying_Tombstone = 659,
	C_DOTA_Unit_Undying_Zombie = 660,
	C_DOTA_Unit_VisageFamiliar = 661,
	C_DOTA_Unit_ZeusCloud = 662,
	C_DOTA_Wisp_Spirit = 663,
	C_DOTAAbilityDraftGameMode = 664,
	C_DOTABaseAbility = 665,
	C_DOTABaseCustomHeroPickRules = 666,
	C_DOTABaseGameMode = 667,
	C_DOTACameraBounds = 668,
	C_DOTAFogOfWarTempViewers = 669,
	C_DOTAGameManagerProxy = 670,
	C_DOTAGamerulesProxy = 671,
	C_DOTAHoldoutNetworker = 672,
	CDOTAInGamePredictionState = 673,
	C_DOTAMinimapBoundary = 677,
	C_DOTAMutationGameMode = 674,
	C_DOTAPlayer = 675,
	C_DOTAPropCustomTexture = 676,
	C_DotaQuest = 677,
	C_DotaQuestBase = 678,
	C_DOTASpecGraphPlayerData = 679,
	C_DOTASpectatorGraphManagerProxy = 680,
	C_DotaSubquestBase = 681,
	C_DOTATeam = 682,
	C_DOTATurboGameMode = 683,
	C_DOTATurboHeroPickRules = 684,
	C_DotaTutorialNetworker = 685,
	C_DOTAWearableItem = 686,
	C_DynamicLight = 687,
	C_DynamicProp = 688,
	C_EconEntity = 689,
	C_EconWearable = 690,
	C_EntityDissolve = 691,
	C_EntityFlame = 692,
	C_EnvClock = 693,
	C_EnvCombinedLightProbeVolume = 694,
	C_EnvCubemap = 695,
	C_EnvCubemapBox = 696,
	C_EnvDeferredLight = 697,
	C_EnvDetailController = 698,
	C_EnvDOFController = 699,
	C_EnvLightProbeVolume = 700,
	C_EnvProjectedTexture = 701,
	C_EnvScreenEffect = 702,
	C_EnvScreenOverlay = 703,
	C_EnvSky = 704,
	C_EnvVolumetricFogController = 705,
	C_EnvWind = 706,
	C_FireSmoke = 707,
	C_Fish = 708,
	C_FogController = 709,
	C_Func_Dust = 710,
	C_Func_LOD = 711,
	C_FuncAreaPortalWindow = 712,
	C_FuncBrush = 713,
	C_FuncCombineBarrier = 714,
	C_FuncConveyor = 715,
	C_FuncDistanceOccluder = 716,
	C_FuncLadder = 717,
	C_FuncMonitor = 718,
	C_FuncMoveLinear = 719,
	C_FuncOccluder = 720,
	C_FuncRotating = 721,
	C_FuncTrackTrain = 722,
	C_GameRulesProxy = 723,
	C_GenericFlexCycler = 724,
	C_HandleTest = 725,
	C_InfoLadderDismount = 726,
	C_InfoOverlayAccessor = 727,
	C_InfoPlayerStartBadGuys = 728,
	C_InfoPlayerStartDota = 729,
	C_InfoPlayerStartGoodGuys = 730,
	CInfoWorldLayer = 731,
	C_IngameEvent_Base = 732,
	C_IngameEvent_DotaPlus = 733,
	C_IngameEvent_DotaPrime = 734,
	C_IngameEvent_FM2015 = 735,
	C_IngameEvent_FM2016 = 736,
	C_IngameEvent_TI6 = 737,
	C_IngameEvent_TI7 = 738,
	C_IngameEvent_TI8 = 739,
	C_IngameEvent_WM2016 = 740,
	C_IngameEvent_WM2017 = 741,
	C_LightDirectionalEntity = 742,
	C_LightEntity = 743,
	C_LightEnvironmentEntity = 744,
	C_LightGlow = 745,
	C_LightOrthoEntity = 746,
	C_LightSpotEntity = 747,
	C_MaterialModifyControl = 748,
	C_ModelPointEntity = 749,
	C_ParticlePerformanceMonitor = 750,
	C_ParticleSystem = 751,
	C_PhysBox = 752,
	C_PhysBoxMultiplayer = 753,
	C_PhysicsProp = 754,
	C_PhysMagnet = 755,
	C_PlayerResource = 757,
	C_PointCamera = 758,
	C_PointClientUIDialog = 759,
	C_PointClientUIHUD = 763,
	C_PointClientUIWorldPanel = 760,
	C_PointClientUIWorldTextPanel = 761,
	C_PointEntity = 763,
	C_PointHMDAnchor = 764,
	C_PointHMDAnchorOverride = 765,
	C_PointValueRemapper = 766,
	C_PointWorldText = 767,
	C_PoseController = 768,
	C_PostProcessController = 769,
	C_PostProcessingVolume = 770,
	CClient_Precipitation = 771,
	C_PrecipitationBlocker = 772,
	C_PropHMDAvatar = 773,
	C_PropJeep = 777,
	C_PropVehicleChoreoGeneric = 778,
	C_PropVehicleDriveable = 774,
	C_PropVRHand = 775,
	C_PropVRTrackedObject = 776,
	C_PropZipline = 777,
	C_RagdollManager = 778,
	C_ServerRagdoll = 779,
	C_ServerRagdollAttached = 780,
	C_RopeKeyframe = 781,
	C_SceneEntity = 782,
	C_ShadowControl = 783,
	C_SkyCamera = 784,
	C_SlideshowDisplay = 790,
	C_SpeechBubbleManager = 785,
	C_SpotlightEnd = 786,
	C_Sprite = 787,
	C_SpriteOriented = 788,
	C_Sun = 789,
	C_Team = 790,
	C_TeamplayRoundBasedRulesProxy = 797,
	C_TeamRoundTimer = 798,
	C_TestTraceline = 791,
	C_TFWearableItem = 792,
	C_TonemapController2 = 793,
	C_TriggerCamera = 794,
	C_TriggerPlayerMovement = 795,
	C_VRHandModelOverride = 797,
	C_WaterBullet = 798,
	C_World = 799,
	C_NextBotCombatCharacter = 800,
};

#define FL_ONGROUND				(1<<0)	// At rest / on the ground
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define FL_WATERJUMP			(1<<2)	// player jumping out of water
#define FL_ONTRAIN				(1<<3)	// Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<4)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<5)	// Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<6)	// Player can't move, but keeps key inputs for controlling another entity
#define FL_CLIENT				(1<<7)	// Is a player
#define FL_FAKECLIENT			(1<<8)	// Fake client, simulated server side; don't send network messages to them
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define FL_INWATER				(1<<9)	// In water

#define CONTENTS_EMPTY			0		// No contents

#define CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define CONTENTS_AUX			0x4
#define CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define CONTENTS_SLIME			0x10
#define CONTENTS_WATER			0x20
#define CONTENTS_BLOCKLOS		0x40	// block AI line of sight
#define CONTENTS_OPAQUE			0x80	// things that cannot be seen through (may be non-solid though)
#define LAST_VISIBLE_CONTENTS	CONTENTS_OPAQUE

#define ALL_VISIBLE_CONTENTS (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED			0x200

// unused
// NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS
// if not visible, then grab from the bottom.
// CONTENTS_OPAQUE + SURF_NODRAW count as CONTENTS_OPAQUE (shadow-casting toolsblocklight textures)
#define CONTENTS_BLOCKLIGHT		0x400

#define CONTENTS_TEAM1			0x800	// per team contents used to differentiate collisions
#define CONTENTS_TEAM2			0x1000	// between players and objects on different teams

// ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
#define CONTENTS_MOVEABLE		0x4000

// remaining contents are non-visible, and don't eat brushes
#define CONTENTS_AREAPORTAL		0x8000

#define CONTENTS_PLAYERCLIP		0x10000
#define CONTENTS_MONSTERCLIP	0x20000

// currents can be added to any other contents, and may be mixed
#define CONTENTS_CURRENT_0		0x40000
#define CONTENTS_CURRENT_90		0x80000
#define CONTENTS_CURRENT_180	0x100000
#define CONTENTS_CURRENT_270	0x200000
#define CONTENTS_CURRENT_UP		0x400000
#define CONTENTS_CURRENT_DOWN	0x800000

#define CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define CONTENTS_DEBRIS			0x4000000
#define CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace

#define MASK_SHOT	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)

// These are given to FindMaterial to reference the texture groups that show up on the
#define TEXTURE_GROUP_LIGHTMAP						"Lightmaps"
#define TEXTURE_GROUP_WORLD							"World textures"
#define TEXTURE_GROUP_MODEL							"Model textures"
#define TEXTURE_GROUP_VGUI							"VGUI textures"
#define TEXTURE_GROUP_PARTICLE						"Particle textures"
#define TEXTURE_GROUP_DECAL							"Decal textures"
#define TEXTURE_GROUP_SKYBOX						"SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				"ClientEffect textures"
#define TEXTURE_GROUP_OTHER							"Other textures"
#define TEXTURE_GROUP_PRECACHED						"Precached"
#define TEXTURE_GROUP_CUBE_MAP						"CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					"RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					"Unaccounted textures"	// Textures that weren't assigned a texture group.
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			"Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			"Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			"Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					"DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					"ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					"Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				"Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			"RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					"Morph Targets"

#define MAXSTUDIOBONES 128
#define BONE_USED_BY_HITBOX 0x100

// NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
#define SURF_LIGHT		0x0001		// value will hold the light strength
#define SURF_SKY2D		0x0002		// don't draw, indicates we should skylight + draw 2d sky but not draw the 3D skybox
#define SURF_SKY		0x0004		// don't draw, but add to skybox
#define SURF_WARP		0x0008		// turbulent water warp
#define SURF_TRANS		0x0010
#define SURF_NOPORTAL	0x0020	// the surface can not have a portal placed on it
#define SURF_TRIGGER	0x0040	// FIXME: This is an xbox hack to work around elimination of trigger surfaces, which breaks occluders
#define SURF_NODRAW		0x0080	// don't bother referencing the texture

#define SURF_HINT		0x0100	// make a primary bsp splitter

#define SURF_SKIP		0x0200	// completely ignore, allowing non-closed brushes
#define SURF_NOLIGHT	0x0400	// Don't calculate light
#define SURF_BUMPLIGHT	0x0800	// calculate three lightmaps for the surface for bumpmapping
#define SURF_NOSHADOWS	0x1000	// Don't receive shadows
#define SURF_NODECALS	0x2000	// Don't receive decals
#define SURF_NOPAINT	SURF_NODECALS	// the surface can not have paint placed on it
#define SURF_NOCHOP		0x4000	// Don't subdivide patches on this surface
#define SURF_HITBOX		0x8000	// surface is part of a hitbox

#define MASK_ALL					(0xFFFFFFFF)
// everything that is normally solid
#define MASK_SOLID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// everything that blocks player movement
#define MASK_PLAYERSOLID			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// blocks npc movement
#define MASK_NPCSOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// blocks fluid movement
#define MASK_NPCFLUID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
// water physics in these contents
#define MASK_WATER					(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
// everything that blocks lighting
#define MASK_OPAQUE					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
// everything that blocks lighting, but with monsters added.
#define MASK_OPAQUE_AND_NPCS		(MASK_OPAQUE|CONTENTS_MONSTER)
// everything that blocks line of sight for AI
#define MASK_BLOCKLOS				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
// everything that blocks line of sight for AI plus NPCs
#define MASK_BLOCKLOS_AND_NPCS		(MASK_BLOCKLOS|CONTENTS_MONSTER)
// everything that blocks line of sight for players
#define MASK_VISIBLE					(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
// everything that blocks line of sight for players, but with monsters added.
#define MASK_VISIBLE_AND_NPCS		(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
// bullets see these as solid
#define MASK_SHOT					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
// bullets see these as solid, except monsters (world+brush only)
#define MASK_SHOT_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
// non-raycasted weapons see this as solid (includes grates)
#define MASK_SHOT_HULL				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
// hits solids (not grates) and passes through everything else
#define MASK_SHOT_PORTAL			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
// everything normally solid, except monsters (world+brush only)
#define MASK_SOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
// everything normally solid for player movement, except monsters (world+brush only)
#define MASK_PLAYERSOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
// everything normally solid for npc movement, except monsters (world+brush only)
#define MASK_NPCSOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// just the world, used for route rebuilding
#define MASK_NPCWORLDSTATIC			(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// just the world, used for route rebuilding
#define MASK_NPCWORLDSTATIC_FLUID	(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
// These are things that can split areaportals
#define MASK_SPLITAREAPORTAL		(CONTENTS_WATER|CONTENTS_SLIME)

// UNDONE: This is untested, any moving water
#define MASK_CURRENT				(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)

// everything that blocks corpse movement
// UNDONE: Not used yet / may be deleted
#define MASK_DEADSOLID				(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)

#define SEQUENCE_DEFAULT_DRAW						0
#define SEQUENCE_DEFAULT_IDLE1						1
#define SEQUENCE_DEFAULT_IDLE2						2
#define SEQUENCE_DEFAULT_LIGHT_MISS1				3
#define SEQUENCE_DEFAULT_LIGHT_MISS2				4
#define SEQUENCE_DEFAULT_HEAVY_MISS1				9
#define SEQUENCE_DEFAULT_HEAVY_HIT1					10
#define SEQUENCE_DEFAULT_HEAVY_BACKSTAB				11
#define SEQUENCE_DEFAULT_LOOKAT01					12

#define SEQUENCE_BUTTERFLY_DRAW						0
#define SEQUENCE_BUTTERFLY_DRAW2					1
#define SEQUENCE_BUTTERFLY_LOOKAT01					13
#define SEQUENCE_BUTTERFLY_LOOKAT03					15

#define SEQUENCE_FALCHION_IDLE1						1
#define SEQUENCE_FALCHION_HEAVY_MISS1				8
#define SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP		9
#define SEQUENCE_FALCHION_LOOKAT01					12
#define SEQUENCE_FALCHION_LOOKAT02					13

#define SEQUENCE_DAGGERS_IDLE1						1
#define SEQUENCE_DAGGERS_LIGHT_MISS1 				2
#define SEQUENCE_DAGGERS_LIGHT_MISS5 				6
#define SEQUENCE_DAGGERS_HEAVY_MISS2 				11
#define SEQUENCE_DAGGERS_HEAVY_MISS1 				12

#define SEQUENCE_BOWIE_IDLE1 						1

```

`src/SDK/panorama/CPanel2D.h`:

```h
#pragma once

#include "types.h"

// xref "CPanel2D::BSetProperty" to BSetProperty (libclient)
namespace panorama
{
    class CPanel2D
    {
    public:
        virtual panorama::IUIPanel* UIPanel(void) = 0;
        virtual void OnDeletePanel(void) = 0;
        virtual panorama::CPanoramaSymbol GetPanelType(void) = 0;
        virtual void Paint(void) = 0;
        virtual void sub_4554560() = 0;
        virtual void sub_4554570() = 0;
        virtual void OnContentSizeTraverse(float *, float *, float, float, bool) = 0;
        virtual void OnLayoutTraverse(float, float) = 0;
        virtual void OnKeyDown(panorama::KeyData_t const &) = 0;
        virtual void OnKeyUp(panorama::KeyData_t const &) = 0;
        virtual void OnKeyTyped(panorama::KeyData_t const &) = 0;
        virtual void OnGamePadDown(panorama::GamePadData_t const &) = 0;
        virtual void OnGamePadUp(panorama::GamePadData_t const &) = 0;
        virtual void OnGamePadAnalog(panorama::GamePadData_t const &) = 0;
        virtual void OnMouseButtonDown(panorama::MouseData_t const &) = 0;
        virtual void OnMouseButtonUp(panorama::MouseData_t const &) = 0;
        virtual void OnMouseButtonDoubleClick(panorama::MouseData_t const &) = 0;
        virtual void OnMouseButtonTripleClick(panorama::MouseData_t const &) = 0;
        virtual void OnMouseWheel(panorama::MouseData_t const &) = 0;
        virtual void OnMouseMove(float, float) = 0;
        virtual void OnClick(panorama::IUIPanel *panel, panorama::MouseData_t const &) = 0;
        virtual void sub_23BF260() = 0;
        virtual bool BIsClientPanelEvent(panorama::CPanoramaSymbol) = 0;
        virtual bool sub_3BC94E0() = 0;
        virtual void sub_4555580() = 0;
        virtual bool BSetProperty(panorama::CPanoramaSymbol, const char *) = 0;
        virtual bool BIsDelayedProperty(panorama::CPanoramaSymbol) = 0;
        virtual void OnBeforeChildrenChanged(void) = 0;
        virtual void OnRemoveChild(panorama::IUIPanel* child) = 0;
        virtual void OnAfterChildrenChanged(void) = 0;
        virtual void OnInitializedFromLayout(void) = 0;
        virtual void OnStylesChanged(void) = 0;
        virtual void OnChildStylesChanged(void) = 0;
        virtual void OnVisibilityChanged(void) = 0;
        virtual void OnSetFocusToNextPanel(int, panorama::EFocusMoveDirection, bool, float, float, float, float ,float) = 0;
        virtual void* GetLocalizationParent(void) = 0;
        virtual bool BRequiresContentClipLayer(void) = 0;
        virtual void OnCallBeforeStyleAndLayout(void) = 0;
        virtual void OnPanelEventSet(panorama::CPanoramaSymbol event) = 0;
        virtual void* GetMouseCursor(void) = 0;
        virtual void OnUIScaleFactorChanged(float scaleFactor) = 0;
        virtual void SetupJavascriptObjectTemplate(void) = 0;
        virtual void CreateNewVerticalScrollBar(float) = 0;
        virtual void CreateNewHorizontalScrollBar(float) = 0;
        virtual void HideTooltip(void) = 0;
        virtual void GetDefaultInputFocus(void) = 0;
        virtual void GetPositionWithinAncestor(panorama::CPanel2D* ancestor, float *x, float *y) = 0;
        virtual void sub_23BF380() = 0;
        virtual void sub_23BF390() = 0; // These are in these 6 somewhere
        virtual void sub_23BF3A0() = 0; // panorama::CPanel2D::BCanCustomScrollUp(void)
        virtual void sub_23BF3B0() = 0; // panorama::CPanel2D::BCanCustomScrollDown(void)
        virtual void sub_23BF3C0() = 0; // panorama::CPanel2D::BCanCustomScrollLeft(void)
        virtual void sub_23BF3D0() = 0; // panorama::CPanel2D::BCanCustomScrollRight(void)
        virtual void UnloadImages(void) = 0;
        virtual void ReloadImages(void) = 0;
        virtual void DESTROY1() = 0;
        virtual void DESTROY2() = 0;
        virtual void GetContextUIBounds(float *x1, float *y1, float *x2, float *y2) = 0;
        virtual void ScrollToXPercent(float value) = 0;
        virtual void ScrollToYPercent(float value) = 0;
        virtual void OnMoveUp(int) = 0;
        virtual void OnMoveDown(int) = 0;
        virtual void OnMoveLeft(int) = 0;
        virtual void OnMoveRight(int) = 0;
        virtual void OnTabForward(int) = 0;
        virtual void OnTabBackward(int) = 0;
        virtual void sub_23BF270() = 0;
        virtual void sub_23BF290() = 0;
        virtual void sub_4554580() = 0;
        virtual bool IsClonable() = 0;
        virtual panorama::CPanel2D* Clone(void) = 0;
        virtual void ReSortChild(bool (*)(panorama::IUIPanelClient * const&,panorama::IUIPanelClient * const&),panorama::CPanel2D*) = 0;
        virtual bool HasBeenLayedOut(void) = 0;
        virtual void* AccessRenderingEngine(void) = 0;
        virtual void sub_23BF420() = 0;
        virtual void InitClonedPanel(panorama::CPanel2D* ) = 0;
        virtual void AddDisabledFlagToChildren(void) = 0;
        virtual void RemoveDisabledFlagFromChildren(void) = 0;
        virtual void FireGameEvent(void* IGameEvent) = 0;
        virtual void OnDOTAGameUIStateChange(int DotaGameUIStateOld, int DotaGameUIStateNew) = 0;
    };
}
```

`src/SDK/panorama/IUIEvent.h`:

```h
#pragma once
#include "IUIPanel.h"
//#include <v8.h>
namespace panorama
{
    class IUIEvent
    {
    public:
        virtual void DESTROY() = 0;
        virtual void DESTROY2() = 0;
        virtual panorama::PanelHandle_t* GetTargetPanel(void); // 0xC
        virtual void SetTargetPanel(IUIPanel const *);
        virtual CPanoramaSymbol BROKEN_GetEventType(void);
        virtual bool CanBubble(void);
        virtual void Dispatch(CUtlAbstractDelegate);
        virtual void Copy(void);
        virtual void GetJavaScriptArgs(int *);//,v8::Handle<v8::Value> value);

        CPanoramaSymbol GetEventType(void)
        {
            return *( CPanoramaSymbol* )( ((uintptr_t)this) + 0xA );
        }
    };
}
```

`src/SDK/panorama/IUIPanel.h`:

```h
#pragma once
#include "types.h"
#include <array>
#include <cstdint>

namespace panorama
{
    struct PanelArraySlot
    {
        IUIPanel *panel;
        void* unk1;
        void* unk2;
        uint32_t someSymbol; // Might be a CPanoramaSymbol
        uint32_t boolean; // Looks to normally be 1, maybe IsVisible or IsFinishedSettingUp
    };
    struct PanelArray
    {
        void* _pad; // all F's
        uint32_t size; // I don't think this is right.
        uint32_t unk;
        //TODO: This array is not fixed-size! Something like: CUtlVector
        //Make sure to check panel pointer when using this!
        std::array<PanelArraySlot, 4096> slots;
    };
    // "CUIPanel::RemoveAndDeleteChildren" XREF to Function (libpanorama.so)
    class IUIPanel
    {
    public:
        virtual void DESTROY1(void) = 0;
        virtual void DESTROY2(void) = 0;
        virtual void Initialize(IUIWindow *, IUIPanel *, const char *, unsigned int) = 0;
        virtual void InitClonedPanel(IUIPanel *other) = 0;
        virtual void RegisterEventHandlersOnPanel2DType(CPanoramaSymbol) = 0;
        virtual void Shutdown(void) = 0;
        virtual void FirePanelLoadedEvent(void) = 0;
        virtual void SetClientPtr(IUIPanelClient *) = 0;
        virtual IUIPanelClient* ClientPtr() = 0;
        virtual void SetID(const char *id) = 0;
        virtual const char* GetID(void) = 0; // ID in the XML, (EX: <Panel id="ShopCourierControls">)
        virtual void GetPanelType(void) = 0;
        virtual bool HasID() = 0;
        virtual void* LoadLayoutFile(const char *file, bool option) = 0;
        virtual void* LoadLayoutFileWithError(const char *file) = 0;
        virtual void* LoadSnippet(const char *snippet) = 0;
        virtual void* LoadSnippetWithError(const char *snippet) = 0;
        virtual void* sneed(const char* string) = 0;
        virtual void LoadLayoutAsync(const char *pathToXML, bool, bool) = 0;
        virtual void LoadLayoutFromStringAsync(const char *layoutXML, bool, bool) = 0;
        virtual void UnloadLayout(void) = 0;
        virtual bool IsLoaded(void) = 0;
        virtual void sub_F15B0() = 0; // Added post-anime update
        virtual void sub_F1900() = 0; // Added post-anime update
        virtual void sub_F15A0() = 0; // Added post-anime update
        virtual void sub_E7B00() = 0; // Added post-anime update
        virtual void sub_EB010() = 0; // Added post-anime update
        virtual void SetParent(IUIPanel *parent) = 0;
        virtual IUIPanel* GetParent(void) = 0;
        virtual IUIWindow* GetParentWindow(void) = 0;
        virtual void SetVisible(bool state) = 0;
        virtual bool IsVisible(void) = 0;
        virtual bool IsTransparent(void) = 0;
        virtual void SetLayoutLoadedFromParent(IUIPanel *) = 0;
        virtual void unk_setInt(int unk) = 0; // These 4 are Related.
        virtual void unk_setInt2(int unk) = 0;// Added with Summer Scrub pt2
        virtual int unk_getInt(void) = 0;     // ^^
        virtual int unk_getInt2(void) = 0;    // ^^
        virtual void SetPanelIntoContext(IUIPanel *) = 0;
        virtual void* GetLayoutFile(void) = 0;
        virtual void GetLayoutFileLoadedFrom(void) = 0;
        virtual int GetLayoutFileReloadCount(void) = 0;
        virtual void unk6() = 0;
        virtual void unk7() = 0;
        virtual void unk8() = 0;
        virtual IUIPanel* FindChild(const char *) = 0;
        virtual void unk9() = 0;
        virtual IUIPanel* FindChildTraverse(const char *) = 0;
        virtual void unk10() = 0;
        virtual IUIPanel* FindChildInLayoutFile(const char *) = 0;
        virtual void unk11() = 0;
        virtual IUIPanel* FindPanelInLayoutFile(const char *) = 0;
        virtual bool IsDecendantOf(IUIPanel const * const) = 0;
        virtual void RemoveAndDeleteChildren(void) = 0;
        virtual void RemoveAndDeleteChildrenOfType(CPanoramaSymbol) = 0;
        virtual int GetChildCount(void) = 0;
        virtual IUIPanel* GetChild(int) = 0;
        virtual IUIPanel* GetFirstChild(void) = 0;
        virtual IUIPanel* GetLastChild(void) = 0;
        virtual int GetChildIndex(IUIPanel const * const) = 0;
        virtual int GetChildCountOfType(CPanoramaSymbol) = 0;
        virtual int GetHiddenChildCount(void) = 0;
        virtual IUIPanel* GetHiddenChild(int) = 0;
        virtual IUIPanel* FindAncestor(const char *) = 0;
        virtual void SetRepaint(EPanelRepaint) = 0;
        virtual bool ShouldDrawChildren(IUIPanel *) = 0;
        virtual bool _unk12() = 0; // added dec 7th 2018, returns a bool
        virtual void ApplyLayoutFile() = 0; // (panorama::CLayoutFile *,CUtlVector<panorama::IUIPanel *,CUtlMemory<panorama::IUIPanel *,int>> *)
        virtual void EnableBackgroundMovies(bool state) = 0;
        virtual void* AccessIUIStyle() = 0;
        virtual IUIPanelStyle* AccessIUIStyleDirty() = 0;
        virtual void ApplyStyles(bool apply) = 0;
        virtual void AfterStylesApplied(bool, EStyleRepaint, bool, bool) = 0;
        virtual void SetOnStylesChangedNeeded(void) = 0;
        virtual void* AccessChildren(void) = 0;
        virtual void DesiredLayoutSizeTraverse(float, float) = 0;
        virtual void DesiredLayoutSizeTraverse(float *, float *, float, float, bool) = 0;
        virtual void OnContentSizeTraverse(float *, float *, float, float, bool) = 0;
        virtual void LayoutTraverse(float, float, float, float) = 0;
        virtual void OnLayoutTraverse(float, float) = 0;
        virtual void SetPositionFromLayoutTraverse(CUILength, CUILength, CUILength) = 0;
        virtual void InvalidateSizeAndPosition(void) = 0;
        virtual void InvalidatePosition(void) = 0;
        virtual void SetActiveSizeAndPositionTransition(void) = 0;
        virtual void SetActivePositionTransition(void) = 0;
        virtual bool IsSizeValid(void) = 0;
        virtual bool IsPositionValid(void) = 0;
        virtual bool IsChildSizeValid(void) = 0;
        virtual bool IsChildPositionValid(void) = 0;
        virtual bool IsSizeTransitioning(void) = 0;
        virtual bool IsPositionTransitioning(void) = 0;
        virtual bool IsChildPositionTransitioning(void) = 0;
        virtual bool IsChildSizeTransitioning(void) = 0;
        virtual void TransitionPositionApplied(bool) = 0;
        virtual void unk_func_layoutpass() = 0; // @panorama_enable_secondary_layout_pass -- Funcs added 7-17-19
        virtual int unk_somefunc() = 0;  // ^^
        virtual int unk_somefunc2() = 0; // ^^
        virtual float GetDesiredLayoutWidth(void) = 0; // these might be doubles, need to "double"-check
        virtual float GetDesiredLayoutHeight(void) = 0;
        virtual float GetContentWidth(void) = 0;
        virtual float GetContentHeight(void) = 0;
        virtual float GetActualLayoutWidth(void) = 0;
        virtual float GetActualLayoutHeight(void) = 0;
        virtual float GetActualRenderWidth(void) = 0;
        virtual float GetActualRenderHeight(void) = 0;
        virtual float GetActualXOffset(void) = 0;
        virtual float GetActualYOffset(void) = 0;
        virtual float GetRawActualXOffset(void) = 0;
        virtual float GetRawActualYOffset(void) = 0;
        virtual void unk12() = 0;
        virtual float GetContentsYScrollOffset(void) = 0;
        virtual float GetContentsXScrollOffset(void) = 0;
        virtual void unk_152220() = 0;
        virtual void unk_131A10() = 0;
        virtual void unk_152250() = 0;
        virtual void unk_152230() = 0;
        virtual void unk_1522A0() = 0;
        virtual void unk_152270() = 0;
        virtual void unk_1522D0() = 0;
        virtual void unk_1522F0() = 0;
        virtual void unk_152310() = 0;
        virtual void unk_152330() = 0;
        virtual void unk_152350() = 0;
        virtual void unk_152380() = 0;
        virtual void unk_131080() = 0;
        virtual void unk_1310F0() = 0;
        virtual void unk_134E50() = 0;
        virtual void unk_1350C0() = 0;
        virtual void unk_134EF0() = 0;
        virtual void unk_135450() = 0;
        virtual void unk_135470() = 0;
        virtual void unk_131710() = 0;
        virtual void unk_131760() = 0;
        virtual bool CanScrollUp(void) = 0;
        virtual bool CanScrollDown(void) = 0;
        virtual bool CanScrollLeft(void) = 0;
        virtual bool CanScrollRight(void) = 0;
        virtual void AddClass(const char *) = 0;
        virtual void AddClass(CPanoramaSymbol) = 0;
        virtual void AddClasses(CPanoramaSymbol *, unsigned int count) = 0;
        virtual void RemoveClass(const char *) = 0;
        virtual void RemoveClass(CPanoramaSymbol) = 0;
        virtual void RemoveClasses(CPanoramaSymbol const * const, unsigned int) = 0;
        virtual void RemoveClasses(const char *) = 0;
        virtual void RemoveAllClasses(void) = 0;
        virtual void loc_ECAB0() = 0; // Added sept 26, 2019; related
        virtual void sub_EC3A0() = 0; // Added sept 26, 2019; related
        virtual void sub_EC4B0() = 0; // Added sept 26, 2019; related
        virtual void sub_EBFE0() = 0; // Added sept 26, 2019; related
        virtual void* GetClasses(void) = 0;
        virtual bool HasClass(const char *) = 0;
        virtual bool HasClass(CPanoramaSymbol) = 0;
        virtual bool AscendantHasClass(const char *) = 0;
        virtual bool AscendantHasClass(CPanoramaSymbol) = 0;
        virtual void ToggleClass(const char *) = 0;
        virtual void ToggleClass(CPanoramaSymbol) = 0;
        virtual void SetHasClass(const char *, bool) = 0;
        virtual void SetHasClass(CPanoramaSymbol, bool) = 0;
        virtual void SwitchClass(const char *, const char *) = 0;
        virtual void SwitchClass(const char *, CPanoramaSymbol) = 0;
        virtual void unk_149DF0() = 0;
        virtual void unk_149D50() = 0;
        virtual void unk_149EB0() = 0;
        virtual void unk_149E50() = 0;
        virtual void unk_130E10() = 0;
        virtual void SetAcceptsInput() = 0;
        virtual void AcceptsFocus() = 0;
        virtual void SetAcceptsFocus() = 0;
        virtual void CanAcceptInput() = 0;
        virtual void SetDefaultFocus() = 0;
        virtual void GetDefaultFocus() = 0;
        virtual void SetDisableFocusOnMouseDown() = 0;
        virtual void FocusOnMouseDown() = 0;
        virtual void unk_152460() = 0;
        virtual void unk_1523E0() = 0;
        virtual void unk_130E80() = 0;
        virtual void unk_130EB0() = 0;
        virtual void unk_152400() = 0;
        virtual void unk_152420() = 0;
        virtual void unk_152470() = 0;
        virtual void unk_152490() = 0;
        virtual void unk_1318C0() = 0;
        virtual void GetDefaultInputFocus(void) = 0;
        virtual void SetFocus(void) = 0;
        virtual void UpdateFocusInContext(void) = 0;
        virtual void SetFocusDueToHover(void) = 0;
        virtual void SetInputContextFocus(void) = 0;
        virtual unsigned long long GetStyleFlags(void) = 0;
        virtual void AddStyleFlag(EStyleFlags) = 0; // "CUIPanel::AddStyleFlag"
        virtual void RemoveStyleFlag(EStyleFlags) = 0;
        virtual bool IsInspected(void) = 0;
        virtual bool HasHoverStyle(bool) = 0;
        virtual void SetSelected(bool state) = 0;
        virtual bool IsSelected(void) = 0;
        virtual bool HasKeyFocus(void) = 0;
        virtual bool HasDescendantKeyFocus(void) = 0;
        virtual void SetEnabled(bool state) = 0;
        virtual bool IsEnabled(void) = 0;
        virtual void unk_146920() = 0;
        virtual void IsActivationEnabled(void) = 0;
        virtual void unk_1525B0() = 0;
        virtual void unk13() = 0;
        virtual void unk_132B10() = 0;
        virtual void SetHitTestEnabled(bool state) = 0;
        virtual bool HitTestEnabled(void) = 0;
        virtual void SetHitTestEnabledTraverse(bool state) = 0;
        virtual void unk_152630() = 0;
        virtual void unk_152660() = 0;
        virtual void SetDraggable(bool state) = 0;
        virtual bool IsDraggable(void) = 0;
        virtual void SetRememberChildFocus(bool state) = 0;
        virtual bool GetRememberChildFocus(void) = 0;
        virtual void ClearLastChildFocus(void) = 0;
        virtual void SetNeedsIntermediateTexture(bool state) = 0;
        virtual bool GetNeedsIntermediateTexture(void) = 0;
        virtual void unk_152DE0() = 0;
        virtual void unk_152E40() = 0;
        virtual void SetClipAfterTransform(bool state) = 0;
        virtual bool GetClipAfterTransform(void) = 0;
        virtual const char* GetInputNamespace(void) = 0;
        virtual void SetInputNamespace(const char *) = 0;
        virtual void MarkStylesDirty(bool state) = 0; // "CUIPanel::MarkStylesDirty"
        virtual bool StylesDirty(void) = 0;
        virtual void sub_EB920() = 0; // Added with Nemestice update
        virtual bool ChildStylesDirty() = 0;
        virtual bool ParsePanelEvent(CPanoramaSymbol, const char *) = 0;
        virtual bool IsPanelEventSet(CPanoramaSymbol) = 0;
        virtual bool IsPanelEvent(CPanoramaSymbol) = 0;
        virtual void DispatchPanelEvent(CPanoramaSymbol) = 0;
        virtual void* GetJavaScriptContextParent(void) = 0;
        virtual void* UIImageManager(void) = 0;
        virtual void* UIRenderEngine(void) = 0;
        virtual void unk_130DF0() = 0; // returns another class like the 2 above
        virtual void PaintTraverse(void) = 0;
        virtual void SetTabIndex(float) = 0;
        virtual float GetTabIndex(void) = 0;
        virtual void SetSelectionPosition(float, float) = 0;
        virtual void SetSelectionPositionX(float) = 0;
        virtual void SetSelectionPositionY(float) = 0;
        virtual float GetSelectionPositionX(void) = 0;
        virtual float GetSelectionPositionY(void) = 0;
        virtual float GetTabIndex_Raw(void) = 0;
        virtual float GetSelectionPositionX_Raw(void) = 0;
        virtual float GetSelectionPositionY_Raw(void) = 0;
        virtual void SetFocusToNextPanel(int, EFocusMoveDirection, bool, float, float, float, float, float) = 0;
        virtual void SetInputFocusToFirstOrLastChildInFocusOrder(EFocusMoveDirection, float, float) = 0;
        virtual void SelectionPosVerticalBoundary(void) = 0;
        virtual void SelectionPosHorizontalBoundary(void) = 0;
        virtual void SetChildFocusOnHover(bool state) = 0;
        virtual bool GetChildFocusOnHover(void) = 0;
        virtual void SetFocusOnHover(bool state) = 0;
        virtual bool GetFocusOnHover(void) = 0;
        virtual void ScrollToTop(void) = 0;
        virtual void ScrollToBottom(void) = 0;
        virtual void ScrollToLeftEdge(void) = 0;
        virtual void ScrollToRightEdge(void) = 0;
        virtual void ScrollParentToMakePanelFit(ScrollBehavior_t, bool) = 0;
        virtual void ScrollToFitRegion(float, float, float, float, ScrollBehavior_t, bool, bool) = 0;
        virtual bool CanSeeInParentScroll(void) = 0;
        virtual void OnScrollPositionChanged(void) = 0;
        virtual void SetSendChildScrolledIntoViewEvents(bool) = 0;
        virtual void OnCheckChildrenScrolledIntoView(void) = 0;
        virtual void FireScrolledIntoViewEvent(void) = 0;
        virtual void FireScrolledOutOfViewEvent(void) = 0;
        virtual bool IsScrolledIntoView(void) = 0;
        virtual void SortChildren() = 0; // (int (*)(panorama::IUIPanelClient * const*,panorama::IUIPanelClient * const*))
        virtual void AddChild(IUIPanel *) = 0;
        virtual void AddChildSorted() = 0; // (bool (*)(panorama::IUIPanelClient * const&,panorama::IUIPanelClient * const&),panorama::IUIPanel *)
        virtual void ResortChild() = 0; // (bool (*)(panorama::IUIPanelClient * const&,panorama::IUIPanelClient * const&),panorama::IUIPanel *)
        virtual void RemoveChild(IUIPanel *) = 0;
        virtual void unk_139310() = 0;
        virtual void unk_1393C0() = 0;
        virtual void unk_131260() = 0;
        virtual void unk_131270() = 0;
        virtual void SetMouseCanActivate(EMouseCanActivate, const char *) = 0;
        virtual EMouseCanActivate GetMouseCanActivate(void) = 0;
        virtual IUIPanel* FindParentForMouseCanActivate(void) = 0;
        virtual bool ReloadLayout(CPanoramaSymbol) = 0;
        virtual void ReloadStyleFileTraverse(CPanoramaSymbol) = 0;
        virtual bool HasOnActivateEvent(void) = 0;
        virtual bool HasOnMouseActivateEvent(void) = 0;
        virtual void SetupJavascriptObjectTemplate(void) = 0;
        virtual void SetLayoutFile(CPanoramaSymbol) = 0;
        virtual void BuildMatchingStyleList() = 0; // (CUtlVector<panorama::CascadeStyleFileInfo_t,CUtlMemory<panorama::CascadeStyleFileInfo_t,int>> *)
        virtual void GetAttribute(const char *, int) = 0;
        virtual void GetAttribute(const char *, const char *) = 0;
        virtual void unk_132680() = 0;
        virtual void GetAttribute(const char *, unsigned int) = 0;
        virtual void GetAttribute(const char *, unsigned long long) = 0;
        virtual void SetAttribute(const char *, int) = 0;
        virtual void SetAttribute(const char *, const char *) = 0;
        virtual void SetAttribute(const char *, unsigned int) = 0;
        virtual void SetAttribute(const char *, unsigned long long) = 0;
        virtual void SetAttribute() = 0;
        virtual void unk_132770() = 0;
        virtual void unk_132830() = 0;
        virtual void unk_132810() = 0;
        virtual void unk_1327C0() = 0;
        virtual void unk_132880() = 0;
        virtual void unk_13D2D0() = 0;
        virtual void unk_13D110() = 0;
        virtual void unk_13D350() = 0;
        virtual void unk_13D3D0() = 0;
        virtual void unk_13D450() = 0;
        virtual void unk_13D950() = 0;
        virtual void unk_13D870() = 0;
        virtual void sub_E8F60() = 0; // added with dota-anime
        virtual void sub_F83C0() = 0; // added with dota-anime
        virtual void sub_F8450() = 0; // added with dota-anime
        virtual void sub_F84C0() = 0; // added with dota-anime
        virtual void sub_F8530() = 0; // added with dota-anime
        virtual void sub_F8610() = 0; // added with dota-anime
        virtual void sub_F85A0() = 0; // added with dota-anime
        virtual void sub_F8610_() = 0;// added with dota-anime
        virtual void sub_F8680() = 0; // added with dota-anime
        virtual void sub_F86F0() = 0; // added with dota-anime
        virtual void sub_F54F0() = 0; // added with dota-anime
        virtual void sub_F5500() = 0; // added with dota-anime
        virtual void sub_ECC30() = 0; // added with dota-anime
        virtual void SetAnimation(const char *, float, float, EAnimationTimingFunction, EAnimationDirection, float) = 0;
        virtual void UpdateVisibility(bool) = 0;
        virtual void unk14() = 0; // something to do with profiling
        virtual void SetProperty(CPanoramaSymbol, const char *) = 0;
        virtual void sub_F2680() = 0; // added with 2020 battlepass
        virtual void FindChildrenWithClass() = 0; // (char const*,CUtlVector<panorama::IUIPanel *,CUtlMemory<panorama::IUIPanel *,int>> &)
        virtual void FindChildrenWithClassTraverse() = 0; // (char const*,CUtlVector<panorama::IUIPanel *,CUtlMemory<panorama::IUIPanel *,int>> &)
        virtual void FindChildrenWithClassSomething() = 0; // added 7-17-19
        virtual void FindChildrenWithClassSomething2() = 0; // added 7-17-19
        virtual void PlayFocusChangeSound(int, float) = 0;
        virtual void ClearPanelEventsProfiler() = 0;
        virtual void ClearPanelEvents(CPanoramaSymbol) = 0;
        virtual void SetPanelEvent(CPanoramaSymbol, IUIEvent *) = 0;
        virtual void SetPanelEvent2() = 0; // (panorama::CPanoramaSymbol,CUtlVector<panorama::IUIEvent *,CUtlMemory<panorama::IUIEvent *,int>> *)
        virtual bool GetAnalogStickScrollingEnabled(void) = 0;
        virtual void EnableAnalogStickScrolling(bool state) = 0;
        virtual void SetMouseTracking(bool state) = 0;
        virtual void SetInScrollbarConstruction(bool state) = 0;
        virtual void* GetVerticalScrollBar(void) = 0;
        virtual void* GetHorizontalScrollBar(void) = 0;
        virtual void GetPanelEvents(CPanoramaSymbol) = 0;
        virtual bool HasBeenLayedOut(void) = 0;
        virtual void OnStyleTransitionsCleanup(void) = 0;
        virtual void unk_1529D0() = 0;
        virtual void unk_1529F0() = 0;
        virtual void unk_152A00() = 0;
        virtual void unk_152A20() = 0;
        virtual void sub_E7F80() = 0; // added with battlepass 2020
        virtual void sub_E7FA0() = 0; // added with battlepass 2020
        virtual void unk_136B20() = 0;
        virtual void unk_152A30() = 0;
        virtual void unk_139260() = 0;
        virtual void unk_1331A0() = 0;
        virtual void unk_1529A0() = 0;
        virtual void unk_1529B0() = 0;
        virtual void unk_1529C0() = 0;
    };
}

```

`src/SDK/panorama/PanoramaUIEngine.h`:

```h
#pragma once

#include "../IAppSystem.h"
#include "IUIPanel.h"
#include "IUIEvent.h"
#include "CPanel2D.h"


// Xref "english" to first function, then vtable. (StartupSubsystems)
namespace panorama
{
    inline unsigned int panelArrayOffset;
    class UIEngine
    {
    public:
        PanelArray* GetPanelArray()
        {
            return *(PanelArray**)((uintptr_t)this + panelArrayOffset);
        }
        virtual void DESTROY() = 0; // 0
        virtual void DESTROY2() = 0;
        virtual void StartupSubsystems(panorama::IUISettings *,void* PlatWindow_t__) = 0;
        virtual void ConCommandInit(void* IConCommandBaseAccessor) = 0;
        virtual void Shutdown(void) = 0;
        virtual void RequestShutdown(void) = 0; // mov     byte ptr [rdi+59h], 1
        virtual void Run(void) = 0;
        virtual void RunFrame(void) = 0;
        virtual void SetAggressiveFrameRateLimit(bool) = 0;
        virtual bool IsRunning(void) = 0;
        virtual bool HasFocus(void) = 0; // 10
        virtual double GetCurrentFrameTime(void) = 0;
        virtual void pure() = 0;
        virtual void pure1() = 0;
        virtual void pure2() = 0;
        virtual void unk0() = 0;
        virtual void CreateTextLayout(char const*,char const*,float,float,panorama::EFontWeight,panorama::EFontStyle,panorama::ETextAlign,bool,bool,int,float,float) = 0;
        virtual void CreateTextLayout(wchar_t const*,char const*,float,float,panorama::EFontWeight,panorama::EFontStyle,panorama::ETextAlign,bool,bool,int,float,float) = 0;
        virtual void FreeTextLayout(panorama::IUITextLayout *) = 0;
        virtual void GetSortedValidFontNames(void) = 0;
        virtual IUIInputEngine* UIInputEngine(void) = 0;
        virtual IUILocalize* UILocalize(void) = 0;
        virtual IUISoundSystem* UISoundSystem(void) = 0;
        virtual IUISettings*  UISettings(void) = 0;
        virtual IUILayoutManager* UILayoutManager(void) = 0;
        virtual IUIFileSystem* UIFileSystem(void) = 0;
        virtual void somePureFunc() = 0;
        virtual void RegisterFrameFunc(void (*)(void)) = 0;
        virtual void ReloadLayoutFile(panorama::CPanoramaSymbol) = 0;
        virtual void ToggleDebugMode(void) = 0;
        virtual const char* GetConsoleHistory(void) = 0;
        virtual PanelWrapper* CreatePanel(void) = 0;
        virtual void PanelDestroyed(panorama::IUIPanel *,panorama::IUIPanel *) = 0;
        virtual bool IsValidPanelPointer(panorama::IUIPanel const*) = 0;
        virtual PanelHandle_t GetPanelHandle(panorama::IUIPanel const*) = 0;
        virtual IUIPanel* GetPanelPtr(panorama::PanelHandle_t const&) = 0;
        virtual void CallBeforeStyleAndLayout(panorama::IUIPanel *) = 0;
        virtual void _unk() = 0; //added Dec 7th 2018
        virtual void RegisterForPanelDestroyed();//CUtlDelegate<void ()(panorama::IUIPanel const*,panorama::IUIPanel*)>) = 0;
        virtual void UnregisterForPanelDestroyed();//CUtlDelegate<void ()(panorama::IUIPanel const*,panorama::IUIPanel*)>) = 0;
        virtual void RegisterEventHandler(panorama::CPanoramaSymbol&,panorama::IUIPanel *,CUtlAbstractDelegate) = 0;
        virtual void UnregisterEventHandler(panorama::CPanoramaSymbol&,panorama::IUIPanel *,CUtlAbstractDelegate) = 0;
        virtual void RegisterEventHandler(panorama::CPanoramaSymbol&,panorama::IUIPanelClient *,CUtlAbstractDelegate) = 0;
        virtual void UnregisterEventHandler(panorama::CPanoramaSymbol&,panorama::IUIPanelClient *,CUtlAbstractDelegate) = 0;
        virtual void UnregisterEventHandlersForPanel(panorama::IUIPanel *) = 0;
        virtual void RegisterForUnhandledEvent(panorama::CPanoramaSymbol&,CUtlAbstractDelegate) = 0;
        virtual void UnregisterForUnhandledEvent(panorama::CPanoramaSymbol&,CUtlAbstractDelegate) = 0;
        virtual void UnregisterForUnhandledEvents(void *) = 0;
        virtual bool HaveEventHandlersRegisteredForType(panorama::CPanoramaSymbol) = 0;
        virtual void RegisterPanelTypeEventHandler(panorama::CPanoramaSymbol&,panorama::CPanoramaSymbol&,CUtlAbstractDelegate,bool) = 0; //samey
        virtual void DispatchEvent(panorama::IUIEvent *) = 0;
        virtual void DispatchEventAsync(float,panorama::IUIEvent *) = 0;
        virtual bool AnyHandlerRegisteredForEvent(panorama::CPanoramaSymbol const&) = 0;
        virtual void RegisterEventFilter(CUtlAbstractDelegate) = 0; //vprof1
        virtual void UnregisterEventFilter(CUtlAbstractDelegate) = 0;//vprof2
        virtual void LayoutAndPaintWindows(void) = 0; //vprof3
        virtual const char* GetApplicationInstallPath(void) = 0;
        virtual const char* GetApplicationUserDataPath(void) = 0;
        virtual void RegisterNamedLocalPath(char const*,char const*,bool,bool) = 0;
        virtual void RegisterNamedUserPath(char const*,char const*,bool,bool) = 0;
        virtual void RegisterCustomFontPath(char const*) = 0;
        virtual void GetLocalPathForNamedPath(char const*) = 0;
        virtual void GetLocalPathForRelativePath(char const*,char const*,void* CUtlString) = 0;
        virtual void RegisterNamedRemoteHost(char const*,char const*) = 0;
        virtual void GetRemoteHostForNamedHost(char const*) = 0;
        virtual void RegisterXHeader(char const*,char const*) = 0;
        virtual int GetXHeaderCount(void) = 0;
        virtual void GetXHeader(int,void* CUtlString,void* CUtlString2) = 0;
        virtual void SetCookieHeaderForNamedRemoteHost();//char const*,CUtlVector<CUtlString,CUtlMemory<CUtlString,int>> const&) = 0;
        virtual void SetCookieHeaderForRemoteHost();//char const*,CUtlVector<CUtlString,CUtlMemory<CUtlString,int>> const&) = 0;
        virtual void GetCookieHeadersForNamedRemoteHost(char const*) = 0;
        virtual void GetCookieHeadersForRemoteHost(char const*) = 0;
        virtual void GetCookieValueForRemoteHost(char const*,char const*,void* CUtlString) = 0;
        virtual void BSetCookieForWebRequests(char const*,char const*,char const*) = 0;
        virtual void BClearCookieForWebRequests(char const*,char const*,char const*) = 0;
        virtual void* AccessHTMLController(void) = 0;
        virtual void unk() = 0; // _SDL_ShowSimpleMessageBox with yes/no
        virtual void AddFrameListener(panorama::IUIEngineFrameListener *) = 0;
        virtual void RemoveFrameListener(panorama::IUIEngineFrameListener *) = 0;
        virtual void RegisterMouseCanActivateParent(panorama::IUIPanel *,char const*) = 0;
        virtual void UnregisterMouseCanActivateParent(panorama::IUIPanel *) = 0;
        virtual void GetMouseCanActivateParent(panorama::IUIPanel *) = 0;
        virtual bool AnyWindowHasFocus(void) = 0;
        virtual bool AnyVisibleWindowHasFocus(void) = 0;
        virtual bool AnyOverlayWindowHasFocus(void) = 0;
        virtual IUIWindow* GetFocusedWindow(void) = 0;
        virtual float GetLastInputTime(void) = 0;
        virtual float UpdateLastInputTime(void) = 0;
        virtual void ClearClipboard(void) = 0;
        virtual void CopyToClipboard(char const*,char const*) = 0;
        virtual void GetClipboardText(void* CUtlString,void* CUtlString2) = 0; // "#UI_Paste_UnknownSource"
        virtual const char* GetDisplayLanguage(void) = 0;
        virtual void unk2() = 0;
        virtual void unk3() = 0;
        virtual void unk4() = 0;
        virtual bool HasOverlayForApp(unsigned long long,unsigned long long) = 0;
        virtual void TrackOverlayForApp(unsigned long long,unsigned long long,void *) = 0;
        virtual void DeleteOverlayInstanceForApp(unsigned long long,unsigned long long,void *) = 0;
        virtual void OverlayForApp(unsigned long long,unsigned long long) = 0;
        virtual void unk5() = 0;
        virtual IUIPanelStyle* AllocPanelStyle(panorama::IUIPanel *,float) = 0;
        virtual void FreePanelStyle(panorama::IUIPanelStyle *) = 0;
        virtual void SetPanelWaitingAsyncDelete(panorama::IUIPanel *) = 0;
        virtual bool IsPanelWaitingAsyncDelete(panorama::IUIPanel *) = 0;
        virtual void PulseActiveControllerHaptic();//panorama::IUIEngine::EHapticFeedbackPosition,panorama::IUIEngine::EHapticFeedbackStrength) = 0;
        virtual void unk10() = 0;
        virtual void MarkLayerToRepaintThreadSafe(unsigned long long) = 0;
        virtual void AddDirectoryChangeWatch(char const*) = 0;
        virtual int GetWheelScrollLines(void) = 0; // default 3
        virtual int RunScript(panorama::IUIPanel *panel,char const *entireJSCode,char const *pathToXMLContext,int,int,bool alreadyCompiled) = 0;
        virtual int RunScript2() = 0; //params are different. New. Added with void spirit/granny b
        virtual void ExposeObjectTypeToJavaScript(char const*,const CUtlAbstractDelegate &) = 0;
        virtual bool IsObjectTypeExposedToJavaScript(char const*) = 0;
        virtual void ExposeGlobalObjectToJavaScript(char const*,void *,char const*,bool) = 0;
        virtual void ClearGlobalObjectForJavaScript(char const*,void *) = 0;
        virtual void DeleteJSObjectInstance(panorama::IUIJSObject *) = 0;
        virtual IUIPanel* GetPanelForJavaScriptContext();//v8::Context *) = 0;
        virtual void* GetJavaScriptContextForPanel(panorama::IUIPanel *) = 0;
        virtual void OutputJSExceptionToConsole();//v8::TryCatch &,panorama::IUIPanel *) = 0;
        virtual void AddGlobalV8FunctionTemplate();//char const*,v8::Handle<v8::FunctionTemplate> *,bool) = 0;
        virtual void* GetV8GlobalContext(void) = 0;
        virtual void* GetCurrentV8ObjectTemplateToSetup(void) = 0;
        virtual void MsgMemoryPoolMgr(void) = 0;
        virtual void UIStyleFactory(void) = 0;
        virtual void GetV8Isolate(void) = 0;
        virtual void* CreateV8PanelInstance(panorama::IUIPanel *) = 0;
        virtual void* CreateV8PanelStyleInstance(panorama::IUIPanelStyle *) = 0;
        virtual void* CreateV8ObjectInstance(char const*,void *,panorama::IUIJSObject *) = 0;
        virtual void InitiateAsyncJSONWebAPIRequest();//EHTTPMethod,CUtlString,panorama::IUIPanel *,void *,panorama::CJSONWebAPIParams *,uint) = 0;
        virtual void InitiateAsyncJSONWebAPIRequest2();//EHTTPMethod,CUtlString,CUtlDelegate<void ()(unsigned long long,KeyValues *,void *)>,void *,panorama::CJSONWebAPIParams *,uint) = 0;
        virtual void CancelAsyncJSONWebAPIRequest(unsigned int) = 0;
        virtual void ResolvePath(char const*) = 0;
        virtual void RegisterEventWithEngine(panorama::CPanoramaSymbol&,panorama::UIEventFactory*) = 0;
        virtual bool IsValidEventName(panorama::CPanoramaSymbol) = 0;
        virtual bool IsValidPanelEvent(panorama::CPanoramaSymbol,int *) = 0;
        virtual void CreateInputEventFromSymbol(panorama::CPanoramaSymbol,panorama::IUIPanel *,panorama::EPanelEventSource_t,int) = 0;
        virtual int CreateEventFromString(panorama::IUIPanel *,char const*,char const**) = 0;
        virtual void unk11();
        virtual void RegisterPanelFactoryWithEngine(panorama::CPanoramaSymbol,panorama::CPanel2DFactory *) = 0;
        virtual bool RegisteredPanelType(panorama::CPanoramaSymbol) = 0;
        virtual PanelWrapper* CreatePanel(panorama::CPanoramaSymbol *panelType,char const* id,panorama::IUIPanel *createInThisParent) = 0; // paneltype (ex: Panel, Label), id (ex: <Label id="swag">)
        virtual void CreateDebuggerWindow(void) = 0;
        virtual void CloseDebuggerWindow(void) = 0;
        virtual void RegisterScheduledDelegate();// double,CUtlDelegate<void ()(void)> ) = 0;
        virtual void CancelScheduledDelegate(int) = 0;
        virtual void GetLastScheduledDelegateRunTime(void) = 0;
        virtual CPanoramaSymbol MakeSymbol(char const*) = 0; // if the symbol already exists, you'll get that one.
        virtual const char *ResolveSymbol(CPanoramaSymbol symbol) = 0; // if you pass an invalid number into here, it can crash the program.
        virtual void QueueDecrementRefNextFrame();//CRefCounted<CRefCountServiceBase<true,CRefMT>> *) = 0;
        virtual int RegisterJSGenericCallback();//panorama::IUIPanel *,v8::Handle<v8::Function>) = 0;
        virtual void InvokeJSGenericCallback();//int,int,v8::Handle<v8::Value> *,v8::Handle<v8::Value> *) = 0;
        virtual void UnregisterJSGenericCallback(int) = 0;
        virtual int GetNumRegisterJSScopes(void) = 0;
        virtual void GetRegisterJSScopeInfo(int,panorama::RegisterJSScopeInfo_t *) = 0;
        virtual void GetRegisterJSEntryInfo(int,int,panorama::RegisterJSEntryInfo_t *) = 0;
        virtual void StartRegisterJSScope(char const*,char const*) = 0;
        virtual void EndRegisterJSScope(void) = 0;
        virtual void NewRegisterJSEntry(char const*,uint,char const*,panorama::RegisterJSType_t) = 0;
        virtual void SetRegisterJSEntryParams(int,unsigned char,panorama::RegisterJSType_t *) = 0;
        virtual void ClearFileCache(void) = 0;
        virtual void padding3() = 0;
        virtual void PrintCacheStatus(void) = 0;
        virtual void GetWindowsForDebugger();//CUtlVector<panorama::IUIWindow *,CUtlMemory<panorama::IUIWindow *,int>> &) = 0;
        virtual void SetPaintCountTrackingEnabled(bool) = 0;
        virtual bool GetPaintCountTrackingEnabled(void) = 0;
        virtual void IncrementPaintCountForPanel(unsigned long long,bool,double) = 0;
        virtual void GetPanelPaintInfo(unsigned long long,unsigned int &,bool &,double &) = 0;
        virtual bool sub_8E640(void) = 0; // added with nemestice update
        virtual void sub_90E20() = 0; // added with nemestice update
        virtual bool HasAnyWindows(void) = 0;
        virtual void TextEntryFocusChange(panorama::IUIPanel *) = 0;
        virtual void TextEntryInvalid(panorama::IUIPanel *) = 0;
        virtual void PrintJSStackTrace(); // added with void spirit.
        virtual void SetClipboardText(const char* text) = 0; // wrapper for _SDL_SetClipboardText
        virtual const char* GetClipboardText() = 0; // wrapper for _SDL_GetClipboardText
        virtual void OnFileCacheRemoved(panorama::CPanoramaSymbol) = 0;
        virtual void RunPlatformFrame(void) = 0;
        virtual void CreateSoundSystem(void) = 0;
        virtual void unk12();
        virtual void unk13();
        virtual void unk14();
        virtual void unk15();
        virtual void unk16();
        virtual void unk17();
        virtual void unk18();
    };
}

class IPanoramaUIEngine : IAppSystem
{
public:
    virtual void SetupUIEngine(void);
    virtual void ShutdownUIEngine(void);
    virtual panorama::UIEngine* AccessUIEngine(void);
    virtual void HandleInputEvent();
    virtual void unk1(); // calls this function in PanoramaUIEngine -- call    qword ptr [rax+0A0h]
    virtual void unk2();
};

```

`src/SDK/panorama/types.h`:

```h
#pragma once

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wreorder"
#include "../Valve/tier1/utldelegateimpl.h"
#pragma GCC diagnostic pop
namespace panorama
{
    class CPanel2D;

    class IUIPanel;
    class IUIEvent;
    class IUIEngineFrameListener;
    class IUIPanelStyle;
    class IUIJSObject;
    class IUIWindow;
    class IUISettings;
    class IUITextLayout;
    class IUIInputEngine;
    class IUILocalize;
    class IUISoundSystem;
    class IUISettings;
    class IUILayoutManager;
    class IUIFileSystem;
    class IUIPanelClient;

    // E Prefix for enums?
    class EFontStyle;
    class EFontWeight;
    class ETextAlign;
    class EPanelRepaint;
    class EStyleRepaint;
    class EStyleFlags;
    class EFocusMoveDirection;
    class EMouseCanActivate;
    class EAnimationTimingFunction;
    class EAnimationDirection;

    class CUILength;
    class CLayoutFile;
    typedef unsigned short CPanoramaSymbol;
    typedef unsigned long long PanelHandle_t;
    class CJSONWebAPIParams;
    class UIEventFactory;
    class EPanelEventSource_t;
    class CPanel2DFactory;
    class RegisterJSType_t;
    class RegisterJSScopeInfo_t;
    class RegisterJSEntryInfo_t;
    class KeyData_t;
    class GamePadData_t;
    class MouseData_t;


    // Returned by the CreatePanel functions. TODO: Look at panelRefs this might be that.
    class PanelWrapper{
    public:
        void* vtable;
        IUIPanel* panel;
    };


    struct ScrollBehavior_t;
}
```

`src/SDK/vector.h`:

```h
#pragma GCC diagnostic ignored "-Wunused-value"
#pragma GCC diagnostic ignored "-Wreturn-type"

#include <cmath>
#include <cstdlib>

#pragma once

#define CHECK_VALID( _v ) 0
#define Assert( _exp ) ((void)0)

#define FastSqrt(x)			(sqrt)(x)

#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h

#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.

#define M_PHI		1.61803398874989484820 // golden ratio

// NJS: Inlined to prevent floats from being autopromoted to doubles, as with the old system.
#ifndef RAD2DEG
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )
#endif

#ifndef DEG2RAD
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI_F / 180.f) )
#endif

// MOVEMENT INFO
enum
{
	PITCH = 0,	// up / down
	YAW,		// left / right
	ROLL		// fall over
};

// decls for aligning data

#define DECL_ALIGN(x) __attribute__((aligned(x)))


#define ALIGN16 DECL_ALIGN(16)
#define VALVE_RAND_MAX 0x7fff
#define VectorExpand(v) (v).x, (v).y, (v).z

inline unsigned long& FloatBits(float& f)
{
	return *reinterpret_cast<unsigned long*>(&f);
}

inline bool IsFinite(float f)
{
	return ((FloatBits(f) & 0x7F800000) != 0x7F800000);
}

struct matrix3x4_t
{
	matrix3x4_t() {}
	matrix3x4_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		m_flMatVal[0][0] = m00;	m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
		m_flMatVal[1][0] = m10;	m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
		m_flMatVal[2][0] = m20;	m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
	}

	float *operator[](int i)				{ Assert((i >= 0) && (i < 3)); return m_flMatVal[i]; }
	const float *operator[](int i) const	{ Assert((i >= 0) && (i < 3)); return m_flMatVal[i]; }
	float *Base()							{ return &m_flMatVal[0][0]; }
	[[nodiscard]] const float *Base() const				{ return &m_flMatVal[0][0]; }

	float m_flMatVal[3][4];
};

class Vector
{
public:
	float x, y, z;
	Vector(void);
	Vector(float X, float Y, float Z);
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
	[[nodiscard]] bool IsValid() const;
	float operator[](int i) const;
	float& operator[](int i);
	inline void Zero();
	bool operator==(const Vector& v) const;
	bool operator!=(const Vector& v) const;
	inline Vector&	operator+=(const Vector &v);
	inline Vector&	operator-=(const Vector &v);
	inline Vector&	operator*=(const Vector &v);
	inline Vector&	operator*=(float s);
	inline Vector&	operator/=(const Vector &v);
	inline Vector&	operator/=(float s);
	inline Vector&	operator+=(float fl);
	inline Vector&	operator-=(float fl);
	inline Vector  operator%(const Vector &v);
	[[nodiscard]] inline float	Length() const;
	[[nodiscard]] inline float LengthSqr(void) const
	{
		CHECK_VALID(*this);
		return (x*x + y*y + z*z);
	}
	[[nodiscard]] bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance &&
			z > -tolerance && z < tolerance);
	}
	Vector	Normalize();
	float	NormalizeInPlace();
	[[nodiscard]] inline float	DistTo(const Vector &vOther) const;
	[[nodiscard]] inline float	DistToSqr(const Vector &vOther) const;
	[[nodiscard]] float	Dot(const Vector& vOther) const;
	[[nodiscard]] float	Length2D(void) const;
	[[nodiscard]] float	Length2DSqr(void) const;
	Vector	operator-(void) const;
	Vector	operator+(const Vector& v) const;
	Vector	operator-(const Vector& v) const;
	Vector	operator*(const Vector& v) const;
	Vector	operator/(const Vector& v) const;
	Vector	operator*(float fl) const;
	Vector	operator/(float fl) const;
	// Base address...
	float* Base();
	[[nodiscard]] float const* Base() const;
};

//===============================================
inline void Vector::Init(float ix, float iy, float iz)
{
	x = ix; y = iy; z = iz;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(float X, float Y, float Z)
{
	x = X; y = Y; z = Z;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(void){ }
//===============================================
inline void Vector::Zero()
{
	x = y = z = 0.0f;
}
//===============================================
inline void VectorClear(Vector& a)
{
	a.x = a.y = a.z = 0.0f;
}
//===============================================
inline float& Vector::operator[](int i)
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline float Vector::operator[](int i) const
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline bool Vector::operator==(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x == x) && (src.y == y) && (src.z == z);
}
//===============================================
inline bool Vector::operator!=(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x != x) || (src.y != y) || (src.z != z);
}
//===============================================
inline void VectorCopy(const Vector& src, Vector& dst)
{
	CHECK_VALID(src);
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
}
//===============================================
inline  Vector& Vector::operator+=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x += v.x; y += v.y; z += v.z;
	return *this;
}
//===============================================
inline  Vector& Vector::operator-=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}
//===============================================
// Alias for Cross Product.
inline  Vector Vector::operator%(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);

	return Vector(y*v.z - z*v.y,
				  z*v.x - x*v.z,
				  x*v.y - y*v.x);
}
//===============================================
inline  Vector& Vector::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator*=(const Vector& v)
{
	CHECK_VALID(v);
	x *= v.x;
	y *= v.y;
	z *= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector&	Vector::operator+=(float fl)
{
	x += fl;
	y += fl;
	z += fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector&	Vector::operator-=(float fl)
{
	x -= fl;
	y -= fl;
	z -= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(const Vector& v)
{
	CHECK_VALID(v);
	Assert(v.x != 0.0f && v.y != 0.0f && v.z != 0.0f);
	x /= v.x;
	y /= v.y;
	z /= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline bool Vector::IsValid() const
{
	return IsFinite(x) && IsFinite(y) && IsFinite(z);
}
//===============================================
inline float Vector::Length(void) const
{
	CHECK_VALID(*this);

	float sqsr = x*x + y*y + z*z;

	float root = sqrt(sqsr);

	return root;
}
//===============================================
inline float Vector::Length2D(void) const
{
	CHECK_VALID(*this);

	float sqst = x*x + y*y;

	float root = sqrt(sqst);

	return root;
}
//===============================================
inline float Vector::Length2DSqr(void) const
{
	return (x*x + y*y);
}
//===============================================
inline Vector CrossProduct(const Vector& a, const Vector& b)
{
	return Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
}
//===============================================
float Vector::DistTo(const Vector &vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.Length();
}
float Vector::DistToSqr(const Vector &vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.LengthSqr();
}
//===============================================
inline Vector Vector::Normalize()
{
	Vector vector;
	float length = this->Length();

	if (length != 0)
	{
		vector.x = x / length;
		vector.y = y / length;
		vector.z = z / length;
	}
	else
	{
		vector.x = vector.y = 0.0f; vector.z = 1.0f;
	}

	return vector;
}
//===============================================
inline float Vector::NormalizeInPlace()
{
	Vector& v = *this;

	float iradius = 1.f / (this->Length() + 1.192092896e-07F); //FLT_EPSILON

	v.x *= iradius;
	v.y *= iradius;
	v.z *= iradius;
}
//===============================================
inline float VectorNormalize(Vector& v)
{
	Assert(v.IsValid());
	float l = v.Length();
	if (l != 0.0f)
	{
		v /= l;
	}
	else
	{
		// FIXME:
		// Just copying the existing implemenation; shouldn't res.z == 0?
		v.x = v.y = 0.0f; v.z = 1.0f;
	}
	return l;
}
//===============================================
inline float VectorNormalize(float * v)
{
	return VectorNormalize(*(reinterpret_cast<Vector *>(v)));
}
//===============================================
inline Vector Vector::operator+(const Vector& v) const
{
	Vector res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

//===============================================
inline Vector Vector::operator-(const Vector& v) const
{
	Vector res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}
//===============================================
inline Vector Vector::operator*(float fl) const
{
	Vector res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}
//===============================================
inline Vector Vector::operator*(const Vector& v) const
{
	Vector res;
	res.x = x * v.x;
	res.y = y * v.y;
	res.z = z * v.z;
	return res;
}
//===============================================
inline Vector Vector::operator/(float fl) const
{
	Vector res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}
//===============================================
inline Vector Vector::operator/(const Vector& v) const
{
	Vector res;
	res.x = x / v.x;
	res.y = y / v.y;
	res.z = z / v.z;
	return res;
}
inline float Vector::Dot(const Vector& vOther) const
{
	const Vector& a = *this;

	return(a.x*vOther.x + a.y*vOther.y + a.z*vOther.z);
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------

inline float VectorLength(const Vector& v)
{
	CHECK_VALID(v);
	return FastSqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

//VECTOR SUBTRAC
inline void VectorSubtract(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	c.z = a.z - b.z;
}

//VECTORADD
inline void VectorAdd(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* Vector::Base()
{
	return (float*)this;
}

inline float const* Vector::Base() const
{
	return (float const*)this;
}

inline void VectorMAInline(const float* start, float scale, const float* direction, float* dest)
{
	dest[0] = start[0] + direction[0] * scale;
	dest[1] = start[1] + direction[1] * scale;
	dest[2] = start[2] + direction[2] * scale;
}

inline void VectorMAInline(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	dest.x = start.x + direction.x*scale;
	dest.y = start.y + direction.y*scale;
	dest.z = start.z + direction.z*scale;
}

inline void VectorMA(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	VectorMAInline(start, scale, direction, dest);
}

inline void VectorMA(const float * start, float scale, const float *direction, float *dest)
{
	VectorMAInline(start, scale, direction, dest);
}


class ALIGN16 VectorAligned : public Vector
{
public:
	inline VectorAligned(void) {};
	inline VectorAligned(float X, float Y, float Z)
	{
		Init(X, Y, Z);
	}

#ifdef VECTOR_NO_SLOW_OPERATIONS

private:
	// No copy constructors allowed if we're in optimal mode
	VectorAligned(const VectorAligned& vOther);
	VectorAligned(const Vector &vOther);

#else
public:
	explicit VectorAligned(const Vector &vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
	}

	VectorAligned& operator=(const Vector &vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
		return *this;
	}

#endif
	float w;	// this space is used anyway
};

//=========================================================
// 2D Vector2D
//=========================================================

class Vector2D
{
public:
	// Members
	float x, y;

	// Construction/destruction
	Vector2D(void);
	Vector2D(float X, float Y);
	explicit Vector2D(const float *pFloat);

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f);

	// Got any nasty NAN's?
	[[nodiscard]] bool IsValid() const;

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	[[nodiscard]] float const* Base() const;

	// Initialization methods
	void Random(float minVal, float maxVal);

	// equality
	bool operator==(const Vector2D& v) const;
	bool operator!=(const Vector2D& v) const;

	// arithmetic operations
	Vector2D&	operator+=(const Vector2D &v);
	Vector2D&	operator-=(const Vector2D &v);
	Vector2D&	operator*=(const Vector2D &v);
	Vector2D&	operator*=(float s);
	Vector2D&	operator/=(const Vector2D &v);
	Vector2D&	operator/=(float s);

	// negate the Vector2D components
	void	Negate();

	// Get the Vector2D's magnitude.
	[[nodiscard]] float	Length() const;

	// Get the Vector2D's magnitude squared.
	[[nodiscard]] float	LengthSqr(void) const;

	// return true if this vector is (0,0) within tolerance
	[[nodiscard]] bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance);
	}

	float	Normalize();

	// Normalize in place and return the old length.
	float	NormalizeInPlace();

	// Compare length.
	[[nodiscard]] bool	IsLengthGreaterThan(float val) const;
	[[nodiscard]] bool	IsLengthLessThan(float val) const;

	// Get the distance from this Vector2D to the other one.
	[[nodiscard]] float	DistTo(const Vector2D &vOther) const;

	// Get the distance from this Vector2D to the other one squared.
	[[nodiscard]] float	DistToSqr(const Vector2D &vOther) const;

	// Copy
	void	CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual Vector2D equation (because it's done per-component
	// rather than per-Vector2D).
	void	MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

	// Dot product.
	[[nodiscard]] float	Dot(const Vector2D& vOther) const;

	// assignment
	Vector2D& operator=(const Vector2D &vOther);

#ifndef VECTOR_NO_SLOW_OPERATIONS
	// copy constructors
	Vector2D(const Vector2D &vOther);

	// arithmetic operations
	Vector2D	operator-(void) const;

	Vector2D	operator+(const Vector2D& v) const;
	Vector2D	operator-(const Vector2D& v) const;
	Vector2D	operator*(const Vector2D& v) const;
	Vector2D	operator/(const Vector2D& v) const;
	Vector2D	operator*(float fl) const;
	Vector2D	operator/(float fl) const;

	// Cross product between two vectors.
	[[nodiscard]] Vector2D	Cross(const Vector2D &vOther) const;

	// Returns a Vector2D with the min or max in X, Y, and Z.
	[[nodiscard]] Vector2D	Min(const Vector2D &vOther) const;
	[[nodiscard]] Vector2D	Max(const Vector2D &vOther) const;

#else

private:
	// No copy constructors allowed if we're in optimal mode
	Vector2D(const Vector2D& vOther);
#endif
};

//-----------------------------------------------------------------------------

const Vector2D vec2_origin(0, 0);
const Vector2D vec2_invalid(3.40282347E+38F, 3.40282347E+38F);

//-----------------------------------------------------------------------------
// Vector2D related operations
//-----------------------------------------------------------------------------

// Vector2D clear
void Vector2DClear(Vector2D& a);

// Copy
void Vector2DCopy(const Vector2D& src, Vector2D& dst);

// Vector2D arithmetic
void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, float b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, float b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result);

// Store the min or max of each of x, y, and z into the result.
void Vector2DMin(const Vector2D &a, const Vector2D &b, Vector2D &result);
void Vector2DMax(const Vector2D &a, const Vector2D &b, Vector2D &result);

#define Vector2DExpand( v ) (v).x, (v).y

// Normalization
float Vector2DNormalize(Vector2D& v);

// Length
float Vector2DLength(const Vector2D& v);

// Dot Product
float DotProduct2D(const Vector2D& a, const Vector2D& b);

// Linearly interpolate between two vectors
void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t, Vector2D& dest);


//-----------------------------------------------------------------------------
//
// Inlined Vector2D methods
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(void)
{
#ifdef _DEBUG
	// Initialize to NAN to catch errors
	//x = y = float_NAN;
#endif
}

inline Vector2D::Vector2D(float X, float Y)
{
	x = X; y = Y;
	Assert(IsValid());
}

inline Vector2D::Vector2D(const float *pFloat)
{
	Assert(pFloat);
	x = pFloat[0]; y = pFloat[1];
	Assert(IsValid());
}


//-----------------------------------------------------------------------------
// copy constructor
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(const Vector2D &vOther)
{
	Assert(vOther.IsValid());
	x = vOther.x; y = vOther.y;
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

inline void Vector2D::Init(float ix, float iy)
{
	x = ix; y = iy;
	Assert(IsValid());
}

inline void Vector2D::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
}

inline void Vector2DClear(Vector2D& a)
{
	a.x = a.y = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

inline Vector2D& Vector2D::operator=(const Vector2D &vOther)
{
	Assert(vOther.IsValid());
	x = vOther.x; y = vOther.y;
	return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

inline float& Vector2D::operator[](int i)
{
	Assert((i >= 0) && (i < 2));
	return ((float*)this)[i];
}

inline float Vector2D::operator[](int i) const
{
	Assert((i >= 0) && (i < 2));
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

inline float* Vector2D::Base()
{
	return (float*)this;
}

inline float const* Vector2D::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

inline bool Vector2D::IsValid() const
{
	return IsFinite(x) && IsFinite(y);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

inline bool Vector2D::operator==(const Vector2D& src) const
{
	Assert(src.IsValid() && IsValid());
	return (src.x == x) && (src.y == y);
}

inline bool Vector2D::operator!=(const Vector2D& src) const
{
	Assert(src.IsValid() && IsValid());
	return (src.x != x) || (src.y != y);
}


//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

inline void Vector2DCopy(const Vector2D& src, Vector2D& dst)
{
	Assert(src.IsValid());
	dst.x = src.x;
	dst.y = src.y;
}

inline void	Vector2D::CopyToArray(float* rgfl) const
{
	Assert(IsValid());
	Assert(rgfl);
	rgfl[0] = x; rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------

inline void Vector2D::Negate()
{
	Assert(IsValid());
	x = -x; y = -y;
}

inline Vector2D& Vector2D::operator+=(const Vector2D& v)
{
	Assert(IsValid() && v.IsValid());
	x += v.x; y += v.y;
	return *this;
}

inline Vector2D& Vector2D::operator-=(const Vector2D& v)
{
	Assert(IsValid() && v.IsValid());
	x -= v.x; y -= v.y;
	return *this;
}

inline Vector2D& Vector2D::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator*=(const Vector2D& v)
{
	x *= v.x;
	y *= v.y;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	Assert(IsValid());
	return *this;
}

inline Vector2D& Vector2D::operator/=(const Vector2D& v)
{
	Assert(v.x != 0.0f && v.y != 0.0f);
	x /= v.x;
	y /= v.y;
	Assert(IsValid());
	return *this;
}

inline void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x + b.x;
	c.y = a.y + b.y;
}

inline void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x - b.x;
	c.y = a.y - b.y;
}

inline void Vector2DMultiply(const Vector2D& a, float b, Vector2D& c)
{
	Assert(a.IsValid() && IsFinite(b));
	c.x = a.x * b;
	c.y = a.y * b;
}

inline void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid() && b.IsValid());
	c.x = a.x * b.x;
	c.y = a.y * b.y;
}


inline void Vector2DDivide(const Vector2D& a, float b, Vector2D& c)
{
	Assert(a.IsValid());
	Assert(b != 0.0f);
	float oob = 1.0f / b;
	c.x = a.x * oob;
	c.y = a.y * oob;
}

inline void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	Assert(a.IsValid());
	Assert((b.x != 0.0f) && (b.y != 0.0f));
	c.x = a.x / b.x;
	c.y = a.y / b.y;
}

inline void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result)
{
	Assert(start.IsValid() && IsFinite(s) && dir.IsValid());
	result.x = start.x + s*dir.x;
	result.y = start.y + s*dir.y;
}

// FIXME: Remove
// For backwards compatability
inline void	Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
}

inline void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t, Vector2D& dest)
{
	dest[0] = src1[0] + (src2[0] - src1[0]) * t;
	dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
inline float DotProduct2D(const Vector2D& a, const Vector2D& b)
{
	Assert(a.IsValid() && b.IsValid());
	return(a.x*b.x + a.y*b.y);
}

// for backwards compatability
inline float Vector2D::Dot(const Vector2D& vOther) const
{
	return DotProduct2D(*this, vOther);
}


//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float Vector2DLength(const Vector2D& v)
{
	Assert(v.IsValid());
	return FastSqrt(v.x*v.x + v.y*v.y);
}

inline float Vector2D::LengthSqr(void) const
{
	Assert(IsValid());
	return (x*x + y*y);
}

inline float Vector2D::NormalizeInPlace()
{
	return Vector2DNormalize(*this);
}

inline bool Vector2D::IsLengthGreaterThan(float val) const
{
	return LengthSqr() > val*val;
}

inline bool Vector2D::IsLengthLessThan(float val) const
{
	return LengthSqr() < val*val;
}

inline float Vector2D::Length(void) const
{
	return Vector2DLength(*this);
}


inline void Vector2DMin(const Vector2D &a, const Vector2D &b, Vector2D &result)
{
	result.x = (a.x < b.x) ? a.x : b.x;
	result.y = (a.y < b.y) ? a.y : b.y;
}


inline void Vector2DMax(const Vector2D &a, const Vector2D &b, Vector2D &result)
{
	result.x = (a.x > b.x) ? a.x : b.x;
	result.y = (a.y > b.y) ? a.y : b.y;
}


//-----------------------------------------------------------------------------
// Normalization
//-----------------------------------------------------------------------------
inline float Vector2DNormalize(Vector2D& v)
{
	Assert(v.IsValid());
	float l = v.Length();
	if (l != 0.0f)
	{
		v /= l;
	}
	else
	{
		v.x = v.y = 0.0f;
	}
	return l;
}


//-----------------------------------------------------------------------------
// Get the distance from this Vector2D to the other one
//-----------------------------------------------------------------------------
inline float Vector2D::DistTo(const Vector2D &vOther) const
{
	Vector2D delta;
	Vector2DSubtract(*this, vOther, delta);
	return delta.Length();
}

inline float Vector2D::DistToSqr(const Vector2D &vOther) const
{
	Vector2D delta;
	Vector2DSubtract(*this, vOther, delta);
	return delta.LengthSqr();
}


//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from vecStart
//-----------------------------------------------------------------------------
inline void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D *pResult)
{
	Vector2D vecDelta;
	Vector2DSubtract(vecTarget, vecStart, vecDelta);
	float flDistSqr = vecDelta.LengthSqr();
	if (flDistSqr <= flMaxDist * flMaxDist)
	{
		*pResult = vecTarget;
	}
	else
	{
		vecDelta /= FastSqrt(flDistSqr);
		Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
	}
}



//-----------------------------------------------------------------------------
//
// Slow methods
//
//-----------------------------------------------------------------------------

#ifndef VECTOR_NO_SLOW_OPERATIONS
#endif
//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::Min(const Vector2D &vOther) const
{
	return Vector2D(x < vOther.x ? x : vOther.x,
		y < vOther.y ? y : vOther.y);
}

inline Vector2D Vector2D::Max(const Vector2D &vOther) const
{
	return Vector2D(x > vOther.x ? x : vOther.x,
		y > vOther.y ? y : vOther.y);
}


//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::operator-(void) const
{
	return Vector2D(-x, -y);
}

inline Vector2D Vector2D::operator+(const Vector2D& v) const
{
	Vector2D res;
	Vector2DAdd(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator-(const Vector2D& v) const
{
	Vector2D res;
	Vector2DSubtract(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator*(float fl) const
{
	Vector2D res;
	Vector2DMultiply(*this, fl, res);
	return res;
}

inline Vector2D Vector2D::operator*(const Vector2D& v) const
{
	Vector2D res;
	Vector2DMultiply(*this, v, res);
	return res;
}

inline Vector2D Vector2D::operator/(float fl) const
{
	Vector2D res;
	Vector2DDivide(*this, fl, res);
	return res;
}

inline Vector2D Vector2D::operator/(const Vector2D& v) const
{
	Vector2D res;
	Vector2DDivide(*this, v, res);
	return res;
}

inline Vector2D operator*(float fl, const Vector2D& v)
{
	return v * fl;
}

class QAngleByValue;
class QAngle
{
public:
	// Members
	float x, y, z;

	// Construction/destruction
	QAngle(void);
	QAngle(float X, float Y, float Z);
	//      QAngle(RadianEuler const &angles);      // evil auto type promotion!!!

	// Allow pass-by-value
	explicit operator QAngleByValue &()              { return *((QAngleByValue *)(this)); }
	explicit operator const QAngleByValue &() const  { return *((const QAngleByValue *)(this)); }

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
	void Random(float minVal, float maxVal);

	// Got any nasty NAN's?
	[[nodiscard]] bool IsValid() const;
	void Invalidate();

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	[[nodiscard]] float const* Base() const;

	// equality
	bool operator==(const QAngle& v) const;
	bool operator!=(const QAngle& v) const;

	[[nodiscard]] bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
				y > -tolerance && y < tolerance &&
				z > -tolerance && z < tolerance);
	}

	// arithmetic operations
	QAngle& operator+=(const QAngle &v);
	QAngle& operator-=(const QAngle &v);
	QAngle& operator*=(float s);
	QAngle& operator/=(float s);

	// Get the vector's magnitude.
	[[nodiscard]] float   Length() const;
	[[nodiscard]] float   LengthSqr() const;

	// negate the QAngle components
	//void  Negate();

#ifndef VECTOR_NO_SLOW_OPERATIONS
	// copy constructors

	// arithmetic operations
	QAngle  operator-(void) const;

	QAngle  operator+(const QAngle& v) const;
	QAngle  operator-(const QAngle& v) const;
	QAngle  operator*(float fl) const;
	QAngle  operator/(float fl) const;
#else

private:
	// No copy constructors allowed if we're in optimal mode
	QAngle(const QAngle& vOther);

#endif
};

//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------
inline QAngle::QAngle(void)
{
#ifdef _DEBUG
#ifdef VECTOR_PARANOIA
	// Initialize to NAN to catch errors
	x = y = z = VEC_T_NAN;
#endif
#endif
}

inline QAngle::QAngle(float X, float Y, float Z)
{
	x = X; y = Y; z = Z;
	CHECK_VALID(*this);
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------
inline void QAngle::Init(float ix, float iy, float iz)
{
	x = ix; y = iy; z = iz;
	CHECK_VALID(*this);
}

inline void QAngle::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	CHECK_VALID(*this);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------
inline bool QAngle::operator==(const QAngle& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x == x) && (src.y == y) && (src.z == z);
}

inline bool QAngle::operator!=(const QAngle& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x != x) || (src.y != y) || (src.z != z);
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator+=(const QAngle& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x += v.x; y += v.y; z += v.z;
	return *this;
}

inline QAngle& QAngle::operator-=(const QAngle& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}

inline QAngle& QAngle::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID(*this);
	return *this;
}

inline QAngle& QAngle::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID(*this);
	return *this;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* QAngle::Base()
{
	return (float*)this;
}

inline float const* QAngle::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
inline float& QAngle::operator[](int i)
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}

inline float QAngle::operator[](int i) const
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float QAngle::Length() const
{
	CHECK_VALID(*this);
	return FastSqrt(LengthSqr());
}


inline float QAngle::LengthSqr() const
{
	CHECK_VALID(*this);
	return x * x + y * y + z * z;
}


//-----------------------------------------------------------------------------
// arithmetic operations (SLOW!!)
//-----------------------------------------------------------------------------
#ifndef VECTOR_NO_SLOW_OPERATIONS

inline QAngle QAngle::operator-(void) const
{
	return QAngle(-x, -y, -z);
}

inline QAngle QAngle::operator+(const QAngle& v) const
{
	QAngle res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

inline QAngle QAngle::operator-(const QAngle& v) const
{
	QAngle res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}

inline QAngle QAngle::operator*(float fl) const
{
	QAngle res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}

inline QAngle QAngle::operator/(float fl) const
{
	QAngle res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}

inline QAngle operator*(float fl, const QAngle& v)
{
	return v * fl;
}

#endif // VECTOR_NO_SLOW_OPERATIONS


//QANGLE SUBTRAC
inline void QAngleSubtract(const QAngle& a, const QAngle& b, QAngle& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	c.z = a.z - b.z;
}

//QANGLEADD
inline void QAngleAdd(const QAngle& a, const QAngle& b, QAngle& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
}



class Quaternion; // placeholder
```

`src/SDK/vmatrix.h`:

```h
#pragma once

class VMatrix
{
public:

    VMatrix() {}
    VMatrix(
            float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33
    ){
        m[0][0] = m00;
        m[0][1] = m01;
        m[0][2] = m02;
        m[0][3] = m03;

        m[1][0] = m10;
        m[1][1] = m11;
        m[1][2] = m12;
        m[1][3] = m13;

        m[2][0] = m20;
        m[2][1] = m21;
        m[2][2] = m22;
        m[2][3] = m23;

        m[3][0] = m30;
        m[3][1] = m31;
        m[3][2] = m32;
        m[3][3] = m33;
    }

    // array access
    inline float* operator[](int i)
    {
        return m[i];
    }

    inline const float* operator[](int i) const
    {
        return m[i];
    }

    // Get a pointer to m[0][0]
    inline float *Base()
    {
        return &m[0][0];
    }

    inline const float *Base() const
    {
        return &m[0][0];
    }


public:
    // The matrix.
    float		m[4][4];
};
```

`src/Scanner.cpp`:

```cpp
#include "Scanner.h"

#include "Interfaces.h"
#include "Utils/Patternfinder.h"

static bool FindGlobalVars() {

	// CSource2Client::SetGlobals()
	// 55                      push    rbp
    // 48 85 F6                test    rsi, rsi
    // 48 89 E5                mov     rbp, rsp
    // 48 89 35 D2 8C A0 02    mov     cs:_gpGlobals, rsi

    void ( CSource2Client::*setGlobalsPtr )( void* ) = &CSource2Client::SetGlobals;

    uintptr_t SetGlobals = reinterpret_cast<uintptr_t>( (void*)(client->*setGlobalsPtr) );

    MC_PRINTF("setglobalsPtr (%p)\n", (void*)(client->*setGlobalsPtr) );

	globalVars = *reinterpret_cast<CGlobalVars**>(GetAbsoluteAddress(SetGlobals + 7, 3, 7));
	return true;
}

static bool FindGameEntitySystem()
{
    // CPrediction::ReinitPredictables()
    // Look for string "ReinitPredictables".
    // The start of this function contains both a pointer to CGameEntitySystem and a call to CGameEntitySystem::GetHighestEntityIndex();
	// 55                      push    rbp
	// 48 89 E5                mov     rbp, rsp
	// 41 56                   push    r14
	// 4C 8B 35 F3 A8 2A 02    mov     r14, cs:_g_pGameEntitySystem
	// 41 55                   push    r13
	// 49 89 FD                mov     r13, rdi
	// 41 54                   push    r12
	// 53                      push    rbx
	// 31 DB                   xor     ebx, ebx
	// C6 87 D0 00 00 00 01    mov     byte ptr [rdi+0D0h], 1
	// 49 8B 3E                mov     rdi, [r14]
	// E8 EA 4B E2 FF          call    CGameEntitySystem__GetHighestEntityIndex

    uintptr_t reinitPredictables = PatternFinder::FindPatternInModule("libclient.so", "55 48 89 E5 41 56 4C 8B 35 ?? ?? ?? ?? 41 55 49 89 FD 41 54 53 31", "reinitPredictables");

	if( !reinitPredictables ){
        MC_PRINTF_ERROR("reinitPredictables sig failed\n");
        return false;
    }

    uintptr_t getHighestEntIndexFnAddr = GetAbsoluteAddress( reinitPredictables + 33, 1, 5 );

    // CGameEntitySystem::GetHighestEntityIndex()
    // We get the class offset for the highest Ent Index
    // 55                      push    rbp
    // 8B 87 60 A0 01 00       mov     eax, dword ptr ds:stru_1A060.r_offset[rdi]
    // 48 89 E5                mov     rbp, rsp
    // 5D                      pop     rbp

    highestEntIndexOffset = *reinterpret_cast<uint32_t*>(getHighestEntIndexFnAddr + 3);
    entitySystem = **reinterpret_cast<CGameEntitySystem***>( GetAbsoluteAddress(reinitPredictables + 6, 3, 7) );

	return true;
}


static bool FindVScript()
{
	// Shortly after "__ReplaceClosures"
	// 0F 84 F5 00 00 00                       jz      loc_2A31390
	// 48 8B 3D 16 38 A3 03                    mov     rdi, cs:qword_6464AB8
	// 0F B6 D3                                movzx   edx, bl
	// 4C 89 E6                                mov     rsi, r12

	uintptr_t initialLine = PatternFinder::FindPatternInModule("libclient.so", "48 8B 3D ?? ?? ?? ?? 0F B6 D3", "FindVScript");

	if( !initialLine ){
        MC_PRINTF_ERROR("ERROR VScript sig failed\n");
        return false;
    }

    // The compiler did some weird shit here to morph 2 vtables into one.
    // Just need to decrease thisptr by 0x10 to get to bigger vtable. (IGameSystem + CVScriptGameSystem) instead of just (CVScriptGameSystem).
	void* scriptSys = *reinterpret_cast<CVScriptGameSystem**>( GetAbsoluteAddress(initialLine, 3, 7) );
    scriptSys = reinterpret_cast<char*>(scriptSys) - 0x10;
    vscriptSystem = (CVScriptGameSystem*)scriptSys;

	return true;
}

static bool FindPanelArrayOffset()
{
	unsigned int knownGoodOffset = 0x1c0;
	//  CUIEngine::IsValidPanelPointer()
	//
	//   55                      push    rbp
	//   48 81 C7 B8 01 00 00    add     rdi, 1B8h <--------

    bool ( panorama::UIEngine::*isValidPanelPtrPtr )( const panorama::IUIPanel* ) = &panorama::UIEngine::IsValidPanelPointer;

    uintptr_t IsValidPanelPointer = reinterpret_cast<uintptr_t>( (void*)(panoramaEngine->AccessUIEngine()->*isValidPanelPtrPtr) );
	panorama::panelArrayOffset = *(unsigned int*)(IsValidPanelPointer + 19);

	if( panorama::panelArrayOffset != knownGoodOffset ) {
		MC_PRINTF_WARN( "Array Offset Changed. Is (%x), supposed to be (%x)\n", panorama::panelArrayOffset, knownGoodOffset );
	}
	if( panorama::panelArrayOffset > 0x300 || panorama::panelArrayOffset < 0x100 ){
		MC_PRINTF_ERROR("Array Offset Drastic Change. Is (%x)!\n", panorama::panelArrayOffset );
		return false;
	}
	return true;
}

static bool FindViewRender()
{
    //  InitGameSystems()
    // 55                      push    rbp
    // 48 89 E5                mov     rbp, rsp
    // 41 54                   push    r12
    // 53                      push    rbx
    // 48 83 EC 20             sub     rsp, 20h
    // E8 30 2C 71 00          call    GetViewRenderInstance <-------------
	uintptr_t initGameSystemsFunc = PatternFinder::FindPatternInModule("libclient.so", "55 48 89 E5 41 54 53 48 83 EC ?? E8 ?? ?? ?? ?? 48 8B 15", "GetViewRender Function");

    if( !initGameSystemsFunc ){
        MC_PRINTF_ERROR("initGameSystemsFunc sig failed\n");
        return false;
    }
	typedef CViewRender* (* GetViewRenderFn)();
    auto GetViewRender = reinterpret_cast<GetViewRenderFn>(GetAbsoluteAddress(initGameSystemsFunc + 11, 1, 5));
    viewRender = GetViewRender();
    return true;
}

static bool FindClientMode()
{
	// CSource2Client::HudUpdate()
	// 55                      push    rbp
	// 48 89 E5                mov     rbp, rsp
	// 53                      push    rbx
	// 89 F3                   mov     ebx, esi
	// 48 83 EC 18             sub     rsp, 18h
	// E8 30 E5 6E 01          call    sub_44B48D0
	// E8 8B 2C ED FF          call    sub_2C99030
	// 84 C0                   test    al, al
	// 75 37                   jnz     short loc_2DC63E0
	// 31 FF                   xor     edi, edi
	// E8 E0 53 20 00          call    GetClientMode <----------------

    void ( CSource2Client::*hudUpdatePtr )( bool ) = &CSource2Client::HudUpdate;

	uintptr_t hudUpdateFn = reinterpret_cast<uintptr_t>( (void*)(client->*hudUpdatePtr) );

	if( !hudUpdateFn ){
		MC_PRINTF_ERROR("hudUpdateFn is NULL\n");
		return false;
	}
	typedef IClientMode* (*GetClientModeFn) ( int splitScreenslot );
	auto GetClientMode = reinterpret_cast<GetClientModeFn>( GetAbsoluteAddress( hudUpdateFn + 27, 1, 5 ) );

	if( !GetClientMode ){
		MC_PRINTF_ERROR("GetClientMode function is NULL\n");
		return false;
	}

	clientMode = GetClientMode( 0 );
	if( !clientMode ){
		MC_PRINTF_ERROR("GetClientMode function failed to return ClientMode\n");
		return false;
	}

	return true;
}

static bool FindCamera()
{
	// Xref "SetCameraYaw" - right above it will be CDOTA_PanoramaScript_GameUI::SetCameraYaw()
	// In here, the first function is GDOTADefaultCamera() which we will sig.

	uintptr_t getCameraFuncAddr = PatternFinder::FindPatternInModule("libclient.so", "55 BF FF FF FF FF 48 89 E5 E8 ?? FF FF FF 48 85 C0 74", "GDOTADefaultCamera()");

	if( !getCameraFuncAddr ){
		MC_PRINTF_ERROR("Get Camera sig failed\n");
		return false;
	}

	GetCurrentCamera = reinterpret_cast<GetCameraFn>( getCameraFuncAddr );

	camera = GetCurrentCamera();
	return true;
}


static bool FindGameEventManager()
{
	// 4C 8D 3D AC 86 3C 02    lea     r15, _gameeventmanager
    void ( CSource2Client::*playerInfoChangedPtr )( int ) = &CSource2Client::PlayerInfoChanged;

    uintptr_t playerInfoChangedFn = reinterpret_cast<uintptr_t>( (void*)(client->*playerInfoChangedPtr) );


    auto gameEventManagerAddr = reinterpret_cast<uintptr_t>( GetAbsoluteAddress(playerInfoChangedFn + 54, 3, 7) );
    if( !gameEventManagerAddr ){
        MC_PRINTF_ERROR("Game Event Manager Addr sig broke!\n");
        return false;
    }

    gameEventManager = **reinterpret_cast<CGameEventManager ***>( gameEventManagerAddr );

    if( !gameEventManager ){
        MC_PRINTF_ERROR("Game Event Manager is NULL\n");
        return false;
    }
    return true;
}

static bool FindDBPlayPanel()
{
	// 48 89 1D ?? ?? ?? ?? E8 ?? ?? ?? ?? 48 89 C7
	// xref  "file://{resources}/layout/play.xml". DBPlay panel is a few lines above it.
	// 48 89 1D 73 45 C3 01    mov     cs:DBPlayPanel, rbx   <-------------------------
	// E8 B6 CA AD FE          call    __Znwm          ; operator new(ulong)
	// 48 89 C7                mov     rdi, rax
	// 49 89 C4                mov     r12, rax
	// E8 BB D6 82 FF          call    loc_2C50EA0
	// 48 8B 05 2C 0E 92 01    mov     rax, cs:off_4D44618

	uintptr_t playPanelLine = PatternFinder::FindPatternInModule("libclient.so", "48 89 1D ?? ?? ?? ?? E8 ?? ?? ?? ?? 48 89 C7", "DBPlay Panel");

	if( !playPanelLine ){
		MC_PRINTF_ERROR("DBPlayPanel Sig is broke!\n");
		return false;
	}

	auto playPanelAddr = reinterpret_cast<uintptr_t>( GetAbsoluteAddress( playPanelLine, 3, 7 ) );

	if( !playPanelAddr ){
		MC_PRINTF_ERROR("DBPlayPanelAddr is NULL\n");
		return false;
	}

	gDBPlayPanel = *reinterpret_cast<panorama::CPanel2D**>( playPanelAddr );

	return true;
}

static bool FindAcceptMatch()
{
	// xref "ui.click_back"
	// CDOTA_DB_Play__OnAcceptMatch proc near
	// 55                      push    rbp
	// 48 89 E5                mov     rbp, rsp
	// 53                      push    rbx
	// 89 F3                   mov     ebx, esi
	// 48 83 EC 08             sub     rsp, 8
	// E8 00 83 9F FF          call    GDOTAGCClientSystem
	// 0F B6 F3                movzx   esi, bl
	// 48 89 C7                mov     rdi, rax

	uintptr_t funcAddr = PatternFinder::FindPatternInModule("libclient.so", "55 48 89 E5 53 89 F3 48 83 EC ?? E8 ?? ?? ?? ?? 0F B6 F3 48 89", "On Accept Match");
	if( !funcAddr ){
		MC_PRINTF_ERROR("On Accept Match Sig is broke!\n");
		return false;
	}
	OnAcceptMatch = reinterpret_cast<OnAcceptMatchFn>( funcAddr );
	return true;
}

static bool FindRichPresence()
{
	// CSource2Client::NotifyClientSignon()
	// 55                      push    rbp
	// 48 89 E5                mov     rbp, rsp
	// 41 54                   push    r12
	// 44 0F B7 E6             movzx   r12d, si
	// 53                      push    rbx
	// 89 F3                   mov     ebx, esi
	// 48 83 EC 10             sub     rsp, 10h
	// E8 8A 85 73 00          call    GDOTAGCClientSystem
	// 44 89 E6                mov     esi, r12d
	// 48 89 C7                mov     rdi, rax
	// E8 0F 20 74 00          call    GDOTAGCClientSystem__NotifyClientSignon(int)
	// E8 7A 85 73 00          call    GDOTAGCClientSystem
	// 89 DA                   mov     edx, ebx
	// C1 EA 10                shr     edx, 10h
	// 83 E2 01                and     edx, 1
	// 88 90 FC 05 00 00       mov     [rax+5FCh], dl
	// E8 17 56 46 00          call    RichPresence   <----------------

	void ( CSource2Client::*notifyClientSignonPtr )( int ) = &CSource2Client::NotifyClientSignon;
	uintptr_t NotifyClientSignon = reinterpret_cast<uintptr_t>( (void*)(client->*notifyClientSignonPtr) );

	typedef CDOTARichPresence* ( *GetRichPresenceFn )();
	auto GetRichPresence = reinterpret_cast<GetRichPresenceFn>( GetAbsoluteAddress(NotifyClientSignon + 38, 1, 5) );

	richPresence = GetRichPresence();


	// xref "active RP" to SetRPStatus()
	uintptr_t funcAddr = PatternFinder::FindPatternInModule( "libclient.so", "55 48 89 E5 41 57 41 56 41 89 D6 41 55 49 89 FD 41 54 53 48 81 EC", "SetRPStatus" );

	if( !funcAddr ){
		MC_PRINTF_ERROR("SetRPStatus sig is broke!\n");
		return false;
	}

	SetRPStatus = reinterpret_cast<SetRPStatusFn>( funcAddr );
	return true;
}

static bool FindGCFunctions()
{
	// GCSDK::CGCClient::DispatchPacket(GCSDK::IMsgNetPacket *)
	// xref for "You have been waiting for"
	DispatchPacketFnAddr = PatternFinder::FindPatternInModule( "libclient.so", "55 48 89 E5 41 57 49 89 FF 41 56 41 55 41 54 53 48 89 F3 48 83 EC 48 48 8B 3D", "DispatchPacket()" );

	if( !DispatchPacketFnAddr ){
		MC_PRINTF_ERROR("DispatchPacketFn sig is broke!\n");
		return false;
	}

    // GCSDK::CProtoBufMsgBase::BAsyncSendProto(GCSDK::CProtoBufMsgBase::IProtoBufSendHandler &, unsigned int, CMsgProtoBufHeader const&, google::protobuf::Message const&)
    // xref "CProtoBufMsg::BAsyncSendProto"
    BAsyncSendProtoFnAddr = PatternFinder::FindPatternInModule( "libclient.so", "55 48 89 E5 41 57 41 56 49 89 D6 41 55 41 54 49 89 CC 53 48 83", "BAsyncSendProto()" );
    if( !BAsyncSendProtoFnAddr ){
        MC_PRINTF_ERROR("BAsyncSendProtoFn sig is broke!\n");
        return false;
    }

	// SendMessageGenericClientToGC(const google::protobuf::Message *const msg, uint32 nMsgID)
	// xref for "DOTAPartySearch--Searching", there is 2, look for one that is Not at the end of a function.
	// Follow the green arrow to the next block....

	// E8 3B 39 19 00          call    sub_37F9EC0
	// 48 89 C7                mov     rdi, rax
	// E8 03 D7 1B 00          call    SendMessageGenericClientToGC_Wrapper <---- go into this function.
	// 5B                      pop     rbx

	// the last block in that function contains the target. (2nd to last function call)
	// 83 4D E0 01             or      [rbp+var_20], 1
	// 48 89 45 D0             mov     [rbp+var_30], rax
	// C7 45 E8 00 00 00 00    mov     [rbp+var_18], 0
	// E8 79 0E 64 00          call    SendMessageGenericClientToGC <-----
	// 48 8D 05 D2 72 7F 01    lea     rax, off_501AFD0
	// 48 89 DF                mov     rdi, rbx

	uintptr_t line = PatternFinder::FindPatternInModule( "libclient.so", "C7 45 ?? 00 00 00 00 E8 ?? ?? ?? ?? 48 8D 05 ?? ?? ?? ?? 48 89 DF", "SendMessageGenericClientToGC()" );
	if( !line ){
		MC_PRINTF_ERROR("SendMessageGenericClientToGC sig is broke!\n");
		return false;
	}

    line = GetAbsoluteAddress( line + 7, 1, 5 );
	SendMessageGenericClientToGC = reinterpret_cast<SendMessageGenericClientToGCFn>( line );

    // Grab Game coordinator client in here too.
    // 55                      push    rbp
    // 89 F2                   mov     edx, esi
    // 48 89 FE                mov     rsi, rdi
    // 48 8B 3D CB E6 59 01    mov     rdi, cs:s_pGCClient
    gcClient = *reinterpret_cast<CGCClient**>( GetAbsoluteAddress( line + 6, 3, 7 ) );
	return true;
}

static bool FindPhysicsQuery()
{
	// MaterialFootstepSound() - xref "LeftFoot" to find this function.
    // 48 8B 05 E7 CA 5D 02                mov     rax, cs:_g_pPhysicsQuery
    // 48 C7 85 48 FD FF FF 01 30 18 00    mov     [rbp+var_2B8], 183001h
    // 48 8B 38                            mov     rdi, [rax]
    // E8 EC 34 0B 00                      call    TraceRay

    // valid masks...
    // 0x83001
    // 0x183001
    // 0x181003
    // 0x3011
	uintptr_t physicsQueryLine = PatternFinder::FindPatternInModule( "libclient.so", "48 8B 05 ? ? ? ? 48 8B 38 E8 ? ? ? ? 45 31 D2", "g_pPhysicsQuery" );
	if( !physicsQueryLine ){
		MC_PRINTF_ERROR("FindPhysicsQuery sig is broke!\n");
		return false;
	}

	// Update: physicsQuery seems to just be CVPhys2World now.
	phys2World = ***reinterpret_cast<CVPhys2World****>( GetAbsoluteAddress( physicsQueryLine, 3, 7 ) );

	return true;
}

static bool FindRenderGameSystem()
{
	// CViewRender::OnRenderStart() - lots of goodies in this function.
	// 48 8B 05 3C F3 32 02    mov     rax, cs:_g_pRenderGameSystem
	// 4C 8D 63 10             lea     r12, [rbx+10h]
	// C6 83 B0 10 00 00 01    mov     byte ptr [rbx+10B0h], 1
	// 48 8D 15 A2 98 4E 02    lea     rdx, g_WorldToView
	// 4C 89 E6                mov     rsi, r12
	// 4C 8D 0D 18 98 4E 02    lea     r9, g_WorldToScreen
	// 4C 8D 05 D1 97 4E 02    lea     r8, _g_WorldToProjection
	// 48 8B 38                mov     rdi, [rax]
	// 48 8D 0D 47 98 4E 02    lea     rcx, g_ViewToProjection
	// E8 02 B3 CC FF          call    CRenderGameSystem__GetMatricesForView
	uintptr_t line = PatternFinder::FindPatternInModule( "libclient.so", "48 8B 05 ?? ?? ?? ?? 4C 8D 63 10 C6", "FindRenderGameSystem" );
	if( !line ){
		MC_PRINTF_ERROR("FindRenderGameSystem sig is broke!\n");
		return false;
	}

	renderGameSystem = **reinterpret_cast<CRenderGameSystem***>( GetAbsoluteAddress( line, 3, 7 ) );
	line += 18; // go to worldToView line
	g_WorldToView = reinterpret_cast<VMatrix*>( GetAbsoluteAddress( line, 3, 7 ) );
	line += 10;
	g_WorldToScreen = reinterpret_cast<VMatrix*>( GetAbsoluteAddress( line, 3, 7 ) );
	line += 7;
	g_WorldToProjection = reinterpret_cast<VMatrix*>( GetAbsoluteAddress( line, 3, 7 ) );
	line += 10;
	g_ViewToProjection = reinterpret_cast<VMatrix*>( GetAbsoluteAddress( line, 3, 7 ) );
	line += 7;
	GetMatricesForView = reinterpret_cast<GetMatricesForViewFn>( GetAbsoluteAddress( line, 1, 5 ) );

	return true;
}

static bool FindPanoramaScriptScopes()
{
	// xref "Usage: cl_panorama_script_help" to callback for that concmd. First function that the callback calls is our target.
	// GetPanoramaScriptScopes
	uintptr_t line = PatternFinder::FindPatternInModule( "libclient.so", "55 48 89 E5 41 57 41 56 41 55 41 54 53 48 83 EC ?? 80 3D ?? ?? ?? ?? 00 0F", "GetPanoramaScriptScopes" );
	if( !line ){
		MC_PRINTF_ERROR("FindPanoramaScriptScopes sig is broke!\n");
		return false;
	}

	GetPanoramaScriptScopes = reinterpret_cast<GetPanoramaScriptScopesFn>( line );
	return true;
}

static bool FindTraceFuncs()
{
    // Xref "Pass table - Inputs: start, end, min, max, mask, ignore  -- outputs: pos, fraction, hit, enthit, startsolid" to CVScriptGameSystem::InstallScriptBindings()
    // Script_Traceline will be loaded into rax shortly below.
    // go into it and look for CGameTrace::Init() at the start of a big chunk

    // Or just xref "invalid_hitbox" back to CGameTrace::Init()
    uintptr_t line = PatternFinder::FindPatternInModule( "libclient.so", "55 48 89 E5 41 57 41 56 41 55 41 54 53 48 89 FB 48 81 EC ? ? 00 00 4C 8B 25 ? ? ? ? 64 48 8B 04 25 ? ? ? ? 48 89 45 C8 31 C0 4D", "CGameTrace::Init()" );
    if( !line ){
        MC_PRINTF_ERROR("CGameTrace::Init() sig is broke!\n");
        return false;
    }
    GameTrace_Init = reinterpret_cast<CGameTraceInitFn>( line );

    // towards the end of that big chunk where u found Init(), look for another function. This function will have `mov dword ptr [rdi+28h], 7` in the first chunk.
    // This function is CTraceFilterSimple::CTraceFilterSimple(IHandleEntity const*, int, bool (*)(IHandleEntity*, int))

    // or search for "48 81 E1 FF FF F7 FF",
    // in the chunk below, go into the function that is called.
    // The function will be a couple blocks down on the left
    // 4C 89 85 48 FF FF FF    mov     [rbp+var_B8], r8
    // E8 77 69 FA FF          call    CTraceFilter__CTraceFilter
    // 4D 89 F1                mov     r9, r14
    // 4C 89 E1                mov     rcx, r12

    // Function has been inlined! Do not Pass! Do not collect 200$
    //line = PatternFinder::FindPatternInModule( "libclient.so", "55 48 8D 05 ?? ?? ?? ?? 48 89 E5 41 56 41 89 D6", "CTraceFilter::CTraceFilter()" );
    //if( !line ){
    //    MC_PRINTF_ERROR("CTraceFilter::CTraceFilter sig is broke!\n");
    //    return false;
    //}
//
    //CTraceFilter_Constructor = reinterpret_cast<CTraceFilterConstructorFn>( line );
    return true;
}

static bool FindRenderDevice()
{
   // Xref "CreateDevice: Requested DX level %d" to CRenderDeviceMgrGL::CreateDevice()
   // look a couple blocks below the string...
   // E8 0D 42 FC FF          call    LoadVideoConfig
   // 44 89 F1                mov     ecx, r14d
   // 44 89 E2                mov     edx, r12d
   // 89 DE                   mov     esi, ebx
   // 48 8B 05 DE F1 30 00    mov     rax, cs:_g_pRenderDeviceGL <----------- This one (it also has more xref's than below)
   // 4C 8B 2D 7F ED 30 00    mov     r13, cs:_g_pRenderDeviceBase
   // 48 8B 38                mov     rdi, [rax]
   // 49 89 7D 00             mov     [r13+0], rdi
   // E8 9B CE FF FF          call    InitDevice

   if( Util::GetGraphicsApiType() != GFX_API::OPENGL ){
       MC_PRINTF_ERROR("Does anyone use the vulkan port?\nIf so, you'll have to add another sig here %s", __LINE__);
       return false;
   }

   uintptr_t line = PatternFinder::FindPatternInModule("librendersystemgl.so", "48 8B 05 ?? ?? ?? ?? 4C 8B 2D ?? ?? ?? ?? 48", "CRenderDeviceGL");
   if( !line ){
       MC_PRINTF_ERROR("FindRenderDevice sig is broke!\n");
       return false;
   }


   return true;
}

bool Scanner::FindAllSigs( )
{
	bool sigsOK = true;

	sigsOK &= FindGlobalVars();
	sigsOK &= FindGameEntitySystem();
	sigsOK &= FindVScript();
	sigsOK &= FindPanelArrayOffset();
	sigsOK &= FindViewRender();
	sigsOK &= FindClientMode();
	sigsOK &= FindCamera();
	sigsOK &= FindGameEventManager();
	sigsOK &= FindDBPlayPanel();
	sigsOK &= FindAcceptMatch();
	//sigsOK &= FindRichPresence(); // removed for now, unused and silly - can do this easier
	sigsOK &= FindGCFunctions();
	sigsOK &= FindPhysicsQuery();
	sigsOK &= FindRenderGameSystem();
	sigsOK &= FindPanoramaScriptScopes();
    sigsOK &= FindTraceFuncs();

	return sigsOK;
}












```

`src/Scanner.h`:

```h
#pragma once

namespace Scanner
{
	bool FindAllSigs();
}

```

`src/Settings.cpp`:

```cpp
#include "Settings.h"

#include "Hooks/HardHooks.h"
#include "Utils/Util_sdk.h"
#include "Interfaces.h"
#include "Utils/Logger.h"

void CC_GC_Client_Recv( ConVar*, const char *, float )
{
	if( mc_log_GC_client_recv->GetBool() ){
		MC_LOGF("Installing HardHook- Client GC Recv\n");
		HardHooks::DispatchPacket.Install( (void*)DispatchPacketFnAddr, (void*)HardHooks::MyDispatchPacket );
	} else {
		MC_LOGF("Removing HardHook - Client GC Recv");
		HardHooks::DispatchPacket.Remove();
	}
}

void CC_GC_Client_Send( ConVar*, const char *, float )
{
	MC_LOGF("GC Send convar changed!(%d)\n", mc_log_GC_client_send ->GetInt());
	if( mc_log_GC_client_send->GetBool() ){
		MC_LOGF("Installing HardHook - Client GC Recv\n");
		HardHooks::BAsyncSendProto.Install( (void*)BAsyncSendProtoFnAddr, (void*)HardHooks::MyBAsyncSendProto );
	} else {
		MC_LOGF("Removing HardHook - Client GC Send\n");
		HardHooks::BAsyncSendProto.Remove();
	}
}

/* ConVars are guaranteed to exist after this function */
bool Settings::RegisterCustomConvars( ) {

	mc_esp_type_bbox = Util::RegisterConVar( "mc_esp_type_bbox", "false" );
	mc_esp_type_absbox = Util::RegisterConVar( "mc_esp_type_absbox", "false" );
	mc_esp_type_rbox = Util::RegisterConVar( "mc_esp_type_rbox", "false" );
	mc_esp_type_entbounds = Util::RegisterConVar( "mc_esp_type_entbounds", "false" );
	mc_esp_type_entattachments = Util::RegisterConVar( "mc_esp_type_entattachments", "false" );
	mc_esp_type_entjointinfo = Util::RegisterConVar( "mc_esp_type_entjointinfo", "false" );
	mc_esp_type_entskele = Util::RegisterConVar( "mc_esp_type_entskele", "false" );
	mc_esp_type_enthitboxes = Util::RegisterConVar( "mc_esp_type_enthitboxes", "false" );
	mc_esp_type_entviewoffset = Util::RegisterConVar( "mc_esp_type_entviewoffset", "false" );
	mc_esp_type_infotext = Util::RegisterConVar( "mc_esp_type_infotext", "false" );

	mc_esp_filter_all = Util::RegisterConVar( "mc_esp_filter_all", "true" );
	mc_esp_filter_heroes_friend = Util::RegisterConVar( "mc_esp_filter_heroes_friend", "false" );
	mc_esp_filter_heroes_friend_seenby_enemy = Util::RegisterConVar( "mc_esp_filter_heroes_friend_seenby_enemy", "false" );
	mc_esp_filter_heroes_enemy = Util::RegisterConVar( "mc_esp_filter_heroes_enemy", "false" );
	mc_esp_filter_creeps_friend = Util::RegisterConVar( "mc_esp_filter_creeps_friend", "false" );
	mc_esp_filter_creeps_enemy = Util::RegisterConVar( "mc_esp_filter_creeps_enemy", "false" );
	mc_esp_filter_illusions_enemy = Util::RegisterConVar( "mc_esp_filter_illusions_enemy", "false" );

	mc_camera_pitch_add = Util::RegisterConVar( "mc_camera_pitch_add", "0.0", 136, nullptr, true, -1.0f, true, 360.0f );
	mc_camera_yaw_add = Util::RegisterConVar( "mc_camera_yaw_add", "0.0", 136, nullptr, true, 0.0f );
	mc_camera_distance = Util::RegisterConVar( "mc_camera_distance", "1200.0", 136, nullptr, true, 0.0f );

	mc_fog_disable = Util::RegisterConVar( "mc_fog_disable", "false" );
	mc_fow_disable = Util::RegisterConVar( "mc_fow_disable", "false" );
	mc_autoaccept_on = Util::RegisterConVar( "mc_autoaccept_on", "false" );

	mc_airstuck_on = Util::RegisterConVar( "mc_airstuck_on", "false" );

	mc_log_createmove = Util::RegisterConVar( "mc_log_createmove", "false" );
	mc_log_clientevents = Util::RegisterConVar( "mc_log_clientevents", "false" );
	mc_log_sendnetmsg = Util::RegisterConVar( "mc_log_sendnetmsg", "false" );
	mc_log_sendnetmsg_to_string = Util::RegisterConVar( "mc_log_sendnetmsg_to_string", "false" );
	mc_log_sendnetmsg_filter_commons = Util::RegisterConVar( "mc_log_sendnetmsg_filter_commons", "false" );
	mc_log_recvnetmsg = Util::RegisterConVar( "mc_log_recvnetmsg", "false" );
	mc_log_recvnetmsg_to_string = Util::RegisterConVar( "mc_log_recvnetmsg_to_string", "false" );
    mc_log_recvnetmsg_filter_commons = Util::RegisterConVar( "mc_log_recvnetmsg_filter_commons", "false" );
	mc_log_runscript = Util::RegisterConVar( "mc_log_runscript", "false" );
	mc_log_GC_client_recv = Util::RegisterConVar( "mc_log_GC_client_recv", "false" );
	mc_log_GC_client_send = Util::RegisterConVar( "mc_log_GC_client_send", "false" );

	if( !mc_log_GC_client_recv->AddChangeCallback( CC_GC_Client_Recv ) ){
		MC_LOGF("Failed to add Change Callback for GC Client Recv\n");
		return false;
	}
	if( !mc_log_GC_client_send->AddChangeCallback( CC_GC_Client_Send ) ){
		MC_LOGF("Failed to add Change Callback for GC Client Send\n");
		return false;
	}

    mc_mute_creeps = Util::RegisterConVar( "mc_mute_creeps", "false" );
	mc_end_createmove = Util::RegisterConVar( "mc_end_createmove", "false" );
	mc_crash_server = Util::RegisterConVar( "mc_crash_server", "false" );

	mc_anti_mute = Util::RegisterConVar( "mc_anti_mute", "false" );
	mc_hide_tips = Util::RegisterConVar( "mc_hide_tips", "false" );
	mc_send_voice = Util::RegisterConVar( "mc_send_voice", "false" );
	mc_send_freq = Util::RegisterConVar( "mc_send_freq", "25" );
	mc_send_status = Util::RegisterConVar( "mc_send_status", "false" );
	mc_stall_connect = Util::RegisterConVar( "mc_stall_connect", "false" );

    mc_custom_str = Util::RegisterConVar( "mc_custom_str", "#as Mars (Lvl 25)" );
	mc_custom_str_alt = Util::RegisterConVar( "mc_custom_str_alt", "test123" );
	mc_custom_int = Util::RegisterConVar( "mc_custom_int", "1" );
	mc_custom_int_alt = Util::RegisterConVar( "mc_custom_int_alt", "1" );
    mc_custom_bool = Util::RegisterConVar( "mc_custom_bool", "1" );
    mc_custom_bool_alt = Util::RegisterConVar( "mc_custom_bool_alt", "1" );

	for ( ConCommandBase *var : Util::createdConvars ) {
		if( !cvar->FindVar(var->m_pszName) ){
			MC_PRINTF_ERROR("Error Finding created Var: %s\n", var->m_pszName);
			return false;
		}
	}
	return true;
}
```

`src/Settings.h`:

```h
#pragma once

#include "SDK/Convar.h"

/* Namespace is kinda annoying for these */
inline ConVar *mc_esp_type_bbox;
inline ConVar *mc_esp_type_absbox;
inline ConVar *mc_esp_type_rbox;
inline ConVar *mc_esp_type_entbounds;
inline ConVar *mc_esp_type_entattachments;
inline ConVar *mc_esp_type_entjointinfo;
inline ConVar *mc_esp_type_entskele;
inline ConVar *mc_esp_type_enthitboxes;
inline ConVar *mc_esp_type_entviewoffset;
inline ConVar *mc_esp_type_infotext;

inline ConVar *mc_esp_filter_all;
inline ConVar *mc_esp_filter_heroes_friend;
inline ConVar *mc_esp_filter_heroes_friend_seenby_enemy;
inline ConVar *mc_esp_filter_heroes_enemy;
inline ConVar *mc_esp_filter_creeps_friend;
inline ConVar *mc_esp_filter_creeps_enemy;
inline ConVar *mc_esp_filter_illusions_enemy;

inline ConVar *mc_camera_pitch_add;
inline ConVar *mc_camera_yaw_add;
inline ConVar *mc_camera_distance;

inline ConVar *mc_fog_disable;
inline ConVar *mc_fow_disable;
inline ConVar *mc_autoaccept_on;
inline ConVar *mc_airstuck_on;

inline ConVar *mc_log_createmove;
inline ConVar *mc_log_clientevents;
inline ConVar *mc_log_sendnetmsg;
inline ConVar *mc_log_sendnetmsg_to_string;
inline ConVar *mc_log_sendnetmsg_filter_commons;
inline ConVar *mc_log_recvnetmsg;
inline ConVar *mc_log_recvnetmsg_to_string;
inline ConVar *mc_log_recvnetmsg_filter_commons;
inline ConVar *mc_log_runscript;
inline ConVar *mc_log_GC_client_send;
inline ConVar *mc_log_GC_client_recv;

inline ConVar *mc_mute_creeps;
inline ConVar *mc_end_createmove;
inline ConVar *mc_crash_server;
inline ConVar *mc_anti_mute;
inline ConVar *mc_hide_tips;

inline ConVar *mc_send_voice;
inline ConVar *mc_send_freq;
inline ConVar *mc_send_status;
inline ConVar *mc_stall_connect;

inline ConVar *mc_custom_str;
inline ConVar *mc_custom_str_alt;
inline ConVar *mc_custom_int;
inline ConVar *mc_custom_int_alt;
inline ConVar *mc_custom_bool;
inline ConVar *mc_custom_bool_alt;


namespace Settings
{
	bool RegisterCustomConvars();
}

```

`src/Utils/Crc32.h`:

```h
// https://github.com/LordJZ/consthash
// MIT Licensed
#pragma once
#ifndef _CONSTHASH_CRC32_HXX
#define _CONSTHASH_CRC32_HXX


#ifndef _CONSTHASH_COMMON_HXX
#define _CONSTHASH_COMMON_HXX

#include <cstdint>

#ifndef CONSTHASH_NAMESPACE_BEGIN
#  define CONSTHASH_NAMESPACE_BEGIN namespace consthash {
#endif

#ifndef CONSTHASH_NAMESPACE_END
#  define CONSTHASH_NAMESPACE_END }
#endif

CONSTHASH_NAMESPACE_BEGIN;

    namespace __detail {;

        template<class T>
        struct ensure
        {
            template<T value>
            static constexpr void ct() { }
        };

    }; // namespace __detail

CONSTHASH_NAMESPACE_END;

#endif


CONSTHASH_NAMESPACE_BEGIN;

namespace {

    static uint32_t constexpr crc32_tab[] = {
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
            0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
            0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
            0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
            0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
            0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
            0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
            0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
            0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
            0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
            0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
            0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
            0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
            0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
            0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
            0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
            0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
            0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
            0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
            0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
            0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
            0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
            0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
            0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
            0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
            0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
            0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
            0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
            0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
            0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
            0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
            0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
            0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
    };

    constexpr uint32_t crc32impl(uint32_t prevCrc, const char* str, size_t size)
    {
        return !size ? prevCrc : crc32impl((prevCrc >> 8) ^ crc32_tab[(prevCrc ^ *str) & 0xff], str + 1, size - 1);
    }

} // namespace

constexpr uint32_t crc32(const char* str, size_t size)
{
    return crc32impl(0xffffffff, str, size) ^ 0xffffffff;
}

CONSTHASH_NAMESPACE_END;

#endif // _CONSTHASH_CRC32_HXX

```

`src/Utils/Draw.cpp`:

```cpp
#include "Draw.h"

// FrustumTransform
bool Draw::WorldToScreen( const Vector &spot, int &xOut, int &yOut, const VMatrix &vMatrix ) {
    float w;
    float x,y;
    x = vMatrix[0][0] * spot[0] + vMatrix[0][1] * spot[1] + vMatrix[0][2] * spot[2] + vMatrix[0][3];
    y = vMatrix[1][0] * spot[0] + vMatrix[1][1] * spot[1] + vMatrix[1][2] * spot[2] + vMatrix[1][3];
    //	z		 = vMatrix[2][0] * spot[0] + vMatrix[2][1] * spot[1] + vMatrix[2][2] * spot[2] + vMatrix[2][3];
    w		 = vMatrix[3][0] * spot[0] + vMatrix[3][1] * spot[1] + vMatrix[3][2] * spot[2] + vMatrix[3][3];

    bool behind;
    if( w < 0.001f )
    {
        behind = true;
    }
    else
    {
        behind = false;
        float invw = 1.0f / w;
        x *= invw;
        y *= invw;
    }

    xOut = (int)x;
    yOut = (int)y;

    return behind;
}
```

`src/Utils/Draw.h`:

```h
#pragma once

#include "../SDK/vmatrix.h"
#include "../SDK/vector.h"

namespace Draw
{
    // True on fail ( behind player or something )
    bool WorldToScreen( const Vector &spot, int &xOut, int &yOut, const VMatrix &vMatrix );
}
```

`src/Utils/Integritycheck.cpp`:

```cpp
#include "Integritycheck.h"

#include "../Interfaces.h"

#include <vector>

static void PrintVMTError( const char *className, uint32_t old, uint32_t now ){
    MC_PRINTF_ERROR("%s VM count does not match! [%d]->[%d]\n", className, old, now);
}

struct VMTEntry
{
    const char *name;
    void **ptrToAddr;
    uint32_t expectedLen;
    VMTEntry( const char *namer, void **ptr, uint32_t len ){
        name = namer;
        ptrToAddr = ptr;
        expectedLen = len;
    }
};

static std::vector<VMTEntry> vms = {
        { "Camera", (void**)&camera, 52 },
        { "Client Mode", (void**)&clientMode, 65 },
        { "Game Event Manager", (void**)&gameEventManager, 17 },
        { "CPanel2D", (void**)&gDBPlayPanel, 82 },
        { "viewRender", (void**)&viewRender, 35 },
        { "vScriptSystem", (void**)&vscriptSystem, 59 },
        { "networkClientService", (void**)&networkClientService, 69 },
};

static const uint32_t dotaPlayerNum = 380;
static const uint32_t baseNPCNum = 185;
static const uint32_t panoramaUIPanelNum = 360;
static const uint32_t uiEngineNum = 185;
static const uint32_t networkGameClientNum = 128;
static const uint32_t netChannelNum = 101;

bool Integrity::VMTsHaveMisMatch( ) {
    bool mismatchFound = false;

    /* In-Game Checks */
    if( engine->IsInGame() ){
        int localID = engine->GetLocalPlayer();
        auto *localPlayer = (CDotaPlayer*)entitySystem->GetBaseEntity(localID);
        if( !localPlayer ) {
            MC_PRINTF_ERROR( "Couldn't grab localplayer while in-game\n" );
        } else {
            vms.emplace_back( "CDotaPlayer", (void**)&localPlayer, dotaPlayerNum );
        }

        CDotaBaseNPC *baseNPC = nullptr;
        int max = entitySystem->GetHighestEntityIndex();
        for( int i = 1; i <=max; i++ ) {
            CBaseEntity *entity = entitySystem->GetBaseEntity( i );
            if( !entity )
                continue;
            if( strstr( entity->Schema_DynamicBinding()->binaryName, "DOTA_Unit_Hero" ) ){
                baseNPC = (CDotaBaseNPC*)entity;
                break;
            }
        }

        if( !baseNPC ){
            MC_PRINTF_ERROR("Couldn't grab a Base NPC to test.\n");
        } else if( baseNPCNum != CountVMs( baseNPC ) ){
            vms.emplace_back( "BaseNPC", (void**)&baseNPC, baseNPCNum );
        }
    }


    panorama::IUIPanel *exampleUIPanel = panoramaEngine->AccessUIEngine()->GetPanelArray()->slots[0].panel; // 0 = DotaDashboard
    if( !exampleUIPanel || !panoramaEngine->AccessUIEngine()->IsValidPanelPointer(exampleUIPanel) ){
        MC_PRINTF_ERROR("UI Panel[0] was INVALID!\n");
    } else {
        vms.emplace_back( "UIPanel", (void**)&exampleUIPanel, panoramaUIPanelNum );
    }

    auto networkGameClient = networkClientService->GetIGameClient();
    vms.emplace_back( "networkGameClient", (void**)&networkGameClient, networkGameClientNum );

    auto uiEngine = panoramaEngine->AccessUIEngine();
    vms.emplace_back( "Panorama UI Engine", (void**)&uiEngine, uiEngineNum );

    auto netChan = engine->GetNetChannelInfo();
    vms.emplace_back( "NetChannel", (void**)&netChan, netChannelNum );

    /* Static Checks */
    for( const VMTEntry &i : vms ){
        uint32_t num = CountVMs( *i.ptrToAddr );
        if( num != i.expectedLen ){
            PrintVMTError( i.name, i.expectedLen, num );
            mismatchFound = true;
        }
    }

    return mismatchFound;
}

/* GetInterface() Adds to interfacesMetaDataList */
bool Integrity::CheckInterfaceVMs( )
{
    bool areVMsGood = true;
    for(auto & grabbedInterface : grabbedInterfaces){
        if( grabbedInterface.numVMs == 0 )
            continue;
        uint32_t vmCount = CountVMs(grabbedInterface.interface);

        if( grabbedInterface.numVMs != vmCount ){
            ConMsg("Warning: Interface \"%s\"(%s) (%p) Has Changed. Expected it to have %d VMs; has %d VMs. Check for Broken offsets and Update interfaces.cpp \n",
                   grabbedInterface.name,
                   Memory::GetModuleName( (uintptr_t)grabbedInterface.interface ),
                   grabbedInterface.interface,
                   grabbedInterface.numVMs,
                   vmCount);

            areVMsGood = false;
        }
    }
    return areVMsGood;
}
```

`src/Utils/Integritycheck.h`:

```h
#pragma once

namespace Integrity
{
    bool VMTsHaveMisMatch();
    bool CheckInterfaceVMs();
}
```

`src/Utils/Keyvalue.cpp`:

```cpp
#include "Keyvalue.h"

#include "Crc32.h"
#include "../Utils/Logger.h"

static constexpr uint32_t VBKV_magic = 0x564b4256; // VBKV
struct VBKVHeader {
    uint32_t magic; // VBKV
    uint32_t crc32;
};

static inline std::string GetName( const char* const str, size_t *offsetInBuffer )
{
    // grab null terminated string for keyname
    std::string name((str + *offsetInBuffer));
    //MC_LOGF("Found keyname(%s)\n", name.c_str());
    size_t name_len = name.size() + 1;
    *offsetInBuffer += name_len;

    return name;
}

static std::vector<KVEntry*> ParseBinaryKV_Internal(const char* const data, size_t data_len) {
    std::vector<KVEntry*> vec;

    for( size_t  i = 0; i < data_len; ){
        types_t type = (types_t)data[i];
        i++;

        std::string keyName;

        switch (type) {
            case TYPE_NEWBLOCK: {
                vec.push_back(new KVEntry(type));
                break;
            }
            case TYPE_STRING: {
                keyName = GetName( data, &i );
                std::string strValue( (data + i) );
                vec.push_back(new KVString(keyName, type, strValue));
                i += strValue.size() + 1;
                break;
            }
            case TYPE_INT:
                keyName = GetName( data, &i );
                vec.push_back(new KVInt(keyName, type, *(int*)(data + i)));
                i += sizeof(int);
                break;
            case TYPE_FLOAT:
                keyName = GetName( data, &i );
                vec.push_back(new KVFloat(keyName, type, *(float*)(data + i)));
                i += sizeof(float);
                break;
            case TYPE_PTR:
                keyName = GetName( data, &i );
                vec.push_back(new KVPtr(keyName, type, *(uint32_t*)(data + i)));
                i += sizeof(uint32_t);
                break;
            case TYPE_WSTRING: {
                keyName = GetName( data, &i );
                std::wstring strValue = std::wstring((wchar_t*)(data + i));
                vec.push_back(new KVWString(keyName, type, strValue));
                i += (strValue.size() + 1) * 2;
                break;
            }
            case TYPE_COLOR:
                keyName = GetName( data, &i );
                vec.push_back(new KVColorRGBA(keyName, type, *(ColorRGBA*)(data + i)));
                i += sizeof(ColorRGBA);
                break;
            case TYPE_UINT64:
                keyName = GetName( data, &i );
                vec.push_back(new KVBigInt(keyName, type, *(uint64_t*)(data + i)));
                i += sizeof(uint64_t);
                break;
            case TYPE_ENDBLOCK:
                vec.push_back(new KVEntry(type));
                break;
        }
    }
    return vec;
}

std::vector<KVEntry*> KeyValue::ParseBinaryKV(const char* data, size_t len) {
    VBKVHeader* header = (VBKVHeader*)data;
    uint32_t crcTable;
    std::vector<KVEntry*> parsedKV;

    if (len < sizeof(VBKVHeader)){
        MC_LOGF("ParseBinaryKV: Error- length is too small to be valid.\n");
        return parsedKV;
    }
    if (header->magic != VBKV_magic){
        MC_LOGF("ParseBinaryKV: Error- magic doesn't match.\n");
        return parsedKV;
    }

    data += sizeof(VBKVHeader);
    len -= sizeof(VBKVHeader);



    crcTable = consthash::crc32( data, len );

    if (crcTable != header->crc32) {
        MC_LOGF("ParseBinaryKV: Error- crc doesn't match\n");
        return parsedKV;
    }

    parsedKV = ParseBinaryKV_Internal( data, len );
    MC_LOGF("Parsed %d Keyvalues\n", parsedKV.size() );
    /*
    if (parsedKV.size() != 1) {
        for (auto obj : parsedKV)
            delete obj;

        MC_LOGF("ParseVBKV: Error- size != 1\n");
        return nullptr;
    }*/

    return parsedKV;
}


static std::string SerializeEntryToString(KVEntry* entry) {
    std::string out;
    switch (entry->type) {
        case TYPE_NEWBLOCK: {
            out += '\x00';
            break;
        }
        case TYPE_STRING: {
            out += entry->type;
            out += ((KVString*)entry)->name;
            out += '\0';
            out += ((KVString*)entry)->val;
            out += '\0';
            break;
        }
        case TYPE_INT: {
            out += entry->type;
            out += ((KVInt*)entry)->name;
            out += '\0';
            auto val = ((KVInt*)entry)->val;
            for (size_t i = 0, end = sizeof(val); i < end; i++)
                out += ((char*)&val)[i];
            break;
        }
        case TYPE_FLOAT: {
            out += entry->type;
            out += ((KVFloat*)entry)->name;
            out += '\0';
            auto val = ((KVFloat*)entry)->val;
            for (size_t i = 0, end = sizeof(val); i < end; i++)
                out += ((char*)&val)[i];
            break;
        }
        case TYPE_PTR: {
            out += entry->type;
            out += ((KVPtr*)entry)->name;
            out += '\0';
            auto val = ((KVPtr*)entry)->val;
            for (size_t i = 0, end = sizeof(val); i < end; i++)
                out += ((char*)&val)[i];
            break;
        }
        case TYPE_WSTRING:
            out += entry->type;
            //out += "wstring unsupported";
            MC_LOGF("wstring unsupported!\n");
            out += '\x00';
            break;
        case TYPE_COLOR: {
            out += entry->type;
            out += ((KVColorRGBA*)entry)->name;
            out += '\0';
            auto val = ((KVColorRGBA*)entry)->val;
            for (size_t i = 0, end = sizeof(val); i < end; i++)
                out += ((char*)&val)[i];
            break;
        }
        case TYPE_UINT64: {
            out += entry->type;
            out += ((KVBigInt*)entry)->name;
            out += '\0';
            auto val = ((KVBigInt*)entry)->val;
            for (size_t i = 0, end = sizeof(val); i < end; i++)
                out += ((char*)&val)[i];
            break;
        }
        case TYPE_ENDBLOCK:
            out += '\x0B';
            break;
    }
    return out;
}

std::string KeyValue::SerializeEntriesToString(std::vector<KVEntry *> entries) {
    std::string ret = "VBKV";
    uint32_t crc;
    std::string entriesStr = "";

    if( entries.size() == 0 ){
        return std::string("Empty entries parameter!" );
    }

    for( KVEntry *entry : entries ){
        entriesStr += SerializeEntryToString( entry );
    }

    crc = consthash::crc32( entriesStr.data(), entriesStr.size() );

    for (size_t i = 0, end = sizeof(crc); i < end; i++)
        ret += ( ((char*)&crc)[i] );

    ret += entriesStr;

    return ret;
}
```

`src/Utils/Keyvalue.h`:

```h
#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include "../SDK/color.h"

enum types_t : uint8_t {
    TYPE_NEWBLOCK = 0,
    TYPE_STRING,
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_PTR,
    TYPE_WSTRING,
    TYPE_COLOR,
    TYPE_UINT64,



    TYPE_ENDBLOCK = 0xB, // technically not accurate
};


/// Example data: data: "VBKV\263\001\211\357\000\000\001keyone_str\000valueone\000\001keytwo_str\000valuetwo\000\002keythree_int\000\010\000\000\000\003keyfour_float\000\000\000\213B\013\013"
/// binary structure is something like this
// VBKV - magic
// \263\001\211\357 - crc
// \000\000 - new block, new block
/// Key Entries
//\001keyone_str\000 valueone\000
//\001keytwo_str\000 valuetwo\000
//\002keythree_int\000 \010\000\000\000
//\003keyfour_float\000 \000\000\213B

//\013\013 - 0xB - end of block, end of block


// WIP keyvalue class. Credits: moofmonkey for original version.
struct KVEntry {
    types_t type;

    KVEntry(types_t type) : type(type) {}
    virtual ~KVEntry() {}
};

#define DEF_ENTRY_TYPE(type_name, val_type) \
struct KV##type_name : public KVEntry {\
    std::string name;\
	val_type val;\
	KV##type_name(std::string name, types_t type, val_type val) : KVEntry(type), name(name), val(val) {}\
}
DEF_ENTRY_TYPE(String, std::string);
DEF_ENTRY_TYPE(Int, int);
DEF_ENTRY_TYPE(Float, float);
DEF_ENTRY_TYPE(Ptr, uint32_t);
DEF_ENTRY_TYPE(WString, std::wstring);
DEF_ENTRY_TYPE(ColorRGBA, ColorRGBA);
DEF_ENTRY_TYPE(BigInt, uint64_t);
#undef DEF_ENTRY_TYPE


namespace KeyValue
{
    std::vector<KVEntry*> ParseBinaryKV(const char* data, size_t len);
    std::string SerializeEntriesToString(std::vector<KVEntry*> entries);
}
```

`src/Utils/Logger.h`:

```h
#pragma once

#include "../SDK/CBaseFileSystem.h"

inline CBaseFileSystem *fs;
namespace Logger
{
    inline FileHandle_t logFile; // logfile Handle
}

#define MC_LOGF(f_, ...) fs->FPrintf( Logger::logFile, ("" f_), ##__VA_ARGS__);fs->Flush( Logger::logFile )
```

`src/Utils/Math.cpp`:

```cpp
#include "Math.h"

void inline Math::SinCos(float radians, float *sine, float *cosine)
{
	double __cosr, __sinr;
	__asm ("fsincos" : "=t" (__cosr), "=u" (__sinr) : "0" (radians));

	*sine = __sinr;
	*cosine = __cosr;
}

void Math::AngleVectors(const QAngle &angles, Vector& forward)
{
	float sp, sy, cp, cy;

	Math::SinCos(DEG2RAD(angles[YAW]), &sy, &cy);
	Math::SinCos(DEG2RAD(angles[PITCH]), &sp, &cp);

	forward.x = cp * cy;
	forward.y = cp * sy;
	forward.z = -sp;
}

void Math::AngleVectors(const QAngle &angles, Vector *forward, Vector *right, Vector *up){
	float sr, sp, sy, cr, cp, cy;

	SinCos( DEG2RAD( angles[YAW] ), &sy, &cy );
	SinCos( DEG2RAD( angles[PITCH] ), &sp, &cp );
	SinCos( DEG2RAD( angles[ROLL] ), &sr, &cr );

	if (forward) {
		forward->x = cp*cy;
		forward->y = cp*sy;
		forward->z = -sp;
	}

	if (right) {
		right->x = (-1*sr*sp*cy+-1*cr*-sy);
		right->y = (-1*sr*sp*sy+-1*cr*cy);
		right->z = -1*sr*cp;
	}

	if (up) {
		up->x = (cr*sp*cy+-sr*-sy);
		up->y = (cr*sp*sy+-sr*cy);
		up->z = cr*cp;
	}
}

void Math::NormalizeAngles(QAngle& angle)
{
	while (angle.x > 89.0f)
		angle.x -= 180.f;

	while (angle.x < -89.0f)
		angle.x += 180.f;

	while (angle.y > 180.f)
		angle.y -= 360.f;

	while (angle.y < -180.f)
		angle.y += 360.f;
}

void Math::ClampAngles(QAngle& angle)
{
	if (angle.y > 180.0f)
		angle.y = 180.0f;
	else if (angle.y < -180.0f)
		angle.y = -180.0f;

	if (angle.x > 89.0f)
		angle.x = 89.0f;
	else if (angle.x < -89.0f)
		angle.x = -89.0f;

	angle.z = 0;
}

float Math::GetFov(const QAngle& viewAngle, const QAngle& aimAngle)
{
	QAngle delta = aimAngle - viewAngle;
	NormalizeAngles(delta);

	return sqrtf(powf(delta.x, 2.0f) + powf(delta.y, 2.0f));
}

void Math::VectorAngles(const Vector& forward, QAngle &angles)
{
	if (forward[1] == 0.0f && forward[0] == 0.0f)
	{
		angles[0] = (forward[2] > 0.0f) ? 270.0f : 90.0f; // Pitch (up/down)
		angles[1] = 0.0f;  //yaw left/right
	}
	else
	{
		angles[0] = atan2(-forward[2], forward.Length2D()) * -180 / M_PI;
		angles[1] = atan2(forward[1], forward[0]) * 180 / M_PI;

		if (angles[1] > 90)
			angles[1] -= 180;
		else if (angles[1] < 90)
			angles[1] += 180;
		else if (angles[1] == 90)
			angles[1] = 0;
	}

	angles[2] = 0.0f;
}

float Math::DotProduct(const Vector &v1, const float* v2)
{
	return v1.x*v2[0] + v1.y*v2[1] + v1.z*v2[2];
}
void Math::VectorTransform (const Vector &in1, const matrix3x4_t& in2, Vector &out)
{
	out.x = DotProduct(in1, in2[0]) + in2[0][3];
	out.y = DotProduct(in1, in2[1]) + in2[1][3];
	out.z = DotProduct(in1, in2[2]) + in2[2][3];
}

QAngle Math::CalcAngle(const Vector &src, const Vector &dst)
{
	QAngle angles;
	Vector delta = src - dst;

	Math::VectorAngles(delta, angles);

	delta.Normalize();

	return angles;
}

bool Math::CmpF( float a, float b, float epsilon ) {
	return std::abs( a - b ) < epsilon;
}

```

`src/Utils/Math.h`:

```h
#pragma once

#include "../SDK/vector.h"

namespace Math {
	void inline SinCos(float radians, float *sine, float *cosine);
	void AngleVectors(const QAngle &angles, Vector &forward);
	void AngleVectors(const QAngle &angles, Vector *forward, Vector *right, Vector *up);
	void NormalizeAngles(QAngle& angle);
	void ClampAngles(QAngle& angle);
	float GetFov(const QAngle &viewAngle, const QAngle &aimAngle);
	float DotProduct(const Vector &v1, const float* v2);
	void VectorAngles(const Vector &forward, QAngle &angles);
	void VectorTransform (const Vector &in1, const matrix3x4_t& in2, Vector &out);
	QAngle CalcAngle(const Vector &src, const Vector &dst);
	bool CmpF( float a, float b, float epsilon = 0.01f );
}
```

`src/Utils/Memory.cpp`:

```cpp
#include "Memory.h"

#include <link.h> // dl_iterate_phdr
#include <cstring>

/* Read Memory Protection without parsing /proc/$$/maps
 * Stack overflow btfo'd */
static unsigned int flags = 0;
static uintptr_t addr;
unsigned int Memory::GetProtectionFlags( uintptr_t address ) {
    flags = 0;
    addr = address;
    dl_iterate_phdr([] (struct dl_phdr_info* info, size_t, void*) {
        uintptr_t startingAddr = 0;
        uintptr_t endingAddr = 0;

        for( int i = 0; i < info->dlpi_phnum; i++ ){
            const ElfW(Phdr) *hdr = &info->dlpi_phdr[i];
            if( hdr->p_memsz ){
                startingAddr = info->dlpi_addr + hdr->p_vaddr;
                endingAddr = startingAddr + hdr->p_memsz;
                if( startingAddr <= addr && endingAddr >= addr ){
                    flags |= hdr->p_flags;
                }
            }
        }

        return 0;
    }, nullptr);

    return flags;
}

static const char unk[] = "Unknown";
static uintptr_t moduleAddr;
static const char *ret;
const char *Memory::GetModuleName( uintptr_t address ) {
    ret = unk;
    moduleAddr = address;
    dl_iterate_phdr([] (struct dl_phdr_info* info, size_t, void*) {
        uintptr_t startingAddr = 0;
        uintptr_t endingAddr = 0;

        for( int i = 0; i < info->dlpi_phnum; i++ ){
            const ElfW(Phdr) *hdr = &info->dlpi_phdr[i];
            if( hdr->p_memsz ){
                startingAddr = info->dlpi_addr + hdr->p_vaddr;
                endingAddr = startingAddr + hdr->p_memsz;
                if( startingAddr <= moduleAddr && endingAddr >= moduleAddr ){
                    ret = strrchr(info->dlpi_name, '/') + (1 * sizeof(char)); // don't grab full path
                    return 0;
                }
            }
        }

        return 0;
    }, nullptr);

    return ret;
}
```

`src/Utils/Memory.h`:

```h
#pragma once

#include <cstdint>
#include <elf.h> // you will need this to check flags for PF_R/PF_W/PF_X

namespace Memory
{
    unsigned int GetProtectionFlags( uintptr_t address );
    const char *GetModuleName( uintptr_t address );
}
```

`src/Utils/Patternfinder.cpp`:

```cpp
#include "Patternfinder.h"

#include <link.h> // dl_iterate_phdr
#include <vector>
#include <cstring> //strcasestr
#include "../Interfaces.h"

// taken from aixxe's cstrike-basehook-linux
static bool GetLibraryInformation(const char* library, uintptr_t* address, size_t* size) {
    static std::vector<dlinfo_t> libraries;

    if (libraries.empty()) {
        dl_iterate_phdr([] (struct dl_phdr_info* info, size_t, void*) {
            dlinfo_t library_info = {};
            library_info.library = info->dlpi_name;
            library_info.address = info->dlpi_addr + info->dlpi_phdr[0].p_vaddr;
            library_info.size = info->dlpi_phdr[0].p_memsz;

            libraries.push_back(library_info);

            return 0;
        }, nullptr);
    }

    for (const dlinfo_t& current: libraries) {
        if (!strcasestr(current.library, library))
            continue;

        if (address)
            *address = current.address;

        if (size)
            *size = current.size;

        return true;
    }

    return false;
}

// original code by dom1n1k and Patrick at GameDeception
inline bool Compare(const unsigned char* pData, const unsigned char* bMask, const char* szMask)
{
    for (; *szMask; ++szMask, ++pData, ++bMask)
        if (*szMask == 'x' && *pData != *bMask)
            return false;

    return (*szMask) == 0;
}

uintptr_t PatternFinder::FindPattern(uintptr_t dwAddress, uintptr_t dwLen, unsigned char* bMask, const char* szMask)
{
	for (uintptr_t i = 0; i < dwLen; i++)
		if (Compare((unsigned char*)(dwAddress + i), bMask, szMask))
			return (uintptr_t)(dwAddress + i);

	return 0;
}

uintptr_t PatternFinder::FindPatternInModule(const char* moduleName, const char* signature, const char* why)
{
	uintptr_t baseAddress;
	size_t memSize;
    size_t sigLen = strlen(signature);

    unsigned int bMaskIndex = 0;
    unsigned int szMaskIndex = 0;

    unsigned char *bMask;
    char *szMask;
    char byteBuffer[3] = { 0 };

	if (!GetLibraryInformation(moduleName, &baseAddress, &memSize)){
		MC_PRINTF_ERROR("Could Not Get info for Module %s\n", moduleName);
		return 0;
	}

    bMask = new unsigned char[sigLen]();
    szMask = new char[sigLen]();

    /* Generate a byte mask and a x/? mask at the same time */
    for( size_t i = 0; i < sigLen; i++ ){
        if( signature[i] == ' ' ){
            szMaskIndex++;
            continue;
        }

        if( signature[i] == '?' ){
            szMask[szMaskIndex] = '?';
        } else {
            szMask[szMaskIndex] = 'x';
        }

        // End of word
        if( signature[i+1] == ' ' || signature[i+1] == '\0' ){
            byteBuffer[0] = signature[i - 1];
            byteBuffer[1] = signature[i];
            bMask[bMaskIndex] = (unsigned char)strtoul( byteBuffer, nullptr, 16 );
            bMaskIndex++;
        }
    }

	uintptr_t ret = FindPattern(baseAddress, memSize, bMask, szMask);

	if( !ret )
		MC_PRINTF_ERROR("Could not find pattern for %s\n", why );

    delete[] bMask;
    delete[] szMask;
	return ret;
}
```

`src/Utils/Patternfinder.h`:

```h
#pragma once

#include <cstdint>
#include <cstddef> // size_t

struct dlinfo_t
{
	const char* library = nullptr;
	uintptr_t address = 0;
	size_t size = 0;
};

namespace PatternFinder
{
	uintptr_t FindPattern(uintptr_t dwAddress, uintptr_t dwLen, unsigned char* bMask, const char* szMask);
	uintptr_t FindPatternInModule(const char* moduleName, const char *signature, const char* why = "NO_NAME_PROVIDED");
}
```

`src/Utils/Protobuf.cpp`:

```cpp
#include "Protobuf.h"

#include "Logger.h"

/* adapted from: https://stackoverflow.com/questions/23963978/c-protobuf-how-to-iterate-through-fields-of-message/35294011 */
void Util::Protobuf::LogMessageContents( const google::protobuf::Message *m, int tabNum ) {
    const google::protobuf::Descriptor *desc       = m->GetDescriptor();
    const google::protobuf::Reflection *refl       = m->GetReflection();

    std::string temp;

    if( !desc || !refl ){
        MC_LOGF("{ (No Desc/Refl) }\n");
        return;
    }

    int fieldCount= desc->field_count();

    if( fieldCount <= 0 ){
        MC_LOGF("{ (Empty Msg) }\n");
        return;
    }

    MC_LOGF("%s (fieldcount=%d){\n", desc->full_name().c_str(), fieldCount);
    for( int tabs = 0; tabs < tabNum; tabs++ ){ MC_LOGF("  "); }

    for(int i=0; i<fieldCount; i++) {
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( i > 0 ){
            for( int tabs = 0; tabs < tabNum; tabs++ ){ MC_LOGF("  "); }
        }
        MC_LOGF("%s %s: ", field->type_name(), field->name().c_str());
        switch( field->type() ){
            case google::protobuf::FieldDescriptor::TYPE_DOUBLE:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%f)\n", j, refl->GetRepeatedDouble( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%f\n", refl->GetDouble( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_FLOAT:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%f)\n", j, refl->GetRepeatedFloat( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%f\n", refl->GetFloat( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_INT64:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%lld)\n", j, refl->GetRepeatedInt64( *m, field, j ) );
                    }
                } else {
                    MC_LOGF( "%lld\n", refl->GetInt64( *m, field ) );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_UINT64:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%lld)\n", j, refl->GetRepeatedUInt64( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%lld\n", refl->GetUInt64( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_INT32:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%d)\n", j, refl->GetRepeatedInt32( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%d\n", refl->GetInt32( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_FIXED64:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%lld)\n", j, refl->GetRepeatedUInt64( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%lld\n", refl->GetUInt64( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_FIXED32:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)(-%d)\n", j, refl->GetRepeatedUInt32( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%d\n", refl->GetUInt32( *m, field ));
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_BOOL:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%s)\n", j, refl->GetRepeatedBool( *m, field, j ) ? "true" : "false" );
                    }
                } else {
                    MC_LOGF("%s\n", refl->GetBool( *m, field ) ? "true" : "false" );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_STRING:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-(%s)\n", j, refl->GetRepeatedStringReference( *m, field, j, &temp ).c_str() );
                    }
                } else {
                    MC_LOGF("(%s)\n", GetStringReference( m, field->name().c_str(), &temp ).c_str() );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_GROUP: // deprecated
                MC_LOGF("We found a group tag!\n");
                break;
            case google::protobuf::FieldDescriptor::TYPE_MESSAGE: {
                if ( field->is_repeated( ) ) {
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        const google::protobuf::Message &mfield = refl->GetRepeatedMessage( *m, field, j );
                        google::protobuf::Message *mcopy = mfield.New();
                        mcopy->CopyFrom(mfield);
                        Util::Protobuf::LogMessageContents( mcopy, tabNum + 1);
                        delete mcopy;
                    }
                } else {
                    const google::protobuf::Message &mfield = refl->GetMessage( *m, field );
                    google::protobuf::Message *mcopy = mfield.New();
                    mcopy->CopyFrom(mfield);
                    Util::Protobuf::LogMessageContents( mcopy, tabNum + 1);
                    delete mcopy;
                }
            }
                break;
            case google::protobuf::FieldDescriptor::TYPE_BYTES:
                MC_LOGF("Byte array found!\n");
                break;
            case google::protobuf::FieldDescriptor::TYPE_UINT32:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%d\n", j, refl->GetRepeatedUInt32( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%d\n", refl->GetUInt32( *m, field ) );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_ENUM:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%s\n", j, refl->GetRepeatedEnum( *m, field, j )->full_name().c_str() );
                    }
                } else {
                    MC_LOGF("%s\n", refl->GetEnum( *m, field )->full_name().c_str() );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_SFIXED32:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%d\n", j, refl->GetRepeatedInt32( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%d\n", refl->GetInt32( *m, field ) );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_SFIXED64:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%lld\n", j, refl->GetRepeatedInt64( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%lld\n", refl->GetInt64( *m, field ) );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_SINT32:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%d\n", j, refl->GetRepeatedInt32( *m, field , j ) );
                    }
                } else {
                    MC_LOGF("%d\n", refl->GetInt32( *m, field ) );
                }
                break;
            case google::protobuf::FieldDescriptor::TYPE_SINT64:
                if( field->is_repeated() ){
                    MC_LOGF("Repeated Field!size(%d)\n", refl->FieldSize( *m, field ));
                    for( int j = 0; j < refl->FieldSize( *m, field ); j++ ){
                        MC_LOGF("repeated:(#%d)-%lld\n", j, refl->GetRepeatedInt64( *m, field, j ) );
                    }
                } else {
                    MC_LOGF("%lld\n", refl->GetInt64( *m, field ) );
                }
                break;

            default:
                MC_LOGF("Can't tell Value! Unknown Type!\n");
                break;
        }
    }
    for( int tabs = 0; tabs < std::max(0, tabNum-1); tabs++ ){ MC_LOGF("  "); }
    MC_LOGF("}\n");
}

bool Util::Protobuf::EditFieldTraverseInt32( google::protobuf::Message *msg, const char *name, int32_t value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedInt32( msg, field, j, value );
                }
            } else {
                refl->SetInt32( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseInt32( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseInt32( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseUInt32( google::protobuf::Message *msg, const char *name, uint32_t value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedUInt32( msg, field, j, value );
                }
            } else {
                refl->SetUInt32( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseUInt32( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseUInt32( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseInt64( google::protobuf::Message *msg, const char *name, int64_t value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedInt64( msg, field, j, value );
                }
            } else {
                refl->SetInt64( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseInt64( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseInt64( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseUInt64( google::protobuf::Message *msg, const char *name, uint64_t value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedUInt64( msg, field, j, value );
                }
            } else {
                refl->SetUInt64( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseUInt64( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseUInt64( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseFloat( google::protobuf::Message *msg, const char *name, float value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedFloat( msg, field, j, value );
                }
            } else {
                refl->SetFloat( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseFloat( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseFloat( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseDouble( google::protobuf::Message *msg, const char *name, double value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedDouble( msg, field, j, value );
                }
            } else {
                refl->SetDouble( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseDouble( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseDouble( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

bool Util::Protobuf::EditFieldTraverseBool( google::protobuf::Message *msg, const char *name, bool value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedBool( msg, field, j, value );
                }
            } else {
                refl->SetBool( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseBool( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseBool( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

/*
bool Util::Protobuf::EditFieldTraverseString( google::protobuf::Message *msg, const char *name, const std::string& value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedString( msg, field, j, value );
                }
            } else {
                refl->SetString( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseString( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseString( mfield, name, value );
            }
        }
    }

    return foundTarget;
}
*/
bool Util::Protobuf::EditFieldTraverseEnumValue( google::protobuf::Message *msg, const char *name, int value ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return false;

    bool foundTarget = false;
    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    refl->SetRepeatedEnumValue( msg, field, j, value );
                }
            } else {
                refl->SetEnumValue( msg, field, value );
            }
            foundTarget = true;
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse

            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    foundTarget |= EditFieldTraverseEnumValue( mfield, name, value );
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                foundTarget |= EditFieldTraverseEnumValue( mfield, name, value );
            }
        }
    }

    return foundTarget;
}

std::string deadString = "fail";

const std::string& Util::Protobuf::GetStringReference( const google::protobuf::Message *msg, const char *name, std::string *scratch ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    if( !desc || !refl )
        return deadString;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetStringReference( *msg, field, scratch );
                //return refl->GetInt32( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( (google::protobuf::Message*)msg, field );
            return GetStringReference( mfield, name, scratch );
        }
    }

    return deadString;
}

std::optional<int32_t> Util::Protobuf::GetFieldTraverseInt32( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<int32_t> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetInt32( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseInt32( mfield, name );
        }
    }

    return ret;
}

std::optional<uint32_t> Util::Protobuf::GetFieldTraverseUInt32( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<uint32_t> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetUInt32( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseUInt32( mfield, name );
        }
    }

    return ret;
}

std::optional<int64_t> Util::Protobuf::GetFieldTraverseInt64( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<int64_t> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetInt64( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseInt64( mfield, name );
        }
    }

    return ret;
}

std::optional<uint64_t> Util::Protobuf::GetFieldTraverseUint64( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<uint64_t> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetUInt64( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseUint64( mfield, name );
        }
    }

    return ret;
}

std::optional<float> Util::Protobuf::GetFieldTraverseFloat( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<float> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetFloat( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseFloat( mfield, name );
        }
    }

    return ret;
}


std::optional<double> Util::Protobuf::GetFieldTraverseDouble( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<double> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetDouble( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseDouble( mfield, name );
        }
    }

    return ret;
}

std::optional<bool> Util::Protobuf::GetFieldTraverseBool( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<bool> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetBool( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseBool( mfield, name );
        }
    }

    return ret;
}

std::optional<std::string> Util::Protobuf::GetFieldTraverseString( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<std::string> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetString( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseString( mfield, name );
        }
    }

    return ret;
}

std::optional<int> Util::Protobuf::GetFieldTraverseEnumValue( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::optional<int> ret = std::nullopt;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field || field->is_repeated() ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( !field->is_repeated() ){
                return refl->GetEnumValue( *msg, field );
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
            ret = GetFieldTraverseEnumValue( mfield, name );
        }
    }

    return ret;
}

























































std::vector<int32_t> Util::Protobuf::GetRepeatedFieldTraverseInt32( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<int32_t> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_INT32 ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedInt32( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetInt32( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type INT32!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<int32_t> more = GetRepeatedFieldTraverseInt32( mfield, name );
                    for(int k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<int32_t> more = GetRepeatedFieldTraverseInt32( mfield, name );
                for(int k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<uint32_t> Util::Protobuf::GetRepeatedFieldTraverseUInt32( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<uint32_t> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_UINT32 ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedUInt32( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetUInt32( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_UINT32!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<uint32_t> more = GetRepeatedFieldTraverseUInt32( mfield, name );
                    for(unsigned int k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<uint32_t> more = GetRepeatedFieldTraverseUInt32( mfield, name );
                for(unsigned int k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}


std::vector<int64_t> Util::Protobuf::GetRepeatedFieldTraverseInt64( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<int64_t> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_INT64 ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedInt64( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetInt64( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_INT64!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<int64_t> more = GetRepeatedFieldTraverseInt64( mfield, name );
                    for(long k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<int64_t> more = GetRepeatedFieldTraverseInt64( mfield, name );
                for(long k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<uint64_t> Util::Protobuf::GetRepeatedFieldTraverseUInt64( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<uint64_t> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_UINT64 ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedUInt64( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetUInt64( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_UINT64!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<uint64_t> more = GetRepeatedFieldTraverseUInt64( mfield, name );
                    for(unsigned long k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<uint64_t> more = GetRepeatedFieldTraverseUInt64( mfield, name );
                for(unsigned long k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<float> Util::Protobuf::GetRepeatedFieldTraverseFloat( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<float> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedFloat( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetFloat( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_FLOAT!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<float> more = GetRepeatedFieldTraverseFloat( mfield, name );
                    for(float k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<float> more = GetRepeatedFieldTraverseFloat( mfield, name );
                for(float k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<double> Util::Protobuf::GetRepeatedFieldTraverseDouble( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<double> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedDouble( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetDouble( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_DOUBLE!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<double> more = GetRepeatedFieldTraverseDouble( mfield, name );
                    for(double k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<double> more = GetRepeatedFieldTraverseDouble( mfield, name );
                for(double k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<bool> Util::Protobuf::GetRepeatedFieldTraverseBool( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<bool> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedBool( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetBool( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_BOOL!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<bool> more = GetRepeatedFieldTraverseBool( mfield, name );
                    for(auto && k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<bool> more = GetRepeatedFieldTraverseBool( mfield, name );
                for(auto && k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<std::string> Util::Protobuf::GetRepeatedFieldTraverseString( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<std::string> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_STRING ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedString( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetString( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_STRING!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<std::string> more = GetRepeatedFieldTraverseString( mfield, name );
                    for(const auto & k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<std::string> more = GetRepeatedFieldTraverseString( mfield, name );
                for(const auto & k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}

std::vector<int> Util::Protobuf::GetRepeatedFieldTraverseEnumValue( google::protobuf::Message *msg, const char *name ) {
    const google::protobuf::Descriptor *desc       = msg->GetDescriptor();
    const google::protobuf::Reflection *refl       = msg->GetReflection();

    std::vector<int> ret;
    if( !desc || !refl )
        return ret;

    int fieldCount = desc->field_count();
    for( int i = 0; i < fieldCount; i++ ){
        const google::protobuf::FieldDescriptor *field = desc->field(i);
        if( !field ) continue;

        if( !strcmp( field->name().c_str(), name ) ){
            if( field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM ){
                if( field->is_repeated() ){
                    for( int j = 0; j < refl->FieldSize(*msg, field); j++ ){
                        ret.push_back( refl->GetRepeatedEnumValue( *msg, field, j ) );
                    }
                } else {
                    ret.push_back( refl->GetEnumValue( *msg, field ) );
                }
            } else {
                MC_LOGF("FIELD (%s) is NOT type TYPE_ENUM!\n", name);
            }
        }

        if( field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE ){ // recurse
            if( field->is_repeated() ){
                for( int j = 0; j < refl->FieldSize( *msg, field ); j++ ){
                    google::protobuf::Message *mfield = refl->MutableRepeatedMessage( msg, field, j );
                    std::vector<int> more = GetRepeatedFieldTraverseEnumValue( mfield, name );
                    for(int k : more){
                        ret.push_back( k );
                    }
                }
            } else {
                google::protobuf::Message *mfield = refl->MutableMessage( msg, field );
                std::vector<int> more = GetRepeatedFieldTraverseEnumValue( mfield, name );
                for(int k : more){
                    ret.push_back( k );
                }
            }
        }
    }

    return ret;
}














```

`src/Utils/Protobuf.h`:

```h
#pragma once


#include <google/protobuf/text_format.h>
#include <string>
#include <cstdint>
#include <optional>
#include <vector>

/* Various functions that deal with protobuf messages */
namespace Util::Protobuf
{
    void LogMessageContents( const google::protobuf::Message* m, int tabNum = 0 );

    /* These return true if found/changed */
    bool EditFieldTraverseInt32( google::protobuf::Message* msg, const char *name, int32_t value );
    bool EditFieldTraverseUInt32( google::protobuf::Message* msg, const char *name, uint32_t value );
    bool EditFieldTraverseInt64( google::protobuf::Message* msg, const char *name, int64_t value );
    bool EditFieldTraverseUInt64( google::protobuf::Message* msg, const char *name, uint64_t value );
    bool EditFieldTraverseFloat( google::protobuf::Message* msg, const char *name, float value );
    bool EditFieldTraverseDouble( google::protobuf::Message* msg, const char *name, double value );
    bool EditFieldTraverseBool( google::protobuf::Message* msg, const char *name, bool value );
    //bool EditFieldTraverseString( google::protobuf::Message *msg, const char *name, const std::string& value ); // doesn't work - use protos instead.
    bool EditFieldTraverseEnumValue( google::protobuf::Message* msg, const char *name, int value );

    /* This is the only way to get a string - To set a string, you will need to use proto file */
    const std::string& GetStringReference( const google::protobuf::Message* msg, const char *name, std::string *scratch );

    std::optional<int32_t> GetFieldTraverseInt32( google::protobuf::Message* msg, const char *name );
    std::optional<uint32_t> GetFieldTraverseUInt32( google::protobuf::Message* msg, const char *name );
    std::optional<int64_t> GetFieldTraverseInt64( google::protobuf::Message* msg, const char *name );
    std::optional<uint64_t> GetFieldTraverseUint64( google::protobuf::Message* msg, const char *name );
    std::optional<float> GetFieldTraverseFloat( google::protobuf::Message* msg, const char *name );
    std::optional<double> GetFieldTraverseDouble( google::protobuf::Message* msg, const char *name );
    std::optional<bool> GetFieldTraverseBool( google::protobuf::Message* msg, const char *name );
    std::optional<std::string> GetFieldTraverseString( google::protobuf::Message* msg, const char *name );
    std::optional<int> GetFieldTraverseEnumValue( google::protobuf::Message* msg, const char *name );

    /* Vector returned can be empty */
    std::vector<int32_t> GetRepeatedFieldTraverseInt32( google::protobuf::Message* msg, const char *name );
    std::vector<uint32_t> GetRepeatedFieldTraverseUInt32( google::protobuf::Message* msg, const char *name );
    std::vector<int64_t> GetRepeatedFieldTraverseInt64( google::protobuf::Message* msg, const char *name );
    std::vector<uint64_t> GetRepeatedFieldTraverseUInt64( google::protobuf::Message* msg, const char *name );
    std::vector<float> GetRepeatedFieldTraverseFloat( google::protobuf::Message* msg, const char *name );
    std::vector<double> GetRepeatedFieldTraverseDouble( google::protobuf::Message* msg, const char *name );
    std::vector<bool> GetRepeatedFieldTraverseBool( google::protobuf::Message* msg, const char *name );
    std::vector<std::string> GetRepeatedFieldTraverseString( google::protobuf::Message* msg, const char *name );
    std::vector<int> GetRepeatedFieldTraverseEnumValue( google::protobuf::Message* msg, const char *name );
}
```

`src/Utils/Util.cpp`:

```cpp
#include "Util.h"

#include <chrono> // chrono time stuff

long Util::GetEpochMs()
{
	auto duration = std::chrono::system_clock::now().time_since_epoch();

	return std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
}

```

`src/Utils/Util.h`:

```h
#pragma once

namespace Util
{
	long GetEpochMs();
}
```

`src/Utils/Util_sdk.cpp`:

```cpp
#include "Util_sdk.h"

#include "Logger.h"
#include "../Interfaces.h"

#include <link.h>

ButtonCode_t Util::GetButtonCode(const char* buttonName)
{
	for (int i = 0; i < ButtonCode_t::LAST_KEY_VALUE; i++)
	{
		const char* currentButton = inputSystem->CodeToString((ButtonCode_t) i);
		if (strcmp(currentButton, buttonName) == 0)
			return (ButtonCode_t) i;
	}

	return ButtonCode_t::BUTTON_CODE_INVALID;
}


static const char* DataFieldType2String( fieldtype_t type )
{
    switch( (int)type )
    {
        CASE_STRING(FIELD_VOID);
        CASE_STRING(FIELD_FLOAT);
        CASE_STRING(FIELD_STRING);
        CASE_STRING(FIELD_VECTOR);
        CASE_STRING(FIELD_QUATERNION);
        CASE_STRING(FIELD_INTEGER);
        CASE_STRING(FIELD_BOOLEAN);
        CASE_STRING(FIELD_SHORT);
        CASE_STRING(FIELD_CHARACTER);
        CASE_STRING(FIELD_COLOR32);
        CASE_STRING(FIELD_EMBEDDED);
        CASE_STRING(FIELD_CUSTOM);
        CASE_STRING(FIELD_CLASSPTR);
        CASE_STRING(FIELD_EHANDLE);
        CASE_STRING(FIELD_POSITION_VECTOR);
        CASE_STRING(FIELD_TIME);
        CASE_STRING(FIELD_TICK);
        CASE_STRING(FIELD_SOUNDNAME);
        CASE_STRING(FIELD_INPUT);
        CASE_STRING(FIELD_FUNCTION);
        CASE_STRING(FIELD_VMATRIX);
        CASE_STRING(FIELD_VMATRIX_WORLDSPACE);
        CASE_STRING(FIELD_MATRIX3X4_WORLDSPACE);
        CASE_STRING(FIELD_INTERVAL);
        CASE_STRING(FIELD_UNUSED);
        CASE_STRING(FIELD_VECTOR2D);
        CASE_STRING(FIELD_INTEGER64);
        CASE_STRING(FIELD_VECTOR4D);
        CASE_STRING(FIELD_RESOURCE);
        CASE_STRING(FIELD_TYPEUNKNOWN);
        CASE_STRING(FIELD_CSTRING);
        CASE_STRING(FIELD_HSCRIPT);
        CASE_STRING(FIELD_VARIANT);
        CASE_STRING(FIELD_UINT64);
        CASE_STRING(FIELD_FLOAT64);
        CASE_STRING(FIELD_POSITIVEINTEGER_OR_NULL);
        CASE_STRING(FIELD_HSCRIPT_NEW_INSTANCE);
        CASE_STRING(FIELD_UINT);
        CASE_STRING(FIELD_UTLSTRINGTOKEN);
        CASE_STRING(FIELD_QANGLE);
        CASE_STRING(FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_VECTOR);
        CASE_STRING(FIELD_HMATERIAL);
        CASE_STRING(FIELD_HMODEL);
        CASE_STRING(FIELD_NETWORK_QUANTIZED_VECTOR);
        CASE_STRING(FIELD_NETWORK_QUANTIZED_FLOAT);
        CASE_STRING(FIELD_DIRECTION_VECTOR_WORLDSPACE);
        CASE_STRING(FIELD_QANGLE_WORLDSPACE);
        CASE_STRING(FIELD_QUATERNION_WORLDSPACE);
        CASE_STRING(FIELD_HSCRIPT_LIGHTBINDING);
        CASE_STRING(FIELD_V8_VALUE);
        CASE_STRING(FIELD_V8_OBJECT);
        CASE_STRING(FIELD_V8_ARRAY);
        CASE_STRING(FIELD_V8_CALLBACK_INFO);
        CASE_STRING(FIELD_UTLSTRING);
        CASE_STRING(FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_POSITION_VECTOR);
        CASE_STRING(FIELD_HRENDERTEXTURE);
        CASE_STRING(FIELD_TYPECOUNT);
        default:
            return "UNKNOWN DATAFIELD TYPE";
    }
}
void Util::SpewDataMap( Datamap *dMap, bool toLogFile ) {

	while( dMap ){
        if( toLogFile ){
            MC_LOGF( "\nStart of Pred Map for %s\n", dMap->className );
        } else {
            MC_PRINTF( "Start of Pred Map for: %s\n", dMap->className );
        }
		for( uint64_t i = 0; i < dMap->numFields; i++ ){
			if( !dMap->dataDesc[i].fieldName )
				continue;

            if( toLogFile ){
                MC_LOGF( "-%s - [0x%x] - (%s)\n", dMap->dataDesc[i].fieldName, dMap->dataDesc[i].fieldOffset[TD_OFFSET_NORMAL], DataFieldType2String( dMap->dataDesc[i].type ) );
            } else {
                MC_PRINTF( "-%s - [0x%x] - (%s)\n", dMap->dataDesc[i].fieldName, dMap->dataDesc[i].fieldOffset[TD_OFFSET_NORMAL], DataFieldType2String( dMap->dataDesc[i].type ) );
            }
            if( dMap->dataDesc[i].type == FIELD_EMBEDDED ){
                if( dMap->dataDesc[i].td ){
                    if( toLogFile ){
                        MC_LOGF("Recursing for Property: %s(%s)\n", dMap->dataDesc[i].fieldName, dMap->dataDesc[i].td->className ? dMap->dataDesc[i].td->className : "NULL_NAME");
                    } else {
                        MC_PRINTF("Recursing for Property: %s(%s)\n", dMap->dataDesc[i].fieldName, dMap->dataDesc[i].td->className ? dMap->dataDesc[i].td->className : "NULL_NAME");
                    }
                    Util::SpewDataMap( dMap->dataDesc[i].td, toLogFile );
                    if( toLogFile ){
                        MC_LOGF("^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n");
                    } else {
                        MC_PRINTF("^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n");
                    }
                }
            }
		}
        if( toLogFile ){
            MC_LOGF( "^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n" );
        } else {
            MC_PRINTF( "^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n" );
        }
        dMap = dMap->baseMap;
	}
}

int Util::FindDataMapElementOffset( Datamap *dMap, const char *element ) {
    while( dMap ){
        for( uint64_t i = 0; i < dMap->numFields; i++ ){
            if( !dMap->dataDesc[i].fieldName )
                continue;

            if( !strcmp(dMap->dataDesc[i].fieldName, element) )
                return dMap->dataDesc[i].fieldOffset[TD_OFFSET_NORMAL];

            if( dMap->dataDesc[i].type == FIELD_EMBEDDED ){
                if( dMap->dataDesc[i].td ){

                    int temp = Util::FindDataMapElementOffset( dMap->dataDesc[i].td, element );
                    if( temp != 0 )
                        return temp;
                }
            }
        }
        dMap = dMap->baseMap;
    }


    return 0;
}
ConVar *Util::RegisterConVar( const char *name, const char *defaultValue, uint32_t flags, const char *helpString, bool bMin, float fMin, bool bMax, float fMax ) {
	ConCommandBase* sens = cvar->FindCommandBase("m_yaw");
    ConVar* command = (ConVar*)new char[sizeof(ConVar)];

    // copy the vtable/layout from the existing convar
	memcpy(command, sens, sizeof(ConVar));

	command->m_bRegistered = false;
	command->m_nFlags = flags;
	command->m_pNext = nullptr;
	command->parent = command;
	command->bHasMin = bMin;
	command->bHasMax = bMax;
	command->m_fMinVal = fMin;
	command->m_fMaxVal = fMax;
    command->m_Value.m_fValue = strtof(defaultValue, nullptr);
    command->m_Value.m_nValue = atoi(defaultValue);

	size_t nameLen = strlen(name) + 1;
	command->m_pszName = new char[nameLen];
	if( command->m_pszName && name ){
		strncpy( command->m_pszName, name, nameLen);
	} else {
        MC_PRINTF_ERROR("Error allocating space for ConVar name (%s)!\n", name);
		return nullptr;
	}

	size_t valueLen = strlen(defaultValue) + 1;
	command->m_Value.m_pszString = new char[valueLen];
    command->m_pszDefaultValue = new char[valueLen];

	if( command->m_Value.m_pszString && command->m_pszDefaultValue && defaultValue ){
		strncpy( command->m_Value.m_pszString, defaultValue, valueLen );
        strncpy( command->m_pszDefaultValue, defaultValue, valueLen );
	} else {
        MC_PRINTF_ERROR("[%s]Error allocating space for ConVar values (%s)!\n", name);
		return nullptr;
	}

	if( helpString ){
		size_t descLen = strlen( helpString ) + 1;
		command->m_pszHelpString = new char[descLen];
		if( command->m_pszHelpString ){
			strncpy( command->m_pszHelpString, helpString, descLen );
		} else{
			MC_PRINTF_ERROR("[%s]Error allocating space for ConVar description (%s)!\n", name);
			return nullptr;
		}
	} else {
		command->m_pszHelpString = nullptr;
	}

	cvar->RegisterConCommand( command );
	Util::createdConvars.push_back(command);

    return cvar->FindVar(name);
}

void Util::SpewScriptScopes( GameScriptScopesWrapper *scopes, bool toLogFile ) {
    for( size_t i = 0; i < scopes->numScopes; i++ ){
        MC_LOGF("------ %s(%d) ------\n", scopes->scopes[i]->name, scopes->scopes[i]->numFuncs);

        for( size_t j = 0; j < scopes->scopes[i]->numFuncs; j++ ){
            ScopeFunction &func = scopes->scopes[i]->funcs[j];
            MC_LOGF("%s %s ( ", GetArgTypeString(func.returnType), func.name);
            const char *names = func.argNames;
            if( names ){
                for( int k = 0; k < func.argNum; k++ ){
                    MC_LOGF( "%s %s, ", GetArgTypeString( func.argTypes[k] ), names );
                    names += strlen( names ) + 1;
                }
            } else {
                for( int k = 0; k < func.argNum; k++ ){
                    MC_LOGF( "%s noname_arg_%d, ", GetArgTypeString( func.argTypes[k] ), k );
                }
            }
            MC_LOGF(")\n");
        }
    }
}

void* Util::GetScriptScopeFunction( GameScriptScopesWrapper *scopes, const char *exactName ) {
    MC_LOGF("GetScriptScopeFunction called!\n");
    for( size_t i = 0; i < scopes->numScopes; i++ ) {
        for ( size_t j = 0; j < scopes->scopes[i]->numFuncs; j++ ) {
            ScopeFunction &func = scopes->scopes[i]->funcs[j];
            if( !strcmp( func.name, exactName ) ){
                MC_LOGF("Found func at %p\n", func.function);
                return func.function;
            }
        }
    }
    return nullptr;
}


bool Util::ReadParticleFiles( const char *pathID, const char *blacklistFileName, const char *tracklistFileName ) {
    char linebuffer[256];
    char *scan;
    std::string temp;

    FileHandle_t blacklist = fileSystem->Open( blacklistFileName, "r", pathID );
    FileHandle_t tracklist = fileSystem->Open( tracklistFileName, "r", pathID );

    if( blacklist ){
        while( fileSystem->ReadLine( linebuffer, sizeof( linebuffer ), blacklist) ) {
            scan = linebuffer;
            temp.clear();
            while( *scan && (*scan != ' ') && (*scan != '\n') ){
                temp.push_back( *scan );
                scan++;
            }
            blacklistedParticles.push_back( temp );
        }
        fileSystem->Close( blacklist );
    }

    if( tracklist ){
        while( fileSystem->ReadLine( linebuffer, sizeof( linebuffer ), tracklist) ) {
            scan = linebuffer;
            temp.clear();
            while( *scan && (*scan != ' ') && (*scan != '\n') ){
                temp.push_back( *scan );
                scan++;
            }
            trackedParticles.push_back( temp );
        }
        fileSystem->Close( tracklist );
    }

    for( const std::string& particle : blacklistedParticles ){
        MC_LOGF("Blacklisted particle - (%s)\n", particle.c_str());
    }

    for( const std::string& particle : trackedParticles ){
        MC_LOGF("Tracked particle - (%s)\n", particle.c_str());
    }

    return true;
}

GFX_API Util::GetGraphicsApiType() {
    static GFX_API ret = GFX_API::UNKNOWN;

    dl_iterate_phdr([] (struct dl_phdr_info* info, size_t, void*) {
        /* Only one of the rendersystem dll's will be loaded at once. */
        if( strstr(info->dlpi_name, "librendersystemgl") ){
            ret = GFX_API::OPENGL;
        }
        if( strstr(info->dlpi_name, "librendersystemvulkan") ){
            ret = GFX_API::VULKAN;
        }

        return 0;
    }, nullptr);

    return ret;
}
```

`src/Utils/Util_sdk.h`:

```h
#pragma once

#include "../SDK/IInputSystem.h" //ButtonCode
#include "../SDK/Convar.h"
#include "../SDK/CPanoramaGameScriptScope.h"
#include "../SDK/Datamap.h"

#include <cstdint>
#include <vector>
#include <string>

enum GFX_API
{
    UNKNOWN = -1,
    OPENGL = 0,
    VULKAN = 1,
    DIRECTX = 2,
};

namespace Util
{
    inline std::vector<ConVar*> createdConvars;

	// List of particles that should hid or tracked for performance reasons.
	// Linear will be faster than a hashmap until about ~400 entries.
	inline std::vector<std::string> blacklistedParticles;
	inline std::vector<std::string> trackedParticles;

	ButtonCode_t GetButtonCode(const char* buttonName);
	ConVar *RegisterConVar( const char *name, const char *defaultValue, uint32_t flags = FCVAR_CLIENTDLL | FCVAR_ARCHIVE, const char *helpString = nullptr, bool bMin = false, float fMin = 0.0f, bool bMax = false, float fMax = false );

	void SpewDataMap( Datamap *dMap, bool toLogFile = false );
	void SpewScriptScopes( GameScriptScopesWrapper *scopes, bool toLogFile = false );
	void* GetScriptScopeFunction( GameScriptScopesWrapper *scopes, const char *exactName );

	int FindDataMapElementOffset( Datamap *dMap, const char *element );

	bool ReadParticleFiles( const char *pathID, const char *blacklistFileName = nullptr, const char *tracklistFileName = nullptr );

	GFX_API GetGraphicsApiType(void);
}
```

`src/Utils/Vmt.h`:

```h
#pragma once

#include "Memory.h"

#include <cstdint>
#include <vector>

class VMT;
inline std::vector<VMT*> createdVMTs;

inline uint32_t CountVMs( void* interface )
{
	auto** vmt = reinterpret_cast<uintptr_t**>(interface);

	uint32_t methodCount = 0;

	while ( vmt && (*vmt)[methodCount] && ( Memory::GetProtectionFlags( (*vmt)[methodCount] ) & PF_X ) )
		methodCount++;

	return methodCount;
}

class VMT
{
public:
	uintptr_t* vmt;
	uintptr_t** interface = nullptr;
	uintptr_t* original_vmt = nullptr;
    size_t method_count = 0;
	bool hasRTTI = false;
    int32_t rttiPrefix = 0;
    uintptr_t* applied_vmt = nullptr;

    ~VMT( ){
        ReleaseVMT();
        delete[] vmt;
    }
	// rttiPrefix 2??? Wtf? Yeah read this: https://web.archive.org/web/20170701021444/https://spockwangs.github.io/2011/01/31/cpp-object-model.html
	explicit VMT(void* interface, bool copyRTTI = true, int32_t rttiPrefixAmount = 2)
	{
		this->interface = reinterpret_cast<uintptr_t**>(interface);

		method_count = CountVMs(interface) + 2 + rttiPrefixAmount;

		original_vmt = *this->interface;

        // Copy the Original Vtable.
		if( copyRTTI ){
			vmt = new uintptr_t[method_count + 1];
			memcpy(vmt, &original_vmt[-rttiPrefixAmount], (sizeof(uintptr_t) * method_count) + sizeof(uintptr_t));
			hasRTTI = true;
            rttiPrefix = rttiPrefixAmount;
		} else {
			vmt = new uintptr_t[method_count];
			memcpy(vmt, original_vmt, sizeof(uintptr_t) * method_count);
		}

        // Make sure to "NULL terminate" our new array of pointers.
        memset(&vmt[method_count], 0, sizeof(uintptr_t));

        createdVMTs.push_back(this);
    }

	// Hook virtual method
	template <typename func>
	void HookVM(func method, size_t methodIndex)
	{
		vmt[hasRTTI ? methodIndex + rttiPrefix : methodIndex] = reinterpret_cast<uintptr_t>(method);
	}

	template<typename Fn>
	Fn GetOriginalMethod(size_t methodIndex)
	{
		return reinterpret_cast<Fn>(original_vmt[methodIndex]);
	}

	void ApplyVMT()
	{
		if( hasRTTI ) {
			*this->interface = &vmt[rttiPrefix];
		} else {
			*this->interface = vmt;
		}
        applied_vmt = *this->interface;
	}

	void ReleaseVMT()
	{
		/* Check if vtable is still set to ours. If it's not, something changed in memory and we should just leave it alone */
		if( *this->interface == applied_vmt ){
            *this->interface = original_vmt;
		}
	}
};

```

`src/Utils/subhook/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8.12)
project(subhook C)

if(POLICY CMP0042)
  cmake_policy(SET CMP0042 NEW)
endif()

list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)

set(SUBHOOK_VERSION_MAJOR 0)
set(SUBHOOK_VERSION_MINOR 6)
set(SUBHOOK_VERSION_PATCH 0)

set(SUBHOOK_VERSION ${SUBHOOK_VERSION_MAJOR})
set(SUBHOOK_VERSION ${SUBHOOK_VERSION}.${SUBHOOK_VERSION_MINOR})
set(SUBHOOK_VERSION ${SUBHOOK_VERSION}.${SUBHOOK_VERSION_PATCH})

macro(subhook_add_option_var name type default_value description)
  set(${name}_DEFAULT ${default_value})
  if(DEFINED ${name})
    set(${name}_DEFAULT ${${name}})
  endif()
  set(${name} ${${name}_DEFAULT} CACHE ${type} ${description})
endmacro()

subhook_add_option_var(SUBHOOK_STATIC BOOL OFF "Build as a static library")
subhook_add_option_var(SUBHOOK_INSTALL
  BOOL ON "Enable installation and packaging of targets/files with CPack")
subhook_add_option_var(SUBHOOK_TESTS BOOL ON "Enable tests")
subhook_add_option_var(SUBHOOK_FORCE_32BIT
  BOOL OFF "Configure for compiling 32-bit binaries (on 64-bit systems)")

set(SUBHOOK_HEADERS subhook.h)
set(SUBHOOK_SOURCES subhook.c subhook_private.h subhook_x86.c)
if(WIN32)
  list(APPEND SUBHOOK_SOURCES subhook_windows.c)
elseif(UNIX)
  list(APPEND SUBHOOK_SOURCES subhook_unix.c)
endif()

add_definitions(-DSUBHOOK_IMPLEMENTATION -DSUBHOOK_SEPARATE_SOURCE_FILES)

if(SUBHOOK_STATIC)
  add_library(subhook STATIC ${SUBHOOK_HEADERS} ${SUBHOOK_SOURCES})
else()
  add_library(subhook SHARED ${SUBHOOK_HEADERS} ${SUBHOOK_SOURCES})
endif()

include_directories(${CMAKE_CURRENT_SOURCE_DIR})
set_property(DIRECTORY ${CMAKE_SOURCE_DIR}
             APPEND PROPERTY INCLUDE_DIRECTORIES ${CMAKE_CURRENT_SOURCE_DIR})

if(CMAKE_COMPILER_ID MATCHES GNU OR CMAKE_C_COMPILER_ID MATCHES Clang)
  set_property(TARGET subhook
               APPEND_STRING PROPERTY COMPILE_FLAGS "-Wall -Wextra")
endif()

if(SUBHOOK_FORCE_32BIT)
  if(APPLE)
    set_target_properties(subhook PROPERTIES OSX_ARCHITECTURES i386)
  endif()
  if(UNIX)
    set_property(TARGET subhook APPEND_STRING PROPERTY
                 COMPILE_FLAGS " -m32")
    set_property(TARGET subhook APPEND_STRING PROPERTY LINK_FLAGS " -m32")
  endif()
endif()

if(SUBHOOK_STATIC)
  add_definitions(-DSUBHOOK_STATIC)
  set_property(DIRECTORY ${CMAKE_SOURCE_DIR}
               APPEND PROPERTY COMPILE_DEFINITIONS SUBHOOK_STATIC)
endif()

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

if(SUBHOOK_INSTALL)
  install(TARGETS subhook LIBRARY DESTINATION lib
                          ARCHIVE DESTINATION lib
                          RUNTIME DESTINATION bin)
  install(FILES ${SUBHOOK_HEADERS} DESTINATION include)
endif()

set(CPACK_PACKAGE_NAME ${PROJECT_NAME})
set(CPACK_PACKAGE_VERSION_MAJOR ${SUBHOOK_VERSION_MAJOR})
set(CPACK_PACKAGE_VERSION_MINOR ${SUBHOOK_VERSION_MINOR})
set(CPACK_PACKAGE_VERSION_PATCH ${SUBHOOK_VERSION_PATCH})

include(CPack)
include(CTest)

if(BUILD_TESTING AND SUBHOOK_TESTS)
  enable_testing()
  add_subdirectory(tests)
endif()

```

`src/Utils/subhook/LICENSE.txt`:

```txt
Copyright (c) 2012-2018 Zeex
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

```

`src/Utils/subhook/README.md`:

```md
[![Build Status][build_status]][build]
[![Build Status - Windows][build_status_win]][build_win]

SubHook is a super-simple hooking library for C and C++ that works on Windows,
Linux and macOS. It supports x86 only (32-bit and 64-bit).

Installation
------------

Simply copy the files to your project and include subhook.c in your build.
The other source files wil be `#included` by the main C file automatically
depending on the OS and achitecture.

Use of CMake is not mandatory, the library can be built wihtout it (no extra
build configuration required).

Examples
--------

In the following examples `foo` is some function or a function pointer that
takes a single argument of type `int` and uses the same calling convention
as `my_foo` (depends on compiler).

### Basic usage

```c
#include <stdio.h>
#include <subhook.h>

subhook_t foo_hook;

void my_foo(int x) {
  /* Remove the hook so that you can call the original function. */
  subhook_remove(foo_hook);

  printf("foo(%d) called\n", x);
  foo(x);

  /* Install the hook back to intercept further calls. */
  subhook_install(foo_hook);
}

int main() {
  /* Create a hook that will redirect all foo() calls to to my_foo(). */
  foo_hook = subhook_new((void *)foo, (void *)my_foo, 0);

  /* Install it. */
  subhook_install(foo_hook);

  foo(123);

  /* Remove the hook and free memory when you're done. */
  subhook_remove(foo_hook);
  subhook_free(foo_hook);
}
```

### Trampolines

Trampolines have been removed because they don't work xD!

### C++

```c++
#include <iostream>
#include <subhook.h>

subhook::Hook foo_hook;

typedef void (*foo_func)(int x);

void my_foo(int x) {
  // ScopedHookRemove removes the specified hook and automatically re-installs
  // it when the object goes out of scope (thanks to C++ destructors).
  subhook::ScopedHookRemove remove(&foo_hook);

  std::cout << "foo(" << x << ") called" << std::endl;
  foo(x + 1);
}

int main() {
  foo_hook.Install((void *)foo, (void *)my_foo);
}
```

Known issues
------------

* `subhook_get_trampoline()` may return NULL because only a small subset of
  x86 instructions is supported by the disassembler in this library (just 
  common prologue instructions). As a workaround you can plug in a more
  advanced instruction length decoder using `subhook_set_disasm_handler()`.

* If a target function (the function you are hooking) is less than N bytes
  in length, for example if it's a short 2-byte jump to a nearby location
  (sometimes compilers generate code like this), then you will not be able
  to hook it.

  N is 5 by default: 1 byte for jmp opcode + 4 bytes for offset. But if you 
  enable the use of 64-bit offsets in 64-bit mode N becomes 14 (see the 
  definition of `subhook_jmp64`).

* Some systems protect executable code form being modified at runtime, which
  will not allow you to install hooks, or don't allow to mark heap-allocated
  memory as executable, which prevents the use of trampolines.

  For example, on Fedora you can have such problems because of SELinux (though
  you can disable it or exclude your files).

License
-------

Licensed under the 2-clause BSD license.

[build]: https://travis-ci.org/Zeex/subhook
[build_status]: https://travis-ci.org/Zeex/subhook.svg?branch=master
[build_win]: https://ci.appveyor.com/project/Zeex/subhook/branch/master
[build_status_win]: https://ci.appveyor.com/api/projects/status/q5sp0p8ahuqfh8e4/branch/master?svg=true

```

`src/Utils/subhook/appveyor.yml`:

```yml
version: '{build}'

platform:
  - x86
  - x64
configuration:
  - Release
environment:
  CTEST_OUTPUT_ON_FAILURE: ON

install:
  - choco install -y yasm
before_build:
  - cmake .
build_script:
  - cmake --build . --config %CONFIGURATION%
test_script:
  - ctest --build-config %CONFIGURATION%
```

`src/Utils/subhook/cmake/FindYasm.cmake`:

```cmake
include(FindPackageHandleStandardArgs)

find_file(YASM_EXECUTABLE NAMES yasm yasm.exe)
mark_as_advanced(YASM_EXECUTABLE)

find_package_handle_standard_args(Yasm
  FOUND_VAR YASM_FOUND
  REQUIRED_VARS YASM_EXECUTABLE
)

```

`src/Utils/subhook/subhook.c`:

```c
/*
 * Copyright (c) 2012-2018 Zeex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "subhook.h"
#include "subhook_private.h"

subhook_disasm_handler_t subhook_disasm_handler = NULL;

SUBHOOK_EXPORT void *SUBHOOK_API subhook_get_src(subhook_t hook) {
  if (hook == NULL) {
    return NULL;
  }
  return hook->src;
}

SUBHOOK_EXPORT void *SUBHOOK_API subhook_get_dst(subhook_t hook) {
  if (hook == NULL) {
    return NULL;
  }
  return hook->dst;
}

SUBHOOK_EXPORT int SUBHOOK_API subhook_is_installed(subhook_t hook) {
  if (hook == NULL) {
    return false;
  }
  return hook->installed;
}

SUBHOOK_EXPORT void SUBHOOK_API subhook_set_disasm_handler(
  subhook_disasm_handler_t handler) {
  subhook_disasm_handler = handler;
}

#ifndef SUBHOOK_SEPARATE_SOURCE_FILES

#if defined SUBHOOK_WINDOWS
  #include "subhook_windows.c"
#elif defined SUBHOOK_UNIX
  #include "subhook_unix.c"
#endif

#if defined SUBHOOK_X86 || defined SUBHOOK_X86_64
  #include "subhook_x86.c"
#endif

#endif

```

`src/Utils/subhook/subhook.h`:

```h
/*
 * Copyright (c) 2012-2018 Zeex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SUBHOOK_H
#define SUBHOOK_H

#if defined _M_IX86 || defined __i386__
  #define SUBHOOK_X86
  #define SUBHOOK_BITS 32
#elif defined _M_AMD64 || __amd64__
  #define SUBHOOK_X86_64
  #define SUBHOOK_BITS 64
#else
  #error Unsupported architecture
#endif

#if defined _WIN32 || defined __CYGWIN__
  #define SUBHOOK_WINDOWS
#elif defined __linux__
  #define SUBHOOK_LINUX
  #define SUBHOOK_UNIX
#elif defined __APPLE__
  #define SUBHOOK_MACOS
  #define SUBHOOK_UNIX
#else
  #error Unsupported operating system
#endif

#if !defined SUBHOOK_EXTERN
  #if defined __cplusplus
    #define SUBHOOK_EXTERN extern "C"
  #else
    #define SUBHOOK_EXTERN extern
  #endif
#endif

#if defined SUBHOOK_STATIC
  #define SUBHOOK_API
  #define SUBHOOK_EXPORT SUBHOOK_EXTERN
#endif

#if !defined SUBHOOK_API
  #if defined SUBHOOK_X86
    #if defined SUBHOOK_WINDOWS
      #define SUBHOOK_API __cdecl
    #elif defined SUBHOOK_UNIX
      #define SUBHOOK_API __attribute__((cdecl))
    #endif
  #else
    #define SUBHOOK_API
  #endif
#endif

#if !defined SUBHOOK_EXPORT
  #if defined SUBHOOK_WINDOWS
    #if defined SUBHOOK_IMPLEMENTATION
      #define SUBHOOK_EXPORT SUBHOOK_EXTERN __declspec(dllexport)
    #else
      #define SUBHOOK_EXPORT SUBHOOK_EXTERN __declspec(dllimport)
    #endif
  #elif defined SUBHOOK_UNIX
    #if defined SUBHOOK_IMPLEMENTATION
      #define SUBHOOK_EXPORT SUBHOOK_EXTERN __attribute__((visibility("default")))
    #else
      #define SUBHOOK_EXPORT SUBHOOK_EXTERN
    #endif
  #endif
#endif

typedef enum subhook_flags {
  /* Use the 64-bit jump method on x86-64 (requires more space). */
  SUBHOOK_64BIT_OFFSET = 1
} subhook_flags_t;

struct subhook_struct;
typedef struct subhook_struct *subhook_t;

typedef int (SUBHOOK_API *subhook_disasm_handler_t)(
  void *src,
  int *reloc_op_offset);

SUBHOOK_EXPORT subhook_t SUBHOOK_API subhook_new(
  void *src,
  void *dst,
  subhook_flags_t flags);
SUBHOOK_EXPORT void SUBHOOK_API subhook_free(subhook_t hook);

SUBHOOK_EXPORT void *SUBHOOK_API subhook_get_src(subhook_t hook);
SUBHOOK_EXPORT void *SUBHOOK_API subhook_get_dst(subhook_t hook);

SUBHOOK_EXPORT int SUBHOOK_API subhook_install(subhook_t hook);
SUBHOOK_EXPORT int SUBHOOK_API subhook_is_installed(subhook_t hook);
SUBHOOK_EXPORT int SUBHOOK_API subhook_remove(subhook_t hook);

/*
 * Reads hook destination address from code.
 *
 * This function may be useful when you don't know the address or want to
 * check whether src is already hooked.
 */
SUBHOOK_EXPORT void *SUBHOOK_API subhook_read_dst(void *src);

/*
 * Sets a custom disassmbler function to use in place of the default one
 * (subhook_disasm).
 *
 * The default function recognized a small st of x86 instructiosn commonly
 * in prologues. If it fails in your situation you might want to use a more
 * advanced disassembler library.
 */
SUBHOOK_EXPORT void SUBHOOK_API subhook_set_disasm_handler(
  subhook_disasm_handler_t handler);

#ifdef __cplusplus

namespace subhook {

enum HookFlags {
  HookNoFlags = 0,
  HookFlag64BitOffset = SUBHOOK_64BIT_OFFSET
};

inline HookFlags operator|(HookFlags o1, HookFlags o2) {
  return static_cast<HookFlags>(
      static_cast<unsigned int>(o1) | static_cast<unsigned int>(o2));
}

inline HookFlags operator&(HookFlags o1, HookFlags o2) {
  return static_cast<HookFlags>(
      static_cast<unsigned int>(o1) & static_cast<unsigned int>(o2));
}

inline void *ReadHookDst(void *src) {
  return subhook_read_dst(src);
}

inline void SetDisasmHandler(subhook_disasm_handler_t handler) {
  subhook_set_disasm_handler(handler);
}

class Hook {
 public:
  Hook() : hook_(0) {}
  Hook(void *src, void *dst, HookFlags flags = HookNoFlags)
    : hook_(subhook_new(src, dst, (subhook_flags_t)flags))
  {
  }

  ~Hook() {
    subhook_remove(hook_);
    subhook_free(hook_);
  }

  void *GetSrc() const { return subhook_get_src(hook_); }
  void *GetDst() const { return subhook_get_dst(hook_); }

  bool Install() {
    return subhook_install(hook_) >= 0;
  }

  bool Install(void *src,
               void *dst,
               HookFlags flags = HookNoFlags) {
    if (hook_ == 0) {
      hook_ = subhook_new(src, dst, (subhook_flags_t)flags);
    }
    return Install();
  }

  bool Remove() {
    return subhook_remove(hook_) >= 0;
  }

  bool IsInstalled() const {
    return !!subhook_is_installed(hook_);
  }

 private:
  Hook(const Hook &);
  void operator=(const Hook &);

 private:
  subhook_t hook_;
};

class ScopedHookRemove {
 public:
  ScopedHookRemove(Hook *hook)
    : hook_(hook)
    , removed_(hook_->Remove())
  {
  }

  ~ScopedHookRemove() {
    if (removed_) {
      hook_->Install();
    }
  }

 private:
  ScopedHookRemove(const ScopedHookRemove &);
  void operator=(const ScopedHookRemove &);

 private:
  Hook *hook_;
  bool removed_;
};

class ScopedHookInstall {
 public:
  ScopedHookInstall(Hook *hook)
    : hook_(hook)
    , installed_(hook_->Install())
  {
  }

  ScopedHookInstall(Hook *hook,
                    void *src,
                    void *dst,
                    HookFlags flags = HookNoFlags)
    : hook_(hook)
    , installed_(hook_->Install(src, dst, flags))
  {
  }

  ~ScopedHookInstall() {
    if (installed_) {
      hook_->Remove();
    }
  }

 private:
  ScopedHookInstall(const ScopedHookInstall &);
  void operator=(const ScopedHookInstall &);

 private:
  Hook *hook_;
  bool installed_;
};

} // namespace subhook

#endif /* __cplusplus */

#endif /* SUBHOOK_H */

```

`src/Utils/subhook/subhook_private.h`:

```h
/*
 * Copyright (c) 2012-2018 Zeex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SUBHOOK_PRIVATE_H
#define SUBHOOK_PRIVATE_H

#include <stddef.h>

#ifndef true
  #define true 1
#endif
#ifndef false
  #define false 0
#endif

struct subhook_struct {
  int installed;
  void *src;
  void *dst;
  subhook_flags_t flags;
  void *code;
  size_t jmp_size;
  unsigned int orig_flags;
};

void *subhook_unprotect(void *address, size_t size, unsigned int *orig_flags);
void *subhook_protect(void *address, size_t size, unsigned int flags);

#endif /* SUBHOOK_PRIVATE_H */

```

`src/Utils/subhook/subhook_unix.c`:

```c
/*
 * Copyright (c) 2012-2018 Zeex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#define _GNU_SOURCE
#include <stddef.h>
#include <unistd.h>
#include <sys/mman.h>
#include <link.h>

static int flags = 0;
static void *addr = NULL;

static int callback(struct dl_phdr_info *info, size_t size, void *data) {
  void *starting_addr = 0;
  void *ending_addr = 0;
  for( int i = 0; i < info->dlpi_phnum; i++ ){
    const ElfW(Phdr) *hdr = &info->dlpi_phdr[i];
    if( hdr->p_memsz ){
      starting_addr = (void*)info->dlpi_addr + hdr->p_vaddr;
      ending_addr = starting_addr + hdr->p_memsz;
      if( starting_addr <= addr && ending_addr >= addr ){
        /* PF_ flags and PROT_ flags are NOT the same! REEE */
        if( hdr->p_flags & PF_R ){
          flags |= PROT_READ;
        }
        if( hdr->p_flags & PF_W ){
          flags |= PROT_WRITE;
        }
        if( hdr->p_flags & PF_X ){
          flags |= PROT_EXEC;
        }
      }
    }
  }
}

/* Assuming the entire region has the same flags. */
void *subhook_unprotect(void *address, size_t size, unsigned int *orig_flags) {
  long pagesize;

  pagesize = sysconf(_SC_PAGESIZE);
  address = (void *)((long)address & ~(pagesize - 1));

  if( orig_flags ) {
    flags = 0;
    addr = address;
    dl_iterate_phdr( callback, NULL );
    *orig_flags = flags;
  }

  if (mprotect(address, size, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) {
    return address;
  } else {
    return NULL;
  }
}

void *subhook_protect(void *address, size_t size, unsigned int flags) {
  long pagesize;

  pagesize = sysconf(_SC_PAGESIZE);
  address = (void *)((long)address & ~(pagesize - 1));

  if( mprotect(address, size, PF_X | PF_R) == 0 ){
    return address;
  } else {
    return NULL;
  }
}

```

`src/Utils/subhook/subhook_x86.c`:

```c
/*
 * Copyright (c) 2012-2018 Zeex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include "subhook.h"
#include "subhook_private.h"

#ifdef SUBHOOK_WINDOWS
  #define INT32_MAX 0x7fffffff
  #define INT32_MIN (-INT32_MAX - 1)
  typedef unsigned __int8 uint8_t;
  typedef __int32 int32_t;
  typedef unsigned __int32 uint32_t;
  typedef __int64 int64_t;
  #ifdef SUBHOOK_X86_64
    typedef __int64 intptr_t;
    typedef unsigned __int64 uintptr_t;
  #else
    typedef __int32 intptr_t;
    typedef unsigned __int32 uintptr_t;
  #endif
#else
  #include <stdint.h>
#endif

#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX_INSN_LEN 15 /* maximum length of x86 instruction */

#define JMP_OPCODE  0xE9
#define PUSH_OPCODE 0x68
#define MOV_OPCODE  0xC7
#define RET_OPCODE  0xC3

#define JMP64_MOV_MODRM  0x44 /* write to address + 1 byte displacement */
#define JMP64_MOV_SIB    0x24 /* write to [rsp] */
#define JMP64_MOV_OFFSET 0x04

#pragma pack(push, 1)

struct subhook_jmp32 {
  uint8_t opcode;
  int32_t offset;
};

/* Since AMD64 doesn't support 64-bit direct jumps, we'll push the address
 * onto the stack, then call RET.
 */
struct subhook_jmp64 {
  uint8_t  push_opcode;
  uint32_t push_addr; /* lower 32-bits of the address to jump to */
  uint8_t  mov_opcode;
  uint8_t  mov_modrm;
  uint8_t  mov_sib;
  uint8_t  mov_offset;
  uint32_t mov_addr;  /* upper 32-bits of the address to jump to */
  uint8_t  ret_opcode;
};

#pragma pack(pop)

extern subhook_disasm_handler_t subhook_disasm_handler;

static int subhook_disasm(void *src, int *reloc_op_offset) {
  enum flags {
    MODRM      = 1,
    PLUS_R     = 1 << 1,
    REG_OPCODE = 1 << 2,
    IMM8       = 1 << 3,
    IMM16      = 1 << 4,
    IMM32      = 1 << 5,
    RELOC      = 1 << 6
  };

  static uint8_t prefixes[] = {
    0xF0, 0xF2, 0xF3,
    0x2E, 0x36, 0x3E, 0x26, 0x64, 0x65,
    0x66, /* operand size override */
    0x67  /* address size override */
  };

  struct opcode_info {
    uint8_t opcode;
    uint8_t reg_opcode;
    unsigned int flags;
  };

  /*
   * See the Intel Developer Manual volumes 2a and 2b for more information
   * about instruction format and encoding:
   *
   * https://www-ssl.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html
   */
  static struct opcode_info opcodes[] = {
    /* ADD AL, imm8      */ {0x04, 0, IMM8},
    /* ADD EAX, imm32    */ {0x05, 0, IMM32},
    /* ADD r/m8, imm8    */ {0x80, 0, MODRM | REG_OPCODE | IMM8},
    /* ADD r/m32, imm32  */ {0x81, 0, MODRM | REG_OPCODE | IMM32},
    /* ADD r/m32, imm8   */ {0x83, 0, MODRM | REG_OPCODE | IMM8},
    /* ADD r/m8, r8      */ {0x00, 0, MODRM},
    /* ADD r/m32, r32    */ {0x01, 0, MODRM},
    /* ADD r8, r/m8      */ {0x02, 0, MODRM},
    /* ADD r32, r/m32    */ {0x03, 0, MODRM},
    /* AND AL, imm8      */ {0x24, 0, IMM8},
    /* AND EAX, imm32    */ {0x25, 0, IMM32},
    /* AND r/m8, imm8    */ {0x80, 4, MODRM | REG_OPCODE | IMM8},
    /* AND r/m32, imm32  */ {0x81, 4, MODRM | REG_OPCODE | IMM32},
    /* AND r/m32, imm8   */ {0x83, 4, MODRM | REG_OPCODE | IMM8},
    /* AND r/m8, r8      */ {0x20, 0, MODRM},
    /* AND r/m32, r32    */ {0x21, 0, MODRM},
    /* AND r8, r/m8      */ {0x22, 0, MODRM},
    /* AND r32, r/m32    */ {0x23, 0, MODRM},
    /* CALL rel32        */ {0xE8, 0, IMM32 | RELOC},
    /* CALL r/m32        */ {0xFF, 2, MODRM | REG_OPCODE},
    /* CMP r/m16/32, imm8*/ {0x83, 7, MODRM | REG_OPCODE | IMM8 },
    /* DEC r/m16/32      */ {0xFF, 1, MODRM | REG_OPCODE },
    /* ENTER imm16, imm8 */ {0xC8, 0, IMM16 | IMM8},
    /* INT 3             */ {0xCC, 0, 0},
    /* JMP rel32         */ {0xE9, 0, IMM32 | RELOC},
    /* JMP r/m32         */ {0xFF, 4, MODRM | REG_OPCODE},
    /* LEA r32,m         */ {0x8D, 0, MODRM},
    /* LEAVE             */ {0xC9, 0, 0},
    /* MOV r/m8,r8       */ {0x88, 0, MODRM},
    /* MOV r/m32,r32     */ {0x89, 0, MODRM},
    /* MOV r8,r/m8       */ {0x8A, 0, MODRM},
    /* MOV r32,r/m32     */ {0x8B, 0, MODRM},
    /* MOV r/m16,Sreg    */ {0x8C, 0, MODRM},
    /* MOV Sreg,r/m16    */ {0x8E, 0, MODRM},
    /* MOV AL,moffs8     */ {0xA0, 0, IMM8},
    /* MOV EAX,moffs32   */ {0xA1, 0, IMM32},
    /* MOV moffs8,AL     */ {0xA2, 0, IMM8},
    /* MOV moffs32,EAX   */ {0xA3, 0, IMM32},
    /* MOV r8, imm8      */ {0xB0, 0, PLUS_R | IMM8},
    /* MOV r32, imm32    */ {0xB8, 0, PLUS_R | IMM32},
    /* MOV r/m8, imm8    */ {0xC6, 0, MODRM | REG_OPCODE | IMM8},
    /* MOV r/m32, imm32  */ {0xC7, 0, MODRM | REG_OPCODE | IMM32},
    /* NOP               */ {0x90, 0, 0},
    /* OR AL, imm8       */ {0x0C, 0, IMM8},
    /* OR EAX, imm32     */ {0x0D, 0, IMM32},
    /* OR r/m8, imm8     */ {0x80, 1, MODRM | REG_OPCODE | IMM8},
    /* OR r/m32, imm32   */ {0x81, 1, MODRM | REG_OPCODE | IMM32},
    /* OR r/m32, imm8    */ {0x83, 1, MODRM | REG_OPCODE | IMM8},
    /* OR r/m8, r8       */ {0x08, 0, MODRM},
    /* OR r/m32, r32     */ {0x09, 0, MODRM},
    /* OR r8, r/m8       */ {0x0A, 0, MODRM},
    /* OR r32, r/m32     */ {0x0B, 0, MODRM},
    /* POP r/m32         */ {0x8F, 0, MODRM | REG_OPCODE},
    /* POP r32           */ {0x58, 0, PLUS_R},
    /* PUSH r/m32        */ {0xFF, 6, MODRM | REG_OPCODE},
    /* PUSH r32          */ {0x50, 0, PLUS_R},
    /* PUSH imm8         */ {0x6A, 0, IMM8},
    /* PUSH imm32        */ {0x68, 0, IMM32},
    /* RET               */ {0xC3, 0, 0},
    /* RET imm16         */ {0xC2, 0, IMM16},
    /* SUB AL, imm8      */ {0x2C, 0, IMM8},
    /* SUB EAX, imm32    */ {0x2D, 0, IMM32},
    /* SUB r/m8, imm8    */ {0x80, 5, MODRM | REG_OPCODE | IMM8},
    /* SUB r/m32, imm32  */ {0x81, 5, MODRM | REG_OPCODE | IMM32},
    /* SUB r/m32, imm8   */ {0x83, 5, MODRM | REG_OPCODE | IMM8},
    /* SUB r/m8, r8      */ {0x28, 0, MODRM},
    /* SUB r/m32, r32    */ {0x29, 0, MODRM},
    /* SUB r8, r/m8      */ {0x2A, 0, MODRM},
    /* SUB r32, r/m32    */ {0x2B, 0, MODRM},
    /* TEST AL, imm8     */ {0xA8, 0, IMM8},
    /* TEST EAX, imm32   */ {0xA9, 0, IMM32},
    /* TEST r/m8, imm8   */ {0xF6, 0, MODRM | REG_OPCODE | IMM8},
    /* TEST r/m32, imm32 */ {0xF7, 0, MODRM | REG_OPCODE | IMM32},
    /* TEST r/m8, r8     */ {0x84, 0, MODRM},
    /* TEST r/m32, r32   */ {0x85, 0, MODRM},
    /* XOR AL, imm8      */ {0x34, 0, IMM8},
    /* XOR EAX, imm32    */ {0x35, 0, IMM32},
    /* XOR r/m8, imm8    */ {0x80, 6, MODRM | REG_OPCODE | IMM8},
    /* XOR r/m32, imm32  */ {0x81, 6, MODRM | REG_OPCODE | IMM32},
    /* XOR r/m32, imm8   */ {0x83, 6, MODRM | REG_OPCODE | IMM8},
    /* XOR r/m8, r8      */ {0x30, 0, MODRM},
    /* XOR r/m32, r32    */ {0x31, 0, MODRM},
    /* XOR r8, r/m8      */ {0x32, 0, MODRM},
    /* XOR r32, r/m32    */ {0x33, 0, MODRM}
  };

  uint8_t *code = src;
  size_t i;
  int len = 0;
  int operand_size = 4;
  uint8_t opcode = 0;
  int found_opcode = false;

  for (i = 0; i < sizeof(prefixes) / sizeof(*prefixes); i++) {
    if (code[len] == prefixes[i]) {
      len++;
      if (prefixes[i] == 0x66) {
        operand_size = 2;
      }
    }
  }

#ifdef SUBHOOK_X86_64
  if ((code[len] & 0xF0) == 0x40) {
    /* This is a REX prefix (40H - 4FH). REX prefixes are valid only in
     * 64-bit mode.
     */
    uint8_t rex = code[len++];

    if (rex & 8) {
      /* REX.W changes size of immediate operand to 64 bits. */
      operand_size = 8;
    }
  }
#endif

  for (i = 0; i < sizeof(opcodes) / sizeof(*opcodes); i++) {
    if (code[len] == opcodes[i].opcode) {
      if (opcodes[i].flags & REG_OPCODE) {
        found_opcode = ((code[len + 1] >> 3) & 7) == opcodes[i].reg_opcode;
      } else {
        found_opcode = true;
      }
    }

    if ((opcodes[i].flags & PLUS_R)
      && (code[len] & 0xF8) == opcodes[i].opcode) {
      found_opcode = true;
    }

    if (found_opcode) {
      opcode = code[len++];
      break;
    }
  }

  if (!found_opcode) {
    return 0;
  }

  if (reloc_op_offset != NULL && opcodes[i].flags & RELOC) {
    *reloc_op_offset = len; /* relative call or jump */
  }

  if (opcodes[i].flags & MODRM) {
    uint8_t modrm = code[len++]; /* +1 for Mod/RM byte */
    uint8_t mod = modrm >> 6;
    uint8_t rm = modrm & 7; 

    if (mod != 3 && rm == 4) {
      uint8_t sib = code[len++]; /* +1 for SIB byte */
      uint8_t base = sib & 7;

      if (base == 5) {
        /* The SIB is followed by a disp32 with no base if the MOD is 00B.
         * Otherwise, disp8 or disp32 + [EBP].
         */
        if (mod == 1) {
          len += 1; /* for disp8 */
        } else {
          len += 4; /* for disp32 */
        }
      }
    }

#ifdef SUBHOOK_X86_64
    if (reloc_op_offset != NULL && rm == 5) {
      *reloc_op_offset = (int32_t)len; /* RIP-relative addressing */
    }
#endif

    if (mod == 1) {
      len += 1; /* for disp8 */
    }
    if (mod == 2 || (mod == 0 && rm == 5)) {
      len += 4; /* for disp32 */
    }
  }

  if (opcodes[i].flags & IMM8) {
    len += 1;
  }
  if (opcodes[i].flags & IMM16) {
    len += 2;
  }
  if (opcodes[i].flags & IMM32) {
    len += operand_size;
  }

  return len;
}

static size_t subhook_get_jmp_size(subhook_flags_t flags) {
#ifdef SUBHOOK_X86_64
  if ((flags & SUBHOOK_64BIT_OFFSET) != 0) {
    return sizeof(struct subhook_jmp64);
  }
#else
  (void)flags;
#endif
  return sizeof(struct subhook_jmp32);
}

static int subhook_make_jmp32(void *src, void *dst) {
  struct subhook_jmp32 *jmp = (struct subhook_jmp32 *)src;
  intptr_t src_addr = (intptr_t)src;
  intptr_t dst_addr = (intptr_t)dst;
#ifdef SUBHOOK_X86_64
  int64_t distance = ABS(src_addr - dst_addr);
#endif

#ifdef SUBHOOK_X86_64
  if (distance < INT32_MIN || distance > INT32_MAX) {
    return -EOVERFLOW;
  }
#endif

  jmp->opcode = JMP_OPCODE;
  jmp->offset = (int32_t)(dst_addr - (src_addr + sizeof(*jmp)));

  return 0;
}

#ifdef SUBHOOK_X86_64

static int subhook_make_jmp64(void *src, void *dst) {
  struct subhook_jmp64 *jmp = (struct subhook_jmp64 *)src;

  jmp->push_opcode = PUSH_OPCODE;
  jmp->push_addr = (uint32_t)(uintptr_t)dst; /* truncate */
  jmp->mov_opcode = MOV_OPCODE;
  jmp->mov_modrm = JMP64_MOV_MODRM;
  jmp->mov_sib = JMP64_MOV_SIB;
  jmp->mov_offset = JMP64_MOV_OFFSET;
  jmp->mov_addr = (uint32_t)(((uintptr_t)dst) >> 32);
  jmp->ret_opcode = RET_OPCODE;

  return 0;
}

#endif

static int subhook_make_jmp(void *src,
                            void *dst,
                            subhook_flags_t flags) {
#ifdef SUBHOOK_X86_64
  if ((flags & SUBHOOK_64BIT_OFFSET) != 0) {
    return subhook_make_jmp64(src, dst);
  }
#else
  (void)flags;
#endif
  return subhook_make_jmp32(src, dst);
}

SUBHOOK_EXPORT subhook_t SUBHOOK_API subhook_new(void *src,
                                                 void *dst,
                                                 subhook_flags_t flags) {
  subhook_t hook;

  if ((hook = malloc(sizeof(*hook))) == NULL) {
    return NULL;
  }

  hook->installed = 0;
  hook->src = src;
  hook->dst = dst;
  hook->flags = flags;
  hook->jmp_size = subhook_get_jmp_size(hook->flags);

  if ((hook->code = malloc(hook->jmp_size)) == NULL) {
    free(hook);
    return NULL;
  }

  memcpy(hook->code, hook->src, hook->jmp_size);

  return hook;
}

SUBHOOK_EXPORT void SUBHOOK_API subhook_free(subhook_t hook) {
  if (hook == NULL) {
    return;
  }
  free(hook->code);
  free(hook);
}

SUBHOOK_EXPORT int SUBHOOK_API subhook_install(subhook_t hook) {
  int error;
  unsigned int orig_flags;

  if (hook == NULL) {
    return -EINVAL;
  }
  if (hook->installed) {
    return -EINVAL;
  }

  if (subhook_unprotect(hook->src, hook->jmp_size, &orig_flags) == NULL ) {
    return 1;
  }

  hook->orig_flags = orig_flags;

  error = subhook_make_jmp(hook->src, hook->dst, hook->flags);

  error += ( subhook_protect(hook->src, hook->jmp_size, hook->orig_flags) ? 1 : 0 );

  if (error >= 0) {
    hook->installed = true;
    return 0;
  }

  return error;
}

SUBHOOK_EXPORT int SUBHOOK_API subhook_remove(subhook_t hook) {
  unsigned int orig_flags;

  if (hook == NULL) {
    return -EINVAL;
  }
  if (!hook->installed) {
    return -EINVAL;
  }

  if( subhook_unprotect(hook->src, hook->jmp_size, &orig_flags) == NULL ){
    return 1;
  }
  memcpy(hook->src, hook->code, hook->jmp_size);
  hook->installed = 0;

  subhook_protect(hook->src, hook->jmp_size, orig_flags);
  return 0;
}

SUBHOOK_EXPORT void *SUBHOOK_API subhook_read_dst(void *src)  {
  struct subhook_jmp32 *maybe_jmp32 = (struct subhook_jmp32 *)src;
#ifdef SUBHOOK_X86_64
  struct subhook_jmp64 *maybe_jmp64 = (struct subhook_jmp64 *)src;
#endif

  if (maybe_jmp32->opcode == JMP_OPCODE) {
    return (void *)(
      maybe_jmp32->offset + (uintptr_t)src + sizeof(*maybe_jmp32));
  }

#ifdef SUBHOOK_X86_64
  if (maybe_jmp64->push_opcode == PUSH_OPCODE
    && maybe_jmp64->mov_opcode == MOV_OPCODE
    && maybe_jmp64->mov_modrm == JMP64_MOV_MODRM
    && maybe_jmp64->mov_sib == JMP64_MOV_SIB
    && maybe_jmp64->mov_offset == JMP64_MOV_OFFSET
    && maybe_jmp64->ret_opcode == RET_OPCODE) {
    return (void *)(
      maybe_jmp64->push_addr & ((uintptr_t)maybe_jmp64->mov_addr << 32));
  }
#endif

  return NULL;
}

```

`src/protos/mcdota.proto`:

```proto
option optimize_for = SPEED;
option cc_generic_services = false;


message CDOTAClientMsg_TipAlert {
	optional string tip_text = 1;
}

message CCLCMsg_SplitPlayerConnect {
	optional string playername = 1;
}

message CDOTAClientMsg_EventCNY2015Cmd {
	optional bytes data = 1;
}

message CDOTAClientMsg_RankWager {
	optional bool announce_wager = 1;
}

message CCLCMsg_Move {
	optional bytes data = 3;
	optional uint32 command_number = 4;
	optional uint32 num_commands = 5;
}

message CNETMsg_Tick {
	optional uint32 tick = 1;
	optional uint32 host_frametime = 2;
	optional uint32 host_frametime_std_deviation = 3;
	optional uint32 host_computationtime = 4;
	optional uint32 host_computationtime_std_deviation = 5;
	optional uint32 host_framestarttime_std_deviation = 6;
	optional uint32 host_loss = 7;
	optional uint32 host_unfiltered_frametime = 8;
}

message CDOTAClientMsg_EventPointsTip {
	optional uint32 recipient_player_id = 1;
}

message CDOTAClientMsg_CoinWager {
	optional uint32 wager_amount = 1;
}

message CMsg_CVars {
	message CVar {
		optional string name = 1;
		optional string value = 2;
	}

	repeated .CMsg_CVars.CVar cvars = 1;
}

message CNETMsg_SetConVar {
	optional .CMsg_CVars convars = 1;
}

message CNETMsg_StringCmd {
	optional string command = 1;
}

message CDOTAMsg_CoachHUDPing {
	optional uint32 x = 1;
	optional uint32 y = 2;
	optional string tgtpath = 3;
}

message CDOTAUserMsg_CoachHUDPing {
	optional uint32 player_id = 1;
	optional .CDOTAMsg_CoachHUDPing hud_ping = 2;
}

message CDOTAClientMsg_GuideSelectOption {
	optional uint32 option = 1;
	optional bool force_recalculate = 2;
}

message CDOTAClientMsg_GuideSelected {
	optional uint64 guide_workshop_id = 1;
	optional bool is_plus_guide = 2;
}

message CCLCMsg_CmdKeyValues {
	optional bytes data = 1;
}

message CCLCMsg_FileCRCCheck {
	optional int32 code_path = 1;
	optional string path = 2;
	optional int32 code_filename = 3;
	optional string filename = 4;
	optional fixed32 crc = 5;
}

message CCLCMsg_ClientMessage {
	optional int32 msg_type = 1;
	optional bytes data = 2;
}

message CDOTAClientMsg_MatchMetadata {
	optional uint64 match_id = 1;
	optional bytes metadata = 2;
}

message CSOEconItemAttribute {
	optional uint32 def_index = 1;
	optional uint32 value = 2;
	optional bytes value_bytes = 3;
}

message CSOEconItemEquipped {
	optional uint32 new_class = 1;
	optional uint32 new_slot = 2;
}
message CSOEconItem {
	optional uint64 id = 1;
	optional uint32 account_id = 2;
	optional uint32 inventory = 3;
	optional uint32 def_index = 4;
	optional uint32 quantity = 5 [default = 1];
	optional uint32 level = 6 [default = 1];
	optional uint32 quality = 7 [default = 4];
	optional uint32 flags = 8 [default = 0];
	optional uint32 origin = 9 [default = 0];
	repeated .CSOEconItemAttribute attribute = 12;
	optional .CSOEconItem interior_item = 13;
	optional uint32 style = 15 [default = 0];
	optional uint64 original_id = 16 [default = 0];
	repeated .CSOEconItemEquipped equipped_state = 18;
}

enum EDOTAMMRBoostType {
	k_EDOTAMMRBoostType_None = 0;
	k_EDOTAMMRBoostType_Leader = 1;
	k_EDOTAMMRBoostType_Follower = 2;
}

message CLobbyTimedRewardDetails {
	optional uint32 item_def_index = 2;
	optional bool is_supply_crate = 3;
	optional bool is_timed_drop = 4;
	optional uint32 account_id = 5;
	optional uint32 origin = 6;
}

enum EEvent {
	EVENT_ID_NONE = 0;
	EVENT_ID_DIRETIDE = 1;
	EVENT_ID_SPRING_FESTIVAL = 2;
	EVENT_ID_FROSTIVUS_2013 = 3;
	EVENT_ID_COMPENDIUM_2014 = 4;
	EVENT_ID_NEXON_PC_BANG = 5;
	EVENT_ID_PWRD_DAC_2015 = 6;
	EVENT_ID_NEW_BLOOM_2015 = 7;
	EVENT_ID_INTERNATIONAL_2015 = 8;
	EVENT_ID_FALL_MAJOR_2015 = 9;
	EVENT_ID_ORACLE_PA = 10;
	EVENT_ID_NEW_BLOOM_2015_PREBEAST = 11;
	EVENT_ID_FROSTIVUS = 12;
	EVENT_ID_WINTER_MAJOR_2016 = 13;
	EVENT_ID_INTERNATIONAL_2016 = 14;
	EVENT_ID_FALL_MAJOR_2016 = 15;
	EVENT_ID_WINTER_MAJOR_2017 = 16;
	EVENT_ID_NEW_BLOOM_2017 = 17;
	EVENT_ID_INTERNATIONAL_2017 = 18;
	EVENT_ID_PLUS_SUBSCRIPTION = 19;
	EVENT_ID_SINGLES_DAY_2017 = 20;
	EVENT_ID_FROSTIVUS_2017 = 21;
	EVENT_ID_INTERNATIONAL_2018 = 22;
	EVENT_ID_FROSTIVUS_2018 = 23;
	EVENT_ID_NEW_BLOOM_2019 = 24;
	EVENT_ID_INTERNATIONAL_2019 = 25;
	EVENT_ID_NEW_PLAYER_EXPERIENCE = 26;
	EVENT_ID_FROSTIVUS_2019 = 27;
	EVENT_ID_COUNT = 28;
}

message CMsgMatchTips {
	message SingleTip {
		optional uint32 source_account_id = 1;
		optional uint32 target_account_id = 2;
		optional uint32 tip_amount = 3;
		optional .EEvent event_id = 4 [default = EVENT_ID_NONE];
	}

	repeated .CMsgMatchTips.SingleTip tips = 2;
}

enum EMatchBehaviorScoreVariance {
	k_EMatchBehaviorScoreVariance_Invalid = 0;
	k_EMatchBehaviorScoreVariance_Low = 1;
	k_EMatchBehaviorScoreVariance_Medium = 2;
	k_EMatchBehaviorScoreVariance_High = 3;
}
message CMsgMatchMatchmakingStats {
	optional uint32 average_queue_time = 1;
	optional uint32 maximum_queue_time = 2;
	optional .EMatchBehaviorScoreVariance behavior_score_variance = 3 [default = k_EMatchBehaviorScoreVariance_Invalid];
}


message CDOTAMatchMetadata {
	message Team {
		message PlayerKill {
			optional uint32 victim_slot = 1;
			optional uint32 count = 2;
		}

		message ItemPurchase {
			optional uint32 item_id = 1;
			optional int32 purchase_time = 2;
		}

		message InventorySnapshot {
			repeated uint32 item_id = 1;
			optional int32 game_time = 2;
			optional uint32 kills = 3;
			optional uint32 deaths = 4;
			optional uint32 assists = 5;
			optional uint32 level = 6;
		}

		message AutoStyleCriteria {
			optional uint32 name_token = 1;
			optional float value = 2;
		}

		message StrangeGemProgress {
			optional uint32 kill_eater_type = 1;
			optional uint32 gem_item_def_index = 2;
			optional uint32 required_hero_id = 3;
			optional uint32 starting_value = 4;
			optional uint32 ending_value = 5;
			optional uint32 owner_item_def_index = 6;
			optional uint64 owner_item_id = 7;
		}

		message VictoryPrediction {
			optional uint64 item_id = 1;
			optional uint32 item_def_index = 2;
			optional uint32 starting_value = 3;
			optional bool is_victory = 4;
		}

		message SubChallenge {
			optional uint32 slot_id = 1;
			optional uint32 start_value = 2;
			optional uint32 end_value = 3;
			optional bool completed = 4;
		}

		message CavernChallengeResult {
			optional uint32 completed_path_id = 1;
			optional uint32 claimed_room_id = 2;
		}

		message ActionGrant {
			optional uint32 action_id = 1;
			optional uint32 quantity = 2;
			optional uint32 audit = 3;
		}

		message EventData {
			optional uint32 event_id = 1;
			optional uint32 event_points = 2;
			optional uint32 challenge_instance_id = 3;
			optional uint32 challenge_quest_id = 4;
			optional uint32 challenge_quest_challenge_id = 5;
			optional bool challenge_completed = 6;
			optional uint32 challenge_rank_completed = 7;
			optional uint32 challenge_rank_previously_completed = 8;
			optional bool event_owned = 9;
			repeated .CDOTAMatchMetadata.Team.SubChallenge sub_challenges_with_progress = 10;
			optional uint32 wager_winnings = 11;
			optional bool cavern_challenge_active = 12;
			optional uint32 cavern_challenge_winnings = 13;
			optional uint32 amount_wagered = 14;
			optional uint32 team_wager_amount = 15;
			optional uint32 periodic_point_adjustments = 16;
			repeated .CDOTAMatchMetadata.Team.CavernChallengeResult cavern_challenge_map_results = 17;
			optional uint32 cavern_challenge_plus_shard_winnings = 18;
			repeated .CDOTAMatchMetadata.Team.ActionGrant actions_granted = 19;
		}

		message Player {
			optional uint32 account_id = 1;
			repeated uint32 ability_upgrades = 2;
			optional uint32 player_slot = 3;
			repeated .CSOEconItem equipped_econ_items = 4;
			repeated .CDOTAMatchMetadata.Team.PlayerKill kills = 5;
			repeated .CDOTAMatchMetadata.Team.ItemPurchase items = 6;
			optional uint32 avg_kills_x16 = 7;
			optional uint32 avg_deaths_x16 = 8;
			optional uint32 avg_assists_x16 = 9;
			optional uint32 avg_gpm_x16 = 10;
			optional uint32 avg_xpm_x16 = 11;
			optional uint32 best_kills_x16 = 12;
			optional uint32 best_assists_x16 = 13;
			optional uint32 best_gpm_x16 = 14;
			optional uint32 best_xpm_x16 = 15;
			optional uint32 win_streak = 16;
			optional uint32 best_win_streak = 17;
			optional float fight_score = 18;
			optional float farm_score = 19;
			optional float support_score = 20;
			optional float push_score = 21;
			repeated uint32 level_up_times = 22;
			repeated float graph_net_worth = 23;
			repeated .CDOTAMatchMetadata.Team.InventorySnapshot inventory_snapshot = 24;
			optional bool avg_stats_calibrated = 25;
			repeated .CDOTAMatchMetadata.Team.AutoStyleCriteria auto_style_criteria = 26;
			repeated .CDOTAMatchMetadata.Team.EventData event_data = 29;
			repeated .CDOTAMatchMetadata.Team.StrangeGemProgress strange_gem_progress = 30;
			optional uint32 hero_xp = 31;
			optional uint32 camps_stacked = 32;
			repeated .CDOTAMatchMetadata.Team.VictoryPrediction victory_prediction = 33;
			optional uint32 lane_selection_flags = 34;
			optional uint32 rampages = 35;
			optional uint32 triple_kills = 36;
			optional uint32 aegis_snatched = 37;
			optional uint32 rapiers_purchased = 38;
			optional uint32 couriers_killed = 39;
			optional uint32 net_worth_rank = 40;
			optional uint32 support_gold_spent = 41;
			optional uint32 observer_wards_placed = 42;
			optional uint32 sentry_wards_placed = 43;
			optional uint32 wards_dewarded = 44;
			optional float stun_duration = 45;
			optional .EDOTAMMRBoostType rank_mmr_boost_type = 46 [default = k_EDOTAMMRBoostType_None];
		}

		optional uint32 dota_team = 1;
		repeated .CDOTAMatchMetadata.Team.Player players = 2;
		repeated float graph_experience = 3;
		repeated float graph_gold_earned = 4;
		repeated float graph_net_worth = 5;
		optional bool cm_first_pick = 6;
		optional uint32 cm_captain_player_id = 7;
		repeated uint32 cm_bans = 8;
		repeated uint32 cm_picks = 9;
		optional uint32 cm_penalty = 10;
	}

	repeated .CDOTAMatchMetadata.Team teams = 1;
	repeated .CLobbyTimedRewardDetails item_rewards = 2;
	optional fixed64 lobby_id = 3;
	optional fixed64 report_until_time = 4;
	optional bytes event_game_custom_table = 5;
	optional uint32 primary_event_id = 6;
	repeated .CMsgMatchTips match_tips = 7;
	optional .CMsgMatchMatchmakingStats matchmaking_stats = 8;
}
// Instead of doing a literal StringCmd "say hello there gamer" chat now has its' own packet.
message CDOTAClientMsg_ChatMessage {
	optional uint32 channel_type = 1;
	optional string message_text = 2;
}
```

`uload`:

```
#!/bin/bash

# Credit: Aixxe @ aixxe.net

dota_pid=$(pidof dota2)
filename="libMcDota.so"
fullpath="$(pwd)/$filename"
echo $fullpath

sudo killall -19 steam
sudo killall -19 steamwebhelper

if grep -q "$filename" "/proc/$dota_pid/maps"; then

#Send signal SIGXCPU, which will signal McDota to get ready for unloading.
kill -24 "$dota_pid"

echo "Unloading..."
sudo gdb -n -q -batch-silent \
	-ex "set logging on" \
	-ex "set logging file /dev/null" \
	-ex "set logging redirect on" \
	-ex "attach $dota_pid" \
	-ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
	-ex "set \$dlclose = (int(*)(void*)) dlclose" \
	-ex "set \$library = \$dlopen(\"$filename\", 6)" \
	-ex "call \$dlclose(\$library)" \
	-ex "call \$dlclose(\$library)" \
	-ex "call \$dlclose(\$library)" \
	-ex "detach" \
	-ex "quit"
fi

sleep 0.2
sudo killall -18 steamwebhelper
sudo killall -18 steam

echo "Done."

```

`uload-stealth`:

```
#!/bin/bash

prefix="\e[34m\e[1mMcDota >\e[0m"
error_prefix="\e[91m\e[1mMcDota >\e[0m"
success_prefix="\e[32m\e[1mMcDota >\e[0m"

dota=$(pidof dota2)

if [ -z "$dota" ]; then
	echo -e "$error_prefix Dota 2 is not open!"
	exit -1
fi

if [ -e "/tmp/.mcdota" ]; then
    last_library=$(cat /tmp/.mcdota)
else
    echo -e "$error_prefix Could not find old filename. You'll have to restart Dota."
    exit -1
fi

if ! grep -q "$last_library" /proc/$dota/maps; then
    echo -e "$error_prefix McDota is not Injected..."
    exit -1
fi

sudo killall -19 steam
sudo killall -19 steamwebhelper

#Send signal SIGXCPU, which will signal McDota to get ready for unloading.
kill -24 "$dota_pid"

input="$(
sudo gdb -n -q -batch \
    -ex "set logging on" \
    -ex "set logging file /dev/null" \
    -ex "attach $dota" \
    -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
    -ex "set \$dlclose = (int(*)(void*)) dlclose" \
    -ex "set \$library = \$dlopen(\"$last_library\", 6)" \
    -ex "call \$dlclose(\$library)" \
    -ex "call \$dlclose(\$library)" \
    -ex "call \$dlclose(\$library)" \
    -ex "call \$dlerror()" \
    -ex "detach" \
    -ex "quit"
)"

last_line="${input##*$'\n'}"
echo ${last_line}

sleep 1
sudo killall -18 steamwebhelper
sudo killall -18 steam

if ! grep -q "$last_library" /proc/$dota/maps; then
    echo -e "$success_prefix McDota has been successfully uninjected."
else
    echo -e "$error_prefix McDota has failed to uninject and Dota 2 has gone rogue. Exterminating with extreme prejudice..."
    ./zombies
fi

if [ -f "$(pwd)/gdb.txt" ]; then
    sudo rm -f gdb.txt
fi

```

`uload_force`:

```
#!/bin/bash
# Uload without checking if it's loaded.
# Credit: Aixxe @ aixxe.net

dota_pid=$(pidof dota2)
filename="libMcDota.so"
fullpath="$(pwd)/$filename"
echo $fullpath

sudo killall -19 steam
sudo killall -19 steamwebhelper

#Send signal SIGXCPU, which will signal McDota to get ready for unloading.
kill -24 "$dota_pid"

echo "Unloading..."
sudo gdb -n -q -batch-silent \
	-ex "set logging on" \
	-ex "set logging file /dev/null" \
	-ex "set logging redirect on" \
	-ex "attach $dota_pid" \
	-ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
	-ex "set \$dlclose = (int(*)(void*)) dlclose" \
	-ex "set \$library = \$dlopen(\"$filename\", 6)" \
	-ex "call \$dlclose(\$library)" \
	-ex "call \$dlclose(\$library)" \
	-ex "call \$dlclose(\$library)" \
	-ex "detach" \
	-ex "quit"

sleep 1
sudo killall -18 steamwebhelper
sudo killall -18 steam

echo "Done."

```

`zombies`:

```
#!/bin/bash

sudo killall -9 dota2
sudo killall -9 dota.sh
sudo killall -9 gdb

```