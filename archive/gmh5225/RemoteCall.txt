Project Path: arc_gmh5225_RemoteCall_mp_a22bd

Source Tree:

```txt
arc_gmh5225_RemoteCall_mp_a22bd
├── Define.h
├── README.md
├── SetContextUserCall.cpp
├── SetContextUserCall.h
├── UsermodeCallback.cpp
├── UsermodeCallback.h
├── pic.png
├── util.cpp
└── util.h

```

`Define.h`:

```h
#pragma once


typedef unsigned long long y64;
typedef unsigned long long u64;
typedef unsigned long long* pu64;
using i64 = __int64;
typedef volatile unsigned long long vu64;
typedef unsigned long u32;
typedef void* pv;
typedef void* pv64;
typedef unsigned short u16;
typedef unsigned char u8;
typedef unsigned char* pu8;
typedef unsigned long long QWORD;


#define __db __debugbreak

#ifdef dbgmode
#define dbgdb __db
#define __dbgdb dbgdb
#else
#define dbgdb() 
#define __dbgdb() 
#endif



#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))


#define PAGE_2MB_SIZE				0x200000
#define	CR3_FLAG_ALL_BITS			0xFFF0000000000FFF

typedef union _virt_addr_t
{
	ULONG64 value;
	struct
	{
		ULONG64 offset : 12;
		ULONG64 pt_index : 9;
		ULONG64 pd_index : 9;
		ULONG64 pdpt_index : 9;
		ULONG64 pml4_index : 9;
		ULONG64 reserved : 16;
	};
	struct
	{
		ULONG64 large_page_offset : 21;
	};
} virt_addr_t, * pvirt_addr_t;

typedef struct _CURDIR
{
	struct _UNICODE_STRING DosPath;                                         //0x0
	VOID* Handle;                                                           //0x10
} CURDIR, * PCURDIR;

union ThreadMiscFlags
{
	struct
	{
		ULONG AutoBoostActive : 1;                                        //0x74
		ULONG ReadyTransition : 1;                                        //0x74
		ULONG WaitNext : 1;                                               //0x74
		ULONG SystemAffinityActive : 1;                                   //0x74
		ULONG Alertable : 1;                                              //0x74
		ULONG UserStackWalkActive : 1;                                    //0x74
		ULONG ApcInterruptRequest : 1;                                    //0x74
		ULONG QuantumEndMigrate : 1;                                      //0x74
		ULONG UmsDirectedSwitchEnable : 1;                                //0x74
		ULONG TimerActive : 1;                                            //0x74
		ULONG SystemThread : 1;                                           //0x74
		ULONG ProcessDetachActive : 1;                                    //0x74
		ULONG CalloutActive : 1;                                          //0x74
		ULONG ScbReadyQueue : 1;                                          //0x74
		ULONG ApcQueueable : 1;                                           //0x74
		ULONG ReservedStackInUse : 1;                                     //0x74
		ULONG UmsPerformingSyscall : 1;                                   //0x74
		ULONG TimerSuspended : 1;                                         //0x74
		ULONG SuspendedWaitMode : 1;                                      //0x74
		ULONG SuspendSchedulerApcWait : 1;                                //0x74
		ULONG CetUserShadowStack : 1;                                     //0x74
		ULONG BypassProcessFreeze : 1;                                    //0x74
		ULONG Reserved : 10;                                              //0x74
	};
	LONG MiscFlags;                                                     //0x74
};

#define MemoryWorkingSetList 1
#define MemorySectionName 2
#define MemoryBasicVlmInformation 3
#define MemoryWorkingSetExList 4

typedef union _PSAPI_WORKING_SET_BLOCK {
	ULONG_PTR Flags;
	struct {
		ULONG_PTR Protection : 5;
		ULONG_PTR ShareCount : 3;
		ULONG_PTR Shared : 1;
		ULONG_PTR Reserved : 3;
#if defined(_WIN64)
		ULONG_PTR VirtualPage : 52;
#else
		ULONG_PTR VirtualPage : 20;
#endif
	};
} PSAPI_WORKING_SET_BLOCK, * PPSAPI_WORKING_SET_BLOCK;

typedef struct _PSAPI_WORKING_SET_INFORMATION {
	ULONG_PTR NumberOfEntries;
	PSAPI_WORKING_SET_BLOCK WorkingSetInfo[1];
} PSAPI_WORKING_SET_INFORMATION, * PPSAPI_WORKING_SET_INFORMATION;

typedef union _PSAPI_WORKING_SET_EX_BLOCK {
	ULONG_PTR Flags;
	union {
		struct {
			ULONG_PTR Valid : 1;
			ULONG_PTR ShareCount : 3;
			ULONG_PTR Win32Protection : 11;
			ULONG_PTR Shared : 1;
			ULONG_PTR Node : 6;
			ULONG_PTR Locked : 1;
			ULONG_PTR LargePage : 1;
			ULONG_PTR Reserved : 7;
			ULONG_PTR Bad : 1;

#if defined(_WIN64)
			ULONG_PTR ReservedUlong : 32;
#endif
		};
		struct {
			ULONG_PTR Valid : 1;            // Valid = 0 in this format.
			ULONG_PTR Reserved0 : 14;
			ULONG_PTR Shared : 1;
			ULONG_PTR Reserved1 : 15;
			ULONG_PTR Bad : 1;

#if defined(_WIN64)
			ULONG_PTR ReservedUlong : 32;
#endif
		} Invalid;
	};
} PSAPI_WORKING_SET_EX_BLOCK, * PPSAPI_WORKING_SET_EX_BLOCK;

typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
	PVOID VirtualAddress;
	PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION, * PPSAPI_WORKING_SET_EX_INFORMATION;

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT, * PKAPC_ENVIRONMENT;

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID(NTAPI* PKRUNDOWN_ROUTINE)(PRKAPC Apc);

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID(NTAPI* PKKERNEL_ROUTINE)(
	PRKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
	);

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;                                                    //0x0
	ULONG Length;                                                           //0x4
	ULONG Flags;                                                            //0x8
	ULONG DebugFlags;                                                       //0xc
	VOID* ConsoleHandle;                                                    //0x10
	ULONG ConsoleFlags;                                                     //0x18
	VOID* StandardInput;                                                    //0x20
	VOID* StandardOutput;                                                   //0x28
	VOID* StandardError;                                                    //0x30
	struct _CURDIR CurrentDirectory;                                        //0x38
	struct _UNICODE_STRING DllPath;                                         //0x50
	struct _UNICODE_STRING ImagePathName;                                   //0x60
	struct _UNICODE_STRING CommandLine;                                     //0x70
	VOID* Environment;                                                      //0x80
	ULONG StartingX;                                                        //0x88
	ULONG StartingY;                                                        //0x8c
	ULONG CountX;                                                           //0x90
	ULONG CountY;                                                           //0x94
	ULONG CountCharsX;                                                      //0x98
	ULONG CountCharsY;                                                      //0x9c
	ULONG FillAttribute;                                                    //0xa0
	ULONG WindowFlags;                                                      //0xa4
	ULONG ShowWindowFlags;                                                  //0xa8
	struct _UNICODE_STRING WindowTitle;                                     //0xb0
	struct _UNICODE_STRING DesktopInfo;                                     //0xc0
	struct _UNICODE_STRING ShellInfo;                                       //0xd0
	struct _UNICODE_STRING RuntimeData;                                     //0xe0
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB32 {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR Spare;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG/*PPEB_LDR_DATA32*/ Ldr;
	ULONG ProcessParameters;
} PEB32, * PPEB32;

typedef struct _PEB64 {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR Spare;
	UCHAR Padding0[4];
	ULONG64 Mutant;
	ULONG64 ImageBaseAddress;
	ULONG64/*PPEB_LDR_DATA64*/ Ldr;
	RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
} PEB64, * PPEB64;


typedef struct _PEB_LDR_DATA32 {
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
	ULONG EntryInProgress;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
	ULONG LoadedImports;
	ULONG EntryPointActivationContext;
	ULONG PatchInformation;
	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;
	ULONG ContextInformation;
	ULONG OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB_LDR_DATA64 {
	ULONG Length;
	UCHAR Initialized;
	ULONG64 SsHandle;
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	ULONG64 EntryInProgress;
} PEB_LDR_DATA64, * PPEB_LDR_DATA64;

typedef struct _LDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	LIST_ENTRY64 InMemoryOrderLinks;
	LIST_ENTRY64 InInitializationOrderLinks;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG64 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY64 HashLinks;
	ULONG64 SectionPointer;
	ULONG64 CheckSum;
	ULONG64 TimeDateStamp;
	ULONG64 LoadedImports;
	ULONG64 EntryPointActivationContext;
	ULONG64 PatchInformation;
	LIST_ENTRY64 ForwarderLinks;
	LIST_ENTRY64 ServiceTagLinks;
	LIST_ENTRY64 StaticLinks;
	ULONG64 ContextInformation;
	ULONG64 OriginalBase;
	LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY64, * PLDR_DATA_TABLE_ENTRY64;

#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))
#define RVA2(Instr, InstrSize, Off) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + Off))

//typedef enum _PROCESS_INFORMATION_CLASS
//{
//	ProcessBasicInformation = 0, // 0, q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
//	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
//	ProcessIoCounters, // q: IO_COUNTERS
//	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX
//	ProcessTimes, // q: KERNEL_USER_TIMES
//	ProcessBasePriority, // s: KPRIORITY
//	ProcessRaisePriority, // s: ULONG
//	ProcessDebugPort, // q: HANDLE
//	ProcessExceptionPort, // s: HANDLE
//	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
//	ProcessLdtInformation, // 10
//	ProcessLdtSize,
//	ProcessDefaultHardErrorMode, // qs: ULONG
//	ProcessIoPortHandlers, // (kernel-mode only)
//	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
//	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
//	ProcessUserModeIOPL,
//	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
//	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
//	ProcessWx86Information,
//	ProcessHandleCount, // 20, q: ULONG, PROCESS_HANDLE_INFORMATION
//	ProcessAffinityMask, // s: KAFFINITY
//	ProcessPriorityBoost, // qs: ULONG
//	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
//	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
//	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
//	ProcessWow64Information, // q: ULONG_PTR
//	ProcessImageFileName, // q: UNICODE_STRING
//	ProcessLUIDDeviceMapsEnabled, // q: ULONG
//	ProcessBreakOnTermination, // qs: ULONG
//	ProcessDebugObjectHandle, // 30, q: HANDLE
//	ProcessDebugFlags, // qs: ULONG
//	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
//	ProcessIoPriority, // qs: ULONG
//	ProcessExecuteFlags, // qs: ULONG
//	ProcessResourceManagement,
//	ProcessCookie, // q: ULONG
//	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
//	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION
//	ProcessPagePriority, // q: ULONG
//	ProcessInstrumentationCallback, // 40
//	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
//	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
//	ProcessImageFileNameWin32, // q: UNICODE_STRING
//	ProcessImageFileMapping, // q: HANDLE (input)
//	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
//	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
//	ProcessGroupInformation, // q: USHORT[]
//	ProcessTokenVirtualizationEnabled, // s: ULONG
//	ProcessConsoleHostProcess, // q: ULONG_PTR
//	ProcessWindowInformation, // 50, q: PROCESS_WINDOW_INFORMATION
//	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
//	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
//	ProcessDynamicFunctionTableInformation,
//	ProcessHandleCheckingMode,
//	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
//	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
//	MaxProcessInfoClass
//} PROCESS_INFORMATION_CLASS;

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
	//
	// Link to other blocks
	//
	LIST_ENTRY64 List;

	//
	// This is a unique tag to identify the owner of the block.
	// If your component only uses one pool tag, use it for this, too.
	//
	ULONG           OwnerTag;

	//
	// This must be initialized to the size of the data block,
	// including this structure.
	//
	ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64 {

	DBGKD_DEBUG_DATA_HEADER64 Header;

	//
	// Base address of kernel image
	//
	ULONG64   KernBase;

	//
	// DbgBreakPointWithStatus is a function which takes an argument
	// and hits a breakpoint.  This field contains the address of the
	// breakpoint instruction.  When the debugger sees a breakpoint
	// at this address, it may retrieve the argument from the first
	// argument register, or on x86 the eax register.
	//
	ULONG64   BreakpointWithStatus;       // address of breakpoint

	//
	// Address of the saved context record during a bugcheck
	//
	// N.B. This is an automatic in KeBugcheckEx's frame, and
	// is only valid after a bugcheck.
	//
	ULONG64   SavedContext;

	//
	// help for walking stacks with user callbacks:
	//

	//
	// The address of the thread structure is provided in the
	// WAIT_STATE_CHANGE packet.  This is the offset from the base of
	// the thread structure to the pointer to the kernel stack frame
	// for the currently active usermode callback.
	//
	USHORT  ThCallbackStack;            // offset in thread data

	//
	// these values are offsets into that frame:
	//
	USHORT  NextCallback;               // saved pointer to next callback frame
	USHORT  FramePointer;               // saved frame pointer

	//
	// pad to a quad boundary
	//
	USHORT  PaeEnabled;

	//
	// Address of the kernel callout routine.
	//
	ULONG64   KiCallUserMode;             // kernel routine

	//
	// Address of the usermode entry point for callbacks.
	//
	ULONG64   KeUserCallbackDispatcher;   // address in ntdll

	//
	// Addresses of various kernel data structures and lists
	// that are of interest to the kernel debugger.
	//

	ULONG64   PsLoadedModuleList;
	ULONG64   PsActiveProcessHead;
	ULONG64   PspCidTable;

	ULONG64   ExpSystemResourcesList;
	ULONG64   ExpPagedPoolDescriptor;
	ULONG64   ExpNumberOfPagedPools;

	ULONG64   KeTimeIncrement;
	ULONG64   KeBugCheckCallbackListHead;
	ULONG64   KiBugcheckData;

	ULONG64   IopErrorLogListHead;

	ULONG64   ObpRootDirectoryObject;
	ULONG64   ObpTypeObjectType;

	ULONG64   MmSystemCacheStart;
	ULONG64   MmSystemCacheEnd;
	ULONG64   MmSystemCacheWs;

	ULONG64   MmPfnDatabase;
	ULONG64   MmSystemPtesStart;
	ULONG64   MmSystemPtesEnd;
	ULONG64   MmSubsectionBase;
	ULONG64   MmNumberOfPagingFiles;

	ULONG64   MmLowestPhysicalPage;
	ULONG64   MmHighestPhysicalPage;
	ULONG64   MmNumberOfPhysicalPages;

	ULONG64   MmMaximumNonPagedPoolInBytes;
	ULONG64   MmNonPagedSystemStart;
	ULONG64   MmNonPagedPoolStart;
	ULONG64   MmNonPagedPoolEnd;

	ULONG64   MmPagedPoolStart;
	ULONG64   MmPagedPoolEnd;
	ULONG64   MmPagedPoolInformation;
	ULONG64   MmPageSize;

	ULONG64   MmSizeOfPagedPoolInBytes;

	ULONG64   MmTotalCommitLimit;
	ULONG64   MmTotalCommittedPages;
	ULONG64   MmSharedCommit;
	ULONG64   MmDriverCommit;
	ULONG64   MmProcessCommit;
	ULONG64   MmPagedPoolCommit;
	ULONG64   MmExtendedCommit;

	ULONG64   MmZeroedPageListHead;
	ULONG64   MmFreePageListHead;
	ULONG64   MmStandbyPageListHead;
	ULONG64   MmModifiedPageListHead;
	ULONG64   MmModifiedNoWritePageListHead;
	ULONG64   MmAvailablePages;
	ULONG64   MmResidentAvailablePages;

	ULONG64   PoolTrackTable;
	ULONG64   NonPagedPoolDescriptor;

	ULONG64   MmHighestUserAddress;
	ULONG64   MmSystemRangeStart;
	ULONG64   MmUserProbeAddress;

	ULONG64   KdPrintCircularBuffer;
	ULONG64   KdPrintCircularBufferEnd;
	ULONG64   KdPrintWritePointer;
	ULONG64   KdPrintRolloverCount;

	ULONG64   MmLoadedUserImageList;

	// NT 5.1 Addition

	ULONG64   NtBuildLab;
	ULONG64   KiNormalSystemCall;

	// NT 5.0 hotfix addition

	ULONG64   KiProcessorBlock;
	ULONG64   MmUnloadedDrivers;
	ULONG64   MmLastUnloadedDriver;
	ULONG64   MmTriageActionTaken;
	ULONG64   MmSpecialPoolTag;
	ULONG64   KernelVerifier;
	ULONG64   MmVerifierData;
	ULONG64   MmAllocatedNonPagedPool;
	ULONG64   MmPeakCommitment;
	ULONG64   MmTotalCommitLimitMaximum;
	ULONG64   CmNtCSDVersion;

	// NT 5.1 Addition

	ULONG64   MmPhysicalMemoryBlock;
	ULONG64   MmSessionBase;
	ULONG64   MmSessionSize;
	ULONG64   MmSystemParentTablePage;

	// Server 2003 addition

	ULONG64   MmVirtualTranslationBase;

	USHORT    OffsetKThreadNextProcessor;
	USHORT    OffsetKThreadTeb;
	USHORT    OffsetKThreadKernelStack;
	USHORT    OffsetKThreadInitialStack;

	USHORT    OffsetKThreadApcProcess;
	USHORT    OffsetKThreadState;
	USHORT    OffsetKThreadBStore;
	USHORT    OffsetKThreadBStoreLimit;

	USHORT    SizeEProcess;
	USHORT    OffsetEprocessPeb;
	USHORT    OffsetEprocessParentCID;
	USHORT    OffsetEprocessDirectoryTableBase;

	USHORT    SizePrcb;
	USHORT    OffsetPrcbDpcRoutine;
	USHORT    OffsetPrcbCurrentThread;
	USHORT    OffsetPrcbMhz;

	USHORT    OffsetPrcbCpuType;
	USHORT    OffsetPrcbVendorString;
	USHORT    OffsetPrcbProcStateContext;
	USHORT    OffsetPrcbNumber;

	USHORT    SizeEThread;

	ULONG64   KdPrintCircularBufferPtr;
	ULONG64   KdPrintBufferSize;

	ULONG64   KeLoaderBlock;

	USHORT    SizePcr;
	USHORT    OffsetPcrSelfPcr;
	USHORT    OffsetPcrCurrentPrcb;
	USHORT    OffsetPcrContainedPrcb;

	USHORT    OffsetPcrInitialBStore;
	USHORT    OffsetPcrBStoreLimit;
	USHORT    OffsetPcrInitialStack;
	USHORT    OffsetPcrStackLimit;

	USHORT    OffsetPrcbPcrPage;
	USHORT    OffsetPrcbProcStateSpecialReg;
	USHORT    GdtR0Code;
	USHORT    GdtR0Data;

	USHORT    GdtR0Pcr;
	USHORT    GdtR3Code;
	USHORT    GdtR3Data;
	USHORT    GdtR3Teb;

	USHORT    GdtLdt;
	USHORT    GdtTss;
	USHORT    Gdt64R3CmCode;
	USHORT    Gdt64R3CmTeb;

	ULONG64   IopNumTriageDumpDataBlocks;
	ULONG64   IopTriageDumpDataBlocks;

	// Longhorn addition

	ULONG64   VfCrashDataBlock;
	ULONG64   MmBadPagesDetected;
	ULONG64   MmZeroedPageSingleBitErrorsDetected;

	// Windows 7 addition

	ULONG64   EtwpDebuggerData;
	USHORT    OffsetPrcbContext;

	// Windows 8 addition

	USHORT    OffsetPrcbMaxBreakpoints;
	USHORT    OffsetPrcbMaxWatchpoints;

	ULONG     OffsetKThreadStackLimit;
	ULONG     OffsetKThreadStackBase;
	ULONG     OffsetKThreadQueueListEntry;
	ULONG     OffsetEThreadIrpList;

	USHORT    OffsetPrcbIdleThread;
	USHORT    OffsetPrcbNormalDpcState;
	USHORT    OffsetPrcbDpcStack;
	USHORT    OffsetPrcbIsrStack;

	USHORT    SizeKDPC_STACK_FRAME;

	// Windows 8.1 Addition

	USHORT    OffsetKPriQueueThreadListHead;
	USHORT    OffsetKThreadWaitReason;

	// Windows 10 RS1 Addition

	USHORT    Padding;
	ULONG64   PteBase;

	// Windows 10 RS5 Addition

	ULONG64 RetpolineStubFunctionTable;
	ULONG RetpolineStubFunctionTableSize;
	ULONG RetpolineStubOffset;
	ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;

typedef struct _DUMP_HEADER
{
	ULONG Signature;
	ULONG ValidDump;
	ULONG MajorVersion;
	ULONG MinorVersion;
	ULONG_PTR DirectoryTableBase;
	ULONG_PTR PfnDataBase;
	PLIST_ENTRY PsLoadedModuleList;
	PLIST_ENTRY PsActiveProcessHead;
	ULONG MachineImageType;
	ULONG NumberProcessors;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParameter1;
	ULONG_PTR BugCheckParameter2;
	ULONG_PTR BugCheckParameter3;
	ULONG_PTR BugCheckParameter4;
	CHAR VersionUser[32];
	struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, * PDUMP_HEADER;

C_ASSERT(FIELD_OFFSET(DUMP_HEADER, Signature) == 0);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, ValidDump) == 4);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MajorVersion) == 8);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MinorVersion) == 0xc);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, DirectoryTableBase) == 0x10);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PfnDataBase) == 0x18);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsLoadedModuleList) == 0x20);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsActiveProcessHead) == 0x28);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MachineImageType) == 0x30);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, NumberProcessors) == 0x34);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckCode) == 0x38);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter1) == 0x40);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter2) == 0x48);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter3) == 0x50);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter4) == 0x58);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, KdDebuggerDataBlock) == 0x80);

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;
typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
	ULONG SessionId;
	ULONG SizeOfBuf;
	PVOID Buffer;
}SYSTEM_SESSION_PROCESS_INFORMATION, * PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG Reserved[40];
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_SERVICE_TABLE {
	LONG* ServiceTable;
	PVOID ServiceCounterTableBase;
	ULONG64 NumberOfService;
	PVOID ParamTableBase;
}_SYSTEM_SERVICE_TABLE, * PSYSTEM_SERVICE_TABLE;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
}SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
}SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _CFG_CALL_TARGET_INFO {
	ULONG_PTR Offset;
	ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, * PCFG_CALL_TARGET_INFO;

typedef struct _VM_INFORMATION
{
	DWORD NumberOfOffsets;
	DWORD MustBeZero;
	PVOID TargetsProcessed;
	PCFG_CALL_TARGET_INFO CallTargets;
	union _Section
	{
		HANDLE Section;
		DWORD64 Data;
	} Section;
	ULONG64 ExpectedFileOffset;
} VM_INFORMATION, * PVM_INFORMATION;

union MiscFlags
{
	struct
	{
		ULONG AutoBoostActive : 1;                                        //0x74
		ULONG ReadyTransition : 1;                                        //0x74
		ULONG WaitNext : 1;                                               //0x74
		ULONG SystemAffinityActive : 1;                                   //0x74
		ULONG Alertable : 1;                                              //0x74
		ULONG UserStackWalkActive : 1;                                    //0x74
		ULONG ApcInterruptRequest : 1;                                    //0x74
		ULONG QuantumEndMigrate : 1;                                      //0x74
		ULONG UmsDirectedSwitchEnable : 1;                                //0x74
		ULONG TimerActive : 1;                                            //0x74
		ULONG SystemThread : 1;                                           //0x74
		ULONG ProcessDetachActive : 1;                                    //0x74
		ULONG CalloutActive : 1;                                          //0x74
		ULONG ScbReadyQueue : 1;                                          //0x74
		ULONG ApcQueueable : 1;                                           //0x74
		ULONG ReservedStackInUse : 1;                                     //0x74
		ULONG UmsPerformingSyscall : 1;                                   //0x74
		ULONG TimerSuspended : 1;                                         //0x74
		ULONG SuspendedWaitMode : 1;                                      //0x74
		ULONG SuspendSchedulerApcWait : 1;                                //0x74
		ULONG CetUserShadowStack : 1;                                     //0x74
		ULONG BypassProcessFreeze : 1;                                    //0x74
		ULONG Reserved : 10;                                              //0x74
	};
	LONG AsLong;                                                     //0x74
};

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
	union {
		PM128A FloatingContext[16];
		struct {
			PM128A Xmm0;
			PM128A Xmm1;
			PM128A Xmm2;
			PM128A Xmm3;
			PM128A Xmm4;
			PM128A Xmm5;
			PM128A Xmm6;
			PM128A Xmm7;
			PM128A Xmm8;
			PM128A Xmm9;
			PM128A Xmm10;
			PM128A Xmm11;
			PM128A Xmm12;
			PM128A Xmm13;
			PM128A Xmm14;
			PM128A Xmm15;
		};
	};

	union {
		PULONG64 IntegerContext[16];
		struct {
			PULONG64 Rax;
			PULONG64 Rcx;
			PULONG64 Rdx;
			PULONG64 Rbx;
			PULONG64 Rsp;
			PULONG64 Rbp;
			PULONG64 Rsi;
			PULONG64 Rdi;
			PULONG64 R8;
			PULONG64 R9;
			PULONG64 R10;
			PULONG64 R11;
			PULONG64 R12;
			PULONG64 R13;
			PULONG64 R14;
			PULONG64 R15;
		};
	};

} KNONVOLATILE_CONTEXT_POINTERS, * PKNONVOLATILE_CONTEXT_POINTERS;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, * PRUNTIME_FUNCTION;

typedef struct _KSTACK_CONTROL
{
	ULONGLONG StackBase;                                                    //0x0
	union
	{
		ULONGLONG ActualLimit;                                              //0x8
		ULONGLONG StackExpansion : 1;                                         //0x8
	};
	struct
	{
		ULONGLONG StackBase;                                                    //0x10
		ULONGLONG StackLimit;                                                   //0x18
		ULONGLONG KernelStack;                                                  //0x20
		ULONGLONG InitialStack;                                                 //0x28
		ULONGLONG KernelShadowStackBase;                                        //0x30
		ULONGLONG KernelShadowStackLimit;										//0x38
		ULONGLONG KernelShadowStack;                                            //0x40
		ULONGLONG KernelShadowStackInitial;                                     //0x48
	} Previous;
}KERNEL_STACK_CONTROL, KSTACK_CONTROL, * PKERNEL_STACK_CONTROL, * PKSTACK_CONTROL;
static_assert(sizeof(KERNEL_STACK_CONTROL) == 0x50, "size mismatch");


//Physical or Virtual is Ok
//just assume it's not large page
#define IsAcrossPages(Address,size) (( PAGE_ALIGN((u64)Address+(u64)size) == PAGE_ALIGN(Address) ) ? FALSE : TRUE)

#define noinl __declspec(noinline)
#define naked __declspec(naked)
#define inl __forceinline
#define ConstStrLen(Str) ((sizeof(Str) - sizeof(Str[0])) / sizeof(Str[0]))
#define ToLower(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)
#define ToUpper(Char) ((Char >= 'a' && Char <= 'z') ? (Char - 'a') : Char)
#define NT_HEADER(Base) (PIMAGE_NT_HEADERS)((ULONG64)(Base) + ((PIMAGE_DOS_HEADER)(Base))->e_lfanew)

```

`README.md`:

```md
# RemoteCall

kernelapc -> set trapframe -> user call driver io function -> driver io -> usermode call .

```

`SetContextUserCall.cpp`:

```cpp
#include "global.h"
#include "callback.h"
#include <PipiDrv/SharedCommunicateDef.h>
#include "SetContextUserCall.h"

#define EFLAGS_IF_MASK 0x00000200       // interrupt flag
#define CONTEXT_EXCEPTION_FLAGS (CONTEXT_EXCEPTION_ACTIVE | CONTEXT_SERVICE_ACTIVE)
#define DR7_LEGAL 0xffff0355
#define DR7_ACTIVE 0x0355
#define DR7_TRACE_BRANCH 0x200
#define DR7_LAST_BRANCH 0x100
#define KGDT64_NULL (0 * 16)            // NULL descriptor
#define KGDT64_R0_CODE (1 * 16)         // kernel mode 64-bit code
#define KGDT64_R0_DATA (1 * 16) + 8     // kernel mode 64-bit data (stack)
#define KGDT64_R3_CMCODE (2 * 16)       // user mode 32-bit code
#define KGDT64_R3_DATA (2 * 16) + 8     // user mode 32-bit data
#define KGDT64_R3_CODE (3 * 16)         // user mode 64-bit code
#define KGDT64_SYS_TSS (4 * 16)         // kernel mode system task state
#define KGDT64_R3_CMTEB (5 * 16)        // user mode 32-bit TEB
#define KGDT64_R0_CMCODE (6 * 16)       // kernel mode 32-bit code
#define KGDT64_LAST (7 * 16)            // last entry
#define RPL_MASK 3
#define KiMxCsrMask 0xFFBF
#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)
#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4
#define SANITIZE_DR7(Dr7, mode) ((Dr7) & DR7_LEGAL)
#define SANITIZE_DRADDR(DrReg, mode)                                         \
    ((mode) == KernelMode ?                                                  \
        (DrReg) :                                                            \
        (((PVOID)(DrReg) <= MM_HIGHEST_USER_ADDRESS) ? (DrReg) : 0))

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMxCsrMask)

#define SANITIZE_FCW(_fcw_) ((_fcw_) & 0x1f3f)

#define EFLAGS_SANITIZE 0x00210fd5L

#define SANITIZE_EFLAGS(eFlags, mode) (                                      \
    ((mode) == KernelMode ?                                                  \
        ((eFlags) & EFLAGS_SANITIZE) :                                       \
        (((eFlags) & EFLAGS_SANITIZE) | EFLAGS_IF_MASK)))

#define SIGN_EXTEND_BIT(_va_, _bit_) \
    (ULONG64)(((LONG64)(_va_) << (64 - (_bit_))) >> (64 - (_bit_)))






ULONG64
SetCtxCall::SANITIZE_VA(
	IN ULONG64 VirtualAddress,
	IN USHORT Segment,
	IN KPROCESSOR_MODE PreviousMode
)

/*++

Routine Description:

	This routine canonicalizes a 64-bit virtual address according to the
	supplied segment selector.

Arguments:

	VirtualAddress - Supplies the 64-bit virtual address to canonicalize.

	Segment - Supplies the selector for for the virtual address.

	PreviousMode - Supplies the processor mode for which the exception and
		trap frames are being built.

Return Value:

	Returns the canonicalized virtual address.

--*/

{

	ULONG64 Va;

	if (PreviousMode == UserMode) {

		//
		// Zero-extend 32-bit addresses, sign extend bit 48 of 64-bit
		// addresses.
		// 

		if ((Segment == (KGDT64_R3_CMCODE | RPL_MASK)) ||
			(Segment == (KGDT64_R3_DATA | RPL_MASK))) {

			Va = (ULONG)VirtualAddress;

		}
		else {
			Va = SIGN_EXTEND_BIT(VirtualAddress, 48);
		}

	}
	else {
		Va = VirtualAddress;
	}

	return Va;
}

VOID
SetCtxCall::PspGetContext(
	IN PKTRAP_FRAME TrapFrame,
	IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
	IN OUT PCONTEXT ContextRecord
)

/*++

Routine Description:

	This function selectively moves the contents of the specified trap frame
	and nonvolatile context to the specified context record.

Arguments:

	TrapFrame - Supplies the contents of a trap frame.

	ContextPointers - Supplies the address of context pointers record.

	ContextRecord - Supplies the address of a context record.

Return Value:

	None.

--*/

{

	ULONG ContextFlags;

	PAGED_CODE();

	//
	// Get control information if specified.
	//

	ContextFlags = ContextRecord->ContextFlags;
	if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

		//
		// Set registers RIP, CS, RSP, SS, and EFlags.
		//

		ContextRecord->Rip = TrapFrame->Rip;
		ContextRecord->SegCs = TrapFrame->SegCs;
		ContextRecord->SegSs = TrapFrame->SegSs;
		ContextRecord->Rsp = TrapFrame->Rsp;
		ContextRecord->EFlags = TrapFrame->EFlags;
	}

	//
	// Get segment register contents if specified.
	//

	if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

		//
		// Set segment registers GS, FS, ES, DS.
		//

		ContextRecord->SegDs = KGDT64_R3_DATA | RPL_MASK;
		ContextRecord->SegEs = KGDT64_R3_DATA | RPL_MASK;
		ContextRecord->SegFs = KGDT64_R3_CMTEB | RPL_MASK;
		ContextRecord->SegGs = KGDT64_R3_DATA | RPL_MASK;
	}

	//
	//  Get integer register contents if specified.
	//

	if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

		//
		// Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
		// RBP, R11, R12, R13, R14, and R15.
		//

		ContextRecord->Rax = TrapFrame->Rax;
		ContextRecord->Rcx = TrapFrame->Rcx;
		ContextRecord->Rdx = TrapFrame->Rdx;
		ContextRecord->R8 = TrapFrame->R8;
		ContextRecord->R9 = TrapFrame->R9;
		ContextRecord->R10 = TrapFrame->R10;
		ContextRecord->R11 = TrapFrame->R11;

		ContextRecord->Rbx = *ContextPointers->Rbx;
		ContextRecord->Rbp = *ContextPointers->Rbp;
		ContextRecord->Rsi = *ContextPointers->Rsi;
		ContextRecord->Rdi = *ContextPointers->Rdi;
		ContextRecord->R12 = *ContextPointers->R12;
		ContextRecord->R13 = *ContextPointers->R13;
		ContextRecord->R14 = *ContextPointers->R14;
		ContextRecord->R15 = *ContextPointers->R15;
	}

	//
	// Get floating point context if specified.
	//

	if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

		//
		// Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
		//
		// N.B. The legacy floating state is handled separately.
		//

		ContextRecord->Xmm0 = TrapFrame->Xmm0;
		ContextRecord->Xmm1 = TrapFrame->Xmm1;
		ContextRecord->Xmm2 = TrapFrame->Xmm2;
		ContextRecord->Xmm3 = TrapFrame->Xmm3;
		ContextRecord->Xmm4 = TrapFrame->Xmm4;
		ContextRecord->Xmm5 = TrapFrame->Xmm5;

		ContextRecord->Xmm6 = *ContextPointers->Xmm6;
		ContextRecord->Xmm7 = *ContextPointers->Xmm7;
		ContextRecord->Xmm8 = *ContextPointers->Xmm8;
		ContextRecord->Xmm9 = *ContextPointers->Xmm9;
		ContextRecord->Xmm10 = *ContextPointers->Xmm10;
		ContextRecord->Xmm11 = *ContextPointers->Xmm11;
		ContextRecord->Xmm12 = *ContextPointers->Xmm12;
		ContextRecord->Xmm13 = *ContextPointers->Xmm13;
		ContextRecord->Xmm14 = *ContextPointers->Xmm14;
		ContextRecord->Xmm15 = *ContextPointers->Xmm15;

		ContextRecord->MxCsr = TrapFrame->MxCsr;
	}

	//
	//
	// Get debug register contents if requested.
	//

	if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

		//
		// Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
		//

		if ((TrapFrame->Dr7 & DR7_ACTIVE) != 0) {
			ContextRecord->Dr0 = TrapFrame->Dr0;
			ContextRecord->Dr1 = TrapFrame->Dr1;
			ContextRecord->Dr2 = TrapFrame->Dr2;
			ContextRecord->Dr3 = TrapFrame->Dr3;
			ContextRecord->Dr6 = TrapFrame->Dr6;
			ContextRecord->Dr7 = TrapFrame->Dr7;
			if ((TrapFrame->Dr7 & DR7_LAST_BRANCH) != 0) {
				ContextRecord->LastBranchToRip = TrapFrame->LastBranchToRip;
				ContextRecord->LastBranchFromRip = TrapFrame->LastBranchFromRip;
				ContextRecord->LastExceptionToRip = TrapFrame->LastExceptionToRip;
				ContextRecord->LastExceptionFromRip = TrapFrame->LastExceptionFromRip;

			}
			else {
				ContextRecord->LastBranchToRip = 0;
				ContextRecord->LastBranchFromRip = 0;
				ContextRecord->LastExceptionToRip = 0;
				ContextRecord->LastExceptionFromRip = 0;
			}

		}
		else {
			ContextRecord->Dr0 = 0;
			ContextRecord->Dr1 = 0;
			ContextRecord->Dr2 = 0;
			ContextRecord->Dr3 = 0;
			ContextRecord->Dr6 = 0;
			ContextRecord->Dr7 = 0;
			ContextRecord->LastBranchToRip = 0;
			ContextRecord->LastBranchFromRip = 0;
			ContextRecord->LastExceptionToRip = 0;
			ContextRecord->LastExceptionFromRip = 0;
		}
	}

	//
	// Get exception reporting information if requested.
	//

	if ((ContextFlags & CONTEXT_EXCEPTION_REQUEST) != 0) {
		ContextRecord->ContextFlags &= ~CONTEXT_EXCEPTION_FLAGS;
		ContextRecord->ContextFlags |= CONTEXT_EXCEPTION_REPORTING;
		if (TrapFrame->ExceptionActive == 1) {
			ContextRecord->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;

		}
		else if (TrapFrame->ExceptionActive == 2) {
			ContextRecord->ContextFlags |= CONTEXT_SERVICE_ACTIVE;
		}
	}

	return;
}

VOID
SetCtxCall::PspSetContext(
	OUT PKTRAP_FRAME TrapFrame,
	OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
	IN PCONTEXT ContextRecord,
	KPROCESSOR_MODE PreviousMode
)

/*++

Routine Description:

	This function selectively moves the contents of the specified context
	record to the specified trap frame and nonvolatile context.

Arguments:

	TrapFrame - Supplies the address of a trap frame.

	ContextPointers - Supplies the address of a context pointers record.

	ContextRecord - Supplies the address of a context record.

	ProcessorMode - Supplies the processor mode to use when sanitizing
		the PSR and FSR.

Return Value:

	None.

--*/

{

	ULONG ContextFlags;

	PAGED_CODE();

	//
	// Set control information if specified.
	//

	ContextFlags = ContextRecord->ContextFlags;
	if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
		TrapFrame->EFlags = SANITIZE_EFLAGS(ContextRecord->EFlags, PreviousMode);
		TrapFrame->Rip = ContextRecord->Rip;
		TrapFrame->Rsp = ContextRecord->Rsp;
	}

	//
	// The segment registers DS, ES, FS, and GS are never restored from saved
	// data. However, SS and CS are restored from the trap frame. Make sure
	// that these segment registers have the proper values.
	//

	if (PreviousMode == UserMode) {
		TrapFrame->SegSs = KGDT64_R3_DATA | RPL_MASK;
		if (ContextRecord->SegCs != (KGDT64_R3_CODE | RPL_MASK)) {
			TrapFrame->SegCs = KGDT64_R3_CMCODE | RPL_MASK;

		}
		else {
			TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
		}

	}
	else {
		TrapFrame->SegCs = KGDT64_R0_CODE;
		TrapFrame->SegSs = KGDT64_NULL;
	}

	TrapFrame->Rip = SANITIZE_VA(TrapFrame->Rip, TrapFrame->SegCs, PreviousMode);

	//
	// Set integer registers contents if specified.
	//

	if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

		//
		// Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
		// RBP, R11, R12, R13, R14, and R15.
		//

		TrapFrame->Rax = ContextRecord->Rax;
		TrapFrame->Rcx = ContextRecord->Rcx;
		TrapFrame->Rdx = ContextRecord->Rdx;
		TrapFrame->R8 = ContextRecord->R8;
		TrapFrame->R9 = ContextRecord->R9;
		TrapFrame->R10 = ContextRecord->R10;
		TrapFrame->R11 = ContextRecord->R11;

		*ContextPointers->Rbx = ContextRecord->Rbx;
		*ContextPointers->Rbp = ContextRecord->Rbp;
		*ContextPointers->Rsi = ContextRecord->Rsi;
		*ContextPointers->Rdi = ContextRecord->Rdi;
		*ContextPointers->R12 = ContextRecord->R12;
		*ContextPointers->R13 = ContextRecord->R13;
		*ContextPointers->R14 = ContextRecord->R14;
		*ContextPointers->R15 = ContextRecord->R15;
	}

	//
	// Set floating register contents if requested.
	//

	if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

		//
		// Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
		//
		// N.B. The legacy floating state is handled separately.
		//

		TrapFrame->Xmm0 = ContextRecord->Xmm0;
		TrapFrame->Xmm1 = ContextRecord->Xmm1;
		TrapFrame->Xmm2 = ContextRecord->Xmm2;
		TrapFrame->Xmm3 = ContextRecord->Xmm3;
		TrapFrame->Xmm4 = ContextRecord->Xmm4;
		TrapFrame->Xmm5 = ContextRecord->Xmm5;

		*ContextPointers->Xmm6 = ContextRecord->Xmm6;
		*ContextPointers->Xmm7 = ContextRecord->Xmm7;
		*ContextPointers->Xmm8 = ContextRecord->Xmm8;
		*ContextPointers->Xmm9 = ContextRecord->Xmm9;
		*ContextPointers->Xmm10 = ContextRecord->Xmm10;
		*ContextPointers->Xmm11 = ContextRecord->Xmm11;
		*ContextPointers->Xmm12 = ContextRecord->Xmm12;
		*ContextPointers->Xmm13 = ContextRecord->Xmm13;
		*ContextPointers->Xmm14 = ContextRecord->Xmm14;
		*ContextPointers->Xmm15 = ContextRecord->Xmm15;

		//
		// Clear all reserved bits in MXCSR.
		//

		TrapFrame->MxCsr = SANITIZE_MXCSR(ContextRecord->MxCsr);

		//
		// Clear all reserved bits in legacy floating state.
		//
		// N.B. The legacy floating state is restored if and only if the
		//      request mode is user.
		//
		// N.B. The current MXCSR value is placed in the legacy floating
		//      state so it will get restored if the legacy state is
		//      restored.
		//

		ContextRecord->FltSave.MxCsr = ReadMxCsr();
		ContextRecord->FltSave.ControlWord =
			SANITIZE_FCW(ContextRecord->FltSave.ControlWord);
	}

	//
	// Set debug register state if specified.
	//

	//if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {
	//
	//	//
	//	// Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
	//	//
	//
	//	TrapFrame->Dr0 = SANITIZE_DRADDR(ContextRecord->Dr0, PreviousMode);
	//	TrapFrame->Dr1 = SANITIZE_DRADDR(ContextRecord->Dr1, PreviousMode);
	//	TrapFrame->Dr2 = SANITIZE_DRADDR(ContextRecord->Dr2, PreviousMode);
	//	TrapFrame->Dr3 = SANITIZE_DRADDR(ContextRecord->Dr3, PreviousMode);
	//	TrapFrame->Dr6 = 0;
	//	TrapFrame->Dr7 = SANITIZE_DR7(ContextRecord->Dr7, PreviousMode);
	//	if (PreviousMode != KernelMode) {
	//		KeGetCurrentThread()->Header.DebugActive =
	//			(BOOLEAN)((TrapFrame->Dr7 & DR7_ACTIVE) != 0);
	//	}
	//}

	return;
}

PKTRAP_FRAME
SetCtxCall::PspGetBaseTrapFrame(
	PETHREAD Thread
)
{
	ULONG64 InitialStack;
	PKERNEL_STACK_CONTROL StackControl;

	InitialStack = *(u64*)((u64)Thread + 0x28);
	StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
	while (StackControl->StackExpansion) {
		InitialStack = StackControl->Previous.InitialStack;
		StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
	}

	return (PKTRAP_FRAME)(InitialStack - KTRAP_FRAME_LENGTH);
}


void SetCtxCall::HkCommunicate()
{
	__dbgdb();
	do
	{
		auto TrapFrame = PsGetTrapFrame();
		if (
			!TrapFrame ||
			!IsValid(TrapFrame->Rsp) ||
			(*(u64*)(TrapFrame->Rsp + 8) != PIPI_CALL_IDENTIFIYER)
			)
		{
			__dbgdb();
			break;
		}

		SetCtxCall* thisptr = *(SetCtxCall**)(TrapFrame->Rsp + 0x10);
		if (!IsValid(thisptr))	{
			__dbgdb();
			break;
		}

		//tf->Rsp -= 8;
		if (!thisptr->bUserCallInit) {
			thisptr->CtxUserCall.Init();
			thisptr->bUserCallInit = true;
		}

		PSET_CONTEXT_CALL_INFORMATION CallInfo = thisptr->CallInfo;

		if (CallInfo->PreCallKernelRoutine)
		{
			CallInfo->PreCallKernelRoutine(thisptr->CallInfo);
		}

		CallInfo->ReturnVal = thisptr->CtxUserCall.Call(
			CallInfo->UserFunction, 
			CallInfo->Param[0].AsU64, 
			CallInfo->Param[1].AsU64, 
			CallInfo->Param[2].AsU64,
			CallInfo->Param[3].AsU64);

		if (CallInfo->PostCallKernelRoutine)
		{
			CallInfo->PostCallKernelRoutine(thisptr->CallInfo);
		}

		ImpCall(KeSetEvent, &CallInfo->Event, IO_KEYBOARD_INCREMENT, FALSE);



	} while (false);

	
}




VOID SetCtxCall::SetCtxApcCallback(
	PRKAPC Apc,
	PKNORMAL_ROUTINE* NormalRoutine,
	PVOID* NormalContext,
	PVOID* SystemArgument1,
	PVOID* SystemArgument2
)
{
	__dbgdb();
	KFree(Apc);


	auto CurrentThread = KeGetCurrentThread();
	if (PsGetTrapFrame(CurrentThread) != 0)
	{
		// apc comes from a interrupt
		__dbgdb();
		//return;
	}

	auto BaseTrapFrame = PspGetBaseTrapFrame(CurrentThread);
	if (!BaseTrapFrame)
	{
		__db();
		return;
	}

	CONTEXT ContextRecord;
	ImpCall(RtlCaptureContext, &ContextRecord);

	ULONG64 ControlPc;
	ULONG64 ImageBase;
	PRUNTIME_FUNCTION FunctionEntry;
	PVOID HandlerData;
	ULONG64 EstablisherFrame = 0;

	KNONVOLATILE_CONTEXT_POINTERS ContextPointers{};
	ContextPointers.Rbx = &ContextRecord.Rbx;
	ContextPointers.Rsp = &ContextRecord.Rsp;
	ContextPointers.Rbp = &ContextRecord.Rbp;
	ContextPointers.Rsi = &ContextRecord.Rsi;
	ContextPointers.Rdi = &ContextRecord.Rdi;
	ContextPointers.R12 = &ContextRecord.R12;
	ContextPointers.R13 = &ContextRecord.R13;
	ContextPointers.R14 = &ContextRecord.R14;
	ContextPointers.R15 = &ContextRecord.R15;

	ContextPointers.Xmm6 = &ContextRecord.Xmm6;
	ContextPointers.Xmm7 = &ContextRecord.Xmm7;
	ContextPointers.Xmm8 = &ContextRecord.Xmm8;
	ContextPointers.Xmm9 = &ContextRecord.Xmm9;
	ContextPointers.Xmm10 = &ContextRecord.Xmm10;
	ContextPointers.Xmm11 = &ContextRecord.Xmm11;
	ContextPointers.Xmm12 = &ContextRecord.Xmm12;
	ContextPointers.Xmm13 = &ContextRecord.Xmm13;
	ContextPointers.Xmm14 = &ContextRecord.Xmm14;
	ContextPointers.Xmm15 = &ContextRecord.Xmm15;

	do {
		ControlPc = ContextRecord.Rip;
		FunctionEntry = ImpCall(RtlLookupFunctionEntry, ControlPc, &ImageBase, NULL);

		if (FunctionEntry != NULL) {
			ImpCall(RtlVirtualUnwind, UNW_FLAG_EHANDLER,
				ImageBase,
				ControlPc,
				FunctionEntry,
				&ContextRecord,
				&HandlerData,
				&EstablisherFrame,
				&ContextPointers);
		}
		else {
			ContextRecord.Rip = *(PULONG64)(ContextRecord.Rsp);
			ContextRecord.Rsp += 8;
		}

	} while (EstablisherFrame != (u64)BaseTrapFrame);

	CONTEXT OrigContext;
	OrigContext.ContextFlags = CONTEXT_FULL;
	PspGetContext(BaseTrapFrame, &ContextPointers, &OrigContext);


	SetCtxCall* thisptr = *(SetCtxCall**)SystemArgument1;

	if (!thisptr->bInitCommu)
	{
		auto ntdll = GetModuleHandle(E("ntdll.dll"));
		auto win32u = GetModuleHandle(E("win32u.dll"));

		// u poi CallRet
		// 00007ffe`88b4a369 xor  edx, edx
		// 00007ffe`88b4a36b lea  rcx, [rsp + 20h]
		// 00007ffe`88b4a370 call ntdll!NtContinue

		thisptr->CallRet = FindPatternSect(ntdll, E(".text"), E("E8 ? ? ? ? 33 D2 48 8D 4C 24 20 E8"));
		if (!thisptr->CallRet)
			__db();

		if (RVA(thisptr->CallRet + 12, 5) != (u64)GetProcAddress(ntdll, E("NtContinue")))
			__db();

		thisptr->CallRet += 5;
		
		thisptr->CommuFunction = something;//your win32k io function or data ptr function;
		thisptr->bInitCommu = true;
	}



	CONTEXT PreCallCtx = OrigContext;
	PreCallCtx.ContextFlags = CONTEXT_CONTROL;
	PreCallCtx.Rsp -= 0x28 + 0x30 + sizeof(CONTEXT) * 2;//alloc stack at the precall to prevent other apc destroy
														//the stack
	PreCallCtx.Rip = (u64)thisptr->CallRet;

	//used in ntcontinue.
	CONTEXT CallDriverCtx = OrigContext;
	CallDriverCtx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
	CallDriverCtx.Rsp -= 0x30 + sizeof(CONTEXT);
	CallDriverCtx.Rip = (u64)thisptr->CommuFunction;
	CallDriverCtx.Rcx = 0;
	CallDriverCtx.Rdx = 0;
	CallDriverCtx.R8 = 0;
	CallDriverCtx.R9 = 0;
	*(u64*)(CallDriverCtx.Rsp + 8) = PIPI_CALL_IDENTIFIYER;
	*(u64*)(CallDriverCtx.Rsp + 0x10) = (u64)thisptr; // using a handle can be more secure. 

	memcpy((pv)(CallDriverCtx.Rsp + 0x28), &OrigContext, sizeof(CONTEXT));
	*(pv*)(CallDriverCtx.Rsp) = thisptr->CallRet;

	memcpy((pv)(PreCallCtx.Rsp + 0x20), &CallDriverCtx, sizeof(CONTEXT));

	PspSetContext(BaseTrapFrame, &ContextPointers, &PreCallCtx, UserMode);

}



NTSTATUS SetCtxCall::QueueUserApc(
	PSET_CONTEXT_CALL_INFORMATION CallInfo
)
{
	PKAPC KernelApc = (PKAPC)KAlloc(sizeof(KAPC));

	ImpCall(KeInitializeApc,
		KernelApc, CallInfo->TargetThread,
		OriginalApcEnvironment, SetCtxApcCallback,
		NULL, NULL, KernelMode, NULL
	);
	
	this->CallInfo = CallInfo;

	// Insert APC
	if (!ImpCall(KeInsertQueueApc, KernelApc, this, 0, 2))
		return STATUS_NOT_CAPABLE;

	return STATUS_SUCCESS;

}

NTSTATUS SetCtxCall::Call(PSET_CONTEXT_CALL_INFORMATION CallInfo)
{
	//HANDLE pid = 0;
	//GetProcessIdByProcessName(E(L"notepad.exe"), &pid);
	//if (!pid)
	//	return 0;
	//auto Epro = GetEpro(pid);
	//auto Thread = LookupProcessThread(Epro);
	//if (!Epro || !Thread)
	//	return 0;
	//
	//auto user32 = GetModuleHandle(E("user32.dll"));
	//auto MsgBoxW = GetProcAddress(user32, E("MessageBoxW"));
	//
	//PSET_CONTEXT_CALL_INFORMATION CallInfo = (PSET_CONTEXT_CALL_INFORMATION)KAlloc(0x1000);
	//CallInfo->TargetThread = Thread;
	//CallInfo->UserFunction = MsgBoxW;
	//CallInfo->ParamCnt = 4;
	//CallInfo->Param[0].AsU64 = 0;// MB_OK
	//CallInfo->Param[1].AsU64 = 0;
	//CallInfo->Param[2].AsU64 = 0;
	//CallInfo->Param[3].AsU64 = 0x40;// MB_ICONINFORMATION;
	//
	//CallInfo->PreCallKernelRoutine = [](PSET_CONTEXT_CALL_INFORMATION CallInf) {
	//	PWCH UserStrMsg = (PWCH)UAlloc(0x1000);
	//	PWCH UserStrTitle = (PWCH)UAlloc(0x1000);
	//	wcscpy(UserStrMsg, E(L"远程call信息"));
	//	wcscpy(UserStrTitle, E(L"来自远程call"));
	//
	//	CallInf->Param[1].AsU64 = (u64)UserStrMsg;
	//	CallInf->Param[2].AsU64 = (u64)UserStrTitle;		
	//};
	//
	//CallInfo->PostCallKernelRoutine = [](PSET_CONTEXT_CALL_INFORMATION CallInf) {
	//	UFree((pv)CallInf->Param[1].AsU64);
	//	UFree((pv)CallInf->Param[2].AsU64);
	//};

	ImpCall(KeInitializeEvent, &CallInfo->Event, NotificationEvent, FALSE);

	QueueUserApc(CallInfo);

	ImpCall(KeWaitForSingleObject, &CallInfo->Event, Executive, KernelMode, FALSE, NULL);

	

	//KFree(CallInfo);
	//ObDeref(Thread);
	//ObDeref(Epro);

	return STATUS_SUCCESS;
}








class SetCtxCall CtxCall;


```

`SetContextUserCall.h`:

```h
#pragma once

typedef struct _SET_CONTEXT_CALL_INFORMATION SET_CONTEXT_CALL_INFORMATION, * PSET_CONTEXT_CALL_INFORMATION;

// executed on the context of target process, irql = 0. 
using PreUserCall =  void(*)(PSET_CONTEXT_CALL_INFORMATION);
using PostUserCall = void(*)(PSET_CONTEXT_CALL_INFORMATION);

struct _SET_CONTEXT_CALL_INFORMATION
{
	PETHREAD TargetThread;
	PVOID UserFunction;
	u64 ReturnVal;
	KEVENT Event;
	PreUserCall PreCallKernelRoutine;
	PostUserCall PostCallKernelRoutine;

	SIZE_T ParamCnt;
	struct
	{
		u64 AsU64;
	}Param[1];

};


class SetCtxCall
{
private:

	u64 CommuFunction = 0;
	PUCHAR CallRet = 0;
	
	UsermodeCallback CtxUserCall;
	bool bUserCallInit = false;

	bool bInitCommu = false;
	PSET_CONTEXT_CALL_INFORMATION CallInfo = 0;


	static ULONG64 SANITIZE_VA(IN ULONG64 VirtualAddress, IN USHORT Segment, IN KPROCESSOR_MODE PreviousMode);

	static VOID PspGetContext(IN PKTRAP_FRAME TrapFrame, IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers, IN OUT PCONTEXT ContextRecord);

	static VOID PspSetContext(OUT PKTRAP_FRAME TrapFrame, OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers, IN PCONTEXT ContextRecord, KPROCESSOR_MODE PreviousMode);

	static PKTRAP_FRAME PspGetBaseTrapFrame(PETHREAD Thread);

	static void HkCommunicate();

	static VOID SetCtxApcCallback(PRKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2);

	NTSTATUS QueueUserApc(PSET_CONTEXT_CALL_INFORMATION CallInfo);
public:


	NTSTATUS Call(PSET_CONTEXT_CALL_INFORMATION CallInfo);

};

extern class SetCtxCall CtxCall;

```

`UsermodeCallback.cpp`:

```cpp
#include "global.h"
#include "UsermodeCallback.h"






void UsermodeCallback::Init() {
	//KiCallUserMode = (KiCallUserModefn)0xfffff801735c4ac0;
	//MmCreateKernelStack = (MmCreateKernelStackfn)0xfffff8017346c210;
	//MmDeleteKernelStack = (MmDeleteKernelStackfn)0xfffff8017346d1e0;


	ContextUser = (CONTEXT*)UAlloc(sizeof(CONTEXT), PAGE_READWRITE, true);


	//__db();
	//MmCreateKernelStack = (pv)(RVA(FindPatternSect(KBase, (".text"), ("E8 ? ? ? ? 41 83 CF 04")), 5));
	//ImpCall(DbgPrintEx, 0, 0, "MmCreateKernelStack %llx\n", MmCreateKernelStack);
	//__db();
	//MmDeleteKernelStack = (pv)(RVA(FindPatternSect(KBase, ("PAGE"), ("8B D5 E8 ? ? ? ? 48 8B 05 ? ? ? ? 48 05 ? ? ? ?")), 7));
	//ImpCall(DbgPrintEx, 0, 0, "MmDeleteKernelStack %llx\n", MmDeleteKernelStack);
	//__db();
	//KiCallUserMode = (pv)(RVA(FindPatternSect(KBase, ("PAGE"), ("4D 8D ? ? 48 8B 94 24 ? ? ? ? 48 8B 8C 24 ? ? ? ? E8 ? ? ? ?")), 25));
	//ImpCall(DbgPrintEx, 0, 0, "KiCallUserMode %llx\n", KiCallUserMode);
}


UsermodeCallback UserCallback;

```

`UsermodeCallback.h`:

```h
#pragma once
#include <tuple>

class UsermodeCallback {
private:
	CONTEXT* ContextUser;
	PVOID NtContinue;

	typedef struct _KSTACK_CONTROL {
		DWORD64 StackBase;
		DWORD64 StackLimit;
		DWORD64 PreviousStackBase;
		DWORD64 PreviousStackLimit;
		DWORD64 Spare0;
		DWORD64 PreviousInitialStack;
		DWORD64 ShadowStackControl[4];
	}KSTACK_CONTROL, * PKSTACK_CONTROL;

	typedef struct _MACHINE_FRAME {
		ULONG64 Rip;
		USHORT SegCs;
		USHORT Fill1[3];
		ULONG EFlags;
		ULONG Fill2;
		ULONG64 Rsp;
		USHORT SegSs;
		USHORT Fill3[3];
	} MACHINE_FRAME, * PMACHINE_FRAME;

	typedef struct _UCALLOUT_FRAME {
		ULONG64 P1Home;
		ULONG64 P2Home;
		ULONG64 P3Home;
		ULONG64 P4Home;
		PVOID Buffer;
		ULONG Length;
		ULONG ApiNumber;
		MACHINE_FRAME MachineFrame;
	} UCALLOUT_FRAME, * PUCALLOUT_FRAME;

#define STACK_ALIGN (16UI64)
#define STACK_ROUND (STACK_ALIGN - 1)
#define UCALLOUT_FRAME_LENGTH sizeof(UCALLOUT_FRAME)

	struct KEUSER_CALLBACK {
		ULONG64 Arg1;
		ULONG64 Arg2;
		ULONG64 Arg3;
		ULONG64 Arg4;
		ULONG64 Arg5;
		PVOID   Func;
	};

	typedef u64(NTAPI* MmCreateKernelStackfn)(u64, u64, u64);
	typedef u64(NTAPI* MmDeleteKernelStackfn)(u64, u64);
	typedef NTSTATUS(NTAPI* KiCallUserModefn)(
		PVOID* Outputbuffer,
		PULONG OutputLength,
		PKSTACK_CONTROL KSC,
		DWORD64 NewStackBase,
		DWORD64 KernelShadowStackBase,
		DWORD64 KernelShadowStackInitial
		);

	KiCallUserModefn KiCallUserMode = (KiCallUserModefn)0xfffff801735c4ac0;
	MmCreateKernelStackfn MmCreateKernelStack = (MmCreateKernelStackfn)0xfffff8017346c210;
	MmDeleteKernelStackfn MmDeleteKernelStack = (MmDeleteKernelStackfn)0xfffff8017346d1e0;

	//PVOID KiCallUserMode;
	//PVOID PspGetContextThreadInternal;


public:
	void Init();
	template<typename Ret = void*, typename A1 = void*, typename A2 = void*, typename A3 = void*, typename A4 = void*, typename A5 = void*, typename A6 = void*>
	u64 Call(PVOID Ptr, A1 a1 = 0, A2 a2 = 0, A3 a3 = 0, A4 a4 = 0, A5 a5 = 0, A6 a6 = 0)
	{
		*(vu64*)Ptr;

		ContextUser->Rcx = (ULONG64)a1;
		ContextUser->Rdx = (ULONG64)a2;
		ContextUser->R8 = (ULONG64)a3;
		ContextUser->R9 = (ULONG64)a4;

		auto TrapFrame = PsGetTrapFrame(KeGetCurrentThread());
		if (!TrapFrame)
		{
			// Stack walk and find trapframe, also set kthread.trapframe since KeUserCall use it. 
			//__dbgdb();
			//TrapFrame = StackWalkFindTrapFrame();
			//if (!TrapFrame)
				__db();
			//PsSetTrapFrame(KeGetCurrentThread(), TrapFrame);
		}

		ContextUser->Rsp = TrapFrame->Rsp - 0xF0;

		ContextUser->Rip = (ULONG64)Ptr;
		ContextUser->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
		*(ULONG64*)(ContextUser->Rsp + 0x30) = (ULONG64)a6;

		KEUSER_CALLBACK UserData;
		UserData.Arg1 = (ULONG64)ContextUser;
		UserData.Arg5 = (ULONG64)a5;
		UserData.Arg2 = 0;
		UserData.Func = NtContinue;

		ImpCall(KeUserModeCallback, 2, &UserData, sizeof(UserData), (pv*)&UserData, (ULONG*)&UserData.Arg2);

		u64 ret = 0;
		if (IsValid(UserData.Arg1))
			ret = *(u64*)UserData.Arg1;

		return ret;
		//USER32!_fnDWORD+0x33:
		//xor     r8d,r8d
		//lea     rcx,[rsp+30h]
		//mov     qword ptr [rsp+30h],rax
		//lea     edx,[r8+18h]
		//call    qword ptr [USER32!_imp_NtCallbackReturn (00007ffe`87598790)]
		//add     rsp,58h
		//ret

	}

	NTSTATUS KeUserModeCall(
		IN ULONG ApiNumber,
		IN PVOID   InputBuffer,
		IN ULONG InputLength,
		OUT PVOID* OutputBuffer,
		IN PULONG OutputLength
	)
	{
		PKTRAP_FRAME TrapFrame;
		ULONG64 OldStack;
		NTSTATUS Status;
		ULONG Length;
		PUCALLOUT_FRAME CalloutFrame;

		auto CurrentThread = __readgsqword(0x188);
		*(UCHAR*)(CurrentThread + 0x2db) = *(UCHAR*)(CurrentThread + 0x2db) + 1; // CallbackNestingLevel++

		DWORD64 StackBase = (DWORD64)MmCreateKernelStack(FALSE, 0, 0);

		PKSTACK_CONTROL KSC = (PKSTACK_CONTROL)(StackBase - sizeof(KSTACK_CONTROL));
		KSC->StackBase = StackBase;
		KSC->StackLimit = StackBase - KERNEL_STACK_SIZE;
		KSC->PreviousStackBase = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x38);//KernelStack
		KSC->PreviousStackLimit = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x30);//StackLimit
		KSC->PreviousInitialStack = *(DWORD64*)((DWORD64)KeGetCurrentThread() + 0x28);//InitialStack
		memset(&KSC->ShadowStackControl, 0, 8*4);

		TrapFrame = PsGetTrapFrame(KeGetCurrentThread());
		OldStack = TrapFrame->Rsp;

		Length = ((InputLength + STACK_ROUND) & ~STACK_ROUND) + UCALLOUT_FRAME_LENGTH;
		CalloutFrame = (PUCALLOUT_FRAME)((OldStack - Length) & ~STACK_ROUND);
		memmove(&CalloutFrame[1], InputBuffer, InputLength);

		CalloutFrame->Buffer = &CalloutFrame[1];
		CalloutFrame->Length = InputLength;
		CalloutFrame->ApiNumber = ApiNumber;
		CalloutFrame->MachineFrame.Rsp = OldStack;
		CalloutFrame->MachineFrame.Rip = TrapFrame->Rip;

		TrapFrame->Rsp = (ULONG64)CalloutFrame;

		Status = KiCallUserMode(
			OutputBuffer,
			OutputLength,
			KSC,
			StackBase,
			0,
			0
		);

		*(UCHAR*)(CurrentThread + 0x2db) = *(UCHAR*)(CurrentThread + 0x2db) - 1; // CallbackNestingLevel--

		MmDeleteKernelStack(StackBase, FALSE);

		TrapFrame->Rsp = OldStack;
		return Status;

	}

	template<typename Ret = void*, typename A1 = void*, typename A2 = void*, typename A3 = void*, typename A4 = void*, typename A5 = void*, typename A6 = void*>
	u64 Call2(PVOID Ptr, A1 a1 = 0, A2 a2 = 0, A3 a3 = 0, A4 a4 = 0, A5 a5 = 0, A6 a6 = 0)
	{
		*(vu64*)Ptr;

		ContextUser->Rcx = (ULONG64)a1;
		ContextUser->Rdx = (ULONG64)a2;
		ContextUser->R8 = (ULONG64)a3;
		ContextUser->R9 = (ULONG64)a4;

		auto TrapFrame = PsGetTrapFrame(KeGetCurrentThread());
		if (!TrapFrame)
		{
			// Stack walk and find trapframe, also set kthread.trapframe since KeUserCall use it. 
			//__dbgdb();
			//TrapFrame = StackWalkFindTrapFrame();
			//if (!TrapFrame)
				__db();
			//PsSetTrapFrame(KeGetCurrentThread(), TrapFrame);
		}

		ContextUser->Rsp = TrapFrame->Rsp - 0xF8;

		ContextUser->Rip = (ULONG64)Ptr;
		ContextUser->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
		*(ULONG64*)(ContextUser->Rsp + 0x30) = (ULONG64)a6;
		
		KEUSER_CALLBACK UserData;
		UserData.Arg1 = (ULONG64)ContextUser;
		UserData.Arg5 = (ULONG64)a5;
		UserData.Arg2 = 0;
		UserData.Func = NtContinue;

		KeUserModeCall( 2, &UserData, sizeof(UserData), (pv*)&UserData, (ULONG*)&UserData.Arg2);

		u64 ret = 0;
		if (IsValid(UserData.Arg1))
			ret = *(u64*)UserData.Arg1;

		return ret;
		//USER32!_fnDWORD+0x33:
		//xor     r8d,r8d
		//lea     rcx,[rsp+30h]
		//mov     qword ptr [rsp+30h],rax
		//lea     edx,[r8+18h]
		//call    qword ptr [USER32!_imp_NtCallbackReturn (00007ffe`87598790)]
		//add     rsp,58h
		//ret

	}

};

extern UsermodeCallback UserCallback;

```

`util.cpp`:

```cpp
#include "global.h"
#include "PhysicalMemory.h"
#include "DispatchFunctions.h"
#include "util.h"

volatile u64 LastAllocation = 0;
volatile u64 LastAllocationAddress = 0;

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize)
{
	if (!moduleStart)
		return STATUS_INVALID_PARAMETER;

	const auto listHeader = NQSI(SystemModuleInformation);
	if (!listHeader)
		return STATUS_MEMORY_NOT_ALLOCATED;

	auto currentModule = reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Module;
	for (size_t i = 0; i < reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Count; ++i, ++currentModule)
	{
		// \SystemRoot\system32\ntoskrnl.exe -> ntoskrnl.exe 
		const auto currentModuleName = reinterpret_cast<const char*>(currentModule->FullPathName + currentModule->OffsetToFileName);
		if (!strcmp(moduleName, currentModuleName))
		{
			*moduleStart = currentModule->ImageBase;
			if (moduleSize)
				*moduleSize = currentModule->ImageSize;
			KFree(listHeader);
			return STATUS_SUCCESS;
		}
	}
	KFree(listHeader);
	return STATUS_NOT_FOUND;
}

NTSTATUS GetProcessIdByProcessName(const wchar_t* ImageName, OUT HANDLE* OutPid )
{
	PSYSTEM_PROCESS_INFO pInfo = 0;
	PSYSTEM_PROCESS_INFO Buffer = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
		
	Buffer = (PSYSTEM_PROCESS_INFO)NQSI(SystemProcessInformation);
	if (!Buffer) 
		return STATUS_UNSUCCESSFUL;

	pInfo = Buffer;

	Status = STATUS_UNSUCCESSFUL;
	for (;;)
	{
		if (pInfo->ImageName.Buffer && StrICmp(ImageName, pInfo->ImageName.Buffer, TRUE))
		{
			//__db();
			*OutPid = pInfo->UniqueProcessId;
			Status = 0;
			break;
		}
		else if (pInfo->NextEntryOffset)
			pInfo = (PSYSTEM_PROCESS_INFO)((PUCHAR)pInfo + pInfo->NextEntryOffset);
		else
			break;
	}

	KFree(Buffer);

	return Status;
}

#define IMAGE_FIRST_SECTION(NtHeader) (PIMAGE_SECTION_HEADER)(NtHeader + 1)
#define NT_HEADER(ModBase) (PIMAGE_NT_HEADERS)((ULONG64)(ModBase) + ((PIMAGE_DOS_HEADER)(ModBase))->e_lfanew)

PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize)
{
	//get & enum sections
	PIMAGE_NT_HEADERS NT_Header = NT_HEADER(ModBase);
	PIMAGE_SECTION_HEADER Sect = IMAGE_FIRST_SECTION(NT_Header);

	for (PIMAGE_SECTION_HEADER pSect = Sect; pSect < Sect + NT_Header->FileHeader.NumberOfSections; pSect++)
	{
		//copy section name
		char SectName[9]; SectName[8] = 0;
		*(ULONG64*)&SectName[0] = *(ULONG64*)&pSect->Name[0];

		//check name
		if (StrICmp(Name, SectName, true))
		{
			//save size
			if (SectSize) {
				ULONG SSize = SizeAlign(max(pSect->Misc.VirtualSize, pSect->SizeOfRawData));
				*SectSize = SSize;
			}

			//ret full sect ptr
			return (PVOID)((ULONG64)ModBase + pSect->VirtualAddress);
		}
	}

	//no section
	return nullptr;
}

bool readByte(PVOID addr, UCHAR* ret)
{
	*ret = *(volatile char*)addr;
	return true;
}

//find pattern utils
#define InRange(x, a, b) (x >= a && x <= b) 
#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : (InRange(x, 'a', 'z') ? ((x - 'a') + 0xA) : ((x - 'A') + 0xA)) )
#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern)
{
	if (!ModBase) return nullptr;

//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)FindSection(ModBase, SectName, &SectSize);
	PUCHAR ModuleEnd = ModuleStart + SectSize;

	if (!ModuleStart) return nullptr;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			if (SkipByte)
				CurPatt += 2;
			else
				CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern)
{
	//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)Start;
	PUCHAR ModuleEnd = ModuleStart + size;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			SkipByte ? CurPatt += 2 : CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PETHREAD LookupProcessThread(IN PEPROCESS pProcess)
{
	if (!pProcess)
		return 0;

	NTSTATUS status = STATUS_SUCCESS;
	PETHREAD thr = 0;
	HANDLE pid = ImpCall(PsGetProcessId, pProcess);
	auto Buf = NQSI(SystemProcessInformation);
	PSYSTEM_PROCESS_INFO pInfo = (PSYSTEM_PROCESS_INFO)Buf;

	// Find target thread	
	status = STATUS_NOT_FOUND;
	for (;;)
	{
		if (pInfo->UniqueProcessId == pid)
		{
			status = STATUS_SUCCESS;
			break;
		}
		else if (pInfo->NextEntryOffset)
			pInfo = (PSYSTEM_PROCESS_INFO)((PUCHAR)pInfo + pInfo->NextEntryOffset);
		else
			break;
	}

	status = STATUS_NOT_FOUND;

	// Get first thread
	for (ULONG i = 0; i < pInfo->NumberOfThreads; i++)
	{
		// Skip current thread
		if (/*pInfo->Threads[i].WaitReason == Suspended ||
			pInfo->Threads[i].ThreadState == 5 ||*/
			pInfo->Threads[i].ClientId.UniqueThread == ImpCall(PsGetCurrentThreadId))
		{
			continue;
		}

		status = ImpCall(PsLookupThreadByThreadId, pInfo->Threads[i].ClientId.UniqueThread, &thr);

		break;
	}

	KFree(Buf);

	return thr;

}


//NTSTATUS CopyPhysics(void* Dst, const void* PhySics, size_t _MaxCount)
//{
//	MM_COPY_ADDRESS copyaddr;
//	copyaddr.PhysicalAddress.QuadPart = (LONGLONG)PhySics;
//	SIZE_T copyed = 0;
//	return MmCopyMemory(Dst, copyaddr, _MaxCount, MM_COPY_MEMORY_PHYSICAL, &copyed);
//}


//void Log2File(const char* format, ...)
//{	
//	char msg[1024] = "";
//	va_list vl;
//	va_start(vl, format);
//	const int n = _vsnprintf(msg, sizeof(msg) / sizeof(char), format, vl);
//	msg[n] = '\0';
//	va_end(vl);
//	va_end(format);
//	UNICODE_STRING FileName;
//	OBJECT_ATTRIBUTES objAttr;
//	RtlInitUnicodeString(&FileName, L"\\DosDevices\\C:\\PPEngine.log");
//	InitializeObjectAttributes(&objAttr, &FileName,
//		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
//		NULL, NULL);
//	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
//	{
//		return;
//	}
//	HANDLE handle;
//	IO_STATUS_BLOCK ioStatusBlock;
//	NTSTATUS ntstatus = ZwCreateFile(&handle,
//		FILE_APPEND_DATA,
//		&objAttr, &ioStatusBlock, NULL,
//		FILE_ATTRIBUTE_NORMAL,
//		FILE_SHARE_WRITE | FILE_SHARE_READ,
//		FILE_OPEN_IF,
//		FILE_SYNCHRONOUS_IO_NONALERT,
//		NULL, 0);
//	if (NT_SUCCESS(ntstatus))
//	{
//		size_t cb;
//		ntstatus = RtlStringCbLengthA(msg, sizeof(msg), &cb);
//		if (NT_SUCCESS(ntstatus))
//			ZwWriteFile(handle, NULL, NULL, NULL, &ioStatusBlock, msg, (ULONG)cb, NULL, NULL);
//		ZwClose(handle);
//	}
//}

ULONG g_dwBuildNumber = 0;
ULONG GetWinVer() 
{
	if (!g_dwBuildNumber)
	{
		ImpCall(PsGetVersion, 0, 0, &g_dwBuildNumber, 0);
	}	
	return g_dwBuildNumber;
}

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

BOOLEAN IsKernelDebuggerPresent()
{
	SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo;
	ULONG RetLen = 0;
	ImpCall(ZwQuerySystemInformation, SystemKernelDebuggerInformation, &DebuggerInfo, 8, &RetLen);

	return !DebuggerInfo.DebuggerNotPresent;
}

PVOID GetCurrentProcessModule(const char* ModName, ULONG* ModSize, bool force64)
{
	auto Process = ImpCall(IoGetCurrentProcess);

	PPEB32 pPeb32 = (PPEB32)ImpCall(PsGetProcessWow64Process,Process);

	if (pPeb32 && !force64)
	{
		if (!pPeb32->Ldr)
			return nullptr;

		for (PLIST_ENTRY32 pListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList.Flink;
			pListEntry != &((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList;
			pListEntry = (PLIST_ENTRY32)pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY32 pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);

			if (StrICmp(ModName, (PWCH)pEntry->BaseDllName.Buffer, false))
			{
				if (ModSize)
				{
					*ModSize = pEntry->SizeOfImage;
				}

				return (PVOID)pEntry->DllBase;
			}
		}
	}
	else
	{
		PPEB64 PEB = ImpCall(PsGetProcessPeb, Process);
		if (!PEB || !PEB->Ldr)
			return nullptr;

		for (PLIST_ENTRY pListEntry = (PLIST_ENTRY)((PPEB_LDR_DATA64)(PEB->Ldr))->InLoadOrderModuleList.Flink;
			pListEntry != (PLIST_ENTRY)&((PPEB_LDR_DATA64)(PEB->Ldr))->InLoadOrderModuleList;
			pListEntry = pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY64 pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);

			if (StrICmp(ModName, pEntry->BaseDllName.Buffer, false))
			{
				if (ModSize)
				{
					*ModSize = pEntry->SizeOfImage;
				}

				return (PVOID)pEntry->DllBase;
			}
		}
	}

	return nullptr;
}

PVOID NQSI(SYSTEM_INFORMATION_CLASS Class)
{
	ULONG ret_size = 0;
	ImpCall(ZwQuerySystemInformation, Class, 0, 0, &ret_size);

	NTSTATUS status = 0;
	PVOID pInfo = 0;
	do
	{
		if (pInfo) KFree(pInfo);

		pInfo = KAlloc(ret_size);
		status = ImpCall(ZwQuerySystemInformation, Class, pInfo, ret_size, &ret_size);
	} while (status == STATUS_BUFFER_TOO_SMALL);

	return pInfo;
}




PVOID GetUserProcessModule(DWORD pid, const wchar_t* ModName)
{
	OperationData op;
	op.Module.ModName = ModName;// L"user32.dll";
	op.Process.Id = pid;
	auto status = Dispatch::GetModuleBase(&op);
	if (status)
		return 0;

	return op.Module.BaseAddress;
}

PEPROCESS GetUserProcessModule(const wchar_t* ProcessName, const wchar_t* ModName, __notnull pv* OutModBase)
{
	HANDLE Pid = 0;
	GetProcessIdByProcessName(ProcessName, &Pid);
	if (!Pid)
		return 0;

	OperationData op;
	op.Module.ModName = ModName;// L"user32.dll";
	op.Process.Id = (DWORD)Pid;
	auto status = Dispatch::GetModuleBase(&op);
	if (status)
		return 0;

	*OutModBase = op.Module.BaseAddress;

	PEPROCESS TargetProcess = 0;
	if (ImpCall(PsLookupProcessByProcessId, Pid, &TargetProcess))
		return 0;

	ImpCall(ObfDereferenceObject, TargetProcess);

	return TargetProcess;
}

NTSTATUS NTQM(PVOID UAddr, PMEMORY_BASIC_INFORMATION mbi)
{
	if (!mbi)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = 0;

	//if (ImpCall(ExGetPreviousMode) == UserMode)
	//{
	//	PMEMORY_BASIC_INFORMATION UserMbi = (PMEMORY_BASIC_INFORMATION)UAlloc(0x1000);
	//	status = ImpCall(ZwQueryVirtualMemory, (HANDLE)-1, (pv)((u64)UAddr & ~0xFFF), MemoryBasicInformation,
	//		UserMbi, sizeof(MEMORY_BASIC_INFORMATION), 0);
	//
	//	*mbi = *UserMbi;
	//
	//	UFree(UserMbi);
	//}
	//else
	{
		status = ImpCall(ZwQueryVirtualMemory, (HANDLE)-1, (pv)((u64)UAddr & ~0xFFF), MemoryBasicInformation,
			mbi, sizeof(MEMORY_BASIC_INFORMATION), 0);
	}

	if (status != 0)
		memset(mbi, 0, sizeof(*mbi));

	return status;
}

NTSTATUS ReadFile(IN const wchar_t* FileName, OUT char** DataFreeByCaller, OUT SIZE_T* DataSize)
{
	HANDLE hFile = NULL;
	IO_STATUS_BLOCK sb = { 0 };
	NTSTATUS status = 0;
	LARGE_INTEGER Offset = { 0 };
	OBJECT_ATTRIBUTES object_attr = { 0 };
	//ANSI_STRING anFilePath = { 0 };
	UNICODE_STRING unFilePathName = { 0 };
	FILE_STANDARD_INFORMATION fsi = { 0 };
	LARGE_INTEGER Size = { 0 };

	ImpCall(RtlInitUnicodeString, &unFilePathName, FileName);
	//status = RtlAnsiStringToUnicodeString(&unFilePathName, &anFilePath, TRUE);
	//if (!NT_SUCCESS(status))
	//{
	//	return status;
	//}

	InitializeObjectAttributes(&object_attr, &unFilePathName, OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = ImpCall(ZwCreateFile, &hFile, GENERIC_READ, &object_attr, &sb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ,
		FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		return status;
	}

	// 获取文件大小
	memset(&sb, 0, sizeof(sb));
	status = ImpCall(ZwQueryInformationFile, hFile, &sb, &fsi, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation);
	if (!NT_SUCCESS(status))
	{
		ImpCall(ZwClose, hFile);
		return status;
	}
	Size.QuadPart = fsi.EndOfFile.QuadPart;

	// 申请内存
	*DataFreeByCaller = (CHAR*)KAlloc(Size.QuadPart);
	if (*DataFreeByCaller == NULL)
	{
		ImpCall(ZwClose, hFile);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// 读文件
	status = ImpCall(ZwReadFile, hFile, NULL, NULL, NULL, &sb, (PVOID)*DataFreeByCaller, (ULONG)Size.QuadPart, &Offset, NULL);
	if (!NT_SUCCESS(status))
	{
		KFree(*DataFreeByCaller);
		*DataFreeByCaller = 0;
		return status;
	}

	if (DataSize)
		*DataSize = Size.QuadPart;
	return ImpCall(ZwClose, hFile);
}

bool DeleteFile(PUNICODE_STRING Path)
{

	HANDLE hFile = NULL;
	OBJECT_ATTRIBUTES obj = { 0 };
	IO_STATUS_BLOCK IoStatck = { 0 };
	InitializeObjectAttributes(&obj, Path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

	NTSTATUS NtStatus = ImpCall(ZwCreateFile, &hFile, FILE_READ_ACCESS, &obj, &IoStatck, NULL,
		FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, NULL);
	if (!NT_SUCCESS(NtStatus))
		return FALSE;

	PFILE_OBJECT FileObject = NULL;
	NtStatus = ImpCall(ObReferenceObjectByHandle, hFile, FILE_ALL_ACCESS, *ImpGetVar(IoFileObjectType), KernelMode, (PVOID*)&FileObject, NULL);
	if (!NT_SUCCESS(NtStatus))
	{
		ImpCall(ZwClose, hFile);
		return FALSE;
	}
	ImpCall(ZwClose, hFile);

	FileObject->DeletePending = 0;
	FileObject->DeleteAccess = 1;
	FileObject->SharedDelete = 1;
	FileObject->SectionObjectPointer->DataSectionObject = NULL;
	FileObject->SectionObjectPointer->ImageSectionObject = NULL;
	FileObject->SectionObjectPointer->SharedCacheMap = NULL;
	NtStatus = ImpCall(ZwDeleteFile, &obj);
	ObDeref(FileObject);
	if (!NT_SUCCESS(NtStatus))
	{
		return FALSE;
	}
	return TRUE;
}

NTSTATUS WriteFile(PUNICODE_STRING filePath, PVOID data, ULONG length)
{
	NTSTATUS status;
	HANDLE fileHandle;
	OBJECT_ATTRIBUTES objAttr;
	IO_STATUS_BLOCK ioStatusBlock;

	// Initialize the object attributes to open the file
	InitializeObjectAttributes(&objAttr, filePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	// Open the file
	status = ZwCreateFile(&fileHandle, GENERIC_WRITE, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

	if (!NT_SUCCESS(status))
	{
		// File open failed
		return status;
	}

	// Write the data to the file
	status = ZwWriteFile(fileHandle, NULL, NULL, NULL, &ioStatusBlock, data, length, NULL, NULL);

	if (!NT_SUCCESS(status))
	{
		// Write operation failed
		ZwClose(fileHandle);
		return status;
	}

	// Close the file handle
	ZwClose(fileHandle);

	return STATUS_SUCCESS;
}

bool IsValidFileObject(PFILE_OBJECT FileObject)
{
	if (!IsValid(FileObject))
		return false;

	if (FileObject->Type != 5)
		return false;

	return true;
}

//Data free by caller, ret = C:\Users\Pipi\Desktop\1.exe 
POBJECT_NAME_INFORMATION GetFileNameInfo(PFILE_OBJECT FileObject)
{
	if (!IsValidFileObject(FileObject))
		return 0;

	POBJECT_NAME_INFORMATION ObjectNameInformation = 0;

	ImpCall(IoQueryFileDosDeviceName, FileObject, &ObjectNameInformation);

	if (ObjectNameInformation)
		*(PWCH)((u64)ObjectNameInformation->Name.Buffer + ObjectNameInformation->Name.Length) = L'\0';

	return ObjectNameInformation;
}

typedef NTSTATUS (NTAPI* _PsSuspendThread)(IN PETHREAD Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
_PsSuspendThread PsSuspendThread = 0;

typedef u64 (__fastcall* _KeResumeThread)(IN PETHREAD Thread, IN ULONG One);
_KeResumeThread KeResumeThread = 0;

void InitSuspendResumeThread()
{
	auto rva =
		FindPatternSect(EPtr(::NtBase), E("PAGE"), E("F7 ? 74 00 00 20 00 75 ? 33 D2 48 8B ? E8"));
	PsSuspendThread = (_PsSuspendThread)RVA(rva + 14, 5);

	auto rva2 =
		FindPatternSect(EPtr(::NtBase), E("PAGE"), E("F7 ? 74 00 00 20 00 75 ? 48 8B ? E8"));
	if (rva2)
	{
		KeResumeThread = (_KeResumeThread)RVA(rva2 + 12, 5);
	}
	else
	{
		rva2 = FindPatternSect(EPtr(::NtBase), E(".text"), E("F7 ? 74 00 00 20 00 75 ? BA 01 00 00 00 48 8B ? E8"));
		if (!rva2)
			__db();
		KeResumeThread = (_KeResumeThread)RVA(rva2 + 17, 5);
	}
}

NTSTATUS SuspendThread(PETHREAD Thread)
{
	if (!Thread)
		return STATUS_NOT_FOUND;
	
	if (!PsSuspendThread || !KeResumeThread)
	{
		InitSuspendResumeThread();
	}

	if (!PsSuspendThread)
		return STATUS_PROCEDURE_NOT_FOUND;

	return PsSuspendThread(Thread, 0);
}

NTSTATUS ResumeThread(PETHREAD Thread)
{
	if (!Thread)
		return STATUS_NOT_FOUND;

	if (!PsSuspendThread || !KeResumeThread)
	{
		InitSuspendResumeThread();
	}

	if (!KeResumeThread)
		return STATUS_PROCEDURE_NOT_FOUND;

	KeResumeThread(Thread, 1);

	return 0;
}




```

`util.h`:

```h
#pragma once

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize = 0);

NTSTATUS GetProcessIdByProcessName(const wchar_t* ImageName, OUT HANDLE* OutPid);

PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize);

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern);

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern);

PETHREAD LookupProcessThread(IN PEPROCESS pProcess);

//NTSTATUS RtlSuperCopyMemory(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

//NTSTATUS RtlSuperWriteMemoryPipi(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

void Log2File(const char* format, ...);

//dwBuildNumber
ULONG GetWinVer();

BOOLEAN IsKernelDebuggerPresent();

PVOID GetProcAddress(PVOID ModBase, const char* Name);

PVOID GetCurrentProcessModule(const char* ModName, ULONG* ModSize = 0, bool force64 = 1);

PVOID NQSI(SYSTEM_INFORMATION_CLASS Class);

PVOID GetUserProcessModule(DWORD pid, const wchar_t* ModName);

PEPROCESS GetUserProcessModule(const wchar_t* ProcessName, const wchar_t* ModName, __notnull pv* OutModBase);

PEPROCESS GetEpro(HANDLE pid);

inl BOOLEAN IsProcessExit(PEPROCESS epro);

NTSTATUS ReadFile(IN const wchar_t* FileName, OUT char** DataFreeByCaller, OUT SIZE_T* DataSize);

bool DeleteFile(PUNICODE_STRING Path);

NTSTATUS WriteFile(PUNICODE_STRING filePath, PVOID data, ULONG length);

bool IsValidFileObject(PFILE_OBJECT FileObject);

POBJECT_NAME_INFORMATION GetFileNameInfo(PFILE_OBJECT FileObject);

#define LOCK(Lock) while (_InterlockedCompareExchange64(&Lock, 1, 0) == 1){;}

#define UNLOCK(Lock) (InterlockedExchange64(&Lock, 0))

#define SizeAlign(Size) ((Size + 0xFFF) & 0xFFFFFFFFFFFFF000)

inl void MemZero(PVOID Ptr, SIZE_T Size, UCHAR Filling = 0)
{
	__stosb((PUCHAR)Ptr, Filling, Size);
}

inl void MemCpy(PVOID Destination, PVOID Source, SIZE_T Count)
{
	__movsb((PUCHAR)Destination, (PUCHAR)Source, Count);
}

inl PVOID UAlloc(ULONG Size, ULONG Protect = PAGE_READWRITE, bool load = true)
{
	PVOID AllocBase = nullptr; SIZE_T SizeUL = SizeAlign(Size);	
#define LOCK_VM_IN_RAM 2
#define LOCK_VM_IN_WORKING_SET 1
	if (!ImpCall(ZwAllocateVirtualMemory, ZwCurrentProcess(), &AllocBase, 0, &SizeUL, MEM_COMMIT, Protect)) {
		//ZwLockVirtualMemory(ZwCurrentProcess(), &AllocBase, &SizeUL, LOCK_VM_IN_WORKING_SET | LOCK_VM_IN_RAM);
		if (load)
			MemZero(AllocBase, SizeUL);
	}
	return AllocBase;
}

inl DWORD UProtect(PVOID Address, ULONG Size, ULONG Protect)
{
	SIZE_T SizeUL = Size;
	u32 OldPro = 0;
	ImpCall(ZwProtectVirtualMemory, ZwCurrentProcess(), &Address, &SizeUL, Protect, &OldPro);
	return OldPro;
}

inl void UFree(PVOID Ptr)
{
	SIZE_T SizeUL = 0;
	ImpCall(ZwFreeVirtualMemory, ZwCurrentProcess(), &Ptr, &SizeUL, MEM_RELEASE);
}

//help to debug
extern volatile u64 LastAllocation;
extern volatile u64 LastAllocationAddress;


//kernel memory utils
inl PVOID KAlloc(u64 Size, bool exec = false, bool PagedPool = false)
{
	PVOID Buff = ImpCall(ExAllocatePoolWithTag,
		PagedPool ? POOL_TYPE::PagedPool : (exec ? NonPagedPool : NonPagedPoolNx),
		Size, GetRandomPoolTag());
	memset(Buff, 0, Size);

	LastAllocation = (u64)Buff;
	LastAllocationAddress = (u64)_ReturnAddress();
	return Buff;
}

inl void KFree(PVOID Ptr)
{
	if(Ptr)
		ImpCall(ExFreePoolWithTag, Ptr, 0);
}

inl PVOID GetModuleHandle(const char* ModName)
{
	return GetCurrentProcessModule(ModName);
}

inl KAPC_STATE KeStackAttach(PEPROCESS process)
{
	KAPC_STATE kapc;
	ImpCall(KeStackAttachProcess, process, &kapc);
	return kapc;
}

inl void KeStackDetach(KAPC_STATE* kapc)
{
	ImpCall(KeUnstackDetachProcess, kapc);
}

inl KPROCESSOR_MODE ExSetPreviousMode(KPROCESSOR_MODE NewMode, PETHREAD Thread = (PETHREAD)__readgsqword(0x188))
{
	auto ret = *(u8*)((u64)Thread + 0x232);
	*(u8*)((u64)Thread + 0x232) = NewMode;
	return ret;
}

inl KTRAP_FRAME* PsGetTrapFrame(PETHREAD Thread = (PETHREAD)__readgsqword(0x188))
{
	return *(KTRAP_FRAME**)((ULONG64)Thread + 0x90);
}

inl void PsSetTrapFrame(PETHREAD Thread, KTRAP_FRAME* tf)
{
	*(KTRAP_FRAME**)((ULONG64)Thread + 0x90) = tf;
}

inl PEPROCESS GetEpro(HANDLE pid)
{
	PEPROCESS epro = 0;
	ImpCall(PsLookupProcessByProcessId, pid, &epro);
	return epro;
}

inl BOOLEAN IsProcessExit(PEPROCESS epro)
{
	if (!epro)
	{
		__dbgdb();
		return TRUE;
	}

	return ImpCall(PsGetProcessExitStatus, epro) != STATUS_PENDING;
}

#define ObDeref ObfDeref

inl void ObfDeref(PVOID Obj)
{
	if(Obj)
		ImpCall(ObfDereferenceObject, Obj);
}

inl void KSleep(LONG milliseconds)
{
	LARGE_INTEGER interval;
	interval.QuadPart = -(10000 * milliseconds); // convert milliseconds to 100 nanosecond intervals
	ImpCall(KeDelayExecutionThread, KernelMode, FALSE, &interval);
}



template <class T>
inl bool IsCanonicalAddress(T address)
{
	u64 addr = *(u64*)&address;

	if (addr <= 0x1000)
		return false;

	if (
		((addr >= 0xFFFF800000000000) && (addr <= 0xFFFFFFFFFFFFFFFF)) ||
		((addr >= 0) && (addr <= 0x7FFFFFFFFFFF)) 		
		)
	{
		return true;
	}

	return false;
}

inl BOOLEAN IsValid(pv addr)
{
	if ((u64)addr <= 0x1000)
		return false;

	if (!IsCanonicalAddress(addr))
		return false;

	return ImpCall(MmIsAddressValid, addr);
}

inl BOOLEAN IsValid(u64 addr)
{
	if (addr < 0x1000)
		return false;
	return ImpCall(MmIsAddressValid, (pv)addr);
}

NTSTATUS NTQM(PVOID UAddr, PMEMORY_BASIC_INFORMATION mbi);

inl DECLSPEC_NORETURN VOID BugCheck(u32 Line)
{
	ImpCall(KeBugCheck, Line);
}

#define GetTickCount64 KeQueryInterruptTime

extern ULONG g_dwBuildNumber;


```