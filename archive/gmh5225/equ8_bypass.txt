Project Path: arc_gmh5225_equ8_bypass_zc0jofq4

Source Tree:

```txt
arc_gmh5225_equ8_bypass_zc0jofq4
├── LICENSE
├── README.md
├── globals.hpp
├── main.cpp
├── processuser.hpp
└── trustedinstaller.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 hotline1337

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# EQU8 User-Mode Bypass and Injector

Simple EQU8 User-Mode Bypass that uses registry to find the driver path and close the IOCTL handle

## Proof of concept
By finding EQU8's driver **SessionId** using registry keys we get the **IOCTL handle** and close it - as it's the only handle the driver will simply **unload itself**

## Compiling
Build as **Release x64 | MSVC v143**

## Contributing
Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

Please make sure to update tests as appropriate.

## License
[MIT](https://choosealicense.com/licenses/mit/)

```

`globals.hpp`:

```hpp
/**
 *
 * Title: EQU8 User-Mode Bypass and Injector
 * Author: hotline
 *
*/
#pragma once
#include <Windows.h>
#include <functional>
#include <fstream>
#include <memory>

#include "processuser.hpp"
#include "trustedinstaller.hpp"

using namespace std;
namespace globals
{
	namespace string
	{
		inline auto erase_all_sub_str(std::string& mainStr, const std::string& toErase) -> void
		{
			auto pos = std::string::npos;
			while ((pos = mainStr.find(toErase)) != std::string::npos)
			{
				mainStr.erase(pos, toErase.length());
			}
		}
	}
	namespace validation
	{
		static CHAR path[MAX_PATH];
		inline function<void(void)> set_user = []()
		{
			ofstream file;

			const auto current_user = getenv("USERPROFILE");
			file.open("C:\\ProgramData\\user.equ8", ios::out | ios::trunc);
			file << current_user << "\\Desktop";
			file.close();
		};
		inline function<void(void)> validate_system = []()
		{
			bool is_system;
			std::string user;
			GetUserFromProcess(GetCurrentProcessId(), user);

			std::string user_name = getenv("USERPROFILE");
			string::erase_all_sub_str(user_name, "C:\\Users\\");

			if (user == user_name)
			{
				is_system = false;
			}
			else
			{
				is_system = true;
			}

			GetModuleFileNameA(nullptr, path, MAX_PATH);
			if (!is_system)
			{
				set_user();
				create_process(path);
				TerminateProcess(GetCurrentProcess(), 0);
			}
		};
		inline auto get_user() -> ::string
		{
			ifstream input_file("C:\\ProgramData\\user.equ8");
			if (!input_file.is_open())
				return "C:\\";

			return ::string((istreambuf_iterator<char>(input_file)), istreambuf_iterator<char>());
		};
	}
	namespace process
	{
		inline auto get_process_pid_by_name(const char* ProcessName) -> DWORD
		{
			PROCESSENTRY32 entry;

			entry.dwSize = sizeof(PROCESSENTRY32);
			DWORD targetProcessId = 0;
			const HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
			if (Process32First(snapshot, &entry) == TRUE)
			{
				while (Process32Next(snapshot, &entry) == TRUE)
				{
					if (_stricmp(entry.szExeFile, ProcessName) == 0)
					{
						targetProcessId = entry.th32ProcessID;
						break;
					}
				}
			}
			CloseHandle(snapshot);
			return targetProcessId;
		}

		inline auto inject_dll(HANDLE handle, std::string_view dll_path) -> void
		{
			auto* dll_path_addr = VirtualAllocEx(handle, nullptr, dll_path.size(), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			if (!dll_path_addr)
				return;

			if (!WriteProcessMemory(handle, dll_path_addr, dll_path.data(), dll_path.size(), nullptr))
				return;

			const auto remote_thread = CreateRemoteThread(handle, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(LoadLibraryA),
				dll_path_addr, 0, nullptr);
			if (!remote_thread)
				return;

			WaitForSingleObject(remote_thread, INFINITE);
		}
	}
	namespace file
	{
		inline auto open_file_name(const char* filter = "All Files (*.dll)\0*.dll\0", HWND owner = nullptr) -> ::string
		{
			OPENFILENAME ofn;
			char fileName[MAX_PATH] = "";
			memset(&ofn, 0, sizeof(ofn));

			ofn.lStructSize = sizeof(OPENFILENAME);
			ofn.hwndOwner = owner;
			ofn.lpstrFilter = filter;
			ofn.lpstrFile = fileName;
			ofn.nMaxFile = MAX_PATH;
			ofn.lpstrInitialDir = validation::get_user().c_str();
			ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
			ofn.lpstrDefExt = "";

			::string fileNameStr;
			if (GetOpenFileNameA(&ofn))
				fileNameStr = fileName;

			return fileNameStr;
		}
	}
}

```

`main.cpp`:

```cpp
/**
 *
 * Title: EQU8 User-Mode Bypass and Injector
 * Author: hotline
 *
*/
#include <Windows.h>
#include <cstdio>
#include <string>
#include <TlHelp32.h>
#include <iostream>
#include <functional>

#include "globals.hpp"
#include "xor.hpp"
#include "import.hpp"

using namespace std;

auto main(void) -> int
{
	try
	{
		globals::validation::validate_system();
	}
	catch (std::exception& ex)
	{
		std::string error = "Something went wrong : ";
		error.append(ex.what());
		MessageBoxA(nullptr, error.c_str(), "equ8 bypass", MB_ICONERROR | MB_OK);
		return 0;
	}

	LI_FN(SetConsoleTitleA)(xorstr_("equ8 bypass by u55dx"));
	std::cout << xorstr_("~ equ8 bypass by u55dx for unknowncheats\n~ github.com/hotline1337") << std::endl << std::endl;
	std::cout << "~ successfully launched as system" << std::endl;

	/* variables */
	int lastError;
	int lastErrorHistory = 0;
	HANDLE ioctlHandle;
	HKEY equ8DriverKey;
	CHAR deviceSessionId[MAX_PATH];
	DWORD deviceSessionIdLength = sizeof(deviceSessionId);

	LSTATUS status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, R"(SYSTEM\CurrentControlSet\Services\EQU8_HELPER_36)", 0,
	                               KEY_READ, &equ8DriverKey);
	if (status != ERROR_SUCCESS)
	{
		std::cout << "~ failed to open equ8 driver key : " << std::hex << status << "\n";
		std::cin.get();
		return 0;
	}

	status = RegQueryValueExA(equ8DriverKey, "SessionId", nullptr, nullptr, reinterpret_cast<LPBYTE>(deviceSessionId),
	                          &deviceSessionIdLength);
	if (status != ERROR_SUCCESS)
	{
		std::cout << "~ failed to query equ8 session id : " << std::hex << status << "\n";
		std::cin.get();
		return 0;
	}

	const std::string driverDeviceName = "\\??\\" + std::string(deviceSessionId);
	std::cout << "~ found equ8 driver : " << driverDeviceName << "\n";
	std::cout << "~ waiting for game\n";

	do
	{
		ioctlHandle = LI_FN(CreateFileA).get()(driverDeviceName.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING,
		                          FILE_ATTRIBUTE_NORMAL, nullptr);
		lastError = GetLastError();
		if (lastErrorHistory != lastError)
		{
			if (lastErrorHistory == 0 && lastError == ERROR_NO_SUCH_DEVICE)
			{
				std::cout << "~ failed to get device handle\n";
			}
			if (lastErrorHistory == ERROR_NO_SUCH_DEVICE && lastError != ERROR_SUCCESS)
			{
				std::cout << "~ failed to find the device\n";
			}
			lastErrorHistory = lastError;
		}
	}
	while (lastError == ERROR_FILE_NOT_FOUND || lastError == ERROR_ACCESS_DENIED || lastError == ERROR_NO_SUCH_DEVICE);

	if (ioctlHandle == INVALID_HANDLE_VALUE)
	{
		std::cout << "~ failed to get device handle due to unhandled error : " << std::hex << lastError << "\n";
		std::cin.get();
		return 0;
	}

	std::cout << "~ successfully opened equ8 driver : " << std::hex << reinterpret_cast<ULONG64>(ioctlHandle) << "\n";
	while (globals::process::get_process_pid_by_name("PortalWars-Win64-Shipping.exe") == NULL)
	{
		Sleep(50);
	}

	std::cout << "~ received handle to the game\n";
	CloseHandle(ioctlHandle);

	std::cout << "~ equ8 unloaded successfully\n";
	std::cout << "~ waiting for window\n";
	while (!FindWindowA(nullptr, "PortalWars  "))
	{
		Sleep(100);
	}

	DWORD split_gate_pid = 0;
	GetWindowThreadProcessId(FindWindowA(nullptr, "PortalWars  "), &split_gate_pid);

	const HANDLE h_object = OpenProcess(PROCESS_ALL_ACCESS, false, split_gate_pid);
	if (!h_object)
	{
		std::cout << "~ failed to get handle to process\n";
		std::cin.get();
		return 0;
	}
	std::cout << "~ opening file dialog\n";
	globals::process::inject_dll(h_object, globals::file::open_file_name());
	CloseHandle(h_object);

	std::cout << "~ successfully loaded the buffer\n";
	std::cin.get();
	return 0;
}




```

`processuser.hpp`:

```hpp
/**
 *
 * Title: EQU8 User-Mode Bypass and Injector
 * Author: hotline
 *
*/
#pragma once
#include <Windows.h>
#include <string>

#define MAX_NAME 256

inline auto GetLogonFromToken(HANDLE hToken, std::string& strUser) -> BOOL
{
    DWORD dwSize = MAX_NAME;
    BOOL bSuccess = FALSE;
    DWORD dwLength = 0;
    strUser = "";
    PTOKEN_USER ptu = nullptr;
    //Verify the parameter passed in is not NULL.
    if (nullptr == hToken)
        goto Cleanup;

    if (!GetTokenInformation(
        hToken,         // handle to the access token
        TokenUser,    // get information about the token's groups 
        static_cast<LPVOID>(ptu),   // pointer to PTOKEN_USER buffer
        0,              // size of buffer
        &dwLength       // receives required buffer size
        ))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            goto Cleanup;

        ptu = static_cast<PTOKEN_USER>(HeapAlloc(GetProcessHeap(),
            HEAP_ZERO_MEMORY, dwLength));

        if (ptu == nullptr)
            goto Cleanup;
    }

    if (!GetTokenInformation(
        hToken,         // handle to the access token
        TokenUser,    // get information about the token's groups 
        static_cast<LPVOID>(ptu),   // pointer to PTOKEN_USER buffer
        dwLength,       // size of buffer
        &dwLength       // receives required buffer size
        ))
    {
        goto Cleanup;
    }
    SID_NAME_USE SidType;
    char lpName[MAX_NAME];
    char lpDomain[MAX_NAME];

    if (!LookupAccountSidA(nullptr, ptu->User.Sid, lpName, &dwSize, lpDomain, &dwSize, &SidType))
    {
        const DWORD dwResult = GetLastError();
        if (dwResult == ERROR_NONE_MAPPED)
            strcpy_s(lpName, "NONE_MAPPED");
    }
    else
    {
        strUser = lpName;
        bSuccess = TRUE;
    }

Cleanup:

    if (ptu != nullptr)
        HeapFree(GetProcessHeap(), 0, static_cast<LPVOID>(ptu));
    return bSuccess;
}

inline auto GetUserFromProcess(const DWORD procId, std::string& strUser) -> HRESULT
{
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, procId);
    if (hProcess == nullptr)
        return E_FAIL;
    HANDLE hToken = nullptr;

    if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken))
    {
        CloseHandle(hProcess);
        return E_FAIL;
    }
    BOOL bres = GetLogonFromToken(hToken, strUser);

    CloseHandle(hToken);
    CloseHandle(hProcess);
    return bres ? S_OK : E_FAIL;
}
```

`trustedinstaller.hpp`:

```hpp
/**
 *
 * Title: EQU8 User-Mode Bypass and Injector
 * Author: hotline
 *
*/
#pragma once
#include <iostream>
#include <codecvt>
#include <string>
#include <tchar.h>
#include <Windows.h>
#include <TlHelp32.h>

using namespace std;

inline auto EnablePrivilege(string privilegeName) -> void
{
	HANDLE hToken;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
		return;

	LUID luid;
	if (!LookupPrivilegeValueA(nullptr, privilegeName.c_str(), &luid))
	{
		CloseHandle(hToken);
		return;
	}

	TOKEN_PRIVILEGES tp;
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr))
	{
		CloseHandle(hToken);
		return;
	}

	CloseHandle(hToken);
}

inline auto s2ws(const std::string& s) -> std::wstring
{
	const int slength = static_cast<int>(s.length()) + 1;
	const int len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0);
	wchar_t* buf = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len);
	std::wstring r(buf);
	delete[] buf;
	return r;
}

inline auto GetProcessIdByName(string processName) -> DWORD
{
	HANDLE hSnapshot;
	if ((hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)) == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD pid = -1;
	PROCESSENTRY32 pe;
	ZeroMemory(&pe, sizeof(PROCESSENTRY32));
	pe.dwSize = sizeof(PROCESSENTRY32);
	if (Process32First(hSnapshot, &pe))
	{
		while (Process32Next(hSnapshot, &pe))
		{
			if (pe.szExeFile == processName)
			{
				pid = pe.th32ProcessID;
				break;
			}
		}
	}
	else
	{
		CloseHandle(hSnapshot);
		return 0;
	}

	if (pid == -1)
	{
		CloseHandle(hSnapshot);
		return 0;
	}

	CloseHandle(hSnapshot);
	return pid;
}

inline auto ImpersonateSystem() -> void
{
	const auto systemPid = GetProcessIdByName("winlogon.exe");
	HANDLE hSystemProcess;
	if ((hSystemProcess = OpenProcess(
		PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
		FALSE,
		systemPid)) == nullptr)
	{
		return;
	}

	HANDLE hSystemToken;
	if (!OpenProcessToken(
		hSystemProcess,
		MAXIMUM_ALLOWED,
		&hSystemToken))
	{
		CloseHandle(hSystemProcess);
		return;
	}

	HANDLE hDupToken;
	SECURITY_ATTRIBUTES tokenAttributes;
	tokenAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	tokenAttributes.lpSecurityDescriptor = nullptr;
	tokenAttributes.bInheritHandle = FALSE;
	if (!DuplicateTokenEx(
		hSystemToken,
		MAXIMUM_ALLOWED,
		&tokenAttributes,
		SecurityImpersonation,
		TokenImpersonation,
		&hDupToken))
	{
		CloseHandle(hSystemToken);
		return;
	}

	if (!ImpersonateLoggedOnUser(hDupToken))
	{
		CloseHandle(hDupToken);
		CloseHandle(hSystemToken);
		return;
	}

	CloseHandle(hDupToken);
	CloseHandle(hSystemToken);
}

inline auto StartTrustedInstallerService() -> int
{
	SC_HANDLE hSCManager;
	if ((hSCManager = OpenSCManagerA(
		nullptr,
		SERVICES_ACTIVE_DATABASE,
		GENERIC_EXECUTE)) == nullptr)
	{
		return 0;
	}

	SC_HANDLE hService;
	if ((hService = OpenServiceA(
		hSCManager,
		"TrustedInstaller",
		GENERIC_READ | GENERIC_EXECUTE)) == nullptr)
	{
		CloseServiceHandle(hSCManager);
		return 0;
	}

	SERVICE_STATUS_PROCESS statusBuffer;
	DWORD bytesNeeded;
	while (QueryServiceStatusEx(
		hService,
		SC_STATUS_PROCESS_INFO,
		reinterpret_cast<LPBYTE>(&statusBuffer),
		sizeof(SERVICE_STATUS_PROCESS),
		&bytesNeeded))
	{
		if (statusBuffer.dwCurrentState == SERVICE_STOPPED)
		{
			if (!StartServiceA(hService, 0, nullptr))
			{
				CloseServiceHandle(hService);
				CloseServiceHandle(hSCManager);
				return 0;
			}
		}
		if (statusBuffer.dwCurrentState == SERVICE_START_PENDING ||
			statusBuffer.dwCurrentState == SERVICE_STOP_PENDING)
		{
			Sleep(statusBuffer.dwWaitHint);
			continue;
		}
		if (statusBuffer.dwCurrentState == SERVICE_RUNNING)
		{
			CloseServiceHandle(hService);
			CloseServiceHandle(hSCManager);
			return statusBuffer.dwProcessId;
		}
	}
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	return 0;
}

inline auto CreateProcessAsTrustedInstaller(DWORD pid, string exe_path) -> void
{
	EnablePrivilege(SE_DEBUG_NAME);
	EnablePrivilege(SE_IMPERSONATE_NAME);
	ImpersonateSystem();

	HANDLE hTIProcess;
	if ((hTIProcess = OpenProcess(
		PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
		FALSE,
		pid)) == nullptr)
	{
		return;
	}

	HANDLE hTIToken;
	if (!OpenProcessToken(
		hTIProcess,
		MAXIMUM_ALLOWED,
		&hTIToken))
	{
		CloseHandle(hTIProcess);
		return;
	}

	HANDLE hDupToken;
	SECURITY_ATTRIBUTES tokenAttributes;
	tokenAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	tokenAttributes.lpSecurityDescriptor = nullptr;
	tokenAttributes.bInheritHandle = FALSE;
	if (!DuplicateTokenEx(
		hTIToken,
		MAXIMUM_ALLOWED,
		&tokenAttributes,
		SecurityImpersonation,
		TokenImpersonation,
		&hDupToken))
	{
		CloseHandle(hTIToken);
		return;
	}

	STARTUPINFOW startupInfo;
	ZeroMemory(&startupInfo, sizeof(STARTUPINFOW));
	startupInfo.lpDesktop = LPWSTR(L"Winsta0\\Default");
	PROCESS_INFORMATION processInfo;
	ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));
	if (!CreateProcessWithTokenW(
		hDupToken,
		LOGON_WITH_PROFILE,
		LPWSTR(s2ws(exe_path).c_str()),
		nullptr,
		CREATE_UNICODE_ENVIRONMENT,
		nullptr,
		nullptr,
		&startupInfo,
		&processInfo))
	{
		return;
	}
}

inline auto create_process(string exe) -> void
{
	const auto pid = StartTrustedInstallerService();
	CreateProcessAsTrustedInstaller(pid, exe);
}

```