Project Path: arc_gmh5225_KernelPatch_f3q5v6v5

Source Tree:

```txt
arc_gmh5225_KernelPatch_f3q5v6v5
├── LICENSE
├── README.md
├── README_zh-CN.md
├── doc
│   ├── en
│   │   ├── build.md
│   │   ├── faq.md
│   │   ├── guide.md
│   │   ├── inline-hook.md
│   │   ├── module.md
│   │   ├── super-syscall.md
│   │   └── syscall-hook.md
│   └── zh-cn
│       ├── build.md
│       ├── faq.md
│       ├── guide.md
│       ├── inline-hook.md
│       ├── module.md
│       ├── super-syscall.md
│       └── syscall-hook.md
├── kernel
│   ├── Makefile
│   ├── base
│   │   ├── hmem.c
│   │   ├── hook.c
│   │   ├── map.c
│   │   ├── predata.c
│   │   ├── preset.h
│   │   ├── setup.c
│   │   ├── setup.h
│   │   ├── setup1.S
│   │   ├── start.c
│   │   └── start.h
│   ├── include
│   │   ├── cache.h
│   │   ├── common.h
│   │   ├── compiler.h
│   │   ├── error.h
│   │   ├── hook.h
│   │   ├── kallsyms.h
│   │   ├── ktypes.h
│   │   ├── log.h
│   │   ├── pgtable.h
│   │   ├── predata.h
│   │   ├── stdarg.h
│   │   ├── stdbool.h
│   │   ├── stddef.h
│   │   └── stdint.h
│   ├── init
│   │   ├── accctl
│   │   │   ├── accctl.c
│   │   │   ├── lsmhook.c
│   │   │   ├── selinuxhook.c
│   │   │   ├── sucompat.c
│   │   │   └── supercall.c
│   │   ├── extend
│   │   │   ├── lsmext.c
│   │   │   ├── syscall.c
│   │   │   └── taskob.c
│   │   ├── include
│   │   │   ├── accctl.h
│   │   │   ├── ksyms.h
│   │   │   ├── lsmext.h
│   │   │   ├── syscall.h
│   │   │   ├── taskext.h
│   │   │   ├── taskob.h
│   │   │   └── uapi
│   │   │       ├── lsmdef.h
│   │   │       └── scdefs.h
│   │   ├── init.c
│   │   ├── init.h
│   │   ├── ksyms
│   │   │   ├── misc.c
│   │   │   ├── misc_len.c
│   │   │   ├── security.c
│   │   │   └── selinux.c
│   │   └── struct
│   │       └── task_cred.c
│   ├── kpimg.lds
│   ├── linux
│   │   ├── arch
│   │   │   └── arm64
│   │   │       └── include
│   │   │           ├── asm
│   │   │           │   ├── cacheflush.h
│   │   │           │   ├── current.h
│   │   │           │   ├── ptrace.h
│   │   │           │   ├── thread_info.h
│   │   │           │   ├── unistd.h
│   │   │           │   └── unistd32.h
│   │   │           └── uapi
│   │   │               └── asm
│   │   │                   └── ptrace.h
│   │   ├── include
│   │   │   ├── asm-generic
│   │   │   │   └── rwonce.h
│   │   │   ├── linux
│   │   │   │   ├── bitops.h
│   │   │   │   ├── build_bug.h
│   │   │   │   ├── capability.h
│   │   │   │   ├── container_of.h
│   │   │   │   ├── cred.h
│   │   │   │   ├── errno.h
│   │   │   │   ├── fs.h
│   │   │   │   ├── gfp.h
│   │   │   │   ├── init_task.h
│   │   │   │   ├── kallsyms.h
│   │   │   │   ├── kern_levels.h
│   │   │   │   ├── kernel.h
│   │   │   │   ├── list.h
│   │   │   │   ├── mm.h
│   │   │   │   ├── pid.h
│   │   │   │   ├── poison.h
│   │   │   │   ├── preempt.h
│   │   │   │   ├── printk.h
│   │   │   │   ├── rcupdate.h
│   │   │   │   ├── rwlock.h
│   │   │   │   ├── sched
│   │   │   │   │   └── task.h
│   │   │   │   ├── sched.h
│   │   │   │   ├── security.h
│   │   │   │   ├── slab.h
│   │   │   │   ├── socket.h
│   │   │   │   ├── spinlock.h
│   │   │   │   ├── stop_machine.h
│   │   │   │   ├── string.h
│   │   │   │   ├── syscall.h
│   │   │   │   ├── thread_info.h
│   │   │   │   ├── uaccess.h
│   │   │   │   └── vmalloc.h
│   │   │   ├── net
│   │   │   │   └── netlabel.h
│   │   │   ├── uapi
│   │   │   │   ├── asm-generic
│   │   │   │   │   ├── errno-base.h
│   │   │   │   │   ├── errno.h
│   │   │   │   │   └── unistd.h
│   │   │   │   └── linux
│   │   │   │       ├── capability.h
│   │   │   │       ├── magic.h
│   │   │   │       └── prctl.h
│   │   │   └── vdso
│   │   │       └── limits.h
│   │   ├── security
│   │   │   └── selinux
│   │   │       └── include
│   │   │           ├── avc.h
│   │   │           ├── avc_ss.h
│   │   │           ├── classmap.h
│   │   │           └── security.h
│   │   └── tools
│   │       └── arch
│   │           └── arm64
│   │               └── include
│   │                   └── asm
│   │                       └── barrier.h
│   ├── minc
│   │   ├── ctype.h
│   │   ├── print.c
│   │   ├── print.h
│   │   ├── stdio.h
│   │   ├── stdlib.c
│   │   ├── stdlib.h
│   │   ├── string.c
│   │   └── string.h
│   ├── module
│   │   ├── hello
│   │   │   ├── Makefile
│   │   │   └── hello.c
│   │   ├── module.c
│   │   └── module.h
│   └── version
├── tools
│   ├── CMakeLists.txt
│   ├── Makefile
│   ├── image.c
│   ├── image.h
│   ├── kallsym.c
│   ├── kallsym.h
│   ├── kptools.c
│   ├── order.c
│   ├── order.h
│   └── version
└── user
    ├── CMakeLists.txt
    ├── Makefile
    ├── libkp.c
    ├── libkp.h
    ├── main.c
    ├── supercall.h
    └── version

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# KernelPatch

**Patching and hooking the Linux kernel with only stripped Linux kernel image.**

If you are using Android, [AndroidKernelPatch](https://github.com/bmax121/AndroidKernelPatch) would be a better choice.

**English** | [简体中文](README_zh-CN.md)

KernelPatch provides the fundamental capability to parse Linux kernel images without source code and symbol information, allowing for the retrieval of arbitrary symbol offsets and the injection of arbitrary code into the kernel.  
Building upon this foundation, KernelPatch offers essential features such as system-call-hook and inline-hook in the kernel.  
You have complete control over the kernel, allowing you to implement desired functionalities such as privilege escalation, hiding, monitoring, and more.  

**KernelPatch is intended solely for learning and communication purposes. It is strictly prohibited from being used for any illegal activities.**

## Supported Versions

Currently only supports arm64 architecture.  

Linux 3.8 - 6.2 (theoretically)  
Linux 6.3+ (not yet adapted)  

## Get Help

## Get Involved

## Community Discussion

## More Information

[Documentation](./doc/en/)

## Credits

- [vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf): Some ideas for parsing kernel symbols.
- [android-inline-hook](https://github.com/bytedance/android-inline-hook): Some code for fixing arm64 inline hook instructions.
- [https://elixir.bootlin.com](https://elixir.bootlin.com/linux/v6.2.16/C/ident/): Linux source code online.

## License

KernelPatch is licensed under the **GNU General Public License v3 (GPL-3)** (<http://www.gnu.org/copyleft/gpl.html>).

```

`README_zh-CN.md`:

```md
# KernelPatch

**Patching and hooking the Linux kernel with only stripped Linux kernel image.**

如果你在使用 Android，[AndroidKernelPatch](https://github.com/bmax121/AndroidKernelPatch) 会是更好的选择。

KernelPatch 提供可以在无源码无符号情况下解析Linux内核镜像，获取任意符号偏移，并向内核中注入任意代码的基础能力。  
在此基础上，KernelPatch 还提供了系统调用 hook，内核 inline-hook 等基础功能。  
你可以完全的掌控内核，实现你想要的功能，比如提权，隐藏，监控等等。  

**KernelPatch 仅供学习交流。严禁用于任何非法用途。**

## 支持情况

当前只支持 arm64

Linux 3.8 - 6.2 (理论上)  
Linux 6.3+ (暂未适配)  

## 获取帮助

## 参与进来

## 讨论

## 更多信息

[文档](./doc/zh-cn/)

## 鸣谢

- [vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf): 参考学习了解析内核符号的思路
- [android-inline-hook](https://github.com/bytedance/android-inline-hook): 用了 arm64 inline hook 指令修复的代码
- [linux source code online](https://elixir.bootlin.com/linux/v6.2.16/C/ident/): 内核源码在线

## 许可证

KernelPatch 发布许可：**GNU General Public License v3 (GPL-3)** (<http://www.gnu.org/copyleft/gpl.html>).

```

`doc/en/build.md`:

```md
# How to Build

## Build kpimg

Need to use a bare-metal cross-compiler.  
[Download](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)

```shell
export TARGET_COMPILE=aarch64-none-elf-
cd kernel
make
```

## Build kptools

kptools can run anywhere, just compile it.

- Using Makefile

```shell
cd tools
make
```

- Using CMake

```shell
mkdir build
cd build
cmake ..
make
```

## Building kpatch

kpatch runs in the user space of the target system, so you can build it as usual, for example, using NDK on Android.

- Using Makefile

```shell
cd tools
make
```

- Using CMake

```shell
mkdir build
cd build
cmake ..
make
```

```

`doc/en/guide.md`:

```md
# Guide

## How KernelPatch Works

KernelPatch consists of three components: kptools, kpimg, and kpatch.

### [kptools](/tools/)

kptools serves the following purposes:

- It can parse kernel images without source code or symbol information and retrieve the offset addresses of arbitrary kernel symbols.
- It patches the kernel image by appending kpimg to the end of the image and writing necessary information to the predetermined locations in kpimg. Finally, it replaces the kernel's startup location with the starting address of kpimg.

### [kpimg](/kernel/)

kpimg is a specially designed ELF

1. kpimg takes over the kernel start-up while the kernel is still using physical addresses. At this point, kpimg writes necessary information into [map](/kernel/base/map.c) and [start](/kernel/base/start.c), then relocates them to the specified location.
2. It replaces **paging_init** with **_paging_init**, and then restarts the kernel.
**_paging_init** reserves space, modifies page table attributes, and jumps to **start**.
3. In the **start** phase, further page table modifications are performed, kernel inline hooks are initialized, and then it proceeds to **init**.
4. **init** provides a relatively comfortable C-language environment (except for statically linked absolute addresses), where we can accomplish various desired functionalities, such as modifying system calls, and more.  

If you don't need extensive functionalities or want customization, you can separately utilize the code in [/kernel/base](/kernel/base).

- [SuperCall](./super-syscall.md)

- [Kernel Inline Hook](./inline-hook.md)

- [Kernel Patch Module](./module.md)

### [kpuser](/user/)

kpuser is the user space header file and library for KernelPatch. You can directly embed kpuser into your program.

```

`doc/en/module.md`:

```md
# KernelPatch Module

```

`doc/en/super-syscall.md`:

```md
# Super System Call

```

`doc/zh-cn/build.md`:

```md
# 如何编译

## 编译 kpimg

需要使用裸机交叉编译器  
[下载编译器](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)

```shell
export TARGET_COMPILE=aarch64-none-elf-
cd kernel
make
```

## 编译 kptools

kptools 可以运行在任何地方，编译就好了

- 使用 Makefile

```shell
cd tools
make
```

- 使用 CMake

```shell
mkdir build
cd build
cmake ..
make
```

## 编译 kpatch

kpatch 运行在目标系统的用户空间，像往常一样构建就好了，例如在 Android 上使用 ndk

- 使用 Makefile

```shell
cd tools
make
```

- 使用 CMake

```shell
mkdir build
cd build
cmake ..
make
```

```

`doc/zh-cn/faq.md`:

```md
# FAQ

```

`doc/zh-cn/guide.md`:

```md
# Guide

## KernelPatch 是如何做到的

KernelPatch 包含 kptools kpimg kpatch 三个部分

### [kptools](/tools/)

kptools 主要有以下几个作用：

- 可以在无源码和符号信息的情况下解析内核镜像，获取任意内核符号的偏移地址。
- 修补内核镜像，将 kpimg 追加到内核镜像后面并将一些必要的信息写入到 kpimg 预设的位置上，最后内核的启动位置替换为kpimg起始地址。

### [kpimg](/kernel/)

kpimg 是一个经过特殊设计的 ELF

1. kpimg 接管内核启动，此时内核还在使用物理地址，kpimg 会在这时将必要的信息写入到 [map](/kernel/base/map.c) 和 [start](/kernel/base/start.c)，
然后将其都重定位到指定的位置
2. 替换 **paging_init** 为 **_paging_init**，然后重新启动内核
3. **_paging_init** 预留空间，修改页表属性，然后跳转到 **start**
4. **start** 阶段会进一步修改页表，初始化内核内联钩子等，然后进入到 **init**
5. **init** 是一个相对舒服的C语言世界（除了静态链接的绝对地址），在这里我们可以完成任意我们想要的功能，例如修改系统调用，等。  

如果你不需要太多的功能，或者想要定制的话，[/kernel/base](/kernel/base) 代码可以单独拿出来使用。  

- [SuperCall](./super-syscall.md)

- [Kernel Inline Hook](./inline-hook.md)

- [Kernel Patch Module](./module.md)

### [kpuser](/user/)

kpuser 是用户空间头文件，库，还有一个可执行程序 kpatch，可以直接将它们嵌入到你的程序中。

```

`doc/zh-cn/module.md`:

```md
# KernelPatch Module

```

`doc/zh-cn/super-syscall.md`:

```md
# Super System Call

```

`kernel/Makefile`:

```
ifndef TARGET_COMPILE
    $(error TARGET_COMPILE is not set)
endif

CC = $(TARGET_COMPILE)gcc
LD = $(TARGET_COMPILE)ld
AS = $(TARGET_COMPILE)as
OBJCOPY = $(TARGET_COMPILE)objcopy

CFLAGS += -Wall -fno-builtin -std=gnu11 -nostdinc
CFLAGS += -g

ifdef DEBUG
	CFLAGS += -DDEBUG -DMAP_DEBUG -g
endif

ifdef ANDROID
	CFLAGS += -DANDROID
endif

INCLUDE := -I. -Iinclude -Ilibc -Iinit/include -Ilinux -Ilinux/include -Ilinux/arch/arm64/include -Ilinux/tools/arch/arm64/include

BASE_SRCS += base/hook.c 
BASE_SRCS += base/map.c 
BASE_SRCS += base/hmem.c 
BASE_SRCS += base/setup.c 
BASE_SRCS += base/setup1.S
BASE_SRCS += base/start.c 
BASE_SRCS += base/predata.c 

BASE_SRCS += $(wildcard minc/*.c)

BASE_SRCS += $(wildcard module/*.c)

BASE_SRCS += $(wildcard init/*.c)
BASE_SRCS += $(wildcard init/accctl/*.c)
BASE_SRCS += $(wildcard init/extend/*.c)
BASE_SRCS += $(wildcard init/ksyms/*.c)
BASE_SRCS += $(wildcard init/struct/*.c)
BASE_SRCS += $(wildcard init/debug/*.c)


SRCS += $(BASE_SRCS)
SRCS += $(LINUX_SRCS)

OBJS := $(SRCS:.c=.o)
OBJS := $(OBJS:.S=.o)

all: kpimg hdr

kpimg: kpimg.elf
	${OBJCOPY} -O binary -S $^ $@

kpimg.elf: ${OBJS}
	${LD} -nostdlib -static -no-pie -Tkpimg.lds -o $@ $^

%.o: %.c
	${CC} $(CFLAGS) $(INCLUDE) -c -O2 -o $@ $<

%.o: %.S
	${CC} $(CFLAGS) $(INCLUDE) -c -o $@ $<

hdr:
	cp base/preset.h ../tools/
	cp -rf init/include/uapi ../user/

.PHONY: clean
clean:
	rm -rf *.elf
	rm -rf kpimg
	find . -name *.o | xargs rm -f
```

`kernel/base/hmem.c`:

```c
#include "hook.h"

#include <stdint.h>

// todo: refactor

static uint64_t mem_region_start[HOOK_MEM_REGION_NUM] = { 0 };
static uint64_t mem_region_end[HOOK_MEM_REGION_NUM] = { 0 };

typedef struct
{
    bool using;
    hook_chain_t chain;
} hook_mem_warp_t;

bool hook_mem_add(uint64_t start, int32_t size)
{
    for (uint64_t i = start; i < start + size; i += 8) {
        *(uint64_t *)i = 0;
    }

    for (int i = 0; i < HOOK_MEM_REGION_NUM; i++) {
        if (!mem_region_start[i]) {
            mem_region_start[i] = start;
            mem_region_end[i] = start + size;
            return true;
        }
    }
    return false;
}

hook_chain_t *hook_mem_alloc()
{
    for (int i = 0; i < HOOK_MEM_REGION_NUM; i++) {
        uint64_t start = mem_region_start[i];
        if (!start)
            continue;
        for (uint64_t addr = start; addr < mem_region_end[i]; addr += sizeof(hook_mem_warp_t)) {
            hook_mem_warp_t *wrap = (hook_mem_warp_t *)addr;
            // todo: lock
            if (wrap->using)
                continue;

            wrap->using = true;

            for (int j = local_offsetof(hook_mem_warp_t, chain); j < sizeof(hook_mem_warp_t); j += 8) {
                *(uint64_t *)(addr + j) = 0;
            }
            return &wrap->chain;
        }
    }
    return 0;
}

inline void hook_mem_free(hook_chain_t *free)
{
    hook_mem_warp_t *warp = local_container_of(free, hook_mem_warp_t, chain);
    warp->using = false;
}

hook_chain_t *hook_get_chain_from_origin(uint64_t origin_addr)
{
    for (int i = 0; i < HOOK_MEM_REGION_NUM; i++) {
        uint64_t start = mem_region_start[i];
        if (!start)
            continue;
        for (uint64_t addr = start; addr < mem_region_end[i]; addr += sizeof(hook_mem_warp_t)) {
            hook_mem_warp_t *wrap = (hook_mem_warp_t *)addr;
            if (wrap->using && wrap->chain.hook.origin_addr == origin_addr) {
                return &wrap->chain;
            }
        }
    }
    return 0;
}

```

`kernel/base/hook.c`:

```c
#include <hook.h>
#include <cache.h>
#include <pgtable.h>

#define bits32(n, high, low) ((uint32_t)((n) << (31u - (high))) >> (31u - (high) + (low)))
#define bit(n, st) (((n) >> (st)) & 1)
#define sign64_extend(n, len) \
    (((uint64_t)((n) << (63u - (len - 1))) >> 63u) ? ((n) | (0xFFFFFFFFFFFFFFFF << (len))) : n)
#define align_ceil(x, align) (((u64)(x) + (u64)(align)-1) & ~((u64)(align)-1))

typedef uint32_t inst_type_t;
typedef uint32_t inst_mask_t;

#define INST_B 0x14000000
#define INST_BC 0x54000000
#define INST_BL 0x94000000
#define INST_ADR 0x10000000
#define INST_ADRP 0x90000000
#define INST_LDR_32 0x18000000
#define INST_LDR_64 0x58000000
#define INST_LDRSW_LIT 0x98000000
#define INST_PRFM_LIT 0xD8000000
#define INST_LDR_SIMD_32 0x1C000000
#define INST_LDR_SIMD_64 0x5C000000
#define INST_LDR_SIMD_128 0x9C000000
#define INST_CBZ 0x34000000
#define INST_CBNZ 0x35000000
#define INST_TBZ 0x36000000
#define INST_TBNZ 0x37000000
#define INST_IGNORE 0x0

#define MASK_B 0xFC000000
#define MASK_BC 0xFF000010
#define MASK_BL 0xFC000000
#define MASK_ADR 0x9F000000
#define MASK_ADRP 0x9F000000
#define MASK_LDR_32 0xFF000000
#define MASK_LDR_64 0xFF000000
#define MASK_LDRSW_LIT 0xFF000000
#define MASK_PRFM_LIT 0xFF000000
#define MASK_LDR_SIMD_32 0xFF000000
#define MASK_LDR_SIMD_64 0xFF000000
#define MASK_LDR_SIMD_128 0xFF000000
#define MASK_CBZ 0x7F000000u
#define MASK_CBNZ 0x7F000000u
#define MASK_TBZ 0x7F000000u
#define MASK_TBNZ 0x7F000000u
#define MASK_IGNORE 0x0

static inst_mask_t masks[] = {
    MASK_B,      MASK_BC,        MASK_BL,       MASK_ADR,         MASK_ADRP,        MASK_LDR_32,
    MASK_LDR_64, MASK_LDRSW_LIT, MASK_PRFM_LIT, MASK_LDR_SIMD_32, MASK_LDR_SIMD_64, MASK_LDR_SIMD_128,
    MASK_CBZ,    MASK_CBNZ,      MASK_TBZ,      MASK_TBNZ,        MASK_IGNORE,
};
static inst_type_t types[] = {
    INST_B,      INST_BC,        INST_BL,       INST_ADR,         INST_ADRP,        INST_LDR_32,
    INST_LDR_64, INST_LDRSW_LIT, INST_PRFM_LIT, INST_LDR_SIMD_32, INST_LDR_SIMD_64, INST_LDR_SIMD_128,
    INST_CBZ,    INST_CBNZ,      INST_TBZ,      INST_TBNZ,        INST_IGNORE,
};

static int32_t relo_len[] = { 5, 7, 5, 4, 4, 5, 5, 5, 7, 7, 7, 7, 6, 6, 6, 6, 1 };

// static uint64_t sign_extend(uint64_t x, uint32_t len)
// {
//     char sign_bit = bit(x, len - 1);
//     unsigned long sign_mask = 0 - sign_bit;
//     x |= ((sign_mask >> len) << len);
//     return x;
// }

static bool is_in_tramp(hook_t *hook, uint64_t addr)
{
    uint64_t tramp_start = hook->origin_addr;
    uint64_t tramp_end = tramp_start + hook->tramp_insts_len * 4;
    if (addr >= tramp_start && addr < tramp_end)
        return true;
    return false;
}

static uint64_t relo_in_tramp(hook_t *hook, uint64_t addr)
{
    uint64_t tramp_start = hook->origin_addr;
    uint64_t tramp_end = tramp_start + hook->tramp_insts_len * 4;
    if (!(addr >= tramp_start && addr < tramp_end))
        return addr;
    uint32_t addr_inst_index = (addr - tramp_start) / 4;
    uint64_t fix_addr = hook->relo_addr;
    for (int i = 0; i < addr_inst_index; i++) {
        inst_type_t inst = hook->origin_insts[i];
        for (int j = 0; j < sizeof(relo_len) / sizeof(relo_len[0]); j++) {
            if ((inst & masks[j]) == types[j]) {
                fix_addr += relo_len[j] * 4;
                break;
            }
        }
    }
    return fix_addr;
}

#ifdef HOOK_INTO_BRANCH_FUNC
uint64_t relo_func(uint64_t addr)
{
    uint32_t inst = *(uint32_t *)addr;
    if ((inst & MASK_B) == INST_B) {
        uint64_t imm26 = bits32(inst, 25, 0);
        uint64_t imm64 = sign64_extend(imm26 << 2u, 28u);
        addr += imm64;
    }
    return addr;
}
#endif

bool relo_b(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;
    uint64_t imm64;
    if (type == INST_BC) {
        uint64_t imm19 = bits32(inst, 23, 5);
        imm64 = sign64_extend(imm19 << 2u, 21u);
    } else {
        uint64_t imm26 = bits32(inst, 25, 0);
        imm64 = sign64_extend(imm26 << 2u, 28u);
    }
    uint64_t addr = inst_addr + imm64;
    addr = relo_in_tramp(hook, addr);

    uint32_t idx = 0;
    if (type == INST_BC) {
        buf[idx++] = (inst & 0xFF00001F) | 0x40u; // B.<cond> #8
        buf[idx++] = 0x14000006; // B #24
    }
    buf[idx++] = 0x58000051; // LDR X17, #8
    buf[idx++] = 0x14000003; // B #12
    buf[idx++] = addr & 0xFFFFFFFF;
    buf[idx++] = addr >> 32u;
    if (type == INST_BL) {
        buf[idx++] = 0xD63F0220; // BLR X17
    } else {
        buf[idx++] = 0xD61F0220; // BR X17
    }
    return true;
}

bool relo_adr(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;

    uint32_t xd = bits32(inst, 4, 0);
    uint64_t immlo = bits32(inst, 30, 29);
    uint64_t immhi = bits32(inst, 23, 5);
    uint64_t addr;

    if (type == INST_ADR) {
        addr = inst_addr + sign64_extend((immhi << 2u) | immlo, 21u);
    } else {
        addr = (inst_addr + sign64_extend((immhi << 14u) | (immlo << 12u), 33u)) & 0xFFFFFFFFFFFFF000;
        if (is_in_tramp(hook, addr))
            return false;
    }
    buf[0] = 0x58000040u | xd; // LDR Xd, #8
    buf[1] = 0x14000003; // B #12
    buf[2] = addr & 0xFFFFFFFF;
    buf[3] = addr >> 32u;
    return true;
}

bool relo_ldr(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;

    uint32_t rt = bits32(inst, 4, 0);
    uint64_t imm19 = bits32(inst, 23, 5);
    uint64_t offset = sign64_extend((imm19 << 2u), 21u);
    uint64_t addr = inst_addr + offset;

    if (is_in_tramp(hook, addr) && type != INST_PRFM_LIT)
        return false;

    addr = relo_in_tramp(hook, addr);

    if (type == INST_LDR_32 || type == INST_LDR_64 || type == INST_LDRSW_LIT) {
        buf[0] = 0x58000060u | rt; // LDR Xt, #12
        if (type == INST_LDR_32) {
            buf[1] = 0xB9400000 | rt | (rt << 5u); // LDR Wt, [Xt]
        } else if (type == INST_LDR_64) {
            buf[1] = 0xF9400000 | rt | (rt << 5u); // LDR Xt, [Xt]
        } else {
            // LDRSW_LIT
            buf[1] = 0xB9800000 | rt | (rt << 5u); // LDRSW Xt, [Xt]
        }
        buf[2] = 0x14000003; // B #12
        buf[3] = addr & 0xFFFFFFFF;
        buf[4] = addr >> 32u;
    } else {
        buf[0] = 0xA93F47F0; // STP X16, X17, [SP, -0x10]
        buf[1] = 0x58000091; // LDR X17, #16
        if (type == INST_PRFM_LIT) {
            buf[2] = 0xF9800220 | rt; // PRFM Rt, [X17]
        } else if (type == INST_LDR_SIMD_32) {
            buf[2] = 0xBD400220 | rt; // LDR St, [X17]
        } else if (type == INST_LDR_SIMD_64) {
            buf[2] = 0xFD400220 | rt; // LDR Dt, [X17]
        } else {
            // LDR_SIMD_128
            buf[2] = 0x3DC00220u | rt; // LDR Qt, [X17]
        }
        buf[3] = 0xF85F83F1; // LDR X17, [SP, -0x8]
        buf[4] = 0x14000003; // B #12
        buf[5] = addr & 0xFFFFFFFF;
        buf[6] = addr >> 32u;
    }
    return true;
}

bool relo_cb(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;

    uint64_t imm19 = bits32(inst, 23, 5);
    uint64_t offset = sign64_extend((imm19 << 2u), 21u);
    uint64_t addr = inst_addr + offset;
    addr = relo_in_tramp(hook, addr);

    buf[0] = (inst & 0xFF00001F) | 0x40u; // CB(N)Z Rt, #8
    buf[1] = 0x14000005; // B #20
    buf[2] = 0x58000051; // LDR X17, #8
    buf[3] = 0xd61f0220; // BR X17
    buf[4] = addr & 0xFFFFFFFF;
    buf[5] = addr >> 32u;
    return true;
}

bool relo_tb(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;

    uint64_t imm14 = bits32(inst, 18, 5);
    uint64_t offset = sign64_extend((imm14 << 2u), 16u);
    uint64_t addr = inst_addr + offset;
    addr = relo_in_tramp(hook, addr);

    buf[0] = (inst & 0xFFF8001F) | 0x40u; // TB(N)Z Rt, #<imm>, #8
    buf[1] = 0x14000005; // B #20
    buf[2] = 0x58000051; // LDR X17, #8
    buf[3] = 0xd61f0220; // BR X17
    buf[4] = addr & 0xFFFFFFFF;
    buf[5] = addr >> 32u;
    return true;
}

bool relo_ignore(hook_t *hook, uint64_t inst_addr, uint32_t inst, inst_type_t type)
{
    uint32_t *buf = hook->relo_insts + hook->relo_insts_len;
    buf[0] = inst;
    return true;
}

static uint32_t can_b_rel(uint64_t src_addr, uint64_t dst_addr)
{
#define B_REL_RANGE ((1 << 25) << 2)
    return ((dst_addr >= src_addr) & (dst_addr - src_addr <= B_REL_RANGE)) ||
           ((src_addr >= dst_addr) & (src_addr - dst_addr <= B_REL_RANGE));
}

int32_t branch_relative(uint32_t *buf, uint64_t src_addr, uint64_t dst_addr)
{
    if (can_b_rel(src_addr, dst_addr)) {
        buf[0] = 0x14000000u | (((dst_addr - src_addr) & 0x0FFFFFFFu) >> 2u); // B <label>
        return 1;
    }
    return 0;
}

int32_t branch_absolute(uint32_t *buf, uint64_t addr)
{
    buf[0] = 0x58000051; // LDR X17, #8
    buf[1] = 0xd61f0220; // BR X17
    buf[2] = addr & 0xFFFFFFFF;
    buf[3] = addr >> 32u;
    return 4;
}

int32_t branch_from_to(uint32_t *tramp_buf, uint64_t src_addr, uint64_t dst_addr)
{
#if 1
    uint32_t len = branch_relative(tramp_buf, src_addr, dst_addr);
    if (len)
        return len;
#endif
    return branch_absolute(tramp_buf, dst_addr);
}

// transit0
typedef uint64_t (*transit0_func_t)();

uint64_t __attribute__((section(".transit0.text"))) __attribute__((__noinline__)) _transit0()
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata0_t fdata = { 0 };
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain0_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit0_func_t origin_func = (transit0_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func();
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain0_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}
extern void _transit0_end();

// transit1
typedef uint64_t (*transit1_func_t)(uint64_t);

uint64_t __attribute__((section(".transit1.text"))) __attribute__((__noinline__)) _transit1(uint64_t arg0)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata1_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain1_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit1_func_t origin_func = (transit1_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func(fdata.arg0);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain1_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit1_end();

// transit2
typedef uint64_t (*transit2_func_t)(uint64_t, uint64_t);

uint64_t __attribute__((section(".transit2.text"))) __attribute__((__noinline__))
_transit2(uint64_t arg0, uint64_t arg1)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata2_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.arg1 = arg1;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain2_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit2_func_t origin_func = (transit2_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func(fdata.arg0, fdata.arg1);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain2_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit2_end();

// transit3
typedef uint64_t (*transit3_func_t)(uint64_t, uint64_t, uint64_t);

uint64_t __attribute__((section(".transit3.text"))) __attribute__((__noinline__))
_transit3(uint64_t arg0, uint64_t arg1, uint64_t arg2)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata3_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.arg1 = arg1;
    fdata.arg2 = arg2;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain3_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit3_func_t origin_func = (transit3_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func(fdata.arg0, fdata.arg1, fdata.arg2);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain3_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit3_end();

// transit4
typedef uint64_t (*transit4_func_t)(uint64_t, uint64_t, uint64_t, uint64_t);

uint64_t __attribute__((section(".transit4.text"))) __attribute__((__noinline__))
_transit4(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata4_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.arg1 = arg1;
    fdata.arg2 = arg2;
    fdata.arg3 = arg3;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain4_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit4_func_t origin_func = (transit4_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func(fdata.arg0, fdata.arg1, fdata.arg2, fdata.arg3);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain4_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit4_end();

// transit8:
typedef uint64_t (*transit8_func_t)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

uint64_t __attribute__((section(".transit8.text"))) __attribute__((__noinline__))
_transit8(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6,
          uint64_t arg7)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata8_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.arg1 = arg1;
    fdata.arg2 = arg2;
    fdata.arg3 = arg3;
    fdata.arg4 = arg4;
    fdata.arg5 = arg5;
    fdata.arg6 = arg6;
    fdata.arg7 = arg7;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain8_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit8_func_t origin_func = (transit8_func_t)hook_chain->hook.relo_addr;
        fdata.ret =
            origin_func(fdata.arg0, fdata.arg1, fdata.arg2, fdata.arg3, fdata.arg4, fdata.arg5, fdata.arg6, fdata.arg7);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain8_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit8_end();

// transit12:
typedef uint64_t (*transit12_func_t)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t,
                                     uint64_t, uint64_t, uint64_t, uint64_t);

uint64_t __attribute__((section(".transit12.text"))) __attribute__((__noinline__))
_transit12(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6,
           uint64_t arg7, uint64_t arg8, uint64_t arg9, uint64_t arg10, uint64_t arg11)
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    uint32_t *vptr = (uint32_t *)this_va;
    while (*--vptr != ARM64_NOP) {
    };
    hook_chain_t *hook_chain = local_container_of((uint64_t)vptr, hook_chain_t, transit);
    hook_fdata12_t fdata = { 0 };
    fdata.arg0 = arg0;
    fdata.arg1 = arg1;
    fdata.arg2 = arg2;
    fdata.arg3 = arg3;
    fdata.arg4 = arg4;
    fdata.arg5 = arg5;
    fdata.arg6 = arg6;
    fdata.arg7 = arg7;
    fdata.arg8 = arg8;
    fdata.arg9 = arg9;
    fdata.arg10 = arg10;
    fdata.arg11 = arg11;
    fdata.chain = hook_chain;
    for (int32_t i = 0; i < HOOK_CHAIN_NUM; i++) {
        hook_chain12_callback func = hook_chain->befores[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    if (!fdata.early_ret) {
        transit12_func_t origin_func = (transit12_func_t)hook_chain->hook.relo_addr;
        fdata.ret = origin_func(fdata.arg0, fdata.arg1, fdata.arg2, fdata.arg3, fdata.arg4, fdata.arg5, fdata.arg6,
                                fdata.arg7, fdata.arg8, fdata.arg9, fdata.arg10, fdata.arg11);
    }
    for (int32_t i = HOOK_CHAIN_NUM - 1; i >= 0; i--) {
        hook_chain12_callback func = hook_chain->afters[i];
        if (func)
            func(&fdata, hook_chain->udata[i]);
    }
    return fdata.ret;
}

extern void _transit12_end();

// todo: pac
// todo: stop_machine
// todo: no task has the function in its call stack
hook_err_t hook_prepare(hook_t *hook)
{
    if (!hook->func_addr || !hook->origin_addr || !hook->replace_addr || !hook->relo_addr) {
        return HOOK_INPUT_NULL;
    }
    // backup origin instruction
    for (int i = 0; i < TRAMPOLINE_NUM; i++) {
        hook->origin_insts[i] = *((uint32_t *)hook->origin_addr + i);
    }
    // trampline to replace_addr
    hook->tramp_insts_len = branch_from_to(hook->tramp_insts, hook->origin_addr, hook->replace_addr);
    // relocate
    for (int i = 0; i < hook->tramp_insts_len; i++) {
        uint32_t inst = hook->origin_insts[i];
        uint64_t inst_addr = hook->origin_addr + i * 4;
        for (int j = 0; j < sizeof(relo_len) / sizeof(relo_len[0]); j++) {
            bool relo_res = true;
            if ((inst & masks[j]) == types[j]) {
                inst_type_t it = types[j];
                switch (it) {
                case INST_B:
                case INST_BC:
                case INST_BL:
                    // todo: Crash on pixel 3xl android 12 when relo_b is static inline
                    relo_res = relo_b(hook, inst_addr, inst, it);
                    break;
                case INST_ADR:
                case INST_ADRP:
                    relo_res = relo_adr(hook, inst_addr, inst, it);
                    break;
                case INST_LDR_32:
                case INST_LDR_64:
                case INST_LDRSW_LIT:
                case INST_PRFM_LIT:
                case INST_LDR_SIMD_32:
                case INST_LDR_SIMD_64:
                case INST_LDR_SIMD_128:
                    relo_res = relo_ldr(hook, inst_addr, inst, it);
                    break;
                case INST_CBZ:
                case INST_CBNZ:
                    relo_res = relo_cb(hook, inst_addr, inst, it);
                    break;
                case INST_TBZ:
                case INST_TBNZ:
                    relo_res = relo_tb(hook, inst_addr, inst, it);
                    break;
                case INST_IGNORE:
                default:
                    relo_res = relo_ignore(hook, inst_addr, inst, it);
                    break;
                }
                hook->relo_insts_len += relo_len[j];
                break;
            }
            if (!relo_res)
                return HOOK_BAD_RELO;
        }
    }
    // jump back
    uint64_t back_src_addr = hook->relo_addr + hook->relo_insts_len * 4;
    uint64_t back_dst_addr = hook->origin_addr + hook->tramp_insts_len * 4;
    uint32_t *back_buf = hook->relo_insts + hook->relo_insts_len;
    hook->relo_insts_len += branch_from_to(back_buf, back_src_addr, back_dst_addr);
    return HOOK_NO_ERR;
}

void hook_install(hook_t *hook)
{
    uint64_t va = hook->origin_addr;
    uint64_t *entry = get_pte(va);
    uint64_t ori_prot = *entry;
    *entry = (ori_prot | PTE_DBM) & ~PTE_RDONLY;
    flush_tlb_kernel_page(va);
    for (int32_t i = 0; i < hook->tramp_insts_len; i++) {
        *((uint32_t *)hook->origin_addr + i) = hook->tramp_insts[i];
    }
    dsb(ishst);
    flush_icache_all();
    *entry = ori_prot;
    flush_tlb_kernel_page(va);
}

void hook_uninstall(hook_t *hook)
{
    uint64_t va = hook->origin_addr;
    uint64_t *entry = get_pte(va);
    uint64_t ori_prot = *entry;
    *entry = (ori_prot | PTE_DBM) & ~PTE_RDONLY;
    flush_tlb_kernel_page(va);
    for (int32_t i = 0; i < hook->tramp_insts_len; i++) {
        *((uint32_t *)hook->origin_addr + i) = hook->origin_insts[i];
    }
    dsb(ishst);
    flush_icache_all();
    *entry = ori_prot;
    flush_tlb_kernel_page(va);
}

hook_err_t hook(void *func, void *replace, void **backup)
{
    hook_chain_t *chain = (hook_chain_t *)hook_mem_alloc();
    if (!chain)
        return HOOK_NO_MEM;
    hook_t *hook = &chain->hook;
    hook->func_addr = (uint64_t)func;
    hook->origin_addr = relo_func(hook->func_addr);
    hook->replace_addr = (uint64_t)replace;
    hook->relo_addr = (uint64_t)hook->relo_insts;
    *backup = (void *)hook->relo_addr;
    logkv("Hook func: %llx, origin: %llx, replace: %llx, relocate: %llx, chain: %llx\n", hook->func_addr,
          hook->origin_addr, hook->replace_addr, hook->relo_addr, chain);
    hook_err_t err = hook_prepare(hook);
    if (err)
        goto out;
    hook_install(hook);
    logkv("Hook func: %llx succsseed\n", hook->func_addr);
    return HOOK_NO_ERR;
out:
    hook_mem_free(chain);
    logkv("Hook func: %llx failed, err: %d\n", hook->func_addr, err);
    return err;
}

void unhook(void *func)
{
    uint64_t origin = relo_func((uint64_t)func);
    hook_chain_t *chain = hook_get_chain_from_origin(origin);
    if (!chain)
        return;
    hook_uninstall(&chain->hook);
    hook_mem_free(chain);
    logkv("Unhook func: %llx\n", func);
}

hook_err_t hook_chain_prepare(hook_chain_t *chain, int32_t argno)
{
    hook_t *hook = &chain->hook;
    hook_err_t err = hook_prepare(hook);
    if (err)
        return err;

    uint64_t transit, transit_end;
    switch (argno) {
    case 0:
        transit = (uint64_t)_transit0;
        transit_end = (uint64_t)_transit0_end;
        break;
    case 1:
        transit = (uint64_t)_transit1;
        transit_end = (uint64_t)_transit1_end;
        break;
    case 2:
        transit = (uint64_t)_transit2;
        transit_end = (uint64_t)_transit2_end;
        break;
    case 3:
        transit = (uint64_t)_transit3;
        transit_end = (uint64_t)_transit3_end;
        break;
    case 4:
        transit = (uint64_t)_transit4;
        transit_end = (uint64_t)_transit4_end;
        break;
    case 5:
    case 6:
    case 7:
    case 8:
        transit = (uint64_t)_transit8;
        transit_end = (uint64_t)_transit8_end;
        break;
    default:
        transit = (uint64_t)_transit12;
        transit_end = (uint64_t)_transit12_end;
        break;
    }

    int32_t transit_num = (transit_end - transit) / 4;
    if (transit_num >= TRANSIT_INST_NUM)
        return HOOK_TRANSIT_NO_MEM;

    chain->transit[0] = ARM64_NOP;
    for (int i = 0; i < transit_num; i++) {
        chain->transit[i + 1] = ((uint32_t *)transit)[i];
    }
    return HOOK_NO_ERR;
}

hook_err_t hook_chain_add(hook_chain_t *chain, void *before, void *after, void *udata)
{
    for (int i = 0; i < HOOK_CHAIN_NUM; i++) {
        if (!chain->befores[i] && !chain->afters[i]) {
            chain->udata[i] = udata;
            chain->befores[i] = before;
            chain->afters[i] = after;
            logkv("Wrap chain add: %llx, %llx, %llx successed\n", chain->hook.func_addr, before, after);
            return HOOK_NO_ERR;
        }
    }
    logkv("Wrap chain add: %llx, %llx, %llx filed\n", chain->hook.func_addr, before, after);
    return HOOK_CHAIN_FULL;
}

void hook_chain_remove(hook_chain_t *chain, void *before, void *after)
{
    for (int i = 0; i < HOOK_CHAIN_NUM; i++) {
        if ((before && chain->befores[i] == before) || (after && chain->afters[i] == after)) {
            chain->udata[i] = 0;
            chain->befores[i] = 0;
            chain->afters[i] = 0;
            break;
        }
    }
    logkv("Wrap chain remove: %llx, %llx, %llx\n", chain->hook.func_addr, before, after);
}

// todo: lock
hook_err_t hook_wrap(void *func, int32_t argno, void *before, void *after, void *udata, void **backup)
{
    if (!func)
        return HOOK_INPUT_NULL;
    uint64_t faddr = (uint64_t)func;
    uint64_t origin = relo_func(faddr);
    hook_chain_t *chain = hook_get_chain_from_origin(origin);
    if (chain)
        return hook_chain_add(chain, before, after, udata);
    chain = hook_mem_alloc();
    if (!chain)
        return HOOK_NO_MEM;
    hook_t *hook = &chain->hook;
    hook->func_addr = faddr;
    hook->origin_addr = origin;
    hook->replace_addr = (uint64_t)chain->transit;
    hook->relo_addr = (uint64_t)hook->relo_insts;
    if (backup)
        *(uint64_t *)backup = chain->hook.relo_addr;
    logkv("Wrap func: %llx, origin: %llx, replace: %llx, relocate: %llx, chain: %llx\n", hook->func_addr,
          hook->origin_addr, hook->replace_addr, hook->relo_addr, chain);
    hook_err_t err = hook_chain_prepare(chain, argno);
    if (err)
        goto err;
    err = hook_chain_add(chain, before, after, udata);
    if (err)
        goto err;
    hook_chain_install(chain);
    logkv("Wrap func: %llx succsseed\n", hook->func_addr);
    return HOOK_NO_ERR;
err:
    hook_mem_free(chain);
    logkv("Wrap func: %llx failed, err: %d\n", hook->func_addr, err);
    return err;
}

void hook_unwrap(void *func, void *before, void *after)
{
    uint64_t faddr = (uint64_t)func;
    uint64_t origin = relo_func(faddr);
    hook_chain_t *chain = hook_get_chain_from_origin(origin);
    if (!chain)
        return;
    hook_chain_remove(chain, before, after);
    for (int i = 0; i < HOOK_CHAIN_NUM; i++) {
        if (chain->befores[i] || chain->afters[i])
            return;
    }
    hook_chain_uninstall(chain);
    hook_mem_free(chain);
    logkv("Unwrap func: %llx\n", func);
}

```

`kernel/base/map.c`:

```c
#include "setup.h"

typedef unsigned long phys_addr_t;
typedef unsigned long (*kallsyms_f)(const char *name);
typedef int (*memblock_reserve_f)(phys_addr_t base, phys_addr_t size);
typedef void *(*memblock_alloc_try_nid_f)(phys_addr_t size, phys_addr_t align, phys_addr_t min_addr,
                                          phys_addr_t max_addr, int nid);
typedef void (*printk_f)(const char *fmt, ...);
typedef void (*paging_init_f)(void);

map_preset_t map_preset __section(.map.data) __aligned(MAP_ALIGN) = {
#ifdef MAP_DEBUG
    .str_fmt_px = "KP:%2d - 0x%llx\n",
// .str_fmt_px = "KP:%2d - 0x%px\n",
#endif
};

uint64_t __section(.map.text) __noinline __aligned(MAP_ALIGN) get_myva()
{
    uint64_t this_va;
    asm volatile("adr %0, ." : "=r"(this_va));
    return this_va & ~((uint64_t)MAP_ALIGN - 1);
}

map_preset_t *__noinline get_preset()
{
    uint64_t va = get_myva() - sizeof(map_preset_t);
    return (map_preset_t *)(va & ~((uint64_t)MAP_ALIGN - 1));
}

static inline uint64_t get_kva()
{
    map_preset_t *preset = get_preset();
    uint64_t kernel_va = (uint64_t)preset - preset->map_offset;
    return kernel_va;
}

static inline uint64_t phys_to_virt(map_preset_t *preset, uint64_t phys)
{
    uint64_t page_offset = preset->page_offset;
    uint64_t virt = preset->kimage_voffset_relo ? (phys - preset->memstart_addr_relo) | page_offset :
                                                  phys - preset->memstart_addr_relo + page_offset;
    return virt;
}

static inline uint64_t phys_to_kimg(map_preset_t *preset, uint64_t phys)
{
    return phys + preset->kimage_voffset_relo;
}

static uint64_t __noinline pa_to_va(map_preset_t *preset, uint64_t phys, uint32_t is_kimg)
{
    if (preset->kimage_voffset_relo && is_kimg) {
        return phys_to_kimg(preset, phys);
    }
    return phys_to_virt(preset, phys);
}

static inline void flush_tlb_all()
{
    asm volatile("dsb ishst" : : : "memory");
    asm volatile("tlbi vmalle1is\n"
                 "dsb ish\n"
                 "tlbi vmalle1is\n");
    asm volatile("dsb ish" : : : "memory");
    asm volatile("isb" : : : "memory");
}

static inline void flush_icache_all(void)
{
    asm volatile("dsb ish" : : : "memory");
    asm volatile("ic ialluis");
    asm volatile("dsb ish" : : : "memory");
    asm volatile("isb" : : : "memory");
}

// todo: 52-bits pa
static uint64_t __noinline get_entry(uint64_t va, map_preset_t *preset, uint64_t is_kimg)
{
    // #ifdef MAP_DEBUG
    //     printk_f printk = (printk_f)(preset->printk_relo);
    // #define map_debug(idx, val) printk(preset->str_fmt_px, idx, val)
    //     map_debug(50, va);
    // #endif

    uint64_t page_shift = preset->page_shift;
    uint64_t va_bits = preset->va1_bits;
    uint64_t page_level = (va_bits - 4) / (page_shift - 3);
    uint64_t pxd_bits = page_shift - 3;
    uint64_t pxd_ptrs = 1u << pxd_bits;
    uint64_t ttbr1_el1;
    asm volatile("mrs %0, ttbr1_el1" : "=r"(ttbr1_el1));
    uint64_t pxd_pa = ttbr1_el1 & ~0xfff;
    uint64_t pxd_va = pa_to_va(preset, pxd_pa, is_kimg);
    uint64_t pxd_entry_va = 0;
    uint64_t block_flag = 0;

    for (int64_t lv = 4 - page_level; lv < 4; lv++) {
        uint64_t pxd_shift = (page_shift - 3) * (4 - lv) + 3;
        uint64_t pxd_index = (va >> pxd_shift) & (pxd_ptrs - 1);
        pxd_entry_va = pxd_va + pxd_index * 8;
        uint64_t pxd_desc = *((uint64_t *)pxd_entry_va);

        if ((pxd_desc & 0b11) == 0b11) { // table
            pxd_pa = pxd_desc & (((1ul << (48 - page_shift)) - 1) << page_shift);
        } else if ((pxd_desc & 0b11) == 0b01) { // block
            // 4k page: lv1, lv2. 16k and 64k page: only lv2.
            uint64_t block_bits = (3 - lv) * pxd_bits + page_shift;
            pxd_pa = pxd_desc & (((1ul << (48 - block_bits)) - 1) << block_bits);
            block_flag = 1;
        } else { // invalid
            return (uint64_t)0;
        }
        pxd_va = pa_to_va(preset, pxd_pa, is_kimg);
        if (block_flag) {
            break;
        }
    }
    return pxd_entry_va;
}

static map_preset_t *__noinline mem_proc()
{
    map_preset_t *preset = get_preset();
    uint64_t kernel_va = get_kva();
    preset->kernel_va = kernel_va;
    preset->paging_init_relo += kernel_va;
    preset->memblock_reserve_relo += kernel_va;
    preset->memblock_alloc_try_nid_relo += kernel_va;
    if (preset->vabits_actual_relo) {
        preset->vabits_actual_relo = *(uint64_t *)(kernel_va + preset->vabits_actual_relo);
    }
    if (preset->memstart_addr_relo) {
        preset->memstart_addr_relo = *(int64_t *)(kernel_va + preset->memstart_addr_relo);
    }
    if (preset->kimage_voffset_relo) {
        preset->kimage_voffset_relo = *(uint64_t *)(kernel_va + preset->kimage_voffset_relo);
    }
#ifdef MAP_DEBUG
    preset->kallsyms_lookup_name_relo += kernel_va;
    preset->printk_relo += kernel_va;
#endif

    uint64_t tcr_el1;
    asm volatile("mrs %0, tcr_el1" : "=r"(tcr_el1));
    uint64_t t1sz = tcr_el1 << 42 >> 58; // bits(tcr_el1, 21, 16)
    uint64_t va1_bits = 64 - t1sz;
    preset->va1_bits = va1_bits;
    uint64_t tg1 = tcr_el1 << 32 >> 62; // bits(tcr_el1, 31, 30)
    // uint64_t shift_map[] = { 12, 14, 12, 16 };   // Can't use
    // uint64_t page_shift = shift_map[tg1];
    uint64_t page_shift = 12;
    if (tg1 == 1)
        page_shift = 14;
    if (tg1 == 3)
        page_shift = 16;
    preset->page_shift = page_shift;
    preset->page_offset = preset->vabits_actual_relo ? -(1ul << va1_bits) : (0xffffffffffffffff << (va1_bits - 1));
    return preset;
}

// void __noinline _start_kernel()
// {
// }

void __noinline _paging_init()
{
    map_preset_t *preset = mem_proc();

#ifdef MAP_DEBUG
    kallsyms_f kallsyms_lookup_name = (kallsyms_f)(preset->kallsyms_lookup_name_relo);
    printk_f printk = (printk_f)(preset->printk_relo);
#define map_debug(idx, val) printk(preset->str_fmt_px, idx, val)
    map_debug(0, kallsyms_lookup_name);
    map_debug(1, preset->kernel_va);
    map_debug(2, preset->tmp0);
#endif

    // todo: May cause memory wastage
    ((memblock_reserve_f)preset->memblock_reserve_relo)(preset->start_offset + preset->kernel_pa, preset->start_size);

    // paging_init
    uint64_t paging_init_va = preset->paging_init_relo;
    uint64_t paging_init_entry = get_entry(paging_init_va, preset, 1);
    uint64_t paging_init_prot_ori = *(uint64_t *)paging_init_entry;
    *(uint64_t *)paging_init_entry = (paging_init_prot_ori | 0x0008000000000000) & 0xFFFFFFFFFFFFFF7F;
    flush_tlb_all();
    *(uint32_t *)(paging_init_va) = preset->paging_init_backup;
    flush_icache_all();
    *(uint64_t *)paging_init_entry = paging_init_prot_ori;
    flush_tlb_all();
    ((paging_init_f)(paging_init_va))();

    // start
    uint64_t old_start = phys_to_virt(preset, preset->start_offset + preset->kernel_pa);
    phys_addr_t page_size = 1 << preset->page_shift;
    phys_addr_t start_size = (preset->start_size + page_size - 1) & ~(page_size - 1);
    phys_addr_t alloc_size = start_size + preset->alloc_size;

    uint64_t start =
        (uint64_t)((memblock_alloc_try_nid_f)preset->memblock_alloc_try_nid_relo)(alloc_size, page_size, 0, 0, -1);
    if (!(start & 0xF000000000000000)) {
        start = phys_to_virt(preset, start);
    }
    for (int32_t i = 0; i < preset->start_size; i += 4) {
        *(uint32_t *)(start + i) = *(uint32_t *)(old_start + i);
    }
    flush_icache_all();
    uint64_t start_entry = get_entry(start, preset, 0);
    *(uint64_t *)start_entry &= 0xFFDFFFFFFFFFFFFF;
    flush_tlb_all();
    ((start_f)start)(preset->kernel_va);
}

```

`kernel/base/predata.c`:

```c
#include <predata.h>
#include <common.h>
#include <log.h>

#include "start.h"

static char superkey[SUPER_KEY_LEN] = { '\0' };
static int32_t superkey_len = 0;

int superkey_auth(const char *key, int32_t len)
{
    if (!key || len <= 0 || superkey_len != len)
        return -1;
    for (int i = 0; i < len; i++) {
        if (superkey[i] != key[i])
            return -1;
    }
    return 0;
}

int predata_init()
{
    for (int32_t i = 0; i < SUPER_KEY_LEN; i++) {
        char c = start_preset.superkey[i];
        if (!c) {
            superkey_len = i;
            break;
        }
        superkey[i] = c;
    }
    logki("Preset super key: %s\n", superkey);
    return 0;
}
```

`kernel/base/preset.h`:

```h
#ifndef _KP_PRESET_H_
#define _KP_PRESET_H_

#ifndef __ASSEMBLY__
#include <stdint.h>
#endif

#define MAGIC_LEN 0x8
#define KP_HEADER_SIZE 0x40
#define SUPER_KEY_LEN 0x20
#define HDR_BACKUP_SIZE 0x8
#define COMPILE_TIME_LEN 0x18
#define MAP_MAX_SIZE 0xa00
#define HOOK_ALLOC_SIZE (256 * 1024)
#define MAP_ALIGN 16

#define VERSION(major, minor, patch) (((major) << 16) + ((minor) << 8) + (patch))

#ifndef __ASSEMBLY__
typedef struct version_t
{
    uint8_t _;
    uint8_t patch;
    uint8_t minor;
    uint8_t major;
} version_t;
#endif

#ifndef __ASSEMBLY__
typedef struct _setup_header_t // 64-bytes
{
    char magic[MAGIC_LEN];
    version_t kp_version;
    version_t kernel_version;
    char compile_time[COMPILE_TIME_LEN];
    char _reserved[];
} setup_header_t;
#else
#define header_magic_offset 0
#define header_kp_version_offset (MAGIC_LEN)
#define header_kernel_version_offset (header_kp_version_offset + 4)
#define header_compile_time_offset (header_kernel_version_offset + 4)
#endif

#ifndef __ASSEMBLY__
typedef struct _setup_preset_t
{
    int64_t kernel_size;
    int64_t page_shift;
    int64_t kp_offset;
    int64_t start_offset;
    int64_t map_offset; // must be divisibled by MAP_ALIGN
    int64_t map_max_size;

    int64_t kallsyms_lookup_name_offset;
    int64_t paging_init_offset;
    int64_t printk_offset;
    int64_t memblock_reserve_offset;
    int64_t memblock_alloc_try_nid_offset;
    int64_t vabits_actual_offset;
    int64_t memstart_addr_offset;
    int64_t kimage_voffset_offset;

    uint8_t header_backup[HDR_BACKUP_SIZE];
    uint8_t superkey[SUPER_KEY_LEN];
} setup_preset_t;
#else
#define setup_kernel_size_offset 0
#define setup_page_shift_offset 8
#define setup_kp_offset_offset 0x10
#define setup_start_offset_offset 0x18
#define setup_map_offset_offset 0x20
#define setup_map_max_size_offset 0x28
#define setup_kallsyms_lookup_name_offset_offset 0x30
#define setup_paging_init_offset_offset 0x38
#define setup_printk_offset_offset 0x40
#define setup_memblock_reserve_offset_offset 0x48
#define setup_memblock_alloc_try_nid_offset_offset 0x50
#define setup_vabits_actual_offset_offset 0x58
#define setup_memstart_addr_offset_offset 0x60
#define setup_kimage_voffset_offset_offset 0x68
#define setup_header_backup_offset 0x70
#define setup_superkey_offset (setup_header_backup_offset + HDR_BACKUP_SIZE)
#endif

#ifndef __ASSEMBLY__
typedef struct
{
} setup_config_t;
#endif

#endif // _KP_PRESET_H_
```

`kernel/base/setup.c`:

```c
#include "setup.h"
#include "../version"

setup_header_t header __section(.setup.header) = { .magic = "KP1158",
                                                   .kp_version.major = MAJOR,
                                                   .kp_version.minor = MINOR,
                                                   .kp_version.patch = PATCH,
                                                   .compile_time = __TIME__ " " __DATE__ };

setup_preset_t setup_preset __section(.setup.preset) = { 0 };

struct
{
    uint8_t fp[STACK_SIZE];
    uint8_t sp[0];
} stack __section(.setup.data) __aligned(16);

```

`kernel/base/setup.h`:

```h
#ifndef _KP_SETUP_H_
#define _KP_SETUP_H_

#include "./preset.h"

#define STACK_SIZE 0x800

#ifndef __ASSEMBLY__

#define offsetof(TYPE, MEMBER) ((size_t) & ((TYPE *)0)->MEMBER)

#define __section(s) __attribute__((section(#s)))
#define __noinline __attribute__((__noinline__))
#define __aligned(x) __attribute__((aligned(x)))

#endif

#ifndef __ASSEMBLY__
typedef struct
{
    // preset
    uint32_t paging_init_backup;
    uint32_t __;
    int64_t map_offset;
    int64_t start_offset;
    int64_t start_size;
    int64_t alloc_size;
    uint64_t kernel_pa;
    uint64_t paging_init_relo;
    uint64_t memblock_reserve_relo;
    uint64_t memblock_alloc_try_nid_relo;
    uint64_t vabits_actual_relo;
    int64_t memstart_addr_relo;
    uint64_t kimage_voffset_relo;
#ifdef MAP_DEBUG
    uint64_t printk_relo;
    uint64_t kallsyms_lookup_name_relo;
    uint64_t tmp0;
    uint64_t tmp1;
    char str_fmt_px[24];
#endif
    // local
    int64_t va1_bits;
    int64_t page_shift;
    uint64_t kernel_va;
    uint64_t page_offset;
} map_preset_t;
#else
#define map_paging_init_backup_offset 0
#define map_map_offset_offset 0x8
#define map_start_offset_offset 0x10
#define map_start_size_offset 0x18
#define map_alloc_size_offset 0x20
#define map_kernel_pa_offset 0x28
#define map_paging_init_relo_offset 0x30
#define map_memblock_reserve_relo_offset 0x38
#define map_memblock_alloc_try_nid_relo_offset 0x40
#define map_vabits_actual_relo_offset 0x48
#define map_memstart_addr_relo_offset 0x50
#define map_kimage_voffset_relo_offset 0x58
#ifdef MAP_DEBUG
#define map_printk_relo_offset 0x60
#define map_kallsyms_lookup_name_relo_offset 0x68
#define map_tmp0_offset 0x70
#define map_tmp1_offset 0x78
#define map_str_fmt_px_offset 0x80
#endif // MAP_DEBUG
#endif

#ifndef __ASSEMBLY__
typedef int (*start_f)(uint64_t kva);
extern void _start_kernel();
extern void _paging_init();
extern void _link_base();
extern void _link_end();
extern void _setup_start();
extern void _setup_end();
extern void _map_start();
extern void _map_text();
extern void _map_data();
extern void _map_end();
extern void _kp_end();
#endif // __ASSEMBLY__

#endif // _KP_SETUP_H_
```

`kernel/base/setup1.S`:

```S

#define __ASSEMBLY__
#include "./setup.h"
#include "./start.h"

.text
.align 2
.type memcpy8, %function
memcpy8:
    cmp x2, 0
    ble .l8end
.l8loop:
    ldrb w9, [x1], 1
    strb w9, [x0], 1
    subs x2, x2, 1
    cbnz x2, .l8loop
.l8end:
    ret

.text
.align 2
.type rmemcpy32, %function
rmemcpy32:
    subs x2, x2, #0x4
    b.lt .r32end
.r32loop:
    ldr w9, [x1, x2]
    str w9, [x0, x2]
    subs x2, x2, #0x4
    b.ge .r32loop
.r32end:
    ret


.text
.align 2
.type start_prepare, %function
start_prepare:
    stp x29, x30, [sp, -16]!
    stp x19, x20, [sp, -16]!
    stp x21, x22, [sp, -16]!
    // kernel_pa
    mov x19, x0
    // map_preset
    adrp x9, map_preset
    add x9, x9, :lo12:map_preset
    // setup_preset
    adrp x10, setup_preset
    add x10, x10, :lo12:setup_preset
    // start_preset
    adrp x11, start_preset
    add x11, x11, :lo12:start_preset
    // header
    adrp x12, header
    add x12, x12, :lo12:header
    // start_preset.kernel_version = header.kernel_version;
    ldr w13, [x12, #header_kernel_version_offset]
    str w13, [x11, #start_kernel_version_offset]
    // start_preset.kp_version = header.kp_version;
    ldr w13, [x12, #header_kp_version_offset]
    str w13, [x11, #start_kp_version_offset]
    // start_preset.kallsyms_lookup_name_offset = setup_preset.set.kallsyms_lookup_name_offset;
    ldr x13, [x10, #setup_kallsyms_lookup_name_offset_offset]
    str x13, [x11, #start_kallsyms_lookup_name_offset_offset]
    // start_preset.kernel_size = setup_preset.set.kernel_size;
    ldr x13, [x10, #setup_kernel_size_offset]
    str x13, [x11, #start_kernel_size_offset]
    // start_preset.start_offset = setup_preset.start_offset;
    ldr x13, [x10, #setup_start_offset_offset]
    str x13, [x11, #start_start_offset_offset]
    mov x21, x13
    // start_preset.kernel_pa = kernel_pa;
    str x19, [x11, #start_kernel_pa_offset]
    // start_preset.map_offset = setup_preset.map_offset
    ldr x13, [x10, #setup_map_offset_offset]
    str x13, [x11, #start_map_offset_offset]
    mov x20, x13

    // memcpy(start_preset.superkey, setup_preset.superkey, SUPER_KEY_LEN);
    add x0, x11, #start_superkey_offset;
    add x1, x10, #setup_superkey_offset
    mov x2, #SUPER_KEY_LEN
    bl memcpy8

    // memcpy(start_preset.compile_time, header.compile_time, COMPILE_TIME_LEN);
    add x0, x11, #start_compile_time_offset;
    add x1, x12, #header_compile_time_offset
    mov x2, #COMPILE_TIME_LEN
    bl memcpy8

    // backup map area
    // memcpy((uint64_t)start_preset.map_backup, kernel_pa + setup_preset.map_offset, (uint64_t)_map_end - (uint64_t)_map_start)
    adrp x13, _map_end
    add x13, x13, :lo12:_map_end
    adrp x14, _map_start
    add x14, x14, :lo12:_map_start
    sub x2, x13, x14
    // start_preset.map_backup_len = (uint64_t)_map_end - (uint64_t)_map_start
    str x2, [x11, #start_map_backup_len_offset]
    add x0, x11, #start_map_backup_offset
    add x1, x19, x20
    bl memcpy8

    // finally relocate start
    // memcpy(kernel_pa + start_offset, (uint64_t)_kp_start, (int64_t)(_kp_end - _kp_start))
    add x0, x19, x21
    adrp x1, _kp_start
    add x1, x1, :lo12:_kp_start 
    adrp x2, _kp_end
    add x2, x2, :lo12:_kp_end 
    sub x2, x2, x1
    bl rmemcpy32

    // Restore
    ldp x21, x22, [sp], 16 
    ldp x19, x20, [sp], 16 
    ldp x29, x30, [sp], 16
    ret

.text
.align 2
.type map_prepare, %function
map_prepare:
    stp x29, x30, [sp, -16]!
    stp x19, x20, [sp, -16]!
    mov x19, x0
    // map_preset
    adrp x9, map_preset
    add x9, x9, :lo12:map_preset
    // setup_preset
    adrp x10, setup_preset
    add x10, x10, :lo12:setup_preset
    // map_preset.kernel_pa = kernel_pa;
    str x19, [x9, #map_kernel_pa_offset]
    // map_preset.map_offset = setup_preset.map_offset;
    ldr x11, [x10, #setup_map_offset_offset]
    str x11, [x9, #map_map_offset_offset]
    mov x14, x11
    // map_preset.paging_init_relo = setup_preset.paging_init_offset;
    ldr x11, [x10, #setup_paging_init_offset_offset]
    str x11, [x9, #map_paging_init_relo_offset]
    mov x15, x11
    // map_preset.memblock_reserve_relo = setup_preset.memblock_reserve_offset;
    ldr x11, [x10, #setup_memblock_reserve_offset_offset]
    str x11, [x9, #map_memblock_reserve_relo_offset]
    // map_preset.memblock_alloc_try_nid_relo = setup_preset.memblock_alloc_try_nid_offset;
    ldr x11, [x10, #setup_memblock_alloc_try_nid_offset_offset]
    str x11, [x9, #map_memblock_alloc_try_nid_relo_offset]
    // map_preset.vabits_actual_relo = setup_preset.vabits_actual_offset 
    ldr x11, [x10, #setup_vabits_actual_offset_offset]
    str x11, [x9, #map_vabits_actual_relo_offset]
    // map_preset.memstart_addr_relo = setup_preset.memstart_addr_offset 
    ldr x11, [x10, #setup_memstart_addr_offset_offset]
    str x11, [x9, #map_memstart_addr_relo_offset]
    // map_preset.kimage_voffset_relo = setup_preset.kimage_voffset_offset 
    ldr x11, [x10, #setup_kimage_voffset_offset_offset]
    str x11, [x9, #map_kimage_voffset_relo_offset]
#ifdef MAP_DEBUG
    // map_preset.printk_relo = setup_preset.printk_offset;
    ldr x11, [x10, #setup_printk_offset_offset]
    str x11, [x9, #map_printk_relo_offset]
    // map_preset.kallsyms_lookup_name_relo = setup_preset.kallsyms_lookup_name_offset;
    ldr x11, [x10, #setup_kallsyms_lookup_name_offset_offset]
    str x11, [x9, #map_kallsyms_lookup_name_relo_offset]
#endif

    // set start memory info
    // map_preset.start_offset = setup_preset.start_offset;
    ldr x11, [x10, #setup_start_offset_offset]
    str x11, [x9, #map_start_offset_offset]
    // map_preset.start_size = (int64_t)(_kp_end - _kp_start);
    adrp x11, _kp_end
    add x11, x11, :lo12:_kp_end
    adrp x12, _kp_start
    add x12, x12, :lo12:_kp_start
    sub x11, x11, x12
    str x11, [x9, #map_start_size_offset]
    // map_preset.alloc_size = HOOK_ALLOC_SIZE;
    mov x11, #HOOK_ALLOC_SIZE
    str x11, [x9, #map_alloc_size_offset]

    // backup and hook paging_init
    // uint64_t paging_init_pa = paging_init_offset + kernel_pa;
    add x13, x15, x19
    // map_preset.paging_init_backup = *(uint32_t *)(paging_init_pa);
    ldr w12, [x13]
    str w12, [x9, #map_paging_init_backup_offset]
    // uint64_t replace_offset = (uint64_t)(_paging_init - _map_start) + map_offset;
    adrp x11, _paging_init
    add x11, x11, :lo12:_paging_init
    adrp x12, _map_start
    add x12, x12, :lo12:_map_start
    sub x11, x11, x12
    add x11, x11, x14
    // *(uint32_t *)paging_init_pa = B_REL(paging_init_offset, replace_offset);
    // #define B_REL(src, dst) (0x14000000u | (((dst - src) & 0x0FFFFFFFu) >> 2u))
    sub x15, x11, x15
    ubfx w15, w15, #2, #26
    mov w12, #0x14000000
    orr w15, w15, w12
    str w15, [x13]

    // finally relocate map
    // memcpy(preset.map_offset + kernel_pa, (uint64_t)_map_start, (int64_t)(_map_end - _map_start));
    adrp x2, _map_end
    add x2, x2, :lo12:_map_end
    adrp x1, _map_start
    add x1, x1, :lo12:_map_start
    sub x2, x2, x1
    add x0, x19, x14
    bl memcpy8

    // Restore
    ldp x19, x20, [sp], 16
    ldp x29, x30, [sp], 16
    ret

.text
.align 2
.type setup, %function
setup:
    // Save
    stp x29, x30, [sp, -16]!
    stp x0, x1, [sp, -16]!
    stp x2, x3, [sp, -16]!
    stp x4, x5, [sp, -16]!
    stp x6, x7, [sp, -16]!
    stp x8, x18, [sp, -16]!
    stp x19, x20, [sp, -16]!
    stp x21, x22, [sp, -16]!
    stp x23, x24, [sp, -16]!
    stp x25, x26, [sp, -16]!
    stp x27, x28, [sp, -16]!

    // _link_base
    adrp x9, _link_base
    add x9, x9, :lo12:_link_base
    // setup_preset
    adrp x10, setup_preset
    add x10, x10, :lo12:setup_preset
    mov x20, x10
    // uint64 kernel_pa = (uint64_t)_link_base - setup_preset.kp_offset;
    ldr x11, [x10, #setup_kp_offset_offset]
    sub x12, x9, x11
    mov x19, x12

    mov x0, x19
    bl start_prepare
    mov x0, x19
    bl map_prepare

    // memcpy(kernel_pa, (uint64_t)setup_preset.header_backup, sizeof(setup_preset.header_backup));
    mov x0, x19
    add x1, x20, #setup_header_backup_offset
    mov x2, #HDR_BACKUP_SIZE
    bl memcpy8

    // I-cache = on or off,
    dsb ish
    ic iallu
    isb

    mov x16, x19

    // Restore
    ldp x27, x28, [sp], 16
    ldp x25, x26, [sp], 16
    ldp x23, x24, [sp], 16
    ldp x21, x22, [sp], 16
    ldp x19, x20, [sp], 16
    ldp x8, x18, [sp], 16
    ldp x6, x7, [sp], 16
    ldp x4, x5, [sp], 16
    ldp x2, x3, [sp], 16
    ldp x0, x1, [sp], 16
    ldp x29, x30, [sp], 16

    // Restore sp
    ldp x9, x10, [sp], 16
    mov sp, x9
    // _head
    br x16


.section .entry.text, "ax"
.global setup_entry
.type entry, %function
setup_entry:
    // x0 = physical address to the FDT blob.
    // Preserve the arguments passed by the bootloader in x0 .. x3
    mov x9, sp
    adrp x11, stack
    add x11, x11, :lo12:stack
    add x11, x11, STACK_SIZE
    mov sp, x11
    stp x9, x10, [sp, -16]! 
    b setup

#undef __ASSEMBLY__
```

`kernel/base/start.c`:

```c
#include <common.h>
#include <pgtable.h>
#include <ktypes.h>
#include <kallsyms.h>
#include <log.h>
#include <compiler.h>
#include <init/init.h>
#include <cache.h>

#include "start.h"
#include "hook.h"

start_preset_t start_preset __attribute__((section(".start.data")));

int (*kallsyms_on_each_symbol)(int (*fn)(void *, const char *, struct module *, unsigned long), void *data) = 0;
unsigned long (*kallsyms_lookup_name)(const char *name) = 0;
int (*kallsyms_lookup_size_offset)(unsigned long addr, unsigned long *symbolsize, unsigned long *offset) = 0;
const char *(*kallsyms_lookup)(unsigned long addr, unsigned long *symbolsize, unsigned long *offset, char **modname,
                               char *namebuf) = 0;
int (*sprint_symbol)(char *buffer, unsigned long address) = 0;
int (*sprint_symbol_no_offset)(char *buffer, unsigned long address) = 0;
int (*sprint_backtrace)(char *buffer, unsigned long address) = 0;

int (*lookup_symbol_name)(unsigned long addr, char *symname) = 0;
int (*lookup_symbol_attrs)(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname,
                           char *name) = 0;

void (*printk)(const char *fmt, ...) = 0;

uint32_t kver = 0;
uint32_t kpver = 0;
endian_t endian = little;

uint64_t kernel_va = 0;
uint64_t kernel_pa = 0;
int64_t kernel_size = 0;
uint64_t vabits_actual = 0;
int64_t memstart_addr = 0;
uint64_t kimage_voffset = 0;
uint64_t page_offset = 0;
int64_t page_shift = 0;
int64_t page_size = 0;
int64_t va_bits = 0;
// int64_t pa_bits = 0;

uint64_t *get_pte(uint64_t va)
{
    uint64_t page_level = (va_bits - 4) / (page_shift - 3);
    uint64_t pxd_bits = page_shift - 3;
    uint64_t pxd_ptrs = 1u << pxd_bits;
    uint64_t ttbr1_el1;
    asm volatile("mrs %0, ttbr1_el1" : "=r"(ttbr1_el1));
    uint64_t pxd_pa = ttbr1_el1 & ~0xfff;
    uint64_t pxd_va = phys_to_virt(pxd_pa);
    uint64_t pxd_entry_va = 0;
    uint64_t block_lv = 0;

    for (int64_t lv = 4 - page_level; lv < 4; lv++) {
        uint64_t pxd_shift = (page_shift - 3) * (4 - lv) + 3;
        uint64_t pxd_index = (va >> pxd_shift) & (pxd_ptrs - 1);
        pxd_entry_va = pxd_va + pxd_index * 8;
        if (!pxd_entry_va)
            return 0;
        uint64_t pxd_desc = *((uint64_t *)pxd_entry_va);
        if ((pxd_desc & 0b11) == 0b11) { // table
            pxd_pa = pxd_desc & (((1ul << (48 - page_shift)) - 1) << page_shift);
        } else if ((pxd_desc & 0b11) == 0b01) { // block
            // 4k page: lv1, lv2. 16k and 64k page: only lv2.
            uint64_t block_bits = (3 - lv) * pxd_bits + page_shift;
            pxd_pa = pxd_desc & (((1ul << (48 - block_bits)) - 1) << block_bits);
            block_lv = lv;
        } else { // invalid
            return 0;
        }
        pxd_va = phys_to_virt(pxd_pa);
        // todo: It works! ?
        dsb(ish);
        if (block_lv)
            break;
    }

#if 1
    uint64_t left_bit = page_shift + (block_lv ? (3 - block_lv) * pxd_bits : 0);
    uint64_t tpa = pxd_pa + (va & ((1u << left_bit) - 1));
    uint64_t tlva = phys_to_virt(tpa);
    uint64_t tkimg = phys_to_kimg(tpa);
    if (tlva != va && tkimg != va) {
        logke("Page table error: %llx, %llx, %llx\n", va, tlva, tkimg);
        return 0;
    }
#endif

    return (uint64_t *)pxd_entry_va;
}

static int prot_myself()
{
    uint64_t *kpte = get_pte(kernel_va);
    bool rdonly = (*kpte & PTE_RDONLY) == PTE_RDONLY;
    bool dbm = (*kpte & PTE_DBM) == PTE_DBM;

    // text, rodata
    uint64_t text_start = (uint64_t)_kp_text_start;
    uint64_t text_end = (uint64_t)_kp_text_end;
    uint64_t align_text_end = align_ceil(text_end, page_size);
    logkd("Text range: %llx, %llx\n", text_start, text_end);

    for (uint64_t i = text_start; i < align_text_end; i += page_size) {
        uint64_t *pte = get_pte(i);
        if (!pte)
            return -1;
        *pte |= PTE_SHARED;
        *pte = *pte & ~PTE_PXN & ~PTE_DBM & ~PTE_RDONLY;
        if (rdonly)
            *pte |= PTE_RDONLY;
        if (dbm)
            *pte |= PTE_DBM;
    }
    flush_tlb_kernel_range(text_start, align_text_end);

    // data, bss
    uint64_t data_start = (uint64_t)_kp_data_start;
    uint64_t data_end = (uint64_t)_kp_data_end;
    uint64_t align_data_end = align_ceil(data_end, page_size);
    logkd("Data range: %llx, %llx\n", data_start, data_end);

    for (uint64_t i = data_start; i < align_data_end; i += page_size) {
        uint64_t *pte = get_pte(i);
        if (!pte)
            return -2;
        *pte = (*pte | PTE_DBM | PTE_SHARED) & ~PTE_RDONLY;
    }
    flush_tlb_kernel_range(data_start, align_data_end);

    return 0;
}

static int restore_map()
{
    uint64_t start = kernel_va + start_preset.map_offset;
    uint64_t end = start + start_preset.map_backup_len;
    logkd("Restore range: %llx, %llx\n", start, end);

    for (uint64_t i = start; i < align_ceil(end, page_size); i += page_size) {
        uint64_t *pte = get_pte(i);
        if (!pte)
            return -3;
        uint64_t orig = *pte;
        *pte = (orig | PTE_DBM) & ~PTE_RDONLY;
        flush_tlb_kernel_page(i);
        for (uint64_t j = i; j >= start && j < end && j < i + page_size; j += 8) {
            *(uint64_t *)j = *(uint64_t *)(start_preset.map_backup + (j - start));
        }
        *pte = orig;
        flush_tlb_kernel_page(i);
    }
    flush_icache_all();
    return 0;
}

static int pgtable_init()
{
    uint64_t addr = kallsyms_lookup_name("memstart_addr");
    if (addr)
        memstart_addr = *(int64_t *)addr;
    addr = kallsyms_lookup_name("kimage_voffset");
    if (addr)
        kimage_voffset = *(uint64_t *)addr;
    addr = kallsyms_lookup_name("vabits_actual");
    if (addr)
        vabits_actual = *(uint64_t *)addr;

    uint64_t tcr_el1;
    asm("mrs %0, tcr_el1" : "=r"(tcr_el1));
    uint64_t t1sz = bits(tcr_el1, 21, 16);
    va_bits = 64 - t1sz;
    uint64_t tg1 = bits(tcr_el1, 31, 30);
    page_shift = 12;
    if (tg1 == 1)
        page_shift = 14;
    if (tg1 == 3)
        page_shift = 16;
    page_size = 1 << page_shift;
    page_offset = vabits_actual ? -(1ul << va_bits) : (0xffffffffffffffff << (va_bits - 1));
    return 0;
}

static int hook_init()
{
    // rwx for hook
    for (uint32_t i = 0; i < HOOK_ALLOC_SIZE; i += (1 << page_shift)) {
        uint64_t va = (uint64_t)_kp_end + i;
        uint64_t *pte = get_pte(va);
        if (!pte)
            return -4;
        *pte = (*pte & ~PTE_PXN & ~PTE_RDONLY) | PTE_DBM | PTE_SHARED;
    }
    hook_mem_add((uint64_t)_kp_end, HOOK_ALLOC_SIZE);
    flush_tlb_kernel_range((uint64_t)_kp_end, (uint64_t)_kp_end + HOOK_ALLOC_SIZE);
    logkd("Hook range: %llx, %llx\n", (uint64_t)_kp_end, (uint64_t)_kp_end + HOOK_ALLOC_SIZE);
    return 0;
}

static int start_init(uint64_t kva)
{
    kernel_va = kva;
    kernel_pa = start_preset.kernel_pa;
    kernel_size = start_preset.kernel_size;
    uint64_t kallsym_addr = kva + start_preset.kallsyms_lookup_name_offset;
    kallsyms_lookup_name = (typeof(kallsyms_lookup_name))(kallsym_addr);
    printk = (typeof(printk))kallsyms_lookup_name("printk");

    endian = *(unsigned char *)&(uint16_t){ 1 } ? little : big;
    kver = VERSION(start_preset.kernel_version.major, start_preset.kernel_version.minor,
                   start_preset.kernel_version.patch);
    kpver = VERSION(start_preset.kp_version.major, start_preset.kp_version.minor, start_preset.kp_version.patch);
    logki("Kernel pa: %llx, va: %llx, size: %x\n", kernel_pa, kernel_va, start_preset.kernel_size);
    logki("Version: %x, Compile Time: %s\n", kpver, start_preset.compile_time);

    kallsyms_on_each_symbol = (typeof(kallsyms_on_each_symbol))kallsyms_lookup_name("kallsyms_on_each_symbol");
    kallsyms_lookup_size_offset =
        (typeof(kallsyms_lookup_size_offset))kallsyms_lookup_name("kallsyms_lookup_size_offset");
    kallsyms_lookup = (typeof(kallsyms_lookup))kallsyms_lookup_name("kallsyms_lookup");
    sprint_symbol = (typeof(sprint_symbol))kallsyms_lookup_name("sprint_symbol");
    sprint_symbol_no_offset = (typeof(sprint_symbol_no_offset))kallsyms_lookup_name("sprint_symbol_no_offset");
    sprint_backtrace = (typeof(sprint_backtrace))kallsyms_lookup_name("sprint_backtrace");
    lookup_symbol_name = (typeof(lookup_symbol_name))kallsyms_lookup_name("lookup_symbol_name");
    lookup_symbol_attrs = (typeof(lookup_symbol_attrs))kallsyms_lookup_name("lookup_symbol_attrs");
    return 0;
}

static int nice_zone()
{
    logki("==== KernelPatch Entering Nicezone ====\n");
    return init();
}

int __attribute__((section(".start.text"))) __noinline start(uint64_t kva)
{
    int err = 0;
    if ((err = start_init(kva)))
        goto out;
    if ((err = pgtable_init()))
        goto out;
    if ((err = prot_myself()))
        goto out;
    if ((err = restore_map()))
        goto out;
    if ((err = predata_init()))
        goto out;
    if ((err = hook_init()))
        goto out;

    if ((err = nice_zone()))
        goto out;
out:
    return 0;
}

```

`kernel/base/start.h`:

```h
#ifndef _KP_START_H_
#define _KP_START_H_

#include "preset.h"

#define bits(n, high, low) (((n) << (63u - (high))) >> (63u - (high) + (low)))
#define align_floor(x, align) ((uint64_t)(x) & ~((uint64_t)(align)-1))
#define align_ceil(x, align) (((uint64_t)(x) + (uint64_t)(align)-1) & ~((uint64_t)(align)-1))

#ifndef __ASSEMBLY__
typedef struct
{
    version_t kernel_version;
    version_t kp_version;
    int64_t kallsyms_lookup_name_offset;
    int64_t kernel_size;
    int64_t start_offset;
    uint64_t kernel_pa;
    int64_t map_offset;
    int64_t map_backup_len;
    char compile_time[COMPILE_TIME_LEN];
    uint8_t superkey[SUPER_KEY_LEN];
    uint8_t map_backup[MAP_MAX_SIZE];
} start_preset_t;
#else
#define start_kernel_version_offset 0
#define start_kp_version_offset 0x4
#define start_kallsyms_lookup_name_offset_offset 0x8
#define start_kernel_size_offset 0x10
#define start_start_offset_offset 0x18
#define start_kernel_pa_offset 0x20
#define start_map_offset_offset 0x28
#define start_map_backup_len_offset 0x30
#define start_compile_time_offset 0x38
#define start_superkey_offset (start_compile_time_offset + COMPILE_TIME_LEN)
#define start_map_backup_offset (start_superkey_offset + SUPER_KEY_LEN)
#endif

#ifndef __ASSEMBLY__

extern start_preset_t start_preset;

int predata_init();

void _kp_start();
void _kp_text_start();
void _kp_text_end();
void _kp_data_start();
void _kp_data_end();
void _kp_end();

#endif

#endif // _KP_START_H_
```

`kernel/include/cache.h`:

```h
#ifndef _KP_CACHE_H_
#define _KP_CACHE_H_

#include <stdint.h>

// todo: arch/arm64/mm/cache.S

static inline void local_flush_icache_all(void)
{
    asm volatile("ic iallu");
    asm volatile("dsb nsh" : : : "memory");
    asm volatile("isb" : : : "memory");
}

static inline void flush_icache_all(void)
{
    asm volatile("dsb ish" : : : "memory");
    asm volatile("ic ialluis");
    asm volatile("dsb ish" : : : "memory");
    asm volatile("isb" : : : "memory");
}

// todo
void flush_dcache_area(uint64_t kaddr, uint64_t size);

#endif
```

`kernel/include/common.h`:

```h
#ifndef _KP_COMMON_H_
#define _KP_COMMON_H_

#include <stdint.h>

#define VERSION(major, minor, patch) (((major) << 16) + ((minor) << 8) + (patch))

typedef enum
{
    little = 0,
    big = 1
} endian_t;

extern uint32_t kver;
extern uint32_t kpver;
extern endian_t endian;

#endif
```

`kernel/include/compiler.h`:

```h
#ifndef _KP_COMPILER_H_
#define _KP_COMPILER_H_

#define __pure __attribute__((pure))
#define __aligned(x) __attribute__((aligned(x)))
#define __printf(a, b) __attribute__((format(printf, a, b)))
#define __scanf(a, b) __attribute__((format(scanf, a, b)))
#define __attribute_const__ __attribute__((__const__))
#define __maybe_unused __attribute__((unused))
#define __always_unused __attribute__((unused))

#define __noreturn __attribute__((__noreturn__))
#define __noinline __attribute__((__noinline__))
#define __always_inline inline __attribute__((__always_inline__))
// #define __section(S) __attribute__((__section__(#S)))
#define __cold
#define __visible
#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
#define __native_word(t) \
    (sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))

#define __user
#define __kernel
#define __safe __attribute__((safe))
// #define __force __attribute__((force))
#define __force
#define __nocast __attribute__((nocast))
#define __iomem
#define __chk_user_ptr(x) (void)0
#define __chk_io_ptr(x) (void)0
#define __builtin_warning(x, y...) (1)
#define __must_hold(x) __attribute__((context(x, 1, 1)))
#define __acquires(x) __attribute__((context(x, 0, 1)))
#define __releases(x) __attribute__((context(x, 1, 0)))
#define __acquire(x) __context__(x, 1)
#define __release(x) __context__(x, -1)
#define __cond_lock(x, c) \
    ((c) ? ({             \
        __acquire(x);     \
        1;                \
    }) :                  \
           0)
#define __percpu
#define __rcu
#define __pmem

#define likely(x) __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#define __weak __attribute__((weak))
#define __packed __attribute__((__packed__))
#define __used __attribute__((__unused__))
#define __maybe_unused __attribute__((unused))

#endif
```

`kernel/include/error.h`:

```h
#ifndef _KP_ERROR_H_
#define _KP_ERROR_H

#define ERR_NO_ERR 0

#define ERR_COMMON -1
#define ERR_DIRTY_EXT -2
#define ERR_NOT_IMPL -3
#define ERR_NO_SUCH_ID -4
#define ERR_CAP_FULL -5
#define ERR_NO_KFUNC -6
#define ERR_NO_KVAR -7
#define ERR_EXIST -8

#endif
```

`kernel/include/hook.h`:

```h
#ifndef _KP_HOOK_H_
#define _KP_HOOK_H_

#include <stdint.h>
#include <stdbool.h>
#include <log.h>

#define HOOK_INTO_BRANCH_FUNC

typedef enum
{
    HOOK_NO_ERR = 0,
    HOOK_INPUT_NULL,
    HOOK_NO_MEM,
    HOOK_BAD_RELO,
    HOOK_TRANSIT_NO_MEM,
    HOOK_CHAIN_FULL,
    HOOK_NOT_HOOK,
} hook_err_t;

#define local_offsetof(TYPE, MEMBER) ((size_t) & ((TYPE *)0)->MEMBER)
#define local_container_of(ptr, type, member) ({ (type *)((char *)(ptr)-local_offsetof(type, member)); })

#define HOOK_MEM_REGION_NUM 4
#define TRAMPOLINE_NUM 4
#define RELOCATE_INST_NUM (TRAMPOLINE_NUM * 7 + 4)
#define HOOK_CHAIN_NUM 4

#define TRANSIT_INST_NUM 64
#define TRANSIT_ALIGN 32
#define ARM64_NOP 0xd503201f

typedef struct
{
    // in
    uint64_t func_addr;
    uint64_t origin_addr;
    uint64_t replace_addr;
    uint64_t relo_addr;
    // out
    bool pac;
    uint32_t origin_insts[TRAMPOLINE_NUM];
    uint32_t tramp_insts_len;
    uint32_t tramp_insts[TRAMPOLINE_NUM];
    uint32_t relo_insts_len;
    uint32_t relo_insts[RELOCATE_INST_NUM];
} hook_t;

struct _hook_chain;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
} hook_fdata0_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
} hook_fdata1_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
    uint64_t arg1;
} hook_fdata2_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
    uint64_t arg1;
    uint64_t arg2;
} hook_fdata3_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
    uint64_t arg1;
    uint64_t arg2;
    uint64_t arg3;
} hook_fdata4_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
    uint64_t arg1;
    uint64_t arg2;
    uint64_t arg3;
    uint64_t arg4;
    uint64_t arg5;
    uint64_t arg6;
    uint64_t arg7;
} hook_fdata8_t;

typedef struct
{
    struct _hook_chain *chain;
    bool early_ret;
    uint64_t ret;
    uint64_t arg0;
    uint64_t arg1;
    uint64_t arg2;
    uint64_t arg3;
    uint64_t arg4;
    uint64_t arg5;
    uint64_t arg6;
    uint64_t arg7;
    uint64_t arg8;
    uint64_t arg9;
    uint64_t arg10;
    uint64_t arg11;
} hook_fdata12_t;

typedef void (*hook_chain0_callback)(hook_fdata0_t *fdata, void *udata);
typedef void (*hook_chain1_callback)(hook_fdata1_t *fdata, void *udata);
typedef void (*hook_chain2_callback)(hook_fdata2_t *fdata, void *udata);
typedef void (*hook_chain3_callback)(hook_fdata3_t *fdata, void *udata);
typedef void (*hook_chain4_callback)(hook_fdata4_t *fdata, void *udata);
typedef void (*hook_chain8_callback)(hook_fdata8_t *fdata, void *udata);
typedef void (*hook_chain12_callback)(hook_fdata12_t *fdata, void *udata);

typedef struct _hook_chain
{
    hook_t hook;
    void *udata[HOOK_CHAIN_NUM];
    void *befores[HOOK_CHAIN_NUM];
    void *afters[HOOK_CHAIN_NUM];
    uint32_t transit[TRANSIT_ALIGN / 4 + TRANSIT_INST_NUM];
} hook_chain_t;

bool hook_mem_add(uint64_t start, int32_t size);
hook_chain_t *hook_mem_alloc();
void hook_mem_free(hook_chain_t *free);
hook_chain_t *hook_get_chain_from_origin(uint64_t origin_addr);

int32_t branch_from_to(uint32_t *tramp_buf, uint64_t src_addr, uint64_t dst_addr);
int32_t branch_relative(uint32_t *buf, uint64_t src_addr, uint64_t dst_addr);
int32_t branch_absolute(uint32_t *buf, uint64_t addr);

#ifdef HOOK_INTO_BRANCH_FUNC
uint64_t relo_func(uint64_t addr);
#else
static inline uint64_t relo_func(uint64_t addr)
{
    return addr;
}
#endif

hook_err_t hook_prepare(hook_t *hook);
void hook_install(hook_t *hook);
void hook_uninstall(hook_t *hook);
hook_err_t hook(void *func, void *replace, void **backup);
void unhook(void *func);

// todo: hook priority
hook_err_t hook_chain_prepare(hook_chain_t *chain, int32_t argno);
static inline void hook_chain_install(hook_chain_t *chain)
{
    hook_install(&chain->hook);
}
static inline void hook_chain_uninstall(hook_chain_t *chain)
{
    hook_uninstall(&chain->hook);
}
hook_err_t hook_chain_add(hook_chain_t *chain, void *before, void *after, void *udata);
void hook_chain_remove(hook_chain_t *chain, void *before, void *after);
hook_err_t hook_wrap(void *func, int32_t argno, void *before, void *after, void *udata, void **backup);
void hook_unwrap(void *func, void *before, void *after);

static inline hook_err_t hook_wrap0(void *func, hook_chain0_callback before, hook_chain0_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 0, before, after, udata, backup);
}

static inline hook_err_t hook_wrap1(void *func, hook_chain1_callback before, hook_chain1_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 1, before, after, udata, backup);
}

static inline hook_err_t hook_wrap2(void *func, hook_chain2_callback before, hook_chain2_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 2, before, after, udata, backup);
}

static inline hook_err_t hook_wrap3(void *func, hook_chain3_callback before, hook_chain3_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 3, before, after, udata, backup);
}

static inline hook_err_t hook_wrap4(void *func, hook_chain4_callback before, hook_chain4_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 4, before, after, udata, backup);
}

static inline hook_err_t hook_wrap8(void *func, hook_chain8_callback before, hook_chain8_callback after, void *udata,
                                    void **backup)
{
    return hook_wrap(func, 8, before, after, udata, backup);
}

static inline hook_err_t hook_wrap12(void *func, hook_chain12_callback before, hook_chain12_callback after, void *udata,
                                     void **backup)
{
    return hook_wrap(func, 12, before, after, udata, backup);
}

static inline void hook_unwrapn(void *func, void *before, void *after)
{
    return hook_unwrap(func, before, after);
}

#endif

```

`kernel/include/kallsyms.h`:

```h
#ifndef _KP_KALLSYMS_H_
#define _KP_KALLSYMS_H_

struct module;

#define KSYM_NAME_LEN 512

extern int (*kallsyms_on_each_symbol)(int (*fn)(void *, const char *, struct module *, unsigned long), void *data);
/* Lookup the address for a symbol. Returns 0 if not found. */
extern unsigned long (*kallsyms_lookup_name)(const char *name);
extern int (*kallsyms_lookup_size_offset)(unsigned long addr, unsigned long *symbolsize, unsigned long *offset);
/* Lookup an address.  modname is set to NULL if it's in the kernel. */
extern const char *(*kallsyms_lookup)(unsigned long addr, unsigned long *symbolsize, unsigned long *offset,
                                      char **modname, char *namebuf);
/* Look up a kernel symbol and return it in a text buffer. */
extern int (*sprint_symbol)(char *buffer, unsigned long address);
extern int (*sprint_symbol_no_offset)(char *buffer, unsigned long address);
extern int (*sprint_backtrace)(char *buffer, unsigned long address);

extern int (*lookup_symbol_name)(unsigned long addr, char *symname);
extern int (*lookup_symbol_attrs)(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname,
                                  char *name);

// extern int sprint_symbol_build_id(char *buffer, unsigned long address);
// extern int sprint_backtrace_build_id(char *buffer, unsigned long address);

#endif
```

`kernel/include/ktypes.h`:

```h
#ifndef _KP_KTYPES_H_
#define _KP_KTYPES_H_

#include <stdint.h>
#include <compiler.h>
#include <stdbool.h>

#define __bitwise
#define __user
#define __must_check
#define __cold
#define asmlinkage

typedef uint64_t u64;
typedef int64_t s64;
typedef uint32_t u32;
typedef int32_t s32;
typedef uint16_t u16;
typedef int16_t s16;
typedef uint8_t u8;
typedef int8_t s8;
typedef uint64_t __u64;
typedef uint32_t __u32;
typedef uint16_t __u16;

typedef __u16 __bitwise __le16;
typedef __u16 __bitwise __be16;
typedef __u32 __bitwise __le32;
typedef __u32 __bitwise __be32;
typedef __u64 __bitwise __le64;
typedef __u64 __bitwise __be64;

typedef __u16 __bitwise __sum16;
typedef __u32 __bitwise __wsum;

#define __aligned_u64 __u64 __attribute__((aligned(8)))
#define __aligned_be64 __be64 __attribute__((aligned(8)))
#define __aligned_le64 __le64 __attribute__((aligned(8)))

typedef unsigned __bitwise __poll_t;

#ifdef __ASSEMBLY__
#define _AC(X, Y) X
#define _AT(T, X) X
#else
#define __AC(X, Y) (X##Y)
#define _AC(X, Y) __AC(X, Y)
#define _AT(T, X) ((T)(X))
#endif

#define _UL(x) (_AC(x, UL))
#define _ULL(x) (_AC(x, ULL))

#define UL(x) (_UL(x))
#define ULL(x) (_ULL(x))

#define _BITUL(x) (_UL(1) << (x))
#define _BITULL(x) (_ULL(1) << (x))

#define BIT(nr) (UL(1) << (nr))
#define BIT_ULL(nr) (ULL(1) << (nr))

#define __FD_SETSIZE 1024

typedef struct
{
    unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} __kernel_fd_set;

/* Type of a signal handler.  */
typedef void (*__kernel_sighandler_t)(int);

/* Type of a SYSV IPC key.  */
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef __kernel_ulong_t __kernel_ino_t;
typedef unsigned int __kernel_mode_t;
typedef int __kernel_pid_t;
typedef int __kernel_ipc_pid_t;
typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;
typedef __kernel_long_t __kernel_suseconds_t;
typedef int __kernel_daddr_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;
typedef struct
{
    int val[2];
} __kernel_fsid_t;
typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;

typedef uint64_t pteval_t;

typedef u64 sector_t;
typedef u64 blkcnt_t;

typedef u32 __kernel_dev_t;

typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef unsigned short umode_t;
typedef u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;

typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
typedef __kernel_loff_t loff_t;
// typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_caddr_t caddr_t;
typedef u64 sector_t;
typedef u64 blkcnt_t;
typedef u64 phys_addr_t;
typedef u64 dma_addr_t;
typedef phys_addr_t resource_size_t;
typedef unsigned long irq_hw_number_t;

typedef unsigned int __bitwise gfp_t;
typedef unsigned int __bitwise slab_flags_t;
typedef unsigned int __bitwise fmode_t;

typedef u32 __kernel_dev_t;

/* Type of a SYSV IPC key.  */
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

typedef struct
{
    uid_t val;
} kuid_t;

typedef struct
{
    gid_t val;
} kgid_t;

typedef struct
{
    int counter;
} atomic_t;

typedef struct
{
    long counter;
} atomic64_t;

struct list_head
{
    struct list_head *next, *prev;
};

struct hlist_head
{
    struct hlist_node *first;
};

struct hlist_node
{
    struct hlist_node *next, **pprev;
};

struct ustat
{
    __kernel_daddr_t f_tfree;
    __kernel_ino_t f_tinode;
    char f_fname[6];
    char f_fpack[6];
};

struct callback_head
{
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));

#define rcu_head callback_head

typedef void (*rcu_callback_t)(struct rcu_head *head);
typedef void (*call_rcu_func_t)(struct rcu_head *head, rcu_callback_t func);

typedef void (*swap_func_t)(void *a, void *b, int size);

typedef int (*cmp_r_func_t)(const void *a, const void *b, const void *priv);
typedef int (*cmp_func_t)(const void *a, const void *b);



#define offsetof(TYPE, MEMBER) ((size_t) & ((TYPE *)0)->MEMBER)

#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))

#define offsetofend(TYPE, MEMBER) (offsetof(TYPE, MEMBER) + sizeof_field(TYPE, MEMBER))

#endif
```

`kernel/include/log.h`:

```h
#ifndef _KP_LOG_H_
#define _KP_LOG_H_

extern void (*printk)(const char *fmt, ...);

// #define logkv(fmt, ...) printk("[+] KP V " fmt, ##__VA_ARGS__)
#define logkv(fmt, ...)
#define logkfv(fmt, ...)

#define logkd(fmt, ...) printk("[+] KP D " fmt, ##__VA_ARGS__)
#define logkfd(fmt, ...) printk("[+] KP D %s " fmt, __func__, ##__VA_ARGS__)

#define logki(fmt, ...) printk("[+] KP I " fmt, ##__VA_ARGS__)
#define logkfi(fmt, ...) printk("[+] KP I %s " fmt, __func__, ##__VA_ARGS__)

#define logkw(fmt, ...) printk("[-] KP W " fmt, ##__VA_ARGS__)
#define logkfw(fmt, ...) printk("[-] KP W %s " fmt, __func__, ##__VA_ARGS__)

#define logke(fmt, ...) printk("[-] KP E " fmt, ##__VA_ARGS__)
#define logkfe(fmt, ...) printk("[-] KP E %s " fmt, __func__, ##__VA_ARGS__)

#endif
```

`kernel/include/pgtable.h`:

```h
#ifndef _KP_PGTABLE_H_
#define _KP_PGTABLE_H_

#include <ktypes.h>

/*
 * Level 3 descriptor (PTE).
 */
#define PTE_VALID (_AT(pteval_t, 1) << 0)
#define PTE_TYPE_MASK (_AT(pteval_t, 3) << 0)
#define PTE_TYPE_PAGE (_AT(pteval_t, 3) << 0)
#define PTE_TABLE_BIT (_AT(pteval_t, 1) << 1)
#define PTE_USER (_AT(pteval_t, 1) << 6) /* AP[1] */
#define PTE_RDONLY (_AT(pteval_t, 1) << 7) /* AP[2] */
#define PTE_SHARED (_AT(pteval_t, 3) << 8) /* SH[1:0], inner shareable */
#define PTE_AF (_AT(pteval_t, 1) << 10) /* Access Flag */
#define PTE_NG (_AT(pteval_t, 1) << 11) /* nG */
#define PTE_GP (_AT(pteval_t, 1) << 50) /* BTI guarded */
#define PTE_DBM (_AT(pteval_t, 1) << 51) /* Dirty Bit Management */
#define PTE_CONT (_AT(pteval_t, 1) << 52) /* Contiguous range */
#define PTE_PXN (_AT(pteval_t, 1) << 53) /* Privileged XN */
#define PTE_UXN (_AT(pteval_t, 1) << 54) /* User XN */

#define mask_ul(h, l) (((~0ul) << (l)) & (~0ul >> (63 - (h))))

#define sev() asm volatile("sev" : : : "memory")
#define wfe() asm volatile("wfe" : : : "memory")
#define wfi() asm volatile("wfi" : : : "memory")

#define isb() asm volatile("isb" : : : "memory")
#define dmb(opt) asm volatile("dmb " #opt : : : "memory")
#define dsb(opt) asm volatile("dsb " #opt : : : "memory")

#define tlbi_0(op)       \
    asm("tlbi " #op "\n" \
        "dsb ish\n"      \
        "tlbi " #op "\n")

#define tlbi_1(op, arg)      \
    asm("tlbi " #op ", %0\n" \
        "dsb ish\n"          \
        "tlbi " #op ", %0\n" \
        :                    \
        : "r"(arg))

static inline void local_flush_tlb_all(void)
{
    dsb(nshst);
    tlbi_0(vmalle1);
    dsb(nsh);
    isb();
}

static inline void flush_tlb_all(void)
{
    dsb(ishst);
    tlbi_0(vmalle1is);
    dsb(ish);
    isb();
}

static inline uint64_t tlbi_vaddr(uint64_t addr, uint64_t asid)
{
    uint64_t x = addr >> 12;
    x &= mask_ul(43, 0);
    x |= asid << 48;
    return x;
}

extern int64_t memstart_addr;
extern uint64_t kimage_voffset;
extern uint64_t page_offset;
extern uint64_t vabits_actual;
extern uint64_t kernel_va;
extern uint64_t kernel_pa;
extern int64_t kernel_size;
extern int64_t page_shift;
extern int64_t page_size;
extern int64_t va_bits;
// extern int64_t pa_bits;

static inline uint64_t phys_to_virt(uint64_t phys)
{
    return kimage_voffset ? (phys - memstart_addr) | page_offset : phys - memstart_addr + page_offset;
}

static inline uint64_t virt_to_phys(uint64_t virt)
{
    return kimage_voffset ? (virt & ~page_offset) + memstart_addr : virt - page_offset + memstart_addr;
}

static inline uint64_t phys_to_kimg(uint64_t phys)
{
    return phys + kimage_voffset;
}

static inline uint64_t kimg_to_phys(uint64_t addr)
{
    return addr - kimage_voffset;
}

// 4.9
// static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end)
// {
//     unsigned long addr;
//     if ((end - start) > 1024 * page_shift) {
//         flush_tlb_all();
//         return;
//     }
//     start >>= 12;
//     end >>= 12;
//     dsb(ishst);
//     for (addr = start; addr < end; addr += 1 << (PAGE_SHIFT - 12)) tlbi_1(vaae1is, addr);
//     dsb(ish);
//     isb();
// }

static inline void flush_tlb_kernel_range(uint64_t start, uint64_t end)
{
    start = tlbi_vaddr(start, 0);
    end = tlbi_vaddr(end, 0);
    dsb(ishst);
    for (uint64_t addr = start; addr < end; addr += 1 << (page_shift - 12))
        tlbi_1(vaale1is, addr);
    dsb(ish);
    isb();
}

static inline void flush_tlb_kernel_page(uint64_t addr)
{
    addr = tlbi_vaddr(addr, 0);
    dsb(ishst);
    tlbi_1(vaale1is, addr);
    dsb(ish);
    isb();
}

static inline bool is_kimg_range(uint64_t addr)
{
    return addr > kernel_va && addr < (kernel_va + kernel_size);
}

uint64_t *get_pte(uint64_t va);

#endif
```

`kernel/include/predata.h`:

```h
#ifndef _KP_PREDATA_H_
#define _KP_PREDATA_H_

#include <ktypes.h>
#include <stdbool.h>

int superkey_auth(const char *key, int32_t len);

#endif
```

`kernel/include/stdarg.h`:

```h
#ifndef _KP_STDARG_H_
#define _KP_STDARG_H_

#ifndef _VA_LIST
typedef __builtin_va_list va_list;
#define _VA_LIST
#endif
#define va_start(ap, param) __builtin_va_start(ap, param)
#define va_end(ap) __builtin_va_end(ap)
#define va_arg(ap, type) __builtin_va_arg(ap, type)

/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */
#define __va_copy(d, s) __builtin_va_copy(d, s)

#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined(__cplusplus) && __cplusplus >= 201103L) || \
    !defined(__STRICT_ANSI__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#endif

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST 1
typedef __builtin_va_list __gnuc_va_list;
#endif

#endif

```

`kernel/include/stdbool.h`:

```h
#ifndef _KP_STDBOOL_H_
#define _KP_STDBOOL_H_

typedef char bool;
#define true 1
#define false 0

#endif
```

`kernel/include/stddef.h`:

```h
#ifndef _KP_STDDEF_H_
#define _KP_STDDEF_H_

#define NULL 0

#define RET_VOID ((void)0)

#endif
```

`kernel/include/stdint.h`:

```h
#ifndef _KP_STDINT_H_
#define _KP_STDINT_H_

typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef signed short int16_t;
typedef unsigned short uint16_t;
typedef signed int int32_t;
typedef unsigned int uint32_t;
typedef signed long int64_t;
typedef unsigned long uint64_t;

typedef uint64_t u64;
typedef int64_t s64;
typedef uint32_t u32;
typedef int32_t s32;
typedef uint16_t u16;
typedef int16_t s16;
typedef uint8_t u8;
typedef int8_t s8;

typedef long ptrdiff_t;

typedef unsigned long size_t;
typedef long ssize_t;
typedef unsigned long uintptr_t;

typedef int intmax_t;
typedef unsigned long uintmax_t;

#endif
```

`kernel/init/accctl/accctl.c`:

```c
#include "accctl.h"

#include <taskext.h>
#include <linux/spinlock.h>
#include <linux/capability.h>
#include <linux/security.h>
#include <asm/current.h>
#include <linux/pid.h>
#include <linux/sched/task.h>
#include <linux/sched.h>
#include <pgtable.h>
#include <ksyms.h>
#include <error.h>

int commit_su_nodep()
{
    int rc = 0;
    struct task_struct *task = current;
    struct task_ext *ext = get_task_ext(task);
    if (!task_ext_valid(ext))
        goto out;

    const struct cred *old = get_task_cred(task);
    struct cred *new = prepare_kernel_cred(0);
    u32 secid;
    if (kfunc_def(security_cred_getsecid)) {
        kfunc_def(security_cred_getsecid)(old, &secid);
        set_security_override(new, secid);
    }
    commit_creds(new);
out:
    return rc;
}

int commit_su()
{
    int rc = 0;
    struct task_struct *task = current;
    struct task_ext *ext = get_task_ext(task);
    if (!task_ext_valid(ext)) {
        logkfe("dirty task_ext %llx\n", ext);
        rc = ERR_DIRTY_EXT;
        goto out;
    }

    ext->selinux_allow = true;
    struct cred *new = prepare_creds();

    if (cred_offset.cap_inheritable_offset >= 0)
        *(kernel_cap_t *)((uintptr_t) new + cred_offset.cap_inheritable_offset) = full_cap;
    if (cred_offset.cap_permitted_offset >= 0)
        *(kernel_cap_t *)((uintptr_t) new + cred_offset.cap_permitted_offset) = full_cap;
    if (cred_offset.cap_effective_offset >= 0)
        *(kernel_cap_t *)((uintptr_t) new + cred_offset.cap_effective_offset) = full_cap;
    if (cred_offset.cap_bset_offset >= 0)
        *(kernel_cap_t *)((uintptr_t) new + cred_offset.cap_bset_offset) = full_cap;
    if (cred_offset.cap_ambient_offset >= 0)
        *(kernel_cap_t *)((uintptr_t) new + cred_offset.cap_ambient_offset) = full_cap;

    if (cred_offset.uid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.uid_offset) = 0;
    if (cred_offset.euid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.euid_offset) = 0;
    if (cred_offset.fsuid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.fsuid_offset) = 0;
    if (cred_offset.suid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.suid_offset) = 0;

    if (cred_offset.gid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.gid_offset) = 0;
    if (cred_offset.egid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.egid_offset) = 0;
    if (cred_offset.fsgid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.fsgid_offset) = 0;
    if (cred_offset.sgid_offset >= 0)
        *(uid_t *)((uintptr_t) new + cred_offset.sgid_offset) = 0;

    commit_creds(new);

    logkd("commit_su pid: %d, tgid: %d\n", ext->pid, ext->tgid);
out:
    return rc;
}

// todo: cow
int thread_su(pid_t vpid, bool real)
{
    int rc = 0;
    struct task_struct *task = find_get_task_by_vpid(vpid);
    if (!task) {
        rc = ERR_NO_SUCH_ID;
        goto out;
    }
    struct task_ext *ext = get_task_ext(task);

    if (!task_ext_valid(ext)) {
        logkfe("dirty task_ext %llx\n", ext);
        rc = ERR_DIRTY_EXT;
        goto out;
    }

    // todo: COW
    struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);

    if (cred_offset.cap_inheritable_offset >= 0)
        *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_inheritable_offset) = full_cap;
    if (cred_offset.cap_permitted_offset >= 0)
        *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_permitted_offset) = full_cap;
    if (cred_offset.cap_effective_offset >= 0)
        *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_effective_offset) = full_cap;
    if (cred_offset.cap_bset_offset >= 0)
        *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_bset_offset) = full_cap;
    if (cred_offset.cap_ambient_offset >= 0)
        *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_ambient_offset) = full_cap;

    if (cred_offset.uid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.uid_offset) = 0;
    if (cred_offset.euid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.euid_offset) = 0;
    if (cred_offset.fsuid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.fsuid_offset) = 0;
    if (cred_offset.suid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.suid_offset) = 0;

    if (cred_offset.gid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.gid_offset) = 0;
    if (cred_offset.egid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.egid_offset) = 0;
    if (cred_offset.fsgid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.fsgid_offset) = 0;
    if (cred_offset.sgid_offset >= 0)
        *(uid_t *)((uintptr_t)cred + cred_offset.sgid_offset) = 0;

    if (real) {
        struct cred *real_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.real_cred_offset);

        if (cred_offset.cap_inheritable_offset >= 0)
            *(kernel_cap_t *)((uintptr_t)real_cred + cred_offset.cap_inheritable_offset) = full_cap;
        if (cred_offset.cap_permitted_offset >= 0)
            *(kernel_cap_t *)((uintptr_t)real_cred + cred_offset.cap_permitted_offset) = full_cap;
        if (cred_offset.cap_effective_offset >= 0)
            *(kernel_cap_t *)((uintptr_t)real_cred + cred_offset.cap_effective_offset) = full_cap;
        if (cred_offset.cap_bset_offset >= 0)
            *(kernel_cap_t *)((uintptr_t)cred + cred_offset.cap_bset_offset) = full_cap;
        if (cred_offset.cap_ambient_offset >= 0)
            *(kernel_cap_t *)((uintptr_t)real_cred + cred_offset.cap_ambient_offset) = full_cap;

        if (cred_offset.uid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.uid_offset) = 0;
        if (cred_offset.euid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.euid_offset) = 0;
        if (cred_offset.fsuid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.fsuid_offset) = 0;
        if (cred_offset.suid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.suid_offset) = 0;

        if (cred_offset.gid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.gid_offset) = 0;
        if (cred_offset.egid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.egid_offset) = 0;
        if (cred_offset.fsgid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.fsgid_offset) = 0;
        if (cred_offset.sgid_offset >= 0)
            *(uid_t *)((uintptr_t)real_cred + cred_offset.sgid_offset) = 0;
    }

    logkd("thread_su pid: %d, tgid: %d\n", ext->pid, ext->tgid);
out:
    __put_task_struct(task);
    return rc;
}

```

`kernel/init/accctl/lsmhook.c`:

```c
#include <accctl.h>
#include <linux/security.h>
#include <asm/current.h>
#include <linux/sched.h>
#include <uapi/asm-generic/errno.h>
#include <uapi/asm-generic/errno-base.h>
#include <linux/errno.h>
#include <taskext.h>
#include <ksyms.h>
#include <hook.h>
#include <log.h>

#define lsm_backup(func) hook_backup(func)
#define lsm_replace(func) hook_replace(func)
#define lsm_hook(func) hook_kfunc(func)
#define lsm_call_backup(func, ...) hook_call_backup(func, __VA_ARGS__)

#define lsm_int_hook_before(type, ret)

#define lsm_int_hook_after(type, ret)

#define lsm_void_hook_before(type)

#define lsm_void_hook_after(type)

/* Security operations */
int lsm_backup(security_binder_set_context_mgr)(const struct cred *mgr);
int lsm_backup(security_binder_transaction)(const struct cred *from, const struct cred *to);
int lsm_backup(security_binder_transfer_binder)(const struct cred *from, const struct cred *to);
int lsm_backup(security_binder_transfer_file)(const struct cred *from, const struct cred *to, struct file *file);
int lsm_backup(security_ptrace_access_check)(struct task_struct *child, unsigned int mode);
int lsm_backup(security_ptrace_traceme)(struct task_struct *parent);
int lsm_backup(security_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                                kernel_cap_t *permitted);
int lsm_backup(security_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                                const kernel_cap_t *inheritable, const kernel_cap_t *permitted);
int lsm_backup(security_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts);
int lsm_backup(security_quotactl)(int cmds, int type, int id, struct super_block *sb);
int lsm_backup(security_quota_on)(struct dentry *dentry);
int lsm_backup(security_syslog)(int type);
int lsm_backup(security_settime64)(const struct timespec64 *ts, const struct timezone *tz);
int lsm_backup(security_vm_enough_memory_mm)(struct mm_struct *mm, long pages);
int lsm_backup(security_bprm_creds_for_exec)(struct linux_binprm *bprm);
int lsm_backup(security_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file);
int lsm_backup(security_bprm_check)(struct linux_binprm *bprm);
void lsm_backup(security_bprm_committing_creds)(struct linux_binprm *bprm);
void lsm_backup(security_bprm_committed_creds)(struct linux_binprm *bprm);
int lsm_backup(security_fs_context_dup)(struct fs_context *fc, struct fs_context *src_fc);
int lsm_backup(security_fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param);
int lsm_backup(security_sb_alloc)(struct super_block *sb);
void lsm_backup(security_sb_delete)(struct super_block *sb);
void lsm_backup(security_sb_free)(struct super_block *sb);
void lsm_backup(security_free_mnt_opts)(void **mnt_opts);
int lsm_backup(security_sb_eat_lsm_opts)(char *options, void **mnt_opts);
int lsm_backup(security_sb_remount)(struct super_block *sb, void *mnt_opts);
int lsm_backup(security_sb_kern_mount)(struct super_block *sb);
int lsm_backup(security_sb_show_options)(struct seq_file *m, struct super_block *sb);
int lsm_backup(security_sb_statfs)(struct dentry *dentry);
int lsm_backup(security_sb_mount)(const char *dev_name, const struct path *path, const char *type, unsigned long flags,
                                  void *data);
int lsm_backup(security_sb_umount)(struct vfsmount *mnt, int flags);
int lsm_backup(security_sb_pivotroot)(const struct path *old_path, const struct path *new_path);
int lsm_backup(security_sb_set_mnt_opts)(struct super_block *sb, void *mnt_opts, unsigned long kern_flags,
                                         unsigned long *set_kern_flags);
int lsm_backup(security_sb_clone_mnt_opts)(const struct super_block *oldsb, struct super_block *newsb,
                                           unsigned long kern_flags, unsigned long *set_kern_flags);
int lsm_backup(security_add_mnt_opt)(const char *option, const char *val, int len, void **mnt_opts);
int lsm_backup(security_move_mount)(const struct path *from_path, const struct path *to_path);
int lsm_backup(security_dentry_init_security)(struct dentry *dentry, int mode, const struct qstr *name, void **ctx,
                                              u32 *ctxlen);
int lsm_backup(security_dentry_create_files_as)(struct dentry *dentry, int mode, struct qstr *name,
                                                const struct cred *old, struct cred *new);

//CONFIG_SECURITY_PATH
int lsm_backup(security_path_unlink)(const struct path *dir, struct dentry *dentry);
int lsm_backup(security_path_mkdir)(const struct path *dir, struct dentry *dentry, umode_t mode);
int lsm_backup(security_path_rmdir)(const struct path *dir, struct dentry *dentry);
int lsm_backup(security_path_mknod)(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev);
int lsm_backup(security_path_truncate)(const struct path *path);
int lsm_backup(security_path_symlink)(const struct path *dir, struct dentry *dentry, const char *old_name);
int lsm_backup(security_path_link)(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry);
int lsm_backup(security_path_rename)(const struct path *old_dir, struct dentry *old_dentry, const struct path *new_dir,
                                     struct dentry *new_dentry, unsigned int flags);
int lsm_backup(security_path_chmod)(const struct path *path, umode_t mode);
int lsm_backup(security_path_chown)(const struct path *path, kuid_t uid, kgid_t gid);
int lsm_backup(security_path_chroot)(const struct path *path);
/* CONFIG_SECURITY_PATH */

/* Needed for inode based security check */
int lsm_backup(security_path_notify)(const struct path *path, u64 mask, unsigned int obj_type);
int lsm_backup(security_inode_alloc)(struct inode *inode);
void lsm_backup(security_inode_free)(struct inode *inode);
int lsm_backup(security_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                             initxattrs initxattrs, void *fs_data);
int lsm_backup(security_old_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                                 const char **name, void **value, size_t *len);
int lsm_backup(security_inode_create)(struct inode *dir, struct dentry *dentry, umode_t mode);
int lsm_backup(security_inode_link)(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry);
int lsm_backup(security_inode_unlink)(struct inode *dir, struct dentry *dentry);
int lsm_backup(security_inode_symlink)(struct inode *dir, struct dentry *dentry, const char *old_name);
int lsm_backup(security_inode_mkdir)(struct inode *dir, struct dentry *dentry, umode_t mode);
int lsm_backup(security_inode_rmdir)(struct inode *dir, struct dentry *dentry);
int lsm_backup(security_inode_mknod)(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev);
int lsm_backup(security_inode_rename)(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir,
                                      struct dentry *new_dentry, unsigned int flags);
int lsm_backup(security_inode_readlink)(struct dentry *dentry);
int lsm_backup(security_inode_follow_link)(struct dentry *dentry, struct inode *inode, bool rcu);
int lsm_backup(security_inode_permission)(struct inode *inode, int mask);
int lsm_backup(security_inode_setattr)(struct dentry *dentry, struct iattr *attr);
int lsm_backup(security_inode_getattr)(const struct path *path);
int lsm_backup(security_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                        int flags);
void lsm_backup(security_inode_post_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                              int flags);
int lsm_backup(security_inode_getxattr)(struct dentry *dentry, const char *name);
int lsm_backup(security_inode_listxattr)(struct dentry *dentry);
int lsm_backup(security_inode_removexattr)(struct dentry *dentry, const char *name);
int lsm_backup(security_inode_set_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name,
                                       struct posix_acl *kacl);
int lsm_backup(security_inode_get_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name);
int lsm_backup(security_inode_remove_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name);
int lsm_backup(security_inode_need_killpriv)(struct dentry *dentry);
int lsm_backup(security_inode_killpriv)(struct dentry *dentry);
int lsm_backup(security_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc);
int lsm_backup(security_inode_setsecurity)(struct inode *inode, const char *name, const void *value, size_t size,
                                           int flags);
int lsm_backup(security_inode_listsecurity)(struct inode *inode, char *buffer, size_t buffer_size);
void lsm_backup(security_inode_getsecid)(struct inode *inode, u32 *secid);
int lsm_backup(security_inode_copy_up)(struct dentry *src, struct cred **new);
int lsm_backup(security_inode_copy_up_xattr)(const char *name);
int lsm_backup(security_kernfs_init_security)(struct kernfs_node *kn_dir, struct kernfs_node *kn);
int lsm_backup(security_file_permission)(struct file *file, int mask);
int lsm_backup(security_file_alloc)(struct file *file);
void lsm_backup(security_file_free)(struct file *file);
int lsm_backup(security_file_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
int lsm_backup(security_mmap_addr)(unsigned long addr);
int lsm_backup(security_mmap_file)(struct file *file, unsigned long prot, unsigned long flags);
int lsm_backup(security_file_mprotect)(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot);
int lsm_backup(security_file_lock)(struct file *file, unsigned int cmd);
int lsm_backup(security_file_fcntl)(struct file *file, unsigned int cmd, unsigned long arg);
void lsm_backup(security_file_set_fowner)(struct file *file);
int lsm_backup(security_file_send_sigiotask)(struct task_struct *tsk, struct fown_struct *fown, int sig);
int lsm_backup(security_file_receive)(struct file *file);
// int lsm_backup(security_file_open)(struct file *file);
int lsm_backup(security_file_open)(struct file *file, const struct cred *cred);
int lsm_backup(security_file_truncate)(struct file *file);
int lsm_backup(security_task_alloc)(struct task_struct *task, unsigned long clone_flags);
void lsm_backup(security_task_free)(struct task_struct *task);
int lsm_backup(security_cred_alloc_blank)(struct cred *cred, gfp_t gfp);
void lsm_backup(security_cred_free)(struct cred *cred);
int lsm_backup(security_prepare_creds)(struct cred *new, const struct cred *old, gfp_t gfp);
void lsm_backup(security_transfer_creds)(struct cred *new, const struct cred *old);
void lsm_backup(security_cred_getsecid)(const struct cred *c, u32 *secid);
int lsm_backup(security_kernel_act_as)(struct cred *new, u32 secid);
int lsm_backup(security_kernel_create_files_as)(struct cred *new, struct inode *inode);
int lsm_backup(security_kernel_module_request)(char *kmod_name);
int lsm_backup(security_kernel_load_data)(enum kernel_load_data_id id, bool contents);
int lsm_backup(security_kernel_post_load_data)(char *buf, loff_t size, enum kernel_load_data_id id, char *description);
int lsm_backup(security_kernel_read_file)(struct file *file, enum kernel_read_file_id id, bool contents);
int lsm_backup(security_kernel_post_read_file)(struct file *file, char *buf, loff_t size, enum kernel_read_file_id id);
int lsm_backup(security_task_fix_setuid)(struct cred *new, const struct cred *old, int flags);
int lsm_backup(security_task_fix_setgid)(struct cred *new, const struct cred *old, int flags);
int lsm_backup(security_task_fix_setgroups)(struct cred *new, const struct cred *old);
int lsm_backup(security_task_setpgid)(struct task_struct *p, pid_t pgid);
int lsm_backup(security_task_getpgid)(struct task_struct *p);
int lsm_backup(security_task_getsid)(struct task_struct *p);
void lsm_backup(security_current_getsecid_subj)(u32 *secid);
void lsm_backup(security_task_getsecid_obj)(struct task_struct *p, u32 *secid); // ?-6.3
void lsm_backup(security_task_getsecid)(struct task_struct *p, u32 *secid); // 4.4-?
int lsm_backup(security_task_setnice)(struct task_struct *p, int nice);
int lsm_backup(security_task_setioprio)(struct task_struct *p, int ioprio);
int lsm_backup(security_task_getioprio)(struct task_struct *p);
int lsm_backup(security_task_prlimit)(const struct cred *cred, const struct cred *tcred, unsigned int flags);
int lsm_backup(security_task_setrlimit)(struct task_struct *p, unsigned int resource, struct rlimit *new_rlim);
int lsm_backup(security_task_setscheduler)(struct task_struct *p);
int lsm_backup(security_task_getscheduler)(struct task_struct *p);
int lsm_backup(security_task_movememory)(struct task_struct *p);
int lsm_backup(security_task_kill)(struct task_struct *p, struct kernel_siginfo *info, int sig,
                                   const struct cred *cred);
int lsm_backup(security_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                    unsigned long arg5);
void lsm_backup(security_task_to_inode)(struct task_struct *p, struct inode *inode);
int lsm_backup(security_create_user_ns)(const struct cred *cred);
int lsm_backup(security_ipc_permission)(struct kern_ipc_perm *ipcp, short flag);
void lsm_backup(security_ipc_getsecid)(struct kern_ipc_perm *ipcp, u32 *secid);
int lsm_backup(security_msg_msg_alloc)(struct msg_msg *msg);
void lsm_backup(security_msg_msg_free)(struct msg_msg *msg);
int lsm_backup(security_msg_queue_alloc)(struct kern_ipc_perm *msq);
void lsm_backup(security_msg_queue_free)(struct kern_ipc_perm *msq);
int lsm_backup(security_msg_queue_associate)(struct kern_ipc_perm *msq, int msqflg);
int lsm_backup(security_msg_queue_msgctl)(struct kern_ipc_perm *msq, int cmd);
int lsm_backup(security_msg_queue_msgsnd)(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg);
int lsm_backup(security_msg_queue_msgrcv)(struct kern_ipc_perm *msq, struct msg_msg *msg, struct task_struct *target,
                                          long type, int mode);
int lsm_backup(security_shm_alloc)(struct kern_ipc_perm *shp);
void lsm_backup(security_shm_free)(struct kern_ipc_perm *shp);
int lsm_backup(security_shm_associate)(struct kern_ipc_perm *shp, int shmflg);
int lsm_backup(security_shm_shmctl)(struct kern_ipc_perm *shp, int cmd);
int lsm_backup(security_shm_shmat)(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg);
int lsm_backup(security_sem_alloc)(struct kern_ipc_perm *sma);
void lsm_backup(security_sem_free)(struct kern_ipc_perm *sma);
int lsm_backup(security_sem_associate)(struct kern_ipc_perm *sma, int semflg);
int lsm_backup(security_sem_semctl)(struct kern_ipc_perm *sma, int cmd);
int lsm_backup(security_sem_semop)(struct kern_ipc_perm *sma, struct sembuf *sops, unsigned nsops, int alter);
void lsm_backup(security_d_instantiate)(struct dentry *dentry, struct inode *inode);
int lsm_backup(security_getprocattr)(struct task_struct *p, const char *lsm, char *name, char **value);
int lsm_backup(security_setprocattr)(const char *lsm, const char *name, void *value, size_t size);
int lsm_backup(security_netlink_send)(struct sock *sk, struct sk_buff *skb);
int lsm_backup(security_ismaclabel)(const char *name);
int lsm_backup(security_secid_to_secctx)(u32 secid, char **secdata, u32 *seclen);
int lsm_backup(security_secctx_to_secid)(const char *secdata, u32 seclen, u32 *secid);
void lsm_backup(security_release_secctx)(char *secdata, u32 seclen);
void lsm_backup(security_inode_invalidate_secctx)(struct inode *inode);
int lsm_backup(security_inode_notifysecctx)(struct inode *inode, void *ctx, u32 ctxlen);
int lsm_backup(security_inode_setsecctx)(struct dentry *dentry, void *ctx, u32 ctxlen);
int lsm_backup(security_inode_getsecctx)(struct inode *inode, void **ctx, u32 *ctxlen);

// CONFIG_WATCH_QUEUE
int lsm_backup(security_post_notification)(const struct cred *w_cred, const struct cred *cred,
                                           struct watch_notification *n);

// CONFIG_KEY_NOTIFICATIONS
int lsm_backup(security_watch_key)(struct key *key);

// CONFIG_SECURITY_NETWORK
int lsm_backup(security_unix_stream_connect)(struct sock *sock, struct sock *other, struct sock *newsk);
int lsm_backup(security_unix_may_send)(struct socket *sock, struct socket *other);
int lsm_backup(security_socket_create)(int family, int type, int protocol, int kern);
int lsm_backup(security_socket_post_create)(struct socket *sock, int family, int type, int protocol, int kern);
int lsm_backup(security_socket_socketpair)(struct socket *socka, struct socket *sockb);
int lsm_backup(security_socket_bind)(struct socket *sock, struct sockaddr *address, int addrlen);
int lsm_backup(security_socket_connect)(struct socket *sock, struct sockaddr *address, int addrlen);
int lsm_backup(security_socket_listen)(struct socket *sock, int backlog);
int lsm_backup(security_socket_accept)(struct socket *sock, struct socket *newsock);
int lsm_backup(security_socket_sendmsg)(struct socket *sock, struct msghdr *msg, int size);
int lsm_backup(security_socket_recvmsg)(struct socket *sock, struct msghdr *msg, int size, int flags);
int lsm_backup(security_socket_getsockname)(struct socket *sock);
int lsm_backup(security_socket_getpeername)(struct socket *sock);
int lsm_backup(security_socket_getsockopt)(struct socket *sock, int level, int optname);
int lsm_backup(security_socket_setsockopt)(struct socket *sock, int level, int optname);
int lsm_backup(security_socket_shutdown)(struct socket *sock, int how);
int lsm_backup(security_sock_rcv_skb)(struct sock *sk, struct sk_buff *skb);
int lsm_backup(security_socket_getpeersec_stream)(struct socket *sock, sockptr_t optval, sockptr_t optlen,
                                                  unsigned int len);
int lsm_backup(security_socket_getpeersec_dgram)(struct socket *sock, struct sk_buff *skb, u32 *secid);
int lsm_backup(security_sk_alloc)(struct sock *sk, int family, gfp_t priority);
void lsm_backup(security_sk_free)(struct sock *sk);
void lsm_backup(security_sk_clone)(const struct sock *sk, struct sock *newsk);
void lsm_backup(security_sk_classify_flow)(struct sock *sk, struct flowi_common *flic);
void lsm_backup(security_req_classify_flow)(const struct request_sock *req, struct flowi_common *flic);
void lsm_backup(security_sock_graft)(struct sock *sk, struct socket *parent);
int lsm_backup(security_inet_conn_request)(const struct sock *sk, struct sk_buff *skb, struct request_sock *req);
void lsm_backup(security_inet_csk_clone)(struct sock *newsk, const struct request_sock *req);
void lsm_backup(security_inet_conn_established)(struct sock *sk, struct sk_buff *skb);
int lsm_backup(security_secmark_relabel_packet)(u32 secid);
void lsm_backup(security_secmark_refcount_inc)(void);
void lsm_backup(security_secmark_refcount_dec)(void);
int lsm_backup(security_tun_dev_alloc_security)(void **security);
void lsm_backup(security_tun_dev_free_security)(void *security);
int lsm_backup(security_tun_dev_create)(void);
int lsm_backup(security_tun_dev_attach_queue)(void *security);
int lsm_backup(security_tun_dev_attach)(struct sock *sk, void *security);
int lsm_backup(security_tun_dev_open)(void *security);
int lsm_backup(security_sctp_assoc_request)(struct sctp_association *asoc, struct sk_buff *skb);
int lsm_backup(security_sctp_bind_connect)(struct sock *sk, int optname, struct sockaddr *address, int addrlen);
void lsm_backup(security_sctp_sk_clone)(struct sctp_association *asoc, struct sock *sk, struct sock *newsk);
int lsm_backup(security_sctp_assoc_established)(struct sctp_association *asoc, struct sk_buff *skb);

// CONFIG_SECURITY_INFINIBAND
int lsm_backup(security_ib_pkey_access)(void *sec, u64 subnet_prefix, u16 pkey);
int lsm_backup(security_ib_endport_manage_subnet)(void *sec, const char *dev_name, u8 port_num);
int lsm_backup(security_ib_alloc_security)(void **sec);
void lsm_backup(security_ib_free_security)(void *sec);

// CONFIG_SECURITY_NETWORK_XFRM
int lsm_backup(security_xfrm_policy_alloc)(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp);
int lsm_backup(security_xfrm_policy_clone)(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp);
void lsm_backup(security_xfrm_policy_free)(struct xfrm_sec_ctx *ctx);
int lsm_backup(security_xfrm_policy_delete)(struct xfrm_sec_ctx *ctx);
int lsm_backup(security_xfrm_state_alloc)(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx);
int lsm_backup(security_xfrm_state_alloc_acquire)(struct xfrm_state *x, struct xfrm_sec_ctx *polsec, u32 secid);
int lsm_backup(security_xfrm_state_delete)(struct xfrm_state *x);
void lsm_backup(security_xfrm_state_free)(struct xfrm_state *x);
int lsm_backup(security_xfrm_policy_lookup)(struct xfrm_sec_ctx *ctx, u32 fl_secid);
int lsm_backup(security_xfrm_state_pol_flow_match)(struct xfrm_state *x, struct xfrm_policy *xp,
                                                   const struct flowi_common *flic);
int lsm_backup(security_xfrm_decode_session)(struct sk_buff *skb, u32 *secid);
void lsm_backup(security_skb_classify_flow)(struct sk_buff *skb, struct flowi_common *flic);

/* key management security hooks */
// CONFIG_KEYS
typedef void *key_ref_t;
int lsm_backup(security_key_alloc)(struct key *key, const struct cred *cred, unsigned long flags);
void lsm_backup(security_key_free)(struct key *key);
int lsm_backup(security_key_permission)(key_ref_t key_ref, const struct cred *cred, enum key_need_perm need_perm);
int lsm_backup(security_key_getsecurity)(struct key *key, char **_buffer);

// CONFIG_AUDIT
int lsm_backup(security_audit_rule_init)(u32 field, u32 op, char *rulestr, void **lsmrule);
int lsm_backup(security_audit_rule_known)(struct audit_krule *krule);
void lsm_backup(security_audit_rule_free)(void *lsmrule);
int lsm_backup(security_audit_rule_match)(u32 secid, u32 field, u32 op, void *lsmrule);

// CONFIG_BPF_SYSCALL
int lsm_backup(security_bpf)(int cmd, union bpf_attr *attr, unsigned int size);
int lsm_backup(security_bpf_map)(struct bpf_map *map, fmode_t fmode);
int lsm_backup(security_bpf_prog)(struct bpf_prog *prog);
int lsm_backup(security_bpf_map_alloc)(struct bpf_map *map);
int lsm_backup(security_bpf_prog_alloc)(struct bpf_prog_aux *aux);
void lsm_backup(security_bpf_map_free)(struct bpf_map *map);
void lsm_backup(security_bpf_prog_free)(struct bpf_prog_aux *aux);
// CONFIG_BPF_SYSCALL

int lsm_backup(security_locked_down)(enum lockdown_reason what);

// CONFIG_PERF_EVENTS
int lsm_backup(security_perf_event_open)(struct perf_event_attr *attr, int type);
int lsm_backup(security_perf_event_alloc)(struct perf_event *event);
void lsm_backup(security_perf_event_free)(struct perf_event *event);
int lsm_backup(security_perf_event_read)(struct perf_event *event);
int lsm_backup(security_perf_event_write)(struct perf_event *event);

// CONFIG_IO_URING
int lsm_backup(security_uring_override_creds)(const struct cred *new);
int lsm_backup(security_uring_sqpoll)(void);
int lsm_backup(security_uring_cmd)(struct io_uring_cmd *ioucmd);

// @see document: include/linux/lsm_hooks.h

/* Security operations */

int lsm_replace(security_binder_set_context_mgr)(const struct cred *mgr)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_binder_set_context_mgr, ret);
    ret = lsm_call_backup(security_binder_set_context_mgr, mgr);
    lsm_int_hook_after(LSM_TYPE_security_binder_set_context_mgr, ret);
    return ret;
}

int lsm_replace(security_binder_transaction)(const struct cred *from, const struct cred *to)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_binder_transaction, ret);
    ret = lsm_call_backup(security_binder_transaction, from, to);
    lsm_int_hook_after(LSM_TYPE_security_binder_transaction, ret);
    return ret;
}

int lsm_replace(security_binder_transfer_binder)(const struct cred *from, const struct cred *to)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_binder_transfer_binder, ret);
    ret = lsm_call_backup(security_binder_transfer_binder, from, to);
    lsm_int_hook_after(LSM_TYPE_security_binder_transfer_binder, ret);
    return ret;
}

int lsm_replace(security_binder_transfer_file)(const struct cred *from, const struct cred *to, struct file *file)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_binder_transfer_file, ret);
    ret = lsm_call_backup(security_binder_transfer_file, from, to, file);
    lsm_int_hook_after(LSM_TYPE_security_binder_transfer_file, ret);
    return ret;
}

int lsm_replace(security_ptrace_access_check)(struct task_struct *child, unsigned int mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ptrace_access_check, ret);
    ret = lsm_call_backup(security_ptrace_access_check, child, mode);
    lsm_int_hook_after(LSM_TYPE_security_ptrace_access_check, ret);
    return ret;
}

int lsm_replace(security_ptrace_traceme)(struct task_struct *parent)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ptrace_traceme, ret);
    ret = lsm_call_backup(security_ptrace_traceme, parent);
    lsm_int_hook_after(LSM_TYPE_security_ptrace_traceme, ret);
    return ret;
}

int lsm_replace(security_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                                 kernel_cap_t *permitted)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_capget, ret);
    ret = lsm_call_backup(security_capget, target, effective, inheritable, permitted);
    lsm_int_hook_after(LSM_TYPE_security_capget, ret);
    return ret;
}

int lsm_replace(security_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                                 const kernel_cap_t *inheritable, const kernel_cap_t *permitted)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_capset, ret);
    ret = lsm_call_backup(security_capset, new, old, effective, inheritable, permitted);
    lsm_int_hook_after(LSM_TYPE_security_capset, ret);
    return ret;
}

int lsm_replace(security_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_capable, ret);
    ret = lsm_call_backup(security_capable, cred, ns, cap, opts);
    lsm_int_hook_after(LSM_TYPE_security_capable, ret);
    return ret;
}

int lsm_replace(security_quotactl)(int cmds, int type, int id, struct super_block *sb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_quotactl, ret);
    ret = lsm_call_backup(security_quotactl, cmds, type, id, sb);
    lsm_int_hook_after(LSM_TYPE_security_quotactl, ret);
    return ret;
}

int lsm_replace(security_quota_on)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_quota_on, ret);
    ret = lsm_call_backup(security_quota_on, dentry);
    lsm_int_hook_after(LSM_TYPE_security_quota_on, ret);
    return ret;
}

int lsm_replace(security_syslog)(int type)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_syslog, ret);
    ret = lsm_call_backup(security_syslog, type);
    lsm_int_hook_after(LSM_TYPE_security_syslog, ret);
    return ret;
}

int lsm_replace(security_settime64)(const struct timespec64 *ts, const struct timezone *tz)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_settime64, ret);
    ret = lsm_call_backup(security_settime64, ts, tz);
    lsm_int_hook_after(LSM_TYPE_security_settime64, ret);
    return ret;
}

int lsm_replace(security_vm_enough_memory_mm)(struct mm_struct *mm, long pages)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_vm_enough_memory_mm, ret);
    ret = lsm_call_backup(security_vm_enough_memory_mm, mm, pages);
    lsm_int_hook_after(LSM_TYPE_security_vm_enough_memory_mm, ret);

    return ret;
}

// Security hooks for program execution operations.

/**
 * Security hooks for program execution operations.
 *
 * @bprm_creds_for_exec:
 *	If the setup in prepare_exec_creds did not setup @bprm->cred->security
 *	properly for executing @bprm->file, update the LSM's portion of
 *	@bprm->cred->security to be what commit_creds needs to install for the
 *	new program.  This hook may also optionally check permissions
 *	(e.g. for transitions between security domains).
 *	The hook must set @bprm->secureexec to 1 if AT_SECURE should be set to
 *	request libc enable secure mode.
 *	@bprm contains the linux_binprm structure.
 *	Return 0 if the hook is successful and permission is granted.
 */
int lsm_replace(security_bprm_creds_for_exec)(struct linux_binprm *bprm)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bprm_creds_for_exec, ret);
    ret = lsm_call_backup(security_bprm_creds_for_exec, bprm);
    lsm_int_hook_after(LSM_TYPE_security_bprm_creds_for_exec, ret);
    return ret;
}

int lsm_replace(security_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bprm_creds_from_file, ret);
    ret = lsm_call_backup(security_bprm_creds_from_file, bprm, file);
    lsm_int_hook_after(LSM_TYPE_security_bprm_creds_from_file, ret);
    return ret;
}

int lsm_replace(security_bprm_check)(struct linux_binprm *bprm)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bprm_check, ret);
    ret = lsm_call_backup(security_bprm_check, bprm);
    lsm_int_hook_after(LSM_TYPE_security_bprm_check, ret);
    return ret;
}

void lsm_replace(security_bprm_committing_creds)(struct linux_binprm *bprm)
{
    lsm_void_hook_before(LSM_TYPE_security_bprm_committing_creds);
    lsm_call_backup(security_bprm_committing_creds, bprm);
    lsm_void_hook_after(LSM_TYPE_security_bprm_committing_creds);
}

void lsm_replace(security_bprm_committed_creds)(struct linux_binprm *bprm)
{
    lsm_void_hook_before(LSM_TYPE_security_bprm_committed_creds);
    lsm_call_backup(security_bprm_committed_creds, bprm);
    lsm_void_hook_after(LSM_TYPE_security_bprm_committed_creds);
}

int lsm_replace(security_fs_context_dup)(struct fs_context *fc, struct fs_context *src_fc)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_fs_context_dup, ret);
    ret = lsm_call_backup(security_fs_context_dup, fc, src_fc);
    lsm_int_hook_after(LSM_TYPE_security_fs_context_dup, ret);
    return ret;
}

int lsm_replace(security_fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param)
{
    // int defrc = -ENOPARAM;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_fs_context_parse_param, ret);
    ret = lsm_call_backup(security_fs_context_parse_param, fc, param);
    lsm_int_hook_after(LSM_TYPE_security_fs_context_parse_param, ret);
    return ret;
}
int lsm_replace(security_sb_alloc)(struct super_block *sb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_alloc, ret);
    ret = lsm_call_backup(security_sb_alloc, sb);
    lsm_int_hook_after(LSM_TYPE_security_sb_alloc, ret);
    return ret;
}

void lsm_replace(security_sb_delete)(struct super_block *sb)
{
    lsm_void_hook_before(LSM_TYPE_security_sb_delete);
    lsm_call_backup(security_sb_delete, sb);
    lsm_void_hook_after(LSM_TYPE_security_sb_delete);
}

void lsm_replace(security_sb_free)(struct super_block *sb)
{
    lsm_void_hook_before(LSM_TYPE_security_sb_free);
    lsm_call_backup(security_sb_free, sb);
    lsm_void_hook_after(LSM_TYPE_security_sb_free);
}

void lsm_replace(security_free_mnt_opts)(void **mnt_opts)
{
    lsm_void_hook_before(LSM_TYPE_security_free_mnt_opts);
    lsm_call_backup(security_free_mnt_opts, mnt_opts);
    lsm_void_hook_after(LSM_TYPE_security_free_mnt_opts);
}

int lsm_replace(security_sb_eat_lsm_opts)(char *options, void **mnt_opts)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_eat_lsm_opts, ret);
    ret = lsm_call_backup(security_sb_eat_lsm_opts, options, mnt_opts);
    lsm_int_hook_after(LSM_TYPE_security_sb_eat_lsm_opts, ret);
    return ret;
}

int lsm_replace(security_sb_remount)(struct super_block *sb, void *mnt_opts)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_remount, ret);
    ret = lsm_call_backup(security_sb_remount, sb, mnt_opts);
    lsm_int_hook_after(LSM_TYPE_security_sb_remount, ret);
    return ret;
}

int lsm_replace(security_sb_kern_mount)(struct super_block *sb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_kern_mount, ret);
    ret = lsm_call_backup(security_sb_kern_mount, sb);
    lsm_int_hook_after(LSM_TYPE_security_sb_kern_mount, ret);
    return ret;
}

int lsm_replace(security_sb_show_options)(struct seq_file *m, struct super_block *sb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_show_options, ret);
    ret = lsm_call_backup(security_sb_show_options, m, sb);
    lsm_int_hook_after(LSM_TYPE_security_sb_show_options, ret);
    return ret;
}

int lsm_replace(security_sb_statfs)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_statfs, ret);
    ret = lsm_call_backup(security_sb_statfs, dentry);
    lsm_int_hook_after(LSM_TYPE_security_sb_statfs, ret);
    return ret;
}

int lsm_replace(security_sb_mount)(const char *dev_name, const struct path *path, const char *type, unsigned long flags,
                                   void *data)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_mount, ret);
    ret = lsm_call_backup(security_sb_mount, dev_name, path, type, flags, data);
    lsm_int_hook_after(LSM_TYPE_security_sb_mount, ret);
    return ret;
}

int lsm_replace(security_sb_umount)(struct vfsmount *mnt, int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_umount, ret);
    ret = lsm_call_backup(security_sb_umount, mnt, flags);
    lsm_int_hook_after(LSM_TYPE_security_sb_umount, ret);
    return ret;
}
int lsm_replace(security_sb_pivotroot)(const struct path *old_path, const struct path *new_path)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_pivotroot, ret);
    ret = lsm_call_backup(security_sb_pivotroot, old_path, new_path);
    lsm_int_hook_after(LSM_TYPE_security_sb_pivotroot, ret);
    return ret;
}

int lsm_replace(security_sb_set_mnt_opts)(struct super_block *sb, void *mnt_opts, unsigned long kern_flags,
                                          unsigned long *set_kern_flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_set_mnt_opts, ret);
    ret = lsm_call_backup(security_sb_set_mnt_opts, sb, mnt_opts, kern_flags, set_kern_flags);
    lsm_int_hook_after(LSM_TYPE_security_sb_set_mnt_opts, ret);
    return ret;
}

int lsm_replace(security_sb_clone_mnt_opts)(const struct super_block *oldsb, struct super_block *newsb,
                                            unsigned long kern_flags, unsigned long *set_kern_flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sb_clone_mnt_opts, ret);
    ret = lsm_call_backup(security_sb_clone_mnt_opts, oldsb, newsb, kern_flags, set_kern_flags);
    lsm_int_hook_after(LSM_TYPE_security_sb_clone_mnt_opts, ret);
    return ret;
}

int lsm_replace(security_add_mnt_opt)(const char *option, const char *val, int len, void **mnt_opts)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_add_mnt_opt, ret);
    ret = lsm_call_backup(security_add_mnt_opt, option, val, len, mnt_opts);
    lsm_int_hook_after(LSM_TYPE_security_add_mnt_opt, ret);
    return ret;
}

int lsm_replace(security_move_mount)(const struct path *from_path, const struct path *to_path)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_move_mount, ret);
    ret = lsm_call_backup(security_move_mount, from_path, to_path);
    lsm_int_hook_after(LSM_TYPE_security_move_mount, ret);
    return ret;
}

int lsm_replace(security_dentry_init_security)(struct dentry *dentry, int mode, const struct qstr *name, void **ctx,
                                               u32 *ctxlen)
{
    // int defrc = -EOPNOTSUPP;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_dentry_init_security, ret);
    ret = lsm_call_backup(security_dentry_init_security, dentry, mode, name, ctx, ctxlen);
    lsm_int_hook_after(LSM_TYPE_security_dentry_init_security, ret);
    return ret;
}

int lsm_replace(security_dentry_create_files_as)(struct dentry *dentry, int mode, struct qstr *name,
                                                 const struct cred *old, struct cred *new)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_dentry_create_files_as, ret);
    ret = lsm_call_backup(security_dentry_create_files_as, dentry, mode, name, old, new);
    lsm_int_hook_after(LSM_TYPE_security_dentry_create_files_as, ret);
    return ret;
}

//CONFIG_SECURITY_PATH
int lsm_replace(security_path_unlink)(const struct path *dir, struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_unlink, ret);
    ret = lsm_call_backup(security_path_unlink, dir, dentry);
    lsm_int_hook_after(LSM_TYPE_security_path_unlink, ret);
    return ret;
}

int lsm_replace(security_path_mkdir)(const struct path *dir, struct dentry *dentry, umode_t mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_mkdir, ret);
    ret = lsm_call_backup(security_path_mkdir, dir, dentry, mode);
    lsm_int_hook_after(LSM_TYPE_security_path_mkdir, ret);
    return ret;
}
int lsm_replace(security_path_rmdir)(const struct path *dir, struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_rmdir, ret);
    ret = lsm_call_backup(security_path_rmdir, dir, dentry);
    lsm_int_hook_after(LSM_TYPE_security_path_rmdir, ret);

    return ret;
}
int lsm_replace(security_path_mknod)(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_mknod, ret);
    ret = lsm_call_backup(security_path_mknod, dir, dentry, mode, dev);
    lsm_int_hook_after(LSM_TYPE_security_path_mknod, ret);

    return ret;
}
int lsm_replace(security_path_truncate)(const struct path *path)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_truncate, ret);
    ret = lsm_call_backup(security_path_truncate, path);
    lsm_int_hook_after(LSM_TYPE_security_path_truncate, ret);

    return ret;
}
int lsm_replace(security_path_symlink)(const struct path *dir, struct dentry *dentry, const char *old_name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_symlink, ret);
    ret = lsm_call_backup(security_path_symlink, dir, dentry, old_name);
    lsm_int_hook_after(LSM_TYPE_security_path_symlink, ret);

    return ret;
}
int lsm_replace(security_path_link)(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_link, ret);
    ret = lsm_call_backup(security_path_link, old_dentry, new_dir, new_dentry);
    lsm_int_hook_after(LSM_TYPE_security_path_link, ret);

    return ret;
}
int lsm_replace(security_path_rename)(const struct path *old_dir, struct dentry *old_dentry, const struct path *new_dir,
                                      struct dentry *new_dentry, unsigned int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_rename, ret);
    ret = lsm_call_backup(security_path_rename, old_dir, old_dentry, new_dir, new_dentry, flags);
    lsm_int_hook_after(LSM_TYPE_security_path_rename, ret);

    return ret;
}
int lsm_replace(security_path_chmod)(const struct path *path, umode_t mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_chmod, ret);
    ret = lsm_call_backup(security_path_chmod, path, mode);
    lsm_int_hook_after(LSM_TYPE_security_path_chmod, ret);
    return ret;
}
int lsm_replace(security_path_chown)(const struct path *path, kuid_t uid, kgid_t gid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_chown, ret);
    ret = lsm_call_backup(security_path_chown, path, uid, gid);
    lsm_int_hook_after(LSM_TYPE_security_path_chown, ret);
    return ret;
}
int lsm_replace(security_path_chroot)(const struct path *path)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_chroot, ret);
    ret = lsm_call_backup(security_path_chroot, path);
    lsm_int_hook_after(LSM_TYPE_security_path_chroot, ret);
    return ret;
}
/* CONFIG_SECURITY_PATH */

// Security hooks for inode operations.

int lsm_replace(security_path_notify)(const struct path *path, u64 mask, unsigned int obj_type)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_path_notify, ret);
    ret = lsm_call_backup(security_path_notify, path, mask, obj_type);
    lsm_int_hook_after(LSM_TYPE_security_path_notify, ret);
    return ret;
}

int lsm_replace(security_inode_alloc)(struct inode *inode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_alloc, ret);
    ret = lsm_call_backup(security_inode_alloc, inode);
    lsm_int_hook_after(LSM_TYPE_security_inode_alloc, ret);
    return ret;
}

void lsm_replace(security_inode_free)(struct inode *inode)
{
    lsm_void_hook_before(LSM_TYPE_security_inode_free);
    lsm_call_backup(security_inode_free, inode);
    lsm_void_hook_after(LSM_TYPE_security_inode_free);
}

int lsm_replace(security_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                              initxattrs initxattrs, void *fs_data)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_init_security, ret);
    ret = lsm_call_backup(security_inode_init_security, inode, dir, qstr, initxattrs, fs_data);
    lsm_int_hook_after(LSM_TYPE_security_inode_init_security, ret);
    return ret;
}

int lsm_replace(security_old_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                                  const char **name, void **value, size_t *len)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_old_inode_init_security, ret);
    ret = lsm_call_backup(security_old_inode_init_security, inode, dir, qstr, name, value, len);
    lsm_int_hook_after(LSM_TYPE_security_old_inode_init_security, ret);
    return ret;
}

int lsm_replace(security_inode_create)(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_create, ret);
    ret = lsm_call_backup(security_inode_create, dir, dentry, mode);
    lsm_int_hook_after(LSM_TYPE_security_inode_create, ret);
    return ret;
}

int lsm_replace(security_inode_link)(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_link, ret);
    ret = lsm_call_backup(security_inode_link, old_dentry, dir, new_dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_link, ret);
    return ret;
}

int lsm_replace(security_inode_unlink)(struct inode *dir, struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_unlink, ret);
    ret = lsm_call_backup(security_inode_unlink, dir, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_unlink, ret);
    return ret;
}

int lsm_replace(security_inode_symlink)(struct inode *dir, struct dentry *dentry, const char *old_name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_symlink, ret);
    ret = lsm_call_backup(security_inode_symlink, dir, dentry, old_name);
    lsm_int_hook_after(LSM_TYPE_security_inode_symlink, ret);
    return ret;
}

int lsm_replace(security_inode_mkdir)(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_mkdir, ret);
    ret = lsm_call_backup(security_inode_mkdir, dir, dentry, mode);
    lsm_int_hook_after(LSM_TYPE_security_inode_mkdir, ret);
    return ret;
}

int lsm_replace(security_inode_rmdir)(struct inode *dir, struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_rmdir, ret);
    ret = lsm_call_backup(security_inode_rmdir, dir, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_rmdir, ret);
    return ret;
}

int lsm_replace(security_inode_mknod)(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_mknod, ret);
    ret = lsm_call_backup(security_inode_mknod, dir, dentry, mode, dev);
    lsm_int_hook_after(LSM_TYPE_security_inode_mknod, ret);
    return ret;
}

int lsm_replace(security_inode_rename)(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir,
                                       struct dentry *new_dentry, unsigned int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_rename, ret);
    ret = lsm_call_backup(security_inode_rename, old_dir, old_dentry, new_dir, new_dentry, flags);
    lsm_int_hook_after(LSM_TYPE_security_inode_rename, ret);
    return ret;
}

int lsm_replace(security_inode_readlink)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_readlink, ret);
    ret = lsm_call_backup(security_inode_readlink, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_readlink, ret);
    return ret;
}

int lsm_replace(security_inode_follow_link)(struct dentry *dentry, struct inode *inode, bool rcu)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_follow_link, ret);
    ret = lsm_call_backup(security_inode_follow_link, dentry, inode, rcu);
    lsm_int_hook_after(LSM_TYPE_security_inode_follow_link, ret);
    return ret;
}

int lsm_replace(security_inode_permission)(struct inode *inode, int mask)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_permission, ret);
    ret = lsm_call_backup(security_inode_permission, inode, mask);
    lsm_int_hook_after(LSM_TYPE_security_inode_permission, ret);
    return ret;
}

int lsm_replace(security_inode_setattr)(struct dentry *dentry, struct iattr *attr)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_setattr, ret);
    ret = lsm_call_backup(security_inode_setattr, dentry, attr);
    lsm_int_hook_after(LSM_TYPE_security_inode_setattr, ret);
    return ret;
}

int lsm_replace(security_inode_getattr)(const struct path *path)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_getattr, ret);
    ret = lsm_call_backup(security_inode_getattr, path);
    lsm_int_hook_after(LSM_TYPE_security_inode_getattr, ret);
    return ret;
}
int lsm_replace(security_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                         int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_setxattr, ret);
    ret = lsm_call_backup(security_inode_setxattr, dentry, name, value, size, flags);
    lsm_int_hook_after(LSM_TYPE_security_inode_setxattr, ret);
    return ret;
}

void lsm_replace(security_inode_post_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                               int flags)
{
    lsm_void_hook_before(LSM_TYPE_security_inode_post_setxattr);
    lsm_call_backup(security_inode_post_setxattr, dentry, name, value, size, flags);
    lsm_void_hook_after(LSM_TYPE_security_inode_post_setxattr);
}

int lsm_replace(security_inode_getxattr)(struct dentry *dentry, const char *name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_getxattr, ret);
    ret = lsm_call_backup(security_inode_getxattr, dentry, name);
    lsm_int_hook_after(LSM_TYPE_security_inode_getxattr, ret);
    return ret;
}

int lsm_replace(security_inode_listxattr)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_listxattr, ret);
    ret = lsm_call_backup(security_inode_listxattr, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_listxattr, ret);
    return ret;
}

int lsm_replace(security_inode_removexattr)(struct dentry *dentry, const char *name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_removexattr, ret);
    ret = lsm_call_backup(security_inode_removexattr, dentry, name);
    lsm_int_hook_after(LSM_TYPE_security_inode_removexattr, ret);
    return ret;
}

int lsm_replace(security_inode_set_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name,
                                        struct posix_acl *kacl)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_set_acl, ret);
    ret = lsm_call_backup(security_inode_set_acl, idmap, dentry, acl_name, kacl);
    lsm_int_hook_after(LSM_TYPE_security_inode_set_acl, ret);
    return ret;
}

int lsm_replace(security_inode_get_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_get_acl, ret);
    ret = lsm_call_backup(security_inode_get_acl, idmap, dentry, acl_name);
    lsm_int_hook_after(LSM_TYPE_security_inode_get_acl, ret);
    return ret;
}

int lsm_replace(security_inode_remove_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_remove_acl, ret);
    ret = lsm_call_backup(security_inode_remove_acl, idmap, dentry, acl_name);
    lsm_int_hook_after(LSM_TYPE_security_inode_remove_acl, ret);
    return ret;
}

int lsm_replace(security_inode_need_killpriv)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_need_killpriv, ret);
    ret = lsm_call_backup(security_inode_need_killpriv, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_need_killpriv, ret);
    return ret;
}

int lsm_replace(security_inode_killpriv)(struct dentry *dentry)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_killpriv, ret);
    ret = lsm_call_backup(security_inode_killpriv, dentry);
    lsm_int_hook_after(LSM_TYPE_security_inode_killpriv, ret);
    return ret;
}

int lsm_replace(security_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc)
{
    // int defrc = -EOPNOTSUPP;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_getsecurity, ret);
    ret = lsm_call_backup(security_inode_getsecurity, inode, name, buffer, alloc);
    lsm_int_hook_after(LSM_TYPE_security_inode_getsecurity, ret);
    return ret;
}

int lsm_replace(security_inode_setsecurity)(struct inode *inode, const char *name, const void *value, size_t size,
                                            int flags)
{
    // int defrc = -EOPNOTSUPP;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_setsecurity, ret);
    ret = lsm_call_backup(security_inode_setsecurity, inode, name, value, size, flags);
    lsm_int_hook_after(LSM_TYPE_security_inode_setsecurity, ret);
    return ret;
}

int lsm_replace(security_inode_listsecurity)(struct inode *inode, char *buffer, size_t buffer_size)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_listsecurity, ret);
    ret = lsm_call_backup(security_inode_listsecurity, inode, buffer, buffer_size);
    lsm_int_hook_after(LSM_TYPE_security_inode_listsecurity, ret);
    return ret;
}
void lsm_replace(security_inode_getsecid)(struct inode *inode, u32 *secid)
{
    lsm_void_hook_before(LSM_TYPE_security_inode_getsecid);
    lsm_call_backup(security_inode_getsecid, inode, secid);
    lsm_void_hook_after(LSM_TYPE_security_inode_getsecid);
}
int lsm_replace(security_inode_copy_up)(struct dentry *src, struct cred **new)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_copy_up, ret);
    ret = lsm_call_backup(security_inode_copy_up, src, new);
    lsm_int_hook_after(LSM_TYPE_security_inode_copy_up, ret);

    return ret;
}
int lsm_replace(security_inode_copy_up_xattr)(const char *name)
{
    // // int defrc = -EOPNOTSUPP;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_copy_up_xattr, ret);
    ret = lsm_call_backup(security_inode_copy_up_xattr, name);
    lsm_int_hook_after(LSM_TYPE_security_inode_copy_up_xattr, ret);
    return ret;
}
int lsm_replace(security_kernfs_init_security)(struct kernfs_node *kn_dir, struct kernfs_node *kn)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernfs_init_security, ret);
    ret = lsm_call_backup(security_kernfs_init_security, kn_dir, kn);
    lsm_int_hook_after(LSM_TYPE_security_kernfs_init_security, ret);

    return ret;
}
int lsm_replace(security_file_permission)(struct file *file, int mask)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_permission, ret);
    ret = lsm_call_backup(security_file_permission, file, mask);
    lsm_int_hook_after(LSM_TYPE_security_file_permission, ret);

    return ret;
}
int lsm_replace(security_file_alloc)(struct file *file)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_alloc, ret);
    ret = lsm_call_backup(security_file_alloc, file);
    lsm_int_hook_after(LSM_TYPE_security_file_alloc, ret);
    return ret;
}
void lsm_replace(security_file_free)(struct file *file)
{
    lsm_void_hook_before(LSM_TYPE_security_file_free);
    lsm_call_backup(security_file_free, file);
    lsm_void_hook_after(LSM_TYPE_security_file_free);
}
int lsm_replace(security_file_ioctl)(struct file *file, unsigned int cmd, unsigned long arg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_ioctl, ret);
    ret = lsm_call_backup(security_file_ioctl, file, cmd, arg);
    lsm_int_hook_after(LSM_TYPE_security_file_ioctl, ret);

    return ret;
}
int lsm_replace(security_mmap_addr)(unsigned long addr)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_mmap_addr, ret);
    ret = lsm_call_backup(security_mmap_addr, addr);
    lsm_int_hook_after(LSM_TYPE_security_mmap_addr, ret);

    return ret;
}
int lsm_replace(security_mmap_file)(struct file *file, unsigned long prot, unsigned long flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_mmap_file, ret);
    ret = lsm_call_backup(security_mmap_file, file, prot, flags);
    lsm_int_hook_after(LSM_TYPE_security_mmap_file, ret);

    return ret;
}
int lsm_replace(security_file_mprotect)(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_mprotect, ret);
    ret = lsm_call_backup(security_file_mprotect, vma, reqprot, prot);
    lsm_int_hook_after(LSM_TYPE_security_file_mprotect, ret);

    return ret;
}
int lsm_replace(security_file_lock)(struct file *file, unsigned int cmd)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_lock, ret);
    ret = lsm_call_backup(security_file_lock, file, cmd);
    lsm_int_hook_after(LSM_TYPE_security_file_lock, ret);

    return ret;
}
int lsm_replace(security_file_fcntl)(struct file *file, unsigned int cmd, unsigned long arg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_fcntl, ret);
    ret = lsm_call_backup(security_file_fcntl, file, cmd, arg);
    lsm_int_hook_after(LSM_TYPE_security_file_fcntl, ret);

    return ret;
}
void lsm_replace(security_file_set_fowner)(struct file *file)
{
    lsm_void_hook_before(LSM_TYPE_security_file_set_fowner);
    lsm_call_backup(security_file_set_fowner, file);
    lsm_void_hook_after(LSM_TYPE_security_file_set_fowner);
}
int lsm_replace(security_file_send_sigiotask)(struct task_struct *tsk, struct fown_struct *fown, int sig)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_send_sigiotask, ret);
    ret = lsm_call_backup(security_file_send_sigiotask, tsk, fown, sig);
    lsm_int_hook_after(LSM_TYPE_security_file_send_sigiotask, ret);

    return ret;
}
int lsm_replace(security_file_receive)(struct file *file)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_receive, ret);
    ret = lsm_call_backup(security_file_receive, file);
    lsm_int_hook_after(LSM_TYPE_security_file_receive, ret);

    return ret;
}
int lsm_replace(security_file_open)(struct file *file, const struct cred *cred)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_open, ret);
    ret = lsm_call_backup(security_file_open, file, cred);
    lsm_int_hook_after(LSM_TYPE_security_file_open, ret);

    return ret;
}
int lsm_replace(security_file_truncate)(struct file *file)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_file_truncate, ret);
    ret = lsm_call_backup(security_file_truncate, file);
    lsm_int_hook_after(LSM_TYPE_security_file_truncate, ret);

    return ret;
}
int lsm_replace(security_task_alloc)(struct task_struct *task, unsigned long clone_flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_alloc, ret);
    ret = lsm_call_backup(security_task_alloc, task, clone_flags);
    lsm_int_hook_after(LSM_TYPE_security_task_alloc, ret);

    return ret;
}
void lsm_replace(security_task_free)(struct task_struct *task)
{
    lsm_void_hook_before(LSM_TYPE_security_task_free);
    lsm_call_backup(security_task_free, task);
    lsm_void_hook_after(LSM_TYPE_security_task_free);
}
int lsm_replace(security_cred_alloc_blank)(struct cred *cred, gfp_t gfp)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_cred_alloc_blank, ret);
    ret = lsm_call_backup(security_cred_alloc_blank, cred, gfp);
    lsm_int_hook_after(LSM_TYPE_security_cred_alloc_blank, ret);
    return ret;
}
void lsm_replace(security_cred_free)(struct cred *cred)
{
    lsm_void_hook_before(LSM_TYPE_security_cred_free);
    lsm_call_backup(security_cred_free, cred);
    lsm_void_hook_after(LSM_TYPE_security_cred_free);
}
int lsm_replace(security_prepare_creds)(struct cred *new, const struct cred *old, gfp_t gfp)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_prepare_creds, ret);
    ret = lsm_call_backup(security_prepare_creds, new, old, gfp);
    lsm_int_hook_after(LSM_TYPE_security_prepare_creds, ret);
    return ret;
}
void lsm_replace(security_transfer_creds)(struct cred *new, const struct cred *old)
{
    lsm_void_hook_before(LSM_TYPE_security_transfer_creds);
    lsm_call_backup(security_transfer_creds, new, old);
    lsm_void_hook_after(LSM_TYPE_security_transfer_creds);
}
void lsm_replace(security_cred_getsecid)(const struct cred *c, u32 *secid)
{
    lsm_void_hook_before(LSM_TYPE_security_cred_getsecid);
    lsm_call_backup(security_cred_getsecid, c, secid);
    lsm_void_hook_after(LSM_TYPE_security_cred_getsecid);
}
int lsm_replace(security_kernel_act_as)(struct cred *new, u32 secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_act_as, ret);
    ret = lsm_call_backup(security_kernel_act_as, new, secid);
    lsm_int_hook_after(LSM_TYPE_security_kernel_act_as, ret);

    return ret;
}
int lsm_replace(security_kernel_create_files_as)(struct cred *new, struct inode *inode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_create_files_as, ret);
    ret = lsm_call_backup(security_kernel_create_files_as, new, inode);
    lsm_int_hook_after(LSM_TYPE_security_kernel_create_files_as, ret);

    return ret;
}
int lsm_replace(security_kernel_module_request)(char *kmod_name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_module_request, ret);
    ret = lsm_call_backup(security_kernel_module_request, kmod_name);
    lsm_int_hook_after(LSM_TYPE_security_kernel_module_request, ret);

    return ret;
}
int lsm_replace(security_kernel_load_data)(enum kernel_load_data_id id, bool contents)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_load_data, ret);
    ret = lsm_call_backup(security_kernel_load_data, id, contents);
    lsm_int_hook_after(LSM_TYPE_security_kernel_load_data, ret);

    return ret;
}
int lsm_replace(security_kernel_post_load_data)(char *buf, loff_t size, enum kernel_load_data_id id, char *description)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_post_load_data, ret);
    ret = lsm_call_backup(security_kernel_post_load_data, buf, size, id, description);
    lsm_int_hook_after(LSM_TYPE_security_kernel_post_load_data, ret);

    return ret;
}
int lsm_replace(security_kernel_read_file)(struct file *file, enum kernel_read_file_id id, bool contents)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_read_file, ret);
    ret = lsm_call_backup(security_kernel_read_file, file, id, contents);
    lsm_int_hook_after(LSM_TYPE_security_kernel_read_file, ret);

    return ret;
}
int lsm_replace(security_kernel_post_read_file)(struct file *file, char *buf, loff_t size, enum kernel_read_file_id id)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_kernel_post_read_file, ret);
    ret = lsm_call_backup(security_kernel_post_read_file, file, buf, size, id);
    lsm_int_hook_after(LSM_TYPE_security_kernel_post_read_file, ret);

    return ret;
}
int lsm_replace(security_task_fix_setuid)(struct cred *new, const struct cred *old, int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_fix_setuid, ret);
    ret = lsm_call_backup(security_task_fix_setuid, new, old, flags);
    lsm_int_hook_after(LSM_TYPE_security_task_fix_setuid, ret);

    return ret;
}
int lsm_replace(security_task_fix_setgid)(struct cred *new, const struct cred *old, int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_fix_setgid, ret);
    ret = lsm_call_backup(security_task_fix_setgid, new, old, flags);
    lsm_int_hook_after(LSM_TYPE_security_task_fix_setgid, ret);

    return ret;
}
int lsm_replace(security_task_fix_setgroups)(struct cred *new, const struct cred *old)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_fix_setgroups, ret);
    ret = lsm_call_backup(security_task_fix_setgroups, new, old);
    lsm_int_hook_after(LSM_TYPE_security_task_fix_setgroups, ret);

    return ret;
}
int lsm_replace(security_task_setpgid)(struct task_struct *p, pid_t pgid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_setpgid, ret);
    ret = lsm_call_backup(security_task_setpgid, p, pgid);
    lsm_int_hook_after(LSM_TYPE_security_task_setpgid, ret);

    return ret;
}
int lsm_replace(security_task_getpgid)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_getpgid, ret);
    ret = lsm_call_backup(security_task_getpgid, p);
    lsm_int_hook_after(LSM_TYPE_security_task_getpgid, ret);

    return ret;
}
int lsm_replace(security_task_getsid)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_getsid, ret);
    ret = lsm_call_backup(security_task_getsid, p);
    lsm_int_hook_after(LSM_TYPE_security_task_getsid, ret);

    return ret;
}
void lsm_replace(security_current_getsecid_subj)(u32 *secid)
{
    lsm_void_hook_before(LSM_TYPE_security_current_getsecid_subj);
    lsm_call_backup(security_current_getsecid_subj, secid);
    lsm_void_hook_after(LSM_TYPE_security_current_getsecid_subj);
}
void lsm_replace(security_task_getsecid_obj)(struct task_struct *p, u32 *secid) // ?-6.3
{
    lsm_void_hook_before(LSM_TYPE_security_task_getsecid_obj);
    lsm_call_backup(security_task_getsecid_obj, p, secid);
    lsm_void_hook_after(LSM_TYPE_security_task_getsecid_obj);
}
void lsm_replace(security_task_getsecid)(struct task_struct *p, u32 *secid) // 4.4-?
{
    lsm_void_hook_before(LSM_TYPE_security_task_getsecid);
    lsm_call_backup(security_task_getsecid, p, secid);
    lsm_void_hook_after(LSM_TYPE_security_task_getsecid);
}
int lsm_replace(security_task_setnice)(struct task_struct *p, int nice)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_setnice, ret);
    ret = lsm_call_backup(security_task_setnice, p, nice);
    lsm_int_hook_after(LSM_TYPE_security_task_setnice, ret);

    return ret;
}
int lsm_replace(security_task_setioprio)(struct task_struct *p, int ioprio)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_setioprio, ret);
    ret = lsm_call_backup(security_task_setioprio, p, ioprio);
    lsm_int_hook_after(LSM_TYPE_security_task_setioprio, ret);

    return ret;
}
int lsm_replace(security_task_getioprio)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_getioprio, ret);
    ret = lsm_call_backup(security_task_getioprio, p);
    lsm_int_hook_after(LSM_TYPE_security_task_getioprio, ret);

    return ret;
}
int lsm_replace(security_task_prlimit)(const struct cred *cred, const struct cred *tcred, unsigned int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_prlimit, ret);
    ret = lsm_call_backup(security_task_prlimit, cred, tcred, flags);
    lsm_int_hook_after(LSM_TYPE_security_task_prlimit, ret);

    return ret;
}
int lsm_replace(security_task_setrlimit)(struct task_struct *p, unsigned int resource, struct rlimit *new_rlim)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_setrlimit, ret);
    ret = lsm_call_backup(security_task_setrlimit, p, resource, new_rlim);
    lsm_int_hook_after(LSM_TYPE_security_task_setrlimit, ret);

    return ret;
}
int lsm_replace(security_task_setscheduler)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_setscheduler, ret);
    ret = lsm_call_backup(security_task_setscheduler, p);
    lsm_int_hook_after(LSM_TYPE_security_task_setscheduler, ret);

    return ret;
}
int lsm_replace(security_task_getscheduler)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_getscheduler, ret);
    ret = lsm_call_backup(security_task_getscheduler, p);
    lsm_int_hook_after(LSM_TYPE_security_task_getscheduler, ret);

    return ret;
}
int lsm_replace(security_task_movememory)(struct task_struct *p)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_movememory, ret);
    ret = lsm_call_backup(security_task_movememory, p);
    lsm_int_hook_after(LSM_TYPE_security_task_movememory, ret);

    return ret;
}
int lsm_replace(security_task_kill)(struct task_struct *p, struct kernel_siginfo *info, int sig,
                                    const struct cred *cred)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_kill, ret);
    ret = lsm_call_backup(security_task_kill, p, info, sig, cred);
    lsm_int_hook_after(LSM_TYPE_security_task_kill, ret);

    return ret;
}
int lsm_replace(security_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                     unsigned long arg5)
{
    // int defrc = -ENOSYS;
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_task_prctl, ret);
    ret = lsm_call_backup(security_task_prctl, option, arg2, arg3, arg4, arg5);
    lsm_int_hook_after(LSM_TYPE_security_task_prctl, ret);
    return ret;
}
void lsm_replace(security_task_to_inode)(struct task_struct *p, struct inode *inode)
{
    lsm_void_hook_before(LSM_TYPE_security_task_to_inode);
    lsm_call_backup(security_task_to_inode, p, inode);
    lsm_void_hook_after(LSM_TYPE_security_task_to_inode);
}
int lsm_replace(security_create_user_ns)(const struct cred *cred)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_create_user_ns, ret);
    ret = lsm_call_backup(security_create_user_ns, cred);
    lsm_int_hook_after(LSM_TYPE_security_create_user_ns, ret);

    return ret;
}
int lsm_replace(security_ipc_permission)(struct kern_ipc_perm *ipcp, short flag)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ipc_permission, ret);
    ret = lsm_call_backup(security_ipc_permission, ipcp, flag);
    lsm_int_hook_after(LSM_TYPE_security_ipc_permission, ret);

    return ret;
}
void lsm_replace(security_ipc_getsecid)(struct kern_ipc_perm *ipcp, u32 *secid)
{
    lsm_void_hook_before(LSM_TYPE_security_ipc_getsecid);
    lsm_call_backup(security_ipc_getsecid, ipcp, secid);
    lsm_void_hook_after(LSM_TYPE_security_ipc_getsecid);
}
int lsm_replace(security_msg_msg_alloc)(struct msg_msg *msg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_msg_alloc, ret);
    ret = lsm_call_backup(security_msg_msg_alloc, msg);
    lsm_int_hook_after(LSM_TYPE_security_msg_msg_alloc, ret);

    return ret;
}
void lsm_replace(security_msg_msg_free)(struct msg_msg *msg)
{
    lsm_void_hook_before(LSM_TYPE_security_msg_msg_free);
    lsm_call_backup(security_msg_msg_free, msg);
    lsm_void_hook_after(LSM_TYPE_security_msg_msg_free);
}
int lsm_replace(security_msg_queue_alloc)(struct kern_ipc_perm *msq)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_queue_alloc, ret);
    ret = lsm_call_backup(security_msg_queue_alloc, msq);
    lsm_int_hook_after(LSM_TYPE_security_msg_queue_alloc, ret);

    return ret;
}
void lsm_replace(security_msg_queue_free)(struct kern_ipc_perm *msq)
{
    lsm_void_hook_before(LSM_TYPE_security_msg_queue_free);
    lsm_call_backup(security_msg_queue_free, msq);
    lsm_void_hook_after(LSM_TYPE_security_msg_queue_free);
}
int lsm_replace(security_msg_queue_associate)(struct kern_ipc_perm *msq, int msqflg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_queue_associate, ret);
    ret = lsm_call_backup(security_msg_queue_associate, msq, msqflg);
    lsm_int_hook_after(LSM_TYPE_security_msg_queue_associate, ret);

    return ret;
}
int lsm_replace(security_msg_queue_msgctl)(struct kern_ipc_perm *msq, int cmd)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_queue_msgctl, ret);
    ret = lsm_call_backup(security_msg_queue_msgctl, msq, cmd);
    lsm_int_hook_after(LSM_TYPE_security_msg_queue_msgctl, ret);

    return ret;
}
int lsm_replace(security_msg_queue_msgsnd)(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_queue_msgsnd, ret);
    ret = lsm_call_backup(security_msg_queue_msgsnd, msq, msg, msqflg);
    lsm_int_hook_after(LSM_TYPE_security_msg_queue_msgsnd, ret);

    return ret;
}
int lsm_replace(security_msg_queue_msgrcv)(struct kern_ipc_perm *msq, struct msg_msg *msg, struct task_struct *target,
                                           long type, int mode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_msg_queue_msgrcv, ret);
    ret = lsm_call_backup(security_msg_queue_msgrcv, msq, msg, target, type, mode);
    lsm_int_hook_after(LSM_TYPE_security_msg_queue_msgrcv, ret);

    return ret;
}
int lsm_replace(security_shm_alloc)(struct kern_ipc_perm *shp)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_shm_alloc, ret);
    ret = lsm_call_backup(security_shm_alloc, shp);
    lsm_int_hook_after(LSM_TYPE_security_shm_alloc, ret);

    return ret;
}
void lsm_replace(security_shm_free)(struct kern_ipc_perm *shp)
{
    lsm_void_hook_before(LSM_TYPE_security_shm_free);
    lsm_call_backup(security_shm_free, shp);
    lsm_void_hook_after(LSM_TYPE_security_shm_free);
}
int lsm_replace(security_shm_associate)(struct kern_ipc_perm *shp, int shmflg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_shm_associate, ret);
    ret = lsm_call_backup(security_shm_associate, shp, shmflg);
    lsm_int_hook_after(LSM_TYPE_security_shm_associate, ret);

    return ret;
}
int lsm_replace(security_shm_shmctl)(struct kern_ipc_perm *shp, int cmd)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_shm_shmctl, ret);
    ret = lsm_call_backup(security_shm_shmctl, shp, cmd);
    lsm_int_hook_after(LSM_TYPE_security_shm_shmctl, ret);

    return ret;
}
int lsm_replace(security_shm_shmat)(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_shm_shmat, ret);
    ret = lsm_call_backup(security_shm_shmat, shp, shmaddr, shmflg);
    lsm_int_hook_after(LSM_TYPE_security_shm_shmat, ret);

    return ret;
}
int lsm_replace(security_sem_alloc)(struct kern_ipc_perm *sma)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sem_alloc, ret);
    ret = lsm_call_backup(security_sem_alloc, sma);
    lsm_int_hook_after(LSM_TYPE_security_sem_alloc, ret);

    return ret;
}
void lsm_replace(security_sem_free)(struct kern_ipc_perm *sma)
{
    lsm_void_hook_before(LSM_TYPE_security_sem_free);
    lsm_call_backup(security_sem_free, sma);
    lsm_void_hook_after(LSM_TYPE_security_sem_free);
}
int lsm_replace(security_sem_associate)(struct kern_ipc_perm *sma, int semflg)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sem_associate, ret);
    ret = lsm_call_backup(security_sem_associate, sma, semflg);
    lsm_int_hook_after(LSM_TYPE_security_sem_associate, ret);

    return ret;
}
int lsm_replace(security_sem_semctl)(struct kern_ipc_perm *sma, int cmd)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sem_semctl, ret);
    ret = lsm_call_backup(security_sem_semctl, sma, cmd);
    lsm_int_hook_after(LSM_TYPE_security_sem_semctl, ret);

    return ret;
}
int lsm_replace(security_sem_semop)(struct kern_ipc_perm *sma, struct sembuf *sops, unsigned nsops, int alter)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sem_semop, ret);
    ret = lsm_call_backup(security_sem_semop, sma, sops, nsops, alter);
    lsm_int_hook_after(LSM_TYPE_security_sem_semop, ret);

    return ret;
}
void lsm_replace(security_d_instantiate)(struct dentry *dentry, struct inode *inode)
{
    lsm_void_hook_before(LSM_TYPE_security_d_instantiate);
    lsm_call_backup(security_d_instantiate, dentry, inode);
    lsm_void_hook_after(LSM_TYPE_security_d_instantiate);
}
int lsm_replace(security_getprocattr)(struct task_struct *p, const char *lsm, char *name, char **value)
{
    // int defrc = -EINVAL;

    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_getprocattr, ret);
    ret = lsm_call_backup(security_getprocattr, p, lsm, name, value);
    lsm_int_hook_after(LSM_TYPE_security_getprocattr, ret);

    return ret;
}
int lsm_replace(security_setprocattr)(const char *lsm, const char *name, void *value, size_t size)
{
    // int defrc = -EINVAL;

    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_setprocattr, ret);
    ret = lsm_call_backup(security_setprocattr, lsm, name, value, size);
    lsm_int_hook_after(LSM_TYPE_security_setprocattr, ret);

    return ret;
}
int lsm_replace(security_netlink_send)(struct sock *sk, struct sk_buff *skb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_netlink_send, ret);
    ret = lsm_call_backup(security_netlink_send, sk, skb);
    lsm_int_hook_after(LSM_TYPE_security_netlink_send, ret);

    return ret;
}
int lsm_replace(security_ismaclabel)(const char *name)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ismaclabel, ret);
    ret = lsm_call_backup(security_ismaclabel, name);
    lsm_int_hook_after(LSM_TYPE_security_ismaclabel, ret);

    return ret;
}
int lsm_replace(security_secid_to_secctx)(u32 secid, char **secdata, u32 *seclen)
{
    // int defrc = -EOPNOTSUPP;

    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_secid_to_secctx, ret);
    ret = lsm_call_backup(security_secid_to_secctx, secid, secdata, seclen);
    lsm_int_hook_after(LSM_TYPE_security_secid_to_secctx, ret);

    return ret;
}
int lsm_replace(security_secctx_to_secid)(const char *secdata, u32 seclen, u32 *secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_secctx_to_secid, ret);
    ret = lsm_call_backup(security_secctx_to_secid, secdata, seclen, secid);
    lsm_int_hook_after(LSM_TYPE_security_secctx_to_secid, ret);

    return ret;
}
void lsm_replace(security_release_secctx)(char *secdata, u32 seclen)
{
    lsm_void_hook_before(LSM_TYPE_security_release_secctx);
    lsm_call_backup(security_release_secctx, secdata, seclen);
    lsm_void_hook_after(LSM_TYPE_security_release_secctx);
}
void lsm_replace(security_inode_invalidate_secctx)(struct inode *inode)
{
    lsm_void_hook_before(LSM_TYPE_security_inode_invalidate_secctx);
    lsm_call_backup(security_inode_invalidate_secctx, inode);
    lsm_void_hook_after(LSM_TYPE_security_inode_invalidate_secctx);
}
int lsm_replace(security_inode_notifysecctx)(struct inode *inode, void *ctx, u32 ctxlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_notifysecctx, ret);
    ret = lsm_call_backup(security_inode_notifysecctx, inode, ctx, ctxlen);
    lsm_int_hook_after(LSM_TYPE_security_inode_notifysecctx, ret);

    return ret;
}
int lsm_replace(security_inode_setsecctx)(struct dentry *dentry, void *ctx, u32 ctxlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_setsecctx, ret);
    ret = lsm_call_backup(security_inode_setsecctx, dentry, ctx, ctxlen);
    lsm_int_hook_after(LSM_TYPE_security_inode_setsecctx, ret);

    return ret;
}
int lsm_replace(security_inode_getsecctx)(struct inode *inode, void **ctx, u32 *ctxlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inode_getsecctx, ret);
    ret = lsm_call_backup(security_inode_getsecctx, inode, ctx, ctxlen);
    lsm_int_hook_after(LSM_TYPE_security_inode_getsecctx, ret);

    return ret;
}

// CONFIG_WATCH_QUEUE
int lsm_replace(security_post_notification)(const struct cred *w_cred, const struct cred *cred,
                                            struct watch_notification *n)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_post_notification, ret);
    ret = lsm_call_backup(security_post_notification, w_cred, cred, n);
    lsm_int_hook_after(LSM_TYPE_security_post_notification, ret);

    return ret;
}

// CONFIG_KEY_NOTIFICATIONS
int lsm_replace(security_watch_key)(struct key *key)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_watch_key, ret);
    ret = lsm_call_backup(security_watch_key, key);
    lsm_int_hook_after(LSM_TYPE_security_watch_key, ret);

    return ret;
}

// CONFIG_SECURITY_NETWORK
int lsm_replace(security_unix_stream_connect)(struct sock *sock, struct sock *other, struct sock *newsk)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_unix_stream_connect, ret);
    ret = lsm_call_backup(security_unix_stream_connect, sock, other, newsk);
    lsm_int_hook_after(LSM_TYPE_security_unix_stream_connect, ret);

    return ret;
}
int lsm_replace(security_unix_may_send)(struct socket *sock, struct socket *other)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_unix_may_send, ret);
    ret = lsm_call_backup(security_unix_may_send, sock, other);
    lsm_int_hook_after(LSM_TYPE_security_unix_may_send, ret);

    return ret;
}
int lsm_replace(security_socket_create)(int family, int type, int protocol, int kern)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_create, ret);
    ret = lsm_call_backup(security_socket_create, family, type, protocol, kern);
    lsm_int_hook_after(LSM_TYPE_security_socket_create, ret);

    return ret;
}
int lsm_replace(security_socket_post_create)(struct socket *sock, int family, int type, int protocol, int kern)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_post_create, ret);
    ret = lsm_call_backup(security_socket_post_create, sock, family, type, protocol, kern);
    lsm_int_hook_after(LSM_TYPE_security_socket_post_create, ret);

    return ret;
}
int lsm_replace(security_socket_socketpair)(struct socket *socka, struct socket *sockb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_socketpair, ret);
    ret = lsm_call_backup(security_socket_socketpair, socka, sockb);
    lsm_int_hook_after(LSM_TYPE_security_socket_socketpair, ret);

    return ret;
}
int lsm_replace(security_socket_bind)(struct socket *sock, struct sockaddr *address, int addrlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_bind, ret);
    ret = lsm_call_backup(security_socket_bind, sock, address, addrlen);
    lsm_int_hook_after(LSM_TYPE_security_socket_bind, ret);

    return ret;
}
int lsm_replace(security_socket_connect)(struct socket *sock, struct sockaddr *address, int addrlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_connect, ret);
    ret = lsm_call_backup(security_socket_connect, sock, address, addrlen);
    lsm_int_hook_after(LSM_TYPE_security_socket_connect, ret);

    return ret;
}
int lsm_replace(security_socket_listen)(struct socket *sock, int backlog)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_listen, ret);
    ret = lsm_call_backup(security_socket_listen, sock, backlog);
    lsm_int_hook_after(LSM_TYPE_security_socket_listen, ret);

    return ret;
}
int lsm_replace(security_socket_accept)(struct socket *sock, struct socket *newsock)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_accept, ret);
    ret = lsm_call_backup(security_socket_accept, sock, newsock);
    lsm_int_hook_after(LSM_TYPE_security_socket_accept, ret);

    return ret;
}
int lsm_replace(security_socket_sendmsg)(struct socket *sock, struct msghdr *msg, int size)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_sendmsg, ret);
    ret = lsm_call_backup(security_socket_sendmsg, sock, msg, size);
    lsm_int_hook_after(LSM_TYPE_security_socket_sendmsg, ret);

    return ret;
}
int lsm_replace(security_socket_recvmsg)(struct socket *sock, struct msghdr *msg, int size, int flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_recvmsg, ret);
    ret = lsm_call_backup(security_socket_recvmsg, sock, msg, size, flags);
    lsm_int_hook_after(LSM_TYPE_security_socket_recvmsg, ret);

    return ret;
}
int lsm_replace(security_socket_getsockname)(struct socket *sock)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_getsockname, ret);
    ret = lsm_call_backup(security_socket_getsockname, sock);
    lsm_int_hook_after(LSM_TYPE_security_socket_getsockname, ret);

    return ret;
}
int lsm_replace(security_socket_getpeername)(struct socket *sock)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_getpeername, ret);
    ret = lsm_call_backup(security_socket_getpeername, sock);
    lsm_int_hook_after(LSM_TYPE_security_socket_getpeername, ret);

    return ret;
}
int lsm_replace(security_socket_getsockopt)(struct socket *sock, int level, int optname)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_getsockopt, ret);
    ret = lsm_call_backup(security_socket_getsockopt, sock, level, optname);
    lsm_int_hook_after(LSM_TYPE_security_socket_getsockopt, ret);

    return ret;
}
int lsm_replace(security_socket_setsockopt)(struct socket *sock, int level, int optname)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_setsockopt, ret);
    ret = lsm_call_backup(security_socket_setsockopt, sock, level, optname);
    lsm_int_hook_after(LSM_TYPE_security_socket_setsockopt, ret);

    return ret;
}
int lsm_replace(security_socket_shutdown)(struct socket *sock, int how)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_shutdown, ret);
    ret = lsm_call_backup(security_socket_shutdown, sock, how);
    lsm_int_hook_after(LSM_TYPE_security_socket_shutdown, ret);

    return ret;
}
int lsm_replace(security_sock_rcv_skb)(struct sock *sk, struct sk_buff *skb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sock_rcv_skb, ret);
    ret = lsm_call_backup(security_sock_rcv_skb, sk, skb);
    lsm_int_hook_after(LSM_TYPE_security_sock_rcv_skb, ret);

    return ret;
}
int lsm_replace(security_socket_getpeersec_stream)(struct socket *sock, sockptr_t optval, sockptr_t optlen,
                                                   unsigned int len)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_getpeersec_stream, ret);
    ret = lsm_call_backup(security_socket_getpeersec_stream, sock, optval, optlen, len);
    lsm_int_hook_after(LSM_TYPE_security_socket_getpeersec_stream, ret);

    return ret;
}
int lsm_replace(security_socket_getpeersec_dgram)(struct socket *sock, struct sk_buff *skb, u32 *secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_socket_getpeersec_dgram, ret);
    ret = lsm_call_backup(security_socket_getpeersec_dgram, sock, skb, secid);
    lsm_int_hook_after(LSM_TYPE_security_socket_getpeersec_dgram, ret);

    return ret;
}
int lsm_replace(security_sk_alloc)(struct sock *sk, int family, gfp_t priority)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sk_alloc, ret);
    ret = lsm_call_backup(security_sk_alloc, sk, family, priority);
    lsm_int_hook_after(LSM_TYPE_security_sk_alloc, ret);

    return ret;
}
void lsm_replace(security_sk_free)(struct sock *sk)
{
    lsm_void_hook_before(LSM_TYPE_security_sk_free);
    lsm_call_backup(security_sk_free, sk);
    lsm_void_hook_after(LSM_TYPE_security_sk_free);
}
void lsm_replace(security_sk_clone)(const struct sock *sk, struct sock *newsk)
{
    lsm_void_hook_before(LSM_TYPE_security_sk_clone);
    lsm_call_backup(security_sk_clone, sk, newsk);
    lsm_void_hook_after(LSM_TYPE_security_sk_clone);
}
void lsm_replace(security_sk_classify_flow)(struct sock *sk, struct flowi_common *flic)
{
    lsm_void_hook_before(LSM_TYPE_security_sk_classify_flow);
    lsm_call_backup(security_sk_classify_flow, sk, flic);
    lsm_void_hook_after(LSM_TYPE_security_sk_classify_flow);
}
void lsm_replace(security_req_classify_flow)(const struct request_sock *req, struct flowi_common *flic)
{
    lsm_void_hook_before(LSM_TYPE_security_req_classify_flow);
    lsm_call_backup(security_req_classify_flow, req, flic);
    lsm_void_hook_after(LSM_TYPE_security_req_classify_flow);
}
void lsm_replace(security_sock_graft)(struct sock *sk, struct socket *parent)
{
    lsm_void_hook_before(LSM_TYPE_security_sock_graft);
    lsm_call_backup(security_sock_graft, sk, parent);
    lsm_void_hook_after(LSM_TYPE_security_sock_graft);
}
int lsm_replace(security_inet_conn_request)(const struct sock *sk, struct sk_buff *skb, struct request_sock *req)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_inet_conn_request, ret);
    ret = lsm_call_backup(security_inet_conn_request, sk, skb, req);
    lsm_int_hook_after(LSM_TYPE_security_inet_conn_request, ret);

    return ret;
}
void lsm_replace(security_inet_csk_clone)(struct sock *newsk, const struct request_sock *req)
{
    lsm_void_hook_before(LSM_TYPE_security_inet_csk_clone);
    lsm_call_backup(security_inet_csk_clone, newsk, req);
    lsm_void_hook_after(LSM_TYPE_security_inet_csk_clone);
}
void lsm_replace(security_inet_conn_established)(struct sock *sk, struct sk_buff *skb)
{
    lsm_void_hook_before(LSM_TYPE_security_inet_conn_established);
    lsm_call_backup(security_inet_conn_established, sk, skb);
    lsm_void_hook_after(LSM_TYPE_security_inet_conn_established);
}
int lsm_replace(security_secmark_relabel_packet)(u32 secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_secmark_relabel_packet, ret);
    ret = lsm_call_backup(security_secmark_relabel_packet, secid);
    lsm_int_hook_after(LSM_TYPE_security_secmark_relabel_packet, ret);

    return ret;
}
void lsm_replace(security_secmark_refcount_inc)(void)
{
    lsm_void_hook_before(LSM_TYPE_security_secmark_refcount_inc);
    lsm_call_backup(security_secmark_refcount_inc, );
    lsm_void_hook_after(LSM_TYPE_security_secmark_refcount_inc);
}

void lsm_replace(security_secmark_refcount_dec)(void)
{
    lsm_void_hook_before(LSM_TYPE_security_secmark_refcount_dec);
    lsm_call_backup(security_secmark_refcount_dec);
    lsm_void_hook_after(LSM_TYPE_security_secmark_refcount_dec);
}
int lsm_replace(security_tun_dev_alloc_security)(void **security)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_tun_dev_alloc_security, ret);
    ret = lsm_call_backup(security_tun_dev_alloc_security, security);
    lsm_int_hook_after(LSM_TYPE_security_tun_dev_alloc_security, ret);

    return ret;
}
void lsm_replace(security_tun_dev_free_security)(void *security)
{
    lsm_void_hook_before(LSM_TYPE_security_tun_dev_free_security);
    lsm_call_backup(security_tun_dev_free_security, security);
    lsm_void_hook_after(LSM_TYPE_security_tun_dev_free_security);
}

int lsm_replace(security_tun_dev_create)(void)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_tun_dev_create, ret);
    ret = lsm_call_backup(security_tun_dev_create);
    lsm_int_hook_after(LSM_TYPE_security_tun_dev_create, ret);
    return ret;
}

int lsm_replace(security_tun_dev_attach_queue)(void *security)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_tun_dev_attach_queue, ret);
    ret = lsm_call_backup(security_tun_dev_attach_queue, security);
    lsm_int_hook_after(LSM_TYPE_security_tun_dev_attach_queue, ret);
    return ret;
}

int lsm_replace(security_tun_dev_attach)(struct sock *sk, void *security)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_tun_dev_attach, ret);
    ret = lsm_call_backup(security_tun_dev_attach, sk, security);
    lsm_int_hook_after(LSM_TYPE_security_tun_dev_attach, ret);
    return ret;
}

int lsm_replace(security_tun_dev_open)(void *security)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_tun_dev_open, ret);
    ret = lsm_call_backup(security_tun_dev_open, security);
    lsm_int_hook_after(LSM_TYPE_security_tun_dev_open, ret);
    return ret;
}

int lsm_replace(security_sctp_assoc_request)(struct sctp_association *asoc, struct sk_buff *skb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sctp_assoc_request, ret);
    ret = lsm_call_backup(security_sctp_assoc_request, asoc, skb);
    lsm_int_hook_after(LSM_TYPE_security_sctp_assoc_request, ret);
    return ret;
}

int lsm_replace(security_sctp_bind_connect)(struct sock *sk, int optname, struct sockaddr *address, int addrlen)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sctp_bind_connect, ret);
    ret = lsm_call_backup(security_sctp_bind_connect, sk, optname, address, addrlen);
    lsm_int_hook_after(LSM_TYPE_security_sctp_bind_connect, ret);
    return ret;
}

void lsm_replace(security_sctp_sk_clone)(struct sctp_association *asoc, struct sock *sk, struct sock *newsk)
{
    lsm_void_hook_before(LSM_TYPE_security_sctp_sk_clone);
    lsm_call_backup(security_sctp_sk_clone, asoc, sk, newsk);
    lsm_void_hook_after(LSM_TYPE_security_sctp_sk_clone);
}

int lsm_replace(security_sctp_assoc_established)(struct sctp_association *asoc, struct sk_buff *skb)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_sctp_assoc_established, ret);
    ret = lsm_call_backup(security_sctp_assoc_established, asoc, skb);
    lsm_int_hook_after(LSM_TYPE_security_sctp_assoc_established, ret);
    return ret;
}

// CONFIG_SECURITY_INFINIBAND
int lsm_replace(security_ib_pkey_access)(void *sec, u64 subnet_prefix, u16 pkey)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ib_pkey_access, ret);
    ret = lsm_call_backup(security_ib_pkey_access, sec, subnet_prefix, pkey);
    lsm_int_hook_after(LSM_TYPE_security_ib_pkey_access, ret);
    return ret;
}
int lsm_replace(security_ib_endport_manage_subnet)(void *sec, const char *dev_name, u8 port_num)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ib_endport_manage_subnet, ret);
    ret = lsm_call_backup(security_ib_endport_manage_subnet, sec, dev_name, port_num);
    lsm_int_hook_after(LSM_TYPE_security_ib_endport_manage_subnet, ret);

    return ret;
}
int lsm_replace(security_ib_alloc_security)(void **sec)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_ib_alloc_security, ret);
    ret = lsm_call_backup(security_ib_alloc_security, sec);
    lsm_int_hook_after(LSM_TYPE_security_ib_alloc_security, ret);
    return ret;
}

void lsm_replace(security_ib_free_security)(void *sec)
{
    lsm_void_hook_before(LSM_TYPE_security_ib_free_security);
    lsm_call_backup(security_ib_free_security, sec);
    lsm_void_hook_after(LSM_TYPE_security_ib_free_security);
}

// CONFIG_SECURITY_NETWORK_XFRM
int lsm_replace(security_xfrm_policy_alloc)(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_policy_alloc, ret);
    ret = lsm_call_backup(security_xfrm_policy_alloc, ctxp, sec_ctx, gfp);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_policy_alloc, ret);
    return ret;
}

int lsm_replace(security_xfrm_policy_clone)(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_policy_clone, ret);
    ret = lsm_call_backup(security_xfrm_policy_clone, old_ctx, new_ctxp);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_policy_clone, ret);
    return ret;
}

void lsm_replace(security_xfrm_policy_free)(struct xfrm_sec_ctx *ctx)
{
    lsm_void_hook_before(LSM_TYPE_security_xfrm_policy_free);
    lsm_call_backup(security_xfrm_policy_free, ctx);
    lsm_void_hook_after(LSM_TYPE_security_xfrm_policy_free);
}

int lsm_replace(security_xfrm_policy_delete)(struct xfrm_sec_ctx *ctx)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_policy_delete, ret);
    ret = lsm_call_backup(security_xfrm_policy_delete, ctx);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_policy_delete, ret);
    return ret;
}

int lsm_replace(security_xfrm_state_alloc)(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_state_alloc, ret);
    ret = lsm_call_backup(security_xfrm_state_alloc, x, sec_ctx);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_state_alloc, ret);
    return ret;
}

int lsm_replace(security_xfrm_state_alloc_acquire)(struct xfrm_state *x, struct xfrm_sec_ctx *polsec, u32 secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_state_alloc_acquire, ret);
    ret = lsm_call_backup(security_xfrm_state_alloc_acquire, x, polsec, secid);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_state_alloc_acquire, ret);
    return ret;
}

int lsm_replace(security_xfrm_state_delete)(struct xfrm_state *x)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_state_delete, ret);
    ret = lsm_call_backup(security_xfrm_state_delete, x);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_state_delete, ret);
    return ret;
}

void lsm_replace(security_xfrm_state_free)(struct xfrm_state *x)
{
    lsm_void_hook_before(LSM_TYPE_security_xfrm_state_free);
    lsm_call_backup(security_xfrm_state_free, x);
    lsm_void_hook_after(LSM_TYPE_security_xfrm_state_free);
}

int lsm_replace(security_xfrm_policy_lookup)(struct xfrm_sec_ctx *ctx, u32 fl_secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_policy_lookup, ret);
    ret = lsm_call_backup(security_xfrm_policy_lookup, ctx, fl_secid);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_policy_lookup, ret);
    return ret;
}

int lsm_replace(security_xfrm_state_pol_flow_match)(struct xfrm_state *x, struct xfrm_policy *xp,
                                                    const struct flowi_common *flic)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_state_pol_flow_match, ret);
    ret = lsm_call_backup(security_xfrm_state_pol_flow_match, x, xp, flic);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_state_pol_flow_match, ret);
    return ret;
}

int lsm_replace(security_xfrm_decode_session)(struct sk_buff *skb, u32 *secid)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_xfrm_decode_session, ret);
    ret = lsm_call_backup(security_xfrm_decode_session, skb, secid);
    lsm_int_hook_after(LSM_TYPE_security_xfrm_decode_session, ret);
    return ret;
}

void lsm_replace(security_skb_classify_flow)(struct sk_buff *skb, struct flowi_common *flic)
{
    lsm_void_hook_before(LSM_TYPE_security_skb_classify_flow);
    lsm_call_backup(security_skb_classify_flow, skb, flic);
    lsm_void_hook_after(LSM_TYPE_security_skb_classify_flow);
}

/* key management security hooks */
// CONFIG_KEYS
int lsm_replace(security_key_alloc)(struct key *key, const struct cred *cred, unsigned long flags)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_key_alloc, ret);
    ret = lsm_call_backup(security_key_alloc, key, cred, flags);
    lsm_int_hook_after(LSM_TYPE_security_key_alloc, ret);
    return ret;
}

void lsm_replace(security_key_free)(struct key *key)
{
    lsm_void_hook_before(LSM_TYPE_security_key_free);
    lsm_call_backup(security_key_free, key);
    lsm_void_hook_after(LSM_TYPE_security_key_free);
}

int lsm_replace(security_key_permission)(key_ref_t key_ref, const struct cred *cred, enum key_need_perm need_perm)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_key_permission, ret);
    ret = lsm_call_backup(security_key_permission, key_ref, cred, need_perm);
    lsm_int_hook_after(LSM_TYPE_security_key_permission, ret);
    return ret;
}

int lsm_replace(security_key_getsecurity)(struct key *key, char **_buffer)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_key_getsecurity, ret);
    ret = lsm_call_backup(security_key_getsecurity, key, _buffer);
    lsm_int_hook_after(LSM_TYPE_security_key_getsecurity, ret);
    return ret;
}

// CONFIG_AUDIT
int lsm_replace(security_audit_rule_init)(u32 field, u32 op, char *rulestr, void **lsmrule)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_audit_rule_init, ret);
    ret = lsm_call_backup(security_audit_rule_init, field, op, rulestr, lsmrule);
    lsm_int_hook_after(LSM_TYPE_security_audit_rule_init, ret);

    return ret;
}
int lsm_replace(security_audit_rule_known)(struct audit_krule *krule)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_audit_rule_known, ret);
    ret = lsm_call_backup(security_audit_rule_known, krule);
    lsm_int_hook_after(LSM_TYPE_security_audit_rule_known, ret);

    return ret;
}
void lsm_replace(security_audit_rule_free)(void *lsmrule)
{
    lsm_void_hook_before(LSM_TYPE_security_audit_rule_free);
    lsm_call_backup(security_audit_rule_free, lsmrule);
    lsm_void_hook_after(LSM_TYPE_security_audit_rule_free);
}
int lsm_replace(security_audit_rule_match)(u32 secid, u32 field, u32 op, void *lsmrule)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_audit_rule_match, ret);
    ret = lsm_call_backup(security_audit_rule_match, secid, field, op, lsmrule);
    lsm_int_hook_after(LSM_TYPE_security_audit_rule_match, ret);

    return ret;
}

// CONFIG_BPF_SYSCALL
int lsm_replace(security_bpf)(int cmd, union bpf_attr *attr, unsigned int size)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bpf, ret);
    ret = lsm_call_backup(security_bpf, cmd, attr, size);
    lsm_int_hook_after(LSM_TYPE_security_bpf, ret);

    return ret;
}
int lsm_replace(security_bpf_map)(struct bpf_map *map, fmode_t fmode)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bpf_map, ret);
    ret = lsm_call_backup(security_bpf_map, map, fmode);
    lsm_int_hook_after(LSM_TYPE_security_bpf_map, ret);

    return ret;
}
int lsm_replace(security_bpf_prog)(struct bpf_prog *prog)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bpf_prog, ret);
    ret = lsm_call_backup(security_bpf_prog, prog);
    lsm_int_hook_after(LSM_TYPE_security_bpf_prog, ret);

    return ret;
}
int lsm_replace(security_bpf_map_alloc)(struct bpf_map *map)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bpf_map_alloc, ret);
    ret = lsm_call_backup(security_bpf_map_alloc, map);
    lsm_int_hook_after(LSM_TYPE_security_bpf_map_alloc, ret);

    return ret;
}
int lsm_replace(security_bpf_prog_alloc)(struct bpf_prog_aux *aux)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_bpf_prog_alloc, ret);
    ret = lsm_call_backup(security_bpf_prog_alloc, aux);
    lsm_int_hook_after(LSM_TYPE_security_bpf_prog_alloc, ret);

    return ret;
}
void lsm_replace(security_bpf_map_free)(struct bpf_map *map)
{
    lsm_void_hook_before(LSM_TYPE_security_bpf_map_free);
    lsm_call_backup(security_bpf_map_free, map);
    lsm_void_hook_after(LSM_TYPE_security_bpf_map_free);
}
void lsm_replace(security_bpf_prog_free)(struct bpf_prog_aux *aux)
{
    lsm_void_hook_before(LSM_TYPE_security_bpf_prog_free);
    lsm_call_backup(security_bpf_prog_free, aux);
    lsm_void_hook_after(LSM_TYPE_security_bpf_prog_free);
}
// CONFIG_BPF_SYSCALL

int lsm_replace(security_locked_down)(enum lockdown_reason what)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_locked_down, ret);
    ret = lsm_call_backup(security_locked_down, what);
    lsm_int_hook_after(LSM_TYPE_security_locked_down, ret);

    return ret;
}

// CONFIG_PERF_EVENTS
int lsm_replace(security_perf_event_open)(struct perf_event_attr *attr, int type)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_perf_event_open, ret);
    ret = lsm_call_backup(security_perf_event_open, attr, type);
    lsm_int_hook_after(LSM_TYPE_security_perf_event_open, ret);

    return ret;
}
int lsm_replace(security_perf_event_alloc)(struct perf_event *event)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_perf_event_alloc, ret);
    ret = lsm_call_backup(security_perf_event_alloc, event);
    lsm_int_hook_after(LSM_TYPE_security_perf_event_alloc, ret);

    return ret;
}
void lsm_replace(security_perf_event_free)(struct perf_event *event)
{
    lsm_void_hook_before(LSM_TYPE_security_perf_event_free);
    lsm_call_backup(security_perf_event_free, event);
    lsm_void_hook_after(LSM_TYPE_security_perf_event_free);
}
int lsm_replace(security_perf_event_read)(struct perf_event *event)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_perf_event_read, ret);
    ret = lsm_call_backup(security_perf_event_read, event);
    lsm_int_hook_after(LSM_TYPE_security_perf_event_read, ret);

    return ret;
}
int lsm_replace(security_perf_event_write)(struct perf_event *event)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_perf_event_write, ret);
    ret = lsm_call_backup(security_perf_event_write, event);
    lsm_int_hook_after(LSM_TYPE_security_perf_event_write, ret);

    return ret;
}

// CONFIG_IO_URING
int lsm_replace(security_uring_override_creds)(const struct cred *new)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_uring_override_creds, ret);
    ret = lsm_call_backup(security_uring_override_creds, new);
    lsm_int_hook_after(LSM_TYPE_security_uring_override_creds, ret);

    return ret;
}
int lsm_replace(security_uring_sqpoll)(void)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_uring_sqpoll, ret);
    ret = lsm_call_backup(security_uring_sqpoll);
    lsm_int_hook_after(LSM_TYPE_security_uring_sqpoll, ret);
    return ret;
}
int lsm_replace(security_uring_cmd)(struct io_uring_cmd *ioucmd)
{
    int ret = 0;
    lsm_int_hook_before(LSM_TYPE_security_uring_cmd, ret);
    ret = lsm_call_backup(security_uring_cmd, ioucmd);
    lsm_int_hook_after(LSM_TYPE_security_uring_cmd, ret);
    return ret;
}

int lsm_hook_install()
{
    // Security hooks for program execution operations.
    lsm_hook(security_binder_set_context_mgr);
    lsm_hook(security_binder_transaction);
    lsm_hook(security_binder_transfer_binder);
    lsm_hook(security_binder_transfer_file);
    lsm_hook(security_ptrace_access_check);
    lsm_hook(security_ptrace_traceme);
    lsm_hook(security_capget);
    lsm_hook(security_capset);
    lsm_hook(security_capable);
    lsm_hook(security_quotactl);
    lsm_hook(security_quota_on);
    lsm_hook(security_syslog);
    lsm_hook(security_settime64);
    lsm_hook(security_vm_enough_memory_mm);
    lsm_hook(security_bprm_creds_for_exec);
    lsm_hook(security_bprm_creds_from_file);
    lsm_hook(security_bprm_check);
    lsm_hook(security_bprm_committing_creds);
    lsm_hook(security_bprm_committed_creds);

    // Security hooks for mount using fs_context.
    lsm_hook(security_fs_context_dup);
    lsm_hook(security_fs_context_parse_param);

    // Security hooks for filesystem operations.
    lsm_hook(security_sb_alloc);
    lsm_hook(security_sb_delete);
    lsm_hook(security_sb_free);
    lsm_hook(security_free_mnt_opts);
    lsm_hook(security_sb_eat_lsm_opts);
    lsm_hook(security_sb_remount);
    lsm_hook(security_sb_kern_mount);
    lsm_hook(security_sb_show_options);
    lsm_hook(security_sb_statfs);
    lsm_hook(security_sb_mount);
    lsm_hook(security_sb_umount);
    lsm_hook(security_sb_pivotroot);
    lsm_hook(security_sb_set_mnt_opts);
    lsm_hook(security_sb_clone_mnt_opts);
    lsm_hook(security_add_mnt_opt);
    lsm_hook(security_move_mount);
    lsm_hook(security_dentry_init_security);
    lsm_hook(security_dentry_create_files_as);

    // //CONFIG_SECURITY_PATH
    lsm_hook(security_path_unlink);
    lsm_hook(security_path_mkdir);
    lsm_hook(security_path_rmdir);
    lsm_hook(security_path_mknod);
    lsm_hook(security_path_truncate);
    lsm_hook(security_path_symlink);
    lsm_hook(security_path_link);
    lsm_hook(security_path_rename);
    lsm_hook(security_path_chmod);
    lsm_hook(security_path_chown);
    lsm_hook(security_path_chroot);
    /* CONFIG_SECURITY_PATH */

    /* Needed for inode based security check */
    lsm_hook(security_path_notify);
    lsm_hook(security_inode_alloc);
    lsm_hook(security_inode_free);
    lsm_hook(security_inode_init_security);
    lsm_hook(security_old_inode_init_security);
    lsm_hook(security_inode_create);
    lsm_hook(security_inode_link);
    lsm_hook(security_inode_unlink);
    lsm_hook(security_inode_symlink);
    lsm_hook(security_inode_mkdir);
    lsm_hook(security_inode_rmdir);
    lsm_hook(security_inode_mknod);
    lsm_hook(security_inode_rename);
    lsm_hook(security_inode_readlink);
    lsm_hook(security_inode_follow_link);
    lsm_hook(security_inode_permission);
    lsm_hook(security_inode_setattr);
    lsm_hook(security_inode_getattr);
    lsm_hook(security_inode_setxattr);
    lsm_hook(security_inode_post_setxattr);
    lsm_hook(security_inode_getxattr);
    lsm_hook(security_inode_listxattr);
    lsm_hook(security_inode_removexattr);
    lsm_hook(security_inode_set_acl);
    lsm_hook(security_inode_get_acl);
    lsm_hook(security_inode_remove_acl);
    lsm_hook(security_inode_need_killpriv);
    lsm_hook(security_inode_killpriv);
    lsm_hook(security_inode_getsecurity);
    lsm_hook(security_inode_setsecurity);
    lsm_hook(security_inode_listsecurity);
    lsm_hook(security_inode_getsecid);
    lsm_hook(security_inode_copy_up);
    lsm_hook(security_inode_copy_up_xattr);
    lsm_hook(security_kernfs_init_security);
    lsm_hook(security_file_permission);
    lsm_hook(security_file_alloc);
    lsm_hook(security_file_free);
    lsm_hook(security_file_ioctl);
    lsm_hook(security_mmap_addr);
    lsm_hook(security_mmap_file);
    lsm_hook(security_file_mprotect);
    lsm_hook(security_file_lock);
    lsm_hook(security_file_fcntl);
    lsm_hook(security_file_set_fowner);
    lsm_hook(security_file_send_sigiotask);
    lsm_hook(security_file_receive);
    lsm_hook(security_file_open);
    lsm_hook(security_file_truncate);
    lsm_hook(security_task_alloc);
    lsm_hook(security_task_free);
    lsm_hook(security_cred_alloc_blank);
    lsm_hook(security_cred_free);
    lsm_hook(security_prepare_creds);
    lsm_hook(security_transfer_creds);
    lsm_hook(security_cred_getsecid);
    lsm_hook(security_kernel_act_as);
    lsm_hook(security_kernel_create_files_as);
    lsm_hook(security_kernel_module_request);
    lsm_hook(security_kernel_load_data);
    lsm_hook(security_kernel_post_load_data);
    lsm_hook(security_kernel_read_file);
    lsm_hook(security_kernel_post_read_file);
    lsm_hook(security_task_fix_setuid);
    lsm_hook(security_task_fix_setgid);
    lsm_hook(security_task_fix_setgroups);
    lsm_hook(security_task_setpgid);
    lsm_hook(security_task_getpgid);
    lsm_hook(security_task_getsid);
    lsm_hook(security_current_getsecid_subj);
    lsm_hook(security_task_getsecid_obj);
    lsm_hook(security_task_getsecid);
    lsm_hook(security_task_setnice);
    lsm_hook(security_task_setioprio);
    lsm_hook(security_task_getioprio);
    lsm_hook(security_task_prlimit);
    lsm_hook(security_task_setrlimit);
    lsm_hook(security_task_setscheduler);
    lsm_hook(security_task_getscheduler);
    lsm_hook(security_task_movememory);
    lsm_hook(security_task_kill);
    lsm_hook(security_task_prctl);
    lsm_hook(security_task_to_inode);
    lsm_hook(security_create_user_ns);
    lsm_hook(security_ipc_permission);
    lsm_hook(security_ipc_getsecid);
    lsm_hook(security_msg_msg_alloc);
    lsm_hook(security_msg_msg_free);
    lsm_hook(security_msg_queue_alloc);
    lsm_hook(security_msg_queue_free);
    lsm_hook(security_msg_queue_associate);
    lsm_hook(security_msg_queue_msgctl);
    lsm_hook(security_msg_queue_msgsnd);
    lsm_hook(security_msg_queue_msgrcv);
    lsm_hook(security_shm_alloc);
    lsm_hook(security_shm_free);
    lsm_hook(security_shm_associate);
    lsm_hook(security_shm_shmctl);
    lsm_hook(security_shm_shmat);
    lsm_hook(security_sem_alloc);
    lsm_hook(security_sem_free);
    lsm_hook(security_sem_associate);
    lsm_hook(security_sem_semctl);
    lsm_hook(security_sem_semop);
    lsm_hook(security_d_instantiate);
    lsm_hook(security_getprocattr);
    lsm_hook(security_setprocattr);
    lsm_hook(security_netlink_send);
    lsm_hook(security_ismaclabel);
    lsm_hook(security_secid_to_secctx);
    lsm_hook(security_secctx_to_secid);
    lsm_hook(security_release_secctx);
    lsm_hook(security_inode_invalidate_secctx);
    lsm_hook(security_inode_notifysecctx);
    lsm_hook(security_inode_setsecctx);
    lsm_hook(security_inode_getsecctx);

    // CONFIG_WATCH_QUEUE
    lsm_hook(security_post_notification);

    // CONFIG_KEY_NOTIFICATIONS
    lsm_hook(security_watch_key);

    // CONFIG_SECURITY_NETWORK
    lsm_hook(security_unix_stream_connect);
    lsm_hook(security_unix_may_send);
    lsm_hook(security_socket_create);
    lsm_hook(security_socket_post_create);
    lsm_hook(security_socket_socketpair);
    lsm_hook(security_socket_bind);
    lsm_hook(security_socket_connect);
    lsm_hook(security_socket_listen);
    lsm_hook(security_socket_accept);
    lsm_hook(security_socket_sendmsg);
    lsm_hook(security_socket_recvmsg);
    lsm_hook(security_socket_getsockname);
    lsm_hook(security_socket_getpeername);
    lsm_hook(security_socket_getsockopt);
    lsm_hook(security_socket_setsockopt);
    lsm_hook(security_socket_shutdown);
    lsm_hook(security_sock_rcv_skb);
    lsm_hook(security_socket_getpeersec_stream);
    lsm_hook(security_socket_getpeersec_dgram);
    lsm_hook(security_sk_alloc);
    lsm_hook(security_sk_free);
    lsm_hook(security_sk_clone);
    lsm_hook(security_sk_classify_flow);
    lsm_hook(security_req_classify_flow);
    lsm_hook(security_sock_graft);
    lsm_hook(security_inet_conn_request);
    lsm_hook(security_inet_csk_clone);
    lsm_hook(security_inet_conn_established);
    lsm_hook(security_secmark_relabel_packet);
    lsm_hook(security_secmark_refcount_inc);
    lsm_hook(security_secmark_refcount_dec);
    lsm_hook(security_tun_dev_alloc_security);
    lsm_hook(security_tun_dev_free_security);
    lsm_hook(security_tun_dev_create);
    lsm_hook(security_tun_dev_attach_queue);
    lsm_hook(security_tun_dev_attach);
    lsm_hook(security_tun_dev_open);
    lsm_hook(security_sctp_assoc_request);
    lsm_hook(security_sctp_bind_connect);
    lsm_hook(security_sctp_sk_clone);
    lsm_hook(security_sctp_assoc_established);

    // CONFIG_SECURITY_INFINIBAND
    lsm_hook(security_ib_pkey_access);
    lsm_hook(security_ib_endport_manage_subnet);
    lsm_hook(security_ib_alloc_security);
    lsm_hook(security_ib_free_security);

    // CONFIG_SECURITY_NETWORK_XFRM
    lsm_hook(security_xfrm_policy_alloc);
    lsm_hook(security_xfrm_policy_clone);
    lsm_hook(security_xfrm_policy_free);
    lsm_hook(security_xfrm_policy_delete);
    lsm_hook(security_xfrm_state_alloc);
    lsm_hook(security_xfrm_state_alloc_acquire);
    lsm_hook(security_xfrm_state_delete);
    lsm_hook(security_xfrm_state_free);
    lsm_hook(security_xfrm_policy_lookup);
    lsm_hook(security_xfrm_state_pol_flow_match);
    lsm_hook(security_xfrm_decode_session);
    lsm_hook(security_skb_classify_flow);

    /* key management security hooks */
    // CONFIG_KEYS
    lsm_hook(security_key_alloc);
    lsm_hook(security_key_free);
    lsm_hook(security_key_permission);
    lsm_hook(security_key_getsecurity);

    // CONFIG_AUDIT
    lsm_hook(security_audit_rule_init);
    lsm_hook(security_audit_rule_known);
    lsm_hook(security_audit_rule_free);
    lsm_hook(security_audit_rule_match);

    // CONFIG_BPF_SYSCALL
    lsm_hook(security_bpf);
    lsm_hook(security_bpf_map);
    lsm_hook(security_bpf_prog);
    lsm_hook(security_bpf_map_alloc);
    lsm_hook(security_bpf_prog_alloc);
    lsm_hook(security_bpf_map_free);
    lsm_hook(security_bpf_prog_free);
    // CONFIG_BPF_SYSCALL

    lsm_hook(security_locked_down);

    // CONFIG_PERF_EVENTS
    lsm_hook(security_perf_event_open);
    lsm_hook(security_perf_event_alloc);
    lsm_hook(security_perf_event_free);
    lsm_hook(security_perf_event_read);
    lsm_hook(security_perf_event_write);

    // CONFIG_IO_URING
    lsm_hook(security_uring_override_creds);
    lsm_hook(security_uring_sqpoll);
    lsm_hook(security_uring_cmd);

    return 0;
}

```

`kernel/init/accctl/selinuxhook.c`:

```c
#include "accctl.h"

#include <hook.h>
#include <log.h>
#include <ksyms.h>
#include <taskext.h>
#include <linux/sched/task.h>
#include <asm/current.h>
#include <minc/string.h>
#include <security/selinux/include/avc.h>
#include <security/selinux/include/security.h>

#define hook_compat_replace(func) compat_replace_##func
#define hook_compat_backup(func) (*compat_backup_##func)
#define hook_compat_call_backup(func, ...) compat_backup_##func(__VA_ARGS__)
#define hook_compat_kfunc(func) hook_kfunc_with(func, compat_replace_##func, compat_backup_##func)

int hook_backup(avc_denied)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 xperm, unsigned int flags,
                            struct av_decision *avd) = 0;
int hook_backup(avc_has_perm_noaudit)(u32 ssid, u32 tsid, u16 tclass, u32 requested, unsigned flags,
                                      struct av_decision *avd) = 0;
int hook_backup(avc_has_perm)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata) = 0;
int hook_backup(avc_has_perm_flags)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata,
                                    int flags) = 0;
int hook_backup(avc_has_extended_perms)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 perm,
                                        struct common_audit_data *ad) = 0;

int hook_compat_backup(avc_denied)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                   u8 driver, u8 xperm, unsigned int flags, struct av_decision *avd) = 0;
int hook_compat_backup(avc_has_perm_noaudit)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                             unsigned flags, struct av_decision *avd) = 0;
int hook_compat_backup(avc_has_perm)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                     struct common_audit_data *auditdata) = 0;
int hook_compat_backup(avc_has_perm_flags)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                           struct common_audit_data *auditdata, int flags) = 0;
int hook_compat_backup(avc_has_extended_perms)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                               u32 requested, u8 driver, u8 perm, struct common_audit_data *ad) = 0;

#define SHOW_AVC_PASS_LOG

#if 0
static void _selinux_debug(u32 ssid, u32 tsid, u16 tclass, u32 requested)
{
    logkfd("ssid: %x, tsid: %x, tclass: %x, requested: %x\n", ssid, tsid, tclass, requested);
    char *scontext = 0;
    u32 sctx_len = 0;
    char *tcontext = 0;
    u32 tctx_len = 0;
    security_sid_to_context(ssid, &scontext, &sctx_len);
    security_sid_to_context(tsid, &tcontext, &tctx_len);
    const char *stclass = kvar_val(secclass_map)[tclass - 1].name;
    const char *const *perms = kvar_val(secclass_map)[tclass - 1].perms;
    char buf[128] = { '\0' };
    for (int i = 0; i < (sizeof(u32) * 8); i++) {
        if ((1 << i) & requested) {
            int len = min_strlen(buf);
            min_snprintf(buf + len, 128 - len, "%s ", perms[i]);
        }
    }
    logkfd("context: %s, tcontext: %s, tclass: %s, perms: %s\n", scontext, tcontext, stclass, buf);
}
#endif

#define HOOK_AVC_BEFORE()                            \
    struct task_ext *ext = get_current_task_ext();   \
    if (task_ext_valid(ext) && ext->selinux_allow) { \
        return 0;                                    \
    }

// #define HOOK_AVC_BEFORE()

int hook_replace(avc_denied)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 xperm, unsigned int flags,
                             struct av_decision *avd)
{
    HOOK_AVC_BEFORE();
    int rc = hook_call_backup(avc_denied, ssid, tsid, tclass, requested, driver, xperm, flags, avd);
    return rc;
}

int hook_replace(avc_has_perm_noaudit)(u32 ssid, u32 tsid, u16 tclass, u32 requested, unsigned flags,
                                       struct av_decision *avd)
{
    HOOK_AVC_BEFORE();
    int rc = hook_call_backup(avc_has_perm_noaudit, ssid, tsid, tclass, requested, flags, avd);
    return rc;
}

int hook_replace(avc_has_perm)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata)
{
    HOOK_AVC_BEFORE();
    int rc = hook_call_backup(avc_has_perm, ssid, tsid, tclass, requested, auditdata);
    return rc;
}

int hook_replace(avc_has_perm_flags)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata,
                                     int flags)
{
    HOOK_AVC_BEFORE();
    int rc = hook_call_backup(avc_has_perm_flags, ssid, tsid, tclass, requested, auditdata, flags);
    return rc;
}

int hook_replace(avc_has_extended_perms)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 perm,
                                         struct common_audit_data *ad)
{
    HOOK_AVC_BEFORE();
    int rc = hook_call_backup(avc_has_extended_perms, ssid, tsid, tclass, requested, driver, perm, ad);
    return rc;
}

//

#include <linux/printk.h>

int hook_compat_replace(avc_denied)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                    u8 driver, u8 xperm, unsigned int flags, struct av_decision *avd)
{
    struct task_ext *ext = get_current_task_ext();
    if (task_ext_valid(ext) && ext->selinux_allow) {
        dump_stack();
        return 0;
    }
    // HOOK_AVC_BEFORE();
    int rc = hook_compat_call_backup(avc_denied, state, ssid, tsid, tclass, requested, driver, xperm, flags, avd);
    return rc;
}

int hook_compat_replace(avc_has_perm_noaudit)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                              u32 requested, unsigned flags, struct av_decision *avd)
{
    HOOK_AVC_BEFORE();
    int rc = hook_compat_call_backup(avc_has_perm_noaudit, state, ssid, tsid, tclass, requested, flags, avd);
    return rc;
}

int hook_compat_replace(avc_has_perm)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                      struct common_audit_data *auditdata)
{
    HOOK_AVC_BEFORE();
    int rc = hook_compat_call_backup(avc_has_perm, state, ssid, tsid, tclass, requested, auditdata);
    return rc;
}

int hook_compat_replace(avc_has_perm_flags)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                            struct common_audit_data *auditdata, int flags)
{
    HOOK_AVC_BEFORE();
    int rc = hook_compat_call_backup(avc_has_perm_flags, state, ssid, tsid, tclass, requested, auditdata, flags);
    return rc;
}

int hook_compat_replace(avc_has_extended_perms)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                u32 requested, u8 driver, u8 perm, struct common_audit_data *ad)
{
    HOOK_AVC_BEFORE();
    int rc = hook_compat_call_backup(avc_has_extended_perms, state, ssid, tsid, tclass, requested, driver, perm, ad);
    return rc;
}

void hook_backup(security_compute_av)(void *_state, void *_ssid, void *_tsid, void *_orig_tclass, void *_avd,
                                      void *_xperms) = 0;

// struct selinux_state *state, u32 ssid, u32 tsid, u16 orig_tclass, struct av_decision *avd, struct extended_perms *xperms
void hook_replace(security_compute_av)(void *_state, void *_ssid, void *_tsid, void *_orig_tclass, void *_avd,
                                       void *_xperms)
{
    hook_call_backup(security_compute_av, _state, _ssid, _tsid, _orig_tclass, _avd, _xperms);

    struct task_ext *ext = get_current_task_ext();
    if (task_ext_valid(ext) && ext->selinux_allow) {
        struct av_decision *avd = (struct av_decision *)_avd;
        struct extended_perms *xperms = (struct extended_perms *)_xperms;
        if ((uint64_t)_state <= 0xffffffffL) {
            avd = (struct av_decision *)_orig_tclass;
            xperms = (struct extended_perms *)_avd;
        }
        avd->allowed = 0xffffffff;
        avd->auditallow = 0;
        avd->auditdeny = 0;
        if (xperms) {
            min_memset(xperms->drivers.p, 0xff, sizeof(xperms->drivers.p));
        }
    }
}

void hook_backup(security_compute_xperms_decision)(void *_state, void *_ssid, void *_tsid, void *_orig_tclass,
                                                   void *_driver, void *_xpermd) = 0;

//struct selinux_state *state, u32 ssid, u32 tsid, u16 orig_tclass, u8 driver, struct extended_perms_decision *xpermd
void hook_replace(security_compute_xperms_decision)(void *_state, void *_ssid, void *_tsid, void *_orig_tclass,
                                                    void *_driver, void *_xpermd)
{
    hook_call_backup(security_compute_xperms_decision, _state, _ssid, _tsid, _orig_tclass, _driver, _xpermd);
    struct task_ext *ext = get_current_task_ext();
    if (task_ext_valid(ext) && ext->selinux_allow) {
        struct extended_perms_decision *xpermd = (struct extended_perms_decision *)_xpermd;
        if ((uint64_t)_state <= 0xffffffffL) {
            xpermd = (struct extended_perms_decision *)_driver;
        }
        min_memset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));
        min_memset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));
        min_memset(xpermd->dontaudit->p, 0xff, sizeof(xpermd->dontaudit->p));
    }
}

void hook_backup(security_compute_av_user)(void *_state, void *_ssid, void *_tsid, void *_tclass, void *_avd) = 0;

// struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd
void hook_replace(security_compute_av_user)(void *_state, void *_ssid, void *_tsid, void *_tclass, void *_avd)
{
    hook_call_backup(security_compute_av_user, _state, _ssid, _tsid, _tclass, _avd);

    struct task_ext *ext = get_current_task_ext();
    if (task_ext_valid(ext) && ext->selinux_allow) {
        struct av_decision *avd = (struct av_decision *)_avd;
        if ((uint64_t)_state <= 0xffffffffL) {
            avd = (struct av_decision *)_tclass;
        }
        avd->allowed = 0xffffffff;
        avd->auditallow = 0;
        avd->auditdeny = 0;
    }
}

int selinux_hook_install()
{
    // just hook compat func, it has more args
    // hook_compat_kfunc(avc_denied);
    // hook_compat_kfunc(avc_has_perm_noaudit);
    // hook_compat_kfunc(avc_has_perm);
    // hook_compat_kfunc(avc_has_perm_flags);
    // hook_compat_kfunc(avc_has_extended_perms);

    hook_kfunc(security_compute_av);
    hook_kfunc(security_compute_xperms_decision);
    hook_kfunc(security_compute_av_user);
    return 0;
}
```

`kernel/init/accctl/sucompat.c`:

```c
#include <linux/list.h>
#include <ktypes.h>
#include <stdbool.h>
#include <linux/vmalloc.h>
#include <syscall.h>
#include <ksyms.h>
#include <hook.h>
#include <minc/string.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define SU_UID_IGNORE 0
#define SU_UID_ALLOW 1
#define SU_UID_DENY 2

static const char *su_path = 0;
static const char *sh_path = 0;

struct su_uid_list
{
    uid_t uid;
    int rule;
    struct list_head list;
};

static struct su_uid_list su_allow_list;

int su_get_uid_rule(uid_t uid)
{
    struct su_uid_list *pos;
    list_for_each_entry(pos, &su_allow_list.list, list)
    {
        if (uid == pos->uid)
            return pos->rule;
    }
    return SU_UID_IGNORE;
}

static inline bool is_su_allow(uid_t uid)
{
    return su_get_uid_rule(uid) == SU_UID_ALLOW;
}

static inline bool is_su_deny(uid_t uid)
{
    return su_get_uid_rule(uid) == SU_UID_DENY;
}

// todo: rcu list, delete ignore rule
int su_modify_uid_rule(uid_t uid, bool rule)
{
    struct su_uid_list *pos;
    list_for_each_entry(pos, &su_allow_list.list, list)
    {
        if (uid == pos->uid) {
            pos->rule = rule;
        }
        return 0;
    }
    struct su_uid_list *elem = (struct su_uid_list *)vmalloc(sizeof(struct su_uid_list));
    elem->rule = SU_UID_IGNORE;
    elem->uid = uid;
    elem->rule = rule;
    list_add_tail(&elem->list, &su_allow_list.list);
    return 0;
}

static inline void su_allow_uid(uid_t uid)
{
    su_modify_uid_rule(uid, SU_UID_ALLOW);
}

static inline void su_deny_uid(uid_t uid)
{
    su_modify_uid_rule(uid, SU_UID_DENY);
}

static inline void su_ignore_uid(uid_t uid)
{
    su_modify_uid_rule(uid, SU_UID_IGNORE);
}

struct user_arg_ptr
{
    union
    {
        const char __user *const __user *native;
    } ptr;
};

typedef u32 compat_uptr_t;
struct user_arg_ptr_compat
{
    bool is_compat;
    union
    {
        const compat_uptr_t __user *compat;
    } ptr;
};

struct file;

// int do_execveat_common(int fd, struct filename *filename, struct user_arg_ptr argv, struct user_arg_ptr envp, int flags)
// int __do_execve_file(int fd, struct filename *filename, struct user_arg_ptr argv, struct user_arg_ptr envp, int flags,
//                      struct file *file);

static int (*backup_do_execve)(int fd, struct filename *filename, struct user_arg_ptr argv, struct user_arg_ptr envp,
                               int flags, struct file *file, long _p) = 0;

static int replace_do_execve(int fd, struct filename *filename, struct user_arg_ptr argv, struct user_arg_ptr envp,
                             int flags, struct file *file, long _p)
{
    logkfd("filename: %s %s\n", filename->name, filename->iname);

    int rc = backup_do_execve(fd, filename, argv, envp, flags, file, _p);

    return rc;
}

static long (*backup_do_faccessat)(int dfd, const char __user *filename, int mode) = 0;

static long replace_do_faccessat(int dfd, const char __user *filename, int mode)
{
    char buf[64] = { '\0' };
    strncpy_from_user(buf, filename, 63);
    logkfd("filename: %s\n", buf);

    int rc = backup_do_faccessat(dfd, filename, mode);
    return rc;
}

int su_compat_init()
{
    INIT_LIST_HEAD(&su_allow_list.list);

    sh_path = "/system/bin/sh";
    su_path = "/system/bin/su";

    unsigned long hook_execve_addr = kallsyms_lookup_name("__do_execve_file");
    if (!hook_execve_addr)
        hook_execve_addr = kallsyms_lookup_name("do_execveat_common");
    if (!hook_execve_addr) {
        logkfe("su compat execve not found\n");
    }

    hook_err_t err = hook((void *)hook_execve_addr, (void *)replace_do_execve, (void **)&backup_do_execve);
    if (err != HOOK_NO_ERR) {
        logkfe("su compat hook error\n");
    }

    unsigned hook_faccessat_addr = kallsyms_lookup_name("do_faccessat");
    if (!hook_faccessat_addr)
        hook_faccessat_addr = kallsyms_lookup_name("sys_faccessat");

    if (!hook_faccessat_addr) {
        logkfe("su compat faccessat not found\n");
    }

    return 0;
}
```

`kernel/init/accctl/supercall.c`:

```c
#include <uapi/scdefs.h>
#include <hook.h>
#include <common.h>
#include <log.h>
#include <predata.h>
#include <pgtable.h>
#include <syscall.h>
#include <linux/uaccess.h>
#include <linux/cred.h>
#include <asm/current.h>
#include <linux/string.h>
#include <linux/pid.h>
#include <linux/sched.h>
#include <linux/security.h>
#include <accctl.h>

#define MAX_KEY_LEN 127

static inline long call_hello()
{
    logki("KernelPatch Supercall Hello!\n");
    return SUPERCALL_HELLO_MAGIC;
}

static inline long call_get_kernel_version()
{
    return kver;
}

static inline long call_get_kp_version()
{
    return kpver;
}

static long call_load_kpm(const char *path, long len)
{
    return SUPERCALL_RES_NOT_IMPL;
}

static long call_unload_kpm(const char *path, long len)
{
    return SUPERCALL_RES_NOT_IMPL;
}

static inline long call_su()
{
    int ret = commit_su();
    return ret;
}

static long call_grant_su(uid_t uid)
{
    return SUPERCALL_RES_NOT_IMPL;
}

static long call_revoke_su(uid_t uid)
{
    return SUPERCALL_RES_NOT_IMPL;
}

static long call_thread_su(pid_t pid)
{
    int ret = SUPERCALL_RES_SUCCEED;
    ret = thread_su(pid, true);
    return ret;
}

static long call_thread_unsu(pid_t pid)
{
    return SUPERCALL_RES_NOT_IMPL;
}

static long call_test()
{
    int ret = SUPERCALL_RES_SUCCEED;
    return ret;
}

static long supercall(long cmd, long arg1, long arg2, long arg3)
{
    logkd("SuperCall with cmd: %x, a1: %llx, a2: %llx, a3: %llx\n", cmd, arg1, arg2, arg3);

    long ret = SUPERCALL_RES_SUCCEED;
    if (cmd == SUPERCALL_HELLO) {
        ret = call_hello();
    } else if (cmd == SUPERCALL_GET_KERNEL_VERSION) {
        ret = kver;
    } else if (cmd == SUPERCALL_GET_KP_VERSION) {
        ret = kpver;
    } else if (cmd == SUPERCALL_LOAD_KPM) {
        ret = call_load_kpm(0, 0);
    } else if (cmd == SUPERCALL_UNLOAD_KPM) {
        ret = call_unload_kpm(0, 0);
    } else if (cmd == SUPERCALL_SU) {
        ret = call_su();
    } else if (cmd == SUPERCALL_GRANT_SU) {
        uid_t uid = (uid_t)arg1;
        ret = call_grant_su(uid);
    } else if (cmd == SUPERCALL_REVOKE_SU) {
        uid_t uid = (uid_t)arg1;
        ret = call_revoke_su(uid);
    } else if (cmd == SUPERCALL_THREAD_SU) {
        pid_t pid = (pid_t)arg1;
        ret = call_thread_su(pid);
    } else if (cmd == SUPERCALL_THREAD_UNSU) {
        pid_t pid = (pid_t)arg1;
        ret = call_thread_unsu(pid);
    } else if (cmd == SUPERCALL_TEST) {
        ret = call_test();
    } else {
        ret = SUPERCALL_RES_NOT_IMPL;
    }
    return ret;
}

HOOK_SYSCALL_DEFINE6(__NR_supercall, const char __user *, ukey, long, hash, long, cmd, long, a1, long, a2, long, a3)
{
    char key[MAX_KEY_LEN + 1] = { '\0' };
    long len = strncpy_from_user(key, ukey, MAX_KEY_LEN);

    if (len <= 0) {
        goto ori_call;
    }

    if (hash_key(key) != hash) {
        goto ori_call;
    }

    if (cmd >= SUPERCALL_MAX || cmd < SUPERCALL_HELLO) {
        goto ori_call;
    }

    if (superkey_auth(key, len)) {
        goto ori_call;
    }

    return supercall(cmd, a1, a2, a3);

ori_call:
    return HOOK_SYSCALL_CALL_ORIGIN(__NR_supercall, ukey, hash, cmd, a1, a2, a3);
}

int supercall_install()
{
    // REPLACE_SYSCALL_INSTALL(__NR_supercall);
    INLINE_SYSCALL_INSTALL(__NR_supercall);
    return 0;
}

```

`kernel/init/extend/lsmext.c`:

```c
#include <lsmext.h>
#include <ktypes.h>
#include <error.h>
#include <minc/string.h>
#include <linux/gfp.h>
#include <linux/vmalloc.h>
#include <linux/spinlock.h>
#include <linux/list.h>
#include <security/selinux/include/security.h>
#include <security/selinux/include/classmap.h>

static uint8_t *secid_fast_table = 0;
static struct selinux_policy policy_list = { 0 };

struct selinux_policy *selinux_secid_policies(u32 secid)
{
    if (is_secid_fast(secid)) {
        if (secid_fast_table[secid] == FAST_TABLE_ELEM_INVALID) {
            return 0;
        };
    }

    char *secctx = 0;
    u32 seclen = 0;
    if (security_sid_to_context(secid, &secctx, &seclen)) {
        return 0;
    }
    struct selinux_policy *find = 0;
    struct selinux_policy *policy;
    list_for_each_entry(policy, &policy_list.list, list)
    {
        if (!min_strncmp(secctx, policy->scontext, seclen)) {
            find = policy;
            break;
        }
    }

    if (!find) {
        if (is_secid_fast(secid))
            secid_fast_table[secid] = FAST_TABLE_ELEM_INVALID;
    }
    return find;
}

int add_secctx_policy(const char *secctx, const char *tcontext, const char *tclass, const char *perms)
{
    return 0;
}

int del_secctx_policy(const char *secctx, struct lsm_pair *pairs, int npair)
{
    return 0;
}

int lsm_ext_init()
{
    INIT_LIST_HEAD(&policy_list.list);

    secid_fast_table = (typeof(secid_fast_table))vmalloc(SECID_FAST_TABLE_NUM * sizeof(uint8_t));
    for (int i = 0; i < SECID_FAST_TABLE_NUM; i++)
        secid_fast_table[i] = FAST_TABLE_ELEM_UNKNOWN;

#ifdef ANDROID
        // add_secctx_policy("u:r:logd:s0", "", "dir", "search");
        // add_secctx_policy("u:r:logd:s0", "", "file", "read,open,getattr");
#endif

    return 0;
}

```

`kernel/init/extend/syscall.c`:

```c
#include "syscall.h"

#include <cache.h>
#include <ktypes.h>
#include <hook.h>
#include <common.h>
#include <linux/string.h>

bool syscall_has_wrapper = false;
uintptr_t syscall_table_addr = 0;
uintptr_t compat_syscall_table_addr = 0;

void inline_syscall_with(long nr, uintptr_t *old, uintptr_t new)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    uint64_t func = *(uintptr_t *)addr;
    hook((void *)func, (void *)new, (void **)old);
}

void inline_compat_syscall_with(long nr, uintptr_t *old, uintptr_t new)
{
    uintptr_t addr = compat_syscall_table_addr + nr * sizeof(uintptr_t);
    uint64_t func = *(uintptr_t *)addr;
    hook((void *)func, (void *)new, (void **)old);
}

// todo: Control Flow Integrity, CONFIG_LTO_CLANG=y CONFIG_CFI_CLANG=y
void replace_syscall_with(long nr, uintptr_t *old, uintptr_t new)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    *old = *(uintptr_t *)addr;
    uintptr_t *pte = get_pte(addr);
    uintptr_t ori_prot = *pte;
    *pte = (ori_prot | PTE_DBM) & ~PTE_RDONLY;
    flush_tlb_kernel_page(addr);
    *(uintptr_t *)addr = new;
    // flush_icache_all();
    *pte = ori_prot;
    flush_tlb_kernel_page(addr);
}

void replace_compat_syscall_whit(long nr, uintptr_t *old, uintptr_t new)
{
    uintptr_t addr = compat_syscall_table_addr + nr * sizeof(uintptr_t);
    *old = *(uintptr_t *)addr;
    uintptr_t *pte = get_pte(addr);
    uintptr_t ori_prot = *pte;
    *pte = (ori_prot | PTE_DBM) & ~PTE_RDONLY;
    flush_tlb_kernel_page(addr);
    *(uintptr_t *)addr = new;
    // flush_icache_all();
    *pte = ori_prot;
    flush_tlb_kernel_page(addr);
}

typedef long (*warp_raw_syscall_f)(const struct pt_regs *regs);
typedef long (*raw_syscall0_f)();
typedef long (*raw_syscall1_f)(long arg0);
typedef long (*raw_syscall2_f)(long arg0, long arg1);
typedef long (*raw_syscall3_f)(long arg0, long arg1, long arg2);
typedef long (*raw_syscall4_f)(long arg0, long arg1, long arg2, long arg3);
typedef long (*raw_syscall5_f)(long arg0, long arg1, long arg2, long arg3, long arg4);
typedef long (*raw_syscall6_f)(long arg0, long arg1, long arg2, long arg3, long arg4, long arg5);

long raw_syscall0(long nr)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        // todo:
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall0_f)addr)();
    return 0;
}

long raw_syscall1(long nr, long arg0)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall1_f)addr)(arg0);
}

long raw_syscall2(long nr, long arg0, long arg1)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        regs.regs[0] = arg0;
        regs.regs[1] = arg1;
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall2_f)addr)(arg0, arg1);
}

long raw_syscall3(long nr, long arg0, long arg1, long arg2)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        regs.regs[0] = arg0;
        regs.regs[1] = arg1;
        regs.regs[2] = arg2;
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall3_f)addr)(arg0, arg1, arg2);
}

long raw_syscall4(long nr, long arg0, long arg1, long arg2, long arg3)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        regs.regs[0] = arg0;
        regs.regs[1] = arg1;
        regs.regs[2] = arg2;
        regs.regs[3] = arg3;
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall4_f)addr)(arg0, arg1, arg2, arg3);
}

long raw_syscall5(long nr, long arg0, long arg1, long arg2, long arg3, long arg4)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        regs.regs[0] = arg0;
        regs.regs[1] = arg1;
        regs.regs[2] = arg2;
        regs.regs[3] = arg3;
        regs.regs[4] = arg4;
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall5_f)addr)(arg0, arg1, arg2, arg3, arg4);
}

long raw_syscall6(long nr, long arg0, long arg1, long arg2, long arg3, long arg4, long arg5)
{
    uintptr_t addr = syscall_table_addr + nr * sizeof(uintptr_t);
    addr = *(uintptr_t *)addr;
    if (syscall_has_wrapper) {
        struct pt_regs regs;
        memset(&regs, 0, sizeof(regs));
        regs.regs[0] = arg0;
        regs.regs[1] = arg1;
        regs.regs[2] = arg2;
        regs.regs[3] = arg3;
        regs.regs[4] = arg4;
        regs.regs[5] = arg5;
        return ((warp_raw_syscall_f)addr)(&regs);
    }
    return ((raw_syscall6_f)addr)(arg0, arg1, arg2, arg3, arg4, arg5);
}

int syscall_init()
{
    compat_syscall_table_addr = kallsyms_lookup_name("compat_sys_call_table");
    syscall_table_addr = kallsyms_lookup_name("sys_call_table");
    syscall_has_wrapper = kallsyms_lookup_name("__arm64_sys_openat") ? true : false;
    logkd("syscall has wrapper: %d\n", syscall_has_wrapper);
    return 0;
}

```

`kernel/init/extend/taskob.c`:

```c
#include <taskob.h>
#include <taskext.h>
#include <kallsyms.h>
#include <hook.h>
#include <asm/current.h>
#include <linux/sched/task.h>
#include <linux/pid.h>
#include <linux/security.h>
#include <minc/string.h>

static inline void prepare_init_ext(struct task_struct *task)
{
    struct task_ext *ext = get_task_ext(task);
    ext->magic = TASK_EXT_MAGIC;
    ext->task = task;
    ext->pid = 0;
    ext->tgid = 0;
    ext->selinux_allow = false;
}

static inline struct task_ext *prepare_task_ext(struct task_struct *new, struct task_struct *old)
{
    struct task_ext *new_ext = get_task_ext(new);
    struct task_ext *old_ext = get_task_ext(old);

    new_ext->magic = TASK_EXT_MAGIC;
    new_ext->task = new;
    new_ext->pid = __task_pid_nr_ns(new, PIDTYPE_PID, 0);
    new_ext->tgid = __task_pid_nr_ns(new, PIDTYPE_TGID, 0);
    new_ext->selinux_allow = false;

    //
    if (old_ext->selinux_allow) {
        new_ext->selinux_allow = true;
    }

#if 0
    u32 new_secid = 0, seclen = 0;
    const char *new_secctx = 0;
    security_task_getsecid(new, &new_secid);
    security_secid_to_secctx(new_secid, &new_secctx, &seclen);
    if (new_secctx)
        security_release_secctx(new_secctx, seclen);
#endif

    return new_ext;
}

void before_do_exit(hook_fdata2_t *data, void *udata)
{
}

void after_copy_process(hook_fdata8_t *data, void *udata)
{
    struct task_struct *old = current;
    struct task_ext *old_ext = get_task_ext(old);
    old_ext = old_ext;

    struct task_struct *new = (struct task_struct *)data->ret;
    struct task_ext *new_ext = prepare_task_ext(new, old);
    new_ext = new_ext;
}

int task_observer()
{
    prepare_init_ext(kvar(init_task));

    unsigned long do_exit_addr = kallsyms_lookup_name("do_exit");
    hook_wrap2((void *)do_exit_addr, before_do_exit, 0, 0, 0);

    unsigned long copy_process_addr = kallsyms_lookup_name("copy_process");
    hook_wrap8((void *)copy_process_addr, 0, after_copy_process, 0, 0);
    return 0;
}
```

`kernel/init/include/accctl.h`:

```h
#ifndef _KP_ACCCTL_H_
#define _KP_ACCCTL_H_

#include <linux/cred.h>
#include <linux/spinlock.h>
#include <linux/sched.h>

int commit_su_nodep();
int commit_su();
int thread_su(pid_t vpid, bool real);

int su_compat_init();

int supercall_install();
int lsm_hook_install();
int selinux_hook_install();

#endif
```

`kernel/init/include/ksyms.h`:

```h
#ifndef _KSYMS_H
#define _KSYMS_H

#include <linux/kallsyms.h>
#include <log.h>

int _local_strcmp(const char *s1, const char *s2);

// todo: Crash on Pixel3xl android 12 when call kallsyms_on_each_symbol,
#define USE_KALLSYMS_LOOKUP_NAME_INSTEAD

#define kvar(var) kv_##var
#define kvar_def(var) (*kv_##var)
#define kvlen(var) kvl_##var
#define kvar_val(var) (*kvar(var))

#define kfunc(func) kf_##func
#define kfunc_def(func) (*kf_##func)

#ifdef USE_KALLSYMS_LOOKUP_NAME_INSTEAD
#define kvar_match(var, name, addr) kv_##var = (typeof(kv_##var))kallsyms_lookup_name(#var)
#define kfunc_match(func, name, addr) kf_##func = (typeof(kf_##func))kallsyms_lookup_name(#func)
#else
#define kvar_match(var, name, addr)              \
    if (!kv_##var && !_local_strcmp(#var, name)) \
        kv_##var = (typeof(kv_##var))addr;
#define kfunc_match(func, name, addr)              \
    if (!kf_##func && !_local_strcmp(#func, name)) \
    kf_##func = (typeof(kf_##func))addr
#define kvar_match_len(var, name, addr)                         \
    if (!kv_##var && !_local_strcmp(#var, name)) {              \
        kv_##var = (typeof(kv_##var))addr;                      \
        kvl_##var = 0;                                          \
    }                                                           \
    if (kv_##var && !kvl_##var && (uint64_t)kv_##var != addr) { \
        kvl_##var = addr - (uint64_t)kv_##var;                  \
    }
#endif

#define kfunc_call(func, ...) \
    if (kf_##func)            \
        return kf_##func(__VA_ARGS__);
#define kfunc_call_void(func, ...) \
    if (kf_##func)                 \
        kf_##func(__VA_ARGS__);

// todo
#define kfunc_not_found() logke("kfunc: %s not found\n", __func__);

#define hook_backup(func) (*backup_##func)
#define hook_replace(func) replace_##func
#define hook_call_backup(func, ...) backup_##func(__VA_ARGS__)

#define hook_kfunc_with(func, replace, backup)                                \
    if (kfunc(func)) {                                                        \
        hook_err_t err_##func = hook(kfunc(func), replace, (void **)&backup); \
        if (err_##func != HOOK_NO_ERR) {                                      \
            logke("hook: %s, ret: %d\n", #func, err_##func);                  \
        }                                                                     \
    } else {                                                                  \
        logkw("hook: %s not found\n", #func);                                 \
    }

#define hook_kfunc(func) hook_kfunc_with(func, replace_##func, backup_##func)

#define find_and_hook_func_with(func, replace, backup)                 \
    unsigned long addr = kallsyms_lookup_name(#func);                  \
    if (addr) {                                                        \
        hook_err_t err_##func = hook(addr, replace, (void **)&backup); \
        if (err_##func != HOOK_NO_ERR) {                               \
            logke("hook: %s, ret: %d\n", #func, err_##func);           \
        }                                                              \
    } else {                                                           \
        logkw("hook: %s not found\n", #func);                          \
    }

#endif

```

`kernel/init/include/lsmext.h`:

```h
#ifndef _KP_LSMEXT_H_
#define _KP_LSMEXT_H_

#include <ktypes.h>
#include <uapi/lsmdef.h>
#include <linux/list.h>

#define FAST_TABLE_ELEM_UNKNOWN 1
#define FAST_TABLE_ELEM_INVALID 2

#define SECID_FAST_TABLE_NUM 4096

struct lsm_pair
{
    LSM_TYPE type;
    LSM_VAL val;
};

struct task_selinux_rule
{
    u32 tsid;
    u16 tclass;
    u32 allowed;
};

struct selinux_policy
{
    struct list_head list;
    const char *scontext;
    const char *tcontext;
    const char *tclass;
    const char *perms;
};

static inline bool is_secid_fast(u32 secid)
{
    return secid >= 0 && secid < SECID_FAST_TABLE_NUM;
}

int lsm_ext_init();

#endif
```

`kernel/init/include/syscall.h`:

```h
#ifndef _KP_SYSCALL_H_
#define _KP_SYSCALL_H_

#include <asm/ptrace.h>
#include <uapi/asm-generic/errno.h>
#include <uapi/asm-generic/unistd.h>

#define SYS_CALL_MAX_NR 512

#define __MAP0(m, ...)
#define __MAP1(m, t, a, ...) m(t, a)
#define __MAP2(m, t, a, ...) m(t, a), __MAP1(m, __VA_ARGS__)
#define __MAP3(m, t, a, ...) m(t, a), __MAP2(m, __VA_ARGS__)
#define __MAP4(m, t, a, ...) m(t, a), __MAP3(m, __VA_ARGS__)
#define __MAP5(m, t, a, ...) m(t, a), __MAP4(m, __VA_ARGS__)
#define __MAP6(m, t, a, ...) m(t, a), __MAP5(m, __VA_ARGS__)
#define __MAP(n, ...) __MAP##n(__VA_ARGS__)

#define __SC_DECL(t, a) t a
#define __SC_ARGS(t, a) a
#define __SC_EMPTY(t, a) 0

#define ARM64_REGS_TO_ARGS(x, ...)                                                                             \
    __MAP(x, __SC_ARGS, , regs->regs[0], , regs->regs[1], , regs->regs[2], , regs->regs[3], , regs->regs[4], , \
          regs->regs[5])

#define __REGS_ASSIGN0(n, ...)
#define __REGS_ASSIGN1(n, t, a, ...) \
    a = (t)(regs->regs[n - 1]);      \
    __REGS_ASSIGN0(n, __VA_ARGS__)
#define __REGS_ASSIGN2(n, t, a, ...) \
    a = (t)(regs->regs[n - 2]);      \
    __REGS_ASSIGN1(n, __VA_ARGS__)
#define __REGS_ASSIGN3(n, t, a, ...) \
    a = (t)(regs->regs[n - 3]);      \
    __REGS_ASSIGN2(n, __VA_ARGS__)
#define __REGS_ASSIGN4(n, t, a, ...) \
    a = (t)(regs->regs[n - 4]);      \
    __REGS_ASSIGN3(n, __VA_ARGS__)
#define __REGS_ASSIGN5(n, t, a, ...) \
    a = (t)(regs->regs[n - 5]);      \
    __REGS_ASSIGN4(n, __VA_ARGS__)
#define __REGS_ASSIGN6(n, t, a, ...) \
    a = (t)(regs->regs[n - 6]);      \
    __REGS_ASSIGN5(n, __VA_ARGS__)
#define __REGS_ASSIGN(n, ...) __REGS_ASSIGN##n(n, __VA_ARGS__)

#define HOOK_SYSCALL_DEFINE(x, nr, ...)                                                                     \
    static long (*__hook_sys_backup_##nr)(__MAP(x, __SC_DECL, __VA_ARGS__)) = 0;                            \
    static long (*__hook_sys_wrap_backup_##nr)(const struct pt_regs *regs) = 0;                             \
    static long __hook_sys_bridge_##nr(const struct pt_regs *regs, __MAP(x, __SC_DECL, __VA_ARGS__));       \
    static long __hook_sys_common_##nr(const struct pt_regs *regs, __MAP(x, __SC_DECL, __VA_ARGS__));       \
    long __attribute__((__noinline__)) __hook_sys_##nr(__MAP(x, __SC_DECL, __VA_ARGS__))                    \
    {                                                                                                       \
        return __hook_sys_bridge_##nr(0, __MAP(x, __SC_ARGS, __VA_ARGS__));                                 \
    }                                                                                                       \
    long __attribute__((__noinline__)) __hook_sys_wrap_##nr(const struct pt_regs *regs)                     \
    {                                                                                                       \
        return __hook_sys_bridge_##nr(regs, __MAP(x, __SC_EMPTY, __VA_ARGS__));                             \
    }                                                                                                       \
    static long inline __hook_sys_bridge_##nr(const struct pt_regs *regs, __MAP(x, __SC_DECL, __VA_ARGS__)) \
    {                                                                                                       \
        if (regs) {                                                                                         \
            __REGS_ASSIGN(x, __VA_ARGS__);                                                                  \
        }                                                                                                   \
        return __hook_sys_common_##nr(regs, __MAP(x, __SC_ARGS, __VA_ARGS__));                              \
    }                                                                                                       \
    static long inline __hook_sys_common_##nr(const struct pt_regs *regs, __MAP(x, __SC_DECL, __VA_ARGS__))

#define HOOK_SYSCALL_DEFINE0(nr, ...) HOOK_SYSCALL_DEFINE(0, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE1(nr, ...) HOOK_SYSCALL_DEFINE(1, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE2(nr, ...) HOOK_SYSCALL_DEFINE(2, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE3(nr, ...) HOOK_SYSCALL_DEFINE(3, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE4(nr, ...) HOOK_SYSCALL_DEFINE(4, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE5(nr, ...) HOOK_SYSCALL_DEFINE(5, nr, __VA_ARGS__)
#define HOOK_SYSCALL_DEFINE6(nr, ...) HOOK_SYSCALL_DEFINE(6, nr, __VA_ARGS__)

#define __HOOK_SYSCALL_CALL_ORIGIN(nr, ...) \
    (syscall_has_wrapper ? __hook_sys_wrap_backup_##nr(regs) : __hook_sys_backup_##nr(__VA_ARGS__));

#define HOOK_SYSCALL_CALL_ORIGIN(nr, ...) __HOOK_SYSCALL_CALL_ORIGIN(nr, __VA_ARGS__)

#define __REPLACE_SYSCALL_INSTALL(nr)                                                                         \
    if (syscall_has_wrapper) {                                                                                \
        replace_syscall_with(nr, (uintptr_t *)&__hook_sys_wrap_backup_##nr, (uintptr_t)__hook_sys_wrap_##nr); \
    } else {                                                                                                  \
        replace_syscall_with(nr, (uintptr_t *)&__hook_sys_backup_##nr, (uintptr_t)__hook_sys_##nr);           \
    }
#define REPLACE_SYSCALL_INSTALL(nr) __REPLACE_SYSCALL_INSTALL(nr)

#define __INLINE_SYSCALL_INSTALL(nr)                                                                         \
    if (syscall_has_wrapper) {                                                                               \
        inline_syscall_with(nr, (uintptr_t *)&__hook_sys_wrap_backup_##nr, (uintptr_t)__hook_sys_wrap_##nr); \
    } else {                                                                                                 \
        inline_syscall_with(nr, (uintptr_t *)&__hook_sys_backup_##nr, (uintptr_t)__hook_sys_##nr);           \
    }
#define INLINE_SYSCALL_INSTALL(nr) __INLINE_SYSCALL_INSTALL(nr)

#define _ARGS_TO_REGS(regs, idx, val, ...)        \
    do {                                          \
        regs.regs[idx] = val;                     \
        ARGS_TO_REGS(regs, idx + 1, __VA_ARGS__); \
    } while (0)

#define ARGS_TO_REGS(regs, ...) _ARGS_TO_REGS(regs, 0, __VA_ARGS__)

extern bool syscall_has_wrapper;
extern uintptr_t syscall_table_addr;
extern uintptr_t compat_syscall_table_addr;

void inline_syscall_with(long nr, uintptr_t *old, uintptr_t new);
void inline_compat_syscall_with(long nr, uintptr_t *old, uintptr_t new);
void replace_syscall_with(long nr, uintptr_t *old, uintptr_t newsc);
void replace_compat_syscall_whit(long nr, uintptr_t *old, uintptr_t newsc);

long raw_syscall0(long nr);
long raw_syscall1(long nr, long arg0);
long raw_syscall2(long nr, long arg0, long arg1);
long raw_syscall3(long nr, long arg0, long arg1, long arg2);
long raw_syscall4(long nr, long arg0, long arg1, long arg2, long arg3);
long raw_syscall5(long nr, long arg0, long arg1, long arg2, long arg3, long arg4);
long raw_syscall6(long nr, long arg0, long arg1, long arg2, long arg3, long arg4, long arg5);

#define raw_syscall(f) raw_syscall##f

static inline pid_t raw_syscall(getpid)()
{
    return raw_syscall0(__NR_getpid);
}

static inline pid_t raw_syscall(getppid)()
{
    return raw_syscall0(__NR_getppid);
}

static inline pid_t raw_syscall(gettid)()
{
    return raw_syscall0(__NR_gettid);
}

static inline int raw_syscall(setresuid)(uid_t ruid, uid_t euid, uid_t suid)
{
    return raw_syscall3(__NR_getresuid, ruid, euid, suid);
}

static inline uid_t raw_syscall(getuid)()
{
    return raw_syscall0(__NR_getuid);
}

static inline uid_t raw_syscall(geteuid)()
{
    return raw_syscall0(__NR_geteuid);
}

int syscall_init();

#endif
```

`kernel/init/include/taskext.h`:

```h
#ifndef _KP_TASKEXT_H_
#define _KP_TASKEXT_H_

#include <asm/current.h>
#include <linux/sched.h>
#include <linux/sched/task.h>

#define TASK_EXT_MAGIC 0x1158115811581158

struct task_ext
{
    // first
    struct task_struct *task;
    pid_t pid;
    pid_t tgid;
    bool selinux_allow;
    // last
    uint64_t magic;
};

static inline bool task_ext_valid(struct task_ext *ext)
{
    bool rc = ext->magic == TASK_EXT_MAGIC;
    return rc;
}

#endif

```

`kernel/init/include/taskob.h`:

```h
#ifndef _KP_TASKOB_H_
#define _KP_TASKOB_H_

#endif
```

`kernel/init/include/uapi/lsmdef.h`:

```h
#ifndef _KP_LSMDEF_H_
#define _KP_LSMDEF_H_

// /include/linux/lsm_hooks.h

typedef unsigned char LSM_VAL;

#define LSM_VAL_IGNORE 0
#define LSM_VAL_ALL 0xff

typedef enum LSM_TYPE
{
    LSM_TYPE_MIN = 0,
    LSM_TYPE_security_binder_set_context_mgr,
    LSM_TYPE_security_binder_transaction,
    LSM_TYPE_security_binder_transfer_binder,
    LSM_TYPE_security_binder_transfer_file,
    LSM_TYPE_security_ptrace_access_check,
    LSM_TYPE_security_ptrace_traceme,
    LSM_TYPE_security_capget,
    LSM_TYPE_security_capset,
    LSM_TYPE_security_capable,
    LSM_TYPE_security_quotactl,
    LSM_TYPE_security_quota_on,
    LSM_TYPE_security_syslog,
    LSM_TYPE_security_settime64,
    LSM_TYPE_security_vm_enough_memory_mm,
    LSM_TYPE_security_bprm_creds_for_exec,
    LSM_TYPE_security_bprm_creds_from_file,
    LSM_TYPE_security_bprm_check,
    LSM_TYPE_security_bprm_committing_creds,
    LSM_TYPE_security_bprm_committed_creds,
    LSM_TYPE_security_fs_context_dup,
    LSM_TYPE_security_fs_context_parse_param,
    LSM_TYPE_security_sb_alloc,
    LSM_TYPE_security_sb_delete,
    LSM_TYPE_security_sb_free,
    LSM_TYPE_security_free_mnt_opts,
    LSM_TYPE_security_sb_eat_lsm_opts,
    LSM_TYPE_security_sb_remount,
    LSM_TYPE_security_sb_kern_mount,
    LSM_TYPE_security_sb_show_options,
    LSM_TYPE_security_sb_statfs,
    LSM_TYPE_security_sb_mount,
    LSM_TYPE_security_sb_umount,
    LSM_TYPE_security_sb_pivotroot,
    LSM_TYPE_security_sb_set_mnt_opts,
    LSM_TYPE_security_sb_clone_mnt_opts,
    LSM_TYPE_security_add_mnt_opt,
    LSM_TYPE_security_move_mount,
    LSM_TYPE_security_dentry_init_security,
    LSM_TYPE_security_dentry_create_files_as,

    //config_security_path
    LSM_TYPE_security_path_unlink,
    LSM_TYPE_security_path_mkdir,
    LSM_TYPE_security_path_rmdir,
    LSM_TYPE_security_path_mknod,
    LSM_TYPE_security_path_truncate,
    LSM_TYPE_security_path_symlink,
    LSM_TYPE_security_path_link,
    LSM_TYPE_security_path_rename,
    LSM_TYPE_security_path_chmod,
    LSM_TYPE_security_path_chown,
    LSM_TYPE_security_path_chroot,
    /* config_security_path */

    /* needed for inode based security check */
    LSM_TYPE_security_path_notify,
    LSM_TYPE_security_inode_alloc,
    LSM_TYPE_security_inode_free,
    LSM_TYPE_security_inode_init_security,
    LSM_TYPE_security_old_inode_init_security,
    LSM_TYPE_security_inode_create,
    LSM_TYPE_security_inode_link,
    LSM_TYPE_security_inode_unlink,
    LSM_TYPE_security_inode_symlink,
    LSM_TYPE_security_inode_mkdir,
    LSM_TYPE_security_inode_rmdir,
    LSM_TYPE_security_inode_mknod,
    LSM_TYPE_security_inode_rename,
    LSM_TYPE_security_inode_readlink,
    LSM_TYPE_security_inode_follow_link,
    LSM_TYPE_security_inode_permission,
    LSM_TYPE_security_inode_setattr,
    LSM_TYPE_security_inode_getattr,
    LSM_TYPE_security_inode_setxattr,
    LSM_TYPE_security_inode_post_setxattr,
    LSM_TYPE_security_inode_getxattr,
    LSM_TYPE_security_inode_listxattr,
    LSM_TYPE_security_inode_removexattr,
    LSM_TYPE_security_inode_set_acl,
    LSM_TYPE_security_inode_get_acl,
    LSM_TYPE_security_inode_remove_acl,
    LSM_TYPE_security_inode_need_killpriv,
    LSM_TYPE_security_inode_killpriv,
    LSM_TYPE_security_inode_getsecurity,
    LSM_TYPE_security_inode_setsecurity,
    LSM_TYPE_security_inode_listsecurity,
    LSM_TYPE_security_inode_getsecid,
    LSM_TYPE_security_inode_copy_up,
    LSM_TYPE_security_inode_copy_up_xattr,
    LSM_TYPE_security_kernfs_init_security,
    LSM_TYPE_security_file_permission,
    LSM_TYPE_security_file_alloc,
    LSM_TYPE_security_file_free,
    LSM_TYPE_security_file_ioctl,
    LSM_TYPE_security_mmap_addr,
    LSM_TYPE_security_mmap_file,
    LSM_TYPE_security_file_mprotect,
    LSM_TYPE_security_file_lock,
    LSM_TYPE_security_file_fcntl,
    LSM_TYPE_security_file_set_fowner,
    LSM_TYPE_security_file_send_sigiotask,
    LSM_TYPE_security_file_receive,
    LSM_TYPE_security_file_open,
    LSM_TYPE_security_file_truncate,
    LSM_TYPE_security_task_alloc,
    LSM_TYPE_security_task_free,
    LSM_TYPE_security_cred_alloc_blank,
    LSM_TYPE_security_cred_free,
    LSM_TYPE_security_prepare_creds,
    LSM_TYPE_security_transfer_creds,
    LSM_TYPE_security_cred_getsecid,
    LSM_TYPE_security_kernel_act_as,
    LSM_TYPE_security_kernel_create_files_as,
    LSM_TYPE_security_kernel_module_request,
    LSM_TYPE_security_kernel_load_data,
    LSM_TYPE_security_kernel_post_load_data,
    LSM_TYPE_security_kernel_read_file,
    LSM_TYPE_security_kernel_post_read_file,
    LSM_TYPE_security_task_fix_setuid,
    LSM_TYPE_security_task_fix_setgid,
    LSM_TYPE_security_task_fix_setgroups,
    LSM_TYPE_security_task_setpgid,
    LSM_TYPE_security_task_getpgid,
    LSM_TYPE_security_task_getsid,
    LSM_TYPE_security_current_getsecid_subj,
    LSM_TYPE_security_task_getsecid_obj,
    LSM_TYPE_security_task_getsecid,
    LSM_TYPE_security_task_setnice,
    LSM_TYPE_security_task_setioprio,
    LSM_TYPE_security_task_getioprio,
    LSM_TYPE_security_task_prlimit,
    LSM_TYPE_security_task_setrlimit,
    LSM_TYPE_security_task_setscheduler,
    LSM_TYPE_security_task_getscheduler,
    LSM_TYPE_security_task_movememory,
    LSM_TYPE_security_task_kill,
    LSM_TYPE_security_task_prctl,
    LSM_TYPE_security_task_to_inode,
    LSM_TYPE_security_create_user_ns,
    LSM_TYPE_security_ipc_permission,
    LSM_TYPE_security_ipc_getsecid,
    LSM_TYPE_security_msg_msg_alloc,
    LSM_TYPE_security_msg_msg_free,
    LSM_TYPE_security_msg_queue_alloc,
    LSM_TYPE_security_msg_queue_free,
    LSM_TYPE_security_msg_queue_associate,
    LSM_TYPE_security_msg_queue_msgctl,
    LSM_TYPE_security_msg_queue_msgsnd,
    LSM_TYPE_security_msg_queue_msgrcv,
    LSM_TYPE_security_shm_alloc,
    LSM_TYPE_security_shm_free,
    LSM_TYPE_security_shm_associate,
    LSM_TYPE_security_shm_shmctl,
    LSM_TYPE_security_shm_shmat,
    LSM_TYPE_security_sem_alloc,
    LSM_TYPE_security_sem_free,
    LSM_TYPE_security_sem_associate,
    LSM_TYPE_security_sem_semctl,
    LSM_TYPE_security_sem_semop,
    LSM_TYPE_security_d_instantiate,
    LSM_TYPE_security_getprocattr,
    LSM_TYPE_security_setprocattr,
    LSM_TYPE_security_netlink_send,
    LSM_TYPE_security_ismaclabel,
    LSM_TYPE_security_secid_to_secctx,
    LSM_TYPE_security_secctx_to_secid,
    LSM_TYPE_security_release_secctx,
    LSM_TYPE_security_inode_invalidate_secctx,
    LSM_TYPE_security_inode_notifysecctx,
    LSM_TYPE_security_inode_setsecctx,
    LSM_TYPE_security_inode_getsecctx,

    // config_watch_queue
    LSM_TYPE_security_post_notification,

    // config_key_notifications
    LSM_TYPE_security_watch_key,

    // config_security_network
    LSM_TYPE_security_unix_stream_connect,
    LSM_TYPE_security_unix_may_send,
    LSM_TYPE_security_socket_create,
    LSM_TYPE_security_socket_post_create,
    LSM_TYPE_security_socket_socketpair,
    LSM_TYPE_security_socket_bind,
    LSM_TYPE_security_socket_connect,
    LSM_TYPE_security_socket_listen,
    LSM_TYPE_security_socket_accept,
    LSM_TYPE_security_socket_sendmsg,
    LSM_TYPE_security_socket_recvmsg,
    LSM_TYPE_security_socket_getsockname,
    LSM_TYPE_security_socket_getpeername,
    LSM_TYPE_security_socket_getsockopt,
    LSM_TYPE_security_socket_setsockopt,
    LSM_TYPE_security_socket_shutdown,
    LSM_TYPE_security_sock_rcv_skb,
    LSM_TYPE_security_socket_getpeersec_stream,
    LSM_TYPE_security_socket_getpeersec_dgram,
    LSM_TYPE_security_sk_alloc,
    LSM_TYPE_security_sk_free,
    LSM_TYPE_security_sk_clone,
    LSM_TYPE_security_sk_classify_flow,
    LSM_TYPE_security_req_classify_flow,
    LSM_TYPE_security_sock_graft,
    LSM_TYPE_security_inet_conn_request,
    LSM_TYPE_security_inet_csk_clone,
    LSM_TYPE_security_inet_conn_established,
    LSM_TYPE_security_secmark_relabel_packet,
    LSM_TYPE_security_secmark_refcount_inc,
    LSM_TYPE_security_secmark_refcount_dec,
    LSM_TYPE_security_tun_dev_alloc_security,
    LSM_TYPE_security_tun_dev_free_security,
    LSM_TYPE_security_tun_dev_create,
    LSM_TYPE_security_tun_dev_attach_queue,
    LSM_TYPE_security_tun_dev_attach,
    LSM_TYPE_security_tun_dev_open,
    LSM_TYPE_security_sctp_assoc_request,
    LSM_TYPE_security_sctp_bind_connect,
    LSM_TYPE_security_sctp_sk_clone,
    LSM_TYPE_security_sctp_assoc_established,

    // config_security_infiniband
    LSM_TYPE_security_ib_pkey_access,
    LSM_TYPE_security_ib_endport_manage_subnet,
    LSM_TYPE_security_ib_alloc_security,
    LSM_TYPE_security_ib_free_security,

    // config_security_network_xfrm
    LSM_TYPE_security_xfrm_policy_alloc,
    LSM_TYPE_security_xfrm_policy_clone,
    LSM_TYPE_security_xfrm_policy_free,
    LSM_TYPE_security_xfrm_policy_delete,
    LSM_TYPE_security_xfrm_state_alloc,
    LSM_TYPE_security_xfrm_state_alloc_acquire,
    LSM_TYPE_security_xfrm_state_delete,
    LSM_TYPE_security_xfrm_state_free,
    LSM_TYPE_security_xfrm_policy_lookup,
    LSM_TYPE_security_xfrm_state_pol_flow_match,
    LSM_TYPE_security_xfrm_decode_session,
    LSM_TYPE_security_skb_classify_flow,

    /* key management security hooks */
    // config_keys
    LSM_TYPE_security_key_alloc,
    LSM_TYPE_security_key_free,
    LSM_TYPE_security_key_permission,
    LSM_TYPE_security_key_getsecurity,

    // config_audit
    LSM_TYPE_security_audit_rule_init,
    LSM_TYPE_security_audit_rule_known,
    LSM_TYPE_security_audit_rule_free,
    LSM_TYPE_security_audit_rule_match,

    // config_bpf_syscall
    LSM_TYPE_security_bpf,
    LSM_TYPE_security_bpf_map,
    LSM_TYPE_security_bpf_prog,
    LSM_TYPE_security_bpf_map_alloc,
    LSM_TYPE_security_bpf_prog_alloc,
    LSM_TYPE_security_bpf_map_free,
    LSM_TYPE_security_bpf_prog_free,
    // config_bpf_syscall

    LSM_TYPE_security_locked_down,

    // config_perf_events
    LSM_TYPE_security_perf_event_open,
    LSM_TYPE_security_perf_event_alloc,
    LSM_TYPE_security_perf_event_free,
    LSM_TYPE_security_perf_event_read,
    LSM_TYPE_security_perf_event_write,

    // config_io_uring
    LSM_TYPE_security_uring_override_creds,
    LSM_TYPE_security_uring_sqpoll,
    LSM_TYPE_security_uring_cmd,

    //
    LSM_TYPE_MAX,
} LSM_TYPE;

#define LSM_TYPE_INVALID LSM_TYPE_MAX

static inline int lsm_type_valid(LSM_TYPE type)
{
    return type > LSM_TYPE_MIN && type < LSM_TYPE_MAX;
}

#endif

```

`kernel/init/include/uapi/scdefs.h`:

```h
#ifndef _KP_SUPERCALL_H_
#define _KP_SUPERCALL_H_

static inline long hash_key(const char *key)
{
    long hash = 1000000007;
    for (int i = 0; key[i]; i++) {
        hash = hash * 31 + key[i];
    }
    return hash;
}

// #define __NR_supercall __NR3264_truncate // 45
#define __NR_supercall 45

#define SUPERCALL_HELLO 0x1000
#define SUPERCALL_GET_KERNEL_VERSION 0x1001
#define SUPERCALL_GET_KP_VERSION 0x1002
#define SUPERCALL_LOAD_KPM 0x1003
#define SUPERCALL_UNLOAD_KPM 0x1004
#define SUPERCALL_SU 0x1005
#define SUPERCALL_GRANT_SU 0x1006
#define SUPERCALL_REVOKE_SU 0x1007
#define SUPERCALL_THREAD_SU 0x1008
#define SUPERCALL_THREAD_UNSU 0x1009

#define SUPERCALL_TEST 0x10FF
#define SUPERCALL_MAX 0x1100

#define SUPERCALL_RES_SUCCEED 0
#define SUPERCALL_RES_FAILED 1
#define SUPERCALL_RES_NOT_IMPL 2

#define SUPERCALL_HELLO_MAGIC 0x1158

#endif

```

`kernel/init/init.c`:

```c
#include "init.h"

#include <log.h>
#include <ksyms.h>
#include <kallsyms.h>
#include <hook.h>
#include <accctl.h>
#include <linux/sched.h>
#include <linux/sched/task.h>
#include <linux/cred.h>
#include <linux/capability.h>
#include <syscall.h>
#include <lsmext.h>
#include <security/selinux/include/security.h>

void _linux_kernel_cred_sym_match(const char *name, unsigned long addr);
void _linux_kernel_pid_sym_match(const char *name, unsigned long addr);
void _linux_kernel_fork_sym_match(const char *name, unsigned long addr);
void _linux_lib_strncpy_from_user_sym_match(const char *name, unsigned long addr);
void _linxu_lib_strnlen_user_sym_match(const char *name, unsigned long addr);
void _linux_lib_string_sym_match(const char *name, unsigned long addr);
void _linux_mm_utils_sym_match(const char *name, unsigned long addr);
void _linux_lib_argv_split_sym_match(const char *name, unsigned long addr);
void _linxu_lib_kstrtox_sym_match(const char *name, unsigned long addr);
void _linux_kernel_stop_machine_sym_match(const char *name, unsigned long addr);
void _linux_init_task_sym_match(const char *name, unsigned long addr);
void _linux_lib_dump_stack_sym_match(const char *name, unsigned long addr);
void _linux_mm_vmalloc_sym_match(const char *name, unsigned long addr);
void _linux_security_security_sym_match(const char *name, unsigned long addr);
void _linux_security_selinux_avc_sym_match(const char *name, unsigned long addr);
void _linux_security_commoncap_sym_match(const char *name, unsigned long addr);
void _linux_locking_spinlock_sym_match(const char *name, unsigned long addr);
void _linux_security_selinux_sym_match(const char *name, unsigned long addr);

void linux_sybmol_len_init();

int build_struct();
int task_observer();

int _local_strcmp(const char *s1, const char *s2)
{
    while (*s1 == *s2++)
        if (*s1++ == 0)
            return (0);
    return (*(unsigned char *)s1 - *(unsigned char *)--s2);
}

int linux_symbol_init(void *data, const char *name, struct module *m, unsigned long addr)
{
    _linux_kernel_cred_sym_match(name, addr);
    _linux_kernel_pid_sym_match(name, addr);
    _linux_kernel_fork_sym_match(name, addr);
    _linux_lib_strncpy_from_user_sym_match(name, addr);
    _linxu_lib_strnlen_user_sym_match(name, addr);
    _linux_mm_utils_sym_match(name, addr);
    _linux_kernel_stop_machine_sym_match(name, addr);
    _linux_init_task_sym_match(name, addr);
    _linux_lib_dump_stack_sym_match(name, addr);
    _linux_mm_vmalloc_sym_match(name, addr);
    _linux_security_selinux_avc_sym_match(name, addr);
    _linux_security_commoncap_sym_match(name, addr);
    _linux_locking_spinlock_sym_match(name, addr);
    _linux_security_selinux_sym_match(name, addr);

    _linux_lib_string_sym_match(name, addr);
    // _linux_lib_argv_split_sym_match(name, addr);
    // _linxu_lib_kstrtox_sym_match(name, addr);
    // _linux_security_security_sym_match(name, addr);

    return 0;
}

void before_rest_init(hook_fdata0_t *fdata, void *udata)
{
    logkd("init before rest_init\n");

#ifdef USE_KALLSYMS_LOOKUP_NAME_INSTEAD
    linux_symbol_init(0, 0, 0, 0);
    linux_sybmol_len_init();
#else
    kallsyms_on_each_symbol(linux_symbol_init, 0);
#endif
    syscall_init();
    build_struct();
    // lsm_ext_init();
    // lsm_hook_install();
    selinux_hook_install();
    task_observer();
    supercall_install();
    // su_compat(); // todo: uaccess
    logki("==== KernelPatch Everything Done ====\n");
}

int init()
{
    int err = 0;
    unsigned long rest_init_addr = kallsyms_lookup_name("rest_init");
    if (rest_init_addr)
        hook_wrap0((void *)rest_init_addr, before_rest_init, 0, 0, 0);
    return err;
}

```

`kernel/init/init.h`:

```h
#ifndef _KP_INIT_H_
#define _KP_INIT_H_

int init();

#endif
```

`kernel/init/ksyms/misc.c`:

```c
#include <ksyms.h>
#include <ktypes.h>

// init/init_task.c  kernel/cred.c
#include <linux/sched.h>
#include <linux/cred.h>
#include <linux/sched/task.h>

struct task_struct *kvar(init_task) = 0;
union thread_union *kvar(init_thread_union) = 0;

void _linux_init_task_sym_match(const char *name, unsigned long addr)
{
#ifdef USE_KALLSYMS_LOOKUP_NAME_INSTEAD
    kvar_match(init_task, name, addr);
#else
    kvar_match_len(init_task, name, addr);
#endif
    kvar_match(init_thread_union, name, addr);
}

struct cred *kvar(init_cred) = 0;
struct group_info *kvar(init_groups) = 0;

void kfunc_def(__put_cred)(struct cred *) = 0;
void kfunc_def(exit_creds)(struct task_struct *) = 0;
int kfunc_def(copy_creds)(struct task_struct *, unsigned long) = 0;
const struct cred *kfunc_def(get_task_cred)(struct task_struct *) = 0;
struct cred *kfunc_def(cred_alloc_blank)(void) = 0;
struct cred *kfunc_def(prepare_creds)(void) = 0;
struct cred *kfunc_def(prepare_exec_creds)(void) = 0;
int kfunc_def(commit_creds)(struct cred *) = 0;
void kfunc_def(abort_creds)(struct cred *) = 0;
const struct cred *kfunc_def(override_creds)(const struct cred *) = 0;
void kfunc_def(revert_creds)(const struct cred *) = 0;
struct cred *kfunc_def(prepare_kernel_cred)(struct task_struct *) = 0;
int kfunc_def(change_create_files_as)(struct cred *, struct inode *) = 0;
int kfunc_def(set_security_override)(struct cred *, u32) = 0;
int kfunc_def(set_security_override_from_ctx)(struct cred *, const char *) = 0;
int kfunc_def(set_create_files_as)(struct cred *, struct inode *) = 0;
int kfunc_def(cred_fscmp)(const struct cred *, const struct cred *) = 0;
void kfunc_def(cred_init)(void) = 0;
bool kfunc_def(creds_are_invalid)(const struct cred *cred) = 0;

void _linux_kernel_cred_sym_match(const char *name, unsigned long addr)
{
#ifdef USE_KALLSYMS_LOOKUP_NAME_INSTEAD
    kvar_match(init_cred, name, addr);
#else
    kvar_match_len(init_cred, name, addr);
#endif
    kvar_match(init_groups, name, addr);
    kfunc_match(__put_cred, name, addr);
    kfunc_match(exit_creds, name, addr);
    kfunc_match(copy_creds, name, addr);
    kfunc_match(get_task_cred, name, addr);
    kfunc_match(cred_alloc_blank, name, addr);
    kfunc_match(prepare_creds, name, addr);
    kfunc_match(prepare_exec_creds, name, addr);
    kfunc_match(commit_creds, name, addr);
    kfunc_match(abort_creds, name, addr);
    kfunc_match(override_creds, name, addr);
    kfunc_match(revert_creds, name, addr);
    kfunc_match(prepare_kernel_cred, name, addr);
    kfunc_match(change_create_files_as, name, addr);
    kfunc_match(set_security_override, name, addr);
    kfunc_match(set_security_override_from_ctx, name, addr);
    kfunc_match(set_create_files_as, name, addr);
    kfunc_match(cred_fscmp, name, addr);
    kfunc_match(cred_init, name, addr);
    kfunc_match(creds_are_invalid, name, addr);
}

// kernel/locking/spinlock.c
#include <linux/spinlock.h>

int kfunc_def(_raw_spin_trylock)(raw_spinlock_t *lock) = 0;
int kfunc_def(_raw_spin_trylock_bh)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_lock)(raw_spinlock_t *lock) = 0;
unsigned long kfunc_def(_raw_spin_lock_irqsave)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_lock_irq)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_lock_bh)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_unlock)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_unlock_irqrestore)(raw_spinlock_t *lock, unsigned long flags) = 0;
void kfunc_def(_raw_spin_unlock_irq)(raw_spinlock_t *lock) = 0;
void kfunc_def(_raw_spin_unlock_bh)(raw_spinlock_t *lock) = 0;
int kfunc_def(_raw_read_trylock)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_lock)(rwlock_t *lock) = 0;
unsigned long kfunc_def(_raw_read_lock_irqsave)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_lock_irq)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_lock_bh)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_unlock)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_unlock_irqrestore)(rwlock_t *lock, unsigned long flags) = 0;
void kfunc_def(_raw_read_unlock_irq)(rwlock_t *lock) = 0;
void kfunc_def(_raw_read_unlock_bh)(rwlock_t *lock) = 0;
int kfunc_def(_raw_write_trylock)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_lock)(rwlock_t *lock) = 0;
unsigned long kfunc_def(_raw_write_lock_irqsave)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_lock_irq)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_lock_bh)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_unlock)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_unlock_irqrestore)(rwlock_t *lock, unsigned long flags) = 0;
void kfunc_def(_raw_write_unlock_irq)(rwlock_t *lock) = 0;
void kfunc_def(_raw_write_unlock_bh)(rwlock_t *lock) = 0;

void _linux_locking_spinlock_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(_raw_spin_trylock, name, addr);
    kfunc_match(_raw_spin_trylock_bh, name, addr);
    kfunc_match(_raw_spin_lock, name, addr);
    kfunc_match(_raw_spin_lock_irqsave, name, addr);
    kfunc_match(_raw_spin_lock_irq, name, addr);
    kfunc_match(_raw_spin_lock_bh, name, addr);
    kfunc_match(_raw_spin_unlock, name, addr);
    kfunc_match(_raw_spin_unlock_irqrestore, name, addr);
    kfunc_match(_raw_spin_unlock_irq, name, addr);
    kfunc_match(_raw_spin_unlock_bh, name, addr);
    kfunc_match(_raw_read_trylock, name, addr);
    kfunc_match(_raw_read_lock, name, addr);
    kfunc_match(_raw_read_lock_irqsave, name, addr);
    kfunc_match(_raw_read_lock_irq, name, addr);
    kfunc_match(_raw_read_lock_bh, name, addr);
    kfunc_match(_raw_read_unlock, name, addr);
    kfunc_match(_raw_read_unlock_irqrestore, name, addr);
    kfunc_match(_raw_read_unlock_irq, name, addr);
    kfunc_match(_raw_read_unlock_bh, name, addr);
    kfunc_match(_raw_write_trylock, name, addr);
    kfunc_match(_raw_write_lock, name, addr);
    kfunc_match(_raw_write_lock_irqsave, name, addr);
    kfunc_match(_raw_write_lock_irq, name, addr);
    kfunc_match(_raw_write_lock_bh, name, addr);
    kfunc_match(_raw_write_unlock, name, addr);
    kfunc_match(_raw_write_unlock_irqrestore, name, addr);
    kfunc_match(_raw_write_unlock_irq, name, addr);
    kfunc_match(_raw_write_unlock_bh, name, addr);
}

// kernel/fork.c
#include <ksyms.h>

struct file;
struct mm_struct;
struct task_struct;
struct kernel_clone_args;
struct files_struct;

struct pid *kfunc_def(pidfd_pid)(const struct file *file) = 0;
void kfunc_def(free_task)(struct task_struct *tsk) = 0;
void kfunc_def(__put_task_struct)(struct task_struct *tsk) = 0;
void kfunc_def(fork_init)(void) = 0;
void kfunc_def(set_mm_exe_file)(struct mm_struct *mm, struct file *new_exe_file) = 0;
struct file *kfunc_def(get_mm_exe_file)(struct mm_struct *mm) = 0;
struct file *kfunc_def(get_task_exe_file)(struct task_struct *task) = 0;
struct mm_struct *kfunc_def(get_task_mm)(struct task_struct *task) = 0;
struct mm_struct *kfunc_def(mm_access)(struct task_struct *task, unsigned int mode) = 0;
void kfunc_def(exit_mm_release)(struct task_struct *tsk, struct mm_struct *mm) = 0;
void kfunc_def(exec_mm_release)(struct task_struct *tsk, struct mm_struct *mm) = 0;
struct task_struct *kfunc_def(fork_idle)(int cpu) = 0;
struct mm_struct *kfunc_def(copy_init_mm)(void) = 0;
struct task_struct *kfunc_def(create_io_thread)(int (*fn)(void *), void *arg, int node) = 0;
pid_t kfunc_def(kernel_clone)(struct kernel_clone_args *args) = 0;
pid_t kfunc_def(kernel_thread)(int (*fn)(void *), void *arg, unsigned long flags) = 0;
int kfunc_def(unshare_fd)(unsigned long unshare_flags, unsigned int max_fds, struct files_struct **new_fdp) = 0;
int kfunc_def(ksys_unshare)(unsigned long unshare_flags) = 0;
int kfunc_def(unshare_files)(struct files_struct **displaced) = 0;

void _linux_kernel_fork_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(pidfd_pid, name, addr);
    kfunc_match(get_mm_exe_file, name, addr);
    kfunc_match(free_task, name, addr);
    kfunc_match(__put_task_struct, name, addr);
    kfunc_match(fork_init, name, addr);
    kfunc_match(set_mm_exe_file, name, addr);
    kfunc_match(get_mm_exe_file, name, addr);
    kfunc_match(get_task_exe_file, name, addr);
    kfunc_match(get_task_mm, name, addr);
    kfunc_match(mm_access, name, addr);
    kfunc_match(exit_mm_release, name, addr);
    kfunc_match(exec_mm_release, name, addr);
    kfunc_match(fork_idle, name, addr);
    kfunc_match(copy_init_mm, name, addr);
    kfunc_match(create_io_thread, name, addr);
    kfunc_match(kernel_clone, name, addr);
    kfunc_match(kernel_thread, name, addr);
    kfunc_match(unshare_fd, name, addr);
    kfunc_match(ksys_unshare, name, addr);
    kfunc_match(unshare_files, name, addr);
}

// kernel/pid.c
#include <linux/pid.h>
#include <linux/sched/task.h>
#include <linux/sched.h>

struct pid *kfunc_def(pidfd_get_pid)(unsigned int fd, unsigned int *flags) = 0;
void kfunc_def(put_pid)(struct pid *pid) = 0;
struct task_struct *kfunc_def(pid_task)(struct pid *pid, enum pid_type) = 0;
struct task_struct *kfunc_def(get_pid_task)(struct pid *pid, enum pid_type) = 0;
struct pid *kfunc_def(get_task_pid)(struct task_struct *task, enum pid_type type) = 0;
void kfunc_def(attach_pid)(struct task_struct *task, enum pid_type) = 0;
void kfunc_def(detach_pid)(struct task_struct *task, enum pid_type) = 0;
void kfunc_def(change_pid)(struct task_struct *task, enum pid_type, struct pid *pid) = 0;
void kfunc_def(exchange_tids)(struct task_struct *task, struct task_struct *old) = 0;
void kfunc_def(transfer_pid)(struct task_struct *old, struct task_struct *new, enum pid_type) = 0;

pid_t kfunc_def(__task_pid_nr_ns)(struct task_struct *task, enum pid_type type, struct pid_namespace *ns) = 0;
struct pid_namespace *kfunc_def(task_active_pid_ns)(struct task_struct *tsk) = 0;
struct pid *kfunc_def(find_pid_ns)(int nr, struct pid_namespace *ns) = 0;
struct pid *kfunc_def(find_vpid)(int nr) = 0;
struct pid *kfunc_def(find_get_pid)(int nr) = 0;
struct pid *kfunc_def(find_ge_pid)(int nr, struct pid_namespace *ns) = 0;
struct pid *kfunc_def(alloc_pid)(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size) = 0;
void kfunc_def(free_pid)(struct pid *pid) = 0;
void kfunc_def(disable_pid_allocation)(struct pid_namespace *ns) = 0;
pid_t kfunc_def(pid_nr_ns)(struct pid *pid, struct pid_namespace *ns) = 0;
pid_t kfunc_def(pid_vnr)(struct pid *pid) = 0;

struct task_struct *kfunc_def(find_task_by_vpid)(pid_t nr) = 0;
struct task_struct *kfunc_def(find_task_by_pid_ns)(pid_t nr, struct pid_namespace *ns) = 0;
struct task_struct *kfunc_def(find_get_task_by_vpid)(pid_t nr) = 0;

void _linux_kernel_pid_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(pidfd_get_pid, name, addr);
    kfunc_match(put_pid, name, addr);
    kfunc_match(pid_task, name, addr);
    kfunc_match(get_pid_task, name, addr);
    kfunc_match(get_task_pid, name, addr);
    kfunc_match(attach_pid, name, addr);
    kfunc_match(detach_pid, name, addr);
    kfunc_match(change_pid, name, addr);
    kfunc_match(exchange_tids, name, addr);
    kfunc_match(transfer_pid, name, addr);

    kfunc_match(__task_pid_nr_ns, name, addr);
    kfunc_match(task_active_pid_ns, name, addr);
    kfunc_match(find_pid_ns, name, addr);
    kfunc_match(find_vpid, name, addr);
    kfunc_match(find_get_pid, name, addr);
    kfunc_match(find_ge_pid, name, addr);
    kfunc_match(alloc_pid, name, addr);
    kfunc_match(free_pid, name, addr);
    kfunc_match(disable_pid_allocation, name, addr);
    kfunc_match(pid_nr_ns, name, addr);
    kfunc_match(pid_vnr, name, addr);

    kfunc_match(find_task_by_vpid, name, addr);
    kfunc_match(find_task_by_pid_ns, name, addr);
    kfunc_match(find_get_task_by_vpid, name, addr);
}

// kernel/stop_machine.c
#include <linux/stop_machine.h>

int kfunc_def(stop_machine)(int (*fn)(void *), void *data, const struct cpumask *cpus) = 0;

void _linux_kernel_stop_machine_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(stop_machine, name, addr);
}

// lib/argv_split.c

void kfunc_def(argv_free)(char **argv) = 0;
char **kfunc_def(argv_split)(gfp_t gfp, const char *str, int *argcp) = 0;

void _linux_lib_argv_split_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(argv_free, name, addr);
    kfunc_match(argv_split, name, addr);
}

// lib/kstrtox.c
int kfunc_def(kstrtoull)(const char *s, unsigned int base, unsigned long long *res) = 0;
int kfunc_def(kstrtoll)(const char *s, unsigned int base, long long *res) = 0;
int kfunc_def(kstrtouint)(const char *s, unsigned int base, unsigned int *res) = 0;
int kfunc_def(kstrtoint)(const char *s, unsigned int base, int *res) = 0;
int kfunc_def(kstrtou16)(const char *s, unsigned int base, u16 *res) = 0;
int kfunc_def(kstrtos16)(const char *s, unsigned int base, s16 *res) = 0;
int kfunc_def(kstrtou8)(const char *s, unsigned int base, u8 *res) = 0;
int kfunc_def(kstrtos8)(const char *s, unsigned int base, s8 *res) = 0;
int kfunc_def(kstrtobool)(const char *s, bool *res) = 0;
int kfunc_def(kstrtobool_from_user)(const char __user *s, size_t count, bool *res) = 0;

void _linxu_lib_kstrtox_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(kstrtoull, name, addr);
    kfunc_match(kstrtoll, name, addr);
    kfunc_match(kstrtouint, name, addr);
    kfunc_match(kstrtoint, name, addr);
    kfunc_match(kstrtou16, name, addr);
    kfunc_match(kstrtos16, name, addr);
    kfunc_match(kstrtou8, name, addr);
    kfunc_match(kstrtos8, name, addr);
    kfunc_match(kstrtobool, name, addr);
    kfunc_match(kstrtobool_from_user, name, addr);
}

// lib/string.c
#include <linux/string.h>

int kfunc_def(strncasecmp)(const char *s1, const char *s2, size_t len) = 0;
int kfunc_def(strcasecmp)(const char *s1, const char *s2) = 0;
char *kfunc_def(strcpy)(char *dest, const char *src) = 0;
char *kfunc_def(strncpy)(char *dest, const char *src, size_t count) = 0;
size_t kfunc_def(strlcpy)(char *dest, const char *src, size_t size) = 0;
ssize_t kfunc_def(strscpy)(char *dest, const char *src, size_t count) = 0;
ssize_t kfunc_def(strscpy_pad)(char *dest, const char *src, size_t count) = 0;
char *kfunc_def(stpcpy)(char *__restrict__ dest, const char *__restrict__ src) = 0;
char *kfunc_def(strcat)(char *dest, const char *src) = 0;
char *kfunc_def(strncat)(char *dest, const char *src, size_t count) = 0;
size_t kfunc_def(strlcat)(char *dest, const char *src, size_t count) = 0;
int kfunc_def(strcmp)(const char *cs, const char *ct) = 0;
int kfunc_def(strncmp)(const char *cs, const char *ct, size_t count) = 0;
char *kfunc_def(strchr)(const char *s, int c) = 0;
char *kfunc_def(strchrnul)(const char *s, int c) = 0;
char *kfunc_def(strnchrnul)(const char *s, size_t count, int c) = 0;
char *kfunc_def(strrchr)(const char *s, int c) = 0;
char *kfunc_def(strnchr)(const char *s, size_t count, int c) = 0;
char *kfunc_def(skip_spaces)(const char *str) = 0;
char *kfunc_def(strim)(char *s) = 0;
size_t kfunc_def(strlen)(const char *s) = 0;
size_t kfunc_def(strnlen)(const char *s, size_t count) = 0;
size_t kfunc_def(strspn)(const char *s, const char *accept) = 0;
size_t kfunc_def(strcspn)(const char *s, const char *reject) = 0;
char *kfunc_def(strpbrk)(const char *cs, const char *ct) = 0;
char *kfunc_def(strsep)(char **s, const char *ct) = 0;
bool kfunc_def(sysfs_streq)(const char *s1, const char *s2) = 0;
int kfunc_def(match_string)(const char *const *array, size_t n, const char *string) = 0;
int kfunc_def(__sysfs_match_string)(const char *const *array, size_t n, const char *str) = 0;
void *kfunc_def(memset)(void *s, int c, size_t count) = 0;
void *kfunc_def(memset16)(uint16_t *s, uint16_t v, size_t count) = 0;
void *kfunc_def(memset32)(uint32_t *s, uint32_t v, size_t count) = 0;
void *kfunc_def(memset64)(uint64_t *s, uint64_t v, size_t count) = 0;
void *kfunc_def(memcpy)(void *dest, const void *src, size_t count) = 0;
void *kfunc_def(memmove)(void *dest, const void *src, size_t count) = 0;
int kfunc_def(memcmp)(const void *cs, const void *ct, size_t count) = 0;
int kfunc_def(bcmp)(const void *a, const void *b, size_t len) = 0;
void *kfunc_def(memscan)(void *addr, int c, size_t size) = 0;
char *kfunc_def(strstr)(const char *s1, const char *s2) = 0;
char *kfunc_def(strnstr)(const char *s1, const char *s2, size_t len) = 0;
void *kfunc_def(memchr)(const void *s, int c, size_t n) = 0;
void *kfunc_def(memchr_inv)(const void *start, int c, size_t bytes) = 0;
char *kfunc_def(strreplace)(char *s, char old, char new) = 0;
void kfunc_def(fortify_panic)(const char *name) = 0;

void _linux_lib_string_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(strncasecmp, name, addr);
    kfunc_match(strcasecmp, name, addr);
    kfunc_match(strcpy, name, addr);
    kfunc_match(strncpy, name, addr);
    kfunc_match(strlcpy, name, addr);
    kfunc_match(strscpy, name, addr);
    kfunc_match(strscpy_pad, name, addr);
    kfunc_match(stpcpy, name, addr);
    kfunc_match(strcat, name, addr);
    kfunc_match(strncat, name, addr);
    kfunc_match(strlcat, name, addr);
    kfunc_match(strcmp, name, addr);
    kfunc_match(strncmp, name, addr);
    kfunc_match(strchr, name, addr);
    kfunc_match(strchrnul, name, addr);
    kfunc_match(strnchrnul, name, addr);
    kfunc_match(strrchr, name, addr);
    kfunc_match(strnchr, name, addr);
    kfunc_match(skip_spaces, name, addr);
    kfunc_match(strim, name, addr);
    kfunc_match(strlen, name, addr);
    kfunc_match(strnlen, name, addr);
    kfunc_match(strspn, name, addr);
    kfunc_match(strcspn, name, addr);
    kfunc_match(strpbrk, name, addr);
    kfunc_match(strsep, name, addr);
    kfunc_match(sysfs_streq, name, addr);
    kfunc_match(match_string, name, addr);
    kfunc_match(__sysfs_match_string, name, addr);
    kfunc_match(memset, name, addr);
    kfunc_match(memset16, name, addr);
    kfunc_match(memset32, name, addr);
    kfunc_match(memset64, name, addr);
    kfunc_match(memcpy, name, addr);
    kfunc_match(memmove, name, addr);
    kfunc_match(memcmp, name, addr);
    kfunc_match(bcmp, name, addr);
    kfunc_match(memscan, name, addr);
    kfunc_match(strstr, name, addr);
    kfunc_match(strnstr, name, addr);
    kfunc_match(memchr, name, addr);
    kfunc_match(memchr_inv, name, addr);
    kfunc_match(strreplace, name, addr);
    kfunc_match(fortify_panic, name, addr);
}

// lib/strncpy_from_user.c
#include <linux/uaccess.h>

long kfunc_def(strncpy_from_user)(char *dst, const char __user *src, long count) = 0;

void _linux_lib_strncpy_from_user_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(strncpy_from_user, name, addr);
}

// lib/strnlen_user.c
#include <linux/uaccess.h>

long kfunc_def(strnlen_user)(const char __user *str, long count) = 0;

void _linxu_lib_strnlen_user_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(strnlen_user, name, addr);
}

// mm/util.c
struct file;
struct page;
struct address_space;
struct task_struct;

void kfunc_def(kfree_const)(const void *x) = 0;
char *kfunc_def(kstrdup)(const char *s, gfp_t gfp) = 0;
const char *kfunc_def(kstrdup_const)(const char *s, gfp_t gfp) = 0;
char *kfunc_def(kstrndup)(const char *s, size_t max, gfp_t gfp) = 0;
void *kfunc_def(kmemdup)(const void *src, size_t len, gfp_t gfp) = 0;
char *kfunc_def(kmemdup_nul)(const char *s, size_t len, gfp_t gfp) = 0;
void *kfunc_def(memdup_user)(const void __user *src, size_t len) = 0;
void *kfunc_def(vmemdup_user)(const void __user *src, size_t len) = 0;
char *kfunc_def(strndup_user)(const char __user *s, long n) = 0;
void *kfunc_def(memdup_user_nul)(const void __user *src, size_t len) = 0;
unsigned long kfunc_def(vm_mmap)(struct file *file, unsigned long addr, unsigned long len, unsigned long prot,
                                 unsigned long flag, unsigned long offset) = 0;
void *kfunc_def(kvmalloc_node)(size_t size, gfp_t flags, int node) = 0;
void kfunc_def(kvfree)(const void *addr) = 0;
void kfunc_def(kvfree_sensitive)(const void *addr, size_t len) = 0;
void *kfunc_def(kvrealloc)(const void *p, size_t oldsize, size_t newsize, gfp_t flags) = 0;
bool kfunc_def(page_mapped)(struct page *page) = 0;
struct address_space *kfunc_def(page_mapping)(struct page *page) = 0;
int kfunc_def(__page_mapcount)(struct page *page) = 0;
unsigned long kfunc_def(vm_memory_committed)(void) = 0;
int kfunc_def(get_cmdline)(struct task_struct *task, char *buffer, int buflen) = 0; // not exported

void _linux_mm_utils_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(kfree_const, name, addr);
    kfunc_match(kstrdup, name, addr);
    kfunc_match(kstrdup_const, name, addr);
    kfunc_match(kstrndup, name, addr);
    kfunc_match(kmemdup, name, addr);
    kfunc_match(kmemdup_nul, name, addr);
    kfunc_match(memdup_user, name, addr);
    kfunc_match(vmemdup_user, name, addr);
    kfunc_match(strndup_user, name, addr);
    kfunc_match(memdup_user_nul, name, addr);
    kfunc_match(vm_mmap, name, addr);
    kfunc_match(kvmalloc_node, name, addr);
    kfunc_match(kvfree, name, addr);
    kfunc_match(kvfree_sensitive, name, addr);
    kfunc_match(kvrealloc, name, addr);
    kfunc_match(page_mapped, name, addr);
    kfunc_match(page_mapping, name, addr);
    kfunc_match(__page_mapcount, name, addr);
    kfunc_match(vm_memory_committed, name, addr);
    kfunc_match(get_cmdline, name, addr);
}

// lib/dump_stack.c
void kfunc_def(dump_stack_lvl)(const char *log_lvl) = 0;
void kfunc_def(dump_stack)(void) = 0;

void _linux_lib_dump_stack_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(dump_stack_lvl, name, addr);
    kfunc_match(dump_stack, name, addr);
}

// mm/vmalloc.c
#include <linux/vmalloc.h>

void kfunc_def(vm_unmap_ram)(const void *mem, unsigned int count) = 0;
void *kfunc_def(vm_map_ram)(struct page **pages, unsigned int count, int node) = 0;
void kfunc_def(vm_unmap_aliases)(void) = 0;

void *kfunc_def(vmalloc)(unsigned long size) = 0;
void *kfunc_def(vzalloc)(unsigned long size) = 0;
void *kfunc_def(vmalloc_user)(unsigned long size) = 0;
void *kfunc_def(vmalloc_node)(unsigned long size, int node) = 0;
void *kfunc_def(vzalloc_node)(unsigned long size, int node) = 0;
void *kfunc_def(vmalloc_32)(unsigned long size) = 0;
void *kfunc_def(vmalloc_32_user)(unsigned long size) = 0;
void *kfunc_def(__vmalloc)(unsigned long size, gfp_t gfp_mask) = 0;
void *kfunc_def(__vmalloc_node_range)(unsigned long size, unsigned long align, unsigned long start, unsigned long end,
                                      gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags, int node,
                                      const void *caller) = 0;
void *kfunc_def(__vmalloc_node)(unsigned long size, unsigned long align, gfp_t gfp_mask, int node,
                                const void *caller) = 0;

void kfunc_def(vfree)(const void *addr) = 0;
void kfunc_def(vfree_atomic)(const void *addr) = 0;

void *kfunc_def(vmap)(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot) = 0;
void *kfunc_def(vmap_pfn)(unsigned long *pfns, unsigned int count, pgprot_t prot) = 0;
void kfunc_def(vunmap)(const void *addr) = 0;
int kfunc_def(remap_vmalloc_range_partial)(struct vm_area_struct *vma, unsigned long uaddr, void *kaddr,
                                           unsigned long pgoff, unsigned long size) = 0;
int kfunc_def(remap_vmalloc_range)(struct vm_area_struct *vma, void *addr, unsigned long pgoff) = 0;

struct vm_struct *kfunc_def(get_vm_area)(unsigned long size, unsigned long flags) = 0;
struct vm_struct *kfunc_def(get_vm_area_caller)(unsigned long size, unsigned long flags, const void *caller) = 0;
struct vm_struct *kfunc_def(__get_vm_area_caller)(unsigned long size, unsigned long flags, unsigned long start,
                                                  unsigned long end, const void *caller) = 0;
void kfunc_def(free_vm_area)(struct vm_struct *area) = 0;
struct vm_struct *kfunc_def(remove_vm_area)(const void *addr) = 0;
struct vm_struct *kfunc_def(find_vm_area)(const void *addr) = 0;

int kfunc_def(map_kernel_range_noflush)(unsigned long start, unsigned long size, pgprot_t prot,
                                        struct page **pages) = 0;
int kfunc_def(map_kernel_range)(unsigned long start, unsigned long size, pgprot_t prot, struct page **pages) = 0;
void kfunc_def(unmap_kernel_range_noflush)(unsigned long addr, unsigned long size) = 0;
void kfunc_def(unmap_kernel_range)(unsigned long addr, unsigned long size) = 0;

long kfunc_def(vread)(char *buf, char *addr, unsigned long count) = 0;
long kfunc_def(vwrite)(char *buf, char *addr, unsigned long count) = 0;

void _linux_mm_vmalloc_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(vm_unmap_ram, name, addr);
    kfunc_match(vm_map_ram, name, addr);
    kfunc_match(vm_unmap_aliases, name, addr);

    kfunc_match(vmalloc, name, addr);
    kfunc_match(vzalloc, name, addr);
    kfunc_match(vmalloc_user, name, addr);
    kfunc_match(vmalloc_node, name, addr);
    kfunc_match(vzalloc_node, name, addr);
    kfunc_match(vmalloc_32, name, addr);
    kfunc_match(vmalloc_32_user, name, addr);
    kfunc_match(__vmalloc, name, addr);
    kfunc_match(__vmalloc_node_range, name, addr);
    kfunc_match(__vmalloc_node, name, addr);

    kfunc_match(vfree, name, addr);
    kfunc_match(vfree_atomic, name, addr);

    kfunc_match(vmap, name, addr);
    kfunc_match(vmap_pfn, name, addr);
    kfunc_match(vunmap, name, addr);
    kfunc_match(remap_vmalloc_range_partial, name, addr);
    kfunc_match(remap_vmalloc_range, name, addr);

    kfunc_match(get_vm_area, name, addr);
    kfunc_match(get_vm_area_caller, name, addr);
    kfunc_match(__get_vm_area_caller, name, addr);
    kfunc_match(free_vm_area, name, addr);
    kfunc_match(remove_vm_area, name, addr);
    kfunc_match(find_vm_area, name, addr);

    kfunc_match(map_kernel_range_noflush, name, addr);
    kfunc_match(map_kernel_range, name, addr);
    kfunc_match(unmap_kernel_range_noflush, name, addr);
    kfunc_match(unmap_kernel_range, name, addr);

    kfunc_match(vread, name, addr);
    kfunc_match(vwrite, name, addr);
}

//
```

`kernel/init/ksyms/misc_len.c`:

```c
#ifndef _KP_MISC_LEN_H_
#define _KP_MISC_LEN_H_

#include <ktypes.h>
#include <ksyms.h>
#include <linux/sched.h>
#include <linux/cred.h>
#include <linux/sched/task.h>
#include <asm/current.h>
#include <linux/init_task.h>

int kvlen(init_task) = -1;
int kvlen(init_cred) = -1;
int kvlen(init_thread_union) = -1;

void linux_sybmol_len_init()
{
    unsigned long offset = 0;
    unsigned long size = 0;
    char mod[16] = { '\0' };
    char name[16] = { '\0' };

    lookup_symbol_attrs((unsigned long)kvar(init_cred), &size, &offset, mod, name);
    kvlen(init_cred) = size;

    lookup_symbol_attrs((unsigned long)kvar(init_task), &size, &offset, mod, name);
    kvlen(init_task) = size;

    lookup_symbol_attrs((unsigned long)kvar(init_thread_union), &size, &offset, mod, name);
    kvlen(init_thread_union) = size;
    thread_size = size;
}

#endif
```

`kernel/init/ksyms/security.c`:

```c
#include <linux/security.h>

//
/* Security operations */
int kfunc_def(security_binder_set_context_mgr)(const struct cred *mgr) = 0;
int kfunc_def(security_binder_transaction)(const struct cred *from, const struct cred *to) = 0;
int kfunc_def(security_binder_transfer_binder)(const struct cred *from, const struct cred *to) = 0;
int kfunc_def(security_binder_transfer_file)(const struct cred *from, const struct cred *to, struct file *file) = 0;
int kfunc_def(security_ptrace_access_check)(struct task_struct *child, unsigned int mode) = 0;
int kfunc_def(security_ptrace_traceme)(struct task_struct *parent) = 0;
int kfunc_def(security_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                               kernel_cap_t *permitted) = 0;
int kfunc_def(security_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                               const kernel_cap_t *inheritable, const kernel_cap_t *permitted) = 0;
int kfunc_def(security_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts) = 0;
int kfunc_def(security_quotactl)(int cmds, int type, int id, struct super_block *sb) = 0;
int kfunc_def(security_quota_on)(struct dentry *dentry) = 0;
int kfunc_def(security_syslog)(int type) = 0;
int kfunc_def(security_settime64)(const struct timespec64 *ts, const struct timezone *tz) = 0;
int kfunc_def(security_vm_enough_memory_mm)(struct mm_struct *mm, long pages) = 0;
int kfunc_def(security_bprm_creds_for_exec)(struct linux_binprm *bprm) = 0;
int kfunc_def(security_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file) = 0;
int kfunc_def(security_bprm_check)(struct linux_binprm *bprm) = 0;
void kfunc_def(security_bprm_committing_creds)(struct linux_binprm *bprm) = 0;
void kfunc_def(security_bprm_committed_creds)(struct linux_binprm *bprm) = 0;
int kfunc_def(security_fs_context_dup)(struct fs_context *fc, struct fs_context *src_fc) = 0;
int kfunc_def(security_fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param) = 0;
int kfunc_def(security_sb_alloc)(struct super_block *sb) = 0;
void kfunc_def(security_sb_delete)(struct super_block *sb) = 0;
void kfunc_def(security_sb_free)(struct super_block *sb) = 0;
void kfunc_def(security_free_mnt_opts)(void **mnt_opts) = 0;
int kfunc_def(security_sb_eat_lsm_opts)(char *options, void **mnt_opts) = 0;
int kfunc_def(security_sb_remount)(struct super_block *sb, void *mnt_opts) = 0;
int kfunc_def(security_sb_kern_mount)(struct super_block *sb) = 0;
int kfunc_def(security_sb_show_options)(struct seq_file *m, struct super_block *sb) = 0;
int kfunc_def(security_sb_statfs)(struct dentry *dentry) = 0;
int kfunc_def(security_sb_mount)(const char *dev_name, const struct path *path, const char *type, unsigned long flags,
                                 void *data) = 0;
int kfunc_def(security_sb_umount)(struct vfsmount *mnt, int flags) = 0;
int kfunc_def(security_sb_pivotroot)(const struct path *old_path, const struct path *new_path) = 0;
int kfunc_def(security_sb_set_mnt_opts)(struct super_block *sb, void *mnt_opts, unsigned long kern_flags,
                                        unsigned long *set_kern_flags) = 0;
int kfunc_def(security_sb_clone_mnt_opts)(const struct super_block *oldsb, struct super_block *newsb,
                                          unsigned long kern_flags, unsigned long *set_kern_flags) = 0;
int kfunc_def(security_add_mnt_opt)(const char *option, const char *val, int len, void **mnt_opts) = 0;
int kfunc_def(security_move_mount)(const struct path *from_path, const struct path *to_path) = 0;
int kfunc_def(security_dentry_init_security)(struct dentry *dentry, int mode, const struct qstr *name, void **ctx,
                                             u32 *ctxlen) = 0;
int kfunc_def(security_dentry_create_files_as)(struct dentry *dentry, int mode, struct qstr *name,
                                               const struct cred *old, struct cred *new) = 0;

//CONFIG_SECURITY_PATH
int kfunc_def(security_path_unlink)(const struct path *dir, struct dentry *dentry) = 0;
int kfunc_def(security_path_mkdir)(const struct path *dir, struct dentry *dentry, umode_t mode) = 0;
int kfunc_def(security_path_rmdir)(const struct path *dir, struct dentry *dentry) = 0;
int kfunc_def(security_path_mknod)(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev) = 0;
int kfunc_def(security_path_truncate)(const struct path *path) = 0;
int kfunc_def(security_path_symlink)(const struct path *dir, struct dentry *dentry, const char *old_name) = 0;
int kfunc_def(security_path_link)(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry) = 0;
int kfunc_def(security_path_rename)(const struct path *old_dir, struct dentry *old_dentry, const struct path *new_dir,
                                    struct dentry *new_dentry, unsigned int flags) = 0;
int kfunc_def(security_path_chmod)(const struct path *path, umode_t mode) = 0;
int kfunc_def(security_path_chown)(const struct path *path, kuid_t uid, kgid_t gid) = 0;
int kfunc_def(security_path_chroot)(const struct path *path) = 0;
/* CONFIG_SECURITY_PATH */

/* Needed for inode based security check */
int kfunc_def(security_path_notify)(const struct path *path, u64 mask, unsigned int obj_type) = 0;
int kfunc_def(security_inode_alloc)(struct inode *inode) = 0;
void kfunc_def(security_inode_free)(struct inode *inode) = 0;
int kfunc_def(security_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                            initxattrs initxattrs, void *fs_data) = 0;
int kfunc_def(security_old_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                                const char **name, void **value, size_t *len) = 0;
int kfunc_def(security_inode_create)(struct inode *dir, struct dentry *dentry, umode_t mode) = 0;
int kfunc_def(security_inode_link)(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry) = 0;
int kfunc_def(security_inode_unlink)(struct inode *dir, struct dentry *dentry) = 0;
int kfunc_def(security_inode_symlink)(struct inode *dir, struct dentry *dentry, const char *old_name) = 0;
int kfunc_def(security_inode_mkdir)(struct inode *dir, struct dentry *dentry, umode_t mode) = 0;
int kfunc_def(security_inode_rmdir)(struct inode *dir, struct dentry *dentry) = 0;
int kfunc_def(security_inode_mknod)(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev) = 0;
int kfunc_def(security_inode_rename)(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir,
                                     struct dentry *new_dentry, unsigned int flags) = 0;
int kfunc_def(security_inode_readlink)(struct dentry *dentry) = 0;
int kfunc_def(security_inode_follow_link)(struct dentry *dentry, struct inode *inode, bool rcu) = 0;
int kfunc_def(security_inode_permission)(struct inode *inode, int mask) = 0;
int kfunc_def(security_inode_setattr)(struct dentry *dentry, struct iattr *attr) = 0;
int kfunc_def(security_inode_getattr)(const struct path *path) = 0;
int kfunc_def(security_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                       int flags) = 0;
void kfunc_def(security_inode_post_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                             int flags) = 0;
int kfunc_def(security_inode_getxattr)(struct dentry *dentry, const char *name) = 0;
int kfunc_def(security_inode_listxattr)(struct dentry *dentry) = 0;
int kfunc_def(security_inode_removexattr)(struct dentry *dentry, const char *name) = 0;
int kfunc_def(security_inode_set_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name,
                                      struct posix_acl *kacl) = 0;
int kfunc_def(security_inode_get_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name) = 0;
int kfunc_def(security_inode_remove_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name) = 0;
int kfunc_def(security_inode_need_killpriv)(struct dentry *dentry) = 0;
int kfunc_def(security_inode_killpriv)(struct dentry *dentry) = 0;
int kfunc_def(security_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc) = 0;
int kfunc_def(security_inode_setsecurity)(struct inode *inode, const char *name, const void *value, size_t size,
                                          int flags) = 0;
int kfunc_def(security_inode_listsecurity)(struct inode *inode, char *buffer, size_t buffer_size) = 0;
void kfunc_def(security_inode_getsecid)(struct inode *inode, u32 *secid) = 0;
int kfunc_def(security_inode_copy_up)(struct dentry *src, struct cred **new) = 0;
int kfunc_def(security_inode_copy_up_xattr)(const char *name) = 0;
int kfunc_def(security_kernfs_init_security)(struct kernfs_node *kn_dir, struct kernfs_node *kn) = 0;
int kfunc_def(security_file_permission)(struct file *file, int mask) = 0;
int kfunc_def(security_file_alloc)(struct file *file) = 0;
void kfunc_def(security_file_free)(struct file *file) = 0;
int kfunc_def(security_file_ioctl)(struct file *file, unsigned int cmd, unsigned long arg) = 0;
int kfunc_def(security_mmap_addr)(unsigned long addr) = 0;
int kfunc_def(security_mmap_file)(struct file *file, unsigned long prot, unsigned long flags) = 0;
int kfunc_def(security_file_mprotect)(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot) = 0;
int kfunc_def(security_file_lock)(struct file *file, unsigned int cmd) = 0;
int kfunc_def(security_file_fcntl)(struct file *file, unsigned int cmd, unsigned long arg) = 0;
void kfunc_def(security_file_set_fowner)(struct file *file) = 0;
int kfunc_def(security_file_send_sigiotask)(struct task_struct *tsk, struct fown_struct *fown, int sig) = 0;
int kfunc_def(security_file_receive)(struct file *file) = 0;
// int kfunc_def(security_file_open)(struct file *file) = 0;
int kfunc_def(security_file_open)(struct file *file, const struct cred *cred) = 0;
int kfunc_def(security_file_truncate)(struct file *file) = 0;
int kfunc_def(security_task_alloc)(struct task_struct *task, unsigned long clone_flags) = 0;
void kfunc_def(security_task_free)(struct task_struct *task) = 0;
int kfunc_def(security_cred_alloc_blank)(struct cred *cred, gfp_t gfp) = 0;
void kfunc_def(security_cred_free)(struct cred *cred) = 0;
int kfunc_def(security_prepare_creds)(struct cred *new, const struct cred *old, gfp_t gfp) = 0;
void kfunc_def(security_transfer_creds)(struct cred *new, const struct cred *old) = 0;
void kfunc_def(security_cred_getsecid)(const struct cred *c, u32 *secid) = 0;
int kfunc_def(security_kernel_act_as)(struct cred *new, u32 secid) = 0;
int kfunc_def(security_kernel_create_files_as)(struct cred *new, struct inode *inode) = 0;
int kfunc_def(security_kernel_module_request)(char *kmod_name) = 0;
int kfunc_def(security_kernel_load_data)(enum kernel_load_data_id id, bool contents) = 0;
int kfunc_def(security_kernel_post_load_data)(char *buf, loff_t size, enum kernel_load_data_id id,
                                              char *description) = 0;
int kfunc_def(security_kernel_read_file)(struct file *file, enum kernel_read_file_id id, bool contents) = 0;
int kfunc_def(security_kernel_post_read_file)(struct file *file, char *buf, loff_t size,
                                              enum kernel_read_file_id id) = 0;
int kfunc_def(security_task_fix_setuid)(struct cred *new, const struct cred *old, int flags) = 0;
int kfunc_def(security_task_fix_setgid)(struct cred *new, const struct cred *old, int flags) = 0;
int kfunc_def(security_task_fix_setgroups)(struct cred *new, const struct cred *old) = 0;
int kfunc_def(security_task_setpgid)(struct task_struct *p, pid_t pgid) = 0;
int kfunc_def(security_task_getpgid)(struct task_struct *p) = 0;
int kfunc_def(security_task_getsid)(struct task_struct *p) = 0;

void kfunc_def(security_current_getsecid_subj)(u32 *secid); // 5.10
void kfunc_def(security_task_getsecid_obj)(struct task_struct *p, u32 *secid); // ?-6.3
void kfunc_def(security_task_getsecid)(struct task_struct *p, u32 *secid); // 4.4-5.10

int kfunc_def(security_task_setnice)(struct task_struct *p, int nice) = 0;
int kfunc_def(security_task_setioprio)(struct task_struct *p, int ioprio) = 0;
int kfunc_def(security_task_getioprio)(struct task_struct *p) = 0;
int kfunc_def(security_task_prlimit)(const struct cred *cred, const struct cred *tcred, unsigned int flags) = 0;
int kfunc_def(security_task_setrlimit)(struct task_struct *p, unsigned int resource, struct rlimit *new_rlim) = 0;
int kfunc_def(security_task_setscheduler)(struct task_struct *p) = 0;
int kfunc_def(security_task_getscheduler)(struct task_struct *p) = 0;
int kfunc_def(security_task_movememory)(struct task_struct *p) = 0;
int kfunc_def(security_task_kill)(struct task_struct *p, struct kernel_siginfo *info, int sig,
                                  const struct cred *cred) = 0;
int kfunc_def(security_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                   unsigned long arg5) = 0;
void kfunc_def(security_task_to_inode)(struct task_struct *p, struct inode *inode) = 0;
int kfunc_def(security_create_user_ns)(const struct cred *cred) = 0;
int kfunc_def(security_ipc_permission)(struct kern_ipc_perm *ipcp, short flag) = 0;
void kfunc_def(security_ipc_getsecid)(struct kern_ipc_perm *ipcp, u32 *secid) = 0;
int kfunc_def(security_msg_msg_alloc)(struct msg_msg *msg) = 0;
void kfunc_def(security_msg_msg_free)(struct msg_msg *msg) = 0;
int kfunc_def(security_msg_queue_alloc)(struct kern_ipc_perm *msq) = 0;
void kfunc_def(security_msg_queue_free)(struct kern_ipc_perm *msq) = 0;
int kfunc_def(security_msg_queue_associate)(struct kern_ipc_perm *msq, int msqflg) = 0;
int kfunc_def(security_msg_queue_msgctl)(struct kern_ipc_perm *msq, int cmd) = 0;
int kfunc_def(security_msg_queue_msgsnd)(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg) = 0;
int kfunc_def(security_msg_queue_msgrcv)(struct kern_ipc_perm *msq, struct msg_msg *msg, struct task_struct *target,
                                         long type, int mode) = 0;
int kfunc_def(security_shm_alloc)(struct kern_ipc_perm *shp) = 0;
void kfunc_def(security_shm_free)(struct kern_ipc_perm *shp) = 0;
int kfunc_def(security_shm_associate)(struct kern_ipc_perm *shp, int shmflg) = 0;
int kfunc_def(security_shm_shmctl)(struct kern_ipc_perm *shp, int cmd) = 0;
int kfunc_def(security_shm_shmat)(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg) = 0;
int kfunc_def(security_sem_alloc)(struct kern_ipc_perm *sma) = 0;
void kfunc_def(security_sem_free)(struct kern_ipc_perm *sma) = 0;
int kfunc_def(security_sem_associate)(struct kern_ipc_perm *sma, int semflg) = 0;
int kfunc_def(security_sem_semctl)(struct kern_ipc_perm *sma, int cmd) = 0;
int kfunc_def(security_sem_semop)(struct kern_ipc_perm *sma, struct sembuf *sops, unsigned nsops, int alter) = 0;
void kfunc_def(security_d_instantiate)(struct dentry *dentry, struct inode *inode) = 0;
int kfunc_def(security_getprocattr)(struct task_struct *p, const char *lsm, char *name, char **value) = 0;
int kfunc_def(security_setprocattr)(const char *lsm, const char *name, void *value, size_t size) = 0;
int kfunc_def(security_netlink_send)(struct sock *sk, struct sk_buff *skb) = 0;
int kfunc_def(security_ismaclabel)(const char *name) = 0;
int kfunc_def(security_secid_to_secctx)(u32 secid, char **secdata, u32 *seclen) = 0;
int kfunc_def(security_secctx_to_secid)(const char *secdata, u32 seclen, u32 *secid) = 0;
void kfunc_def(security_release_secctx)(char *secdata, u32 seclen) = 0;
void kfunc_def(security_inode_invalidate_secctx)(struct inode *inode) = 0;
int kfunc_def(security_inode_notifysecctx)(struct inode *inode, void *ctx, u32 ctxlen) = 0;
int kfunc_def(security_inode_setsecctx)(struct dentry *dentry, void *ctx, u32 ctxlen) = 0;
int kfunc_def(security_inode_getsecctx)(struct inode *inode, void **ctx, u32 *ctxlen) = 0;

// CONFIG_WATCH_QUEUE
int kfunc_def(security_post_notification)(const struct cred *w_cred, const struct cred *cred,
                                          struct watch_notification *n) = 0;

// CONFIG_KEY_NOTIFICATIONS
int kfunc_def(security_watch_key)(struct key *key) = 0;

// CONFIG_SECURITY_NETWORK
int kfunc_def(security_unix_stream_connect)(struct sock *sock, struct sock *other, struct sock *newsk) = 0;
int kfunc_def(security_unix_may_send)(struct socket *sock, struct socket *other) = 0;
int kfunc_def(security_socket_create)(int family, int type, int protocol, int kern) = 0;
int kfunc_def(security_socket_post_create)(struct socket *sock, int family, int type, int protocol, int kern) = 0;
int kfunc_def(security_socket_socketpair)(struct socket *socka, struct socket *sockb) = 0;
int kfunc_def(security_socket_bind)(struct socket *sock, struct sockaddr *address, int addrlen) = 0;
int kfunc_def(security_socket_connect)(struct socket *sock, struct sockaddr *address, int addrlen) = 0;
int kfunc_def(security_socket_listen)(struct socket *sock, int backlog) = 0;
int kfunc_def(security_socket_accept)(struct socket *sock, struct socket *newsock) = 0;
int kfunc_def(security_socket_sendmsg)(struct socket *sock, struct msghdr *msg, int size) = 0;
int kfunc_def(security_socket_recvmsg)(struct socket *sock, struct msghdr *msg, int size, int flags) = 0;
int kfunc_def(security_socket_getsockname)(struct socket *sock) = 0;
int kfunc_def(security_socket_getpeername)(struct socket *sock) = 0;
int kfunc_def(security_socket_getsockopt)(struct socket *sock, int level, int optname) = 0;
int kfunc_def(security_socket_setsockopt)(struct socket *sock, int level, int optname) = 0;
int kfunc_def(security_socket_shutdown)(struct socket *sock, int how) = 0;
int kfunc_def(security_sock_rcv_skb)(struct sock *sk, struct sk_buff *skb) = 0;
int kfunc_def(security_socket_getpeersec_stream)(struct socket *sock, sockptr_t optval, sockptr_t optlen,
                                                 unsigned int len) = 0;
int kfunc_def(security_socket_getpeersec_dgram)(struct socket *sock, struct sk_buff *skb, u32 *secid) = 0;
int kfunc_def(security_sk_alloc)(struct sock *sk, int family, gfp_t priority) = 0;
void kfunc_def(security_sk_free)(struct sock *sk) = 0;
void kfunc_def(security_sk_clone)(const struct sock *sk, struct sock *newsk) = 0;
void kfunc_def(security_sk_classify_flow)(struct sock *sk, struct flowi_common *flic) = 0;
void kfunc_def(security_req_classify_flow)(const struct request_sock *req, struct flowi_common *flic) = 0;
void kfunc_def(security_sock_graft)(struct sock *sk, struct socket *parent) = 0;
int kfunc_def(security_inet_conn_request)(const struct sock *sk, struct sk_buff *skb, struct request_sock *req) = 0;
void kfunc_def(security_inet_csk_clone)(struct sock *newsk, const struct request_sock *req) = 0;
void kfunc_def(security_inet_conn_established)(struct sock *sk, struct sk_buff *skb) = 0;
int kfunc_def(security_secmark_relabel_packet)(u32 secid) = 0;
void kfunc_def(security_secmark_refcount_inc)(void) = 0;
void kfunc_def(security_secmark_refcount_dec)(void) = 0;
int kfunc_def(security_tun_dev_alloc_security)(void **security) = 0;
void kfunc_def(security_tun_dev_free_security)(void *security) = 0;
int kfunc_def(security_tun_dev_create)(void) = 0;
int kfunc_def(security_tun_dev_attach_queue)(void *security) = 0;
int kfunc_def(security_tun_dev_attach)(struct sock *sk, void *security) = 0;
int kfunc_def(security_tun_dev_open)(void *security) = 0;
int kfunc_def(security_sctp_assoc_request)(struct sctp_association *asoc, struct sk_buff *skb) = 0;
int kfunc_def(security_sctp_bind_connect)(struct sock *sk, int optname, struct sockaddr *address, int addrlen) = 0;
void kfunc_def(security_sctp_sk_clone)(struct sctp_association *asoc, struct sock *sk, struct sock *newsk) = 0;
int kfunc_def(security_sctp_assoc_established)(struct sctp_association *asoc, struct sk_buff *skb) = 0;

// CONFIG_SECURITY_INFINIBAND
int kfunc_def(security_ib_pkey_access)(void *sec, u64 subnet_prefix, u16 pkey) = 0;
int kfunc_def(security_ib_endport_manage_subnet)(void *sec, const char *dev_name, u8 port_num) = 0;
int kfunc_def(security_ib_alloc_security)(void **sec) = 0;
void kfunc_def(security_ib_free_security)(void *sec) = 0;

// CONFIG_SECURITY_NETWORK_XFRM
int kfunc_def(security_xfrm_policy_alloc)(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp) = 0;
int kfunc_def(security_xfrm_policy_clone)(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp) = 0;
void kfunc_def(security_xfrm_policy_free)(struct xfrm_sec_ctx *ctx) = 0;
int kfunc_def(security_xfrm_policy_delete)(struct xfrm_sec_ctx *ctx) = 0;
int kfunc_def(security_xfrm_state_alloc)(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx) = 0;
int kfunc_def(security_xfrm_state_alloc_acquire)(struct xfrm_state *x, struct xfrm_sec_ctx *polsec, u32 secid) = 0;
int kfunc_def(security_xfrm_state_delete)(struct xfrm_state *x) = 0;
void kfunc_def(security_xfrm_state_free)(struct xfrm_state *x) = 0;
int kfunc_def(security_xfrm_policy_lookup)(struct xfrm_sec_ctx *ctx, u32 fl_secid) = 0;
int kfunc_def(security_xfrm_state_pol_flow_match)(struct xfrm_state *x, struct xfrm_policy *xp,
                                                  const struct flowi_common *flic) = 0;
int kfunc_def(security_xfrm_decode_session)(struct sk_buff *skb, u32 *secid) = 0;
void kfunc_def(security_skb_classify_flow)(struct sk_buff *skb, struct flowi_common *flic) = 0;

/* key management security hooks */
// CONFIG_KEYS
typedef void *key_ref_t;
int kfunc_def(security_key_alloc)(struct key *key, const struct cred *cred, unsigned long flags) = 0;
void kfunc_def(security_key_free)(struct key *key) = 0;
int kfunc_def(security_key_permission)(key_ref_t key_ref, const struct cred *cred, enum key_need_perm need_perm) = 0;
int kfunc_def(security_key_getsecurity)(struct key *key, char **_buffer) = 0;

// CONFIG_AUDIT
int kfunc_def(security_audit_rule_init)(u32 field, u32 op, char *rulestr, void **lsmrule) = 0;
int kfunc_def(security_audit_rule_known)(struct audit_krule *krule) = 0;
void kfunc_def(security_audit_rule_free)(void *lsmrule) = 0;
int kfunc_def(security_audit_rule_match)(u32 secid, u32 field, u32 op, void *lsmrule) = 0;

// CONFIG_BPF_SYSCALL
int kfunc_def(security_bpf)(int cmd, union bpf_attr *attr, unsigned int size) = 0;
int kfunc_def(security_bpf_map)(struct bpf_map *map, fmode_t fmode) = 0;
int kfunc_def(security_bpf_prog)(struct bpf_prog *prog) = 0;
int kfunc_def(security_bpf_map_alloc)(struct bpf_map *map) = 0;
int kfunc_def(security_bpf_prog_alloc)(struct bpf_prog_aux *aux) = 0;
void kfunc_def(security_bpf_map_free)(struct bpf_map *map) = 0;
void kfunc_def(security_bpf_prog_free)(struct bpf_prog_aux *aux) = 0;
// CONFIG_BPF_SYSCALL

int kfunc_def(security_locked_down)(enum lockdown_reason what) = 0;

// CONFIG_PERF_EVENTS
int kfunc_def(security_perf_event_open)(struct perf_event_attr *attr, int type) = 0;
int kfunc_def(security_perf_event_alloc)(struct perf_event *event) = 0;
void kfunc_def(security_perf_event_free)(struct perf_event *event) = 0;
int kfunc_def(security_perf_event_read)(struct perf_event *event) = 0;
int kfunc_def(security_perf_event_write)(struct perf_event *event) = 0;

// CONFIG_IO_URING
int kfunc_def(security_uring_override_creds)(const struct cred *new) = 0;
int kfunc_def(security_uring_sqpoll)(void) = 0;
int kfunc_def(security_uring_cmd)(struct io_uring_cmd *ioucmd) = 0;

void _linux_security_security_sym_match(const char *name, unsigned long addr)
{
    /* Security operations */
    kfunc_match(security_binder_set_context_mgr, name, addr);
    kfunc_match(security_binder_transaction, name, addr);
    kfunc_match(security_binder_transfer_binder, name, addr);
    kfunc_match(security_binder_transfer_file, name, addr);
    kfunc_match(security_ptrace_access_check, name, addr);
    kfunc_match(security_ptrace_traceme, name, addr);
    kfunc_match(security_capget, name, addr);
    kfunc_match(security_capset, name, addr);
    kfunc_match(security_capable, name, addr);
    kfunc_match(security_quotactl, name, addr);
    kfunc_match(security_quota_on, name, addr);
    kfunc_match(security_syslog, name, addr);
    kfunc_match(security_settime64, name, addr);
    kfunc_match(security_vm_enough_memory_mm, name, addr);
    kfunc_match(security_bprm_creds_for_exec, name, addr);
    kfunc_match(security_bprm_creds_from_file, name, addr);
    kfunc_match(security_bprm_check, name, addr);
    kfunc_match(security_bprm_committing_creds, name, addr);
    kfunc_match(security_bprm_committed_creds, name, addr);
    kfunc_match(security_fs_context_dup, name, addr);
    kfunc_match(security_fs_context_parse_param, name, addr);
    kfunc_match(security_sb_alloc, name, addr);
    kfunc_match(security_sb_delete, name, addr);
    kfunc_match(security_sb_free, name, addr);
    kfunc_match(security_free_mnt_opts, name, addr);
    kfunc_match(security_sb_eat_lsm_opts, name, addr);
    kfunc_match(security_sb_remount, name, addr);
    kfunc_match(security_sb_kern_mount, name, addr);
    kfunc_match(security_sb_show_options, name, addr);
    kfunc_match(security_sb_statfs, name, addr);
    kfunc_match(security_sb_mount, name, addr);
    kfunc_match(security_sb_umount, name, addr);
    kfunc_match(security_sb_pivotroot, name, addr);
    kfunc_match(security_sb_set_mnt_opts, name, addr);
    kfunc_match(security_sb_clone_mnt_opts, name, addr);
    kfunc_match(security_add_mnt_opt, name, addr);
    kfunc_match(security_move_mount, name, addr);
    kfunc_match(security_dentry_init_security, name, addr);
    kfunc_match(security_dentry_create_files_as, name, addr);

    //CONFIG_SECURITY_PATH
    kfunc_match(security_path_unlink, name, addr);
    kfunc_match(security_path_mkdir, name, addr);
    kfunc_match(security_path_rmdir, name, addr);
    kfunc_match(security_path_mknod, name, addr);
    kfunc_match(security_path_truncate, name, addr);
    kfunc_match(security_path_symlink, name, addr);
    kfunc_match(security_path_link, name, addr);
    kfunc_match(security_path_rename, name, addr);
    kfunc_match(security_path_chmod, name, addr);
    kfunc_match(security_path_chown, name, addr);
    kfunc_match(security_path_chroot, name, addr);
    /* CONFIG_SECURITY_PATH */

    /* Needed for inode based security check */
    kfunc_match(security_path_notify, name, addr);
    kfunc_match(security_inode_alloc, name, addr);
    kfunc_match(security_inode_free, name, addr);
    kfunc_match(security_inode_init_security, name, addr);
    kfunc_match(security_old_inode_init_security, name, addr);
    kfunc_match(security_inode_create, name, addr);
    kfunc_match(security_inode_link, name, addr);
    kfunc_match(security_inode_unlink, name, addr);
    kfunc_match(security_inode_symlink, name, addr);
    kfunc_match(security_inode_mkdir, name, addr);
    kfunc_match(security_inode_rmdir, name, addr);
    kfunc_match(security_inode_mknod, name, addr);
    kfunc_match(security_inode_rename, name, addr);
    kfunc_match(security_inode_readlink, name, addr);
    kfunc_match(security_inode_follow_link, name, addr);
    kfunc_match(security_inode_permission, name, addr);
    kfunc_match(security_inode_setattr, name, addr);
    kfunc_match(security_inode_getattr, name, addr);
    kfunc_match(security_inode_setxattr, name, addr);
    kfunc_match(security_inode_post_setxattr, name, addr);
    kfunc_match(security_inode_getxattr, name, addr);
    kfunc_match(security_inode_listxattr, name, addr);
    kfunc_match(security_inode_removexattr, name, addr);
    kfunc_match(security_inode_set_acl, name, addr);
    kfunc_match(security_inode_get_acl, name, addr);
    kfunc_match(security_inode_remove_acl, name, addr);
    kfunc_match(security_inode_need_killpriv, name, addr);
    kfunc_match(security_inode_killpriv, name, addr);
    kfunc_match(security_inode_getsecurity, name, addr);
    kfunc_match(security_inode_setsecurity, name, addr);
    kfunc_match(security_inode_listsecurity, name, addr);
    kfunc_match(security_inode_getsecid, name, addr);
    kfunc_match(security_inode_copy_up, name, addr);
    kfunc_match(security_inode_copy_up_xattr, name, addr);
    kfunc_match(security_kernfs_init_security, name, addr);
    kfunc_match(security_file_permission, name, addr);
    kfunc_match(security_file_alloc, name, addr);
    kfunc_match(security_file_free, name, addr);
    kfunc_match(security_file_ioctl, name, addr);
    kfunc_match(security_mmap_addr, name, addr);
    kfunc_match(security_mmap_file, name, addr);
    kfunc_match(security_file_mprotect, name, addr);
    kfunc_match(security_file_lock, name, addr);
    kfunc_match(security_file_fcntl, name, addr);
    kfunc_match(security_file_set_fowner, name, addr);
    kfunc_match(security_file_send_sigiotask, name, addr);
    kfunc_match(security_file_receive, name, addr);
    kfunc_match(security_file_open, name, addr);
    kfunc_match(security_file_truncate, name, addr);
    kfunc_match(security_task_alloc, name, addr);
    kfunc_match(security_task_free, name, addr);
    kfunc_match(security_cred_alloc_blank, name, addr);
    kfunc_match(security_cred_free, name, addr);
    kfunc_match(security_prepare_creds, name, addr);
    kfunc_match(security_transfer_creds, name, addr);
    kfunc_match(security_cred_getsecid, name, addr);
    kfunc_match(security_kernel_act_as, name, addr);
    kfunc_match(security_kernel_create_files_as, name, addr);
    kfunc_match(security_kernel_module_request, name, addr);
    kfunc_match(security_kernel_load_data, name, addr);
    kfunc_match(security_kernel_post_load_data, name, addr);
    kfunc_match(security_kernel_read_file, name, addr);
    kfunc_match(security_kernel_post_read_file, name, addr);
    kfunc_match(security_task_fix_setuid, name, addr);
    kfunc_match(security_task_fix_setgid, name, addr);
    kfunc_match(security_task_fix_setgroups, name, addr);
    kfunc_match(security_task_setpgid, name, addr);
    kfunc_match(security_task_getpgid, name, addr);
    kfunc_match(security_task_getsid, name, addr);
    kfunc_match(security_current_getsecid_subj, name, addr);
    kfunc_match(security_task_getsecid_obj, name, addr);
    kfunc_match(security_task_getsecid, name, addr);
    kfunc_match(security_task_setnice, name, addr);
    kfunc_match(security_task_setioprio, name, addr);
    kfunc_match(security_task_getioprio, name, addr);
    kfunc_match(security_task_prlimit, name, addr);
    kfunc_match(security_task_setrlimit, name, addr);
    kfunc_match(security_task_setscheduler, name, addr);
    kfunc_match(security_task_getscheduler, name, addr);
    kfunc_match(security_task_movememory, name, addr);
    kfunc_match(security_task_kill, name, addr);
    kfunc_match(security_task_prctl, name, addr);
    kfunc_match(security_task_to_inode, name, addr);
    kfunc_match(security_create_user_ns, name, addr);
    kfunc_match(security_ipc_permission, name, addr);
    kfunc_match(security_ipc_getsecid, name, addr);
    kfunc_match(security_msg_msg_alloc, name, addr);
    kfunc_match(security_msg_msg_free, name, addr);
    kfunc_match(security_msg_queue_alloc, name, addr);
    kfunc_match(security_msg_queue_free, name, addr);
    kfunc_match(security_msg_queue_associate, name, addr);
    kfunc_match(security_msg_queue_msgctl, name, addr);
    kfunc_match(security_msg_queue_msgsnd, name, addr);
    kfunc_match(security_msg_queue_msgrcv, name, addr);
    kfunc_match(security_shm_alloc, name, addr);
    kfunc_match(security_shm_free, name, addr);
    kfunc_match(security_shm_associate, name, addr);
    kfunc_match(security_shm_shmctl, name, addr);
    kfunc_match(security_shm_shmat, name, addr);
    kfunc_match(security_sem_alloc, name, addr);
    kfunc_match(security_sem_free, name, addr);
    kfunc_match(security_sem_associate, name, addr);
    kfunc_match(security_sem_semctl, name, addr);
    kfunc_match(security_sem_semop, name, addr);
    kfunc_match(security_d_instantiate, name, addr);
    kfunc_match(security_getprocattr, name, addr);
    kfunc_match(security_setprocattr, name, addr);
    kfunc_match(security_netlink_send, name, addr);
    kfunc_match(security_ismaclabel, name, addr);
    kfunc_match(security_secid_to_secctx, name, addr);
    kfunc_match(security_secctx_to_secid, name, addr);
    kfunc_match(security_release_secctx, name, addr);
    kfunc_match(security_inode_invalidate_secctx, name, addr);
    kfunc_match(security_inode_notifysecctx, name, addr);
    kfunc_match(security_inode_setsecctx, name, addr);
    kfunc_match(security_inode_getsecctx, name, addr);

    // CONFIG_WATCH_QUEUE
    kfunc_match(security_post_notification, name, addr);

    // CONFIG_KEY_NOTIFICATIONS
    kfunc_match(security_watch_key, name, addr);

    // CONFIG_SECURITY_NETWORK
    kfunc_match(security_unix_stream_connect, name, addr);
    kfunc_match(security_unix_may_send, name, addr);
    kfunc_match(security_socket_create, name, addr);
    kfunc_match(security_socket_post_create, name, addr);
    kfunc_match(security_socket_socketpair, name, addr);
    kfunc_match(security_socket_bind, name, addr);
    kfunc_match(security_socket_connect, name, addr);
    kfunc_match(security_socket_listen, name, addr);
    kfunc_match(security_socket_accept, name, addr);
    kfunc_match(security_socket_sendmsg, name, addr);
    kfunc_match(security_socket_recvmsg, name, addr);
    kfunc_match(security_socket_getsockname, name, addr);
    kfunc_match(security_socket_getpeername, name, addr);
    kfunc_match(security_socket_getsockopt, name, addr);
    kfunc_match(security_socket_setsockopt, name, addr);
    kfunc_match(security_socket_shutdown, name, addr);
    kfunc_match(security_sock_rcv_skb, name, addr);
    kfunc_match(security_socket_getpeersec_stream, name, addr);
    kfunc_match(security_socket_getpeersec_dgram, name, addr);
    kfunc_match(security_sk_alloc, name, addr);
    kfunc_match(security_sk_free, name, addr);
    kfunc_match(security_sk_clone, name, addr);
    kfunc_match(security_sk_classify_flow, name, addr);
    kfunc_match(security_req_classify_flow, name, addr);
    kfunc_match(security_sock_graft, name, addr);
    kfunc_match(security_inet_conn_request, name, addr);
    kfunc_match(security_inet_csk_clone, name, addr);
    kfunc_match(security_inet_conn_established, name, addr);
    kfunc_match(security_secmark_relabel_packet, name, addr);
    kfunc_match(security_secmark_refcount_inc, name, addr);
    kfunc_match(security_secmark_refcount_dec, name, addr);
    kfunc_match(security_tun_dev_alloc_security, name, addr);
    kfunc_match(security_tun_dev_free_security, name, addr);
    kfunc_match(security_tun_dev_create, name, addr);
    kfunc_match(security_tun_dev_attach_queue, name, addr);
    kfunc_match(security_tun_dev_attach, name, addr);
    kfunc_match(security_tun_dev_open, name, addr);
    kfunc_match(security_sctp_assoc_request, name, addr);
    kfunc_match(security_sctp_bind_connect, name, addr);
    kfunc_match(security_sctp_sk_clone, name, addr);
    kfunc_match(security_sctp_assoc_established, name, addr);

    // CONFIG_SECURITY_INFINIBAND
    kfunc_match(security_ib_pkey_access, name, addr);
    kfunc_match(security_ib_endport_manage_subnet, name, addr);
    kfunc_match(security_ib_alloc_security, name, addr);
    kfunc_match(security_ib_free_security, name, addr);

    // CONFIG_SECURITY_NETWORK_XFRM
    kfunc_match(security_xfrm_policy_alloc, name, addr);
    kfunc_match(security_xfrm_policy_clone, name, addr);
    kfunc_match(security_xfrm_policy_free, name, addr);
    kfunc_match(security_xfrm_policy_delete, name, addr);
    kfunc_match(security_xfrm_state_alloc, name, addr);
    kfunc_match(security_xfrm_state_alloc_acquire, name, addr);
    kfunc_match(security_xfrm_state_delete, name, addr);
    kfunc_match(security_xfrm_state_free, name, addr);
    kfunc_match(security_xfrm_policy_lookup, name, addr);
    kfunc_match(security_xfrm_state_pol_flow_match, name, addr);
    kfunc_match(security_xfrm_decode_session, name, addr);
    kfunc_match(security_skb_classify_flow, name, addr);

    /* key management security hooks */
    // CONFIG_KEYS
    kfunc_match(security_key_alloc, name, addr);
    kfunc_match(security_key_free, name, addr);
    kfunc_match(security_key_permission, name, addr);
    kfunc_match(security_key_getsecurity, name, addr);

    // CONFIG_AUDIT
    kfunc_match(security_audit_rule_init, name, addr);
    kfunc_match(security_audit_rule_known, name, addr);
    kfunc_match(security_audit_rule_free, name, addr);
    kfunc_match(security_audit_rule_match, name, addr);

    // CONFIG_BPF_SYSCALL
    kfunc_match(security_bpf, name, addr);
    kfunc_match(security_bpf_map, name, addr);
    kfunc_match(security_bpf_prog, name, addr);
    kfunc_match(security_bpf_map_alloc, name, addr);
    kfunc_match(security_bpf_prog_alloc, name, addr);
    kfunc_match(security_bpf_map_free, name, addr);
    kfunc_match(security_bpf_prog_free, name, addr);
    // CONFIG_BPF_SYSCALL

    kfunc_match(security_locked_down, name, addr);

    // CONFIG_PERF_EVENTS
    kfunc_match(security_perf_event_open, name, addr);
    kfunc_match(security_perf_event_alloc, name, addr);
    kfunc_match(security_perf_event_free, name, addr);
    kfunc_match(security_perf_event_read, name, addr);
    kfunc_match(security_perf_event_write, name, addr);

    // CONFIG_IO_URING
    kfunc_match(security_uring_override_creds, name, addr);
    kfunc_match(security_uring_sqpoll, name, addr);
    kfunc_match(security_uring_cmd, name, addr);
}

// security/selinux/avc.c
#include <security/selinux/include/avc.h>

int kfunc_def(avc_denied)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 xperm, unsigned int flags,
                          struct av_decision *avd) = 0;
int kfunc_def(avc_has_perm_noaudit)(u32 ssid, u32 tsid, u16 tclass, u32 requested, unsigned flags,
                                    struct av_decision *avd) = 0;
int kfunc_def(avc_has_perm)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata) = 0;
int kfunc_def(avc_has_perm_flags)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata,
                                  int flags) = 0;
int kfunc_def(avc_has_extended_perms)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 perm,
                                      struct common_audit_data *ad) = 0;

void _linux_security_selinux_avc_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(avc_denied, name, addr);
    kfunc_match(avc_has_perm_noaudit, name, addr);
    kfunc_match(avc_has_perm, name, addr);
    kfunc_match(avc_has_perm_flags, name, addr);
    kfunc_match(avc_has_extended_perms, name, addr);
}

// security/commmoncap.c
#include <linux/security.h>

int kfunc_def(cap_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts) = 0;
int kfunc_def(cap_settime)(const struct timespec64 *ts, const struct timezone *tz) = 0;
int kfunc_def(cap_ptrace_access_check)(struct task_struct *child, unsigned int mode) = 0;
int kfunc_def(cap_ptrace_traceme)(struct task_struct *parent) = 0;
int kfunc_def(cap_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                          kernel_cap_t *permitted) = 0;
int kfunc_def(cap_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                          const kernel_cap_t *inheritable, const kernel_cap_t *permitted) = 0;
int kfunc_def(cap_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file) = 0;
int kfunc_def(cap_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                  int flags) = 0;
int kfunc_def(cap_inode_removexattr)(struct dentry *dentry, const char *name) = 0;
int kfunc_def(cap_inode_need_killpriv)(struct dentry *dentry) = 0;
int kfunc_def(cap_inode_killpriv)(struct dentry *dentry) = 0;
int kfunc_def(cap_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc) = 0;
int kfunc_def(cap_mmap_addr)(unsigned long addr) = 0;
int kfunc_def(cap_mmap_file)(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags) = 0;
int kfunc_def(cap_task_fix_setuid)(struct cred *new, const struct cred *old, int flags) = 0;
int kfunc_def(cap_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                              unsigned long arg5) = 0;
int kfunc_def(cap_task_setscheduler)(struct task_struct *p) = 0;
int kfunc_def(cap_task_setioprio)(struct task_struct *p, int ioprio) = 0;
int kfunc_def(cap_task_setnice)(struct task_struct *p, int nice) = 0;
int kfunc_def(cap_vm_enough_memory)(struct mm_struct *mm, long pages) = 0;

kernel_cap_t full_cap = { 0 };

void _linux_security_commoncap_sym_match(const char *name, unsigned long addr)
{
    kfunc_match(cap_capable, name, addr);
    kfunc_match(cap_settime, name, addr);
    kfunc_match(cap_ptrace_access_check, name, addr);
    kfunc_match(cap_ptrace_traceme, name, addr);
    kfunc_match(cap_capget, name, addr);
    kfunc_match(cap_capset, name, addr);
    kfunc_match(cap_bprm_creds_from_file, name, addr);
    kfunc_match(cap_inode_setxattr, name, addr);
    kfunc_match(cap_inode_removexattr, name, addr);
    kfunc_match(cap_inode_need_killpriv, name, addr);
    kfunc_match(cap_inode_killpriv, name, addr);
    kfunc_match(cap_inode_getsecurity, name, addr);
    kfunc_match(cap_mmap_addr, name, addr);
    kfunc_match(cap_mmap_file, name, addr);
    kfunc_match(cap_task_fix_setuid, name, addr);
    kfunc_match(cap_task_prctl, name, addr);
    kfunc_match(cap_task_setscheduler, name, addr);
    kfunc_match(cap_task_setioprio, name, addr);
    kfunc_match(cap_task_setnice, name, addr);
    kfunc_match(cap_vm_enough_memory, name, addr);
}

```

`kernel/init/ksyms/selinux.c`:

```c
#include <ksyms.h>
#include <ktypes.h>

#include <security/selinux/include/security.h>
#include <security/selinux/include/classmap.h>

int kvar_def(selinux_enabled_boot) = 0;
int kvar_def(selinux_enabled) = 0;
struct selinux_state kvar_def(selinux_state) = 0;
struct security_class_mapping kvar_def(secclass_map)[] = 0;

int kfunc_def(security_mls_enabled)(void) = 0;
int kfunc_def(security_load_policy)(void *data, size_t len, struct selinux_load_state *load_state) = 0;
void kfunc_def(selinux_policy_commit)(struct selinux_load_state *load_state) = 0;
void kfunc_def(selinux_policy_cancel)(struct selinux_load_state *load_state) = 0;
int kfunc_def(security_read_policy)(void **data, size_t *len) = 0;
int kfunc_def(security_read_state_kernel)(void **data, size_t *len) = 0;
int kfunc_def(security_policycap_supported)(unsigned int req_cap) = 0;
void kfunc_def(security_compute_av)(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd,
                                    struct extended_perms *xperms) = 0;
void kfunc_def(security_compute_xperms_decision)(u32 ssid, u32 tsid, u16 tclass, u8 driver,
                                                 struct extended_perms_decision *xpermd) = 0;
void kfunc_def(security_compute_av_user)(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd) = 0;
int kfunc_def(security_transition_sid)(u32 ssid, u32 tsid, u16 tclass, const struct qstr *qstr, u32 *out_sid) = 0;
int kfunc_def(security_transition_sid_user)(u32 ssid, u32 tsid, u16 tclass, const char *objname, u32 *out_sid) = 0;
int kfunc_def(security_member_sid)(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid) = 0;
int kfunc_def(security_change_sid)(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid) = 0;
int kfunc_def(security_sid_to_context)(u32 sid, char **scontext, u32 *scontext_len) = 0;
int kfunc_def(security_sid_to_context_force)(u32 sid, char **scontext, u32 *scontext_len) = 0;
int kfunc_def(security_sid_to_context_inval)(u32 sid, char **scontext, u32 *scontext_len) = 0;
int kfunc_def(security_context_to_sid)(const char *scontext, u32 scontext_len, u32 *out_sid, gfp_t gfp) = 0;
int kfunc_def(security_context_str_to_sid)(const char *scontext, u32 *out_sid, gfp_t gfp) = 0;
int kfunc_def(security_context_to_sid_default)(const char *scontext, u32 scontext_len, u32 *out_sid, u32 def_sid,
                                               gfp_t gfp_flags) = 0;
int kfunc_def(security_context_to_sid_force)(const char *scontext, u32 scontext_len, u32 *sid) = 0;
int kfunc_def(security_get_user_sids)(u32 callsid, char *username, u32 **sids, u32 *nel) = 0;
int kfunc_def(security_port_sid)(u8 protocol, u16 port, u32 *out_sid) = 0;
int kfunc_def(security_ib_pkey_sid)(u64 subnet_prefix, u16 pkey_num, u32 *out_sid) = 0;
int kfunc_def(security_ib_endport_sid)(const char *dev_name, u8 port_num, u32 *out_sid) = 0;
int kfunc_def(security_netif_sid)(char *name, u32 *if_sid) = 0;
int kfunc_def(security_node_sid)(u16 domain, void *addr, u32 addrlen, u32 *out_sid) = 0;
int kfunc_def(security_validate_transition)(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass) = 0;
int kfunc_def(security_validate_transition_user)(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass) = 0;
int kfunc_def(security_bounded_transition)(u32 oldsid, u32 newsid) = 0;
int kfunc_def(security_sid_mls_copy)(u32 sid, u32 mls_sid, u32 *new_sid) = 0;
int kfunc_def(security_net_peersid_resolve)(u32 nlbl_sid, u32 nlbl_type, u32 xfrm_sid, u32 *peer_sid) = 0;
int kfunc_def(security_get_classes)(struct selinux_policy *policy, char ***classes, int *nclasses) = 0;
int kfunc_def(security_get_permissions)(struct selinux_policy *policy, char *class, char ***perms, int *nperms) = 0;
int kfunc_def(security_get_reject_unknown)(void) = 0;
int kfunc_def(security_get_allow_unknown)(void) = 0;

int kfunc_def(security_fs_use)(struct super_block *sb) = 0;
int kfunc_def(security_genfs_sid)(const char *fstype, const char *path, u16 sclass, u32 *sid) = 0;
int kfunc_def(selinux_policy_genfs_sid)(struct selinux_policy *policy, const char *fstype, const char *path, u16 sclass,
                                        u32 *sid) = 0;
int kfunc_def(security_netlbl_secattr_to_sid)(struct netlbl_lsm_secattr *secattr, u32 *sid) = 0;
int kfunc_def(security_netlbl_sid_to_secattr)(u32 sid, struct netlbl_lsm_secattr *secattr) = 0;
const char *kfunc_def(security_get_initial_sid_context)(u32 sid) = 0;

void kfunc_def(selinux_status_update_setenforce)(int enforcing) = 0;
void kfunc_def(selinux_status_update_policyload)(int seqno) = 0;
void kfunc_def(selinux_complete_init)(void) = 0;
void kfunc_def(exit_sel_fs)(void) = 0;
void kfunc_def(selnl_notify_setenforce)(int val) = 0;
void kfunc_def(selnl_notify_policyload)(u32 seqno) = 0;
int kfunc_def(selinux_nlmsg_lookup)(u16 sclass, u16 nlmsg_type, u32 *perm) = 0;

void kfunc_def(avtab_cache_init)(void) = 0;
void kfunc_def(ebitmap_cache_init)(void) = 0;
void kfunc_def(hashtab_cache_init)(void) = 0;
int kfunc_def(security_sidtab_hash_stats)(char *page) = 0;

void _linux_security_selinux_sym_match(const char *name, unsigned long addr)
{
    kvar_match(selinux_enabled_boot, name, addr);
    kvar_match(selinux_enabled, name, addr);
    kvar_match(selinux_state, name, addr);
    kvar_match(secclass_map, name, addr);

    kfunc_match(security_mls_enabled, name, addr);
    // kfunc_match(security_load_policy, name, addr);
    // kfunc_match(selinux_policy_commit, name, addr);
    // kfunc_match(selinux_policy_cancel, name, addr);
    // kfunc_match(security_read_policy, name, addr);
    // kfunc_match(security_read_state_kernel, name, addr);
    // kfunc_match(security_policycap_supported, name, addr);
    kfunc_match(security_compute_av, name, addr);
    kfunc_match(security_compute_xperms_decision, name, addr);
    kfunc_match(security_compute_av_user, name, addr);
    // kfunc_match(security_transition_sid, name, addr);
    // kfunc_match(security_transition_sid_user, name, addr);
    // kfunc_match(security_member_sid, name, addr);
    // kfunc_match(security_change_sid, name, addr);
    // kfunc_match(security_sid_to_context, name, addr);
    // kfunc_match(security_sid_to_context_force, name, addr);
    // kfunc_match(security_sid_to_context_inval, name, addr);
    // kfunc_match(security_context_to_sid, name, addr);
    // kfunc_match(security_context_str_to_sid, name, addr);
    // kfunc_match(security_context_to_sid_default, name, addr);
    // kfunc_match(security_context_to_sid_force, name, addr);
    // kfunc_match(security_get_user_sids, name, addr);
    // kfunc_match(security_port_sid, name, addr);
    // kfunc_match(security_ib_pkey_sid, name, addr);
    // kfunc_match(security_ib_endport_sid, name, addr);
    // kfunc_match(security_netif_sid, name, addr);
    // kfunc_match(security_node_sid, name, addr);
    // kfunc_match(security_validate_transition, name, addr);
    // kfunc_match(security_validate_transition_user, name, addr);
    // kfunc_match(security_bounded_transition, name, addr);
    // kfunc_match(security_sid_mls_copy, name, addr);
    // kfunc_match(security_net_peersid_resolve, name, addr);
    // kfunc_match(security_get_classes, name, addr);
    // kfunc_match(security_get_permissions, name, addr);
    // kfunc_match(security_get_reject_unknown, name, addr);
    // kfunc_match(security_get_allow_unknown, name, addr);

    // kfunc_match(security_fs_use, name, addr);
    // kfunc_match(security_genfs_sid, name, addr);
    // kfunc_match(selinux_policy_genfs_sid, name, addr);
    // kfunc_match(security_netlbl_secattr_to_sid, name, addr);
    // kfunc_match(security_netlbl_sid_to_secattr, name, addr);
    // kfunc_match(security_get_initial_sid_context, name, addr);

    // kfunc_match(selinux_status_update_setenforce, name, addr);
    // kfunc_match(selinux_status_update_policyload, name, addr);
    // kfunc_match(selinux_complete_init, name, addr);
    // kfunc_match(exit_sel_fs, name, addr);
    // kfunc_match(selnl_notify_setenforce, name, addr);
    // kfunc_match(selnl_notify_policyload, name, addr);
    // kfunc_match(selinux_nlmsg_lookup, name, addr);

    // kfunc_match(avtab_cache_init, name, addr);
    // kfunc_match(ebitmap_cache_init, name, addr);
    // kfunc_match(hashtab_cache_init, name, addr);
    // kfunc_match(security_sidtab_hash_stats, name, addr);
}
```

`kernel/init/struct/task_cred.c`:

```c
#include <log.h>
#include <stdbool.h>
#include <linux/cred.h>
#include <linux/sched.h>
#include <linux/sched/task.h>
#include <linux/string.h>
#include <linux/vmalloc.h>
#include <linux/string.h>
#include <linux/pid.h>
#include <asm/current.h>
#include <linux/security.h>
#include <syscall.h>
#include <uapi/linux/prctl.h>
#include <linux/capability.h>
#include <ksyms.h>
#include <uapi/linux/magic.h>
#include <pgtable.h>

struct task_struct_offset task_struct_offset = {
    .pid_offset = -1,
    .tgid_offset = -1,
    .thread_pid_offset = -1,
    .ptracer_cred_offset = -1,
    .real_cred_offset = -1,
    .cred_offset = -1,
    .fs_offset = -1,
    .files_offset = -1,
    .loginuid_offset = -1,
    .sessionid_offset = -1,
    .seccomp_offset = -1,
    .security_offset = -1,
    .stack_offset = -1,
};

struct cred_offset cred_offset = {
    .usage_offset = -1,
    .subscribers_offset = -1,
    .magic_offset = -1,

    .uid_offset = -1,
    .gid_offset = -1,
    .suid_offset = -1,
    .sgid_offset = -1,
    .euid_offset = -1,
    .egid_offset = -1,
    .fsuid_offset = -1,
    .fsgid_offset = -1,
    .securebits_offset = -1,
    .cap_inheritable_offset = -1,
    .cap_permitted_offset = -1,
    .cap_effective_offset = -1,
    .cap_bset_offset = -1,
    .cap_ambient_offset = -1,

    .user_offset = -1,
    .user_ns_offset = -1,
    .ucounts_offset = -1,
    .group_info_offset = -1,

    .session_keyring_offset = -1,
    .process_keyring_offset = -1,
    .thread_keyring_offset = -1,
    .request_key_auth_offset = -1,

    .security_offset = -1,

    .rcu_offset = -1,
};

int thread_size = -1;
bool thread_info_in_task = false;
bool task_is_sp_el0 = false;
bool thread_info_is_sp_el0 = false;
bool thread_info_is_sp = false;
int task_in_thread_info_offset = -1;
int stack_in_task_offset = -1;

struct task_struct *task = 0;

static int16_t *bl_list = 0;
static int bl_cap = 0;

static void reinit_bllist(int num)
{
    bl_cap = num;
    bl_list = (int16_t *)vmalloc(bl_cap * sizeof(int16_t));
    for (int i = 0; i < bl_cap; i++) {
        bl_list[i] = -1;
    }
}

static void uninit_bllist()
{
    vfree(bl_list);
    bl_cap = 0;
}

static bool is_bl(int16_t off)
{
    for (int i = 0; i < bl_cap; i++) {
        if (bl_list[i] < 0)
            break;
        if (bl_list[i] == off)
            return true;
    }
    return false;
}

static void add_bll(int16_t off, int16_t size)
{
    for (int i = 0; i < bl_cap; i++) {
        if (bl_list[i] < 0) {
            bl_list[i] = off;
            if (size == 8)
                bl_list[i + 1] = off + 4;
            break;
        }
    }
}

// todo:
int build_cred_offset()
{
    int cred_len = kvlen(init_cred);
    int task_len = kvlen(init_task);

    if (task_len <= 0 || cred_len <= 0) {
        logke("init_task or init_cred length unknown\n");
        return -1;
    }
    reinit_bllist(128);

    struct cred *cred = cred_alloc_blank();
    struct cred *cred1 = cred_alloc_blank();

    memcpy(task, kvar(init_task), task_len);
    memcpy(cred, kvar(init_cred), cred_len);
    memcpy(cred1, kvar(init_cred), cred_len);
    *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset) = cred;
    *(struct cred **)((uintptr_t)task + task_struct_offset.real_cred_offset) = cred;

    const struct task_struct *backup = override_current(task);

    // todo:
    unsigned long root_user_ptr = kallsyms_lookup_name("root_user");
    unsigned long init_user_ns_ptr = kallsyms_lookup_name("init_user_ns");
    unsigned long init_groups_ptr = kallsyms_lookup_name("init_groups");
    unsigned long init_ucounts_ptr = kallsyms_lookup_name("init_ucounts");

    for (int16_t i = 0; i < cred_len; i += sizeof(uintptr_t)) {
        uintptr_t ptr = *(uintptr_t *)((uintptr_t)kvar(init_cred) + i);
        if (root_user_ptr && ptr == root_user_ptr) {
            cred_offset.user_offset = i;
            add_bll(i, sizeof(uintptr_t));
        }
        if (init_user_ns_ptr && ptr == init_user_ns_ptr) {
            cred_offset.user_ns_offset = i;
            add_bll(i, sizeof(uintptr_t));
        }
        if (init_groups_ptr && ptr == init_groups_ptr) {
            cred_offset.group_info_offset = i;
            add_bll(i, sizeof(uintptr_t));
        }
        if (init_ucounts_ptr && ptr == init_ucounts_ptr) {
            cred_offset.ucounts_offset = i;
            add_bll(i, sizeof(uintptr_t));
        }
    }
    logkd("struct cred offsets: user: %d, user_ns: %d, group_info: %d\n", cred_offset.user_offset,
          cred_offset.user_ns_offset, cred_offset.group_info_offset);

    for (int16_t i = 0; i < cred_len; i += sizeof(unsigned)) {
        unsigned int val = *(unsigned int *)((uintptr_t)kvar(init_cred) + i);
        if (4 == val) {
            cred_offset.usage_offset = i;
            add_bll(i, sizeof(unsigned));
        }
        if (CRED_MAGIC == val) {
            cred_offset.magic_offset = i;
            add_bll(i, sizeof(unsigned));
        }
        if (2 == val) {
            cred_offset.subscribers_offset = i;
            add_bll(i, sizeof(unsigned));
        }
    }
    logkd("struct cred offsets: usage: %d, magic: %d, subscribers: %d\n", cred_offset.usage_offset,
          cred_offset.magic_offset, cred_offset.subscribers_offset);

    // cap_inheritable, cap_permitted, cap_effective
    kernel_cap_t effective, inheritable, permitted;
    cap_capget(task, &effective, &inheritable, &permitted);
    full_cap.val = effective.val;
    logkd("capability full_cap: %llx\n", full_cap.val);

    kernel_cap_t new_cap_e = { 0xff }, new_cap_i = { 0xf }, new_cap_p = { 0xfff };
    cap_capset(cred1, cred, &new_cap_e, &new_cap_i, &new_cap_p);

    for (int16_t i = 0; i < cred_len; i += sizeof(kernel_cap_t)) {
        if (is_bl(i))
            continue;
        kernel_cap_t cap = *(kernel_cap_t *)((uintptr_t)cred + i);
        kernel_cap_t cap1 = *(kernel_cap_t *)((uintptr_t)cred1 + i);
        if (cap.val == effective.val && cap1.val == new_cap_e.val) {
            cred_offset.cap_effective_offset = i;
            add_bll(i, sizeof(kernel_cap_t));
            continue;
        }
        if (cap.val == inheritable.val && cap1.val == new_cap_i.val) {
            cred_offset.cap_inheritable_offset = i;
            add_bll(i, sizeof(kernel_cap_t));
            continue;
        }
        if (cap.val == permitted.val && cap1.val == new_cap_p.val) {
            cred_offset.cap_permitted_offset = i;
            add_bll(i, sizeof(kernel_cap_t));
            continue;
        }
    }

    // cap_bset
    for (int16_t i = 0; i < cred_len; i += sizeof(kernel_cap_t)) {
        if (is_bl(i))
            continue;
        kernel_cap_t cap1 = *(kernel_cap_t *)((uintptr_t)cred1 + i);
        if (cap1.val == effective.val) {
            cred_offset.cap_bset_offset = i;
            add_bll(i, sizeof(kernel_cap_t));
        }
    }
    logkd("struct cred offsets: cap_effective: %d, cap_inheritable: %d, cap_permitted: %d, cap_bset: %d\n",
          cred_offset.cap_effective_offset, cred_offset.cap_inheritable_offset, cred_offset.cap_permitted_offset,
          cred_offset.cap_bset_offset);

    // securebits
    for (int i = 0; i < cred_len; i += sizeof(unsigned)) {
        if (is_bl(i))
            continue;
        unsigned *sbitsp = (unsigned *)((uintptr_t)cred + i);
        unsigned oribits = *sbitsp;
        *sbitsp = 1158;
        unsigned sbits = cap_task_prctl(PR_GET_SECUREBITS, 0, 0, 0, 0);
        if (sbits != 1158) {
            *sbitsp = oribits;
            continue;
        }
        *sbitsp = oribits;
        cred_offset.securebits_offset = i;
        add_bll(i, sizeof(unsigned));
        break;
    }
    logkd("struct cred offsets: securebits: %d\n", cred_offset.securebits_offset);

    // euid, uid, egid, gid
    for (int i = 0; i < cred_len; i += sizeof(uid_t)) {
        if (is_bl(i))
            continue;
        uid_t *uidp = (uid_t *)((uintptr_t)cred + i);
        if (*uidp)
            continue;
        *uidp = 1158;
        if (raw_syscall0(__NR_geteuid) == 1158) {
            cred_offset.euid_offset = i;
        } else if (raw_syscall0(__NR_getuid) == 1158) {
            cred_offset.uid_offset = i;
        } else if (raw_syscall0(__NR_getegid) == 1158) {
            cred_offset.egid_offset = i;
        } else if (raw_syscall0(__NR_getgid) == 1158) {
            cred_offset.gid_offset = i;
        } else {
            *uidp = 0;
            continue;
        }
        *uidp = 0;
        add_bll(i, sizeof(uid_t));
    }
    logkd("struct cred offsets: uid: %d, euid: %d, gid: %d, egid: %d\n", cred_offset.uid_offset,
          cred_offset.euid_offset, cred_offset.gid_offset, cred_offset.egid_offset);

    // fsuid
    for (int i = 0; i < cred_len; i += sizeof(uid_t)) {
        if (is_bl(i))
            continue;
        uid_t *uidp = (uid_t *)((uintptr_t)cred + i);
        uid_t backup = *uidp;
        *uidp = 1158;
        uid_t old_uid = raw_syscall1(__NR_setfsuid, -1);
        *uidp = backup;
        if (old_uid == 1158) {
            cred_offset.fsuid_offset = i;
            add_bll(i, sizeof(uid_t));
            break;
        }
    }
    logkd("struct cred offsets: fsuid: %d\n", cred_offset.fsuid_offset);

    // fsgid
    struct cred *new_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);
    for (int i = 0; i < cred_len; i += sizeof(gid_t)) {
        if (is_bl(i))
            continue;
        gid_t *gidp = (gid_t *)((uintptr_t)new_cred + i);
        gid_t backup = *gidp;
        *gidp = 1158;
        gid_t old_gid = raw_syscall1(__NR_setfsgid, -1);
        *gidp = backup;
        if (old_gid == 1158) {
            cred_offset.fsgid_offset = i;
            add_bll(i, sizeof(gid_t));
            break;
        }
    }
    logkd("struct cred offsets: fsgid: %d\n", cred_offset.fsgid_offset);

    // suid
    raw_syscall3(__NR_setresuid, 0, 0, 1158);
    new_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);
    for (int i = 0; i < cred_len; i += sizeof(uid_t)) {
        if (is_bl(i))
            continue;
        uid_t *uidp = (uid_t *)((uintptr_t)new_cred + i);
        if (*uidp == 1158) {
            cred_offset.suid_offset = i;
            *uidp = 0;
            add_bll(i, sizeof(uid_t));
            break;
        }
    }
    logkd("struct cred offsets: suid: %d\n", cred_offset.suid_offset);

    // sgid
    raw_syscall3(__NR_setresgid, 0, 0, 1158);
    new_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);
    for (int i = 0; i < cred_len; i += sizeof(gid_t)) {
        if (is_bl(i))
            continue;
        gid_t *uidp = (gid_t *)((uintptr_t)new_cred + i);
        if (*uidp == 1158) {
            cred_offset.sgid_offset = i;
            *uidp = 0;
            add_bll(i, sizeof(gid_t));
            break;
        }
    }
    logkd("struct cred offsets: sgid: %d\n", cred_offset.sgid_offset);

    // cap_ambient
    new_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);
    *(kernel_cap_t *)((uintptr_t)new_cred + cred_offset.cap_effective_offset) = full_cap;
    *(kernel_cap_t *)((uintptr_t)new_cred + cred_offset.cap_inheritable_offset) = full_cap;
    *(kernel_cap_t *)((uintptr_t)new_cred + cred_offset.cap_permitted_offset) = full_cap;
    *(unsigned *)((uintptr_t)new_cred + cred_offset.securebits_offset) = 0;
    cap_task_prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, 0xf, 0, 0);
    new_cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset);
    for (int16_t i = 0; i < cred_len; i += sizeof(kernel_cap_t)) {
        if (is_bl(i))
            continue;
        kernel_cap_t cap = *(kernel_cap_t *)((uintptr_t)cred + i);
        kernel_cap_t new_cap = *(kernel_cap_t *)((uintptr_t)new_cred + i);
        if (!cap.val && new_cap.val == (1 << 0xf)) {
            cred_offset.cap_ambient_offset = i;
            add_bll(i, sizeof(kernel_cap_t));
        }
    }
    logkd("struct cred offsets: cap_ambient: %d\n", cred_offset.cap_ambient_offset);

    // todo: put cred
    // __put_cred(new_cred);

    revert_current(backup);
    uninit_bllist();
    return 0;
}

// todo: tid and tgid offsets of task_struct.
int build_task_offset()
{
    int cred_len = kvlen(init_cred);
    int task_len = kvlen(init_task);

    memcpy(task, kvar(init_task), task_len);

    uintptr_t start = (uintptr_t)task;
    uintptr_t end = start + task_len;
    uintptr_t find = 0;
    int16_t cand[8] = { 0 };
    int ci = 0;

    // cred and real_cred
    find = (uintptr_t)kvar(init_cred);
    memset(cand, 0, sizeof(cand));
    ci = 0;
    for (uintptr_t i = start; i < end; i += sizeof(uintptr_t)) {
        uintptr_t val = *(uintptr_t *)i;
        if (find == val) {
            cand[ci++] = i - start;
        }
    }
    if (ci != 2)
        return -2;
    //
    struct cred *flag = (struct cred *)vmalloc(kvlen(init_cred));
    memcpy(flag, kvar(init_cred), cred_len);

    *(uintptr_t *)(start + cand[0]) = (uintptr_t)flag;
    const struct cred *real_cred = get_task_cred(task);
    if (real_cred == flag) {
        task_struct_offset.real_cred_offset = cand[0];
        task_struct_offset.cred_offset = cand[1];
    } else {
        task_struct_offset.real_cred_offset = cand[1];
        task_struct_offset.cred_offset = cand[0];
    }
    vfree(flag);

    logkd("struct task_struct offsets: cred: %d, read_cred: %d\n", task_struct_offset.cred_offset,
          task_struct_offset.real_cred_offset);

    // stack
    uintptr_t stack_base = (uintptr_t)kvar(init_thread_union);
    for (uintptr_t i = start; i < end; i += sizeof(uintptr_t)) {
        uintptr_t val = *(uintptr_t *)i;
        if (stack_base == val) {
            stack_in_task_offset = i - start;
            task_struct_offset.stack_offset = stack_in_task_offset;
            break;
        }
    }
    logkd("struct task_struct offsets: stack: %d\n", task_struct_offset.stack_offset);

    return 0;
}

int resolve_current()
{
    int err = 0;

    thread_info_in_task = true;
    for (int i = 0; i < KP_THREAD_INFO_MAX_SIZE; i += 8) {
        uintptr_t addr = (uintptr_t)kvar(init_thread_union) + i;
        uintptr_t val = *(uintptr_t *)addr;
        if (val && val != STACK_END_MAGIC) {
            thread_info_in_task = false;
            break;
        }
    }
    logkd("thread_info_in_task: %d\n", thread_info_in_task);

    // task_is_sp_el0
    unsigned long sp_el0;
    asm("mrs %0, sp_el0" : "=r"(sp_el0));
    if (sp_el0 == (unsigned long)kvar(init_task)) {
        task_is_sp_el0 = true;
        logkd("current is sp_el0\n");
        goto out;
    }

    // thread_info_is_sp_el0
    if (is_kimg_range((uint64_t)legacy_current_thread_info_sp_el0())) {
        thread_info_is_sp_el0 = true;
        logkd("current_thread_info is sp_el0\n");
    }
    // thread_info_is_sp
    if (is_kimg_range((uint64_t)legacy_current_thread_info_sp())) {
        thread_info_is_sp = true;
        logkd("current_thread_info is sp\n");
    }

    if ((!thread_info_is_sp && !thread_info_is_sp_el0) || (thread_info_is_sp && thread_info_is_sp_el0)) {
        logke("current_thread_info error\n");
        err = -1;
        goto out;
    }

    // task_in_thread_info_offset
    for (int i = 0; i < KP_THREAD_INFO_MAX_SIZE; i += sizeof(uintptr_t)) {
        struct thread_info *thread_info = current_thread_info();
        uintptr_t ptr = (uintptr_t)thread_info + i;
        if (*(uintptr_t *)ptr == (uintptr_t)kvar(init_task)) {
            thread_info_is_sp = true;
            task_in_thread_info_offset = i;
            break;
        }
    }
    logkd("struct thread_info offsets: task: %d\n", task_in_thread_info_offset);

out:
    return err;
}

int build_struct()
{
    if (kvlen(init_task) <= 0 || kvlen(init_cred) <= 0) {
        logke("init_task or init_cred length unknown\n");
        return -1;
    }
    if (thread_size <= 0) {
        logke("init_thread_union length unknown\n");
        return -1;
    }

    full_cap = CAP_FULL_SET;
    task = (struct task_struct *)vmalloc(kvlen(init_task));

    int err = 0;
    if ((err = build_task_offset()))
        goto out;
    if ((err = resolve_current()))
        goto out;
    if ((err = build_cred_offset()))
        goto out;

out:
    vfree(task);
    return err;
}
```

`kernel/kpimg.lds`:

```lds
OUTPUT_ARCH(aarch64)

_link_base = 64k - 3 * 4k;

SECTIONS 
{
    . = _link_base;
    _link_base = .;

    .setup.data : {
        _setup_start = .;
        base/setup.o(.setup.header)
        . = _setup_start + 64;
        base/setup.o(.setup.preset)
        base/setup.o(.setup.data)
        . = _setup_start + 4K;
    }
    
    .setup.text : {
        base/setup1.o(.entry.text)
        base/setup1.o(.text)
        base/setup.o(.text)
        _setup_end = .;
    }

    . = ALIGN(16);
    .setup.map : {
        _map_start = .;
        base/map.o(.map.data)
        base/map.o(.map.text)
        base/map.o(.text)
        . = ALIGN(16);
        _map_end = .;
    }
    ASSERT(SIZEOF(.setup.map) < 0xa00, "Size too large of .setup.map!")

    . = ALIGN(64K);
    _kp_start = .;
    .kp.text : {
        _kp_text_start = .;

        base/start.o(.start.text)
        base/start.o(.text)
        base/hook.o(.transit0.text);
        _transit0_end = .;
        base/hook.o(.transit1.text);
        _transit1_end = .;
        base/hook.o(.transit2.text);
        _transit2_end = .;
        base/hook.o(.transit3.text);
        _transit3_end = .;
        base/hook.o(.transit4.text);
        _transit4_end = .;
        base/hook.o(.transit8.text);
        _transit8_end = .;
        base/hook.o(.transit12.text);
        _transit12_end = .;

        base/*(.text)
        base/*(.rodata*)

        *(.text)
        *(.rodata*)
        /*  *(.got) */

        . = ALIGN(16);
        _kp_text_end = .;
    }

    . = ALIGN(64k);
    .kp.data : {
        _kp_data_start = .;
        base/start.o(.start.data)
        base/*(data)
        base/*(.bss)
        *(.data)
        *(.bss)
        _kp_data_end = .;
    }

    .got.plt : { *(.got.plt) }
    /* ASSERT(SIZEOF(.got.plt) == 0 || SIZEOF(.got.plt) == 0x18, "Unexpected GOT/PLT entries detected!") */
    ASSERT(SIZEOF(.got.plt) == 0, "Unexpected GOT/PLT entries detected!")

    . = ALIGN(64k);
    _kp_end = .;

    _link_end = .;

    .got : {
        *(.got)
    }
    ASSERT(SIZEOF(.got) == 0, "Unexpected GOT detected!")
    
    .plt : {
        *(.plt) *(.plt.*) *(.iplt) *(.igot .igot.plt)
    }
    ASSERT(SIZEOF(.plt) == 0, "Unexpected run-time procedure linkages detected!")


    .data.rel.ro : { 
        *(.data.rel.ro) 
    }
    ASSERT(SIZEOF(.data.rel.ro) == 0, "Unexpected RELRO detected!")
    
    .rela.dyn : {
        *(.rela .rela*)
    }
    ASSERT(SIZEOF(.rela.dyn) == 0, "Unexpected RELRDYN detected!")
}
```

`kernel/linux/arch/arm64/include/asm/cacheflush.h`:

```h
// todo
```

`kernel/linux/arch/arm64/include/asm/current.h`:

```h
#ifndef __ASM_CURRENT_H
#define __ASM_CURRENT_H

#include <stdint.h>
#include <stdbool.h>
#include <compiler.h>

struct task_struct;

extern int thread_size;
extern bool thread_info_in_task;
extern bool task_is_sp_el0;
extern bool thread_info_is_sp_el0;
extern bool thread_info_is_sp;
extern int task_in_thread_info_offset;
extern int stack_in_task_offset;

#define KP_THREAD_INFO_MAX_SIZE 0x80

register unsigned long current_stack_pointer asm("sp");

static __always_inline struct thread_info *legacy_current_thread_info_sp()
{
    return (struct thread_info *)(current_stack_pointer & ~(thread_size - 1));
}

static __always_inline struct thread_info *legacy_current_thread_info_sp_el0()
{
    unsigned long sp_el0;
    asm("mrs %0, sp_el0" : "=r"(sp_el0));
    return (struct thread_info *)sp_el0;
}

static __always_inline struct thread_info *current_thread_info()
{
    if (task_is_sp_el0) {
        unsigned long sp_el0;
        asm("mrs %0, sp_el0" : "=r"(sp_el0));
        if (thread_info_in_task) {
            return (struct thread_info *)sp_el0;
        } else {
            return *(struct thread_info **)(sp_el0 + stack_in_task_offset);
        }
    }
    struct thread_info *ti = legacy_current_thread_info_sp_el0();
    if (thread_info_is_sp)
        ti = legacy_current_thread_info_sp();
    return ti;
}

static __always_inline struct task_struct *get_current()
{
    if (task_is_sp_el0) {
        unsigned long sp_el0;
        asm("mrs %0, sp_el0" : "=r"(sp_el0));
        return (struct task_struct *)sp_el0;
    }
    uintptr_t addr = (uintptr_t)current_thread_info() + task_in_thread_info_offset;
    return *(struct task_struct **)addr;
}

#define current get_current()

static __always_inline void *get_stack(struct task_struct *task)
{
    uintptr_t addr = (uintptr_t)task + stack_in_task_offset;
    return (void *)*(uintptr_t *)addr;
}

static __always_inline void *get_current_stack()
{
    return get_stack(current);
}

static __always_inline struct task_ext *get_task_ext(struct task_struct *task)
{
    uintptr_t addr = (uintptr_t)get_stack(task);
    addr += 0x10;
    if (thread_info_in_task) {
        return (void *)addr;
    }
    return (void *)(addr + KP_THREAD_INFO_MAX_SIZE);
}

static __always_inline struct task_ext *get_current_task_ext()
{
    return get_task_ext(current);
}

#define current_ext get_current_task_ext()

static inline const struct task_struct *override_current(struct task_struct *task)
{
    if (task_is_sp_el0) {
        unsigned long sp_el0;
        asm("mrs %0, sp_el0" : "=r"(sp_el0));
        asm("msr sp_el0, %0" ::"r"(task));
        return (struct task_struct *)sp_el0;
    }
    uintptr_t addr = (uintptr_t)current_thread_info() + task_in_thread_info_offset;
    struct task_struct *old = *(struct task_struct **)addr;
    *(struct task_struct **)addr = (struct task_struct *)task;
    return old;
}

static inline void revert_current(const struct task_struct *old)
{
    if (task_is_sp_el0) {
        asm("msr sp_el0, %0" ::"r"(old));
        return;
    }
    uintptr_t addr = (uintptr_t)current_thread_info() + task_in_thread_info_offset;
    *(struct task_struct **)addr = (struct task_struct *)old;
}

#endif
```

`kernel/linux/arch/arm64/include/asm/ptrace.h`:

```h
#ifndef __ASM_PTRACE_H
#define __ASM_PTRACE_H

#include <ksyms.h>
#include <pgtable.h>
#include <stdbool.h>
#include <uapi/asm-generic/unistd.h>

struct user_pt_regs
{
    __u64 regs[31];
    __u64 sp;
    __u64 pc;
    __u64 pstate;
};

struct pt_regs
{
    union
    {
        struct user_pt_regs user_regs;
        struct
        {
            u64 regs[31];
            u64 sp;
            u64 pc;
            u64 pstate;
        };
    };
    u64 orig_x0;
#ifdef __AARCH64EB__
    u32 unused2;
    s32 syscallno;
#else
    s32 syscallno;
    u32 unused2;
#endif
    u64 sdei_ttbr1;
    /* Only valid when ARM64_HAS_GIC_PRIO_MASKING is enabled. */
    u64 pmr_save;
    u64 stackframe[2];

    /* Only valid for some EL1 exceptions. */
    u64 lockdep_hardirqs;
    u64 exit_rcu;
};

#endif
```

`kernel/linux/arch/arm64/include/asm/thread_info.h`:

```h
#ifndef __ASM_THREAD_INFO_H
#define __ASM_THREAD_INFO_H

#include <stdint.h>

struct task_struct;
typedef unsigned long mm_segment_t;

struct thread_info
{
    unsigned long flags; /* low level flags */
    mm_segment_t addr_limit; /* address limit */
    // from 3.7 to 4.9
    struct task_struct *task; /* main task structure */
    char _others[0];
};

/*
 * low level task data that entry.S needs immediate access to.
 */
// struct thread_info {
// 	unsigned long flags; /* low level flags */
// 	mm_segment_t addr_limit; /* address limit */
// #ifdef CONFIG_ARM64_SW_TTBR0_PAN
// 	u64 ttbr0; /* saved TTBR0_EL1 */
// #endif
// 	union {
// 		u64 preempt_count; /* 0 => preemptible, <0 => bug */
// 		struct {
// #ifdef CONFIG_CPU_BIG_ENDIAN
// 			u32 need_resched;
// 			u32 count;
// #else
// 			u32 count;
// 			u32 need_resched;
// #endif
// 		} preempt;
// 	};
// #ifdef CONFIG_SHADOW_CALL_STACK
// 	void *scs_base;
// 	void *scs_sp;
// #endif
// };

#endif
```

`kernel/linux/arch/arm64/include/asm/unistd.h`:

```h

#define __ARCH_WANT_COMPAT_STAT
#define __ARCH_WANT_COMPAT_STAT64
#define __ARCH_WANT_SYS_GETHOSTNAME
#define __ARCH_WANT_SYS_PAUSE
#define __ARCH_WANT_SYS_GETPGRP
#define __ARCH_WANT_SYS_NICE
#define __ARCH_WANT_SYS_SIGPENDING
#define __ARCH_WANT_SYS_SIGPROCMASK
#define __ARCH_WANT_COMPAT_SYS_SENDFILE
#define __ARCH_WANT_SYS_UTIME32
#define __ARCH_WANT_SYS_FORK
#define __ARCH_WANT_SYS_VFORK

/*
 * Compat syscall numbers used by the AArch64 kernel.
 */
#define __NR_compat_restart_syscall 0
#define __NR_compat_exit 1
#define __NR_compat_read 3
#define __NR_compat_write 4
#define __NR_compat_gettimeofday 78
#define __NR_compat_sigreturn 119
#define __NR_compat_rt_sigreturn 173
#define __NR_compat_clock_gettime 263
#define __NR_compat_clock_getres 264
#define __NR_compat_clock_gettime64 403
#define __NR_compat_clock_getres_time64 406

/*
 * The following SVCs are ARM private.
 */
#define __ARM_NR_COMPAT_BASE 0x0f0000
#define __ARM_NR_compat_cacheflush (__ARM_NR_COMPAT_BASE + 2)
#define __ARM_NR_compat_set_tls (__ARM_NR_COMPAT_BASE + 5)
#define __ARM_NR_COMPAT_END (__ARM_NR_COMPAT_BASE + 0x800)

```

`kernel/linux/arch/arm64/include/asm/unistd32.h`:

```h
#define __NR_restart_syscall 0
#define __NR_exit 1
#define __NR_fork 2
#define __NR_read 3
#define __NR_write 4
#define __NR_open 5
#define __NR_close 6
/* 7 was sys_waitpid */
#define __NR_creat 8
#define __NR_link 9
#define __NR_unlink 10
#define __NR_execve 11
#define __NR_chdir 12
/* 13 was sys_time */
#define __NR_mknod 14
#define __NR_chmod 15
#define __NR_lchown 16
/* 17 was sys_break */
/* 18 was sys_stat */
#define __NR_lseek 19
#define __NR_getpid 20
#define __NR_mount 21
/* 22 was sys_umount */
#define __NR_setuid 23
#define __NR_getuid 24
/* 25 was sys_stime */
#define __NR_ptrace 26
/* 27 was sys_alarm */
/* 28 was sys_fstat */
#define __NR_pause 29
/* 30 was sys_utime */
/* 31 was sys_stty */
/* 32 was sys_gtty */
#define __NR_access 33
#define __NR_nice 34
/* 35 was sys_ftime */
#define __NR_sync 36
#define __NR_kill 37
#define __NR_rename 38
#define __NR_mkdir 39
#define __NR_rmdir 40
#define __NR_dup 41
#define __NR_pipe 42
#define __NR_times 43
/* 44 was sys_prof */
#define __NR_brk 45
#define __NR_setgid 46
#define __NR_getgid 47
/* 48 was sys_signal */
#define __NR_geteuid 49
#define __NR_getegid 50
#define __NR_acct 51
#define __NR_umount2 52
/* 53 was sys_lock */
#define __NR_ioctl 54
#define __NR_fcntl 55
/* 56 was sys_mpx */
#define __NR_setpgid 57
/* 58 was sys_ulimit */
/* 59 was sys_olduname */
#define __NR_umask 60
#define __NR_chroot 61
#define __NR_ustat 62
#define __NR_dup2 63
#define __NR_getppid 64
#define __NR_getpgrp 65
#define __NR_setsid 66
#define __NR_sigaction 67
/* 68 was sys_sgetmask */
/* 69 was sys_ssetmask */
#define __NR_setreuid 70
#define __NR_setregid 71
#define __NR_sigsuspend 72
#define __NR_sigpending 73
#define __NR_sethostname 74
#define __NR_setrlimit 75
/* 76 was compat_sys_getrlimit */
#define __NR_getrusage 77
#define __NR_gettimeofday 78
#define __NR_settimeofday 79
#define __NR_getgroups 80
#define __NR_setgroups 81
/* 82 was compat_sys_select */
#define __NR_symlink 83
/* 84 was sys_lstat */
#define __NR_readlink 85
#define __NR_uselib 86
#define __NR_swapon 87
#define __NR_reboot 88
/* 89 was sys_readdir */
/* 90 was sys_mmap */
#define __NR_munmap 91
#define __NR_truncate 92
#define __NR_ftruncate 93
#define __NR_fchmod 94
#define __NR_fchown 95
#define __NR_getpriority 96
#define __NR_setpriority 97
/* 98 was sys_profil */
#define __NR_statfs 99
#define __NR_fstatfs 100
/* 101 was sys_ioperm */
/* 102 was sys_socketcall */
#define __NR_syslog 103
#define __NR_setitimer 104
#define __NR_getitimer 105
#define __NR_stat 106
#define __NR_lstat 107
#define __NR_fstat 108
/* 109 was sys_uname */
/* 110 was sys_iopl */
#define __NR_vhangup 111
/* 112 was sys_idle */
/* 113 was sys_syscall */
#define __NR_wait4 114
#define __NR_swapoff 115
#define __NR_sysinfo 116
/* 117 was sys_ipc */
#define __NR_fsync 118
#define __NR_sigreturn 119
#define __NR_clone 120
#define __NR_setdomainname 121
#define __NR_uname 122
/* 123 was sys_modify_ldt */
#define __NR_adjtimex 124
#define __NR_mprotect 125
#define __NR_sigprocmask 126
/* 127 was sys_create_module */
#define __NR_init_module 128
#define __NR_delete_module 129
/* 130 was sys_get_kernel_syms */
#define __NR_quotactl 131
#define __NR_getpgid 132
#define __NR_fchdir 133
#define __NR_bdflush 134
#define __NR_sysfs 135
#define __NR_personality 136
/* 137 was sys_afs_syscall */
#define __NR_setfsuid 138
#define __NR_setfsgid 139
#define __NR__llseek 140
#define __NR_getdents 141
#define __NR__newselect 142
#define __NR_flock 143
#define __NR_msync 144
#define __NR_readv 145
#define __NR_writev 146
#define __NR_getsid 147
#define __NR_fdatasync 148
/* 149 was sys_sysctl */
#define __NR_mlock 150
#define __NR_munlock 151
#define __NR_mlockall 152
#define __NR_munlockall 153
#define __NR_sched_setparam 154
#define __NR_sched_getparam 155
#define __NR_sched_setscheduler 156
#define __NR_sched_getscheduler 157
#define __NR_sched_yield 158
#define __NR_sched_get_priority_max 159
#define __NR_sched_get_priority_min 160
#define __NR_sched_rr_get_interval 161
#define __NR_nanosleep 162
#define __NR_mremap 163
#define __NR_setresuid 164
#define __NR_getresuid 165
/* 166 was sys_vm86 */
/* 167 was sys_query_module */
#define __NR_poll 168
#define __NR_nfsservctl 169
#define __NR_setresgid 170
#define __NR_getresgid 171
#define __NR_prctl 172
#define __NR_rt_sigreturn 173
#define __NR_rt_sigaction 174
#define __NR_rt_sigprocmask 175
#define __NR_rt_sigpending 176
#define __NR_rt_sigtimedwait 177
#define __NR_rt_sigqueueinfo 178
#define __NR_rt_sigsuspend 179
#define __NR_pread64 180
#define __NR_pwrite64 181
#define __NR_chown 182
#define __NR_getcwd 183
#define __NR_capget 184
#define __NR_capset 185
#define __NR_sigaltstack 186
#define __NR_sendfile 187
/* 188 reserved */
/* 189 reserved */
#define __NR_vfork 190
#define __NR_ugetrlimit 191 /* SuS compliant getrlimit */
#define __NR_mmap2 192
#define __NR_truncate64 193
#define __NR_ftruncate64 194
#define __NR_stat64 195
#define __NR_lstat64 196
#define __NR_fstat64 197
#define __NR_lchown32 198
#define __NR_getuid32 199
#define __NR_getgid32 200
#define __NR_geteuid32 201
#define __NR_getegid32 202
#define __NR_setreuid32 203
#define __NR_setregid32 204
#define __NR_getgroups32 205
#define __NR_setgroups32 206
#define __NR_fchown32 207
#define __NR_setresuid32 208
#define __NR_getresuid32 209
#define __NR_setresgid32 210
#define __NR_getresgid32 211
#define __NR_chown32 212
#define __NR_setuid32 213
#define __NR_setgid32 214
#define __NR_setfsuid32 215
#define __NR_setfsgid32 216
#define __NR_getdents64 217
#define __NR_pivot_root 218
#define __NR_mincore 219
#define __NR_madvise 220
#define __NR_fcntl64 221
/* 222 for tux */
/* 223 is unused */
#define __NR_gettid 224
#define __NR_readahead 225
#define __NR_setxattr 226
#define __NR_lsetxattr 227
#define __NR_fsetxattr 228
#define __NR_getxattr 229
#define __NR_lgetxattr 230
#define __NR_fgetxattr 231
#define __NR_listxattr 232
#define __NR_llistxattr 233
#define __NR_flistxattr 234
#define __NR_removexattr 235
#define __NR_lremovexattr 236
#define __NR_fremovexattr 237
#define __NR_tkill 238
#define __NR_sendfile64 239
#define __NR_futex 240
#define __NR_sched_setaffinity 241
#define __NR_sched_getaffinity 242
#define __NR_io_setup 243
#define __NR_io_destroy 244
#define __NR_io_getevents 245
#define __NR_io_submit 246
#define __NR_io_cancel 247
#define __NR_exit_group 248
#define __NR_lookup_dcookie 249
#define __NR_epoll_create 250
#define __NR_epoll_ctl 251
#define __NR_epoll_wait 252
#define __NR_remap_file_pages 253
/* 254 for set_thread_area */
/* 255 for get_thread_area */
#define __NR_set_tid_address 256
#define __NR_timer_create 257
#define __NR_timer_settime 258
#define __NR_timer_gettime 259
#define __NR_timer_getoverrun 260
#define __NR_timer_delete 261
#define __NR_clock_settime 262
#define __NR_clock_gettime 263
#define __NR_clock_getres 264
#define __NR_clock_nanosleep 265
#define __NR_statfs64 266
#define __NR_fstatfs64 267
#define __NR_tgkill 268
#define __NR_utimes 269
#define __NR_arm_fadvise64_64 270
#define __NR_pciconfig_iobase 271
#define __NR_pciconfig_read 272
#define __NR_pciconfig_write 273
#define __NR_mq_open 274
#define __NR_mq_unlink 275
#define __NR_mq_timedsend 276
#define __NR_mq_timedreceive 277
#define __NR_mq_notify 278
#define __NR_mq_getsetattr 279
#define __NR_waitid 280
#define __NR_socket 281
#define __NR_bind 282
#define __NR_connect 283
#define __NR_listen 284
#define __NR_accept 285
#define __NR_getsockname 286
#define __NR_getpeername 287
#define __NR_socketpair 288
#define __NR_send 289
#define __NR_sendto 290
#define __NR_recv 291
#define __NR_recvfrom 292
#define __NR_shutdown 293
#define __NR_setsockopt 294
#define __NR_getsockopt 295
#define __NR_sendmsg 296
#define __NR_recvmsg 297
#define __NR_semop 298
#define __NR_semget 299
#define __NR_semctl 300
#define __NR_msgsnd 301
#define __NR_msgrcv 302
#define __NR_msgget 303
#define __NR_msgctl 304
#define __NR_shmat 305
#define __NR_shmdt 306
#define __NR_shmget 307
#define __NR_shmctl 308
#define __NR_add_key 309
#define __NR_request_key 310
#define __NR_keyctl 311
#define __NR_semtimedop 312
#define __NR_vserver 313
#define __NR_ioprio_set 314
#define __NR_ioprio_get 315
#define __NR_inotify_init 316
#define __NR_inotify_add_watch 317
#define __NR_inotify_rm_watch 318
#define __NR_mbind 319
#define __NR_get_mempolicy 320
#define __NR_set_mempolicy 321
#define __NR_openat 322
#define __NR_mkdirat 323
#define __NR_mknodat 324
#define __NR_fchownat 325
#define __NR_futimesat 326
#define __NR_fstatat64 327
#define __NR_unlinkat 328
#define __NR_renameat 329
#define __NR_linkat 330
#define __NR_symlinkat 331
#define __NR_readlinkat 332
#define __NR_fchmodat 333
#define __NR_faccessat 334
#define __NR_pselect6 335
#define __NR_ppoll 336
#define __NR_unshare 337
#define __NR_set_robust_list 338
#define __NR_get_robust_list 339
#define __NR_splice 340
#define __NR_sync_file_range2 341
#define __NR_tee 342
#define __NR_vmsplice 343
#define __NR_move_pages 344
#define __NR_getcpu 345
#define __NR_epoll_pwait 346
#define __NR_kexec_load 347
#define __NR_utimensat 348
#define __NR_signalfd 349
#define __NR_timerfd_create 350
#define __NR_eventfd 351
#define __NR_fallocate 352
#define __NR_timerfd_settime 353
#define __NR_timerfd_gettime 354
#define __NR_signalfd4 355
#define __NR_eventfd2 356
#define __NR_epoll_create1 357
#define __NR_dup3 358
#define __NR_pipe2 359
#define __NR_inotify_init1 360
#define __NR_preadv 361
#define __NR_pwritev 362
#define __NR_rt_tgsigqueueinfo 363
#define __NR_perf_event_open 364
#define __NR_recvmmsg 365
#define __NR_accept4 366
#define __NR_fanotify_init 367
#define __NR_fanotify_mark 368
#define __NR_prlimit64 369
#define __NR_name_to_handle_at 370
#define __NR_open_by_handle_at 371
#define __NR_clock_adjtime 372
#define __NR_syncfs 373
#define __NR_sendmmsg 374
#define __NR_setns 375
#define __NR_process_vm_readv 376
#define __NR_process_vm_writev 377
#define __NR_kcmp 378
#define __NR_finit_module 379
#define __NR_sched_setattr 380
#define __NR_sched_getattr 381
#define __NR_renameat2 382
#define __NR_seccomp 383
#define __NR_getrandom 384
#define __NR_memfd_create 385
#define __NR_bpf 386
#define __NR_execveat 387
#define __NR_userfaultfd 388
#define __NR_membarrier 389
#define __NR_mlock2 390
#define __NR_copy_file_range 391
#define __NR_preadv2 392
#define __NR_pwritev2 393
#define __NR_pkey_mprotect 394
#define __NR_pkey_alloc 395
#define __NR_pkey_free 396
#define __NR_statx 397
#define __NR_rseq 398
#define __NR_io_pgetevents 399
#define __NR_migrate_pages 400
#define __NR_kexec_file_load 401
/* 402 is unused */
#define __NR_clock_gettime64 403
#define __NR_clock_settime64 404
#define __NR_clock_adjtime64 405
#define __NR_clock_getres_time64 406
#define __NR_clock_nanosleep_time64 407
#define __NR_timer_gettime64 408
#define __NR_timer_settime64 409
#define __NR_timerfd_gettime64 410
#define __NR_timerfd_settime64 411
#define __NR_utimensat_time64 412
#define __NR_pselect6_time64 413
#define __NR_ppoll_time64 414
#define __NR_io_pgetevents_time64 416
#define __NR_recvmmsg_time64 417
#define __NR_mq_timedsend_time64 418
#define __NR_mq_timedreceive_time64 419
#define __NR_semtimedop_time64 420
#define __NR_rt_sigtimedwait_time64 421
#define __NR_futex_time64 422
#define __NR_sched_rr_get_interval_time64 423
#define __NR_pidfd_send_signal 424
#define __NR_io_uring_setup 425
#define __NR_io_uring_enter 426
#define __NR_io_uring_register 427
#define __NR_open_tree 428
#define __NR_move_mount 429
#define __NR_fsopen 430
#define __NR_fsconfig 431
#define __NR_fsmount 432
#define __NR_fspick 433
#define __NR_pidfd_open 434
#define __NR_clone3 435
#define __NR_close_range 436
#define __NR_openat2 437
#define __NR_pidfd_getfd 438
#define __NR_faccessat2 439
#define __NR_process_madvise 440
#define __NR_epoll_pwait2 441
#define __NR_mount_setattr 442
#define __NR_quotactl_fd 443
#define __NR_landlock_create_ruleset 444
#define __NR_landlock_add_rule 445
#define __NR_landlock_restrict_self 446
#define __NR_process_mrelease 448
#define __NR_futex_waitv 449
#define __NR_set_mempolicy_home_node 450

```

`kernel/linux/arch/arm64/include/uapi/asm/ptrace.h`:

```h
#ifndef _UAPI__ASM_PTRACE_H
#define _UAPI__ASM_PTRACE_H

#include <ktypes.h>
// #include <linux/bitops.h>

/*
 * PSR bits
 */
#define PSR_MODE_EL0t 0x00000000
#define PSR_MODE_EL1t 0x00000004
#define PSR_MODE_EL1h 0x00000005
#define PSR_MODE_EL2t 0x00000008
#define PSR_MODE_EL2h 0x00000009
#define PSR_MODE_EL3t 0x0000000c
#define PSR_MODE_EL3h 0x0000000d
#define PSR_MODE_MASK 0x0000000f

/* AArch32 CPSR bits */
#define PSR_MODE32_BIT 0x00000010

/* AArch64 SPSR bits */
#define PSR_F_BIT 0x00000040
#define PSR_I_BIT 0x00000080
#define PSR_A_BIT 0x00000100
#define PSR_D_BIT 0x00000200
#define PSR_BTYPE_MASK 0x00000c00
#define PSR_SSBS_BIT 0x00001000
#define PSR_PAN_BIT 0x00400000
#define PSR_UAO_BIT 0x00800000
#define PSR_DIT_BIT 0x01000000
#define PSR_TCO_BIT 0x02000000
#define PSR_V_BIT 0x10000000
#define PSR_C_BIT 0x20000000
#define PSR_Z_BIT 0x40000000
#define PSR_N_BIT 0x80000000

#define PSR_BTYPE_SHIFT 10

/*
 * Groups of PSR bits
 */
#define PSR_f 0xff000000 /* Flags		*/
#define PSR_s 0x00ff0000 /* Status		*/
#define PSR_x 0x0000ff00 /* Extension		*/
#define PSR_c 0x000000ff /* Control		*/

/* Convenience names for the values of PSTATE.BTYPE */
#define PSR_BTYPE_NONE (0b00 << PSR_BTYPE_SHIFT)
#define PSR_BTYPE_JC (0b01 << PSR_BTYPE_SHIFT)
#define PSR_BTYPE_C (0b10 << PSR_BTYPE_SHIFT)
#define PSR_BTYPE_J (0b11 << PSR_BTYPE_SHIFT)

/* syscall emulation path in ptrace */
#define PTRACE_SYSEMU 31
#define PTRACE_SYSEMU_SINGLESTEP 32
/* MTE allocation tag access */
#define PTRACE_PEEKMTETAGS 33
#define PTRACE_POKEMTETAGS 34

#ifndef __ASSEMBLY__

/*
 * User structures for general purpose, floating point and debug registers.
 */
struct user_pt_regs
{
    __u64 regs[31];
    __u64 sp;
    __u64 pc;
    __u64 pstate;
};

struct user_fpsimd_state
{
    __uint128_t vregs[32];
    __u32 fpsr;
    __u32 fpcr;
    __u32 __reserved[2];
};

struct user_hwdebug_state
{
    __u32 dbg_info;
    __u32 pad;
    struct
    {
        __u64 addr;
        __u32 ctrl;
        __u32 pad;
    } dbg_regs[16];
};

/* SVE/FP/SIMD state (NT_ARM_SVE) */

struct user_sve_header
{
    __u32 size; /* total meaningful regset content in bytes */
    __u32 max_size; /* maxmium possible size for this thread */
    __u16 vl; /* current vector length */
    __u16 max_vl; /* maximum possible vector length */
    __u16 flags;
    __u16 __reserved;
};

/* Definitions for user_sve_header.flags: */
#define SVE_PT_REGS_MASK (1 << 0)

#define SVE_PT_REGS_FPSIMD 0
#define SVE_PT_REGS_SVE SVE_PT_REGS_MASK

/*
 * Common SVE_PT_* flags:
 * These must be kept in sync with prctl interface in <linux/prctl.h>
 */
#define SVE_PT_VL_INHERIT ((1 << 17) /* PR_SVE_VL_INHERIT */ >> 16)
#define SVE_PT_VL_ONEXEC ((1 << 18) /* PR_SVE_SET_VL_ONEXEC */ >> 16)

/*
 * The remainder of the SVE state follows struct user_sve_header.  The
 * total size of the SVE state (including header) depends on the
 * metadata in the header:  SVE_PT_SIZE(vq, flags) gives the total size
 * of the state in bytes, including the header.
 *
 * Refer to <asm/sigcontext.h> for details of how to pass the correct
 * "vq" argument to these macros.
 */

/* Offset from the start of struct user_sve_header to the register data */
#define SVE_PT_REGS_OFFSET ((sizeof(struct user_sve_header) + (__SVE_VQ_BYTES - 1)) / __SVE_VQ_BYTES * __SVE_VQ_BYTES)

/*
 * The register data content and layout depends on the value of the
 * flags field.
 */

/*
 * (flags & SVE_PT_REGS_MASK) == SVE_PT_REGS_FPSIMD case:
 *
 * The payload starts at offset SVE_PT_FPSIMD_OFFSET, and is of type
 * struct user_fpsimd_state.  Additional data might be appended in the
 * future: use SVE_PT_FPSIMD_SIZE(vq, flags) to compute the total size.
 * SVE_PT_FPSIMD_SIZE(vq, flags) will never be less than
 * sizeof(struct user_fpsimd_state).
 */

#define SVE_PT_FPSIMD_OFFSET SVE_PT_REGS_OFFSET

#define SVE_PT_FPSIMD_SIZE(vq, flags) (sizeof(struct user_fpsimd_state))

/*
 * (flags & SVE_PT_REGS_MASK) == SVE_PT_REGS_SVE case:
 *
 * The payload starts at offset SVE_PT_SVE_OFFSET, and is of size
 * SVE_PT_SVE_SIZE(vq, flags).
 *
 * Additional macros describe the contents and layout of the payload.
 * For each, SVE_PT_SVE_x_OFFSET(args) is the start offset relative to
 * the start of struct user_sve_header, and SVE_PT_SVE_x_SIZE(args) is
 * the size in bytes:
 *
 *	x	type				description
 *	-	----				-----------
 *	ZREGS		\
 *	ZREG		|
 *	PREGS		| refer to <asm/sigcontext.h>
 *	PREG		|
 *	FFR		/
 *
 *	FPSR	uint32_t			FPSR
 *	FPCR	uint32_t			FPCR
 *
 * Additional data might be appended in the future.
 *
 * The Z-, P- and FFR registers are represented in memory in an endianness-
 * invariant layout which differs from the layout used for the FPSIMD
 * V-registers on big-endian systems: see sigcontext.h for more explanation.
 */

#define SVE_PT_SVE_ZREG_SIZE(vq) __SVE_ZREG_SIZE(vq)
#define SVE_PT_SVE_PREG_SIZE(vq) __SVE_PREG_SIZE(vq)
#define SVE_PT_SVE_FFR_SIZE(vq) __SVE_FFR_SIZE(vq)
#define SVE_PT_SVE_FPSR_SIZE sizeof(__u32)
#define SVE_PT_SVE_FPCR_SIZE sizeof(__u32)

#define SVE_PT_SVE_OFFSET SVE_PT_REGS_OFFSET

#define SVE_PT_SVE_ZREGS_OFFSET (SVE_PT_REGS_OFFSET + __SVE_ZREGS_OFFSET)
#define SVE_PT_SVE_ZREG_OFFSET(vq, n) (SVE_PT_REGS_OFFSET + __SVE_ZREG_OFFSET(vq, n))
#define SVE_PT_SVE_ZREGS_SIZE(vq) (SVE_PT_SVE_ZREG_OFFSET(vq, __SVE_NUM_ZREGS) - SVE_PT_SVE_ZREGS_OFFSET)

#define SVE_PT_SVE_PREGS_OFFSET(vq) (SVE_PT_REGS_OFFSET + __SVE_PREGS_OFFSET(vq))
#define SVE_PT_SVE_PREG_OFFSET(vq, n) (SVE_PT_REGS_OFFSET + __SVE_PREG_OFFSET(vq, n))
#define SVE_PT_SVE_PREGS_SIZE(vq) (SVE_PT_SVE_PREG_OFFSET(vq, __SVE_NUM_PREGS) - SVE_PT_SVE_PREGS_OFFSET(vq))

#define SVE_PT_SVE_FFR_OFFSET(vq) (SVE_PT_REGS_OFFSET + __SVE_FFR_OFFSET(vq))

#define SVE_PT_SVE_FPSR_OFFSET(vq) \
    ((SVE_PT_SVE_FFR_OFFSET(vq) + SVE_PT_SVE_FFR_SIZE(vq) + (__SVE_VQ_BYTES - 1)) / __SVE_VQ_BYTES * __SVE_VQ_BYTES)
#define SVE_PT_SVE_FPCR_OFFSET(vq) (SVE_PT_SVE_FPSR_OFFSET(vq) + SVE_PT_SVE_FPSR_SIZE)

/*
 * Any future extension appended after FPCR must be aligned to the next
 * 128-bit boundary.
 */

#define SVE_PT_SVE_SIZE(vq, flags)                                                                                     \
    ((SVE_PT_SVE_FPCR_OFFSET(vq) + SVE_PT_SVE_FPCR_SIZE - SVE_PT_SVE_OFFSET + (__SVE_VQ_BYTES - 1)) / __SVE_VQ_BYTES * \
     __SVE_VQ_BYTES)

#define SVE_PT_SIZE(vq, flags)                                                                        \
    (((flags)&SVE_PT_REGS_MASK) == SVE_PT_REGS_SVE ? SVE_PT_SVE_OFFSET + SVE_PT_SVE_SIZE(vq, flags) : \
                                                     SVE_PT_FPSIMD_OFFSET + SVE_PT_FPSIMD_SIZE(vq, flags))

/* pointer authentication masks (NT_ARM_PAC_MASK) */

struct user_pac_mask
{
    __u64 data_mask;
    __u64 insn_mask;
};

/* pointer authentication keys (NT_ARM_PACA_KEYS, NT_ARM_PACG_KEYS) */

struct user_pac_address_keys
{
    __uint128_t apiakey;
    __uint128_t apibkey;
    __uint128_t apdakey;
    __uint128_t apdbkey;
};

struct user_pac_generic_keys
{
    __uint128_t apgakey;
};

#endif /* __ASSEMBLY__ */

#endif /* _UAPI__ASM_PTRACE_H */
```

`kernel/linux/include/asm-generic/rwonce.h`:

```h
#ifndef __ASM_GENERIC_RWONCE_H
#define __ASM_GENERIC_RWONCE_H

#define READ_ONCE(x) (*(const volatile typeof(x) *)&(x))

#define WRITE_ONCE(x, val)                   \
    do {                                     \
        *(volatile typeof(x) *)&(x) = (val); \
    } while (0)

#endif

```

`kernel/linux/include/linux/bitops.h`:

```h
#ifndef _LINUX_BITOPS_H
#define _LINUX_BITOPS_H

#include <ktypes.h>

/* Set bits in the first 'n' bytes when loaded from memory */
#ifdef __LITTLE_ENDIAN
#define aligned_byte_mask(n) ((1UL << 8 * (n)) - 1)
#else
#define aligned_byte_mask(n) (~0xffUL << (BITS_PER_LONG - 8 - 8 * (n)))
#endif

#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)
#define BITS_TO_LONGS(nr) DIV_ROUND_UP(nr, BITS_PER_TYPE(long))
#define BITS_TO_U64(nr) DIV_ROUND_UP(nr, BITS_PER_TYPE(u64))
#define BITS_TO_U32(nr) DIV_ROUND_UP(nr, BITS_PER_TYPE(u32))
#define BITS_TO_BYTES(nr) DIV_ROUND_UP(nr, BITS_PER_TYPE(char))

extern unsigned int __sw_hweight8(unsigned int w);
extern unsigned int __sw_hweight16(unsigned int w);
extern unsigned int __sw_hweight32(unsigned int w);
extern unsigned long __sw_hweight64(__u64 w);

#define for_each_set_bit(bit, addr, size) \
    for ((bit) = find_first_bit((addr), (size)); (bit) < (size); (bit) = find_next_bit((addr), (size), (bit) + 1))

/* same as for_each_set_bit() but use bit as value to start with */
#define for_each_set_bit_from(bit, addr, size) \
    for ((bit) = find_next_bit((addr), (size), (bit)); (bit) < (size); (bit) = find_next_bit((addr), (size), (bit) + 1))

#define for_each_clear_bit(bit, addr, size)                           \
    for ((bit) = find_first_zero_bit((addr), (size)); (bit) < (size); \
         (bit) = find_next_zero_bit((addr), (size), (bit) + 1))

/* same as for_each_clear_bit() but use bit as value to start with */
#define for_each_clear_bit_from(bit, addr, size)                            \
    for ((bit) = find_next_zero_bit((addr), (size), (bit)); (bit) < (size); \
         (bit) = find_next_zero_bit((addr), (size), (bit) + 1))

/**
 * for_each_set_clump8 - iterate over bitmap for each 8-bit clump with set bits
 * @start: bit offset to start search and to store the current iteration offset
 * @clump: location to store copy of current 8-bit clump
 * @bits: bitmap address to base the search on
 * @size: bitmap size in number of bits
 */
#define for_each_set_clump8(start, clump, bits, size)                             \
    for ((start) = find_first_clump8(&(clump), (bits), (size)); (start) < (size); \
         (start) = find_next_clump8(&(clump), (bits), (size), (start) + 8))

static inline int get_bitmask_order(unsigned int count)
{
    int order;

    order = fls(count);
    return order; /* We could be slightly more clever with -1 here... */
}

static __always_inline unsigned long hweight_long(unsigned long w)
{
    return sizeof(w) == 4 ? hweight32(w) : hweight64((__u64)w);
}

/**
 * rol64 - rotate a 64-bit value left
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u64 rol64(__u64 word, unsigned int shift)
{
    return (word << (shift & 63)) | (word >> ((-shift) & 63));
}

/**
 * ror64 - rotate a 64-bit value right
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u64 ror64(__u64 word, unsigned int shift)
{
    return (word >> (shift & 63)) | (word << ((-shift) & 63));
}

/**
 * rol32 - rotate a 32-bit value left
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u32 rol32(__u32 word, unsigned int shift)
{
    return (word << (shift & 31)) | (word >> ((-shift) & 31));
}

/**
 * ror32 - rotate a 32-bit value right
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u32 ror32(__u32 word, unsigned int shift)
{
    return (word >> (shift & 31)) | (word << ((-shift) & 31));
}

/**
 * rol16 - rotate a 16-bit value left
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u16 rol16(__u16 word, unsigned int shift)
{
    return (word << (shift & 15)) | (word >> ((-shift) & 15));
}

/**
 * ror16 - rotate a 16-bit value right
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u16 ror16(__u16 word, unsigned int shift)
{
    return (word >> (shift & 15)) | (word << ((-shift) & 15));
}

/**
 * rol8 - rotate an 8-bit value left
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u8 rol8(__u8 word, unsigned int shift)
{
    return (word << (shift & 7)) | (word >> ((-shift) & 7));
}

/**
 * ror8 - rotate an 8-bit value right
 * @word: value to rotate
 * @shift: bits to roll
 */
static inline __u8 ror8(__u8 word, unsigned int shift)
{
    return (word >> (shift & 7)) | (word << ((-shift) & 7));
}

/**
 * sign_extend32 - sign extend a 32-bit value using specified bit as sign-bit
 * @value: value to sign extend
 * @index: 0 based bit index (0<=index<32) to sign bit
 *
 * This is safe to use for 16- and 8-bit types as well.
 */
static __always_inline __s32 sign_extend32(__u32 value, int index)
{
    __u8 shift = 31 - index;
    return (__s32)(value << shift) >> shift;
}

/**
 * sign_extend64 - sign extend a 64-bit value using specified bit as sign-bit
 * @value: value to sign extend
 * @index: 0 based bit index (0<=index<64) to sign bit
 */
static __always_inline __s64 sign_extend64(__u64 value, int index)
{
    __u8 shift = 63 - index;
    return (__s64)(value << shift) >> shift;
}

static inline unsigned fls_long(unsigned long l)
{
    if (sizeof(l) == 4)
        return fls(l);
    return fls64(l);
}

static inline int get_count_order(unsigned int count)
{
    if (count == 0)
        return -1;

    return fls(--count);
}

/**
 * get_count_order_long - get order after rounding @l up to power of 2
 * @l: parameter
 *
 * it is same as get_count_order() but with long type parameter
 */
static inline int get_count_order_long(unsigned long l)
{
    if (l == 0UL)
        return -1;
    return (int)fls_long(--l);
}

/**
 * __ffs64 - find first set bit in a 64 bit word
 * @word: The 64 bit word
 *
 * On 64 bit arches this is a synomyn for __ffs
 * The result is not defined if no bits are set, so check that @word
 * is non-zero before calling this.
 */
static inline unsigned long __ffs64(u64 word)
{
#if BITS_PER_LONG == 32
    if (((u32)word) == 0UL)
        return __ffs((u32)(word >> 32)) + 32;
#elif BITS_PER_LONG != 64
#error BITS_PER_LONG not 32 or 64
#endif
    return __ffs((unsigned long)word);
}

/**
 * assign_bit - Assign value to a bit in memory
 * @nr: the bit to set
 * @addr: the address to start counting from
 * @value: the value to assign
 */
static __always_inline void assign_bit(long nr, volatile unsigned long *addr, bool value)
{
    if (value)
        set_bit(nr, addr);
    else
        clear_bit(nr, addr);
}

static __always_inline void __assign_bit(long nr, volatile unsigned long *addr, bool value)
{
    if (value)
        __set_bit(nr, addr);
    else
        __clear_bit(nr, addr);
}

#ifndef set_mask_bits
#define set_mask_bits(ptr, mask, bits)                         \
    ({                                                         \
        const typeof(*(ptr)) mask__ = (mask), bits__ = (bits); \
        typeof(*(ptr)) old__, new__;                           \
                                                               \
        do {                                                   \
            old__ = READ_ONCE(*(ptr));                         \
            new__ = (old__ & ~mask__) | bits__;                \
        } while (cmpxchg(ptr, old__, new__) != old__);         \
                                                               \
        old__;                                                 \
    })
#endif

#ifndef bit_clear_unless
#define bit_clear_unless(ptr, clear, test)                                  \
    ({                                                                      \
        const typeof(*(ptr)) clear__ = (clear), test__ = (test);            \
        typeof(*(ptr)) old__, new__;                                        \
                                                                            \
        do {                                                                \
            old__ = READ_ONCE(*(ptr));                                      \
            new__ = old__ & ~clear__;                                       \
        } while (!(old__ & test__) && cmpxchg(ptr, old__, new__) != old__); \
                                                                            \
        !(old__ & test__);                                                  \
    })
#endif

#ifndef find_last_bit
/**
 * find_last_bit - find the last set bit in a memory region
 * @addr: The address to start the search at
 * @size: The number of bits to search
 *
 * Returns the bit number of the last set bit, or size.
 */
extern unsigned long find_last_bit(const unsigned long *addr, unsigned long size);
#endif

#endif
```

`kernel/linux/include/linux/build_bug.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _LINUX_BUILD_BUG_H
#define _LINUX_BUILD_BUG_H

#include <compiler.h>

#ifdef __CHECKER__
#define BUILD_BUG_ON_ZERO(e) (0)
#else /* __CHECKER__ */
/*
 * Force a compilation error if condition is true, but also produce a
 * result (of value 0 and type int), so the expression can be used
 * e.g. in a structure initializer (or where-ever else comma expressions
 * aren't permitted).
 */
#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int : (-!!(e)); })))
#endif /* __CHECKER__ */

/* Force a compilation error if a constant expression is not a power of 2 */
#define __BUILD_BUG_ON_NOT_POWER_OF_2(n) BUILD_BUG_ON(((n) & ((n)-1)) != 0)
#define BUILD_BUG_ON_NOT_POWER_OF_2(n) BUILD_BUG_ON((n) == 0 || (((n) & ((n)-1)) != 0))

/*
 * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the
 * expression but avoids the generation of any code, even if that expression
 * has side-effects.
 */
#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))

/**
 * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
 *		      error message.
 * @condition: the condition which the compiler should know is false.
 *
 * See BUILD_BUG_ON for description.
 */
#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)

/**
 * BUILD_BUG_ON - break compile if a condition is true.
 * @condition: the condition which the compiler should know is false.
 *
 * If you have some code which relies on certain constants being equal, or
 * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
 * detect if someone changes it.
 */
#define BUILD_BUG_ON(condition) BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)

/**
 * BUILD_BUG - break compile if used.
 *
 * If you have some code that you expect the compiler to eliminate at
 * build time, you should use BUILD_BUG to detect if it is
 * unexpectedly used.
 */
#define BUILD_BUG() BUILD_BUG_ON_MSG(1, "BUILD_BUG failed")

/**
 * static_assert - check integer constant expression at build time
 *
 * static_assert() is a wrapper for the C11 _Static_assert, with a
 * little macro magic to make the message optional (defaulting to the
 * stringification of the tested expression).
 *
 * Contrary to BUILD_BUG_ON(), static_assert() can be used at global
 * scope, but requires the expression to be an integer constant
 * expression (i.e., it is not enough that __builtin_constant_p() is
 * true for expr).
 *
 * Also note that BUILD_BUG_ON() fails the build if the condition is
 * true, while static_assert() fails the build if the expression is
 * false.
 */
#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)
#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)

#endif /* _LINUX_BUILD_BUG_H */
```

`kernel/linux/include/linux/capability.h`:

```h
#ifndef _LINUX_CAPABILITY_H
#define _LINUX_CAPABILITY_H

#include <uapi/linux/capability.h>

#define _LINUX_CAPABILITY_VERSION_3 0x20080522
#define _LINUX_CAPABILITY_U32S_3 2

#define _KERNEL_CAPABILITY_VERSION _LINUX_CAPABILITY_VERSION_3
#define _KERNEL_CAPABILITY_U32S _LINUX_CAPABILITY_U32S_3

typedef struct
{
    u64 val;
} kernel_cap_t;

#define CAP_FS_MASK                                                                                       \
    (BIT_ULL(CAP_CHOWN) | BIT_ULL(CAP_MKNOD) | BIT_ULL(CAP_DAC_OVERRIDE) | BIT_ULL(CAP_DAC_READ_SEARCH) | \
     BIT_ULL(CAP_FOWNER) | BIT_ULL(CAP_FSETID) | BIT_ULL(CAP_MAC_OVERRIDE))
#define CAP_VALID_MASK (BIT_ULL(CAP_LAST_CAP + 1) - 1)

#define CAP_EMPTY_SET ((kernel_cap_t){ 0 })
#define CAP_FULL_SET ((kernel_cap_t){ CAP_VALID_MASK })
#define CAP_FS_SET ((kernel_cap_t){ CAP_FS_MASK | BIT_ULL(CAP_LINUX_IMMUTABLE) })
#define CAP_NFSD_SET ((kernel_cap_t){ CAP_FS_MASK | BIT_ULL(CAP_SYS_RESOURCE) })

#define cap_clear(c) \
    do {             \
        (c).val = 0; \
    } while (0)

#define cap_raise(c, flag) ((c).val |= BIT_ULL(flag))
#define cap_lower(c, flag) ((c).val &= ~BIT_ULL(flag))
#define cap_raised(c, flag) (((c).val & BIT_ULL(flag)) != 0)

struct user_namespace;
struct task_struct;

extern bool has_capability(struct task_struct *t, int cap);
extern bool has_ns_capability(struct task_struct *t, struct user_namespace *ns, int cap);
extern bool has_capability_noaudit(struct task_struct *t, int cap);
extern bool has_ns_capability_noaudit(struct task_struct *t, struct user_namespace *ns, int cap);
extern bool capable(int cap);
extern bool ns_capable(struct user_namespace *ns, int cap);
extern bool ns_capable_noaudit(struct user_namespace *ns, int cap);
extern bool ns_capable_setid(struct user_namespace *ns, int cap);

extern kernel_cap_t full_cap;

#endif
```

`kernel/linux/include/linux/container_of.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _LINUX_CONTAINER_OF_H
#define _LINUX_CONTAINER_OF_H

#include <compiler.h>
#include <linux/build_bug.h>

#define typeof_member(T, m) typeof(((T *)0)->m)

/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member)                                                      \
    ({                                                                                       \
        void *__mptr = (void *)(ptr);                                                        \
        static_assert(__same_type(*(ptr), ((type *)0)->member) || __same_type(*(ptr), void), \
                      "pointer type mismatch in container_of()");                            \
        ((type *)(__mptr - offsetof(type, member)));                                         \
    })

/**
 * container_of_safe - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.
 */
#define container_of_safe(ptr, type, member)                                                     \
    ({                                                                                           \
        void *__mptr = (void *)(ptr);                                                            \
        static_assert(__same_type(*(ptr), ((type *)0)->member) || __same_type(*(ptr), void),     \
                      "pointer type mismatch in container_of_safe()");                           \
        IS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) : ((type *)(__mptr - offsetof(type, member))); \
    })

#endif /* _LINUX_CONTAINER_OF_H */
```

`kernel/linux/include/linux/cred.h`:

```h
#ifndef _LINUX_CRED_H
#define _LINUX_CRED_H

#include <ktypes.h>
#include <ksyms.h>

struct cred; // __randomize_layout
struct inode;
struct task_struct; // __randomize_layout

#define CRED_MAGIC 0x43736564
#define CRED_MAGIC_DEAD 0x44656144

extern struct group_info *groups_alloc(int);
extern void groups_free(struct group_info *);

extern int in_group_p(kgid_t);
extern int in_egroup_p(kgid_t);
extern int groups_search(const struct group_info *, kgid_t);

extern int set_current_groups(struct group_info *);
extern void set_groups(struct cred *, struct group_info *);
extern bool may_setgroups(void);
extern void groups_sort(struct group_info *);

struct cred_offset
{
    int16_t usage_offset;
    int16_t subscribers_offset;
    int16_t magic_offset;

    int16_t uid_offset;
    int16_t gid_offset;
    int16_t suid_offset;
    int16_t sgid_offset;
    int16_t euid_offset;
    int16_t egid_offset;
    int16_t fsuid_offset;
    int16_t fsgid_offset;
    int16_t securebits_offset;
    int16_t cap_inheritable_offset;
    int16_t cap_permitted_offset;
    int16_t cap_effective_offset;
    int16_t cap_bset_offset;
    int16_t cap_ambient_offset;

    int16_t user_offset;
    int16_t user_ns_offset;
    int16_t ucounts_offset;
    int16_t group_info_offset;

    int16_t session_keyring_offset;
    int16_t process_keyring_offset;
    int16_t thread_keyring_offset;
    int16_t request_key_auth_offset;

    int16_t security_offset;

    int16_t rcu_offset;
};

extern struct cred_offset cred_offset;

void try_cred_offset();

extern void kfunc_def(__put_cred)(struct cred *cred);
extern void kfunc_def(exit_creds)(struct task_struct *task);
extern int kfunc_def(copy_creds)(struct task_struct *p, unsigned long clone_flags);
extern const struct cred *kfunc_def(get_task_cred)(struct task_struct *task);
extern struct cred *kfunc_def(cred_alloc_blank)(void);
extern struct cred *kfunc_def(prepare_creds)(void);
extern struct cred *kfunc_def(prepare_exec_creds)(void);
extern int kfunc_def(commit_creds)(struct cred *new);
extern void kfunc_def(abort_creds)(struct cred *new);
extern const struct cred *kfunc_def(override_creds)(const struct cred *new);
extern void kfunc_def(revert_creds)(const struct cred *old);
extern struct cred *kfunc_def(prepare_kernel_cred)(struct task_struct *daemon);
extern int kfunc_def(change_create_files_as)(struct cred *cred, struct inode *inode);
extern int kfunc_def(set_security_override)(struct cred *a, u32 secid);
extern int kfunc_def(set_security_override_from_ctx)(struct cred *new, const char *secctx);
extern int kfunc_def(set_create_files_as)(struct cred *new, struct inode *inode);
extern int kfunc_def(cred_fscmp)(const struct cred *a, const struct cred *b);
extern void kfunc_def(cred_init)(void);
extern bool kfunc_def(creds_are_invalid)(const struct cred *cred);

static inline void __put_cred(struct cred *cred)
{
    kfunc_call(__put_cred, cred);
    kfunc_not_found();
}
static inline void exit_creds(struct task_struct *task)
{
    kfunc_call(exit_creds, task);
    kfunc_not_found();
}
static inline int copy_creds(struct task_struct *p, unsigned long clone_flags)
{
    kfunc_call(copy_creds, p, clone_flags);
    kfunc_not_found();
    return 0;
}
static inline const struct cred *get_task_cred(struct task_struct *task)
{
    kfunc_call(get_task_cred, task);
    kfunc_not_found();
    return 0;
}
static inline struct cred *cred_alloc_blank(void)
{
    kfunc_call(cred_alloc_blank);
    kfunc_not_found();
    return 0;
}
static inline struct cred *prepare_creds(void)
{
    kfunc_call(prepare_creds);
    kfunc_not_found();
    return 0;
}
static inline struct cred *prepare_exec_creds(void)
{
    kfunc_call(prepare_exec_creds);
    kfunc_not_found();
    return 0;
}
static inline int commit_creds(struct cred *new)
{
    kfunc_call(commit_creds, new);
    kfunc_not_found();
    return 0;
}
static inline void abort_creds(struct cred *new)
{
    kfunc_call(abort_creds, new);
    kfunc_not_found();
}
static inline const struct cred *override_creds(const struct cred *new)
{
    kfunc_call(override_creds, new);
    kfunc_not_found();
    return 0;
}
static inline void revert_creds(const struct cred *old)
{
    kfunc_call(revert_creds, old);
    kfunc_not_found();
}
static inline struct cred *prepare_kernel_cred(struct task_struct *daemon)
{
    kfunc_call(prepare_kernel_cred, daemon);
    kfunc_not_found();
    return 0;
}
static inline int change_create_files_as(struct cred *cred, struct inode *inode)
{
    kfunc_call(change_create_files_as, cred, inode);
    kfunc_not_found();
    return 0;
}
static inline int set_security_override(struct cred *new, u32 secid)
{
    kfunc_call(set_security_override, new, secid);
    kfunc_not_found();
    return 0;
}
static inline int set_security_override_from_ctx(struct cred *new, const char *secctx)
{
    kfunc_call(set_security_override_from_ctx, new, secctx);
    kfunc_not_found();
    return 0;
}
static inline int set_create_files_as(struct cred *new, struct inode *inode)
{
    kfunc_call(set_create_files_as, new, inode);
    kfunc_not_found();
    return 0;
}
static inline int cred_fscmp(const struct cred *a, const struct cred *b)
{
    kfunc_call(cred_fscmp, a, b);
    kfunc_not_found();
    return 0;
}
static inline void cred_init(void)
{
    kfunc_call(cred_init);
    kfunc_not_found();
}

static inline bool creds_are_invalid(const struct cred *cred)
{
    kfunc_call(creds_are_invalid, cred);
    kfunc_not_found();
    return 0;
}

#endif

```

`kernel/linux/include/linux/errno.h`:

```h
#ifndef _LINUX_ERRNO_H
#define _LINUX_ERRNO_H

#define ERESTARTSYS 512
#define ERESTARTNOINTR 513
#define ERESTARTNOHAND 514 /* restart if no handler.. */
#define ENOIOCTLCMD 515 /* No ioctl command */
#define ERESTART_RESTARTBLOCK 516 /* restart by calling sys_restart_syscall */
#define EPROBE_DEFER 517 /* Driver requests probe retry */
#define EOPENSTALE 518 /* open found a stale dentry */
#define ENOPARAM 519 /* Parameter not supported */

/* Defined for the NFSv3 protocol */
#define EBADHANDLE 521 /* Illegal NFS file handle */
#define ENOTSYNC 522 /* Update synchronization mismatch */
#define EBADCOOKIE 523 /* Cookie is stale */
#define ENOTSUPP 524 /* Operation is not supported */
#define ETOOSMALL 525 /* Buffer or request is too small */
#define ESERVERFAULT 526 /* An untranslatable error occurred */
#define EBADTYPE 527 /* Type not supported by server */
#define EJUKEBOX 528 /* Request initiated, but will not complete before timeout */
#define EIOCBQUEUED 529 /* iocb queued, will get completion event */
#define ERECALLCONFLICT 530 /* conflict with recalled state */
#define ENOGRACE

#endif
```

`kernel/linux/include/linux/fs.h`:

```h
#ifndef _LINUX_FS_H
#define _LINUX_FS_H

#include <ktypes.h>

#define MAY_EXEC 0x00000001
#define MAY_WRITE 0x00000002
#define MAY_READ 0x00000004
#define MAY_APPEND 0x00000008
#define MAY_ACCESS 0x00000010
#define MAY_OPEN 0x00000020
#define MAY_CHDIR 0x00000040
/* called from RCU mode, don't block */
#define MAY_NOT_BLOCK 0x00000080

/*
 * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
 * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()
 */

/* file is open for reading */
#define FMODE_READ ((__force fmode_t)0x1)
/* file is open for writing */
#define FMODE_WRITE ((__force fmode_t)0x2)
/* file is seekable */
#define FMODE_LSEEK ((__force fmode_t)0x4)
/* file can be accessed using pread */
#define FMODE_PREAD ((__force fmode_t)0x8)
/* file can be accessed using pwrite */
#define FMODE_PWRITE ((__force fmode_t)0x10)
/* File is opened for execution with sys_execve / sys_uselib */
#define FMODE_EXEC ((__force fmode_t)0x20)
/* File is opened with O_NDELAY (only set for block devices) */
#define FMODE_NDELAY ((__force fmode_t)0x40)
/* File is opened with O_EXCL (only set for block devices) */
#define FMODE_EXCL ((__force fmode_t)0x80)
/* File is opened using open(.., 3, ..) and is writeable only for ioctls
   (specialy hack for floppy.c) */
#define FMODE_WRITE_IOCTL ((__force fmode_t)0x100)
/* 32bit hashes as llseek() offset (for directories) */
#define FMODE_32BITHASH ((__force fmode_t)0x200)
/* 64bit hashes as llseek() offset (for directories) */
#define FMODE_64BITHASH ((__force fmode_t)0x400)

/* fs/open.c */
struct audit_names;
struct filename
{
    const char *name; /* pointer to actual string */
    const __user char *uptr; /* original userland pointer */
    struct audit_names *aname;
    int refcnt;
    const char iname[];
};

#endif
```

`kernel/linux/include/linux/gfp.h`:

```h
#ifndef __LINUX_GFP_H
#define __LINUX_GFP_H

/* Plain integer GFP bitmasks. Do not use this directly. */
#define ___GFP_DMA 0x01u
#define ___GFP_HIGHMEM 0x02u
#define ___GFP_DMA32 0x04u
#define ___GFP_MOVABLE 0x08u
#define ___GFP_RECLAIMABLE 0x10u
#define ___GFP_HIGH 0x20u
#define ___GFP_IO 0x40u
#define ___GFP_FS 0x80u
#define ___GFP_ZERO 0x100u
#define ___GFP_ATOMIC 0x200u
#define ___GFP_DIRECT_RECLAIM 0x400u
#define ___GFP_KSWAPD_RECLAIM 0x800u
#define ___GFP_WRITE 0x1000u
#define ___GFP_NOWARN 0x2000u
#define ___GFP_RETRY_MAYFAIL 0x4000u
#define ___GFP_NOFAIL 0x8000u
#define ___GFP_NORETRY 0x10000u
#define ___GFP_MEMALLOC 0x20000u
#define ___GFP_COMP 0x40000u
#define ___GFP_NOMEMALLOC 0x80000u
#define ___GFP_HARDWALL 0x100000u
#define ___GFP_THISNODE 0x200000u
#define ___GFP_ACCOUNT 0x400000u
#ifdef CONFIG_LOCKDEP
#define ___GFP_NOLOCKDEP 0x800000u
#else
#define ___GFP_NOLOCKDEP 0
#endif

#define __GFP_IO ((__force gfp_t)___GFP_IO)
#define __GFP_FS ((__force gfp_t)___GFP_FS)
#define __GFP_DIRECT_RECLAIM ((__force gfp_t)___GFP_DIRECT_RECLAIM) /* Caller can reclaim */
#define __GFP_KSWAPD_RECLAIM ((__force gfp_t)___GFP_KSWAPD_RECLAIM) /* kswapd can wake */
#define __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM | ___GFP_KSWAPD_RECLAIM))
#define __GFP_RETRY_MAYFAIL ((__force gfp_t)___GFP_RETRY_MAYFAIL)
#define __GFP_NOFAIL ((__force gfp_t)___GFP_NOFAIL)
#define __GFP_NORETRY ((__force gfp_t)___GFP_NORETRY)

#define GFP_ATOMIC (__GFP_HIGH | __GFP_ATOMIC | __GFP_KSWAPD_RECLAIM)
#define GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)
#define GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)
#define GFP_NOWAIT (__GFP_KSWAPD_RECLAIM)
#define GFP_NOIO (__GFP_RECLAIM)
#define GFP_NOFS (__GFP_RECLAIM | __GFP_IO)
#define GFP_USER (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
#define GFP_DMA __GFP_DMA
#define GFP_DMA32 __GFP_DMA32
#define GFP_HIGHUSER (GFP_USER | __GFP_HIGHMEM)
#define GFP_HIGHUSER_MOVABLE (GFP_HIGHUSER | __GFP_MOVABLE)
#define GFP_TRANSHUGE_LIGHT ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) & ~__GFP_RECLAIM)
#define GFP_TRANSHUGE (GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)

/* Convert GFP flags to their corresponding migrate type */
#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE | __GFP_MOVABLE)
#define GFP_MOVABLE_SHIFT 3

#endif
```

`kernel/linux/include/linux/init_task.h`:

```h
#ifndef _LINUX_INIT_TASK_H
#define _LINUX_INIT_TASK_H

extern union thread_union *kvar(init_thread_union);
extern int kvlen(init_thread_union);

extern struct task_struct *kvar(init_task);
extern int kvlen(init_task);

extern unsigned long *kvar(init_stack);
extern int kvlen(init_stack);

extern struct cred *kvar(init_cred);
extern int kvlen(init_cred);
extern struct group_info *kvar(init_groups);

// extern struct files_struct *init_files;
// extern struct fs_struct *init_fs;
// extern struct nsproxy *init_nsproxy;
// extern struct group_info *init_groups;

#endif
```

`kernel/linux/include/linux/kallsyms.h`:

```h
#ifndef _LINUX_KALLSYMS_H
#define _LINUX_KALLSYMS_H

#include <kallsyms.h>

#endif
```

`kernel/linux/include/linux/kern_levels.h`:

```h
#ifndef __KERN_LEVELS_H__
#define __KERN_LEVELS_H__

#define KERN_SOH "\001" /* ASCII Start Of Header */
#define KERN_SOH_ASCII '\001'

#define KERN_EMERG KERN_SOH "0" /* system is unusable */
#define KERN_ALERT KERN_SOH "1" /* action must be taken immediately */
#define KERN_CRIT KERN_SOH "2" /* critical conditions */
#define KERN_ERR KERN_SOH "3" /* error conditions */
#define KERN_WARNING KERN_SOH "4" /* warning conditions */
#define KERN_NOTICE KERN_SOH "5" /* normal but significant condition */
#define KERN_INFO KERN_SOH "6" /* informational */
#define KERN_DEBUG KERN_SOH "7" /* debug-level messages */

#define KERN_DEFAULT "" /* the default kernel loglevel */

/*
 * Annotation for a "continued" line of log printout (only done after a
 * line that had no enclosing \n). Only to be used by core/arch code
 * during early bootup (a continued line is not SMP-safe otherwise).
 */
#define KERN_CONT KERN_SOH "c"

/* integer equivalents of KERN_<LEVEL> */
#define LOGLEVEL_SCHED \
    -2 /* Deferred messages from sched code
					 * are set to this special level */
#define LOGLEVEL_DEFAULT -1 /* default (or last) loglevel */
#define LOGLEVEL_EMERG 0 /* system is unusable */
#define LOGLEVEL_ALERT 1 /* action must be taken immediately */
#define LOGLEVEL_CRIT 2 /* critical conditions */
#define LOGLEVEL_ERR 3 /* error conditions */
#define LOGLEVEL_WARNING 4 /* warning conditions */
#define LOGLEVEL_NOTICE 5 /* normal but significant condition */
#define LOGLEVEL_INFO 6 /* informational */
#define LOGLEVEL_DEBUG 7 /* debug-level messages */

#endif
```

`kernel/linux/include/linux/kernel.h`:

```h
#ifndef _LINUX_KERNEL_H
#define _LINUX_KERNEL_H

#include <ktypes.h>

// void do_exit(long error_code) __noreturn;

#endif
```

`kernel/linux/include/linux/list.h`:

```h
#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#include <ktypes.h>
#include <asm-generic/rwonce.h>
#include <asm/barrier.h>
#include <linux/poison.h>
#include <linux/container_of.h>

/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions ("__xxx") are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */

#define LIST_HEAD_INIT(name) \
    {                        \
        &(name), &(name)     \
    }

#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)

/**
 * INIT_LIST_HEAD - Initialize a list_head structure
 * @list: list_head structure to be initialized.
 *
 * Initializes the list_head to point to itself.  If it is a list header,
 * the result is an empty list.
 */
static inline void INIT_LIST_HEAD(struct list_head *list)
{
    WRITE_ONCE(list->next, list);
    list->prev = list;
}

#ifdef CONFIG_DEBUG_LIST
extern bool __list_add_valid(struct list_head *_new, struct list_head *prev, struct list_head *next);
extern bool __list_del_entry_valid(struct list_head *entry);
#else
static inline bool __list_add_valid(struct list_head *_new, struct list_head *prev, struct list_head *next)
{
    return true;
}
static inline bool __list_del_entry_valid(struct list_head *entry)
{
    return true;
}
#endif

/*
 * Insert a _new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_add(struct list_head *_new, struct list_head *prev, struct list_head *next)
{
    if (!__list_add_valid(_new, prev, next))
        return;

    next->prev = _new;
    _new->next = next;
    _new->prev = prev;
    WRITE_ONCE(prev->next, _new);
}

/**
 * list_add - add a _new entry
 * @_new: _new entry to be added
 * @head: list head to add it after
 *
 * Insert a _new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *_new, struct list_head *head)
{
    __list_add(_new, head, head->next);
}

/**
 * list_add_tail - add a _new entry
 * @_new: _new entry to be added
 * @head: list head to add it before
 *
 * Insert a _new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *_new, struct list_head *head)
{
    __list_add(_new, head->prev, head);
}

/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
    next->prev = prev;
    WRITE_ONCE(prev->next, next);
}

/*
 * Delete a list entry and clear the 'prev' pointer.
 *
 * This is a special-purpose list clearing method used in the networking code
 * for lists allocated as per-cpu, where we don't want to incur the extra
 * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this
 * needs to check the node 'prev' pointer instead of calling list_empty().
 */
static inline void __list_del_clearprev(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
    entry->prev = 0;
}

static inline void __list_del_entry(struct list_head *entry)
{
    if (!__list_del_entry_valid(entry))
        return;

    __list_del(entry->prev, entry->next);
}

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
    __list_del_entry(entry);
    entry->next = (typeof(entry->next))LIST_POISON1;
    entry->prev = (typeof(entry->prev))LIST_POISON2;
}

/**
 * list_replace - replace old entry by _new one
 * @old : the element to be replaced
 * @_new : the _new element to insert
 *
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old, struct list_head *_new)
{
    _new->next = old->next;
    _new->next->prev = _new;
    _new->prev = old->prev;
    _new->prev->next = _new;
}

/**
 * list_replace_init - replace old entry by _new one and initialize the old one
 * @old : the element to be replaced
 * @_new : the _new element to insert
 *
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace_init(struct list_head *old, struct list_head *_new)
{
    list_replace(old, _new);
    INIT_LIST_HEAD(old);
}

/**
 * list_swap - replace entry1 with entry2 and re-add entry1 at entry2's position
 * @entry1: the location to place entry2
 * @entry2: the location to place entry1
 */
static inline void list_swap(struct list_head *entry1, struct list_head *entry2)
{
    struct list_head *pos = entry2->prev;

    list_del(entry2);
    list_replace(entry1, entry2);
    if (pos == entry1)
        pos = entry2;
    list_add(entry1, pos);
}

/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
    __list_del_entry(entry);
    INIT_LIST_HEAD(entry);
}

/**
 * list_move - delete from one list and add as another's head
 * @list: the entry to move
 * @head: the head that will precede our entry
 */
static inline void list_move(struct list_head *list, struct list_head *head)
{
    __list_del_entry(list);
    list_add(list, head);
}

/**
 * list_move_tail - delete from one list and add as another's tail
 * @list: the entry to move
 * @head: the head that will follow our entry
 */
static inline void list_move_tail(struct list_head *list, struct list_head *head)
{
    __list_del_entry(list);
    list_add_tail(list, head);
}

/**
 * list_bulk_move_tail - move a subsection of a list to its tail
 * @head: the head that will follow our entry
 * @first: first entry to move
 * @last: last entry to move, can be the same as first
 *
 * Move all entries between @first and including @last before @head.
 * All three entries must belong to the same linked list.
 */
static inline void list_bulk_move_tail(struct list_head *head, struct list_head *first, struct list_head *last)
{
    first->prev->next = last->next;
    last->next->prev = first->prev;

    head->prev->next = first;
    first->prev = head->prev;

    last->next = head;
    head->prev = last;
}

/**
 * list_is_first -- tests whether @list is the first entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */
static inline int list_is_first(const struct list_head *list, const struct list_head *head)
{
    return list->prev == head;
}

/**
 * list_is_last - tests whether @list is the last entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */
static inline int list_is_last(const struct list_head *list, const struct list_head *head)
{
    return list->next == head;
}

/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
    return READ_ONCE(head->next) == head;
}

/**
 * list_del_init_careful - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 *
 * This is the same as list_del_init(), except designed to be used
 * together with list_empty_careful() in a way to guarantee ordering
 * of other memory operations.
 *
 * Any memory operations done before a list_del_init_careful() are
 * guaranteed to be visible after a list_empty_careful() test.
 */
static inline void list_del_init_careful(struct list_head *entry)
{
    __list_del_entry(entry);
    entry->prev = entry;
    smp_store_release(&entry->next, entry);
}

/**
 * list_empty_careful - tests whether a list is empty and not being modified
 * @head: the list to test
 *
 * Description:
 * tests whether a list is empty _and_ checks that no other CPU might be
 * in the process of modifying either member (next or prev)
 *
 * NOTE: using list_empty_careful() without synchronization
 * can only be safe if the only activity that can happen
 * to the list entry is list_del_init(). Eg. it cannot be used
 * if another CPU could re-list_add() it.
 */
static inline int list_empty_careful(const struct list_head *head)
{
    struct list_head *next = smp_load_acquire(&head->next);
    return (next == head) && (next == head->prev);
}

/**
 * list_rotate_left - rotate the list to the left
 * @head: the head of the list
 */
static inline void list_rotate_left(struct list_head *head)
{
    struct list_head *first;

    if (!list_empty(head)) {
        first = head->next;
        list_move_tail(first, head);
    }
}

/**
 * list_rotate_to_front() - Rotate list to specific item.
 * @list: The desired _new front of the list.
 * @head: The head of the list.
 *
 * Rotates list so that @list becomes the _new front of the list.
 */
static inline void list_rotate_to_front(struct list_head *list, struct list_head *head)
{
    /*
	 * Deletes the list head from the list denoted by @head and
	 * places it as the tail of @list, this effectively rotates the
	 * list so that @list is at the front.
	 */
    list_move_tail(head, list);
}

/**
 * list_is_singular - tests whether a list has just one entry.
 * @head: the list to test.
 */
static inline int list_is_singular(const struct list_head *head)
{
    return !list_empty(head) && (head->next == head->prev);
}

static inline void __list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
    struct list_head *_new_first = entry->next;
    list->next = head->next;
    list->next->prev = list;
    list->prev = entry;
    entry->next = list;
    head->next = _new_first;
    _new_first->prev = head;
}

/**
 * list_cut_position - cut a list into two
 * @list: a _new list to add all removed entries
 * @head: a list with entries
 * @entry: an entry within head, could be the head itself
 *	and if so we won't cut the list
 *
 * This helper moves the initial part of @head, up to and
 * including @entry, from @head to @list. You should
 * pass on @entry an element you know is on @head. @list
 * should be an empty list or a list you do not care about
 * losing its data.
 *
 */
static inline void list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
    if (list_empty(head))
        return;
    if (list_is_singular(head) && (head->next != entry && head != entry))
        return;
    if (entry == head)
        INIT_LIST_HEAD(list);
    else
        __list_cut_position(list, head, entry);
}

/**
 * list_cut_before - cut a list into two, before given entry
 * @list: a _new list to add all removed entries
 * @head: a list with entries
 * @entry: an entry within head, could be the head itself
 *
 * This helper moves the initial part of @head, up to but
 * excluding @entry, from @head to @list.  You should pass
 * in @entry an element you know is on @head.  @list should
 * be an empty list or a list you do not care about losing
 * its data.
 * If @entry == @head, all entries on @head are moved to
 * @list.
 */
static inline void list_cut_before(struct list_head *list, struct list_head *head, struct list_head *entry)
{
    if (head->next == entry) {
        INIT_LIST_HEAD(list);
        return;
    }
    list->next = head->next;
    list->next->prev = list;
    list->prev = entry->prev;
    list->prev->next = list;
    head->next = entry;
    entry->prev = head;
}

static inline void __list_splice(const struct list_head *list, struct list_head *prev, struct list_head *next)
{
    struct list_head *first = list->next;
    struct list_head *last = list->prev;

    first->prev = prev;
    prev->next = first;

    last->next = next;
    next->prev = last;
}

/**
 * list_splice - join two lists, this is designed for stacks
 * @list: the _new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice(const struct list_head *list, struct list_head *head)
{
    if (!list_empty(list))
        __list_splice(list, head, head->next);
}

/**
 * list_splice_tail - join two lists, each list being a queue
 * @list: the _new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice_tail(struct list_head *list, struct list_head *head)
{
    if (!list_empty(list))
        __list_splice(list, head->prev, head);
}

/**
 * list_splice_init - join two lists and reinitialise the emptied list.
 * @list: the _new list to add.
 * @head: the place to add it in the first list.
 *
 * The list at @list is reinitialised
 */
static inline void list_splice_init(struct list_head *list, struct list_head *head)
{
    if (!list_empty(list)) {
        __list_splice(list, head, head->next);
        INIT_LIST_HEAD(list);
    }
}

/**
 * list_splice_tail_init - join two lists and reinitialise the emptied list
 * @list: the _new list to add.
 * @head: the place to add it in the first list.
 *
 * Each of the lists is a queue.
 * The list at @list is reinitialised
 */
static inline void list_splice_tail_init(struct list_head *list, struct list_head *head)
{
    if (!list_empty(list)) {
        __list_splice(list, head->prev, head);
        INIT_LIST_HEAD(list);
    }
}

/**
 * list_entry - get the struct for this entry
 * @ptr:	the &struct list_head pointer.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) container_of(ptr, type, member)

/**
 * list_first_entry - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_first_entry(ptr, type, member) list_entry((ptr)->next, type, member)

/**
 * list_last_entry - get the last element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_last_entry(ptr, type, member) list_entry((ptr)->prev, type, member)

/**
 * list_first_entry_or_null - get the first element from a list
 * @ptr:	the list head to take the element from.
 * @type:	the type of the struct this is embedded in.
 * @member:	the name of the list_head within the struct.
 *
 * Note that if the list is empty, it returns 0.
 */
#define list_first_entry_or_null(ptr, type, member)            \
    ({                                                         \
        struct list_head *head__ = (ptr);                      \
        struct list_head *pos__ = READ_ONCE(head__->next);     \
        pos__ != head__ ? list_entry(pos__, type, member) : 0; \
    })

/**
 * list_next_entry - get the next element in list
 * @pos:	the type * to cursor
 * @member:	the name of the list_head within the struct.
 */
#define list_next_entry(pos, member) list_entry((pos)->member.next, typeof(*(pos)), member)

/**
 * list_prev_entry - get the prev element in list
 * @pos:	the type * to cursor
 * @member:	the name of the list_head within the struct.
 */
#define list_prev_entry(pos, member) list_entry((pos)->member.prev, typeof(*(pos)), member)

/**
 * list_for_each	-	iterate over a list
 * @pos:	the &struct list_head to use as a loop cursor.
 * @head:	the head for your list.
 */
#define list_for_each(pos, head) for (pos = (head)->next; pos != (head); pos = pos->next)

/**
 * list_for_each_continue - continue iteration over a list
 * @pos:	the &struct list_head to use as a loop cursor.
 * @head:	the head for your list.
 *
 * Continue to iterate over a list, continuing after the current position.
 */
#define list_for_each_continue(pos, head) for (pos = pos->next; pos != (head); pos = pos->next)

/**
 * list_for_each_prev	-	iterate over a list backwards
 * @pos:	the &struct list_head to use as a loop cursor.
 * @head:	the head for your list.
 */
#define list_for_each_prev(pos, head) for (pos = (head)->prev; pos != (head); pos = pos->prev)

/**
 * list_for_each_safe - iterate over a list safe against removal of list entry
 * @pos:	the &struct list_head to use as a loop cursor.
 * @n:		another &struct list_head to use as temporary storage
 * @head:	the head for your list.
 */
#define list_for_each_safe(pos, n, head) for (pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)

/**
 * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry
 * @pos:	the &struct list_head to use as a loop cursor.
 * @n:		another &struct list_head to use as temporary storage
 * @head:	the head for your list.
 */
#define list_for_each_prev_safe(pos, n, head) \
    for (pos = (head)->prev, n = pos->prev; pos != (head); pos = n, n = pos->prev)

/**
 * list_entry_is_head - test if the entry points to the head of the list
 * @pos:	the type * to cursor
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_entry_is_head(pos, head, member) (&pos->member == (head))

/**
 * list_for_each_entry	-	iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry(pos, head, member)                                                       \
    for (pos = list_first_entry(head, typeof(*pos), member); !list_entry_is_head(pos, head, member); \
         pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_reverse - iterate backwards over list of given type.
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry_reverse(pos, head, member)                                              \
    for (pos = list_last_entry(head, typeof(*pos), member); !list_entry_is_head(pos, head, member); \
         pos = list_prev_entry(pos, member))

/**
 * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
 * @pos:	the type * to use as a start point
 * @head:	the head of the list
 * @member:	the name of the list_head within the struct.
 *
 * Prepares a pos entry for use as a start point in list_for_each_entry_continue().
 */
#define list_prepare_entry(pos, head, member) ((pos) ?: list_entry(head, typeof(*pos), member))

/**
 * list_for_each_entry_continue - continue iteration over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Continue to iterate over list of given type, continuing after
 * the current position.
 */
#define list_for_each_entry_continue(pos, head, member) \
    for (pos = list_next_entry(pos, member); !list_entry_is_head(pos, head, member); pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_continue_reverse - iterate backwards from the given point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Start to iterate over list of given type backwards, continuing after
 * the current position.
 */
#define list_for_each_entry_continue_reverse(pos, head, member) \
    for (pos = list_prev_entry(pos, member); !list_entry_is_head(pos, head, member); pos = list_prev_entry(pos, member))

/**
 * list_for_each_entry_from - iterate over list of given type from the current point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type, continuing from current position.
 */
#define list_for_each_entry_from(pos, head, member) \
    for (; !list_entry_is_head(pos, head, member); pos = list_next_entry(pos, member))

/**
 * list_for_each_entry_from_reverse - iterate backwards over list of given type
 *                                    from the current point
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate backwards over list of given type, continuing from current position.
 */
#define list_for_each_entry_from_reverse(pos, head, member) \
    for (; !list_entry_is_head(pos, head, member); pos = list_prev_entry(pos, member))

/**
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 */
#define list_for_each_entry_safe(pos, n, head, member)                                         \
    for (pos = list_first_entry(head, typeof(*pos), member), n = list_next_entry(pos, member); \
         !list_entry_is_head(pos, head, member); pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_continue - continue list iteration safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type, continuing after current point,
 * safe against removal of list entry.
 */
#define list_for_each_entry_safe_continue(pos, n, head, member)                                                        \
    for (pos = list_next_entry(pos, member), n = list_next_entry(pos, member); !list_entry_is_head(pos, head, member); \
         pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_from - iterate over list from current point safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate over list of given type from current point, safe against
 * removal of list entry.
 */
#define list_for_each_entry_safe_from(pos, n, head, member)                        \
    for (n = list_next_entry(pos, member); !list_entry_is_head(pos, head, member); \
         pos = n, n = list_next_entry(n, member))

/**
 * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal
 * @pos:	the type * to use as a loop cursor.
 * @n:		another type * to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the list_head within the struct.
 *
 * Iterate backwards over list of given type, safe against removal
 * of list entry.
 */
#define list_for_each_entry_safe_reverse(pos, n, head, member)                                \
    for (pos = list_last_entry(head, typeof(*pos), member), n = list_prev_entry(pos, member); \
         !list_entry_is_head(pos, head, member); pos = n, n = list_prev_entry(n, member))

/**
 * list_safe_reset_next - reset a stale list_for_each_entry_safe loop
 * @pos:	the loop cursor used in the list_for_each_entry_safe loop
 * @n:		temporary storage used in list_for_each_entry_safe
 * @member:	the name of the list_head within the struct.
 *
 * list_safe_reset_next is not safe to use in general if the list may be
 * modified concurrently (eg. the lock is dropped in the loop body). An
 * exception to this is if the cursor element (pos) is pinned in the list,
 * and list_safe_reset_next is called after re-taking the lock and before
 * completing the current iteration of the loop body.
 */
#define list_safe_reset_next(pos, n, member) n = list_next_entry(pos, member)

/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1).
 */

#define HLIST_HEAD_INIT \
    {                   \
        .first = 0      \
    }
#define HLIST_HEAD(name) struct hlist_head name = { .first = 0 }
#define INIT_HLIST_HEAD(ptr) ((ptr)->first = 0)
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
    h->next = 0;
    h->pprev = 0;
}

/**
 * hlist_unhashed - Has node been removed from list and reinitialized?
 * @h: Node to be checked
 *
 * Not that not all removal functions will leave a node in unhashed
 * state.  For example, hlist_nulls_del_init_rcu() does leave the
 * node in unhashed state, but hlist_nulls_del() does not.
 */
static inline int hlist_unhashed(const struct hlist_node *h)
{
    return !h->pprev;
}

/**
 * hlist_unhashed_lockless - Version of hlist_unhashed for lockless use
 * @h: Node to be checked
 *
 * This variant of hlist_unhashed() must be used in lockless contexts
 * to avoid potential load-tearing.  The READ_ONCE() is paired with the
 * various WRITE_ONCE() in hlist helpers that are defined below.
 */
static inline int hlist_unhashed_lockless(const struct hlist_node *h)
{
    return !READ_ONCE(h->pprev);
}

/**
 * hlist_empty - Is the specified hlist_head structure an empty hlist?
 * @h: Structure to check.
 */
static inline int hlist_empty(const struct hlist_head *h)
{
    return !READ_ONCE(h->first);
}

static inline void __hlist_del(struct hlist_node *n)
{
    struct hlist_node *next = n->next;
    struct hlist_node **pprev = n->pprev;

    WRITE_ONCE(*pprev, next);
    if (next)
        WRITE_ONCE(next->pprev, pprev);
}

/**
 * hlist_del - Delete the specified hlist_node from its list
 * @n: Node to delete.
 *
 * Note that this function leaves the node in hashed state.  Use
 * hlist_del_init() or similar instead to unhash @n.
 */
static inline void hlist_del(struct hlist_node *n)
{
    __hlist_del(n);
    n->next = (typeof(n->next))LIST_POISON1;
    n->pprev = (typeof(n->pprev))LIST_POISON2;
}

/**
 * hlist_del_init - Delete the specified hlist_node from its list and initialize
 * @n: Node to delete.
 *
 * Note that this function leaves the node in unhashed state.
 */
static inline void hlist_del_init(struct hlist_node *n)
{
    if (!hlist_unhashed(n)) {
        __hlist_del(n);
        INIT_HLIST_NODE(n);
    }
}

/**
 * hlist_add_head - add a _new entry at the beginning of the hlist
 * @n: _new entry to be added
 * @h: hlist head to add it after
 *
 * Insert a _new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
    struct hlist_node *first = h->first;
    WRITE_ONCE(n->next, first);
    if (first)
        WRITE_ONCE(first->pprev, &n->next);
    WRITE_ONCE(h->first, n);
    WRITE_ONCE(n->pprev, &h->first);
}

/**
 * hlist_add_before - add a _new entry before the one specified
 * @n: _new entry to be added
 * @next: hlist node to add it before, which must be non-0
 */
static inline void hlist_add_before(struct hlist_node *n, struct hlist_node *next)
{
    WRITE_ONCE(n->pprev, next->pprev);
    WRITE_ONCE(n->next, next);
    WRITE_ONCE(next->pprev, &n->next);
    WRITE_ONCE(*(n->pprev), n);
}

/**
 * hlist_add_behing - add a _new entry after the one specified
 * @n: _new entry to be added
 * @prev: hlist node to add it after, which must be non-0
 */
static inline void hlist_add_behind(struct hlist_node *n, struct hlist_node *prev)
{
    WRITE_ONCE(n->next, prev->next);
    WRITE_ONCE(prev->next, n);
    WRITE_ONCE(n->pprev, &prev->next);

    if (n->next)
        WRITE_ONCE(n->next->pprev, &n->next);
}

/**
 * hlist_add_fake - create a fake hlist consisting of a single headless node
 * @n: Node to make a fake list out of
 *
 * This makes @n appear to be its own predecessor on a headless hlist.
 * The point of this is to allow things like hlist_del() to work correctly
 * in cases where there is no list.
 */
static inline void hlist_add_fake(struct hlist_node *n)
{
    n->pprev = &n->next;
}

/**
 * hlist_fake: Is this node a fake hlist?
 * @h: Node to check for being a self-referential fake hlist.
 */
static inline bool hlist_fake(struct hlist_node *h)
{
    return h->pprev == &h->next;
}

/**
 * hlist_is_singular_node - is node the only element of the specified hlist?
 * @n: Node to check for singularity.
 * @h: Header for potentially singular list.
 *
 * Check whether the node is the only node of the head without
 * accessing head, thus avoiding unnecessary cache misses.
 */
static inline bool hlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)
{
    return !n->next && n->pprev == &h->first;
}

/**
 * hlist_move_list - Move an hlist
 * @old: hlist_head for old list.
 * @_new: hlist_head for _new list.
 *
 * Move a list from one list head to another. Fixup the pprev
 * reference of the first entry if it exists.
 */
static inline void hlist_move_list(struct hlist_head *old, struct hlist_head *_new)
{
    _new->first = old->first;
    if (_new->first)
        _new->first->pprev = &_new->first;
    old->first = 0;
}

#define hlist_entry(ptr, type, member) container_of(ptr, type, member)

#define hlist_for_each(pos, head) for (pos = (head)->first; pos; pos = pos->next)

#define hlist_for_each_safe(pos, n, head)        \
    for (pos = (head)->first; pos && ({          \
                                  n = pos->next; \
                                  1;             \
                              });                \
         pos = n)

#define hlist_entry_safe(ptr, type, member)               \
    ({                                                    \
        typeof(ptr) ____ptr = (ptr);                      \
        ____ptr ? hlist_entry(____ptr, type, member) : 0; \
    })

/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)                              \
    for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member); pos; \
         pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
 * @pos:	the type * to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_continue(pos, member)                                \
    for (pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member); pos; \
         pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_from - iterate over a hlist continuing from current point
 * @pos:	the type * to use as a loop cursor.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_from(pos, member) \
    for (; pos; pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

/**
 * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:	the type * to use as a loop cursor.
 * @n:		a &struct hlist_node to use as temporary storage
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_safe(pos, n, head, member)                                         \
    for (pos = hlist_entry_safe((head)->first, typeof(*pos), member); pos && ({                 \
                                                                          n = pos->member.next; \
                                                                          1;                    \
                                                                      });                       \
         pos = hlist_entry_safe(n, typeof(*pos), member))

#endif
```

`kernel/linux/include/linux/mm.h`:

```h
#ifndef _LINUX_MM_H
#define _LINUX_MM_H

#endif
```

`kernel/linux/include/linux/pid.h`:

```h
#ifndef _LINUX_PID_H
#define _LINUX_PID_H

#include <ktypes.h>
#include <ksyms.h>

enum pid_type
{
    PIDTYPE_PID,
    PIDTYPE_TGID,
    PIDTYPE_PGID,
    PIDTYPE_SID,
    PIDTYPE_MAX,
};

struct upid;
struct pid;
struct file;
struct pid_namespace;
struct task_struct;

extern struct pid init_struct_pid;
extern const struct file_operations pidfd_fops;
extern struct pid_namespace init_pid_ns;
extern int pid_max;
extern int pid_max_min, pid_max_max;

extern struct pid *kfunc_def(pidfd_pid)(const struct file *file); // fork.c
extern struct pid *kfunc_def(pidfd_get_pid)(unsigned int fd, unsigned int *flags);
extern void kfunc_def(put_pid)(struct pid *pid);
extern struct task_struct *kfunc_def(pid_task)(struct pid *pid, enum pid_type);
extern struct task_struct *kfunc_def(get_pid_task)(struct pid *pid, enum pid_type);
extern struct pid *kfunc_def(get_task_pid)(struct task_struct *task, enum pid_type type);
extern void kfunc_def(attach_pid)(struct task_struct *task, enum pid_type);
extern void kfunc_def(detach_pid)(struct task_struct *task, enum pid_type);
extern void kfunc_def(change_pid)(struct task_struct *task, enum pid_type, struct pid *pid);
extern void kfunc_def(exchange_tids)(struct task_struct *task, struct task_struct *old);
extern void kfunc_def(transfer_pid)(struct task_struct *old, struct task_struct *new, enum pid_type);

extern struct pid *kfunc_def(find_pid_ns)(int nr, struct pid_namespace *ns);
extern struct pid *kfunc_def(find_vpid)(int nr);
extern struct pid *kfunc_def(find_get_pid)(int nr);
extern struct pid *kfunc_def(find_ge_pid)(int nr, struct pid_namespace *ns);
extern struct pid *kfunc_def(alloc_pid)(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size);
extern void kfunc_def(free_pid)(struct pid *pid);
extern void kfunc_def(disable_pid_allocation)(struct pid_namespace *ns);
extern pid_t kfunc_def(pid_nr_ns)(struct pid *pid, struct pid_namespace *ns);
extern pid_t kfunc_def(pid_vnr)(struct pid *pid);

static inline struct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)
{
    kfunc_call(pidfd_get_pid, fd, flags);
    kfunc_not_found();
    return 0;
}
static inline void put_pid(struct pid *pid)
{
    kfunc_call(put_pid, pid);
    kfunc_not_found();
}
static inline struct task_struct *pid_task(struct pid *pid, enum pid_type type)
{
    kfunc_call(pid_task, pid, type);
    kfunc_not_found();
    return 0;
}
static inline struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)
{
    kfunc_call(get_pid_task, pid, type);
    kfunc_not_found();
    return 0;
}
static inline struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
{
    kfunc_call(get_task_pid, task, type);
    kfunc_not_found();
    return 0;
}
static inline void attach_pid(struct task_struct *task, enum pid_type type)
{
    kfunc_call(attach_pid, task, type);
    kfunc_not_found();
}
static inline void detach_pid(struct task_struct *task, enum pid_type type)
{
    kfunc_call(detach_pid, task, type);
    kfunc_not_found();
}
static inline void change_pid(struct task_struct *task, enum pid_type type, struct pid *pid)
{
    kfunc_call(change_pid, task, type, pid);
    kfunc_not_found();
}
static inline void exchange_tids(struct task_struct *task, struct task_struct *old)
{
    kfunc_call(exchange_tids, task, old);
    kfunc_not_found();
}
static inline void transfer_pid(struct task_struct *old, struct task_struct *new, enum pid_type type)
{
    kfunc_call(transfer_pid, old, new, type);
    kfunc_not_found();
}

static inline struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
    kfunc_call(find_pid_ns, nr, ns);
    kfunc_not_found();
    return 0;
}
static inline struct pid *find_vpid(int nr)
{
    kfunc_call(find_vpid, nr);
    kfunc_not_found();
    return 0;
}
static inline struct pid *find_get_pid(int nr)
{
    kfunc_call(find_get_pid, nr);
    kfunc_not_found();
    return 0;
}
static inline struct pid *find_ge_pid(int nr, struct pid_namespace *ns)
{
    kfunc_call(find_ge_pid, nr, ns);
    kfunc_not_found();
    return 0;
}
static inline struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid, size_t set_tid_size)
{
    kfunc_call(alloc_pid, ns, set_tid, set_tid_size);
    kfunc_not_found();
    return 0;
}
static inline void free_pid(struct pid *pid)
{
    kfunc_call(free_pid, pid);
    kfunc_not_found();
}
static inline void disable_pid_allocation(struct pid_namespace *ns)
{
    kfunc_call(disable_pid_allocation, ns);
    kfunc_not_found();
}
static inline pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)
{
    kfunc_call(pid_nr_ns, pid, ns);
    kfunc_not_found();
    return 0;
}
static inline pid_t pid_vnr(struct pid *pid)
{
    kfunc_call(pid_vnr, pid);
    kfunc_not_found();
    return 0;
}

#endif /* _LINUX_PID_H */
```

`kernel/linux/include/linux/poison.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _LINUX_POISON_H
#define _LINUX_POISON_H

/********** include/linux/list.h **********/

/*
 * Architectures might want to move the poison pointer offset
 * into some well-recognized area such as 0xdead000000000000,
 * that is also not mappable by user-space exploits:
 */
#ifdef CONFIG_ILLEGAL_POINTER_VALUE
#define POISON_POINTER_DELTA _AC(CONFIG_ILLEGAL_POINTER_VALUE, UL)
#else
#define POISON_POINTER_DELTA 0
#endif

/*
 * These are non-NULL pointers that will result in page faults
 * under normal circumstances, used to verify that nobody uses
 * non-initialized list entries.
 */
#define LIST_POISON1 ((void *)0x100 + POISON_POINTER_DELTA)
#define LIST_POISON2 ((void *)0x122 + POISON_POINTER_DELTA)

/********** include/linux/timer.h **********/
#define TIMER_ENTRY_STATIC ((void *)0x300 + POISON_POINTER_DELTA)

/********** mm/page_poison.c **********/
#define PAGE_POISON 0xaa

/********** mm/page_alloc.c ************/

#define TAIL_MAPPING ((void *)0x400 + POISON_POINTER_DELTA)

/********** mm/slab.c **********/
/*
 * Magic nums for obj red zoning.
 * Placed in the first word before and the first word after an obj.
 */
#define RED_INACTIVE 0x09F911029D74E35BULL /* when obj is inactive */
#define RED_ACTIVE 0xD84156C5635688C0ULL /* when obj is active */

#define SLUB_RED_INACTIVE 0xbb
#define SLUB_RED_ACTIVE 0xcc

/* ...and for poisoning */
#define POISON_INUSE 0x5a /* for use-uninitialised poisoning */
#define POISON_FREE 0x6b /* for use-after-free poisoning */
#define POISON_END 0xa5 /* end-byte of poisoning */

/********** arch/$ARCH/mm/init.c **********/
#define POISON_FREE_INITMEM 0xcc

/********** arch/ia64/hp/common/sba_iommu.c **********/
/*
 * arch/ia64/hp/common/sba_iommu.c uses a 16-byte poison string with a
 * value of "SBAIOMMU POISON\0" for spill-over poisoning.
 */

/********** fs/jbd/journal.c **********/
#define JBD_POISON_FREE 0x5b
#define JBD2_POISON_FREE 0x5c

/********** drivers/base/dmapool.c **********/
#define POOL_POISON_FREED 0xa7 /* !inuse */
#define POOL_POISON_ALLOCATED 0xa9 /* !initted */

/********** drivers/atm/ **********/
#define ATM_POISON_FREE 0x12
#define ATM_POISON 0xdeadbeef

/********** kernel/mutexes **********/
#define MUTEX_DEBUG_INIT 0x11
#define MUTEX_DEBUG_FREE 0x22
#define MUTEX_POISON_WW_CTX ((void *)0x500 + POISON_POINTER_DELTA)

/********** security/ **********/
#define KEY_DESTROY 0xbd

/********** net/core/page_pool.c **********/
#define PP_SIGNATURE (0x40 + POISON_POINTER_DELTA)

#endif

```

`kernel/linux/include/linux/preempt.h`:

```h
#ifndef __LINUX_PREEMPT_H
#define __LINUX_PREEMPT_H

// todo

#endif
```

`kernel/linux/include/linux/printk.h`:

```h
#ifndef __KERNEL_PRINTK__
#define __KERNEL_PRINTK__

#include <ktypes.h>
#include <ksyms.h>
#include <linux/kern_levels.h>

// extern const char linux_banner[];
// extern const char linux_proc_banner[];
// extern int oops_in_progress; /* If set, an oops, panic(), BUG() or die() is in progress */
// extern int console_printk[];
// struct va_format
// {
//     const char *fmt;
//     va_list *va;
// };

// extern int vprintk_emit(int facility, int level, const struct dev_printk_info *dev_info, const char *fmt, va_list args);
// extern int vprintk(const char *fmt, va_list args);
// extern int printk(const char *fmt, ...);
// extern int printk_deferred(const char *fmt, ...);

extern void kfunc_def(dump_stack_lvl)(const char *log_lvl) __cold;
extern void kfunc_def(dump_stack)(void) __cold;

extern int __printk_ratelimit(const char *func);
#define printk_ratelimit() __printk_ratelimit(__func__)
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies, unsigned int interval_msec);

extern int printk_delay_msec;
extern int dmesg_restrict;

struct ctl_table;

extern int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void *buf, size_t *lenp, loff_t *ppos);

extern void wake_up_klogd(void);

extern void printk_safe_flush(void);
extern void printk_safe_flush_on_panic(void);

extern int kptr_restrict;

#define pr_fmt(fmt) fmt
#define pr_emerg(fmt, ...) printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
#define pr_alert(fmt, ...) printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
#define pr_crit(fmt, ...) printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)
#define pr_err(fmt, ...) printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
#define pr_warn(fmt, ...) printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
#define pr_notice(fmt, ...) printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
#define pr_info(fmt, ...) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
#define pr_cont(fmt, ...) printk(KERN_CONT fmt, ##__VA_ARGS__)

extern int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize, char *linebuf, size_t linebuflen,
                              bool ascii);

static inline void dump_stack_lvl(const char *log_lvl)
{
    kfunc_call(dump_stack_lvl, log_lvl);
    kfunc_not_found();
}

static inline void dump_stack(void)
{
    kfunc_call(dump_stack);
    kfunc_not_found();
}

#endif
```

`kernel/linux/include/linux/rcupdate.h`:

```h
#ifndef __LINUX_RCUPDATE_H
#define __LINUX_RCUPDATE_H

#include <limits.h>
#include <ktypes.h>
#include <compiler.h>

#define ULONG_CMP_GE(a, b) (ULONG_MAX / 2 >= (a) - (b))
#define ULONG_CMP_LT(a, b) (ULONG_MAX / 2 < (a) - (b))
#define ulong2long(a) (*(long *)(&(a)))
#define USHORT_CMP_GE(a, b) (USHRT_MAX / 2 >= (unsigned short)((a) - (b)))
#define USHORT_CMP_LT(a, b) (USHRT_MAX / 2 < (unsigned short)((a) - (b)))

/* Exported common interfaces */
void call_rcu(struct rcu_head *head, rcu_callback_t func);
void rcu_barrier_tasks(void);
void rcu_barrier_tasks_rude(void);
void synchronize_rcu(void);
struct rcu_gp_oldstate;
unsigned long get_completed_synchronize_rcu(void);
void get_completed_synchronize_rcu_full(struct rcu_gp_oldstate *rgosp);

void __rcu_read_lock(void);
void __rcu_read_unlock(void);

void rcu_read_unlock_strict(void);

/* Internal to kernel */
void rcu_init(void);
extern int rcu_scheduler_active;
void rcu_sched_clock_irq(int user);
void rcu_report_dead(unsigned int cpu);
void rcutree_migrate_callbacks(int cpu);

void rcu_init_tasks_generic(void);

void rcu_sysrq_start(void);
void rcu_sysrq_end(void);
void rcu_irq_work_resched(void);

void rcu_init_nohz(void);
int rcu_nocb_cpu_offload(int cpu);
int rcu_nocb_cpu_deoffload(int cpu);
void rcu_nocb_flush_deferred_wakeup(void);

void exit_tasks_rcu_start(void);
void exit_tasks_rcu_stop(void);
void exit_tasks_rcu_finish(void);

/*
 * Helper functions for rcu_dereference_check(), rcu_dereference_protected()
 * and rcu_assign_pointer().  Some of these could be folded into their
 * callers, but they are left separate in order to ease introduction of
 * multiple pointers markings to match different RCU implementations
 * (e.g., __srcu), should this make sense in the future.
 */

#ifdef __CHECKER__
#define rcu_check_sparse(p, space) ((void)(((typeof(*p) space *)p) == p))
#else /* #ifdef __CHECKER__ */
#define rcu_check_sparse(p, space)
#endif /* #else #ifdef __CHECKER__ */
#define __unrcu_pointer(p, local)                     \
    ({                                                \
        typeof(*p) *local = (typeof(*p) *__force)(p); \
        rcu_check_sparse(p, __rcu);                   \
        ((typeof(*p) __force __kernel *)(local));     \
    })
/**
 * unrcu_pointer - mark a pointer as not being RCU protected
 * @p: pointer needing to lose its __rcu property
 *
 * Converts @p from an __rcu pointer to a __kernel pointer.
 * This allows an __rcu pointer to be used with xchg() and friends.
 */
#define unrcu_pointer(p) __unrcu_pointer(p, __UNIQUE_ID(rcu))

#define __rcu_access_pointer(p, local, space)                  \
    ({                                                         \
        typeof(*p) *local = (typeof(*p) *__force)READ_ONCE(p); \
        rcu_check_sparse(p, space);                            \
        ((typeof(*p) __force __kernel *)(local));              \
    })

#define __rcu_dereference_check(p, local, c, space)                         \
    ({                                                                      \
        /* Dependency order vs. p above. */                                 \
        typeof(*p) *local = (typeof(*p) *__force)READ_ONCE(p);              \
        RCU_LOCKDEP_WARN(!(c), "suspicious rcu_dereference_check() usage"); \
        rcu_check_sparse(p, space);                                         \
        ((typeof(*p) __force __kernel *)(local));                           \
    })

#define __rcu_dereference_protected(p, local, c, space)                         \
    ({                                                                          \
        RCU_LOCKDEP_WARN(!(c), "suspicious rcu_dereference_protected() usage"); \
        rcu_check_sparse(p, space);                                             \
        ((typeof(*p) __force __kernel *)(p));                                   \
    })

#define __rcu_dereference_raw(p, local)           \
    ({                                            \
        /* Dependency order vs. p above. */       \
        typeof(p) local = READ_ONCE(p);           \
        ((typeof(*p) __force __kernel *)(local)); \
    })
#define rcu_dereference_raw(p) __rcu_dereference_raw(p, __UNIQUE_ID(rcu))

/**
 * RCU_INITIALIZER() - statically initialize an RCU-protected global variable
 * @v: The value to statically initialize with.
 */
#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)

#define rcu_assign_pointer(p, v)                                          \
    do {                                                                  \
        uintptr_t _r_a_p__v = (uintptr_t)(v);                             \
        rcu_check_sparse(p, __rcu);                                       \
                                                                          \
        if (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)    \
            WRITE_ONCE((p), (typeof(p))(_r_a_p__v));                      \
        else                                                              \
            smp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \
    } while (0)

#define rcu_replace_pointer(rcu_ptr, ptr, c)                           \
    ({                                                                 \
        typeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c)); \
        rcu_assign_pointer((rcu_ptr), (ptr));                          \
        __tmp;                                                         \
    })

#define rcu_access_pointer(p) __rcu_access_pointer((p), __UNIQUE_ID(rcu), __rcu)

#define rcu_dereference_check(p, c) __rcu_dereference_check((p), __UNIQUE_ID(rcu), (c) || rcu_read_lock_held(), __rcu)

#define rcu_dereference_bh_check(p, c) \
    __rcu_dereference_check((p), __UNIQUE_ID(rcu), (c) || rcu_read_lock_bh_held(), __rcu)

#define rcu_dereference_sched_check(p, c) \
    __rcu_dereference_check((p), __UNIQUE_ID(rcu), (c) || rcu_read_lock_sched_held(), __rcu)

#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), __UNIQUE_ID(rcu), 1, __rcu)

#define rcu_dereference_protected(p, c) __rcu_dereference_protected((p), __UNIQUE_ID(rcu), (c), __rcu)

#define rcu_dereference(p) rcu_dereference_check(p, 0)

#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)

#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)

#define rcu_pointer_handoff(p) (p)

static __always_inline void rcu_read_lock(void)
{
    __rcu_read_lock();
    __acquire(RCU);
    rcu_lock_acquire(&rcu_lock_map);
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_lock() used illegally while idle");
}

static inline void rcu_read_unlock(void)
{
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_unlock() used illegally while idle");
    __release(RCU);
    __rcu_read_unlock();
    rcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */
}

static inline void rcu_read_lock_bh(void)
{
    local_bh_disable();
    __acquire(RCU_BH);
    rcu_lock_acquire(&rcu_bh_lock_map);
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_lock_bh() used illegally while idle");
}

static inline void rcu_read_unlock_bh(void)
{
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_unlock_bh() used illegally while idle");
    rcu_lock_release(&rcu_bh_lock_map);
    __release(RCU_BH);
    local_bh_enable();
}

static inline void rcu_read_lock_sched(void)
{
    preempt_disable();
    __acquire(RCU_SCHED);
    rcu_lock_acquire(&rcu_sched_lock_map);
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_lock_sched() used illegally while idle");
}

static inline notrace void rcu_read_lock_sched_notrace(void)
{
    preempt_disable_notrace();
    __acquire(RCU_SCHED);
}

static inline void rcu_read_unlock_sched(void)
{
    RCU_LOCKDEP_WARN(!rcu_is_watching(), "rcu_read_unlock_sched() used illegally while idle");
    rcu_lock_release(&rcu_sched_lock_map);
    __release(RCU_SCHED);
    preempt_enable();
}

static inline notrace void rcu_read_unlock_sched_notrace(void)
{
    __release(RCU_SCHED);
    preempt_enable_notrace();
}

#define RCU_INIT_POINTER(p, v)             \
    do {                                   \
        rcu_check_sparse(p, __rcu);        \
        WRITE_ONCE(p, RCU_INITIALIZER(v)); \
    } while (0)

#define RCU_POINTER_INITIALIZER(p, v) .p = RCU_INITIALIZER(v)

#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)

#define kfree_rcu(ptr, rhf...) kvfree_rcu(ptr, ##rhf)

static inline void rcu_head_init(struct rcu_head *rhp)
{
    rhp->func = (rcu_callback_t)~0L;
}

static inline bool rcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)
{
    rcu_callback_t func = READ_ONCE(rhp->func);

    if (func == f)
        return true;
    WARN_ON_ONCE(func != (rcu_callback_t)~0L);
    return false;
}

/* kernel/ksysfs.c definitions */
extern int rcu_expedited;
extern int rcu_normal;

#endif
```

`kernel/linux/include/linux/rwlock.h`:

```h
#ifndef __LINUX_RWLOCK_H
#define __LINUX_RWLOCK_H

#include <ktypes.h>
#include <compiler.h>
#include <stdint.h>

// todo: arch, enough size
typedef struct
{
    volatile unsigned int lock;
} arch_rwlock_t;

typedef struct
{
    arch_rwlock_t raw_lock;
} rwlock_t;

#define __RW_LOCK_UNLOCKED() \
    (rwlock_t)               \
    {                        \
        .raw_lock = { 0, 0 } \
    }

#define DEFINE_RWLOCK(x) rwlock_t x = __RW_LOCK_UNLOCKED()

#define rwlock_init(_lockp)              \
    do {                                 \
        *(_lockp) = __RW_LOCK_UNLOCKED() \
    } while (0);

#endif

```

`kernel/linux/include/linux/sched.h`:

```h
#ifndef _LINUX_SCHED_H
#define _LINUX_SCHED_H

#include <ktypes.h>
#include <ksyms.h>
#include <stddef.h>
#include <linux/spinlock.h>
#include <linux/rwlock.h>
#include <linux/pid.h>
#include <linux/init_task.h>

struct task_struct; // __randomize_layout
struct cpumask;
struct sched_param;
struct sched_attr;
struct pid_namespace;

/* Task command name length: */
#define TASK_COMM_LEN 16

extern rwlock_t *kvar(tasklist_lock);
extern spinlock_t *kvar(mmlist_lock);

extern void scheduler_tick(void);

#define MAX_SCHEDULE_TIMEOUT LONG_MAX

extern long schedule_timeout(long timeout);
extern long schedule_timeout_interruptible(long timeout);
extern long schedule_timeout_killable(long timeout);
extern long schedule_timeout_uninterruptible(long timeout);
extern long schedule_timeout_idle(long timeout);
asmlinkage void schedule(void);
extern void schedule_preempt_disabled(void);
asmlinkage void preempt_schedule_irq(void);

extern int __must_check io_schedule_prepare(void);
extern void io_schedule_finish(int token);
extern long io_schedule_timeout(long timeout);
extern void io_schedule(void);

// todo:
struct task_struct_offset
{
    int16_t pid_offset;
    int16_t tgid_offset;
    int16_t thread_pid_offset;
    int16_t ptracer_cred_offset;
    int16_t real_cred_offset;
    int16_t cred_offset;
    int16_t fs_offset;
    int16_t files_offset;
    int16_t loginuid_offset;
    int16_t sessionid_offset;
    int16_t seccomp_offset;
    int16_t security_offset;
    int16_t stack_offset;
};

extern struct task_struct_offset task_struct_offset;

extern struct mm_struct *kvar(init_mm);
extern struct pid_namespace *kvar(init_pid_ns);

extern int cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);
extern int task_can_attach(struct task_struct *p, const struct cpumask *cs_effective_cpus);
extern void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask);
extern int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask);
extern int yield_to(struct task_struct *p, bool preempt);
extern void set_user_nice(struct task_struct *p, long nice);
extern int task_prio(const struct task_struct *p);
extern int can_nice(const struct task_struct *p, const int nice);
extern int task_curr(const struct task_struct *p);
extern int idle_cpu(int cpu);
extern int available_idle_cpu(int cpu);
extern int sched_setscheduler(struct task_struct *, int, const struct sched_param *);
extern int sched_setscheduler_nocheck(struct task_struct *, int, const struct sched_param *);
extern void sched_set_fifo(struct task_struct *p);
extern void sched_set_fifo_low(struct task_struct *p);
extern void sched_set_normal(struct task_struct *p, int nice);
extern int sched_setattr(struct task_struct *, const struct sched_attr *);
extern int sched_setattr_nocheck(struct task_struct *, const struct sched_attr *);
extern struct task_struct *idle_task(int cpu);
extern struct task_struct *curr_task(int cpu);
extern void ia64_set_curr_task(int cpu, struct task_struct *p);
void yield(void);

extern int wake_up_state(struct task_struct *tsk, unsigned int state);
extern int wake_up_process(struct task_struct *tsk);
extern void wake_up_new_task(struct task_struct *tsk);
extern void kick_process(struct task_struct *tsk);
extern void __set_task_comm(struct task_struct *tsk, const char *from, bool exec);
extern unsigned long wait_task_inactive(struct task_struct *, long match_state);

extern pid_t kfunc_def(__task_pid_nr_ns)(struct task_struct *task, enum pid_type type, struct pid_namespace *ns);
extern struct pid_namespace *kfunc_def(task_active_pid_ns)(struct task_struct *tsk);
extern struct task_struct *kfunc_def(find_task_by_vpid)(pid_t nr);
extern struct task_struct *kfunc_def(find_task_by_pid_ns)(pid_t nr, struct pid_namespace *ns);
extern struct task_struct *kfunc_def(find_get_task_by_vpid)(pid_t nr);

static inline pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type, struct pid_namespace *ns)
{
    kfunc_call(__task_pid_nr_ns, task, type, ns);
    kfunc_not_found();
    return 0;
}

static inline pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
}

static inline pid_t task_pid_vnr(struct task_struct *tsk)
{
    return __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
}

static inline struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)
{
    kfunc_call(task_active_pid_ns, tsk);
    kfunc_not_found();
    return 0;
}

static inline struct task_struct *find_task_by_vpid(pid_t nr)
{
    kfunc_call(find_task_by_vpid, nr);
    kfunc_not_found();
    return 0;
}
static inline struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
{
    kfunc_call(find_task_by_pid_ns, nr, ns);
    kfunc_not_found();
    return 0;
}
static inline struct task_struct *find_get_task_by_vpid(pid_t nr)
{
    kfunc_call(find_get_task_by_vpid, nr);
    kfunc_not_found();
    return 0;
}

#endif
```

`kernel/linux/include/linux/sched/task.h`:

```h
#ifndef _LINUX_SCHED_TASK_H
#define _LINUX_SCHED_TASK_H

#include <ktypes.h>
#include <ksyms.h>
#include <linux/init_task.h>

struct task_struct;
struct rusage;
union thread_union;
struct css_set;
struct kernel_clone_args;

extern rwlock_t *kvar(tasklist_lock);
extern spinlock_t *kvar(mmlist_lock);

extern void kfunc_def(__put_task_struct)(struct task_struct *t);
extern int kfunc_def(lockdep_tasklist_lock_is_held)(void);
extern asmlinkage void kfunc_def(schedule_tail)(struct task_struct *prev);
extern void kfunc_def(init_idle)(struct task_struct *idle, int cpu);
extern int kfunc_def(sched_fork)(unsigned long clone_flags, struct task_struct *p);
extern void kfunc_def(sched_cgroup_fork)(struct task_struct *p, struct kernel_clone_args *kargs);
extern void kfunc_def(sched_post_fork)(struct task_struct *p);
extern void kfunc_def(sched_dead)(struct task_struct *p);
extern void __noreturn kfunc_def(do_task_dead)(void);
extern void __noreturn kfunc_def(make_task_dead)(int signr);
extern void kfunc_def(proc_caches_init)(void);
extern void kfunc_def(fork_init)(void);
extern void kfunc_def(release_task)(struct task_struct *p);
// extern int kfunc_def(copy_thread)(struct task_struct *, const struct kernel_clone_args *);
extern int kfunc_def(copy_thread)(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz,
                                  struct task_struct *p, unsigned long tls);
extern void kfunc_def(flush_thread)(void);
extern void kfunc_def(exit_thread)(struct task_struct *tsk);
extern __noreturn void kfunc_def(do_group_exit)(int);
extern void kfunc_def(exit_files)(struct task_struct *);
extern void kfunc_def(exit_itimers)(struct task_struct *);
extern pid_t kfunc_def(kernel_clone)(struct kernel_clone_args *kargs);
extern struct task_struct *kfunc_def(create_io_thread)(int (*fn)(void *), void *arg, int node);
extern struct task_struct *kfunc_def(fork_idle)(int);
extern struct mm_struct *kfunc_def(copy_init_mm)(void);
extern pid_t kfunc_def(kernel_thread)(int (*fn)(void *), void *arg, unsigned long flags);
extern pid_t kfunc_def(user_mode_thread)(int (*fn)(void *), void *arg, unsigned long flags);
extern int kfunc_def(kernel_wait)(pid_t pid, int *stat);
extern void kfunc_def(free_task)(struct task_struct *tsk);
extern void kfunc_def(sched_exec)(void);

static inline void __put_task_struct(struct task_struct *t)
{
    kfunc_call(__put_task_struct, t);
    kfunc_not_found();
}
static inline int lockdep_tasklist_lock_is_held(void)
{
    kfunc_call(lockdep_tasklist_lock_is_held);
    kfunc_not_found();
    return 0;
}
static inline asmlinkage void schedule_tail(struct task_struct *prev)
{
    kfunc_call(schedule_tail, prev);
    kfunc_not_found();
}
static inline void init_idle(struct task_struct *idle, int cpu)
{
    kfunc_call(init_idle, idle, cpu);
    kfunc_not_found();
}
static inline int sched_fork(unsigned long clone_flags, struct task_struct *p)
{
    kfunc_call(sched_fork, clone_flags, p);
    kfunc_not_found();
    return 0;
}
static inline void sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs)
{
    kfunc_call(sched_cgroup_fork, p, kargs);
    kfunc_not_found();
}
static inline void sched_post_fork(struct task_struct *p)
{
    kfunc_call(sched_post_fork, p);
    kfunc_not_found();
}
static inline void sched_dead(struct task_struct *p)
{
    kfunc_call(sched_dead, p);
    kfunc_not_found();
}
static inline void __noreturn do_task_dead(void)
{
    kfunc_call_void(do_task_dead);
    kfunc_not_found();
}
static inline void __noreturn make_task_dead(int signr)
{
    kfunc_call_void(make_task_dead, signr);
    kfunc_not_found();
}
static inline void proc_caches_init(void)
{
    kfunc_call(proc_caches_init);
    kfunc_not_found();
}
static inline void fork_init(void)
{
    kfunc_call(fork_init);
    kfunc_not_found();
}
static inline void release_task(struct task_struct *p)
{
    kfunc_call(release_task, p);
    kfunc_not_found();
}
static inline int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz,
                              struct task_struct *p, unsigned long tls)
{
    kfunc_call(copy_thread, clone_flags, stack_start, stk_sz, p, tls);
    kfunc_not_found();
    return 0;
}
static inline void flush_thread(void)
{
    kfunc_call(flush_thread);
    kfunc_not_found();
}
static inline void exit_thread(struct task_struct *tsk)
{
    kfunc_call(exit_thread, tsk);
    kfunc_not_found();
}
static inline __noreturn void do_group_exit(int exit_code)
{
    kfunc_call_void(do_group_exit, exit_code);
    kfunc_not_found();
}
static inline void exit_files(struct task_struct *tsk)
{
    kfunc_call(exit_files, tsk);
    kfunc_not_found();
}
static inline void exit_itimers(struct task_struct *tsk)
{
    kfunc_call(exit_itimers, tsk);
    kfunc_not_found();
}
static inline pid_t kernel_clone(struct kernel_clone_args *kargs)
{
    kfunc_call(kernel_clone, kargs);
    kfunc_not_found();
    return 0;
}
static inline struct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)
{
    kfunc_call(create_io_thread, fn, arg, node);
    kfunc_not_found();
    return 0;
}
static inline struct task_struct *fork_idle(int cpu)
{
    kfunc_call(fork_idle, cpu);
    kfunc_not_found();
    return 0;
}
static inline struct mm_struct *copy_init_mm(void)
{
    kfunc_call(copy_init_mm);
    kfunc_not_found();
    return 0;
}
static inline pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
{
    kfunc_call(kernel_thread, fn, arg, flags);
    kfunc_not_found();
    return 0;
}
static inline pid_t user_mode_thread(int (*fn)(void *), void *arg, unsigned long flags)
{
    kfunc_call(user_mode_thread, fn, arg, flags);
    kfunc_not_found();
    return 0;
}
static inline int kernel_wait(pid_t pid, int *stat)
{
    kfunc_call(kernel_wait, pid, stat);
    kfunc_not_found();
    return 0;
}
static inline void free_task(struct task_struct *tsk)
{
    kfunc_call(free_task, tsk);
    kfunc_not_found();
}
static inline void sched_exec(void)
{
    kfunc_call(sched_exec);
    kfunc_not_found();
}

#endif
```

`kernel/linux/include/linux/security.h`:

```h
#ifndef __LINUX_SECURITY_H
#define __LINUX_SECURITY_H

#include <ktypes.h>
#include <linux/capability.h>
#include <ksyms.h>

typedef struct
{
    union
    {
        void *kernel;
        void __user *user;
    };
    bool is_kernel : 1;
} sockptr_t;

struct linux_binprm;
struct cred;
struct rlimit;
struct kernel_siginfo;
struct sembuf;
struct kern_ipc_perm;
struct audit_context;
struct super_block;
struct inode;
struct dentry;
struct file;
struct vfsmount;
struct path;
struct qstr;
struct iattr;
struct fown_struct;
struct file_operations;
struct msg_msg;
struct xattr;
struct kernfs_node;
struct xfrm_sec_ctx;
struct mm_struct;
struct fs_context;
struct fs_parameter;
enum fs_value_type;
struct watch;
struct watch_notification;
struct ctl_table;
struct audit_krule;
struct user_namespace;
struct timezone;
struct msghdr;
struct sk_buff;
struct sock;
struct sockaddr;
struct socket;
struct flowi_common;
struct dst_entry;
struct xfrm_selector;
struct xfrm_policy;
struct xfrm_state;
struct xfrm_user_sec_ctx;
struct seq_file;
struct sctp_endpoint;
struct timespec64;
struct task_struct;
struct vm_area_struct;
enum kernel_read_file_id;
enum lockdown_reason;
struct key;
struct posix_acl;
struct mnt_idmap;
struct request_sock;
struct sctp_association;
union bpf_attr;
struct bpf_map;
struct bpf_prog_aux;
struct perf_event_attr;
struct perf_event;
struct io_uring_cmd;
struct mnt_idmap;
struct request_sock;
struct sctp_association;
struct bpf_prog;

enum key_need_perm
{
    KEY_NEED_UNSPECIFIED, /* Needed permission unspecified */
    KEY_NEED_ASSUME_AUTHORITY, /* Want to assume instantiation authority */
    KEY_NEED_CHOWN, /* Want to change key's ownership/group */
    KEY_NEED_DESCRIBE, /* Want to get a key's attributes */
    KEY_NEED_GET_SECURITY, /* Want to get a key's security label */
    KEY_NEED_INSTANTIATE, /* Want to instantiate a key */
    KEY_NEED_INVALIDATE, /* Want to invalidate key */
    KEY_NEED_JOIN, /* Want to set a keyring as the session keyring */
    KEY_NEED_KEYRING_ADD, /* Want to add a link to a keyring */
    KEY_NEED_KEYRING_CLEAR, /* Want to clear a keyring */
    KEY_NEED_KEYRING_DELETE, /* Want to remove a link from a keyring */
    KEY_NEED_LINK, /* Want to create a link to a key */
    KEY_NEED_READ, /* Want to read content to userspace */
    KEY_NEED_REVOKE, /* Want to revoke a key */
    KEY_NEED_SEARCH, /* Want to find a key in a search */
    KEY_NEED_SETPERM, /* Want to set the permissions mask */
    KEY_NEED_SET_RESTRICTION, /* Want to set a restriction on a keyring */
    KEY_NEED_SET_TIMEOUT, /* Want to set the expiration time on a key */
    KEY_NEED_UNLINK, /* Want to remove a link from a key */
    KEY_NEED_UPDATE, /* Want to update a key's payload */
    KEY_NEED_USE, /* Want to use a key (in kernel) */
    KEY_NEED_WATCH, /* Want to watch a key for events */
};
enum lsm_event
{
    LSM_POLICY_CHANGE,
};

#define __kernel_read_file_id(id)                                                                                     \
    id(UNKNOWN, unknown) id(FIRMWARE, firmware) id(MODULE, kernel - module) id(KEXEC_IMAGE, kexec - image)            \
        id(KEXEC_INITRAMFS, kexec - initramfs) id(POLICY, security - policy) id(X509_CERTIFICATE, x509 - certificate) \
            id(MAX_ID, )

#define __fid_enumify(ENUM, dummy) READING_##ENUM,
#define __fid_stringify(dummy, str) #str,

enum kernel_read_file_id
{
    __kernel_read_file_id(__fid_enumify)
};

/* Keep the kernel_load_data_id enum in sync with kernel_read_file_id */
#define __data_id_enumify(ENUM, dummy) LOADING_##ENUM,
#define __data_id_stringify(dummy, str) #str,

enum kernel_load_data_id
{
    __kernel_read_file_id(__data_id_enumify)
};

enum lockdown_reason
{
    LOCKDOWN_NONE,
    LOCKDOWN_MODULE_SIGNATURE,
    LOCKDOWN_DEV_MEM,
    LOCKDOWN_EFI_TEST,
    LOCKDOWN_KEXEC,
    LOCKDOWN_HIBERNATION,
    LOCKDOWN_PCI_ACCESS,
    LOCKDOWN_IOPORT,
    LOCKDOWN_MSR,
    LOCKDOWN_ACPI_TABLES,
    LOCKDOWN_PCMCIA_CIS,
    LOCKDOWN_TIOCSSERIAL,
    LOCKDOWN_MODULE_PARAMETERS,
    LOCKDOWN_MMIOTRACE,
    LOCKDOWN_DEBUGFS,
    LOCKDOWN_XMON_WR,
    LOCKDOWN_BPF_WRITE_USER,
    LOCKDOWN_DBG_WRITE_KERNEL,
    LOCKDOWN_INTEGRITY_MAX,
    LOCKDOWN_KCORE,
    LOCKDOWN_KPROBES,
    LOCKDOWN_BPF_READ,
    LOCKDOWN_DBG_READ_KERNEL,
    LOCKDOWN_PERF,
    LOCKDOWN_TRACEFS,
    LOCKDOWN_XMON_RW,
    LOCKDOWN_CONFIDENTIALITY_MAX,
};

typedef int (*initxattrs)(struct inode *inode, const struct xattr *xattr_array, void *fs_data);

/* These functions are in security/commoncap.c */
extern int kfunc_def(cap_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts);
extern int kfunc_def(cap_settime)(const struct timespec64 *ts, const struct timezone *tz);
extern int kfunc_def(cap_ptrace_access_check)(struct task_struct *child, unsigned int mode);
extern int kfunc_def(cap_ptrace_traceme)(struct task_struct *parent);
extern int kfunc_def(cap_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                                 kernel_cap_t *permitted);
extern int kfunc_def(cap_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                                 const kernel_cap_t *inheritable, const kernel_cap_t *permitted);
extern int kfunc_def(cap_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file);
extern int kfunc_def(cap_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                         int flags);
extern int kfunc_def(cap_inode_removexattr)(struct dentry *dentry, const char *name);
extern int kfunc_def(cap_inode_need_killpriv)(struct dentry *dentry);
extern int kfunc_def(cap_inode_killpriv)(struct dentry *dentry);
extern int kfunc_def(cap_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc);
extern int kfunc_def(cap_mmap_addr)(unsigned long addr);
extern int kfunc_def(cap_mmap_file)(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags);
extern int kfunc_def(cap_task_fix_setuid)(struct cred *new, const struct cred *old, int flags);
extern int kfunc_def(cap_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                     unsigned long arg5);
extern int kfunc_def(cap_task_setscheduler)(struct task_struct *p);
extern int kfunc_def(cap_task_setioprio)(struct task_struct *p, int ioprio);
extern int kfunc_def(cap_task_setnice)(struct task_struct *p, int nice);
extern int kfunc_def(cap_vm_enough_memory)(struct mm_struct *mm, long pages);

//
/* Security operations */
extern int kfunc_def(security_binder_set_context_mgr)(const struct cred *mgr);
extern int kfunc_def(security_binder_transaction)(const struct cred *from, const struct cred *to);
extern int kfunc_def(security_binder_transfer_binder)(const struct cred *from, const struct cred *to);
extern int kfunc_def(security_binder_transfer_file)(const struct cred *from, const struct cred *to, struct file *file);
extern int kfunc_def(security_ptrace_access_check)(struct task_struct *child, unsigned int mode);
extern int kfunc_def(security_ptrace_traceme)(struct task_struct *parent);
extern int kfunc_def(security_capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                                      kernel_cap_t *permitted);
extern int kfunc_def(security_capset)(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                                      const kernel_cap_t *inheritable, const kernel_cap_t *permitted);
extern int kfunc_def(security_capable)(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts);
extern int kfunc_def(security_quotactl)(int cmds, int type, int id, struct super_block *sb);
extern int kfunc_def(security_quota_on)(struct dentry *dentry);
extern int kfunc_def(security_syslog)(int type);
extern int kfunc_def(security_settime64)(const struct timespec64 *ts, const struct timezone *tz);
extern int kfunc_def(security_vm_enough_memory_mm)(struct mm_struct *mm, long pages);
extern int kfunc_def(security_bprm_creds_for_exec)(struct linux_binprm *bprm);
extern int kfunc_def(security_bprm_creds_from_file)(struct linux_binprm *bprm, struct file *file);
extern int kfunc_def(security_bprm_check)(struct linux_binprm *bprm);
extern void kfunc_def(security_bprm_committing_creds)(struct linux_binprm *bprm);
extern void kfunc_def(security_bprm_committed_creds)(struct linux_binprm *bprm);
extern int kfunc_def(security_fs_context_dup)(struct fs_context *fc, struct fs_context *src_fc);
extern int kfunc_def(security_fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param);
extern int kfunc_def(security_sb_alloc)(struct super_block *sb);
extern void kfunc_def(security_sb_delete)(struct super_block *sb);
extern void kfunc_def(security_sb_free)(struct super_block *sb);
extern void kfunc_def(security_free_mnt_opts)(void **mnt_opts);
extern int kfunc_def(security_sb_eat_lsm_opts)(char *options, void **mnt_opts);
extern int kfunc_def(security_sb_remount)(struct super_block *sb, void *mnt_opts);
extern int kfunc_def(security_sb_kern_mount)(struct super_block *sb);
extern int kfunc_def(security_sb_show_options)(struct seq_file *m, struct super_block *sb);
extern int kfunc_def(security_sb_statfs)(struct dentry *dentry);
extern int kfunc_def(security_sb_mount)(const char *dev_name, const struct path *path, const char *type,
                                        unsigned long flags, void *data);
extern int kfunc_def(security_sb_umount)(struct vfsmount *mnt, int flags);
extern int kfunc_def(security_sb_pivotroot)(const struct path *old_path, const struct path *new_path);
extern int kfunc_def(security_sb_set_mnt_opts)(struct super_block *sb, void *mnt_opts, unsigned long kern_flags,
                                               unsigned long *set_kern_flags);
extern int kfunc_def(security_sb_clone_mnt_opts)(const struct super_block *oldsb, struct super_block *newsb,
                                                 unsigned long kern_flags, unsigned long *set_kern_flags);
extern int kfunc_def(security_add_mnt_opt)(const char *option, const char *val, int len, void **mnt_opts);
extern int kfunc_def(security_move_mount)(const struct path *from_path, const struct path *to_path);
extern int kfunc_def(security_dentry_init_security)(struct dentry *dentry, int mode, const struct qstr *name,
                                                    void **ctx, u32 *ctxlen);
extern int kfunc_def(security_dentry_create_files_as)(struct dentry *dentry, int mode, struct qstr *name,
                                                      const struct cred *old, struct cred *new);

//CONFIG_SECURITY_PATH
extern int kfunc_def(security_path_unlink)(const struct path *dir, struct dentry *dentry);
extern int kfunc_def(security_path_mkdir)(const struct path *dir, struct dentry *dentry, umode_t mode);
extern int kfunc_def(security_path_rmdir)(const struct path *dir, struct dentry *dentry);
extern int kfunc_def(security_path_mknod)(const struct path *dir, struct dentry *dentry, umode_t mode,
                                          unsigned int dev);
extern int kfunc_def(security_path_truncate)(const struct path *path);
extern int kfunc_def(security_path_symlink)(const struct path *dir, struct dentry *dentry, const char *old_name);
extern int kfunc_def(security_path_link)(struct dentry *old_dentry, const struct path *new_dir,
                                         struct dentry *new_dentry);
extern int kfunc_def(security_path_rename)(const struct path *old_dir, struct dentry *old_dentry,
                                           const struct path *new_dir, struct dentry *new_dentry, unsigned int flags);
extern int kfunc_def(security_path_chmod)(const struct path *path, umode_t mode);
extern int kfunc_def(security_path_chown)(const struct path *path, kuid_t uid, kgid_t gid);
extern int kfunc_def(security_path_chroot)(const struct path *path);
/* CONFIG_SECURITY_PATH */

/* Needed for inode based security check */
extern int kfunc_def(security_path_notify)(const struct path *path, u64 mask, unsigned int obj_type);
extern int kfunc_def(security_inode_alloc)(struct inode *inode);
extern void kfunc_def(security_inode_free)(struct inode *inode);
extern int kfunc_def(security_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                                   initxattrs initxattrs, void *fs_data);
extern int kfunc_def(security_old_inode_init_security)(struct inode *inode, struct inode *dir, const struct qstr *qstr,
                                                       const char **name, void **value, size_t *len);
extern int kfunc_def(security_inode_create)(struct inode *dir, struct dentry *dentry, umode_t mode);
extern int kfunc_def(security_inode_link)(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry);
extern int kfunc_def(security_inode_unlink)(struct inode *dir, struct dentry *dentry);
extern int kfunc_def(security_inode_symlink)(struct inode *dir, struct dentry *dentry, const char *old_name);
extern int kfunc_def(security_inode_mkdir)(struct inode *dir, struct dentry *dentry, umode_t mode);
extern int kfunc_def(security_inode_rmdir)(struct inode *dir, struct dentry *dentry);
extern int kfunc_def(security_inode_mknod)(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev);
extern int kfunc_def(security_inode_rename)(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir,
                                            struct dentry *new_dentry, unsigned int flags);
extern int kfunc_def(security_inode_readlink)(struct dentry *dentry);
extern int kfunc_def(security_inode_follow_link)(struct dentry *dentry, struct inode *inode, bool rcu);
extern int kfunc_def(security_inode_permission)(struct inode *inode, int mask);
extern int kfunc_def(security_inode_setattr)(struct dentry *dentry, struct iattr *attr);
extern int kfunc_def(security_inode_getattr)(const struct path *path);
extern int kfunc_def(security_inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size,
                                              int flags);
extern void kfunc_def(security_inode_post_setxattr)(struct dentry *dentry, const char *name, const void *value,
                                                    size_t size, int flags);
extern int kfunc_def(security_inode_getxattr)(struct dentry *dentry, const char *name);
extern int kfunc_def(security_inode_listxattr)(struct dentry *dentry);
extern int kfunc_def(security_inode_removexattr)(struct dentry *dentry, const char *name);
extern int kfunc_def(security_inode_set_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name,
                                             struct posix_acl *kacl);
extern int kfunc_def(security_inode_get_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name);
extern int kfunc_def(security_inode_remove_acl)(struct mnt_idmap *idmap, struct dentry *dentry, const char *acl_name);
extern int kfunc_def(security_inode_need_killpriv)(struct dentry *dentry);
extern int kfunc_def(security_inode_killpriv)(struct dentry *dentry);
extern int kfunc_def(security_inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc);
extern int kfunc_def(security_inode_setsecurity)(struct inode *inode, const char *name, const void *value, size_t size,
                                                 int flags);
extern int kfunc_def(security_inode_listsecurity)(struct inode *inode, char *buffer, size_t buffer_size);
extern void kfunc_def(security_inode_getsecid)(struct inode *inode, u32 *secid);
extern int kfunc_def(security_inode_copy_up)(struct dentry *src, struct cred **new);
extern int kfunc_def(security_inode_copy_up_xattr)(const char *name);
extern int kfunc_def(security_kernfs_init_security)(struct kernfs_node *kn_dir, struct kernfs_node *kn);
extern int kfunc_def(security_file_permission)(struct file *file, int mask);
extern int kfunc_def(security_file_alloc)(struct file *file);
extern void kfunc_def(security_file_free)(struct file *file);
extern int kfunc_def(security_file_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
extern int kfunc_def(security_mmap_addr)(unsigned long addr);
extern int kfunc_def(security_mmap_file)(struct file *file, unsigned long prot, unsigned long flags);
extern int kfunc_def(security_file_mprotect)(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot);
extern int kfunc_def(security_file_lock)(struct file *file, unsigned int cmd);
extern int kfunc_def(security_file_fcntl)(struct file *file, unsigned int cmd, unsigned long arg);
extern void kfunc_def(security_file_set_fowner)(struct file *file);
extern int kfunc_def(security_file_send_sigiotask)(struct task_struct *tsk, struct fown_struct *fown, int sig);
extern int kfunc_def(security_file_receive)(struct file *file);
// extern int kfunc_def(security_file_open)(struct file *file);
extern int kfunc_def(security_file_open)(struct file *file, const struct cred *cred);
extern int kfunc_def(security_file_truncate)(struct file *file);
extern int kfunc_def(security_task_alloc)(struct task_struct *task, unsigned long clone_flags);
extern void kfunc_def(security_task_free)(struct task_struct *task);
extern int kfunc_def(security_cred_alloc_blank)(struct cred *cred, gfp_t gfp);
extern void kfunc_def(security_cred_free)(struct cred *cred);
extern int kfunc_def(security_prepare_creds)(struct cred *new, const struct cred *old, gfp_t gfp);
extern void kfunc_def(security_transfer_creds)(struct cred *new, const struct cred *old);
extern void kfunc_def(security_cred_getsecid)(const struct cred *c, u32 *secid);
extern int kfunc_def(security_kernel_act_as)(struct cred *new, u32 secid);
extern int kfunc_def(security_kernel_create_files_as)(struct cred *new, struct inode *inode);
extern int kfunc_def(security_kernel_module_request)(char *kmod_name);
extern int kfunc_def(security_kernel_load_data)(enum kernel_load_data_id id, bool contents);
extern int kfunc_def(security_kernel_post_load_data)(char *buf, loff_t size, enum kernel_load_data_id id,
                                                     char *description);
extern int kfunc_def(security_kernel_read_file)(struct file *file, enum kernel_read_file_id id, bool contents);
extern int kfunc_def(security_kernel_post_read_file)(struct file *file, char *buf, loff_t size,
                                                     enum kernel_read_file_id id);
extern int kfunc_def(security_task_fix_setuid)(struct cred *new, const struct cred *old, int flags);
extern int kfunc_def(security_task_fix_setgid)(struct cred *new, const struct cred *old, int flags);
extern int kfunc_def(security_task_fix_setgroups)(struct cred *new, const struct cred *old);
extern int kfunc_def(security_task_setpgid)(struct task_struct *p, pid_t pgid);
extern int kfunc_def(security_task_getpgid)(struct task_struct *p);
extern int kfunc_def(security_task_getsid)(struct task_struct *p);
extern void kfunc_def(security_current_getsecid_subj)(u32 *secid);
extern void kfunc_def(security_task_getsecid_obj)(struct task_struct *p, u32 *secid); // ?-6.3
extern void kfunc_def(security_task_getsecid)(struct task_struct *p, u32 *secid); // 4.4-?
extern int kfunc_def(security_task_setnice)(struct task_struct *p, int nice);
extern int kfunc_def(security_task_setioprio)(struct task_struct *p, int ioprio);
extern int kfunc_def(security_task_getioprio)(struct task_struct *p);
extern int kfunc_def(security_task_prlimit)(const struct cred *cred, const struct cred *tcred, unsigned int flags);
extern int kfunc_def(security_task_setrlimit)(struct task_struct *p, unsigned int resource, struct rlimit *new_rlim);
extern int kfunc_def(security_task_setscheduler)(struct task_struct *p);
extern int kfunc_def(security_task_getscheduler)(struct task_struct *p);
extern int kfunc_def(security_task_movememory)(struct task_struct *p);
extern int kfunc_def(security_task_kill)(struct task_struct *p, struct kernel_siginfo *info, int sig,
                                         const struct cred *cred);
extern int kfunc_def(security_task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                          unsigned long arg5);
extern void kfunc_def(security_task_to_inode)(struct task_struct *p, struct inode *inode);
extern int kfunc_def(security_create_user_ns)(const struct cred *cred);
extern int kfunc_def(security_ipc_permission)(struct kern_ipc_perm *ipcp, short flag);
extern void kfunc_def(security_ipc_getsecid)(struct kern_ipc_perm *ipcp, u32 *secid);
extern int kfunc_def(security_msg_msg_alloc)(struct msg_msg *msg);
extern void kfunc_def(security_msg_msg_free)(struct msg_msg *msg);
extern int kfunc_def(security_msg_queue_alloc)(struct kern_ipc_perm *msq);
extern void kfunc_def(security_msg_queue_free)(struct kern_ipc_perm *msq);
extern int kfunc_def(security_msg_queue_associate)(struct kern_ipc_perm *msq, int msqflg);
extern int kfunc_def(security_msg_queue_msgctl)(struct kern_ipc_perm *msq, int cmd);
extern int kfunc_def(security_msg_queue_msgsnd)(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg);
extern int kfunc_def(security_msg_queue_msgrcv)(struct kern_ipc_perm *msq, struct msg_msg *msg,
                                                struct task_struct *target, long type, int mode);
extern int kfunc_def(security_shm_alloc)(struct kern_ipc_perm *shp);
extern void kfunc_def(security_shm_free)(struct kern_ipc_perm *shp);
extern int kfunc_def(security_shm_associate)(struct kern_ipc_perm *shp, int shmflg);
extern int kfunc_def(security_shm_shmctl)(struct kern_ipc_perm *shp, int cmd);
extern int kfunc_def(security_shm_shmat)(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg);
extern int kfunc_def(security_sem_alloc)(struct kern_ipc_perm *sma);
extern void kfunc_def(security_sem_free)(struct kern_ipc_perm *sma);
extern int kfunc_def(security_sem_associate)(struct kern_ipc_perm *sma, int semflg);
extern int kfunc_def(security_sem_semctl)(struct kern_ipc_perm *sma, int cmd);
extern int kfunc_def(security_sem_semop)(struct kern_ipc_perm *sma, struct sembuf *sops, unsigned nsops, int alter);
extern void kfunc_def(security_d_instantiate)(struct dentry *dentry, struct inode *inode);
extern int kfunc_def(security_getprocattr)(struct task_struct *p, const char *lsm, char *name, char **value);
extern int kfunc_def(security_setprocattr)(const char *lsm, const char *name, void *value, size_t size);
extern int kfunc_def(security_netlink_send)(struct sock *sk, struct sk_buff *skb);
extern int kfunc_def(security_ismaclabel)(const char *name);
extern int kfunc_def(security_secid_to_secctx)(u32 secid, char **secdata, u32 *seclen);
extern int kfunc_def(security_secctx_to_secid)(const char *secdata, u32 seclen, u32 *secid);
extern void kfunc_def(security_release_secctx)(char *secdata, u32 seclen);
extern void kfunc_def(security_inode_invalidate_secctx)(struct inode *inode);
extern int kfunc_def(security_inode_notifysecctx)(struct inode *inode, void *ctx, u32 ctxlen);
extern int kfunc_def(security_inode_setsecctx)(struct dentry *dentry, void *ctx, u32 ctxlen);
extern int kfunc_def(security_inode_getsecctx)(struct inode *inode, void **ctx, u32 *ctxlen);

// CONFIG_WATCH_QUEUE
extern int kfunc_def(security_post_notification)(const struct cred *w_cred, const struct cred *cred,
                                                 struct watch_notification *n);

// CONFIG_KEY_NOTIFICATIONS
extern int kfunc_def(security_watch_key)(struct key *key);

// CONFIG_SECURITY_NETWORK
extern int kfunc_def(security_unix_stream_connect)(struct sock *sock, struct sock *other, struct sock *newsk);
extern int kfunc_def(security_unix_may_send)(struct socket *sock, struct socket *other);
extern int kfunc_def(security_socket_create)(int family, int type, int protocol, int kern);
extern int kfunc_def(security_socket_post_create)(struct socket *sock, int family, int type, int protocol, int kern);
extern int kfunc_def(security_socket_socketpair)(struct socket *socka, struct socket *sockb);
extern int kfunc_def(security_socket_bind)(struct socket *sock, struct sockaddr *address, int addrlen);
extern int kfunc_def(security_socket_connect)(struct socket *sock, struct sockaddr *address, int addrlen);
extern int kfunc_def(security_socket_listen)(struct socket *sock, int backlog);
extern int kfunc_def(security_socket_accept)(struct socket *sock, struct socket *newsock);
extern int kfunc_def(security_socket_sendmsg)(struct socket *sock, struct msghdr *msg, int size);
extern int kfunc_def(security_socket_recvmsg)(struct socket *sock, struct msghdr *msg, int size, int flags);
extern int kfunc_def(security_socket_getsockname)(struct socket *sock);
extern int kfunc_def(security_socket_getpeername)(struct socket *sock);
extern int kfunc_def(security_socket_getsockopt)(struct socket *sock, int level, int optname);
extern int kfunc_def(security_socket_setsockopt)(struct socket *sock, int level, int optname);
extern int kfunc_def(security_socket_shutdown)(struct socket *sock, int how);
extern int kfunc_def(security_sock_rcv_skb)(struct sock *sk, struct sk_buff *skb);
extern int kfunc_def(security_socket_getpeersec_stream)(struct socket *sock, sockptr_t optval, sockptr_t optlen,
                                                        unsigned int len);
extern int kfunc_def(security_socket_getpeersec_dgram)(struct socket *sock, struct sk_buff *skb, u32 *secid);
extern int kfunc_def(security_sk_alloc)(struct sock *sk, int family, gfp_t priority);
extern void kfunc_def(security_sk_free)(struct sock *sk);
extern void kfunc_def(security_sk_clone)(const struct sock *sk, struct sock *newsk);
extern void kfunc_def(security_sk_classify_flow)(struct sock *sk, struct flowi_common *flic);
extern void kfunc_def(security_req_classify_flow)(const struct request_sock *req, struct flowi_common *flic);
extern void kfunc_def(security_sock_graft)(struct sock *sk, struct socket *parent);
extern int kfunc_def(security_inet_conn_request)(const struct sock *sk, struct sk_buff *skb, struct request_sock *req);
extern void kfunc_def(security_inet_csk_clone)(struct sock *newsk, const struct request_sock *req);
extern void kfunc_def(security_inet_conn_established)(struct sock *sk, struct sk_buff *skb);
extern int kfunc_def(security_secmark_relabel_packet)(u32 secid);
extern void kfunc_def(security_secmark_refcount_inc)(void);
extern void kfunc_def(security_secmark_refcount_dec)(void);
extern int kfunc_def(security_tun_dev_alloc_security)(void **security);
extern void kfunc_def(security_tun_dev_free_security)(void *security);
extern int kfunc_def(security_tun_dev_create)(void);
extern int kfunc_def(security_tun_dev_attach_queue)(void *security);
extern int kfunc_def(security_tun_dev_attach)(struct sock *sk, void *security);
extern int kfunc_def(security_tun_dev_open)(void *security);
extern int kfunc_def(security_sctp_assoc_request)(struct sctp_association *asoc, struct sk_buff *skb);
extern int kfunc_def(security_sctp_bind_connect)(struct sock *sk, int optname, struct sockaddr *address, int addrlen);
extern void kfunc_def(security_sctp_sk_clone)(struct sctp_association *asoc, struct sock *sk, struct sock *newsk);
extern int kfunc_def(security_sctp_assoc_established)(struct sctp_association *asoc, struct sk_buff *skb);

// CONFIG_SECURITY_INFINIBAND
extern int kfunc_def(security_ib_pkey_access)(void *sec, u64 subnet_prefix, u16 pkey);
extern int kfunc_def(security_ib_endport_manage_subnet)(void *sec, const char *dev_name, u8 port_num);
extern int kfunc_def(security_ib_alloc_security)(void **sec);
extern void kfunc_def(security_ib_free_security)(void *sec);

// CONFIG_SECURITY_NETWORK_XFRM
extern int kfunc_def(security_xfrm_policy_alloc)(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx,
                                                 gfp_t gfp);
extern int kfunc_def(security_xfrm_policy_clone)(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctxp);
extern void kfunc_def(security_xfrm_policy_free)(struct xfrm_sec_ctx *ctx);
extern int kfunc_def(security_xfrm_policy_delete)(struct xfrm_sec_ctx *ctx);
extern int kfunc_def(security_xfrm_state_alloc)(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx);
extern int kfunc_def(security_xfrm_state_alloc_acquire)(struct xfrm_state *x, struct xfrm_sec_ctx *polsec, u32 secid);
extern int kfunc_def(security_xfrm_state_delete)(struct xfrm_state *x);
extern void kfunc_def(security_xfrm_state_free)(struct xfrm_state *x);
extern int kfunc_def(security_xfrm_policy_lookup)(struct xfrm_sec_ctx *ctx, u32 fl_secid);
extern int kfunc_def(security_xfrm_state_pol_flow_match)(struct xfrm_state *x, struct xfrm_policy *xp,
                                                         const struct flowi_common *flic);
extern int kfunc_def(security_xfrm_decode_session)(struct sk_buff *skb, u32 *secid);
extern void kfunc_def(security_skb_classify_flow)(struct sk_buff *skb, struct flowi_common *flic);

/* key management security hooks */
// CONFIG_KEYS
typedef void *key_ref_t;
extern int kfunc_def(security_key_alloc)(struct key *key, const struct cred *cred, unsigned long flags);
extern void kfunc_def(security_key_free)(struct key *key);
extern int kfunc_def(security_key_permission)(key_ref_t key_ref, const struct cred *cred, enum key_need_perm need_perm);
extern int kfunc_def(security_key_getsecurity)(struct key *key, char **_buffer);

// CONFIG_AUDIT
extern int kfunc_def(security_audit_rule_init)(u32 field, u32 op, char *rulestr, void **lsmrule);
extern int kfunc_def(security_audit_rule_known)(struct audit_krule *krule);
extern void kfunc_def(security_audit_rule_free)(void *lsmrule);
extern int kfunc_def(security_audit_rule_match)(u32 secid, u32 field, u32 op, void *lsmrule);

// CONFIG_BPF_SYSCALL
extern int kfunc_def(security_bpf)(int cmd, union bpf_attr *attr, unsigned int size);
extern int kfunc_def(security_bpf_map)(struct bpf_map *map, fmode_t fmode);
extern int kfunc_def(security_bpf_prog)(struct bpf_prog *prog);
extern int kfunc_def(security_bpf_map_alloc)(struct bpf_map *map);
extern int kfunc_def(security_bpf_prog_alloc)(struct bpf_prog_aux *aux);
extern void kfunc_def(security_bpf_map_free)(struct bpf_map *map);
extern void kfunc_def(security_bpf_prog_free)(struct bpf_prog_aux *aux);
// CONFIG_BPF_SYSCALL

extern int kfunc_def(security_locked_down)(enum lockdown_reason what);

// CONFIG_PERF_EVENTS
extern int kfunc_def(security_perf_event_open)(struct perf_event_attr *attr, int type);
extern int kfunc_def(security_perf_event_alloc)(struct perf_event *event);
extern void kfunc_def(security_perf_event_free)(struct perf_event *event);
extern int kfunc_def(security_perf_event_read)(struct perf_event *event);
extern int kfunc_def(security_perf_event_write)(struct perf_event *event);

// CONFIG_IO_URING
extern int kfunc_def(security_uring_override_creds)(const struct cred *new);
extern int kfunc_def(security_uring_sqpoll)(void);
extern int kfunc_def(security_uring_cmd)(struct io_uring_cmd *ioucmd);

//
static inline int cap_capable(const struct cred *cred, struct user_namespace *ns, int cap, unsigned int opts)
{
    kfunc_call(cap_capable, cred, ns, cap, opts);
    kfunc_not_found();
    return 0;
}
static inline int cap_settime(const struct timespec64 *ts, const struct timezone *tz)
{
    kfunc_call(cap_settime, ts, tz);
    kfunc_not_found();
    return 0;
}
static inline int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)
{
    kfunc_call(cap_ptrace_access_check, child, mode);
    kfunc_not_found();
    return 0;
}
static inline int cap_ptrace_traceme(struct task_struct *parent)
{
    kfunc_call(cap_ptrace_traceme, parent);
    kfunc_not_found();
    return 0;
}
static inline int cap_capget(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable,
                             kernel_cap_t *permitted)
{
    kfunc_call(cap_capget, target, effective, inheritable, permitted);
    kfunc_not_found();
    return 0;
}
static inline int cap_capset(struct cred *new, const struct cred *old, const kernel_cap_t *effective,
                             const kernel_cap_t *inheritable, const kernel_cap_t *permitted)
{
    kfunc_call(cap_capset, new, old, effective, inheritable, permitted);
    kfunc_not_found();
    return 0;
}
static inline int cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)
{
    kfunc_call(cap_bprm_creds_from_file, bprm, file);
    kfunc_not_found();
    return 0;
}
static inline int cap_inode_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags)
{
    kfunc_call(cap_inode_setxattr, dentry, name, value, size, flags);
    kfunc_not_found();
    return 0;
}
static inline int cap_inode_removexattr(struct dentry *dentry, const char *name)
{
    kfunc_call(cap_inode_removexattr, dentry, name);
    kfunc_not_found();
    return 0;
}
static inline int cap_inode_need_killpriv(struct dentry *dentry)
{
    kfunc_call(cap_inode_need_killpriv, dentry);
    kfunc_not_found();
    return 0;
}
static inline int cap_inode_killpriv(struct dentry *dentry)
{
    kfunc_call(cap_inode_killpriv, dentry);
    kfunc_not_found();
    return 0;
}
static inline int cap_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)
{
    kfunc_call(cap_inode_getsecurity, inode, name, buffer, alloc);
    kfunc_not_found();
    return 0;
}
static inline int cap_mmap_addr(unsigned long addr)
{
    kfunc_call(cap_mmap_addr, addr);
    kfunc_not_found();
    return 0;
}
static inline int cap_mmap_file(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags)
{
    kfunc_call(cap_mmap_file, file, reqprot, prot, flags);
    kfunc_not_found();
    return 0;
}
static inline int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)
{
    kfunc_call(cap_task_fix_setuid, new, old, flags);
    kfunc_not_found();
    return 0;
}
static inline int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4,
                                 unsigned long arg5)
{
    kfunc_call(cap_task_prctl, option, arg2, arg3, arg4, arg5);
    kfunc_not_found();
    return 0;
}
static inline int cap_task_setscheduler(struct task_struct *p)
{
    kfunc_call(cap_task_setscheduler, p);
    kfunc_not_found();
    return 0;
}
static inline int cap_task_setioprio(struct task_struct *p, int ioprio)
{
    kfunc_call(cap_task_setioprio, p, ioprio);
    kfunc_not_found();
    return 0;
}
static inline int cap_task_setnice(struct task_struct *p, int nice)
{
    kfunc_call(cap_task_setnice, p, nice);
    kfunc_not_found();
    return 0;
}
static inline int cap_vm_enough_memory(struct mm_struct *mm, long pages)
{
    kfunc_call(cap_vm_enough_memory, mm, pages);
    kfunc_not_found();
    return 0;
}

//

static inline void security_task_getsecid(struct task_struct *task, u32 *secid)
{
    kfunc_call(security_task_getsecid, task, secid);
    kfunc_call(security_task_getsecid_obj, task, secid);
    kfunc_not_found();
}

// When we are uncertain whether secctx exists or is correct, we cannot rely on security_secctx_to_secid; otherwise, secid might be set to an unexpected value.
static inline int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
{
    kfunc_call(security_secctx_to_secid, secdata, seclen, secid);
    kfunc_not_found();
    return 0;
}

static inline int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
{
    kfunc_call(security_secid_to_secctx, secid, secdata, seclen);
    kfunc_not_found();
    return 0;
}

static inline void security_release_secctx(char *secdata, u32 seclen)
{
    kfunc_call_void(security_release_secctx, secdata, seclen);
    kfunc_not_found();
}

#endif
```

`kernel/linux/include/linux/slab.h`:

```h
#ifndef _LINUX_SLAB_H
#define _LINUX_SLAB_H

#include <ktypes.h>

// todo

void *__must_check krealloc(const void *, size_t, gfp_t);
void kfree(const void *);
void kfree_sensitive(const void *);
size_t __ksize(const void *);
size_t ksize(const void *);

void *__kmalloc(size_t size, gfp_t flags);
void *kmem_cache_alloc(struct kmem_cache *, gfp_t flags);
void kmem_cache_free(struct kmem_cache *, void *);

void kmem_cache_free_bulk(struct kmem_cache *, size_t, void **);
int kmem_cache_alloc_bulk(struct kmem_cache *, gfp_t, size_t, void **);

#endif
```

`kernel/linux/include/linux/socket.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _LINUX_SOCKET_H
#define _LINUX_SOCKET_H

#include <asm/socket.h> /* arch-dependent defines	*/
#include <linux/sockios.h> /* the SIOCxxx I/O controls	*/
#include <linux/uio.h> /* iovec support		*/
#include <linux/types.h> /* pid_t			*/
#include <linux/compiler.h> /* __user			*/
#include <uapi/linux/socket.h>

struct file;
struct pid;
struct cred;
struct socket;
struct sock;
struct sk_buff;

#define __sockaddr_check_size(size) BUILD_BUG_ON(((size) > sizeof(struct __kernel_sockaddr_storage)))

#ifdef CONFIG_PROC_FS
struct seq_file;
extern void socket_seq_show(struct seq_file *seq);
#endif

typedef __kernel_sa_family_t sa_family_t;

/*
 *	1003.1g requires sa_family_t and that sa_data is char.
 */

struct sockaddr
{
    sa_family_t sa_family; /* address family, AF_xxx	*/
    union
    {
        char sa_data_min[14]; /* Minimum 14 bytes of protocol address	*/
        DECLARE_FLEX_ARRAY(char, sa_data);
    };
};

struct linger
{
    int l_onoff; /* Linger active		*/
    int l_linger; /* How long to linger for	*/
};

#define sockaddr_storage __kernel_sockaddr_storage

/*
 *	As we do 4.4BSD message passing we use a 4.4BSD message passing
 *	system, not 4.3. Thus msg_accrights(len) are now missing. They
 *	belong in an obscure libc emulation or the bin.
 */

struct msghdr
{
    void *msg_name; /* ptr to socket address structure */
    int msg_namelen; /* size of socket address structure */

    int msg_inq; /* output, data left in socket */

    struct iov_iter msg_iter; /* data */

    /*
	 * Ancillary data. msg_control_user is the user buffer used for the
	 * recv* side when msg_control_is_user is set, msg_control is the kernel
	 * buffer used for all other cases.
	 */
    union
    {
        void *msg_control;
        void __user *msg_control_user;
    };
    bool msg_control_is_user : 1;
    bool msg_get_inq : 1; /* return INQ after receive */
    unsigned int msg_flags; /* flags on received message */
    __kernel_size_t msg_controllen; /* ancillary data buffer length */
    struct kiocb *msg_iocb; /* ptr to iocb for async requests */
    struct ubuf_info *msg_ubuf;
    int (*sg_from_iter)(struct sock *sk, struct sk_buff *skb, struct iov_iter *from, size_t length);
};

struct user_msghdr
{
    void __user *msg_name; /* ptr to socket address structure */
    int msg_namelen; /* size of socket address structure */
    struct iovec __user *msg_iov; /* scatter/gather array */
    __kernel_size_t msg_iovlen; /* # elements in msg_iov */
    void __user *msg_control; /* ancillary data */
    __kernel_size_t msg_controllen; /* ancillary data buffer length */
    unsigned int msg_flags; /* flags on received message */
};

/* For recvmmsg/sendmmsg */
struct mmsghdr
{
    struct user_msghdr msg_hdr;
    unsigned int msg_len;
};

/*
 *	POSIX 1003.1g - ancillary data object information
 *	Ancillary data consists of a sequence of pairs of
 *	(cmsghdr, cmsg_data[])
 */

struct cmsghdr
{
    __kernel_size_t cmsg_len; /* data byte count, including hdr */
    int cmsg_level; /* originating protocol */
    int cmsg_type; /* protocol-specific type */
};

/*
 *	Ancillary data object information MACROS
 *	Table 5-14 of POSIX 1003.1g
 */

#define __CMSG_NXTHDR(ctl, len, cmsg) __cmsg_nxthdr((ctl), (len), (cmsg))
#define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg))

#define CMSG_ALIGN(len) (((len) + sizeof(long) - 1) & ~(sizeof(long) - 1))

#define CMSG_DATA(cmsg) ((void *)(cmsg) + sizeof(struct cmsghdr))
#define CMSG_USER_DATA(cmsg) ((void __user *)(cmsg) + sizeof(struct cmsghdr))
#define CMSG_SPACE(len) (sizeof(struct cmsghdr) + CMSG_ALIGN(len))
#define CMSG_LEN(len) (sizeof(struct cmsghdr) + (len))

#define __CMSG_FIRSTHDR(ctl, len) ((len) >= sizeof(struct cmsghdr) ? (struct cmsghdr *)(ctl) : (struct cmsghdr *)NULL)
#define CMSG_FIRSTHDR(msg) __CMSG_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)
#define CMSG_OK(mhdr, cmsg)                        \
    ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) && \
     (cmsg)->cmsg_len <= (unsigned long)((mhdr)->msg_controllen - ((char *)(cmsg) - (char *)(mhdr)->msg_control)))
#define for_each_cmsghdr(cmsg, msg) for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))

/*
 *	Get the next cmsg header
 *
 *	PLEASE, do not touch this function. If you think, that it is
 *	incorrect, grep kernel sources and think about consequences
 *	before trying to improve it.
 *
 *	Now it always returns valid, not truncated ancillary object
 *	HEADER. But caller still MUST check, that cmsg->cmsg_len is
 *	inside range, given by msg->msg_controllen before using
 *	ancillary object DATA.				--ANK (980731)
 */

static inline struct cmsghdr *__cmsg_nxthdr(void *__ctl, __kernel_size_t __size, struct cmsghdr *__cmsg)
{
    struct cmsghdr *__ptr;

    __ptr = (struct cmsghdr *)(((unsigned char *)__cmsg) + CMSG_ALIGN(__cmsg->cmsg_len));
    if ((unsigned long)((char *)(__ptr + 1) - (char *)__ctl) > __size)
        return (struct cmsghdr *)0;

    return __ptr;
}

static inline struct cmsghdr *cmsg_nxthdr(struct msghdr *__msg, struct cmsghdr *__cmsg)
{
    return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
}

static inline size_t msg_data_left(struct msghdr *msg)
{
    return iov_iter_count(&msg->msg_iter);
}

/* "Socket"-level control message types: */

#define SCM_RIGHTS 0x01 /* rw: access rights (array of int) */
#define SCM_CREDENTIALS 0x02 /* rw: struct ucred		*/
#define SCM_SECURITY 0x03 /* rw: security label		*/

struct ucred
{
    __u32 pid;
    __u32 uid;
    __u32 gid;
};

/* Supported address families. */
#define AF_UNSPEC 0
#define AF_UNIX 1 /* Unix domain sockets 		*/
#define AF_LOCAL 1 /* POSIX name for AF_UNIX	*/
#define AF_INET 2 /* Internet IP Protocol 	*/
#define AF_AX25 3 /* Amateur Radio AX.25 		*/
#define AF_IPX 4 /* Novell IPX 			*/
#define AF_APPLETALK 5 /* AppleTalk DDP 		*/
#define AF_NETROM 6 /* Amateur Radio NET/ROM 	*/
#define AF_BRIDGE 7 /* Multiprotocol bridge 	*/
#define AF_ATMPVC 8 /* ATM PVCs			*/
#define AF_X25 9 /* Reserved for X.25 project 	*/
#define AF_INET6 10 /* IP version 6			*/
#define AF_ROSE 11 /* Amateur Radio X.25 PLP	*/
#define AF_DECnet 12 /* Reserved for DECnet project	*/
#define AF_NETBEUI 13 /* Reserved for 802.2LLC project*/
#define AF_SECURITY 14 /* Security callback pseudo AF */
#define AF_KEY 15 /* PF_KEY key management API */
#define AF_NETLINK 16
#define AF_ROUTE AF_NETLINK /* Alias to emulate 4.4BSD */
#define AF_PACKET 17 /* Packet family		*/
#define AF_ASH 18 /* Ash				*/
#define AF_ECONET 19 /* Acorn Econet			*/
#define AF_ATMSVC 20 /* ATM SVCs			*/
#define AF_RDS 21 /* RDS sockets 			*/
#define AF_SNA 22 /* Linux SNA Project (nutters!) */
#define AF_IRDA 23 /* IRDA sockets			*/
#define AF_PPPOX 24 /* PPPoX sockets		*/
#define AF_WANPIPE 25 /* Wanpipe API Sockets */
#define AF_LLC 26 /* Linux LLC			*/
#define AF_IB 27 /* Native InfiniBand address	*/
#define AF_MPLS 28 /* MPLS */
#define AF_CAN 29 /* Controller Area Network      */
#define AF_TIPC 30 /* TIPC sockets			*/
#define AF_BLUETOOTH 31 /* Bluetooth sockets 		*/
#define AF_IUCV 32 /* IUCV sockets			*/
#define AF_RXRPC 33 /* RxRPC sockets 		*/
#define AF_ISDN 34 /* mISDN sockets 		*/
#define AF_PHONET 35 /* Phonet sockets		*/
#define AF_IEEE802154 36 /* IEEE802154 sockets		*/
#define AF_CAIF 37 /* CAIF sockets			*/
#define AF_ALG 38 /* Algorithm sockets		*/
#define AF_NFC 39 /* NFC sockets			*/
#define AF_VSOCK 40 /* vSockets			*/
#define AF_KCM 41 /* Kernel Connection Multiplexor*/
#define AF_QIPCRTR 42 /* Qualcomm IPC Router          */
#define AF_SMC \
    43 /* smc sockets: reserve number for
				 * PF_SMC protocol family that
				 * reuses AF_INET address family
				 */
#define AF_XDP 44 /* XDP sockets			*/
#define AF_MCTP \
    45 /* Management component
				 * transport protocol
				 */

#define AF_MAX 46 /* For now.. */

/* Protocol families, same as address families. */
#define PF_UNSPEC AF_UNSPEC
#define PF_UNIX AF_UNIX
#define PF_LOCAL AF_LOCAL
#define PF_INET AF_INET
#define PF_AX25 AF_AX25
#define PF_IPX AF_IPX
#define PF_APPLETALK AF_APPLETALK
#define PF_NETROM AF_NETROM
#define PF_BRIDGE AF_BRIDGE
#define PF_ATMPVC AF_ATMPVC
#define PF_X25 AF_X25
#define PF_INET6 AF_INET6
#define PF_ROSE AF_ROSE
#define PF_DECnet AF_DECnet
#define PF_NETBEUI AF_NETBEUI
#define PF_SECURITY AF_SECURITY
#define PF_KEY AF_KEY
#define PF_NETLINK AF_NETLINK
#define PF_ROUTE AF_ROUTE
#define PF_PACKET AF_PACKET
#define PF_ASH AF_ASH
#define PF_ECONET AF_ECONET
#define PF_ATMSVC AF_ATMSVC
#define PF_RDS AF_RDS
#define PF_SNA AF_SNA
#define PF_IRDA AF_IRDA
#define PF_PPPOX AF_PPPOX
#define PF_WANPIPE AF_WANPIPE
#define PF_LLC AF_LLC
#define PF_IB AF_IB
#define PF_MPLS AF_MPLS
#define PF_CAN AF_CAN
#define PF_TIPC AF_TIPC
#define PF_BLUETOOTH AF_BLUETOOTH
#define PF_IUCV AF_IUCV
#define PF_RXRPC AF_RXRPC
#define PF_ISDN AF_ISDN
#define PF_PHONET AF_PHONET
#define PF_IEEE802154 AF_IEEE802154
#define PF_CAIF AF_CAIF
#define PF_ALG AF_ALG
#define PF_NFC AF_NFC
#define PF_VSOCK AF_VSOCK
#define PF_KCM AF_KCM
#define PF_QIPCRTR AF_QIPCRTR
#define PF_SMC AF_SMC
#define PF_XDP AF_XDP
#define PF_MCTP AF_MCTP
#define PF_MAX AF_MAX

/* Maximum queue length specifiable by listen.  */
#define SOMAXCONN 4096

/* Flags we can use with send/ and recv.
   Added those for 1003.1g not all are supported yet
 */

#define MSG_OOB 1
#define MSG_PEEK 2
#define MSG_DONTROUTE 4
#define MSG_TRYHARD 4 /* Synonym for MSG_DONTROUTE for DECnet */
#define MSG_CTRUNC 8
#define MSG_PROBE 0x10 /* Do not send. Only probe path f.e. for MTU */
#define MSG_TRUNC 0x20
#define MSG_DONTWAIT 0x40 /* Nonblocking io		 */
#define MSG_EOR 0x80 /* End of record */
#define MSG_WAITALL 0x100 /* Wait for a full request */
#define MSG_FIN 0x200
#define MSG_SYN 0x400
#define MSG_CONFIRM 0x800 /* Confirm path validity */
#define MSG_RST 0x1000
#define MSG_ERRQUEUE 0x2000 /* Fetch message from error queue */
#define MSG_NOSIGNAL 0x4000 /* Do not generate SIGPIPE */
#define MSG_MORE 0x8000 /* Sender will send more */
#define MSG_WAITFORONE 0x10000 /* recvmmsg(): block until 1+ packets avail */
#define MSG_SENDPAGE_NOPOLICY 0x10000 /* sendpage() internal : do no apply policy */
#define MSG_SENDPAGE_NOTLAST 0x20000 /* sendpage() internal : not the last page */
#define MSG_BATCH 0x40000 /* sendmmsg(): more messages coming */
#define MSG_EOF MSG_FIN
#define MSG_NO_SHARED_FRAGS 0x80000 /* sendpage() internal : page frags are not shared */
#define MSG_SENDPAGE_DECRYPTED \
    0x100000 /* sendpage() internal : page may carry
					  * plain text and require encryption
					  */

#define MSG_ZEROCOPY 0x4000000 /* Use user data in kernel path */
#define MSG_FASTOPEN 0x20000000 /* Send data in TCP SYN */
#define MSG_CMSG_CLOEXEC \
    0x40000000 /* Set close_on_exec for file
					   descriptor received through
					   SCM_RIGHTS */
#if defined(CONFIG_COMPAT)
#define MSG_CMSG_COMPAT 0x80000000 /* This message needs 32 bit fixups */
#else
#define MSG_CMSG_COMPAT 0 /* We never have 32 bit fixups */
#endif

/* Setsockoptions(2) level. Thanks to BSD these must match IPPROTO_xxx */
#define SOL_IP 0
/* #define SOL_ICMP	1	No-no-no! Due to Linux :-) we cannot use SOL_ICMP=1 */
#define SOL_TCP 6
#define SOL_UDP 17
#define SOL_IPV6 41
#define SOL_ICMPV6 58
#define SOL_SCTP 132
#define SOL_UDPLITE 136 /* UDP-Lite (RFC 3828) */
#define SOL_RAW 255
#define SOL_IPX 256
#define SOL_AX25 257
#define SOL_ATALK 258
#define SOL_NETROM 259
#define SOL_ROSE 260
#define SOL_DECNET 261
#define SOL_X25 262
#define SOL_PACKET 263
#define SOL_ATM 264 /* ATM layer (cell level) */
#define SOL_AAL 265 /* ATM Adaption Layer (packet level) */
#define SOL_IRDA 266
#define SOL_NETBEUI 267
#define SOL_LLC 268
#define SOL_DCCP 269
#define SOL_NETLINK 270
#define SOL_TIPC 271
#define SOL_RXRPC 272
#define SOL_PPPOL2TP 273
#define SOL_BLUETOOTH 274
#define SOL_PNPIPE 275
#define SOL_RDS 276
#define SOL_IUCV 277
#define SOL_CAIF 278
#define SOL_ALG 279
#define SOL_NFC 280
#define SOL_KCM 281
#define SOL_TLS 282
#define SOL_XDP 283
#define SOL_MPTCP 284
#define SOL_MCTP 285
#define SOL_SMC 286

/* IPX options */
#define IPX_TYPE 1

extern int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr);
extern int put_cmsg(struct msghdr *, int level, int type, int len, void *data);

struct timespec64;
struct __kernel_timespec;
struct old_timespec32;

struct scm_timestamping_internal
{
    struct timespec64 ts[3];
};

extern void put_cmsg_scm_timestamping64(struct msghdr *msg, struct scm_timestamping_internal *tss);
extern void put_cmsg_scm_timestamping(struct msghdr *msg, struct scm_timestamping_internal *tss);

/* The __sys_...msg variants allow MSG_CMSG_COMPAT iff
 * forbid_cmsg_compat==false
 */
extern long __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags, bool forbid_cmsg_compat);
extern long __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags, bool forbid_cmsg_compat);
extern int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags,
                          struct __kernel_timespec __user *timeout, struct old_timespec32 __user *timeout32);
extern int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags,
                          bool forbid_cmsg_compat);
extern long __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg, unsigned int flags);
extern long __sys_recvmsg_sock(struct socket *sock, struct msghdr *msg, struct user_msghdr __user *umsg,
                               struct sockaddr __user *uaddr, unsigned int flags);
extern int sendmsg_copy_msghdr(struct msghdr *msg, struct user_msghdr __user *umsg, unsigned flags, struct iovec **iov);
extern int recvmsg_copy_msghdr(struct msghdr *msg, struct user_msghdr __user *umsg, unsigned flags,
                               struct sockaddr __user **uaddr, struct iovec **iov);
extern int __copy_msghdr(struct msghdr *kmsg, struct user_msghdr *umsg, struct sockaddr __user **save_addr);

/* helpers which do the actual work for syscalls */
extern int __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags, struct sockaddr __user *addr,
                          int __user *addr_len);
extern int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags, struct sockaddr __user *addr,
                        int addr_len);
extern struct file *do_accept(struct file *file, unsigned file_flags, struct sockaddr __user *upeer_sockaddr,
                              int __user *upeer_addrlen, int flags);
extern int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags);
extern int __sys_socket(int family, int type, int protocol);
extern struct file *__sys_socket_file(int family, int type, int protocol);
extern int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);
extern int __sys_connect_file(struct file *file, struct sockaddr_storage *addr, int addrlen, int file_flags);
extern int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen);
extern int __sys_listen(int fd, int backlog);
extern int __sys_getsockname(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
extern int __sys_getpeername(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
extern int __sys_socketpair(int family, int type, int protocol, int __user *usockvec);
extern int __sys_shutdown_sock(struct socket *sock, int how);
extern int __sys_shutdown(int fd, int how);
#endif /* _LINUX_SOCKET_H */
```

`kernel/linux/include/linux/spinlock.h`:

```h
#ifndef __LINUX_SPINLOCK_H
#define __LINUX_SPINLOCK_H
#define __LINUX_INSIDE_SPINLOCK_H

#include <ktypes.h>
#include <compiler.h>
#include <stdint.h>
#include <ksyms.h>
#include <linux/rwlock.h>

// todo: arch, enough size
typedef struct
{
#ifdef __AARCH64EB__
    u16 next;
    u16 owner;
#else
    u16 owner;
    u16 next;
#endif
} __aligned(4) arch_spinlock_t;

typedef struct raw_spinlock
{
    arch_spinlock_t raw_lock;
} raw_spinlock_t;

typedef struct spinlock
{
    union
    {
        struct raw_spinlock rlock;
    };
} spinlock_t;

#define __RAW_SPIN_LOCK_INITIALIZER()

#define __SPIN_LOCK_UNLOCKED()           \
    (spinlock_t)                         \
    {                                    \
        .rlock = {.raw_lock = { 0, 0 } } \
    }

#define DEFINE_SPINLOCK(x) spinlock_t x = __SPIN_LOCK_UNLOCKED()

#define spin_lock_init(_lockp)             \
    do {                                   \
        *(_lockp) = __SPIN_LOCK_UNLOCKED() \
    } while (0);

extern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
#define atomic_dec_and_lock(atomic, lock) __cond_lock(lock, _atomic_dec_and_lock(atomic, lock))

extern int kfunc_def(_raw_spin_trylock)(raw_spinlock_t *lock);
extern int kfunc_def(_raw_spin_trylock_bh)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_lock)(raw_spinlock_t *lock);
extern unsigned long kfunc_def(_raw_spin_lock_irqsave)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_lock_irq)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_lock_bh)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_unlock)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_unlock_irqrestore)(raw_spinlock_t *lock, unsigned long flags);
extern void kfunc_def(_raw_spin_unlock_irq)(raw_spinlock_t *lock);
extern void kfunc_def(_raw_spin_unlock_bh)(raw_spinlock_t *lock);
extern int kfunc_def(_raw_read_trylock)(rwlock_t *lock);
extern void kfunc_def(_raw_read_lock)(rwlock_t *lock);
extern unsigned long kfunc_def(_raw_read_lock_irqsave)(rwlock_t *lock);
extern void kfunc_def(_raw_read_lock_irq)(rwlock_t *lock);
extern void kfunc_def(_raw_read_lock_bh)(rwlock_t *lock);
extern void kfunc_def(_raw_read_unlock)(rwlock_t *lock);
extern void kfunc_def(_raw_read_unlock_irqrestore)(rwlock_t *lock, unsigned long flags);
extern void kfunc_def(_raw_read_unlock_irq)(rwlock_t *lock);
extern void kfunc_def(_raw_read_unlock_bh)(rwlock_t *lock);
extern int kfunc_def(_raw_write_trylock)(rwlock_t *lock);
extern void kfunc_def(_raw_write_lock)(rwlock_t *lock);
extern unsigned long kfunc_def(_raw_write_lock_irqsave)(rwlock_t *lock);
extern void kfunc_def(_raw_write_lock_irq)(rwlock_t *lock);
extern void kfunc_def(_raw_write_lock_bh)(rwlock_t *lock);
extern void kfunc_def(_raw_write_unlock)(rwlock_t *lock);
extern void kfunc_def(_raw_write_unlock_irqrestore)(rwlock_t *lock, unsigned long flags);
extern void kfunc_def(_raw_write_unlock_irq)(rwlock_t *lock);
extern void kfunc_def(_raw_write_unlock_bh)(rwlock_t *lock);

static inline int raw_spin_trylock(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_trylock, lock);
    kfunc_not_found();
    return 0;
}
static inline int spin_trylock(spinlock_t *lock)
{
    return raw_spin_trylock(&lock->rlock);
}

static inline int raw_spin_trylock_bh(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_trylock_bh, lock);
    kfunc_not_found();
    return 0;
}
static inline int spin_trylock_bh(spinlock_t *lock)
{
    return raw_spin_trylock_bh(&lock->rlock);
}

static inline void raw_spin_lock(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_lock, lock);
    kfunc_not_found();
}
static inline void spin_lock(spinlock_t *lock)
{
    return raw_spin_lock(&lock->rlock);
}

static inline unsigned long raw_spin_lock_irqsave(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_lock_irqsave, lock);
    kfunc_not_found();
    return 0;
}
static inline unsigned long spin_lock_irqsave(spinlock_t *lock)
{
    return raw_spin_lock_irqsave(&lock->rlock);
}

static inline void raw_spin_lock_irq(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_lock_irq, lock);
    kfunc_not_found();
}
static inline void spin_lock_irq(spinlock_t *lock)
{
    raw_spin_lock_irq(&lock->rlock);
}
static inline void raw_spin_lock_bh(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_lock_bh, lock);
    kfunc_not_found();
}
static inline void spin_lock_bh(spinlock_t *lock)
{
    raw_spin_lock_bh(&lock->rlock);
}
static inline void raw_spin_unlock(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_unlock, lock);
    kfunc_not_found();
}
static inline void spin_unlock(spinlock_t *lock)
{
    raw_spin_unlock(&lock->rlock);
}
static inline void raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)
{
    kfunc_call(_raw_spin_unlock_irqrestore, lock, flags);
    kfunc_not_found();
}
static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
    raw_spin_unlock_irqrestore(&lock->rlock, flags);
}
static inline void raw_spin_unlock_irq(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_unlock_irq, lock);
    kfunc_not_found();
}
static inline void spin_unlock_irq(spinlock_t *lock)
{
    raw_spin_unlock_irq(&lock->rlock);
}

static inline void raw_spin_unlock_bh(raw_spinlock_t *lock)
{
    kfunc_call(_raw_spin_unlock_bh, lock);
    kfunc_not_found();
}

static inline void spin_unlock_bh(spinlock_t *lock)
{
    raw_spin_unlock_bh(&lock->rlock);
}

static inline int raw_read_trylock(rwlock_t *lock)
{
    kfunc_call(_raw_read_trylock, lock);
    kfunc_not_found();
    return 0;
}

static inline void raw_read_lock(rwlock_t *lock)
{
    kfunc_call(_raw_read_lock, lock);
    kfunc_not_found();
}
static inline unsigned long raw_read_lock_irqsave(rwlock_t *lock)
{
    kfunc_call(_raw_read_lock_irqsave, lock);
    kfunc_not_found();
    return 0;
}
static inline void raw_read_lock_irq(rwlock_t *lock)
{
    kfunc_call(_raw_read_lock_irq, lock);
    kfunc_not_found();
}
static inline void raw_read_lock_bh(rwlock_t *lock)
{
    kfunc_call(_raw_read_lock_bh, lock);
    kfunc_not_found();
}
static inline void raw_read_unlock(rwlock_t *lock)
{
    kfunc_call(_raw_read_unlock, lock);
    kfunc_not_found();
}
static inline void raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
{
    kfunc_call(_raw_read_unlock_irqrestore, lock, flags);
    kfunc_not_found();
}
static inline void raw_read_unlock_irq(rwlock_t *lock)
{
    kfunc_call(_raw_read_unlock_irq, lock);
    kfunc_not_found();
}
static inline void raw_read_unlock_bh(rwlock_t *lock)
{
    kfunc_call(_raw_read_unlock_bh, lock);
    kfunc_not_found();
}
static inline int raw_write_trylock(rwlock_t *lock)
{
    kfunc_call(_raw_write_trylock, lock);
    kfunc_not_found();
    return 0;
}
static inline void raw_write_lock(rwlock_t *lock)
{
    kfunc_call(_raw_write_lock, lock);
    kfunc_not_found();
}
static inline unsigned long raw_write_lock_irqsave(rwlock_t *lock)
{
    kfunc_call(_raw_write_lock_irqsave, lock);
    kfunc_not_found();
    return 0;
}
static inline void raw_write_lock_irq(rwlock_t *lock)
{
    kfunc_call(_raw_write_lock_irq, lock);
    kfunc_not_found();
}
static inline void raw_write_lock_bh(rwlock_t *lock)
{
    kfunc_call(_raw_write_lock_bh, lock);
    kfunc_not_found();
}
static inline void raw_write_unlock(rwlock_t *lock)
{
    kfunc_call(_raw_write_unlock, lock);
    kfunc_not_found();
}
static inline void raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
{
    kfunc_call(_raw_write_unlock_irqrestore, lock, flags);
    kfunc_not_found();
}
static inline void raw_write_unlock_irq(rwlock_t *lock)
{
    kfunc_call(_raw_write_unlock_irq, lock);
    kfunc_not_found();
}
static inline void raw_write_unlock_bh(rwlock_t *lock)
{
    kfunc_call(_raw_write_unlock_bh, lock);
    kfunc_not_found();
}

#endif
```

`kernel/linux/include/linux/stop_machine.h`:

```h
#ifndef _LINUX_STOP_MACHINE
#define _LINUX_STOP_MACHINE

#include <ktypes.h>
#include <ksyms.h>

typedef int (*cpu_stop_fn_t)(void *arg);

struct cpumask;

extern int kfunc_def(stop_machine)(int (*fn)(void *), void *data, const struct cpumask *cpus);

#endif
```

`kernel/linux/include/linux/string.h`:

```h
#ifndef _LINUX_STRING_H_
#define _LINUX_STRING_H_

#include <ktypes.h>
#include <ksyms.h>

extern void kfunc_def(kfree_const)(const void *x);
extern char *kfunc_def(kstrdup)(const char *s, gfp_t gfp);
extern const char *kfunc_def(kstrdup_const)(const char *s, gfp_t gfp);
extern char *kfunc_def(kstrndup)(const char *s, size_t len, gfp_t gfp);
extern void *kfunc_def(kmemdup)(const void *src, size_t len, gfp_t gfp);
extern char *kfunc_def(kmemdup_nul)(const char *s, size_t len, gfp_t gfp);
extern char **kfunc_def(argv_split)(gfp_t gfp, const char *str, int *argcp);
extern void kfunc_def(argv_free)(char **argv);
extern int kfunc_def(kstrtobool)(const char *s, bool *res);

extern int kfunc_def(strncasecmp)(const char *s1, const char *s2, size_t len);
extern int kfunc_def(strcasecmp)(const char *s1, const char *s2);
extern char *kfunc_def(strcpy)(char *dest, const char *src);
extern char *kfunc_def(strncpy)(char *dest, const char *src, size_t count);
extern size_t kfunc_def(strlcpy)(char *dest, const char *src, size_t size);
extern ssize_t kfunc_def(strscpy)(char *dest, const char *src, size_t count);
extern ssize_t kfunc_def(strscpy_pad)(char *dest, const char *src, size_t count);
extern char *kfunc_def(stpcpy)(char *__restrict__ dest, const char *__restrict__ src);
extern char *kfunc_def(strcat)(char *dest, const char *src);
extern char *kfunc_def(strncat)(char *dest, const char *src, size_t count);
extern size_t kfunc_def(strlcat)(char *dest, const char *src, size_t count);
extern int kfunc_def(strcmp)(const char *cs, const char *ct);
extern int kfunc_def(strncmp)(const char *cs, const char *ct, size_t count);
extern char *kfunc_def(strchr)(const char *s, int c);
extern char *kfunc_def(strchrnul)(const char *s, int c);
extern char *kfunc_def(strnchrnul)(const char *s, size_t count, int c);
extern char *kfunc_def(strrchr)(const char *s, int c);
extern char *kfunc_def(strnchr)(const char *s, size_t count, int c);
extern char *kfunc_def(skip_spaces)(const char *str);
extern char *kfunc_def(strim)(char *s);
extern size_t kfunc_def(strlen)(const char *s);
extern size_t kfunc_def(strnlen)(const char *s, size_t count);
extern size_t kfunc_def(strspn)(const char *s, const char *accept);
extern size_t kfunc_def(strcspn)(const char *s, const char *reject);
extern char *kfunc_def(strpbrk)(const char *cs, const char *ct);
extern char *kfunc_def(strsep)(char **s, const char *ct);
extern bool kfunc_def(sysfs_streq)(const char *s1, const char *s2);
extern int kfunc_def(match_string)(const char *const *array, size_t n, const char *string);
extern int kfunc_def(__sysfs_match_string)(const char *const *array, size_t n, const char *str);
extern void *kfunc_def(memset)(void *s, int c, size_t count);
extern void *kfunc_def(memset16)(uint16_t *s, uint16_t v, size_t count);
extern void *kfunc_def(memset32)(uint32_t *s, uint32_t v, size_t count);
extern void *kfunc_def(memset64)(uint64_t *s, uint64_t v, size_t count);
extern void *kfunc_def(memcpy)(void *dest, const void *src, size_t count);
extern void *kfunc_def(memmove)(void *dest, const void *src, size_t count);
extern int kfunc_def(memcmp)(const void *cs, const void *ct, size_t count);
extern int kfunc_def(bcmp)(const void *a, const void *b, size_t len);
extern void *kfunc_def(memscan)(void *addr, int c, size_t size);
extern char *kfunc_def(strstr)(const char *s1, const char *s2);
extern char *kfunc_def(strnstr)(const char *s1, const char *s2, size_t len);
extern void *kfunc_def(memchr)(const void *s, int c, size_t n);
extern void *kfunc_def(memchr_inv)(const void *start, int c, size_t bytes);
extern char *kfunc_def(strreplace)(char *s, char old, char new);
extern void kfunc_def(fortify_panic)(const char *name);

inline void kfree_const(const void *x)
{
    kfunc_call(kfree_const, x);
    kfunc_not_found();
    ;
}
inline char *kstrdup(const char *s, gfp_t gfp)
{
    kfunc_call(kstrdup, s, gfp);
    kfunc_not_found();
    return 0;
    ;
}
inline const char *kstrdup_const(const char *s, gfp_t gfp)
{
    kfunc_call(kstrdup_const, s, gfp);
    kfunc_not_found();
    return 0;
    ;
}
inline char *kstrndup(const char *s, size_t len, gfp_t gfp)
{
    kfunc_call(kstrndup, s, len, gfp);
    kfunc_not_found();
    return 0;
    ;
}
inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
{
    kfunc_call(kmemdup, src, len, gfp);
    kfunc_not_found();
    return 0;
    ;
}
inline char *kmemdup_nul(const char *s, size_t len, gfp_t gfp)
{
    kfunc_call(kmemdup_nul, s, len, gfp);
    kfunc_not_found();
    return 0;
    ;
}
inline char **argv_split(gfp_t gfp, const char *str, int *argcp)
{
    kfunc_call(argv_split, gfp, str, argcp);
    kfunc_not_found();
    return 0;
    ;
}
inline void argv_free(char **argv)
{
    kfunc_call(argv_free, argv);
    kfunc_not_found();
    ;
}
inline int kstrtobool(const char *s, bool *res)
{
    kfunc_call(kstrtobool, s, res);
    kfunc_not_found();
    return 0;
    ;
}
inline int strncasecmp(const char *s1, const char *s2, size_t len)
{
    kfunc_call(strncasecmp, s1, s2, len);
    kfunc_not_found();
    return 0;
    ;
}
inline int strcasecmp(const char *s1, const char *s2)
{
    kfunc_call(strcasecmp, s1, s2);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strcpy(char *dest, const char *src)
{
    kfunc_call(strcpy, dest, src);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strncpy(char *dest, const char *src, size_t count)
{
    kfunc_call(strncpy, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strlcpy(char *dest, const char *src, size_t size)
{
    kfunc_call(strlcpy, dest, src, size);
    kfunc_not_found();
    return 0;
    ;
}
inline ssize_t strscpy(char *dest, const char *src, size_t count)
{
    kfunc_call(strscpy, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline ssize_t strscpy_pad(char *dest, const char *src, size_t count)
{
    kfunc_call(strscpy_pad, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline char *stpcpy(char *__restrict__ dest, const char *__restrict__ src)
{
    kfunc_call(stpcpy, dest, src);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strcat(char *dest, const char *src)
{
    kfunc_call(strcat, dest, src);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strncat(char *dest, const char *src, size_t count)
{
    kfunc_call(strncat, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strlcat(char *dest, const char *src, size_t count)
{
    kfunc_call(strlcat, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline int strcmp(const char *cs, const char *ct)
{
    kfunc_call(strcmp, cs, ct);
    kfunc_not_found();
    return 0;
    ;
}
inline int strncmp(const char *cs, const char *ct, size_t count)
{
    kfunc_call(strncmp, cs, ct, count);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strchr(const char *s, int c)
{
    kfunc_call(strchr, s, c);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strchrnul(const char *s, int c)
{
    kfunc_call(strchrnul, s, c);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strnchrnul(const char *s, size_t count, int c)
{
    kfunc_call(strnchrnul, s, count, c);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strrchr(const char *s, int c)
{
    kfunc_call(strrchr, s, c);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strnchr(const char *s, size_t count, int c)
{
    kfunc_call(strnchr, s, count, c);
    kfunc_not_found();
    return 0;
    ;
}
inline char *skip_spaces(const char *str)
{
    kfunc_call(skip_spaces, str);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strim(char *s)
{
    kfunc_call(strim, s);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strlen(const char *s)
{
    kfunc_call(strlen, s);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strnlen(const char *s, size_t count)
{
    kfunc_call(strnlen, s, count);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strspn(const char *s, const char *accept)
{
    kfunc_call(strspn, s, accept);
    kfunc_not_found();
    return 0;
    ;
}
inline size_t strcspn(const char *s, const char *reject)
{
    kfunc_call(strcspn, s, reject);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strpbrk(const char *cs, const char *ct)
{
    kfunc_call(strpbrk, cs, ct);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strsep(char **s, const char *ct)
{
    kfunc_call(strsep, s, ct);
    kfunc_not_found();
    return 0;
    ;
}
inline bool sysfs_streq(const char *s1, const char *s2)
{
    kfunc_call(sysfs_streq, s1, s2);
    kfunc_not_found();
    return 0;
    ;
}
inline int match_string(const char *const *array, size_t n, const char *string)
{
    kfunc_call(match_string, array, n, string);
    kfunc_not_found();
    return 0;
    ;
}
inline int __sysfs_match_string(const char *const *array, size_t n, const char *str)
{
    kfunc_call(__sysfs_match_string, array, n, str);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memset(void *s, int c, size_t count)
{
    kfunc_call(memset, s, c, count);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memset16(uint16_t *s, uint16_t v, size_t count)
{
    kfunc_call(memset16, s, v, count);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memset32(uint32_t *s, uint32_t v, size_t count)
{
    kfunc_call(memset32, s, v, count);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memset64(uint64_t *s, uint64_t v, size_t count)
{
    kfunc_call(memset64, s, v, count);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memcpy(void *dest, const void *src, size_t count)
{
    kfunc_call(memcpy, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memmove(void *dest, const void *src, size_t count)
{
    kfunc_call(memmove, dest, src, count);
    kfunc_not_found();
    return 0;
    ;
}
inline int memcmp(const void *cs, const void *ct, size_t count)
{
    kfunc_call(memcmp, cs, ct, count);
    kfunc_not_found();
    return 0;
    ;
}
inline int bcmp(const void *a, const void *b, size_t len)
{
    kfunc_call(bcmp, a, b, len);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memscan(void *addr, int c, size_t size)
{
    kfunc_call(memscan, addr, c, size);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strstr(const char *s1, const char *s2)
{
    kfunc_call(strstr, s1, s2);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strnstr(const char *s1, const char *s2, size_t len)
{
    kfunc_call(strnstr, s1, s2, len);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memchr(const void *s, int c, size_t n)
{
    kfunc_call(memchr, s, c, n);
    kfunc_not_found();
    return 0;
    ;
}
inline void *memchr_inv(const void *start, int c, size_t bytes)
{
    kfunc_call(memchr_inv, start, c, bytes);
    kfunc_not_found();
    return 0;
    ;
}
inline char *strreplace(char *s, char old, char new)
{
    kfunc_call(strreplace, s, old, new);
    kfunc_not_found();
    return 0;
    ;
}
inline void fortify_panic(const char *name)
{
    kfunc_call(fortify_panic, name);
    kfunc_not_found();
    ;
}

#endif
```

`kernel/linux/include/linux/syscall.h`:

```h
#ifndef _LINUX_SYSCALLS_H
#define _LINUX_SYSCALLS_H

// todo: remove typedef struct

#include <ktypes.h>

typedef struct aio_context_t aio_context_t;
struct iocb;
struct io_event;
struct __kernel_timespec;
struct __aio_sigset;
struct io_uring_params;
struct old_timespec32;
struct epoll_event;
typedef struct sigset_t sigset_t;
struct statfs;
struct statfs64;
struct open_how;
typedef struct qid_t qid_t;
struct linux_dirent64;
struct iovec;
struct pollfd;
struct stat;
struct stat64;
struct __kernel_itimerspec;
struct old_itimerspec32;
typedef struct cap_user_header_t cap_user_header_t;
typedef struct cap_user_data_t cap_user_data_t;
struct siginfo;
struct rusage;
struct robust_list_head;
struct futex_waitv;
struct __kernel_old_itimerval;
struct kexec_segment;
typedef struct clockid_t clockid_t;
struct sigevent;
struct sched_param;
struct sigaltstack;
struct sigaction;
typedef struct siginfo_t siginfo_t;
struct tms;
struct new_utsname;
struct rlimit;
struct getcpu_cache;
struct __kernel_old_timeval;
struct timezone;
struct __kernel_timex;
struct old_timex32;
struct sysinfo;
typedef struct umode_t umode_t;
struct mq_attr;
struct msqid_ds;
struct msgbuf;
struct sembuf;
struct shmid_ds;
struct sockaddr;
struct user_msghdr;
typedef struct key_serial_t key_serial_t;
struct clone_args;
struct perf_event_attr;
struct mmsghdr;
struct rlimit64;
struct file_handle;
struct sched_attr;
union bpf_attr;
typedef struct rwf_t rwf_t;
struct statx;
struct rseq;
struct mount_attr;
struct landlock_ruleset_attr;
enum landlock_rule_type;
typedef struct __kernel_old_time_t __kernel_old_time_t;
typedef struct old_time32_t old_time32_t;
struct utimbuf;
struct old_utimbuf32;
struct old_timeval32;
struct linux_dirent;
struct old_sigaction;
typedef struct old_sigset_t old_sigset_t;
typedef struct __sighandler_t __sighandler_t;
typedef struct old_uid_t old_uid_t;
typedef struct old_gid_t old_gid_t;
struct __old_kernel_stat;
struct sel_arg_struct;
struct old_linux_dirent;
struct old_utsname;
struct oldold_utsname;
struct mmap_arg_struct;
struct sembuf;
struct timespec64;
struct ipc_namespace;

asmlinkage long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);
asmlinkage long sys_io_destroy(aio_context_t ctx);
asmlinkage long sys_io_submit(aio_context_t, long, struct iocb __user *__user *);
asmlinkage long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);
asmlinkage long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events,
                                 struct __kernel_timespec __user *timeout);
asmlinkage long sys_io_getevents_time32(u32 ctx_id, s32 min_nr, s32 nr, struct io_event __user *events,
                                        struct old_timespec32 __user *timeout);
asmlinkage long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events,
                                  struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events,
                                         struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);
asmlinkage long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const void __user *argp,
                                   size_t argsz);
asmlinkage long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);

/* fs/xattr.c */
asmlinkage long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size,
                             int flags);
asmlinkage long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size,
                              int flags);
asmlinkage long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_listxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_llistxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_flistxattr(int fd, char __user *list, size_t size);
asmlinkage long sys_removexattr(const char __user *path, const char __user *name);
asmlinkage long sys_lremovexattr(const char __user *path, const char __user *name);
asmlinkage long sys_fremovexattr(int fd, const char __user *name);

/* fs/dcache.c */
asmlinkage long sys_getcwd(char __user *buf, unsigned long size);

/* fs/cookies.c */
asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);

/* fs/eventfd.c */
asmlinkage long sys_eventfd2(unsigned int count, int flags);

/* fs/eventpoll.c */
asmlinkage long sys_epoll_create1(int flags);
asmlinkage long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);
asmlinkage long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout,
                                const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_epoll_pwait2(int epfd, struct epoll_event __user *events, int maxevents,
                                 const struct __kernel_timespec __user *timeout, const sigset_t __user *sigmask,
                                 size_t sigsetsize);

/* fs/fcntl.c */
asmlinkage long sys_dup(unsigned int fildes);
asmlinkage long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);
asmlinkage long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);

/* fs/inotify_user.c */
asmlinkage long sys_inotify_init1(int flags);
asmlinkage long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);
asmlinkage long sys_inotify_rm_watch(int fd, s32 wd);

/* fs/ioctl.c */
asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);

/* fs/ioprio.c */
asmlinkage long sys_ioprio_set(int which, int who, int ioprio);
asmlinkage long sys_ioprio_get(int which, int who);

/* fs/locks.c */
asmlinkage long sys_flock(unsigned int fd, unsigned int cmd);

/* fs/namei.c */
asmlinkage long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);
asmlinkage long sys_unlinkat(int dfd, const char __user *pathname, int flag);
asmlinkage long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);
asmlinkage long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);
asmlinkage long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);

/* fs/namespace.c */
asmlinkage long sys_umount(char __user *name, int flags);
asmlinkage long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags,
                          void __user *data);
asmlinkage long sys_pivot_root(const char __user *new_root, const char __user *put_old);

/* fs/nfsctl.c */

/* fs/open.c */
asmlinkage long sys_statfs(const char __user *path, struct statfs __user *buf);
asmlinkage long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_fstatfs(unsigned int fd, struct statfs __user *buf);
asmlinkage long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_truncate(const char __user *path, long length);
asmlinkage long sys_ftruncate(unsigned int fd, unsigned long length);
#if BITS_PER_LONG == 32
asmlinkage long sys_truncate64(const char __user *path, loff_t length);
asmlinkage long sys_ftruncate64(unsigned int fd, loff_t length);
#endif
asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
asmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);
asmlinkage long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);
asmlinkage long sys_chdir(const char __user *filename);
asmlinkage long sys_fchdir(unsigned int fd);
asmlinkage long sys_chroot(const char __user *filename);
asmlinkage long sys_fchmod(unsigned int fd, umode_t mode);
asmlinkage long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);
asmlinkage long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);
asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);
asmlinkage long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);
asmlinkage long sys_close(unsigned int fd);
asmlinkage long sys_close_range(unsigned int fd, unsigned int max_fd, unsigned int flags);
asmlinkage long sys_vhangup(void);

/* fs/pipe.c */
asmlinkage long sys_pipe2(int __user *fildes, int flags);

/* fs/quota.c */
asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);
asmlinkage long sys_quotactl_fd(unsigned int fd, unsigned int cmd, qid_t id, void __user *addr);

/* fs/readdir.c */
asmlinkage long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);

/* fs/read_write.c */
asmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result,
                           unsigned int whence);
asmlinkage long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);
asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);
asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
asmlinkage long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l,
                           unsigned long pos_h);
asmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l,
                            unsigned long pos_h);

/* fs/sendfile.c */
asmlinkage long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);

/* fs/select.c */
asmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *,
                             void __user *);
asmlinkage long sys_pselect6_time32(int, fd_set __user *, fd_set __user *, fd_set __user *,
                                    struct old_timespec32 __user *, void __user *);
asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *,
                          const sigset_t __user *, size_t);
asmlinkage long sys_ppoll_time32(struct pollfd __user *, unsigned int, struct old_timespec32 __user *,
                                 const sigset_t __user *, size_t);

/* fs/signalfd.c */
asmlinkage long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);

/* fs/splice.c */
asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);
asmlinkage long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len,
                           unsigned int flags);
asmlinkage long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);

/* fs/stat.c */
asmlinkage long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);
asmlinkage long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);
asmlinkage long sys_newfstat(unsigned int fd, struct stat __user *statbuf);
asmlinkage long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);
asmlinkage long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);

/* fs/sync.c */
asmlinkage long sys_sync(void);
asmlinkage long sys_fsync(unsigned int fd);
asmlinkage long sys_fdatasync(unsigned int fd);
asmlinkage long sys_sync_file_range2(int fd, unsigned int flags, loff_t offset, loff_t nbytes);
asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);

/* fs/timerfd.c */
asmlinkage long sys_timerfd_create(int clockid, int flags);
asmlinkage long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr,
                                    struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);
asmlinkage long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr,
                                      struct old_itimerspec32 __user *otmr);

/* fs/utimes.c */
asmlinkage long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);
asmlinkage long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t,
                                     int flags);

/* kernel/acct.c */
asmlinkage long sys_acct(const char __user *name);

/* kernel/capability.c */
asmlinkage long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);
asmlinkage long sys_capset(cap_user_header_t header, const cap_user_data_t data);

/* kernel/exec_domain.c */
asmlinkage long sys_personality(unsigned int personality);

/* kernel/exit.c */
asmlinkage long sys_exit(int error_code);
asmlinkage long sys_exit_group(int error_code);
asmlinkage long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);

/* kernel/fork.c */
asmlinkage long sys_set_tid_address(int __user *tidptr);
asmlinkage long sys_unshare(unsigned long unshare_flags);

/* kernel/futex/syscalls.c */
asmlinkage long sys_futex(u32 __user *uaddr, int op, u32 val, const struct __kernel_timespec __user *utime,
                          u32 __user *uaddr2, u32 val3);
asmlinkage long sys_futex_time32(u32 __user *uaddr, int op, u32 val, const struct old_timespec32 __user *utime,
                                 u32 __user *uaddr2, u32 val3);
asmlinkage long sys_get_robust_list(int pid, struct robust_list_head __user *__user *head_ptr, size_t __user *len_ptr);
asmlinkage long sys_set_robust_list(struct robust_list_head __user *head, size_t len);

asmlinkage long sys_futex_waitv(struct futex_waitv *waiters, unsigned int nr_futexes, unsigned int flags,
                                struct __kernel_timespec __user *timeout, clockid_t clockid);

/* kernel/hrtimer.c */
asmlinkage long sys_nanosleep(struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);
asmlinkage long sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);

/* kernel/itimer.c */
asmlinkage long sys_getitimer(int which, struct __kernel_old_itimerval __user *value);
asmlinkage long sys_setitimer(int which, struct __kernel_old_itimerval __user *value,
                              struct __kernel_old_itimerval __user *ovalue);

/* kernel/kexec.c */
asmlinkage long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments,
                               unsigned long flags);

/* kernel/module.c */
asmlinkage long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);
asmlinkage long sys_delete_module(const char __user *name_user, unsigned int flags);

/* kernel/posix-timers.c */
asmlinkage long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec,
                                 timer_t __user *created_timer_id);
asmlinkage long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);
asmlinkage long sys_timer_getoverrun(timer_t timer_id);
asmlinkage long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting,
                                  struct __kernel_itimerspec __user *old_setting);
asmlinkage long sys_timer_delete(timer_t timer_id);
asmlinkage long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp,
                                    struct __kernel_timespec __user *rmtp);
asmlinkage long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);
asmlinkage long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new,
                                    struct old_itimerspec32 __user *old);
asmlinkage long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp,
                                           struct old_timespec32 __user *rmtp);

/* kernel/printk.c */
asmlinkage long sys_syslog(int type, char __user *buf, int len);

/* kernel/ptrace.c */
asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);
/* kernel/sched/core.c */

asmlinkage long sys_sched_setparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);
asmlinkage long sys_sched_getscheduler(pid_t pid);
asmlinkage long sys_sched_getparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_yield(void);
asmlinkage long sys_sched_get_priority_max(int policy);
asmlinkage long sys_sched_get_priority_min(int policy);
asmlinkage long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);
asmlinkage long sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);

/* kernel/signal.c */
asmlinkage long sys_restart_syscall(void);
asmlinkage long sys_kill(pid_t pid, int sig);
asmlinkage long sys_tkill(pid_t pid, int sig);
asmlinkage long sys_tgkill(pid_t tgid, pid_t pid, int sig);
asmlinkage long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);
asmlinkage long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);

#ifndef CONFIG_ODD_RT_SIGACTION
asmlinkage long sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);
#endif

asmlinkage long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);
asmlinkage long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo,
                                    const struct __kernel_timespec __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese, siginfo_t __user *uinfo,
                                           const struct old_timespec32 __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);

/* kernel/sys.c */
asmlinkage long sys_setpriority(int which, int who, int niceval);
asmlinkage long sys_getpriority(int which, int who);
asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);
asmlinkage long sys_setregid(gid_t rgid, gid_t egid);
asmlinkage long sys_setgid(gid_t gid);
asmlinkage long sys_setreuid(uid_t ruid, uid_t euid);
asmlinkage long sys_setuid(uid_t uid);
asmlinkage long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);
asmlinkage long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);
asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);
asmlinkage long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);
asmlinkage long sys_setfsuid(uid_t uid);
asmlinkage long sys_setfsgid(gid_t gid);
asmlinkage long sys_times(struct tms __user *tbuf);
asmlinkage long sys_setpgid(pid_t pid, pid_t pgid);
asmlinkage long sys_getpgid(pid_t pid);
asmlinkage long sys_getsid(pid_t pid);
asmlinkage long sys_setsid(void);
asmlinkage long sys_getgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_setgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_newuname(struct new_utsname __user *name);
asmlinkage long sys_sethostname(char __user *name, int len);
asmlinkage long sys_setdomainname(char __user *name, int len);
asmlinkage long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_getrusage(int who, struct rusage __user *ru);
asmlinkage long sys_umask(int mask);
asmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
asmlinkage long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);

/* kernel/time.c */
asmlinkage long sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_adjtimex(struct __kernel_timex __user *txc_p);
asmlinkage long sys_adjtimex_time32(struct old_timex32 __user *txc_p);

/* kernel/sys.c */
asmlinkage long sys_getpid(void);
asmlinkage long sys_getppid(void);
asmlinkage long sys_getuid(void);
asmlinkage long sys_geteuid(void);
asmlinkage long sys_getgid(void);
asmlinkage long sys_getegid(void);
asmlinkage long sys_gettid(void);
asmlinkage long sys_sysinfo(struct sysinfo __user *info);

/* ipc/mqueue.c */
asmlinkage long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);
asmlinkage long sys_mq_unlink(const char __user *name);
asmlinkage long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio,
                                 const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio,
                                    const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);
asmlinkage long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);
asmlinkage long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len,
                                           unsigned int __user *u_msg_prio,
                                           const struct old_timespec32 __user *u_abs_timeout);
asmlinkage long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len,
                                        unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);

/* ipc/msg.c */
asmlinkage long sys_msgget(key_t key, int msgflg);
asmlinkage long sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);
asmlinkage long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);

/* ipc/sem.c */
asmlinkage long sys_semget(key_t key, int nsems, int semflg);
asmlinkage long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops,
                               const struct __kernel_timespec __user *timeout);
asmlinkage long sys_semtimedop_time32(int semid, struct sembuf __user *sops, unsigned nsops,
                                      const struct old_timespec32 __user *timeout);
asmlinkage long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);

/* ipc/shm.c */
asmlinkage long sys_shmget(key_t key, size_t size, int flag);
asmlinkage long sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmat(int shmid, char __user *shmaddr, int shmflg);
asmlinkage long sys_shmdt(char __user *shmaddr);

/* net/socket.c */
asmlinkage long sys_socket(int, int, int);
asmlinkage long sys_socketpair(int, int, int, int __user *);
asmlinkage long sys_bind(int, struct sockaddr __user *, int);
asmlinkage long sys_listen(int, int);
asmlinkage long sys_accept(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_connect(int, struct sockaddr __user *, int);
asmlinkage long sys_getsockname(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_getpeername(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_sendto(int, void __user *, size_t, unsigned, struct sockaddr __user *, int);
asmlinkage long sys_recvfrom(int, void __user *, size_t, unsigned, struct sockaddr __user *, int __user *);
asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);
asmlinkage long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);
asmlinkage long sys_shutdown(int, int);
asmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);

/* mm/filemap.c */
asmlinkage long sys_readahead(int fd, loff_t offset, size_t count);

/* mm/nommu.c, also with MMU */
asmlinkage long sys_brk(unsigned long brk);
asmlinkage long sys_munmap(unsigned long addr, size_t len);
asmlinkage long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags,
                           unsigned long new_addr);

/* security/keys/keyctl.c */
asmlinkage long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload,
                            size_t plen, key_serial_t destringid);
asmlinkage long sys_request_key(const char __user *_type, const char __user *_description,
                                const char __user *_callout_info, key_serial_t destringid);
asmlinkage long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);

/* arch/example/kernel/sys_example.c */
#ifdef CONFIG_CLONE_BACKWARDS
asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, unsigned long, int __user *);
#else
#ifdef CONFIG_CLONE_BACKWARDS3
asmlinkage long sys_clone(unsigned long, unsigned long, int, int __user *, int __user *, unsigned long);
#else
asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);
#endif
#endif

asmlinkage long sys_clone3(struct clone_args __user *uargs, size_t size);

asmlinkage long sys_execve(const char __user *filename, const char __user *const __user *argv,
                           const char __user *const __user *envp);

/* mm/fadvise.c */
asmlinkage long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);

/* mm/, CONFIG_MMU only */
asmlinkage long sys_swapon(const char __user *specialfile, int swap_flags);
asmlinkage long sys_swapoff(const char __user *specialfile);
asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot);
asmlinkage long sys_msync(unsigned long start, size_t len, int flags);
asmlinkage long sys_mlock(unsigned long start, size_t len);
asmlinkage long sys_munlock(unsigned long start, size_t len);
asmlinkage long sys_mlockall(int flags);
asmlinkage long sys_munlockall(void);
asmlinkage long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);
asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);
asmlinkage long sys_process_madvise(int pidfd, const struct iovec __user *vec, size_t vlen, int behavior,
                                    unsigned int flags);
asmlinkage long sys_process_mrelease(int pidfd, unsigned int flags);
asmlinkage long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff,
                                     unsigned long flags);
asmlinkage long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask,
                          unsigned long maxnode, unsigned flags);
asmlinkage long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode,
                                  unsigned long addr, unsigned long flags);
asmlinkage long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);
asmlinkage long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from,
                                  const unsigned long __user *to);
asmlinkage long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user *__user *pages,
                               const int __user *nodes, int __user *status, int flags);

asmlinkage long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);
asmlinkage long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd,
                                    unsigned long flags);
asmlinkage long sys_accept4(int, struct sockaddr __user *, int __user *, int);
asmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags,
                             struct __kernel_timespec __user *timeout);
asmlinkage long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags,
                                    struct old_timespec32 __user *timeout);

asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
asmlinkage long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim,
                              struct rlimit64 __user *old_rlim);
asmlinkage long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);
asmlinkage long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);
asmlinkage long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle,
                                      int __user *mnt_id, int flag);
asmlinkage long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
asmlinkage long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);
asmlinkage long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);
asmlinkage long sys_syncfs(int fd);
asmlinkage long sys_setns(int fd, int nstype);
asmlinkage long sys_pidfd_open(pid_t pid, unsigned int flags);
asmlinkage long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);
asmlinkage long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt,
                                     const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt,
                                      const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);
asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
asmlinkage long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);
asmlinkage long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);
asmlinkage long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname,
                              unsigned int flags);
asmlinkage long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);
asmlinkage long sys_getrandom(char __user *buf, size_t count, unsigned int flags);
asmlinkage long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);
asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
asmlinkage long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv,
                             const char __user *const __user *envp, int flags);
asmlinkage long sys_userfaultfd(int flags);
asmlinkage long sys_membarrier(int cmd, unsigned int flags, int cpu_id);
asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
asmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len,
                                    unsigned int flags);
asmlinkage long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l,
                            unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l,
                             unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);
asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);
asmlinkage long sys_pkey_free(int pkey);
asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);
asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);
asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
asmlinkage long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path,
                               unsigned int ms_flags);
asmlinkage long sys_mount_setattr(int dfd, const char __user *path, unsigned int flags, struct mount_attr __user *uattr,
                                  size_t usize);
asmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);
asmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);
asmlinkage long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);
asmlinkage long sys_fspick(int dfd, const char __user *path, unsigned int flags);
asmlinkage long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);
asmlinkage long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);
asmlinkage long sys_landlock_create_ruleset(const struct landlock_ruleset_attr __user *attr, size_t size, __u32 flags);
asmlinkage long sys_landlock_add_rule(int ruleset_fd, enum landlock_rule_type rule_type, const void __user *rule_attr,
                                      __u32 flags);
asmlinkage long sys_landlock_restrict_self(int ruleset_fd, __u32 flags);
asmlinkage long sys_memfd_secret(unsigned int flags);
asmlinkage long sys_set_mempolicy_home_node(unsigned long start, unsigned long len, unsigned long home_node,
                                            unsigned long flags);

/*
 * Architecture-specific system calls
 */

/* arch/x86/kernel/ioport.c */
asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int on);

/* pciconfig: alpha, arm, arm64, ia64, sparc */
asmlinkage long sys_pciconfig_read(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,
                                   void __user *buf);
asmlinkage long sys_pciconfig_write(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,
                                    void __user *buf);
asmlinkage long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn);

/* powerpc */
asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus);
asmlinkage long sys_spu_create(const char __user *name, unsigned int flags, umode_t mode, int fd);

/*
 * Deprecated system calls which are still defined in
 * include/uapi/asm-generic/unistd.h and wanted by >= 1 arch
 */

/* __ARCH_WANT_SYSCALL_NO_AT */
asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_link(const char __user *oldname, const char __user *newname);
asmlinkage long sys_unlink(const char __user *pathname);
asmlinkage long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_chmod(const char __user *filename, umode_t mode);
asmlinkage long sys_chown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);
asmlinkage long sys_rmdir(const char __user *pathname);
asmlinkage long sys_lchown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_access(const char __user *filename, int mode);
asmlinkage long sys_rename(const char __user *oldname, const char __user *newname);
asmlinkage long sys_symlink(const char __user *old, const char __user *new);
asmlinkage long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);
asmlinkage long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);

asmlinkage long sys_pipe(int __user *fildes);
asmlinkage long sys_dup2(unsigned int oldfd, unsigned int newfd);
asmlinkage long sys_epoll_create(int size);
asmlinkage long sys_inotify_init(void);
asmlinkage long sys_eventfd(unsigned int count);
asmlinkage long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);

/* __ARCH_WANT_SYSCALL_OFF_T */
asmlinkage long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);
asmlinkage long sys_newstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_newlstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);

/* __ARCH_WANT_SYSCALL_DEPRECATED */
asmlinkage long sys_alarm(unsigned int seconds);
asmlinkage long sys_getpgrp(void);
asmlinkage long sys_pause(void);
asmlinkage long sys_time(__kernel_old_time_t __user *tloc);
asmlinkage long sys_time32(old_time32_t __user *tloc);
asmlinkage long sys_utime(char __user *filename, struct utimbuf __user *times);
asmlinkage long sys_utimes(char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat(int dfd, const char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);
asmlinkage long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_creat(const char __user *pathname, umode_t mode);
asmlinkage long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);
asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp,
                           struct __kernel_old_timeval __user *tvp);
asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);
asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);
asmlinkage long sys_ustat(unsigned dev, struct ustat __user *ubuf);
asmlinkage long sys_vfork(void);
asmlinkage long sys_recv(int, void __user *, size_t, unsigned);
asmlinkage long sys_send(int, void __user *, size_t, unsigned);
asmlinkage long sys_oldumount(char __user *name);
asmlinkage long sys_uselib(const char __user *library);
asmlinkage long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);
asmlinkage long sys_fork(void);

/* obsolete: kernel/time/time.c */
asmlinkage long sys_stime(__kernel_old_time_t __user *tptr);
asmlinkage long sys_stime32(old_time32_t __user *tptr);

/* obsolete: kernel/signal.c */
asmlinkage long sys_sigpending(old_sigset_t __user *uset);
asmlinkage long sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);
asmlinkage long sys_sigsuspend(old_sigset_t mask);

#ifdef CONFIG_OLD_SIGSUSPEND3
asmlinkage long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);
#endif

asmlinkage long sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);

asmlinkage long sys_sgetmask(void);
asmlinkage long sys_ssetmask(int newmask);
asmlinkage long sys_signal(int sig, __sighandler_t handler);

/* obsolete: kernel/sched/core.c */
asmlinkage long sys_nice(int increment);

/* obsolete: kernel/kexec_file.c */
asmlinkage long sys_kexec_file_load(int kernel_fd, int initrd_fd, unsigned long cmdline_len,
                                    const char __user *cmdline_ptr, unsigned long flags);

/* obsolete: kernel/exit.c */
asmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options);

/* obsolete: kernel/uid16.c */
asmlinkage long sys_chown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_lchown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);
asmlinkage long sys_setregid16(old_gid_t rgid, old_gid_t egid);
asmlinkage long sys_setgid16(old_gid_t gid);
asmlinkage long sys_setreuid16(old_uid_t ruid, old_uid_t euid);
asmlinkage long sys_setuid16(old_uid_t uid);
asmlinkage long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);
asmlinkage long sys_getresuid16(old_uid_t __user *ruid, old_uid_t __user *euid, old_uid_t __user *suid);
asmlinkage long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);
asmlinkage long sys_getresgid16(old_gid_t __user *rgid, old_gid_t __user *egid, old_gid_t __user *sgid);
asmlinkage long sys_setfsuid16(old_uid_t uid);
asmlinkage long sys_setfsgid16(old_gid_t gid);
asmlinkage long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_getuid16(void);
asmlinkage long sys_geteuid16(void);
asmlinkage long sys_getgid16(void);
asmlinkage long sys_getegid16(void);

/* obsolete: net/socket.c */
asmlinkage long sys_socketcall(int call, unsigned long __user *args);

/* obsolete: fs/stat.c */
asmlinkage long sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_readlink(const char __user *path, char __user *buf, int bufsiz);

/* obsolete: fs/select.c */
asmlinkage long sys_old_select(struct sel_arg_struct __user *arg);

/* obsolete: fs/readdir.c */
asmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);

/* obsolete: kernel/sys.c */
asmlinkage long sys_gethostname(char __user *name, int len);
asmlinkage long sys_uname(struct old_utsname __user *);
asmlinkage long sys_olduname(struct oldold_utsname __user *);

#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
asmlinkage long sys_old_getrlimit(unsigned int resource, struct rlimit __user *rlim);
#endif

/* obsolete: ipc */
asmlinkage long sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr,
                        long fifth);

/* obsolete: mm/ */
asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags,
                               unsigned long fd, unsigned long pgoff);
asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);

/*
 * Not a real system call, but a placeholder for syscalls which are
 * not implemented -- see kernel/sys_ni.c
 */
asmlinkage long sys_ni_syscall(void);

/*
 * Kernel code should not call syscalls (i.e., sys_xyzyyz()) directly.
 * Instead, use one of the functions which work equivalently, such as
 * the ksys_xyzyyz() functions prototyped below.
 */
ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count);
int ksys_fchown(unsigned int fd, uid_t user, gid_t group);
ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count);
void ksys_sync(void);
int ksys_unshare(unsigned long unshare_flags);
int ksys_setsid(void);
int ksys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);
ssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
ssize_t ksys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);
int ksys_fallocate(int fd, int mode, loff_t offset, loff_t len);
int ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);

unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags,
                              unsigned long fd, unsigned long pgoff);
ssize_t ksys_readahead(int fd, loff_t offset, size_t count);
int ksys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);
int compat_ksys_ipc(u32 call, int first, int second, u32 third, u32 ptr, u32 fifth);

long ksys_chown(const char __user *filename, uid_t user, gid_t group);
long ksys_lchown(const char __user *filename, uid_t user, gid_t group);
long ksys_ftruncate(unsigned int fd, loff_t length);
long ksys_truncate(const char __user *pathname, loff_t length);
unsigned int ksys_personality(unsigned int personality);

/* for __ARCH_WANT_SYS_IPC */
long ksys_semtimedop(int semid, struct sembuf __user *tsops, unsigned int nsops,
                     const struct __kernel_timespec __user *timeout);
long ksys_semget(key_t key, int nsems, int semflg);
long ksys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
long ksys_msgget(key_t key, int msgflg);
long ksys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);
long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);
long ksys_shmget(key_t key, size_t size, int shmflg);
long ksys_shmdt(char __user *shmaddr);
long ksys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems, unsigned int nsops,
                            const struct old_timespec32 __user *timeout);
long __do_semtimedop(int semid, struct sembuf *tsems, unsigned int nsops, const struct timespec64 *timeout,
                     struct ipc_namespace *ns);

int __sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);
int __sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);

#endif
```

`kernel/linux/include/linux/thread_info.h`:

```h
#ifndef _LINUX_THREAD_INFO_H
#define _LINUX_THREAD_INFO_H

#include <asm/current.h>
#include <asm/thread_info.h>

// CONFIG_THREAD_INFO_IN_TASK
#define current_thread_info() ((struct thread_info *)current)

// unsigned long sp;
// asm("mrs %0, sp" : "=r"(sp));
// #define THREAD_SIZE 16384
// return (struct thread_info *)(sp & ~(THREAD_SIZE - 1));

#endif
```

`kernel/linux/include/linux/uaccess.h`:

```h
#ifndef __LINUX_UACCESS_H__
#define __LINUX_UACCESS_H__

#include <ktypes.h>
#include <ksyms.h>

#define get_fs() (current_thread_info()->addr_limit)

// todo:
unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n);
unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n);
unsigned long __must_check copy_in_user(void __user *to, const void __user *from, unsigned long n);

extern long kfunc_def(strncpy_from_user)(char *dest, const char __user *src, long count);
extern __must_check long kfunc_def(strnlen_user)(const char __user *str, long n);

static inline long strncpy_from_user(char *dest, const char __user *src, long count)
{
    kfunc_call(strncpy_from_user, dest, src, count);
    kfunc_not_found();
    return 0;
}

static inline __must_check long strnlen_user(const char __user *str, long n)
{
    kfunc_call(strnlen_user, str, n);
    kfunc_not_found();
    return 0;
}

#endif
```

`kernel/linux/include/linux/vmalloc.h`:

```h
#ifndef _LINUX_VMALLOC_H
#define _LINUX_VMALLOC_H

#include <ktypes.h>
#include <ksyms.h>

typedef size_t pgprot_t;

struct vm_area_struct; /* vma defining user mapping in mm_types.h */
struct notifier_block; /* in notifier.h */

/* bits in flags of vmalloc's vm_struct below */
#define VM_IOREMAP 0x00000001 /* ioremap() and friends */
#define VM_ALLOC 0x00000002 /* vmalloc() */
#define VM_MAP 0x00000004 /* vmap()ed pages */
#define VM_USERMAP 0x00000008 /* suitable for remap_vmalloc_range */
#define VM_DMA_COHERENT 0x00000010 /* dma_alloc_coherent */
#define VM_UNINITIALIZED 0x00000020 /* vm_struct is not fully initialized */
#define VM_NO_GUARD 0x00000040 /* don't add guard page */
#define VM_KASAN 0x00000080 /* has allocated kasan shadow memory */
#define VM_FLUSH_RESET_PERMS 0x00000100 /* reset direct map and flush TLB on unmap, can't be freed in atomic context */
#define VM_MAP_PUT_PAGES 0x00000200 /* put pages and free array in vfree */

struct vm_struct
{
    struct vm_struct *next;
    void *addr;
    unsigned long size;
    unsigned long flags;
    struct page **pages;
    unsigned int nr_pages;
    phys_addr_t phys_addr;
    const void *caller;
};

// struct vmap_area {
//     unsigned long va_start;
//     unsigned long va_end;

//     struct rb_node rb_node; /* address sorted rbtree */
//     struct list_head list; /* address sorted list */

//     /*
// 	 * The following three variables can be packed, because
// 	 * a vmap_area object is always one of the three states:
// 	 *    1) in "free" tree (root is vmap_area_root)
// 	 *    2) in "busy" tree (root is free_vmap_area_root)
// 	 *    3) in purge list  (head is vmap_purge_list)
// 	 */
//     union {
//         unsigned long subtree_max_size; /* in "free" tree */
//         struct vm_struct *vm; /* in "busy" tree */
//         struct llist_node purge_list; /* in purge list */
//     };
// };

extern void kfunc_def(vm_unmap_ram)(const void *mem, unsigned int count);
extern void *kfunc_def(vm_map_ram)(struct page **pages, unsigned int count, int node);
extern void kfunc_def(vm_unmap_aliases)(void);

extern void *kfunc_def(vmalloc)(unsigned long size);
extern void *kfunc_def(vzalloc)(unsigned long size);
extern void *kfunc_def(vmalloc_user)(unsigned long size);
extern void *kfunc_def(vmalloc_node)(unsigned long size, int node);
extern void *kfunc_def(vzalloc_node)(unsigned long size, int node);
extern void *kfunc_def(vmalloc_32)(unsigned long size);
extern void *kfunc_def(vmalloc_32_user)(unsigned long size);
extern void *kfunc_def(__vmalloc)(unsigned long size, gfp_t gfp_mask);
extern void *kfunc_def(__vmalloc_node_range)(unsigned long size, unsigned long align, unsigned long start,
                                             unsigned long end, gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags,
                                             int node, const void *caller);
extern void *kfunc_def(__vmalloc_node)(unsigned long size, unsigned long align, gfp_t gfp_mask, int node,
                                       const void *caller);

extern void kfunc_def(vfree)(const void *addr);
extern void kfunc_def(vfree_atomic)(const void *addr);

extern void *kfunc_def(vmap)(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot);
extern void *kfunc_def(vmap_pfn)(unsigned long *pfns, unsigned int count, pgprot_t prot);
extern void kfunc_def(vunmap)(const void *addr);
extern int kfunc_def(remap_vmalloc_range_partial)(struct vm_area_struct *vma, unsigned long uaddr, void *kaddr,
                                                  unsigned long pgoff, unsigned long size);
extern int kfunc_def(remap_vmalloc_range)(struct vm_area_struct *vma, void *addr, unsigned long pgoff);

extern struct vm_struct *kfunc_def(get_vm_area)(unsigned long size, unsigned long flags);
extern struct vm_struct *kfunc_def(get_vm_area_caller)(unsigned long size, unsigned long flags, const void *caller);
extern struct vm_struct *kfunc_def(__get_vm_area_caller)(unsigned long size, unsigned long flags, unsigned long start,
                                                         unsigned long end, const void *caller);
extern void kfunc_def(free_vm_area)(struct vm_struct *area);
extern struct vm_struct *kfunc_def(remove_vm_area)(const void *addr);
extern struct vm_struct *kfunc_def(find_vm_area)(const void *addr);

extern int kfunc_def(map_kernel_range_noflush)(unsigned long start, unsigned long size, pgprot_t prot,
                                               struct page **pages);
extern int kfunc_def(map_kernel_range)(unsigned long start, unsigned long size, pgprot_t prot, struct page **pages);
extern void kfunc_def(unmap_kernel_range_noflush)(unsigned long addr, unsigned long size);
extern void kfunc_def(unmap_kernel_range)(unsigned long addr, unsigned long size);

/* for /dev/kmem */
extern long kfunc_def(vread)(char *buf, char *addr, unsigned long count);
extern long kfunc_def(vwrite)(char *buf, char *addr, unsigned long count);

static inline void vm_unmap_ram(const void *mem, unsigned int count)
{
    kfunc_call(vm_unmap_ram, mem, count);
    kfunc_not_found();
}
static inline void *vm_map_ram(struct page **pages, unsigned int count, int node)
{
    kfunc_call(vm_map_ram, pages, count, node);
    kfunc_not_found();
    return 0;
}
static inline void vm_unmap_aliases(void)
{
    kfunc_call(vm_unmap_aliases);
    kfunc_not_found();
}

static inline void *vmalloc(unsigned long size)
{
    kfunc_call(vmalloc, size);
    kfunc_not_found();
    return 0;
}
static inline void *vzalloc(unsigned long size)
{
    kfunc_call(vzalloc, size);
    kfunc_not_found();
    return 0;
}
static inline void *vmalloc_user(unsigned long size)
{
    kfunc_call(vmalloc_user, size);
    kfunc_not_found();
    return 0;
}
static inline void *vmalloc_node(unsigned long size, int node)
{
    kfunc_call(vmalloc_node, size, node);
    kfunc_not_found();
    return 0;
}
static inline void *vzalloc_node(unsigned long size, int node)
{
    kfunc_call(vzalloc_node, size, node);
    kfunc_not_found();
    return 0;
}
static inline void *vmalloc_32(unsigned long size)
{
    kfunc_call(vmalloc_32, size);
    kfunc_not_found();
    return 0;
}
static inline void *vmalloc_32_user(unsigned long size)
{
    kfunc_call(vmalloc_32_user, size);
    kfunc_not_found();
    return 0;
}
static inline void *__vmalloc(unsigned long size, gfp_t gfp_mask)
{
    kfunc_call(__vmalloc, size, gfp_mask);
    kfunc_not_found();
    return 0;
}
static inline void *__vmalloc_node_range(unsigned long size, unsigned long align, unsigned long start,
                                         unsigned long end, gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags,
                                         int node, const void *caller)
{
    kfunc_call(__vmalloc_node_range, size, align, start, end, gfp_mask, prot, vm_flags, node, caller);
    kfunc_not_found();
    return 0;
}
static inline void *__vmalloc_node(unsigned long size, unsigned long align, gfp_t gfp_mask, int node,
                                   const void *caller)

{
    kfunc_call(__vmalloc_node, size, align, gfp_mask, node, caller);
    kfunc_not_found();
    return 0;
}

static inline void vfree(const void *addr)
{
    kfunc_call(vfree, addr);
    kfunc_not_found();
}
static inline void vfree_atomic(const void *addr)
{
    kfunc_call(vfree_atomic, addr);
    kfunc_not_found();
}

static inline void *vmap(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot)
{
    kfunc_call(vmap, pages, count, flags, prot);
    kfunc_not_found();
    return 0;
}
static inline void *vmap_pfn(unsigned long *pfns, unsigned int count, pgprot_t prot)
{
    kfunc_call(vmap_pfn, pfns, count, prot);
    kfunc_not_found();
    return 0;
}
static inline void vunmap(const void *addr)
{
    kfunc_call(vunmap, addr);
    kfunc_not_found();
}
static inline int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr, void *kaddr,
                                              unsigned long pgoff, unsigned long size)
{
    kfunc_call(remap_vmalloc_range_partial, vma, uaddr, kaddr, pgoff, size);
    kfunc_not_found();
    return 0;
}
static inline int remap_vmalloc_range(struct vm_area_struct *vma, void *addr, unsigned long pgoff)
{
    kfunc_call(remap_vmalloc_range, vma, addr, pgoff);
    kfunc_not_found();
    return 0;
}

static inline struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)
{
    kfunc_call(get_vm_area, size, flags);
    kfunc_not_found();
    return 0;
}
static inline struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags, const void *caller)
{
    kfunc_call(get_vm_area_caller, size, flags, caller);
    kfunc_not_found();
    return 0;
}
static inline struct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags, unsigned long start,
                                                     unsigned long end, const void *caller)
{
    kfunc_call(__get_vm_area_caller, size, flags, start, end, caller);
    kfunc_not_found();
    return 0;
}
static inline void free_vm_area(struct vm_struct *area)
{
    kfunc_call(free_vm_area, area);
    kfunc_not_found();
}
static inline struct vm_struct *remove_vm_area(const void *addr)
{
    kfunc_call(remove_vm_area, addr);
    kfunc_not_found();
    return 0;
}
static inline struct vm_struct *find_vm_area(const void *addr)
{
    kfunc_call(find_vm_area, addr);
    kfunc_not_found();
    return 0;
}

static inline int map_kernel_range_noflush(unsigned long start, unsigned long size, pgprot_t prot, struct page **pages)
{
    kfunc_call(map_kernel_range_noflush, start, size, prot, pages);
    kfunc_not_found();
    return 0;
}
static inline int map_kernel_range(unsigned long start, unsigned long size, pgprot_t prot, struct page **pages)
{
    kfunc_call(map_kernel_range_noflush, start, size, prot, pages);
    kfunc_not_found();
    return 0;
}
static inline void unmap_kernel_range_noflush(unsigned long addr, unsigned long size)
{
    kfunc_call(unmap_kernel_range_noflush, addr, size);
    kfunc_not_found();
}
static inline void unmap_kernel_range(unsigned long addr, unsigned long size)
{
    kfunc_call(unmap_kernel_range, addr, size);
    kfunc_not_found();
}

/* for /dev/kmem */
static inline long vread(char *buf, char *addr, unsigned long count)
{
    kfunc_call(vread, buf, addr, count);
    kfunc_not_found();
    return 0;
}
static inline long vwrite(char *buf, char *addr, unsigned long count)
{
    kfunc_call(vwrite, buf, addr, count);
    kfunc_not_found();
    return 0;
}

#endif
```

`kernel/linux/include/net/netlabel.h`:

```h
#ifndef _NETLABEL_H
#define _NETLABEL_H

#endif
```

`kernel/linux/include/uapi/asm-generic/errno-base.h`:

```h
#ifndef _ASM_GENERIC_ERRNO_BASE_H
#define _ASM_GENERIC_ERRNO_BASE_H

#define EPERM 1 /* Operation not permitted */
#define ENOENT 2 /* No such file or directory */
#define ESRCH 3 /* No such process */
#define EINTR 4 /* Interrupted system call */
#define EIO 5 /* I/O error */
#define ENXIO 6 /* No such device or address */
#define E2BIG 7 /* Argument list too long */
#define ENOEXEC 8 /* Exec format error */
#define EBADF 9 /* Bad file number */
#define ECHILD 10 /* No child processes */
#define EAGAIN 11 /* Try again */
#define ENOMEM 12 /* Out of memory */
#define EACCES 13 /* Permission denied */
#define EFAULT 14 /* Bad address */
#define ENOTBLK 15 /* Block device required */
#define EBUSY 16 /* Device or resource busy */
#define EEXIST 17 /* File exists */
#define EXDEV 18 /* Cross-device link */
#define ENODEV 19 /* No such device */
#define ENOTDIR 20 /* Not a directory */
#define EISDIR 21 /* Is a directory */
#define EINVAL 22 /* Invalid argument */
#define ENFILE 23 /* File table overflow */
#define EMFILE 24 /* Too many open files */
#define ENOTTY 25 /* Not a typewriter */
#define ETXTBSY 26 /* Text file busy */
#define EFBIG 27 /* File too large */
#define ENOSPC 28 /* No space left on device */
#define ESPIPE 29 /* Illegal seek */
#define EROFS 30 /* Read-only file system */
#define EMLINK 31 /* Too many links */
#define EPIPE 32 /* Broken pipe */
#define EDOM 33 /* Math argument out of domain of func */
#define ERANGE 34 /* Math result not representable */

#endif
```

`kernel/linux/include/uapi/asm-generic/errno.h`:

```h
#ifndef _ASM_GENERIC_ERRNO_H
#define _ASM_GENERIC_ERRNO_H

// #include <asm-generic/errno-base.h>

#define EDEADLK 35 /* Resource deadlock would occur */
#define ENAMETOOLONG 36 /* File name too long */
#define ENOLCK 37 /* No record locks available */

/*
 * This error code is special: arch syscall entry code will return
 * -ENOSYS if users try to call a syscall that doesn't exist.  To keep
 * failures of syscalls that really do exist distinguishable from
 * failures due to attempts to use a nonexistent syscall, syscall
 * implementations should refrain from returning -ENOSYS.
 */
#define ENOSYS 38 /* Invalid system call number */

#define ENOTEMPTY 39 /* Directory not empty */
#define ELOOP 40 /* Too many symbolic links encountered */
#define EWOULDBLOCK EAGAIN /* Operation would block */
#define ENOMSG 42 /* No message of desired type */
#define EIDRM 43 /* Identifier removed */
#define ECHRNG 44 /* Channel number out of range */
#define EL2NSYNC 45 /* Level 2 not synchronized */
#define EL3HLT 46 /* Level 3 halted */
#define EL3RST 47 /* Level 3 reset */
#define ELNRNG 48 /* Link number out of range */
#define EUNATCH 49 /* Protocol driver not attached */
#define ENOCSI 50 /* No CSI structure available */
#define EL2HLT 51 /* Level 2 halted */
#define EBADE 52 /* Invalid exchange */
#define EBADR 53 /* Invalid request descriptor */
#define EXFULL 54 /* Exchange full */
#define ENOANO 55 /* No anode */
#define EBADRQC 56 /* Invalid request code */
#define EBADSLT 57 /* Invalid slot */

#define EDEADLOCK EDEADLK

#define EBFONT 59 /* Bad font file format */
#define ENOSTR 60 /* Device not a stream */
#define ENODATA 61 /* No data available */
#define ETIME 62 /* Timer expired */
#define ENOSR 63 /* Out of streams resources */
#define ENONET 64 /* Machine is not on the network */
#define ENOPKG 65 /* Package not installed */
#define EREMOTE 66 /* Object is remote */
#define ENOLINK 67 /* Link has been severed */
#define EADV 68 /* Advertise error */
#define ESRMNT 69 /* Srmount error */
#define ECOMM 70 /* Communication error on send */
#define EPROTO 71 /* Protocol error */
#define EMULTIHOP 72 /* Multihop attempted */
#define EDOTDOT 73 /* RFS specific error */
#define EBADMSG 74 /* Not a data message */
#define EOVERFLOW 75 /* Value too large for defined data type */
#define ENOTUNIQ 76 /* Name not unique on network */
#define EBADFD 77 /* File descriptor in bad state */
#define EREMCHG 78 /* Remote address changed */
#define ELIBACC 79 /* Can not access a needed shared library */
#define ELIBBAD 80 /* Accessing a corrupted shared library */
#define ELIBSCN 81 /* .lib section in a.out corrupted */
#define ELIBMAX 82 /* Attempting to link in too many shared libraries */
#define ELIBEXEC 83 /* Cannot exec a shared library directly */
#define EILSEQ 84 /* Illegal byte sequence */
#define ERESTART 85 /* Interrupted system call should be restarted */
#define ESTRPIPE 86 /* Streams pipe error */
#define EUSERS 87 /* Too many users */
#define ENOTSOCK 88 /* Socket operation on non-socket */
#define EDESTADDRREQ 89 /* Destination address required */
#define EMSGSIZE 90 /* Message too long */
#define EPROTOTYPE 91 /* Protocol wrong type for socket */
#define ENOPROTOOPT 92 /* Protocol not available */
#define EPROTONOSUPPORT 93 /* Protocol not supported */
#define ESOCKTNOSUPPORT 94 /* Socket type not supported */
#define EOPNOTSUPP 95 /* Operation not supported on transport endpoint */
#define EPFNOSUPPORT 96 /* Protocol family not supported */
#define EAFNOSUPPORT 97 /* Address family not supported by protocol */
#define EADDRINUSE 98 /* Address already in use */
#define EADDRNOTAVAIL 99 /* Cannot assign requested address */
#define ENETDOWN 100 /* Network is down */
#define ENETUNREACH 101 /* Network is unreachable */
#define ENETRESET 102 /* Network dropped connection because of reset */
#define ECONNABORTED 103 /* Software caused connection abort */
#define ECONNRESET 104 /* Connection reset by peer */
#define ENOBUFS 105 /* No buffer space available */
#define EISCONN 106 /* Transport endpoint is already connected */
#define ENOTCONN 107 /* Transport endpoint is not connected */
#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */
#define ETOOMANYREFS 109 /* Too many references: cannot splice */
#define ETIMEDOUT 110 /* Connection timed out */
#define ECONNREFUSED 111 /* Connection refused */
#define EHOSTDOWN 112 /* Host is down */
#define EHOSTUNREACH 113 /* No route to host */
#define EALREADY 114 /* Operation already in progress */
#define EINPROGRESS 115 /* Operation now in progress */
#define ESTALE 116 /* Stale file handle */
#define EUCLEAN 117 /* Structure needs cleaning */
#define ENOTNAM 118 /* Not a XENIX named type file */
#define ENAVAIL 119 /* No XENIX semaphores available */
#define EISNAM 120 /* Is a named type file */
#define EREMOTEIO 121 /* Remote I/O error */
#define EDQUOT 122 /* Quota exceeded */

#define ENOMEDIUM 123 /* No medium found */
#define EMEDIUMTYPE 124 /* Wrong medium type */
#define ECANCELED 125 /* Operation Canceled */
#define ENOKEY 126 /* Required key not available */
#define EKEYEXPIRED 127 /* Key has expired */
#define EKEYREVOKED 128 /* Key has been revoked */
#define EKEYREJECTED 129 /* Key was rejected by service */

/* for robust mutexes */
#define EOWNERDEAD 130 /* Owner died */
#define ENOTRECOVERABLE 131 /* State not recoverable */

#define ERFKILL 132 /* Operation not possible due to RF-kill */

#define EHWPOISON 133 /* Memory page has hardware error */

#endif
```

`kernel/linux/include/uapi/asm-generic/unistd.h`:

```h
#define __NR_io_setup 0
#define __NR_io_destroy 1
#define __NR_io_submit 2
#define __NR_io_cancel 3
#define __NR_io_getevents 4

/* fs/xattr.c */
#define __NR_setxattr 5
#define __NR_lsetxattr 6
#define __NR_fsetxattr 7
#define __NR_getxattr 8
#define __NR_lgetxattr 9
#define __NR_fgetxattr 10
#define __NR_listxattr 11
#define __NR_llistxattr 12
#define __NR_flistxattr 13
#define __NR_removexattr 14
#define __NR_lremovexattr 15
#define __NR_fremovexattr 16

/* fs/dcache.c */
#define __NR_getcwd 17

/* fs/cookies.c */
#define __NR_lookup_dcookie 18

/* fs/eventfd.c */
#define __NR_eventfd2 19

/* fs/eventpoll.c */
#define __NR_epoll_create1 20
#define __NR_epoll_ctl 21
#define __NR_epoll_pwait 22

/* fs/fcntl.c */
#define __NR_dup 23
#define __NR_dup3 24
#define __NR3264_fcntl 25

/* fs/inotify_user.c */
#define __NR_inotify_init1 26
#define __NR_inotify_add_watch 27
#define __NR_inotify_rm_watch 28

/* fs/ioctl.c */
#define __NR_ioctl 29

/* fs/ioprio.c */
#define __NR_ioprio_set 30
#define __NR_ioprio_get 31

/* fs/locks.c */
#define __NR_flock 32

/* fs/namei.c */
#define __NR_mknodat 33
#define __NR_mkdirat 34
#define __NR_unlinkat 35
#define __NR_symlinkat 36
#define __NR_linkat 37
/* renameat is superseded with flags by renameat2 */
#define __NR_renameat 38

/* fs/namespace.c */
#define __NR_umount2 39
#define __NR_mount 40
#define __NR_pivot_root 41

/* fs/nfsctl.c */
#define __NR_nfsservctl 42

/* fs/open.c */
#define __NR3264_statfs 43
#define __NR3264_fstatfs 44
#define __NR3264_truncate 45
#define __NR3264_ftruncate 46
#define __NR_fallocate 47
#define __NR_faccessat 48
#define __NR_chdir 49
#define __NR_fchdir 50
#define __NR_chroot 51
#define __NR_fchmod 52
#define __NR_fchmodat 53
#define __NR_fchownat 54
#define __NR_fchown 55
#define __NR_openat 56
#define __NR_close 57
#define __NR_vhangup 58

/* fs/pipe.c */
#define __NR_pipe2 59

/* fs/quota.c */
#define __NR_quotactl 60

/* fs/readdir.c */
#define __NR_getdents64 61

/* fs/read_write.c */
#define __NR3264_lseek 62
#define __NR_read 63
#define __NR_write 64
#define __NR_readv 65
#define __NR_writev 66
#define __NR_pread64 67
#define __NR_pwrite64 68
#define __NR_preadv 69
#define __NR_pwritev 70

/* fs/sendfile.c */
#define __NR3264_sendfile 71

/* fs/select.c */
#define __NR_pselect6 72
#define __NR_ppoll 73

/* fs/signalfd.c */
#define __NR_signalfd4 74

/* fs/splice.c */
#define __NR_vmsplice 75
#define __NR_splice 76
#define __NR_tee 77

/* fs/stat.c */
#define __NR_readlinkat 78
#define __NR3264_fstatat 79
#define __NR3264_fstat 80

/* fs/sync.c */
#define __NR_sync 81
#define __NR_fsync 82
#define __NR_fdatasync 83

#ifdef __ARCH_WANT_SYNC_FILE_RANGE2
#define __NR_sync_file_range2 84
#else
#define __NR_sync_file_range 84
#endif

/* fs/timerfd.c */
#define __NR_timerfd_create 85
#define __NR_timerfd_settime 86
#define __NR_timerfd_gettime 87

/* fs/utimes.c */
#define __NR_utimensat 88

/* kernel/acct.c */
#define __NR_acct 89

/* kernel/capability.c */
#define __NR_capget 90
#define __NR_capset 91

/* kernel/exec_domain.c */
#define __NR_personality 92

/* kernel/exit.c */
#define __NR_exit 93
#define __NR_exit_group 94
#define __NR_waitid 95

/* kernel/fork.c */
#define __NR_set_tid_address 96
#define __NR_unshare 97

/* kernel/futex.c */
#define __NR_futex 98
#define __NR_set_robust_list 99
#define __NR_get_robust_list 100

/* kernel/hrtimer.c */
#define __NR_nanosleep 101

/* kernel/itimer.c */
#define __NR_getitimer 102

#define __NR_setitimer 103

/* kernel/kexec.c */
#define __NR_kexec_load 104

/* kernel/module.c */
#define __NR_init_module 105
#define __NR_delete_module 106

/* kernel/posix-timers.c */
#define __NR_timer_create 107

#define __NR_timer_gettime 108
#define __NR_timer_getoverrun 109
#define __NR_timer_settime 110
#define __NR_timer_delete 111
#define __NR_clock_settime 112
#define __NR_clock_gettime 113
#define __NR_clock_getres 114
#define __NR_clock_nanosleep 115

/* kernel/printk.c */
#define __NR_syslog 116

/* kernel/ptrace.c */
#define __NR_ptrace 117

/* kernel/sched/core.c */
#define __NR_sched_setparam 118
#define __NR_sched_setscheduler 119
#define __NR_sched_getscheduler 120
#define __NR_sched_getparam 121
#define __NR_sched_setaffinity 122

#define __NR_sched_getaffinity 123

#define __NR_sched_yield 124
#define __NR_sched_get_priority_max 125
#define __NR_sched_get_priority_min 126
#define __NR_sched_rr_get_interval 127

/* kernel/signal.c */
#define __NR_restart_syscall 128
#define __NR_kill 129
#define __NR_tkill 130
#define __NR_tgkill 131
#define __NR_sigaltstack 132
#define __NR_rt_sigsuspend 133
#define __NR_rt_sigaction 134
#define __NR_rt_sigprocmask 135
#define __NR_rt_sigpending 136
#define __NR_rt_sigtimedwait 137
#define __NR_rt_sigqueueinfo 138
#define __NR_rt_sigreturn 139

/* kernel/sys.c */
#define __NR_setpriority 140
#define __NR_getpriority 141
#define __NR_reboot 142
#define __NR_setregid 143
#define __NR_setgid 144
#define __NR_setreuid 145
#define __NR_setuid 146
#define __NR_setresuid 147
#define __NR_getresuid 148
#define __NR_setresgid 149
#define __NR_getresgid 150
#define __NR_setfsuid 151
#define __NR_setfsgid 152
#define __NR_times 153

#define __NR_setpgid 154
#define __NR_getpgid 155
#define __NR_getsid 156
#define __NR_setsid 157
#define __NR_getgroups 158
#define __NR_setgroups 159
#define __NR_uname 160
#define __NR_sethostname 161
#define __NR_setdomainname 162

/* getrlimit and setrlimit are superseded with prlimit64 */
#define __NR_getrlimit 163
#define __NR_setrlimit 164
#define __NR_getrusage 165
#define __NR_umask 166
#define __NR_prctl 167
#define __NR_getcpu 168

/* kernel/time.c */
#define __NR_gettimeofday 169
#define __NR_settimeofday 170
#define __NR_adjtimex 171

/* kernel/sys.c */
#define __NR_getpid 172
#define __NR_getppid 173
#define __NR_getuid 174
#define __NR_geteuid 175
#define __NR_getgid 176
#define __NR_getegid 177
#define __NR_gettid 178
#define __NR_sysinfo 179

/* ipc/mqueue.c */
#define __NR_mq_open 180
#define __NR_mq_unlink 181
#define __NR_mq_timedsend 182
#define __NR_mq_timedreceive 183
#define __NR_mq_notify 184
#define __NR_mq_getsetattr 185

/* ipc/msg.c */
#define __NR_msgget 186
#define __NR_msgctl 187

#define __NR_msgrcv 188

#define __NR_msgsnd 189

/* ipc/sem.c */
#define __NR_semget 190
#define __NR_semctl 191
#define __NR_semtimedop 192
#define __NR_semop 193

/* ipc/shm.c */
#define __NR_shmget 194
#define __NR_shmctl 195
#define __NR_shmat 196
#define __NR_shmdt 197

/* net/socket.c */
#define __NR_socket 198
#define __NR_socketpair 199
#define __NR_bind 200
#define __NR_listen 201
#define __NR_accept 202
#define __NR_connect 203
#define __NR_getsockname 204
#define __NR_getpeername 205
#define __NR_sendto 206
#define __NR_recvfrom 207
#define __NR_setsockopt 208
#define __NR_getsockopt 209
#define __NR_shutdown 210
#define __NR_sendmsg 211
#define __NR_recvmsg 212

/* mm/filemap.c */
#define __NR_readahead 213

/* mm/nommu.c, also with MMU */
#define __NR_brk 214
#define __NR_munmap 215
#define __NR_mremap 216

/* security/keys/keyctl.c */
#define __NR_add_key 217
#define __NR_request_key 218
#define __NR_keyctl 219

/* arch/example/kernel/sys_example.c */
#define __NR_clone 220
#define __NR_execve 221

#define __NR3264_mmap 222
/* mm/fadvise.c */
#define __NR3264_fadvise64 223

/* mm/, CONFIG_MMU only */
#define __NR_swapon 224
#define __NR_swapoff 225
#define __NR_mprotect 226
#define __NR_msync 227
#define __NR_mlock 228
#define __NR_munlock 229
#define __NR_mlockall 230
#define __NR_munlockall 231
#define __NR_mincore 232
#define __NR_madvise 233
#define __NR_remap_file_pages 234
#define __NR_mbind 235
#define __NR_get_mempolicy 236
#define __NR_set_mempolicy 237
#define __NR_migrate_pages 238
#define __NR_move_pages 239
#define __NR_rt_tgsigqueueinfo 240

#define __NR_perf_event_open 241
#define __NR_accept4 242
#define __NR_recvmmsg 243

/*
 * Architectures may provide up to 16 syscalls of their own
 * starting with this value.
 */
#define __NR_arch_specific_syscall 244
#define __NR_wait4 260
#define __NR_prlimit64 261
#define __NR_fanotify_init 262
#define __NR_fanotify_mark 263
#define __NR_name_to_handle_at 264
#define __NR_open_by_handle_at 265
#define __NR_clock_adjtime 266
#define __NR_syncfs 267
#define __NR_setns 268
#define __NR_sendmmsg 269

#define __NR_process_vm_readv 270
#define __NR_process_vm_writev 271
#define __NR_kcmp 272
#define __NR_finit_module 273
#define __NR_sched_setattr 274
#define __NR_sched_getattr 275
#define __NR_renameat2 276
#define __NR_seccomp 277
#define __NR_getrandom 278
#define __NR_memfd_create 279
#define __NR_bpf 280
#define __NR_execveat 281

#define __NR_userfaultfd 282
#define __NR_membarrier 283
#define __NR_mlock2 284
#define __NR_copy_file_range 285
#define __NR_preadv2 286

#define __NR_pwritev2 287

#define __NR_pkey_mprotect 288
#define __NR_pkey_alloc 289
#define __NR_pkey_free 290
#define __NR_statx 291
#define __NR_io_pgetevents 292
#define __NR_rseq 293
#define __NR_kexec_file_load 294
/* 295 through 402 are unassigned to sync up with generic numbers, don't use */
#define __NR_clock_gettime64 403
#define __NR_clock_settime64 404
#define __NR_clock_adjtime64 405
#define __NR_clock_getres_time64 406
#define __NR_clock_nanosleep_time64 407
#define __NR_timer_gettime64 408
#define __NR_timer_settime64 409
#define __NR_timerfd_gettime64 410
#define __NR_timerfd_settime64 411
#define __NR_utimensat_time64 412
#define __NR_pselect6_time64 413
#define __NR_ppoll_time64 414
#define __NR_io_pgetevents_time64 416
#define __NR_recvmmsg_time64 417
#define __NR_mq_timedsend_time64 418
#define __NR_mq_timedreceive_time64 419
#define __NR_semtimedop_time64 420
#define __NR_rt_sigtimedwait_time64 421
#define __NR_futex_time64 422
#define __NR_sched_rr_get_interval_time64 423

#define __NR_pidfd_send_signal 424
#define __NR_io_uring_setup 425
#define __NR_io_uring_enter 426
#define __NR_io_uring_register 427
#define __NR_open_tree 428
#define __NR_move_mount 429
#define __NR_fsopen 430
#define __NR_fsconfig 431
#define __NR_fsmount 432
#define __NR_fspick 433
#define __NR_pidfd_open 434
#define __NR_clone3 435
#define __NR_close_range 436

#define __NR_openat2 437
#define __NR_pidfd_getfd 438
#define __NR_faccessat2 439
#define __NR_process_madvise 440
#define __NR_epoll_pwait2 441

#define __NR_mount_setattr 442
#define __NR_quotactl_fd 443

#define __NR_landlock_create_ruleset 444
#define __NR_landlock_add_rule 445
#define __NR_landlock_restrict_self 446
#define __NR_memfd_secret 447
#define __NR_process_mrelease 448
#define __NR_futex_waitv 449
#define __NR_set_mempolicy_home_node 450
#define __NR_syscalls 451

/*
 * 32 bit systems traditionally used different
 * syscalls for off_t and loff_t arguments, while
 * 64 bit systems only need the off_t version.
 * For new 32 bit platforms, there is no need to
 * implement the old 32 bit off_t syscalls, so
 * they take different names.
 * Here we map the numbers so that both versions
 * use the same syscall table layout.
 */
#if __BITS_PER_LONG == 64 && !defined(__SYSCALL_COMPAT)
#define __NR_fcntl __NR3264_fcntl
#define __NR_statfs __NR3264_statfs
#define __NR_fstatfs __NR3264_fstatfs
#define __NR_truncate __NR3264_truncate
#define __NR_ftruncate __NR3264_ftruncate
#define __NR_lseek __NR3264_lseek
#define __NR_sendfile __NR3264_sendfile
#if defined(__ARCH_WANT_NEW_STAT) || defined(__ARCH_WANT_STAT64)
#define __NR_newfstatat __NR3264_fstatat
#define __NR_fstat __NR3264_fstat
#endif
#define __NR_mmap __NR3264_mmap
#define __NR_fadvise64 __NR3264_fadvise64
#ifdef __NR3264_stat
#define __NR_stat __NR3264_stat
#define __NR_lstat __NR3264_lstat
#endif
#else
#define __NR_fcntl64 __NR3264_fcntl
#define __NR_statfs64 __NR3264_statfs
#define __NR_fstatfs64 __NR3264_fstatfs
#define __NR_truncate64 __NR3264_truncate
#define __NR_ftruncate64 __NR3264_ftruncate
#define __NR_llseek __NR3264_lseek
#define __NR_sendfile64 __NR3264_sendfile
#if defined(__ARCH_WANT_NEW_STAT) || defined(__ARCH_WANT_STAT64)
#define __NR_fstatat64 __NR3264_fstatat
#define __NR_fstat64 __NR3264_fstat
#endif
#define __NR_mmap2 __NR3264_mmap
#define __NR_fadvise64_64 __NR3264_fadvise64
#ifdef __NR3264_stat
#define __NR_stat64 __NR3264_stat
#define __NR_lstat64 __NR3264_lstat
#endif
#endif
```

`kernel/linux/include/uapi/linux/capability.h`:

```h
#ifndef _UAPI_LINUX_CAPABILITY_H
#define _UAPI_LINUX_CAPABILITY_H

#include <ktypes.h>

#define _LINUX_CAPABILITY_VERSION_1 0x19980330
#define _LINUX_CAPABILITY_U32S_1 1

#define _LINUX_CAPABILITY_VERSION_2 0x20071026 /* deprecated - use v3 */
#define _LINUX_CAPABILITY_U32S_2 2

#define _LINUX_CAPABILITY_VERSION_3 0x20080522
#define _LINUX_CAPABILITY_U32S_3 2

typedef struct __user_cap_header_struct
{
    __u32 version;
    int pid;
} __user *cap_user_header_t;

typedef struct __user_cap_data_struct
{
    __u32 effective;
    __u32 permitted;
    __u32 inheritable;
} __user *cap_user_data_t;

#define VFS_CAP_REVISION_MASK 0xFF000000
#define VFS_CAP_REVISION_SHIFT 24
#define VFS_CAP_FLAGS_MASK ~VFS_CAP_REVISION_MASK
#define VFS_CAP_FLAGS_EFFECTIVE 0x000001

#define VFS_CAP_REVISION_1 0x01000000
#define VFS_CAP_U32_1 1
#define XATTR_CAPS_SZ_1 (sizeof(__le32) * (1 + 2 * VFS_CAP_U32_1))

#define VFS_CAP_REVISION_2 0x02000000
#define VFS_CAP_U32_2 2
#define XATTR_CAPS_SZ_2 (sizeof(__le32) * (1 + 2 * VFS_CAP_U32_2))

#define VFS_CAP_REVISION_3 0x03000000
#define VFS_CAP_U32_3 2
#define XATTR_CAPS_SZ_3 (sizeof(__le32) * (2 + 2 * VFS_CAP_U32_3))

#define XATTR_CAPS_SZ XATTR_CAPS_SZ_3
#define VFS_CAP_U32 VFS_CAP_U32_3
#define VFS_CAP_REVISION VFS_CAP_REVISION_3

struct vfs_cap_data
{
    __le32 magic_etc; /* Little endian */
    struct
    {
        __le32 permitted; /* Little endian */
        __le32 inheritable; /* Little endian */
    } data[VFS_CAP_U32];
};

/*
 * same as vfs_cap_data but with a rootid at the end
 */
struct vfs_ns_cap_data
{
    __le32 magic_etc;
    struct
    {
        __le32 permitted; /* Little endian */
        __le32 inheritable; /* Little endian */
    } data[VFS_CAP_U32];
    __le32 rootid;
};

/**
 ** POSIX-draft defined capabilities.
 **/

/* In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this
   overrides the restriction of changing file ownership and group
   ownership. */

#define CAP_CHOWN 0

/* Override all DAC access, including ACL execute access if
   [_POSIX_ACL] is defined. Excluding DAC access covered by
   CAP_LINUX_IMMUTABLE. */

#define CAP_DAC_OVERRIDE 1

/* Overrides all DAC restrictions regarding read and search on files
   and directories, including ACL restrictions if [_POSIX_ACL] is
   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */

#define CAP_DAC_READ_SEARCH 2

/* Overrides all restrictions about allowed operations on files, where
   file owner ID must be equal to the user ID, except where CAP_FSETID
   is applicable. It doesn't override MAC and DAC restrictions. */

#define CAP_FOWNER 3

/* Overrides the following restrictions that the effective user ID
   shall match the file owner ID when setting the S_ISUID and S_ISGID
   bits on that file; that the effective group ID (or one of the
   supplementary group IDs) shall match the file owner ID when setting
   the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
   cleared on successful return from chown(2) (not implemented). */

#define CAP_FSETID 4

/* Overrides the restriction that the real or effective user ID of a
   process sending a signal must match the real or effective user ID
   of the process receiving the signal. */

#define CAP_KILL 5

/* Allows setgid(2) manipulation */
/* Allows setgroups(2) */
/* Allows forged gids on socket credentials passing. */

#define CAP_SETGID 6

/* Allows set*uid(2) manipulation (including fsuid). */
/* Allows forged pids on socket credentials passing. */

#define CAP_SETUID 7

/**
 ** Linux-specific capabilities
 **/

/* Without VFS support for capabilities:
 *   Transfer any capability in your permitted set to any pid,
 *   remove any capability in your permitted set from any pid
 * With VFS support for capabilities (neither of above, but)
 *   Add any capability from current's capability bounding set
 *       to the current process' inheritable set
 *   Allow taking bits out of capability bounding set
 *   Allow modification of the securebits for a process
 */

#define CAP_SETPCAP 8

/* Allow modification of S_IMMUTABLE and S_APPEND file attributes */

#define CAP_LINUX_IMMUTABLE 9

/* Allows binding to TCP/UDP sockets below 1024 */
/* Allows binding to ATM VCIs below 32 */

#define CAP_NET_BIND_SERVICE 10

/* Allow broadcasting, listen to multicast */

#define CAP_NET_BROADCAST 11

/* Allow interface configuration */
/* Allow administration of IP firewall, masquerading and accounting */
/* Allow setting debug option on sockets */
/* Allow modification of routing tables */
/* Allow setting arbitrary process / process group ownership on
   sockets */
/* Allow binding to any address for transparent proxying (also via NET_RAW) */
/* Allow setting TOS (type of service) */
/* Allow setting promiscuous mode */
/* Allow clearing driver statistics */
/* Allow multicasting */
/* Allow read/write of device-specific registers */
/* Allow activation of ATM control sockets */

#define CAP_NET_ADMIN 12

/* Allow use of RAW sockets */
/* Allow use of PACKET sockets */
/* Allow binding to any address for transparent proxying (also via NET_ADMIN) */

#define CAP_NET_RAW 13

/* Allow locking of shared memory segments */
/* Allow mlock and mlockall (which doesn't really have anything to do
   with IPC) */

#define CAP_IPC_LOCK 14

/* Override IPC ownership checks */

#define CAP_IPC_OWNER 15

/* Insert and remove kernel modules - modify kernel without limit */
#define CAP_SYS_MODULE 16

/* Allow ioperm/iopl access */
/* Allow sending USB messages to any device via /dev/bus/usb */

#define CAP_SYS_RAWIO 17

/* Allow use of chroot() */

#define CAP_SYS_CHROOT 18

/* Allow ptrace() of any process */

#define CAP_SYS_PTRACE 19

/* Allow configuration of process accounting */

#define CAP_SYS_PACCT 20

/* Allow configuration of the secure attention key */
/* Allow administration of the random device */
/* Allow examination and configuration of disk quotas */
/* Allow setting the domainname */
/* Allow setting the hostname */
/* Allow mount() and umount(), setting up new smb connection */
/* Allow some autofs root ioctls */
/* Allow nfsservctl */
/* Allow VM86_REQUEST_IRQ */
/* Allow to read/write pci config on alpha */
/* Allow irix_prctl on mips (setstacksize) */
/* Allow flushing all cache on m68k (sys_cacheflush) */
/* Allow removing semaphores */
/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
   and shared memory */
/* Allow locking/unlocking of shared memory segment */
/* Allow turning swap on/off */
/* Allow forged pids on socket credentials passing */
/* Allow setting readahead and flushing buffers on block devices */
/* Allow setting geometry in floppy driver */
/* Allow turning DMA on/off in xd driver */
/* Allow administration of md devices (mostly the above, but some
   extra ioctls) */
/* Allow tuning the ide driver */
/* Allow access to the nvram device */
/* Allow administration of apm_bios, serial and bttv (TV) device */
/* Allow manufacturer commands in isdn CAPI support driver */
/* Allow reading non-standardized portions of pci configuration space */
/* Allow DDI debug ioctl on sbpcd driver */
/* Allow setting up serial ports */
/* Allow sending raw qic-117 commands */
/* Allow enabling/disabling tagged queuing on SCSI controllers and sending
   arbitrary SCSI commands */
/* Allow setting encryption key on loopback filesystem */
/* Allow setting zone reclaim policy */
/* Allow everything under CAP_BPF and CAP_PERFMON for backward compatibility */

#define CAP_SYS_ADMIN 21

/* Allow use of reboot() */

#define CAP_SYS_BOOT 22

/* Allow raising priority and setting priority on other (different
   UID) processes */
/* Allow use of FIFO and round-robin (realtime) scheduling on own
   processes and setting the scheduling algorithm used by another
   process. */
/* Allow setting cpu affinity on other processes */
/* Allow setting realtime ioprio class */
/* Allow setting ioprio class on other processes */

#define CAP_SYS_NICE 23

/* Override resource limits. Set resource limits. */
/* Override quota limits. */
/* Override reserved space on ext2 filesystem */
/* Modify data journaling mode on ext3 filesystem (uses journaling
   resources) */
/* NOTE: ext2 honors fsuid when checking for resource overrides, so
   you can override using fsuid too */
/* Override size restrictions on IPC message queues */
/* Allow more than 64hz interrupts from the real-time clock */
/* Override max number of consoles on console allocation */
/* Override max number of keymaps */
/* Control memory reclaim behavior */

#define CAP_SYS_RESOURCE 24

/* Allow manipulation of system clock */
/* Allow irix_stime on mips */
/* Allow setting the real-time clock */

#define CAP_SYS_TIME 25

/* Allow configuration of tty devices */
/* Allow vhangup() of tty */

#define CAP_SYS_TTY_CONFIG 26

/* Allow the privileged aspects of mknod() */

#define CAP_MKNOD 27

/* Allow taking of leases on files */

#define CAP_LEASE 28

/* Allow writing the audit log via unicast netlink socket */

#define CAP_AUDIT_WRITE 29

/* Allow configuration of audit via unicast netlink socket */

#define CAP_AUDIT_CONTROL 30

/* Set or remove capabilities on files.
   Map uid=0 into a child user namespace. */

#define CAP_SETFCAP 31

/* Override MAC access.
   The base kernel enforces no MAC policy.
   An LSM may enforce a MAC policy, and if it does and it chooses
   to implement capability based overrides of that policy, this is
   the capability it should use to do so. */

#define CAP_MAC_OVERRIDE 32

/* Allow MAC configuration or state changes.
   The base kernel requires no MAC configuration.
   An LSM may enforce a MAC policy, and if it does and it chooses
   to implement capability based checks on modifications to that
   policy or the data required to maintain it, this is the
   capability it should use to do so. */

#define CAP_MAC_ADMIN 33

/* Allow configuring the kernel's syslog (printk behaviour) */

#define CAP_SYSLOG 34

/* Allow triggering something that will wake the system */

#define CAP_WAKE_ALARM 35

/* Allow preventing system suspends */

#define CAP_BLOCK_SUSPEND 36

/* Allow reading the audit log via multicast netlink socket */

#define CAP_AUDIT_READ 37

/*
 * Allow system performance and observability privileged operations
 * using perf_events, i915_perf and other kernel subsystems
 */

#define CAP_PERFMON 38

/*
 * CAP_BPF allows the following BPF operations:
 * - Creating all types of BPF maps
 * - Advanced verifier features
 *   - Indirect variable access
 *   - Bounded loops
 *   - BPF to BPF function calls
 *   - Scalar precision tracking
 *   - Larger complexity limits
 *   - Dead code elimination
 *   - And potentially other features
 * - Loading BPF Type Format (BTF) data
 * - Retrieve xlated and JITed code of BPF programs
 * - Use bpf_spin_lock() helper
 *
 * CAP_PERFMON relaxes the verifier checks further:
 * - BPF progs can use of pointer-to-integer conversions
 * - speculation attack hardening measures are bypassed
 * - bpf_probe_read to read arbitrary kernel memory is allowed
 * - bpf_trace_printk to print kernel memory is allowed
 *
 * CAP_SYS_ADMIN is required to use bpf_probe_write_user.
 *
 * CAP_SYS_ADMIN is required to iterate system wide loaded
 * programs, maps, links, BTFs and convert their IDs to file descriptors.
 *
 * CAP_PERFMON and CAP_BPF are required to load tracing programs.
 * CAP_NET_ADMIN and CAP_BPF are required to load networking programs.
 */
#define CAP_BPF 39

/* Allow checkpoint/restore related operations */
/* Allow PID selection during clone3() */
/* Allow writing to ns_last_pid */

#define CAP_CHECKPOINT_RESTORE 40

#define CAP_LAST_CAP CAP_CHECKPOINT_RESTORE

#define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)

/*
 * Bit location of each capability (used by user-space library and kernel)
 */

#define CAP_TO_INDEX(x) ((x) >> 5) /* 1 << 5 == bits in __u32 */
#define CAP_TO_MASK(x) (1U << ((x)&31)) /* mask for indexed __u32 */

#endif
```

`kernel/linux/include/uapi/linux/magic.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef __LINUX_MAGIC_H__
#define __LINUX_MAGIC_H__

#define ADFS_SUPER_MAGIC 0xadf5
#define AFFS_SUPER_MAGIC 0xadff
#define AFS_SUPER_MAGIC 0x5346414F
#define AUTOFS_SUPER_MAGIC 0x0187
#define CEPH_SUPER_MAGIC 0x00c36400
#define CODA_SUPER_MAGIC 0x73757245
#define CRAMFS_MAGIC 0x28cd3d45 /* some random number */
#define CRAMFS_MAGIC_WEND 0x453dcd28 /* magic number with the wrong endianess */
#define DEBUGFS_MAGIC 0x64626720
#define SECURITYFS_MAGIC 0x73636673
#define SELINUX_MAGIC 0xf97cff8c
#define SMACK_MAGIC 0x43415d53 /* "SMAC" */
#define RAMFS_MAGIC 0x858458f6 /* some random number */
#define TMPFS_MAGIC 0x01021994
#define HUGETLBFS_MAGIC 0x958458f6 /* some random number */
#define SQUASHFS_MAGIC 0x73717368
#define ECRYPTFS_SUPER_MAGIC 0xf15f
#define EFS_SUPER_MAGIC 0x414A53
#define EROFS_SUPER_MAGIC_V1 0xE0F5E1E2
#define EXT2_SUPER_MAGIC 0xEF53
#define EXT3_SUPER_MAGIC 0xEF53
#define XENFS_SUPER_MAGIC 0xabba1974
#define EXT4_SUPER_MAGIC 0xEF53
#define BTRFS_SUPER_MAGIC 0x9123683E
#define NILFS_SUPER_MAGIC 0x3434
#define F2FS_SUPER_MAGIC 0xF2F52010
#define HPFS_SUPER_MAGIC 0xf995e849
#define ISOFS_SUPER_MAGIC 0x9660
#define JFFS2_SUPER_MAGIC 0x72b6
#define XFS_SUPER_MAGIC 0x58465342 /* "XFSB" */
#define PSTOREFS_MAGIC 0x6165676C
#define EFIVARFS_MAGIC 0xde5e81e4
#define HOSTFS_SUPER_MAGIC 0x00c0ffee
#define OVERLAYFS_SUPER_MAGIC 0x794c7630
#define FUSE_SUPER_MAGIC 0x65735546

#define MINIX_SUPER_MAGIC 0x137F /* minix v1 fs, 14 char names */
#define MINIX_SUPER_MAGIC2 0x138F /* minix v1 fs, 30 char names */
#define MINIX2_SUPER_MAGIC 0x2468 /* minix v2 fs, 14 char names */
#define MINIX2_SUPER_MAGIC2 0x2478 /* minix v2 fs, 30 char names */
#define MINIX3_SUPER_MAGIC 0x4d5a /* minix v3 fs, 60 char names */

#define MSDOS_SUPER_MAGIC 0x4d44 /* MD */
#define EXFAT_SUPER_MAGIC 0x2011BAB0
#define NCP_SUPER_MAGIC 0x564c /* Guess, what 0x564c is :-) */
#define NFS_SUPER_MAGIC 0x6969
#define OCFS2_SUPER_MAGIC 0x7461636f
#define OPENPROM_SUPER_MAGIC 0x9fa1
#define QNX4_SUPER_MAGIC 0x002f /* qnx4 fs detection */
#define QNX6_SUPER_MAGIC 0x68191122 /* qnx6 fs detection */
#define AFS_FS_MAGIC 0x6B414653

#define REISERFS_SUPER_MAGIC 0x52654973 /* used by gcc */
/* used by file system utilities that
	                                   look at the superblock, etc.  */
#define REISERFS_SUPER_MAGIC_STRING "ReIsErFs"
#define REISER2FS_SUPER_MAGIC_STRING "ReIsEr2Fs"
#define REISER2FS_JR_SUPER_MAGIC_STRING "ReIsEr3Fs"

#define SMB_SUPER_MAGIC 0x517B
#define CIFS_SUPER_MAGIC 0xFF534D42 /* the first four bytes of SMB PDUs */
#define SMB2_SUPER_MAGIC 0xFE534D42

#define CGROUP_SUPER_MAGIC 0x27e0eb
#define CGROUP2_SUPER_MAGIC 0x63677270

#define RDTGROUP_SUPER_MAGIC 0x7655821

#define STACK_END_MAGIC 0x57AC6E9D

#define TRACEFS_MAGIC 0x74726163

#define V9FS_MAGIC 0x01021997

#define BDEVFS_MAGIC 0x62646576
#define DAXFS_MAGIC 0x64646178
#define BINFMTFS_MAGIC 0x42494e4d
#define DEVPTS_SUPER_MAGIC 0x1cd1
#define BINDERFS_SUPER_MAGIC 0x6c6f6f70
#define FUTEXFS_SUPER_MAGIC 0xBAD1DEA
#define PIPEFS_MAGIC 0x50495045
#define PROC_SUPER_MAGIC 0x9fa0
#define SOCKFS_MAGIC 0x534F434B
#define SYSFS_MAGIC 0x62656572
#define USBDEVICE_SUPER_MAGIC 0x9fa2
#define MTD_INODE_FS_MAGIC 0x11307854
#define ANON_INODE_FS_MAGIC 0x09041934
#define BTRFS_TEST_MAGIC 0x73727279
#define NSFS_MAGIC 0x6e736673
#define BPF_FS_MAGIC 0xcafe4a11
#define AAFS_MAGIC 0x5a3c69f0
#define ZONEFS_MAGIC 0x5a4f4653

/* Since UDF 2.01 is ISO 13346 based... */
#define UDF_SUPER_MAGIC 0x15013346
#define DMA_BUF_MAGIC 0x444d4142 /* "DMAB" */
#define DEVMEM_MAGIC 0x454d444d /* "DMEM" */
#define SECRETMEM_MAGIC 0x5345434d /* "SECM" */

#endif /* __LINUX_MAGIC_H__ */
```

`kernel/linux/include/uapi/linux/prctl.h`:

```h
#ifndef _LINUX_PRCTL_H
#define _LINUX_PRCTL_H

/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */

#include <ktypes.h>

/* Values to pass as first argument to prctl() */

#define PR_SET_PDEATHSIG 1 /* Second arg is a signal */
#define PR_GET_PDEATHSIG 2 /* Second arg is a ptr to return the signal */

/* Get/set current->mm->dumpable */
#define PR_GET_DUMPABLE 3
#define PR_SET_DUMPABLE 4

/* Get/set unaligned access control bits (if meaningful) */
#define PR_GET_UNALIGN 5
#define PR_SET_UNALIGN 6
#define PR_UNALIGN_NOPRINT 1 /* silently fix up unaligned user accesses */
#define PR_UNALIGN_SIGBUS 2 /* generate SIGBUS on unaligned user access */

/* Get/set whether or not to drop capabilities on setuid() away from
 * uid 0 (as per security/commoncap.c) */
#define PR_GET_KEEPCAPS 7
#define PR_SET_KEEPCAPS 8

/* Get/set floating-point emulation control bits (if meaningful) */
#define PR_GET_FPEMU 9
#define PR_SET_FPEMU 10
#define PR_FPEMU_NOPRINT 1 /* silently emulate fp operations accesses */
#define PR_FPEMU_SIGFPE 2 /* don't emulate fp operations, send SIGFPE instead */

/* Get/set floating-point exception mode (if meaningful) */
#define PR_GET_FPEXC 11
#define PR_SET_FPEXC 12
#define PR_FP_EXC_SW_ENABLE 0x80 /* Use FPEXC for FP exception enables */
#define PR_FP_EXC_DIV 0x010000 /* floating point divide by zero */
#define PR_FP_EXC_OVF 0x020000 /* floating point overflow */
#define PR_FP_EXC_UND 0x040000 /* floating point underflow */
#define PR_FP_EXC_RES 0x080000 /* floating point inexact result */
#define PR_FP_EXC_INV 0x100000 /* floating point invalid operation */
#define PR_FP_EXC_DISABLED 0 /* FP exceptions disabled */
#define PR_FP_EXC_NONRECOV 1 /* async non-recoverable exc. mode */
#define PR_FP_EXC_ASYNC 2 /* async recoverable exception mode */
#define PR_FP_EXC_PRECISE 3 /* precise exception mode */

/* Get/set whether we use statistical process timing or accurate timestamp
 * based process timing */
#define PR_GET_TIMING 13
#define PR_SET_TIMING 14
#define PR_TIMING_STATISTICAL \
    0 /* Normal, traditional,
                                                   statistical process timing */
#define PR_TIMING_TIMESTAMP \
    1 /* Accurate timestamp based
                                                   process timing */

#define PR_SET_NAME 15 /* Set process name */
#define PR_GET_NAME 16 /* Get process name */

/* Get/set process endian */
#define PR_GET_ENDIAN 19
#define PR_SET_ENDIAN 20
#define PR_ENDIAN_BIG 0
#define PR_ENDIAN_LITTLE 1 /* True little endian mode */
#define PR_ENDIAN_PPC_LITTLE 2 /* "PowerPC" pseudo little endian */

/* Get/set process seccomp mode */
#define PR_GET_SECCOMP 21
#define PR_SET_SECCOMP 22

/* Get/set the capability bounding set (as per security/commoncap.c) */
#define PR_CAPBSET_READ 23
#define PR_CAPBSET_DROP 24

/* Get/set the process' ability to use the timestamp counter instruction */
#define PR_GET_TSC 25
#define PR_SET_TSC 26
#define PR_TSC_ENABLE 1 /* allow the use of the timestamp counter */
#define PR_TSC_SIGSEGV 2 /* throw a SIGSEGV instead of reading the TSC */

/* Get/set securebits (as per security/commoncap.c) */
#define PR_GET_SECUREBITS 27
#define PR_SET_SECUREBITS 28

/*
 * Get/set the timerslack as used by poll/select/nanosleep
 * A value of 0 means "use default"
 */
#define PR_SET_TIMERSLACK 29
#define PR_GET_TIMERSLACK 30

#define PR_TASK_PERF_EVENTS_DISABLE 31
#define PR_TASK_PERF_EVENTS_ENABLE 32

/*
 * Set early/late kill mode for hwpoison memory corruption.
 * This influences when the process gets killed on a memory corruption.
 */
#define PR_MCE_KILL 33
#define PR_MCE_KILL_CLEAR 0
#define PR_MCE_KILL_SET 1

#define PR_MCE_KILL_LATE 0
#define PR_MCE_KILL_EARLY 1
#define PR_MCE_KILL_DEFAULT 2

#define PR_MCE_KILL_GET 34

/*
 * Tune up process memory map specifics.
 */
#define PR_SET_MM 35
#define PR_SET_MM_START_CODE 1
#define PR_SET_MM_END_CODE 2
#define PR_SET_MM_START_DATA 3
#define PR_SET_MM_END_DATA 4
#define PR_SET_MM_START_STACK 5
#define PR_SET_MM_START_BRK 6
#define PR_SET_MM_BRK 7
#define PR_SET_MM_ARG_START 8
#define PR_SET_MM_ARG_END 9
#define PR_SET_MM_ENV_START 10
#define PR_SET_MM_ENV_END 11
#define PR_SET_MM_AUXV 12
#define PR_SET_MM_EXE_FILE 13
#define PR_SET_MM_MAP 14
#define PR_SET_MM_MAP_SIZE 15

/*
 * This structure provides new memory descriptor
 * map which mostly modifies /proc/pid/stat[m]
 * output for a task. This mostly done in a
 * sake of checkpoint/restore functionality.
 */
struct prctl_mm_map
{
    __u64 start_code; /* code section bounds */
    __u64 end_code;
    __u64 start_data; /* data section bounds */
    __u64 end_data;
    __u64 start_brk; /* heap for brk() syscall */
    __u64 brk;
    __u64 start_stack; /* stack starts at */
    __u64 arg_start; /* command line arguments bounds */
    __u64 arg_end;
    __u64 env_start; /* environment variables bounds */
    __u64 env_end;
    __u64 *auxv; /* auxiliary vector */
    __u32 auxv_size; /* vector size */
    __u32 exe_fd; /* /proc/$pid/exe link file */
};

/*
 * Set specific pid that is allowed to ptrace the current task.
 * A value of 0 mean "no process".
 */
#define PR_SET_PTRACER 0x59616d61
#define PR_SET_PTRACER_ANY ((unsigned long)-1)

#define PR_SET_CHILD_SUBREAPER 36
#define PR_GET_CHILD_SUBREAPER 37

/*
 * If no_new_privs is set, then operations that grant new privileges (i.e.
 * execve) will either fail or not grant them.  This affects suid/sgid,
 * file capabilities, and LSMs.
 *
 * Operations that merely manipulate or drop existing privileges (setresuid,
 * capset, etc.) will still work.  Drop those privileges if you want them gone.
 *
 * Changing LSM security domain is considered a new privilege.  So, for example,
 * asking selinux for a specific new context (e.g. with runcon) will result
 * in execve returning -EPERM.
 *
 * See Documentation/userspace-api/no_new_privs.rst for more details.
 */
#define PR_SET_NO_NEW_PRIVS 38
#define PR_GET_NO_NEW_PRIVS 39

#define PR_GET_TID_ADDRESS 40

#define PR_SET_THP_DISABLE 41
#define PR_GET_THP_DISABLE 42

/*
 * No longer implemented, but left here to ensure the numbers stay reserved:
 */
#define PR_MPX_ENABLE_MANAGEMENT 43
#define PR_MPX_DISABLE_MANAGEMENT 44

#define PR_SET_FP_MODE 45
#define PR_GET_FP_MODE 46
#define PR_FP_MODE_FR (1 << 0) /* 64b FP registers */
#define PR_FP_MODE_FRE (1 << 1) /* 32b compatibility */

/* Control the ambient capability set */
#define PR_CAP_AMBIENT 47
#define PR_CAP_AMBIENT_IS_SET 1
#define PR_CAP_AMBIENT_RAISE 2
#define PR_CAP_AMBIENT_LOWER 3
#define PR_CAP_AMBIENT_CLEAR_ALL 4

/* arm64 Scalable Vector Extension controls */
/* Flag values must be kept in sync with ptrace NT_ARM_SVE interface */
#define PR_SVE_SET_VL 50 /* set task vector length */
#define PR_SVE_SET_VL_ONEXEC (1 << 18) /* defer effect until exec */
#define PR_SVE_GET_VL 51 /* get task vector length */
/* Bits common to PR_SVE_SET_VL and PR_SVE_GET_VL */
#define PR_SVE_VL_LEN_MASK 0xffff
#define PR_SVE_VL_INHERIT (1 << 17) /* inherit across exec */

/* Per task speculation control */
#define PR_GET_SPECULATION_CTRL 52
#define PR_SET_SPECULATION_CTRL 53
/* Speculation control variants */
#define PR_SPEC_STORE_BYPASS 0
#define PR_SPEC_INDIRECT_BRANCH 1
#define PR_SPEC_L1D_FLUSH 2
/* Return and control values for PR_SET/GET_SPECULATION_CTRL */
#define PR_SPEC_NOT_AFFECTED 0
#define PR_SPEC_PRCTL (1UL << 0)
#define PR_SPEC_ENABLE (1UL << 1)
#define PR_SPEC_DISABLE (1UL << 2)
#define PR_SPEC_FORCE_DISABLE (1UL << 3)
#define PR_SPEC_DISABLE_NOEXEC (1UL << 4)

/* Reset arm64 pointer authentication keys */
#define PR_PAC_RESET_KEYS 54
#define PR_PAC_APIAKEY (1UL << 0)
#define PR_PAC_APIBKEY (1UL << 1)
#define PR_PAC_APDAKEY (1UL << 2)
#define PR_PAC_APDBKEY (1UL << 3)
#define PR_PAC_APGAKEY (1UL << 4)

/* Tagged user address controls for arm64 */
#define PR_SET_TAGGED_ADDR_CTRL 55
#define PR_GET_TAGGED_ADDR_CTRL 56
#define PR_TAGGED_ADDR_ENABLE (1UL << 0)
/* MTE tag check fault modes */
#define PR_MTE_TCF_NONE 0UL
#define PR_MTE_TCF_SYNC (1UL << 1)
#define PR_MTE_TCF_ASYNC (1UL << 2)
#define PR_MTE_TCF_MASK (PR_MTE_TCF_SYNC | PR_MTE_TCF_ASYNC)
/* MTE tag inclusion mask */
#define PR_MTE_TAG_SHIFT 3
#define PR_MTE_TAG_MASK (0xffffUL << PR_MTE_TAG_SHIFT)
/* Unused; kept only for source compatibility */
#define PR_MTE_TCF_SHIFT 1

/* Control reclaim behavior when allocating memory */
#define PR_SET_IO_FLUSHER 57
#define PR_GET_IO_FLUSHER 58

/* Dispatch syscalls to a userspace handler */
#define PR_SET_SYSCALL_USER_DISPATCH 59
#define PR_SYS_DISPATCH_OFF 0
#define PR_SYS_DISPATCH_ON 1
/* The control values for the user space selector when dispatch is enabled */
#define SYSCALL_DISPATCH_FILTER_ALLOW 0
#define SYSCALL_DISPATCH_FILTER_BLOCK 1

/* Set/get enabled arm64 pointer authentication keys */
#define PR_PAC_SET_ENABLED_KEYS 60
#define PR_PAC_GET_ENABLED_KEYS 61

/* Request the scheduler to share a core */
#define PR_SCHED_CORE 62
#define PR_SCHED_CORE_GET 0
#define PR_SCHED_CORE_CREATE 1 /* create unique core_sched cookie */
#define PR_SCHED_CORE_SHARE_TO 2 /* push core_sched cookie to pid */
#define PR_SCHED_CORE_SHARE_FROM 3 /* pull core_sched cookie to pid */
#define PR_SCHED_CORE_MAX 4
#define PR_SCHED_CORE_SCOPE_THREAD 0
#define PR_SCHED_CORE_SCOPE_THREAD_GROUP 1
#define PR_SCHED_CORE_SCOPE_PROCESS_GROUP 2

/* arm64 Scalable Matrix Extension controls */
/* Flag values must be in sync with SVE versions */
#define PR_SME_SET_VL 63 /* set task vector length */
#define PR_SME_SET_VL_ONEXEC (1 << 18) /* defer effect until exec */
#define PR_SME_GET_VL 64 /* get task vector length */
/* Bits common to PR_SME_SET_VL and PR_SME_GET_VL */
#define PR_SME_VL_LEN_MASK 0xffff
#define PR_SME_VL_INHERIT (1 << 17) /* inherit across exec */

/* Memory deny write / execute */
#define PR_SET_MDWE 65
#define PR_MDWE_REFUSE_EXEC_GAIN 1

#define PR_GET_MDWE 66

#define PR_SET_VMA 0x53564d41
#define PR_SET_VMA_ANON_NAME 0

#endif /* _LINUX_PRCTL_H */
```

`kernel/linux/include/vdso/limits.h`:

```h
#ifndef __VDSO_LIMITS_H
#define __VDSO_LIMITS_H

#define USHRT_MAX ((unsigned short)~0U)
#define SHRT_MAX ((short)(USHRT_MAX >> 1))
#define SHRT_MIN ((short)(-SHRT_MAX - 1))
#define INT_MAX ((int)(~0U >> 1))
#define INT_MIN (-INT_MAX - 1)
#define UINT_MAX (~0U)
#define LONG_MAX ((long)(~0UL >> 1))
#define LONG_MIN (-LONG_MAX - 1)
#define ULONG_MAX (~0UL)
#define LLONG_MAX ((long long)(~0ULL >> 1))
#define LLONG_MIN (-LLONG_MAX - 1)
#define ULLONG_MAX (~0ULL)
#define UINTPTR_MAX ULONG_MAX

#endif
```

`kernel/linux/security/selinux/include/avc.h`:

```h
#ifndef _SELINUX_AVC_H_
#define _SELINUX_AVC_H_

#include <ktypes.h>
#include <ksyms.h>

struct avc_entry;

struct task_struct;
struct inode;
struct sock;
struct sk_buff;
struct common_audit_data;
struct av_decision;

/*
 * We only need this data after we have decided to send an audit message.
 */
struct selinux_audit_data
{
    u32 ssid;
    u32 tsid;
    u16 tclass;
    u32 requested;
    u32 audited;
    u32 denied;
    int result;
    struct selinux_state *state;
};

#define AVC_STRICT 1 /* Ignore permissive mode. */
#define AVC_EXTENDED_PERMS 2 /* update extended permissions */
#define AVC_NONBLOCKING 4 /* non blocking */

extern int kfunc_def(avc_denied)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 xperm, unsigned int flags,
                                 struct av_decision *avd);
extern int kfunc_def(avc_has_perm_noaudit)(u32 ssid, u32 tsid, u16 tclass, u32 requested, unsigned flags,
                                           struct av_decision *avd);
extern int kfunc_def(avc_has_perm)(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common_audit_data *auditdata);
extern int kfunc_def(avc_has_perm_flags)(u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                         struct common_audit_data *auditdata, int flags);
extern int kfunc_def(avc_has_extended_perms)(u32 ssid, u32 tsid, u16 tclass, u32 requested, u8 driver, u8 perm,
                                             struct common_audit_data *ad);

#define kfunc_def_compat(func) kfunc_def(func##_compat)

typedef int kfunc_def_compat(avc_denied)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                         u8 driver, u8 xperm, unsigned int flags, struct av_decision *avd);
typedef int kfunc_def_compat(avc_has_perm_noaudit)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                   u32 requested, unsigned flags, struct av_decision *avd);
typedef int kfunc_def_compat(avc_has_perm)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass, u32 requested,
                                           struct common_audit_data *auditdata);
typedef int kfunc_def_compat(avc_has_perm_flags)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                 u32 requested, struct common_audit_data *auditdata, int flags);
typedef int kfunc_def_compat(avc_has_extended_perms)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                     u32 requested, u8 driver, u8 perm, struct common_audit_data *ad);

#endif
```

`kernel/linux/security/selinux/include/avc_ss.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Access vector cache interface for the security server.
 *
 * Author : Stephen Smalley, <sds@tycho.nsa.gov>
 */
#ifndef _SELINUX_AVC_SS_H_
#define _SELINUX_AVC_SS_H_

#include <ktypes.h>

int avc_ss_reset(u32 seqno);

/* Class/perm mapping support */
struct security_class_mapping
{
    const char *name;
    const char *perms[sizeof(u32) * 8 + 1];
};

extern const struct security_class_mapping secclass_map[];

#endif /* _SELINUX_AVC_SS_H_ */
```

`kernel/linux/security/selinux/include/classmap.h`:

```h
#ifndef _SELINUX_CLASSMAP_H_
#define _SELINUX_CLASSMAP_H_

#include <security/selinux/include/avc_ss.h>
#include <ksyms.h>

extern struct security_class_mapping kvar_def(secclass_map)[];

// todo: relocat needed
/*
#define COMMON_FILE_SOCK_PERMS \
    "ioctl", "read", "write", "create", "getattr", "setattr", "lock", "relabelfrom", "relabelto", "append", "map"

#define COMMON_FILE_PERMS                                                                                        \
    COMMON_FILE_SOCK_PERMS, "unlink", "link", "rename", "execute", "quotaon", "mounton", "audit_access", "open", \
        "execmod", "watch", "watch_mount", "watch_sb", "watch_with_perm", "watch_reads"

#define COMMON_SOCK_PERMS                                                                                      \
    COMMON_FILE_SOCK_PERMS, "bind", "connect", "listen", "accept", "getopt", "setopt", "shutdown", "recvfrom", \
        "sendto", "name_bind"

#define COMMON_IPC_PERMS \
    "create", "destroy", "getattr", "setattr", "read", "write", "associate", "unix_read", "unix_write"

#define COMMON_CAP_PERMS                                                                                         \
    "chown", "dac_override", "dac_read_search", "fowner", "fsetid", "kill", "setgid", "setuid", "setpcap",       \
        "linux_immutable", "net_bind_service", "net_broadcast", "net_admin", "net_raw", "ipc_lock", "ipc_owner", \
        "sys_module", "sys_rawio", "sys_chroot", "sys_ptrace", "sys_pacct", "sys_admin", "sys_boot", "sys_nice", \
        "sys_resource", "sys_time", "sys_tty_config", "mknod", "lease", "audit_write", "audit_control", "setfcap"

#define COMMON_CAP2_PERMS                                                                                 \
    "mac_override", "mac_admin", "syslog", "wake_alarm", "block_suspend", "audit_read", "perfmon", "bpf", \
        "checkpoint_restore"

#if CAP_LAST_CAP > CAP_CHECKPOINT_RESTORE
#error New capability defined, please update COMMON_CAP2_PERMS.
#endif

const struct security_class_mapping secclass_map[] = {
    { "security",
      { "compute_av", "compute_create", "compute_member", "check_context", "load_policy", "compute_relabel",
        "compute_user", "setenforce", "setbool", "setsecparam", "setcheckreqprot", "read_policy", "validate_trans",
        NULL } },
    { "process",
      { "fork",         "transition",    "sigchld",       "sigkill",    "sigstop",     "signull",    "signal",
        "ptrace",       "getsched",      "setsched",      "getsession", "getpgid",     "setpgid",    "getcap",
        "setcap",       "share",         "getattr",       "setexec",    "setfscreate", "noatsecure", "siginh",
        "setrlimit",    "rlimitinh",     "dyntransition", "setcurrent", "execmem",     "execstack",  "execheap",
        "setkeycreate", "setsockcreate", "getrlimit",     NULL } },
    { "process2", { "nnp_transition", "nosuid_transition", NULL } },
    { "system", { "ipc_info", "syslog_read", "syslog_mod", "syslog_console", "module_request", "module_load", NULL } },
    { "capability", { COMMON_CAP_PERMS, NULL } },
    { "filesystem",
      { "mount", "remount", "unmount", "getattr", "relabelfrom", "relabelto", "associate", "quotamod", "quotaget",
        "watch", NULL } },
    { "file", { COMMON_FILE_PERMS, "execute_no_trans", "entrypoint", NULL } },
    { "dir", { COMMON_FILE_PERMS, "add_name", "remove_name", "reparent", "search", "rmdir", NULL } },
    { "fd", { "use", NULL } },
    { "lnk_file", { COMMON_FILE_PERMS, NULL } },
    { "chr_file", { COMMON_FILE_PERMS, NULL } },
    { "blk_file", { COMMON_FILE_PERMS, NULL } },
    { "sock_file", { COMMON_FILE_PERMS, NULL } },
    { "fifo_file", { COMMON_FILE_PERMS, NULL } },
    { "socket", { COMMON_SOCK_PERMS, NULL } },
    { "tcp_socket", { COMMON_SOCK_PERMS, "node_bind", "name_connect", NULL } },
    { "udp_socket", { COMMON_SOCK_PERMS, "node_bind", NULL } },
    { "rawip_socket", { COMMON_SOCK_PERMS, "node_bind", NULL } },
    { "node", { "recvfrom", "sendto", NULL } },
    { "netif", { "ingress", "egress", NULL } },
    { "netlink_socket", { COMMON_SOCK_PERMS, NULL } },
    { "packet_socket", { COMMON_SOCK_PERMS, NULL } },
    { "key_socket", { COMMON_SOCK_PERMS, NULL } },
    { "unix_stream_socket", { COMMON_SOCK_PERMS, "connectto", NULL } },
    { "unix_dgram_socket", { COMMON_SOCK_PERMS, NULL } },
    { "sem", { COMMON_IPC_PERMS, NULL } },
    { "msg", { "send", "receive", NULL } },
    { "msgq", { COMMON_IPC_PERMS, "enqueue", NULL } },
    { "shm", { COMMON_IPC_PERMS, "lock", NULL } },
    { "ipc", { COMMON_IPC_PERMS, NULL } },
    { "netlink_route_socket", { COMMON_SOCK_PERMS, "nlmsg_read", "nlmsg_write", NULL } },
    { "netlink_tcpdiag_socket", { COMMON_SOCK_PERMS, "nlmsg_read", "nlmsg_write", NULL } },
    { "netlink_nflog_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_xfrm_socket", { COMMON_SOCK_PERMS, "nlmsg_read", "nlmsg_write", NULL } },
    { "netlink_selinux_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_iscsi_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_audit_socket",
      { COMMON_SOCK_PERMS, "nlmsg_read", "nlmsg_write", "nlmsg_relay", "nlmsg_readpriv", "nlmsg_tty_audit", NULL } },
    { "netlink_fib_lookup_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_connector_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_netfilter_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_dnrt_socket", { COMMON_SOCK_PERMS, NULL } },
    { "association", { "sendto", "recvfrom", "setcontext", "polmatch", NULL } },
    { "netlink_kobject_uevent_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_generic_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_scsitransport_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_rdma_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netlink_crypto_socket", { COMMON_SOCK_PERMS, NULL } },
    { "appletalk_socket", { COMMON_SOCK_PERMS, NULL } },
    { "packet", { "send", "recv", "relabelto", "forward_in", "forward_out", NULL } },
    { "key", { "view", "read", "write", "search", "link", "setattr", "create", NULL } },
    { "dccp_socket", { COMMON_SOCK_PERMS, "node_bind", "name_connect", NULL } },
    { "memprotect", { "mmap_zero", NULL } },
    { "peer", { "recv", NULL } },
    { "capability2", { COMMON_CAP2_PERMS, NULL } },
    { "kernel_service", { "use_as_override", "create_files_as", NULL } },
    { "tun_socket", { COMMON_SOCK_PERMS, "attach_queue", NULL } },
    { "binder", { "impersonate", "call", "set_context_mgr", "transfer", NULL } },
    { "cap_userns", { COMMON_CAP_PERMS, NULL } },
    { "cap2_userns", { COMMON_CAP2_PERMS, NULL } },
    { "sctp_socket", { COMMON_SOCK_PERMS, "node_bind", "name_connect", "association", NULL } },
    { "icmp_socket", { COMMON_SOCK_PERMS, "node_bind", NULL } },
    { "ax25_socket", { COMMON_SOCK_PERMS, NULL } },
    { "ipx_socket", { COMMON_SOCK_PERMS, NULL } },
    { "netrom_socket", { COMMON_SOCK_PERMS, NULL } },
    { "atmpvc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "x25_socket", { COMMON_SOCK_PERMS, NULL } },
    { "rose_socket", { COMMON_SOCK_PERMS, NULL } },
    { "decnet_socket", { COMMON_SOCK_PERMS, NULL } },
    { "atmsvc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "rds_socket", { COMMON_SOCK_PERMS, NULL } },
    { "irda_socket", { COMMON_SOCK_PERMS, NULL } },
    { "pppox_socket", { COMMON_SOCK_PERMS, NULL } },
    { "llc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "can_socket", { COMMON_SOCK_PERMS, NULL } },
    { "tipc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "bluetooth_socket", { COMMON_SOCK_PERMS, NULL } },
    { "iucv_socket", { COMMON_SOCK_PERMS, NULL } },
    { "rxrpc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "isdn_socket", { COMMON_SOCK_PERMS, NULL } },
    { "phonet_socket", { COMMON_SOCK_PERMS, NULL } },
    { "ieee802154_socket", { COMMON_SOCK_PERMS, NULL } },
    { "caif_socket", { COMMON_SOCK_PERMS, NULL } },
    { "alg_socket", { COMMON_SOCK_PERMS, NULL } },
    { "nfc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "vsock_socket", { COMMON_SOCK_PERMS, NULL } },
    { "kcm_socket", { COMMON_SOCK_PERMS, NULL } },
    { "qipcrtr_socket", { COMMON_SOCK_PERMS, NULL } },
    { "smc_socket", { COMMON_SOCK_PERMS, NULL } },
    { "infiniband_pkey", { "access", NULL } },
    { "infiniband_endport", { "manage_subnet", NULL } },
    { "bpf", { "map_create", "map_read", "map_write", "prog_load", "prog_run", NULL } },
    { "xdp_socket", { COMMON_SOCK_PERMS, NULL } },
    { "mctp_socket", { COMMON_SOCK_PERMS, NULL } },
    { "perf_event", { "open", "cpu", "kernel", "tracepoint", "read", "write", NULL } },
    { "anon_inode", { COMMON_FILE_PERMS, NULL } },
    { "io_uring", { "override_creds", "sqpoll", "cmd", NULL } },
    { "user_namespace", { "create", NULL } },
    { NULL }
};

#if PF_MAX > 46
#error New address family defined, please update secclass_map.
#endif

*/

#endif
```

`kernel/linux/security/selinux/include/security.h`:

```h
#ifndef _SELINUX_SECURITY_H_
#define _SELINUX_SECURITY_H_

#include <ktypes.h>
#include <ksyms.h>
#include <common.h>

#define SECSID_NULL 0x00000000 /* unspecified SID */
#define SECSID_WILD 0xffffffff /* wildcard SID */
#define SECCLASS_NULL 0x0000 /* no class */

/* Identify specific policy version changes */
#define POLICYDB_VERSION_BASE 15
#define POLICYDB_VERSION_BOOL 16
#define POLICYDB_VERSION_IPV6 17
#define POLICYDB_VERSION_NLCLASS 18
#define POLICYDB_VERSION_VALIDATETRANS 19
#define POLICYDB_VERSION_MLS 19
#define POLICYDB_VERSION_AVTAB 20
#define POLICYDB_VERSION_RANGETRANS 21
#define POLICYDB_VERSION_POLCAP 22
#define POLICYDB_VERSION_PERMISSIVE 23
#define POLICYDB_VERSION_BOUNDARY 24
#define POLICYDB_VERSION_FILENAME_TRANS 25
#define POLICYDB_VERSION_ROLETRANS 26
#define POLICYDB_VERSION_NEW_OBJECT_DEFAULTS 27
#define POLICYDB_VERSION_DEFAULT_TYPE 28
#define POLICYDB_VERSION_CONSTRAINT_NAMES 29
#define POLICYDB_VERSION_XPERMS_IOCTL 30
#define POLICYDB_VERSION_INFINIBAND 31
#define POLICYDB_VERSION_GLBLUB 32
#define POLICYDB_VERSION_COMP_FTRANS 33 /* compressed filename transitions */

/* Range of policy versions we understand*/
#define POLICYDB_VERSION_MIN POLICYDB_VERSION_BASE
#define POLICYDB_VERSION_MAX POLICYDB_VERSION_COMP_FTRANS

/* Mask for just the mount related flags */
#define SE_MNTMASK 0x0f
/* Super block security struct flags for mount options */
/* BE CAREFUL, these need to be the low order bits for selinux_get_mnt_opts */
#define CONTEXT_MNT 0x01
#define FSCONTEXT_MNT 0x02
#define ROOTCONTEXT_MNT 0x04
#define DEFCONTEXT_MNT 0x08
#define SBLABEL_MNT 0x10
/* Non-mount related flags */
#define SE_SBINITIALIZED 0x0100
#define SE_SBPROC 0x0200
#define SE_SBGENFS 0x0400
#define SE_SBGENFS_XATTR 0x0800

#define CONTEXT_STR "context"
#define FSCONTEXT_STR "fscontext"
#define ROOTCONTEXT_STR "rootcontext"
#define DEFCONTEXT_STR "defcontext"
#define SECLABEL_STR "seclabel"

struct selinux_policy;
struct selinux_policy_convert_data;

struct selinux_load_state
{
    struct selinux_policy *policy;
    struct selinux_policy_convert_data *convert_data;
};

#define SEL_VEC_MAX 32
struct av_decision
{
    u32 allowed;
    u32 auditallow;
    u32 auditdeny;
    u32 seqno;
    u32 flags;
};

#define XPERMS_ALLOWED 1
#define XPERMS_AUDITALLOW 2
#define XPERMS_DONTAUDIT 4

#define security_xperm_set(perms, x) ((perms)[(x) >> 5] |= 1 << ((x)&0x1f))
#define security_xperm_test(perms, x) (1 & ((perms)[(x) >> 5] >> ((x)&0x1f)))

struct extended_perms_data
{
    u32 p[8];
};

struct extended_perms_decision
{
    u8 used;
    u8 driver;
    struct extended_perms_data *allowed;
    struct extended_perms_data *auditallow;
    struct extended_perms_data *dontaudit;
};

struct extended_perms
{
    u16 len; /* length associated decision chain */
    struct extended_perms_data drivers; /* flag drivers that are used */
};

/* definitions of av_decision.flags */
#define AVD_FLAGS_PERMISSIVE 0x0001

struct qstr;
struct super_block;
struct netlbl_lsm_secattr;

#define SECURITY_FS_USE_XATTR 1 /* use xattr */
#define SECURITY_FS_USE_TRANS 2 /* use transition SIDs, e.g. devpts/tmpfs */
#define SECURITY_FS_USE_TASK 3 /* use task SIDs, e.g. pipefs/sockfs */
#define SECURITY_FS_USE_GENFS 4 /* use the genfs support */
#define SECURITY_FS_USE_NONE 5 /* no labeling support */
#define SECURITY_FS_USE_MNTPOINT 6 /* use mountpoint labeling */
#define SECURITY_FS_USE_NATIVE 7 /* use native label support */
#define SECURITY_FS_USE_MAX 7 /* Highest SECURITY_FS_USE_XXX */

#define SELINUX_KERNEL_STATUS_VERSION 1
struct selinux_kernel_status
{
    u32 version; /* version number of the structure */
    u32 sequence; /* sequence number of seqlock logic */
    u32 enforcing; /* current setting of enforcing mode */
    u32 policyload; /* times of policy reloaded */
    u32 deny_unknown; /* current setting of deny_unknown */
    /*
	 * The version > 0 supports above members.
	 */
} __packed;

extern int kvar_def(selinux_enabled_boot);
extern struct selinux_state kvar_def(selinux_state);
extern int kvar_def(selinux_enabled);

extern int kfunc_def(security_mls_enabled)(void);
extern int kfunc_def(security_load_policy)(void *data, size_t len, struct selinux_load_state *load_state);
extern void kfunc_def(selinux_policy_commit)(struct selinux_load_state *load_state);
extern void kfunc_def(selinux_policy_cancel)(struct selinux_load_state *load_state);
extern int kfunc_def(security_read_policy)(void **data, size_t *len);
extern int kfunc_def(security_read_state_kernel)(void **data, size_t *len);
extern int kfunc_def(security_policycap_supported)(unsigned int req_cap);
extern void kfunc_def(security_compute_av)(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd,
                                           struct extended_perms *xperms);
extern void kfunc_def(security_compute_xperms_decision)(u32 ssid, u32 tsid, u16 tclass, u8 driver,
                                                        struct extended_perms_decision *xpermd);
extern void kfunc_def(security_compute_av_user)(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd);
extern int kfunc_def(security_transition_sid)(u32 ssid, u32 tsid, u16 tclass, const struct qstr *qstr, u32 *out_sid);
extern int kfunc_def(security_transition_sid_user)(u32 ssid, u32 tsid, u16 tclass, const char *objname, u32 *out_sid);
extern int kfunc_def(security_member_sid)(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid);
extern int kfunc_def(security_change_sid)(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid);
extern int kfunc_def(security_sid_to_context)(u32 sid, char **scontext, u32 *scontext_len);
extern int kfunc_def(security_sid_to_context_force)(u32 sid, char **scontext, u32 *scontext_len);
extern int kfunc_def(security_sid_to_context_inval)(u32 sid, char **scontext, u32 *scontext_len);
extern int kfunc_def(security_context_to_sid)(const char *scontext, u32 scontext_len, u32 *out_sid, gfp_t gfp);
extern int kfunc_def(security_context_str_to_sid)(const char *scontext, u32 *out_sid, gfp_t gfp);
extern int kfunc_def(security_context_to_sid_default)(const char *scontext, u32 scontext_len, u32 *out_sid, u32 def_sid,
                                                      gfp_t gfp_flags);
extern int kfunc_def(security_context_to_sid_force)(const char *scontext, u32 scontext_len, u32 *sid);
extern int kfunc_def(security_get_user_sids)(u32 callsid, char *username, u32 **sids, u32 *nel);
extern int kfunc_def(security_port_sid)(u8 protocol, u16 port, u32 *out_sid);
extern int kfunc_def(security_ib_pkey_sid)(u64 subnet_prefix, u16 pkey_num, u32 *out_sid);
extern int kfunc_def(security_ib_endport_sid)(const char *dev_name, u8 port_num, u32 *out_sid);
extern int kfunc_def(security_netif_sid)(char *name, u32 *if_sid);
extern int kfunc_def(security_node_sid)(u16 domain, void *addr, u32 addrlen, u32 *out_sid);
extern int kfunc_def(security_validate_transition)(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass);
extern int kfunc_def(security_validate_transition_user)(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass);
extern int kfunc_def(security_bounded_transition)(u32 oldsid, u32 newsid);
extern int kfunc_def(security_sid_mls_copy)(u32 sid, u32 mls_sid, u32 *new_sid);
extern int kfunc_def(security_net_peersid_resolve)(u32 nlbl_sid, u32 nlbl_type, u32 xfrm_sid, u32 *peer_sid);
extern int kfunc_def(security_get_classes)(struct selinux_policy *policy, char ***classes, int *nclasses);
extern int kfunc_def(security_get_permissions)(struct selinux_policy *policy, char *class, char ***perms, int *nperms);
extern int kfunc_def(security_get_reject_unknown)(void);
extern int kfunc_def(security_get_allow_unknown)(void);

extern int kfunc_def(security_fs_use)(struct super_block *sb);
extern int kfunc_def(security_genfs_sid)(const char *fstype, const char *path, u16 sclass, u32 *sid);
extern int kfunc_def(selinux_policy_genfs_sid)(struct selinux_policy *policy, const char *fstype, const char *path,
                                               u16 sclass, u32 *sid);
extern int kfunc_def(security_netlbl_secattr_to_sid)(struct netlbl_lsm_secattr *secattr, u32 *sid);
extern int kfunc_def(security_netlbl_sid_to_secattr)(u32 sid, struct netlbl_lsm_secattr *secattr);
extern const char *kfunc_def(security_get_initial_sid_context)(u32 sid);

extern void kfunc_def(selinux_status_update_setenforce)(int enforcing);
extern void kfunc_def(selinux_status_update_policyload)(int seqno);
extern void kfunc_def(selinux_complete_init)(void);
extern void kfunc_def(exit_sel_fs)(void);
extern void kfunc_def(selnl_notify_setenforce)(int val);
extern void kfunc_def(selnl_notify_policyload)(u32 seqno);
extern int kfunc_def(selinux_nlmsg_lookup)(u16 sclass, u16 nlmsg_type, u32 *perm);

extern void kfunc_def(avtab_cache_init)(void);
extern void kfunc_def(ebitmap_cache_init)(void);
extern void kfunc_def(hashtab_cache_init)(void);
extern int kfunc_def(security_sidtab_hash_stats)(char *page);

// version compat

#define selinux_compat_def(func) (*selinux_compat_kf_##func##_t)

typedef int selinux_compat_def(security_mls_enabled)(struct selinux_state *state);
typedef int selinux_compat_def(security_load_policy)(struct selinux_state *state, void *data, size_t len,
                                                     struct selinux_load_state *load_state);
typedef void selinux_compat_def(selinux_policy_commit)(struct selinux_state *state,
                                                       struct selinux_load_state *load_state);
typedef void selinux_compat_def(selinux_policy_cancel)(struct selinux_state *state,
                                                       struct selinux_load_state *load_state);
typedef int selinux_compat_def(security_read_policy)(struct selinux_state *state, void **data, size_t *len);
typedef int selinux_compat_def(security_read_state_kernel)(struct selinux_state *state, void **data, size_t *len);
typedef int selinux_compat_def(security_policycap_supported)(struct selinux_state *state, unsigned int req_cap);
typedef void selinux_compat_def(security_compute_av)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                     struct av_decision *avd, struct extended_perms *xperms);
typedef void selinux_compat_def(security_compute_xperms_decision)(struct selinux_state *state, u32 ssid, u32 tsid,
                                                                  u16 tclass, u8 driver,
                                                                  struct extended_perms_decision *xpermd);
typedef void selinux_compat_def(security_compute_av_user)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                          struct av_decision *avd);
typedef int selinux_compat_def(security_transition_sid)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                        const struct qstr *qstr, u32 *out_sid);
typedef int selinux_compat_def(security_transition_sid_user)(struct selinux_state *state, u32 ssid, u32 tsid,
                                                             u16 tclass, const char *objname, u32 *out_sid);
typedef int selinux_compat_def(security_member_sid)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                    u32 *out_sid);
typedef int selinux_compat_def(security_change_sid)(struct selinux_state *state, u32 ssid, u32 tsid, u16 tclass,
                                                    u32 *out_sid);
typedef int selinux_compat_def(security_sid_to_context)(struct selinux_state *state, u32 sid, char **scontext,
                                                        u32 *scontext_len);
typedef int selinux_compat_def(security_sid_to_context_force)(struct selinux_state *state, u32 sid, char **scontext,
                                                              u32 *scontext_len);
typedef int selinux_compat_def(security_sid_to_context_inval)(struct selinux_state *state, u32 sid, char **scontext,
                                                              u32 *scontext_len);
typedef int selinux_compat_def(security_context_to_sid)(struct selinux_state *state, const char *scontext,
                                                        u32 scontext_len, u32 *out_sid, gfp_t gfp);
typedef int selinux_compat_def(security_context_str_to_sid)(struct selinux_state *state, const char *scontext,
                                                            u32 *out_sid, gfp_t gfp);
typedef int selinux_compat_def(security_context_to_sid_default)(struct selinux_state *state, const char *scontext,
                                                                u32 scontext_len, u32 *out_sid, u32 def_sid,
                                                                gfp_t gfp_flags);
typedef int selinux_compat_def(security_context_to_sid_force)(struct selinux_state *state, const char *scontext,
                                                              u32 scontext_len, u32 *sid);
typedef int selinux_compat_def(security_get_user_sids)(struct selinux_state *state, u32 callsid, char *username,
                                                       u32 **sids, u32 *nel);
typedef int selinux_compat_def(security_port_sid)(struct selinux_state *state, u8 protocol, u16 port, u32 *out_sid);
typedef int selinux_compat_def(security_ib_pkey_sid)(struct selinux_state *state, u64 subnet_prefix, u16 pkey_num,
                                                     u32 *out_sid);
typedef int selinux_compat_def(security_ib_endport_sid)(struct selinux_state *state, const char *dev_name, u8 port_num,
                                                        u32 *out_sid);
typedef int selinux_compat_def(security_netif_sid)(struct selinux_state *state, char *name, u32 *if_sid);
typedef int selinux_compat_def(security_node_sid)(struct selinux_state *state, u16 domain, void *addr, u32 addrlen,
                                                  u32 *out_sid);
typedef int selinux_compat_def(security_validate_transition)(struct selinux_state *state, u32 oldsid, u32 newsid,
                                                             u32 tasksid, u16 tclass);
typedef int selinux_compat_def(security_validate_transition_user)(struct selinux_state *state, u32 oldsid, u32 newsid,
                                                                  u32 tasksid, u16 tclass);
typedef int selinux_compat_def(security_bounded_transition)(struct selinux_state *state, u32 oldsid, u32 newsid);
typedef int selinux_compat_def(security_sid_mls_copy)(struct selinux_state *state, u32 sid, u32 mls_sid, u32 *new_sid);
typedef int selinux_compat_def(security_net_peersid_resolve)(struct selinux_state *state, u32 nlbl_sid, u32 nlbl_type,
                                                             u32 xfrm_sid, u32 *peer_sid);
typedef int selinux_compat_def(security_get_classes)(struct selinux_state *state, struct selinux_policy *policy,
                                                     char ***classes, int *nclasses);
typedef int selinux_compat_def(security_get_permissions)(struct selinux_state *state, struct selinux_policy *policy,
                                                         char *class, char ***perms, int *nperms);
typedef int selinux_compat_def(security_get_reject_unknown)(struct selinux_state *state);
typedef int selinux_compat_def(security_get_allow_unknown)(struct selinux_state *state);

typedef int selinux_compat_def(security_fs_use)(struct selinux_state *state, struct super_block *sb);
typedef int selinux_compat_def(security_genfs_sid)(struct selinux_state *state, const char *fstype, const char *path,
                                                   u16 sclass, u32 *sid);
typedef int selinux_compat_def(selinux_policy_genfs_sid)(struct selinux_state *state, struct selinux_policy *policy,
                                                         const char *fstype, const char *path, u16 sclass, u32 *sid);
typedef int selinux_compat_def(security_netlbl_secattr_to_sid)(struct selinux_state *state,
                                                               struct netlbl_lsm_secattr *secattr, u32 *sid);
typedef int selinux_compat_def(security_netlbl_sid_to_secattr)(struct selinux_state *state, u32 sid,
                                                               struct netlbl_lsm_secattr *secattr);
typedef const char *selinux_compat_def(security_get_initial_sid_context)(struct selinux_state *state, u32 sid);

typedef void selinux_compat_def(selinux_status_update_setenforce)(struct selinux_state *state, int enforcing);
typedef void selinux_compat_def(selinux_status_update_policyload)(struct selinux_state *state, int seqno);
typedef void selinux_compat_def(selinux_complete_init)(struct selinux_state *state);
typedef void selinux_compat_def(exit_sel_fs)(struct selinux_state *state);
typedef void selinux_compat_def(selnl_notify_setenforce)(struct selinux_state *state, int val);
typedef void selinux_compat_def(selnl_notify_policyload)(struct selinux_state *state, u32 seqno);
typedef int selinux_compat_def(selinux_nlmsg_lookup)(struct selinux_state *state, u16 sclass, u16 nlmsg_type,
                                                     u32 *perm);

typedef void selinux_compat_def(avtab_cache_init)(struct selinux_state *state);
typedef void selinux_compat_def(ebitmap_cache_init)(struct selinux_state *state);
typedef void selinux_compat_def(hashtab_cache_init)(struct selinux_state *state);
typedef int selinux_compat_def(security_sidtab_hash_stats)(struct selinux_state *state, char *page);

//

static inline bool selinux_has_selinux_state()
{
    return kvar(selinux_state) != 0;
}

static inline bool selinux_need_call_compat()
{
    return kver >= VERSION(4, 17, 0) && kver < VERSION(6, 4, 0);
}

#define selinux_compat_call_kfunc(func, ...) \
    ((selinux_compat_kf_##func##_t)kfunc(func))(kvar(selinux_state), ##__VA_ARGS__)

#define selinux_adapt_kfunc_call(func, ...)                        \
    if (kfunc(func)) {                                             \
        if (selinux_need_call_compat())                            \
            return selinux_compat_call_kfunc(func, ##__VA_ARGS__); \
        else                                                       \
            return kfunc(func)(__VA_ARGS__);                       \
    }

#define selinux_adapt_kfunc_call_void(func, ...)            \
    if (kfunc(func)) {                                      \
        if (selinux_need_call_compat())                     \
            selinux_compat_call_kfunc(func, ##__VA_ARGS__); \
        else                                                \
            kfunc(func)(__VA_ARGS__);                       \
    }

static inline int security_mls_enabled(void)
{
    selinux_adapt_kfunc_call(security_mls_enabled);
    kfunc_not_found();
    return 0;
}
static inline int security_load_policy(void *data, size_t len, struct selinux_load_state *load_state)
{
    selinux_adapt_kfunc_call(security_load_policy, data, len, load_state);
    kfunc_not_found();
    return 0;
}
static inline void selinux_policy_commit(struct selinux_load_state *load_state)
{
    selinux_adapt_kfunc_call_void(selinux_policy_commit, load_state);
    kfunc_not_found();
}
static inline void selinux_policy_cancel(struct selinux_load_state *load_state)
{
    selinux_adapt_kfunc_call_void(selinux_policy_cancel, load_state);
    kfunc_not_found();
}
static inline int security_read_policy(void **data, size_t *len)
{
    selinux_adapt_kfunc_call(security_read_policy, data, len);
    kfunc_not_found();
    return 0;
}
static inline int security_read_state_kernel(void **data, size_t *len)
{
    selinux_adapt_kfunc_call(security_read_state_kernel, data, len);
    kfunc_not_found();
    return 0;
}
static inline int security_policycap_supported(unsigned int req_cap)
{
    selinux_adapt_kfunc_call(security_policycap_supported, req_cap);
    kfunc_not_found();
    return 0;
}
static inline void security_compute_av(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd,
                                       struct extended_perms *xperms)
{
    selinux_adapt_kfunc_call_void(security_compute_av, ssid, tsid, tclass, avd, xperms);
    kfunc_not_found();
}
static inline void security_compute_xperms_decision(u32 ssid, u32 tsid, u16 tclass, u8 driver,
                                                    struct extended_perms_decision *xpermd)
{
    selinux_adapt_kfunc_call_void(security_compute_xperms_decision, ssid, tsid, tclass, driver, xpermd);
    kfunc_not_found();
}
static inline void security_compute_av_user(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)
{
    selinux_adapt_kfunc_call(security_compute_av_user, ssid, tsid, tclass, avd);
    kfunc_not_found();
}
static inline int security_transition_sid(u32 ssid, u32 tsid, u16 tclass, const struct qstr *qstr, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_transition_sid, ssid, tsid, tclass, qstr, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass, const char *objname, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_transition_sid_user, ssid, tsid, tclass, objname, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_member_sid(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_member_sid, ssid, tsid, tclass, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_change_sid(u32 ssid, u32 tsid, u16 tclass, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_change_sid, ssid, tsid, tclass, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)
{
    selinux_adapt_kfunc_call(security_sid_to_context, sid, scontext, scontext_len);
    kfunc_not_found();
    return 0;
}
static inline int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)
{
    selinux_adapt_kfunc_call(security_sid_to_context_force, sid, scontext, scontext_len);
    kfunc_not_found();
    return 0;
}
static inline int security_sid_to_context_inval(u32 sid, char **scontext, u32 *scontext_len)
{
    selinux_adapt_kfunc_call(security_sid_to_context_inval, sid, scontext, scontext_len);
    kfunc_not_found();
    return 0;
}
static inline int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *out_sid, gfp_t gfp)
{
    selinux_adapt_kfunc_call(security_context_to_sid, scontext, scontext_len, out_sid, gfp);
    kfunc_not_found();
    return 0;
}
static inline int security_context_str_to_sid(const char *scontext, u32 *out_sid, gfp_t gfp)
{
    selinux_adapt_kfunc_call(security_context_str_to_sid, scontext, out_sid, gfp);
    kfunc_not_found();
    return 0;
}
static inline int security_context_to_sid_default(const char *scontext, u32 scontext_len, u32 *out_sid, u32 def_sid,
                                                  gfp_t gfp_flags)
{
    selinux_adapt_kfunc_call(security_context_to_sid_default, scontext, scontext_len, out_sid, def_sid, gfp_flags);
    kfunc_not_found();
    return 0;
}
static inline int security_context_to_sid_force(const char *scontext, u32 scontext_len, u32 *sid)
{
    selinux_adapt_kfunc_call(security_context_to_sid_force, scontext, scontext_len, sid);
    kfunc_not_found();
    return 0;
}
static inline int security_get_user_sids(u32 callsid, char *username, u32 **sids, u32 *nel)
{
    selinux_adapt_kfunc_call(security_get_user_sids, callsid, username, sids, nel);
    kfunc_not_found();
    return 0;
}
static inline int security_port_sid(u8 protocol, u16 port, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_port_sid, protocol, port, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_ib_pkey_sid, subnet_prefix, pkey_num, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_ib_endport_sid(const char *dev_name, u8 port_num, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_ib_endport_sid, dev_name, port_num, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_netif_sid(char *name, u32 *if_sid)
{
    selinux_adapt_kfunc_call(security_netif_sid, name, if_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_node_sid(u16 domain, void *addr, u32 addrlen, u32 *out_sid)
{
    selinux_adapt_kfunc_call(security_node_sid, domain, addr, addrlen, out_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass)
{
    selinux_adapt_kfunc_call(security_validate_transition, oldsid, newsid, tasksid, tclass);
    kfunc_not_found();
    return 0;
}
static inline int security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid, u16 tclass)
{
    selinux_adapt_kfunc_call(security_validate_transition_user, oldsid, newsid, tasksid, tclass);
    kfunc_not_found();
    return 0;
}
static inline int security_bounded_transition(u32 oldsid, u32 newsid)
{
    selinux_adapt_kfunc_call(security_bounded_transition, oldsid, newsid);
    kfunc_not_found();
    return 0;
}
static inline int security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)
{
    selinux_adapt_kfunc_call(security_sid_mls_copy, sid, mls_sid, new_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type, u32 xfrm_sid, u32 *peer_sid)
{
    selinux_adapt_kfunc_call(security_net_peersid_resolve, nlbl_sid, nlbl_type, xfrm_sid, peer_sid);
    kfunc_not_found();
    return 0;
}
static inline int security_get_classes(struct selinux_policy *policy, char ***classes, int *nclasses)
{
    selinux_adapt_kfunc_call(security_get_classes, policy, classes, nclasses);
    kfunc_not_found();
    return 0;
}
static inline int security_get_permissions(struct selinux_policy *policy, char *class, char ***perms, int *nperms)
{
    selinux_adapt_kfunc_call(security_get_permissions, policy, class, perms, nperms);
    kfunc_not_found();
    return 0;
}
static inline int security_get_reject_unknown(void)
{
    selinux_adapt_kfunc_call(security_get_reject_unknown);
    kfunc_not_found();
    return 0;
}
static inline int security_get_allow_unknown(void)
{
    selinux_adapt_kfunc_call(security_get_allow_unknown);
    kfunc_not_found();
    return 0;
}

static inline int security_fs_use(struct super_block *sb)
{
    selinux_adapt_kfunc_call(security_fs_use, sb);
    kfunc_not_found();
    return 0;
}
static inline int security_genfs_sid(const char *fstype, const char *path, u16 sclass, u32 *sid)
{
    selinux_adapt_kfunc_call(security_genfs_sid, fstype, path, sclass, sid);
    kfunc_not_found();
    return 0;
}
static inline int selinux_policy_genfs_sid(struct selinux_policy *policy, const char *fstype, const char *path,
                                           u16 sclass, u32 *sid)
{
    selinux_adapt_kfunc_call(selinux_policy_genfs_sid, policy, fstype, path, sclass, sid);
    kfunc_not_found();
    return 0;
}
static inline int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr, u32 *sid)
{
    selinux_adapt_kfunc_call(security_netlbl_secattr_to_sid, secattr, sid);
    kfunc_not_found();
    return 0;
}
static inline int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)
{
    selinux_adapt_kfunc_call(security_netlbl_sid_to_secattr, sid, secattr);
    kfunc_not_found();
    return 0;
}
static inline const char *security_get_initial_sid_context(u32 sid)
{
    selinux_adapt_kfunc_call(security_get_initial_sid_context, sid);
    kfunc_not_found();
    return 0;
}

static inline void selinux_status_update_setenforce(int enforcing)
{
    selinux_adapt_kfunc_call_void(selinux_status_update_setenforce, enforcing);
    kfunc_not_found();
}
static inline void selinux_status_update_policyload(int seqno)
{
    selinux_adapt_kfunc_call_void(selinux_status_update_policyload, seqno);
    kfunc_not_found();
}
static inline void selinux_complete_init(void)
{
    selinux_adapt_kfunc_call_void(selinux_complete_init);
    kfunc_not_found();
}
static inline void exit_sel_fs(void)
{
    selinux_adapt_kfunc_call_void(exit_sel_fs);
    kfunc_not_found();
}
static inline void selnl_notify_setenforce(int val)
{
    selinux_adapt_kfunc_call_void(selnl_notify_setenforce, val);
    kfunc_not_found();
}
static inline void selnl_notify_policyload(u32 seqno)
{
    selinux_adapt_kfunc_call_void(selnl_notify_policyload, seqno);
    kfunc_not_found();
}
static inline int selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm)
{
    selinux_adapt_kfunc_call(selinux_nlmsg_lookup, sclass, nlmsg_type, perm);
    kfunc_not_found();
    return 0;
}

static inline void avtab_cache_init(void)
{
    selinux_adapt_kfunc_call_void(avtab_cache_init);
    kfunc_not_found();
}
static inline void ebitmap_cache_init(void)
{
    selinux_adapt_kfunc_call_void(ebitmap_cache_init);
    kfunc_not_found();
}
static inline void hashtab_cache_init(void)
{
    selinux_adapt_kfunc_call_void(hashtab_cache_init);
    kfunc_not_found();
}
static inline int security_sidtab_hash_stats(char *page)
{
    selinux_adapt_kfunc_call(security_sidtab_hash_stats, page);
    kfunc_not_found();
    return 0;
}

#endif
```

`kernel/linux/tools/arch/arm64/include/asm/barrier.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _TOOLS_LINUX_ASM_AARCH64_BARRIER_H
#define _TOOLS_LINUX_ASM_AARCH64_BARRIER_H

#define mb() asm volatile("dmb ish" ::: "memory")
#define wmb() asm volatile("dmb ishst" ::: "memory")
#define rmb() asm volatile("dmb ishld" ::: "memory")

/*
 * Kernel uses dmb variants on arm64 for smp_*() barriers. Pretty much the same
 * implementation as above mb()/wmb()/rmb(), though for the latter kernel uses
 * dsb. In any case, should above mb()/wmb()/rmb() change, make sure the below
 * smp_*() don't.
 */
#define smp_mb() asm volatile("dmb ish" ::: "memory")
#define smp_wmb() asm volatile("dmb ishst" ::: "memory")
#define smp_rmb() asm volatile("dmb ishld" ::: "memory")

#define smp_store_release(p, v)                                                         \
    do {                                                                                \
        union                                                                           \
        {                                                                               \
            typeof(*p) __val;                                                           \
            char __c[1];                                                                \
        } __u = { .__val = (v) };                                                       \
                                                                                        \
        switch (sizeof(*p)) {                                                           \
        case 1:                                                                         \
            asm volatile("stlrb %w1, %0" : "=Q"(*p) : "r"(*(u8 *)__u.__c) : "memory");  \
            break;                                                                      \
        case 2:                                                                         \
            asm volatile("stlrh %w1, %0" : "=Q"(*p) : "r"(*(u16 *)__u.__c) : "memory"); \
            break;                                                                      \
        case 4:                                                                         \
            asm volatile("stlr %w1, %0" : "=Q"(*p) : "r"(*(u32 *)__u.__c) : "memory");  \
            break;                                                                      \
        case 8:                                                                         \
            asm volatile("stlr %1, %0" : "=Q"(*p) : "r"(*(u64 *)__u.__c) : "memory");   \
            break;                                                                      \
        default:                                                                        \
            /* Only to shut up gcc ... */                                               \
            mb();                                                                       \
            break;                                                                      \
        }                                                                               \
    } while (0)

#define smp_load_acquire(p)                                                             \
    ({                                                                                  \
        union                                                                           \
        {                                                                               \
            typeof(*p) __val;                                                           \
            char __c[1];                                                                \
        } __u = { .__c = { 0 } };                                                       \
                                                                                        \
        switch (sizeof(*p)) {                                                           \
        case 1:                                                                         \
            asm volatile("ldarb %w0, %1" : "=r"(*(u8 *)__u.__c) : "Q"(*p) : "memory");  \
            break;                                                                      \
        case 2:                                                                         \
            asm volatile("ldarh %w0, %1" : "=r"(*(u16 *)__u.__c) : "Q"(*p) : "memory"); \
            break;                                                                      \
        case 4:                                                                         \
            asm volatile("ldar %w0, %1" : "=r"(*(u32 *)__u.__c) : "Q"(*p) : "memory");  \
            break;                                                                      \
        case 8:                                                                         \
            asm volatile("ldar %0, %1" : "=r"(*(u64 *)__u.__c) : "Q"(*p) : "memory");   \
            break;                                                                      \
        default:                                                                        \
            /* Only to shut up gcc ... */                                               \
            mb();                                                                       \
            break;                                                                      \
        }                                                                               \
        __u.__val;                                                                      \
    })

#endif /* _TOOLS_LINUX_ASM_AARCH64_BARRIER_H */
```

`kernel/minc/ctype.h`:

```h
#ifndef _KP_CTYPE_H_
#define _KP_CTYPE_H_

inline int min_isupper(int __c)
{
    return __c >= 'A' && __c <= 'Z';
}

inline int min_islower(int __c)
{
    return __c >= 'a' && __c <= 'z';
}

inline int min_isalpha(int __c)
{
    return min_islower(__c) || min_isupper(__c);
}

inline int min_isdigit(int __c)
{
    return ((unsigned)__c - '0') <= 9;
}

inline int min_isalnum(int __c)
{
    return min_isalpha(__c) || min_isdigit(__c);
}

inline int min_isascii(int __c)
{
    return !(__c & ~0x7f);
}

inline int min_isblank(int __c)
{
    return (__c == '\t') || (__c == ' ');
}

inline int min_iscntrl(int __c)
{
    return __c < 0x20;
}

inline int min_isspace(int __c)
{
    return __c == ' ' || __c == '\n' || __c == '\t' || __c == '\r';
}

inline int min_isxdigit(int __c)
{
    return min_isdigit(__c) || (__c >= 'a' && __c <= 'f') || (__c >= 'A' && __c <= 'F');
}

inline int min_toupper(int __c)
{
    return min_islower(__c) ? (__c & ~32) : __c;
}

inline int min_tolower(int __c)
{
    return min_isupper(__c) ? (__c | 32) : __c;
}

#endif
```

`kernel/minc/print.c`:

```c
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (info@paland.com)
//             2014-2019, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
//        embedded systems with a very limited resources. These routines are thread
//        safe and reentrant!
//        Use this instead of the bloated standard/newlib printf cause these use
//        malloc for printf (and may not be thread safe).
//
///////////////////////////////////////////////////////////////////////////////

#include <stdbool.h>
#include <stdint.h>

#include "print.h"

// 'ntoa' conversion buffer size, this must be big enough to hold one converted
// numeric number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_NTOA_BUFFER_SIZE
#define PRINTF_NTOA_BUFFER_SIZE 32U
#endif

// support for the long long types (%llu or %p)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
#define PRINTF_SUPPORT_LONG_LONG
#endif

// support for the ptrdiff_t type (%t)
// ptrdiff_t is normally defined in <stddef.h> as long or long long type
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
#define PRINTF_SUPPORT_PTRDIFF_T
#endif

///////////////////////////////////////////////////////////////////////////////

// internal flag definitions
#define FLAGS_ZEROPAD (1U << 0U)
#define FLAGS_LEFT (1U << 1U)
#define FLAGS_PLUS (1U << 2U)
#define FLAGS_SPACE (1U << 3U)
#define FLAGS_HASH (1U << 4U)
#define FLAGS_UPPERCASE (1U << 5U)
#define FLAGS_CHAR (1U << 6U)
#define FLAGS_SHORT (1U << 7U)
#define FLAGS_LONG (1U << 8U)
#define FLAGS_LONG_LONG (1U << 9U)
#define FLAGS_PRECISION (1U << 10U)

// output function type
typedef void (*out_fct_type)(char character, void *buffer, size_t idx, size_t maxlen);

// wrapper (used as buffer) for output function type
typedef struct
{
    void (*fct)(char character, void *arg);
    void *arg;
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx, size_t maxlen)
{
    if (idx < maxlen) {
        ((char *)buffer)[idx] = character;
    }
}

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx, size_t maxlen)
{
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx, size_t maxlen)
{
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
        min_putchar(character);
    }
}

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx, size_t maxlen)
{
    (void)idx;
    (void)maxlen;
    if (character) {
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    }
}

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    const char *s;
    for (s = str; *s && maxsize--; ++s)
        ;
    return (unsigned int)(s - str);
}

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
    return (ch >= '0') && (ch <= '9');
}

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    unsigned int i = 0U;
    while (_is_digit(**str)) {
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    }
    return i;
}

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx, size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    const size_t start_idx = idx;

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
        for (size_t i = len; i < width; i++) {
            out(' ', buffer, idx++, maxlen);
        }
    }

    // reverse string
    while (len) {
        out(buf[--len], buffer, idx++, maxlen);
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
        while (idx - start_idx < width) {
            out(' ', buffer, idx++, maxlen);
        }
    }

    return idx;
}

// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx, size_t maxlen, char *buf, size_t len,
                           bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
        if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
            width--;
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
        if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
            len--;
            if (len && (base == 16U)) {
                len--;
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
        } else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
        } else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'b';
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
            buf[len++] = '0';
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
        if (negative) {
            buf[len++] = '-';
        } else if (flags & FLAGS_PLUS) {
            buf[len++] = '+'; // ignore the space if the '+' exists
        } else if (flags & FLAGS_SPACE) {
            buf[len++] = ' ';
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}

// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx, size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;

    // no hash for 0 values
    if (!value) {
        flags &= ~FLAGS_HASH;
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
        do {
            const char digit = (char)(value % base);
            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
            value /= base;
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}

// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx, size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base, unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;

    // no hash for 0 values
    if (!value) {
        flags &= ~FLAGS_HASH;
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
        do {
            const char digit = (char)(value % base);
            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
            value /= base;
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
#endif // PRINTF_SUPPORT_LONG_LONG

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen, const char *format, va_list va)
{
    unsigned int flags, width, precision, n;
    size_t idx = 0U;

    if (!buffer) {
        // use null output function
        out = _out_null;
    }

    while (*format) {
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
            // no
            out(*format, buffer, idx++, maxlen);
            format++;
            continue;
        } else {
            // yes, evaluate it
            format++;
        }

        // evaluate flags
        flags = 0U;
        do {
            switch (*format) {
            case '0':
                flags |= FLAGS_ZEROPAD;
                format++;
                n = 1U;
                break;
            case '-':
                flags |= FLAGS_LEFT;
                format++;
                n = 1U;
                break;
            case '+':
                flags |= FLAGS_PLUS;
                format++;
                n = 1U;
                break;
            case ' ':
                flags |= FLAGS_SPACE;
                format++;
                n = 1U;
                break;
            case '#':
                flags |= FLAGS_HASH;
                format++;
                n = 1U;
                break;
            default:
                n = 0U;
                break;
            }
        } while (n);

        // evaluate width field
        width = 0U;
        if (_is_digit(*format)) {
            width = _atoi(&format);
        } else if (*format == '*') {
            const int w = va_arg(va, int);
            if (w < 0) {
                flags |= FLAGS_LEFT; // reverse padding
                width = (unsigned int)-w;
            } else {
                width = (unsigned int)w;
            }
            format++;
        }

        // evaluate precision field
        precision = 0U;
        if (*format == '.') {
            flags |= FLAGS_PRECISION;
            format++;
            if (_is_digit(*format)) {
                precision = _atoi(&format);
            } else if (*format == '*') {
                const int prec = (int)va_arg(va, int);
                precision = prec > 0 ? (unsigned int)prec : 0U;
                format++;
            }
        }

        // evaluate length field
        switch (*format) {
        case 'l':
            flags |= FLAGS_LONG;
            format++;
            if (*format == 'l') {
                flags |= FLAGS_LONG_LONG;
                format++;
            }
            break;
        case 'h':
            flags |= FLAGS_SHORT;
            format++;
            if (*format == 'h') {
                flags |= FLAGS_CHAR;
                format++;
            }
            break;
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
        case 't':
            flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
            format++;
            break;
#endif
        case 'j':
            flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
            format++;
            break;
        case 'z':
            flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
            format++;
            break;
        default:
            break;
        }

        // evaluate specifier
        switch (*format) {
        case 'd':
        case 'i':
        case 'u':
        case 'x':
        case 'X':
        case 'o':
        case 'b': {
            // set the base
            unsigned int base;
            if (*format == 'x' || *format == 'X') {
                base = 16U;
            } else if (*format == 'o') {
                base = 8U;
            } else if (*format == 'b') {
                base = 2U;
            } else {
                base = 10U;
                flags &= ~FLAGS_HASH; // no hash for dec format
            }
            // uppercase
            if (*format == 'X') {
                flags |= FLAGS_UPPERCASE;
            }

            // no plus or space flag for u, x, X, o, b
            if ((*format != 'i') && (*format != 'd')) {
                flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
            }

            // ignore '0' flag when precision is given
            if (flags & FLAGS_PRECISION) {
                flags &= ~FLAGS_ZEROPAD;
            }

            // convert the integer
            if ((*format == 'i') || (*format == 'd')) {
                // signed
                if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
                    const long long value = va_arg(va, long long);
                    idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value),
                                          value < 0, base, precision, width, flags);
#endif
                } else if (flags & FLAGS_LONG) {
                    const long value = va_arg(va, long);
                    idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value),
                                     value < 0, base, precision, width, flags);
                } else {
                    const int value = (flags & FLAGS_CHAR)  ? (char)va_arg(va, int) :
                                      (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) :
                                                              va_arg(va, int);
                    idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0,
                                     base, precision, width, flags);
                }
            } else {
                // unsigned
                if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base,
                                          precision, width, flags);
#endif
                } else if (flags & FLAGS_LONG) {
                    idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width,
                                     flags);
                } else {
                    const unsigned int value = (flags & FLAGS_CHAR)  ? (unsigned char)va_arg(va, unsigned int) :
                                               (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) :
                                                                       va_arg(va, unsigned int);
                    idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
                }
            }
            format++;
            break;
        }
#if defined(PRINTF_SUPPORT_FLOAT)
        case 'f':
        case 'F':
            if (*format == 'F')
                flags |= FLAGS_UPPERCASE;
            idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
            format++;
            break;
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        case 'e':
        case 'E':
        case 'g':
        case 'G':
            if ((*format == 'g') || (*format == 'G'))
                flags |= FLAGS_ADAPT_EXP;
            if ((*format == 'E') || (*format == 'G'))
                flags |= FLAGS_UPPERCASE;
            idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
            format++;
            break;
#endif // PRINTF_SUPPORT_EXPONENTIAL
#endif // PRINTF_SUPPORT_FLOAT
        case 'c': {
            unsigned int l = 1U;
            // pre padding
            if (!(flags & FLAGS_LEFT)) {
                while (l++ < width) {
                    out(' ', buffer, idx++, maxlen);
                }
            }
            // char output
            out((char)va_arg(va, int), buffer, idx++, maxlen);
            // post padding
            if (flags & FLAGS_LEFT) {
                while (l++ < width) {
                    out(' ', buffer, idx++, maxlen);
                }
            }
            format++;
            break;
        }

        case 's': {
            const char *p = va_arg(va, char *);
            unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
            // pre padding
            if (flags & FLAGS_PRECISION) {
                l = (l < precision ? l : precision);
            }
            if (!(flags & FLAGS_LEFT)) {
                while (l++ < width) {
                    out(' ', buffer, idx++, maxlen);
                }
            }
            // string output
            while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
                out(*(p++), buffer, idx++, maxlen);
            }
            // post padding
            if (flags & FLAGS_LEFT) {
                while (l++ < width) {
                    out(' ', buffer, idx++, maxlen);
                }
            }
            format++;
            break;
        }

        case 'p': {
            width = sizeof(void *) * 2U;
            flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
            if (is_ll) {
                idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void *), false, 16U, precision,
                                      width, flags);
            } else {
#endif
                idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void *)), false, 16U,
                                 precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
            }
#endif
            format++;
            break;
        }

        case '%':
            out('%', buffer, idx++, maxlen);
            format++;
            break;

        default:
            out(*format, buffer, idx++, maxlen);
            format++;
            break;
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

    // return written chars without terminating \0
    return (int)idx;
}

///////////////////////////////////////////////////////////////////////////////

int min_printf(const char *format, ...)
{
    va_list va;
    va_start(va, format);
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    va_end(va);
    return ret;
}

int min_sprintf(char *buffer, const char *format, ...)
{
    va_list va;
    va_start(va, format);
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    va_end(va);
    return ret;
}

int min_snprintf(char *buffer, size_t count, const char *format, ...)
{
    va_list va;
    va_start(va, format);
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    va_end(va);
    return ret;
}

int min_vprintf(const char *format, va_list va)
{
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
}

int min_vsnprintf(char *buffer, size_t count, const char *format, va_list va)
{
    return _vsnprintf(_out_buffer, buffer, count, format, va);
}

int min_fctprintf(void (*out)(char character, void *arg), void *arg, const char *format, ...)
{
    va_list va;
    va_start(va, format);
    const out_fct_wrap_type out_fct_wrap = { out, arg };
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
    va_end(va);
    return ret;
}
```

`kernel/minc/print.h`:

```h
///////////////////////////////////////////////////////////////////////////////
// \author (c) Marco Paland (info@paland.com)
//             2014-2019, PALANDesign Hannover, Germany
//
// \license The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// \brief Tiny printf, sprintf and snprintf implementation, optimized for speed on
//        embedded systems with a very limited resources.
//        Use this instead of bloated standard/newlib printf.
//        These routines are thread safe and reentrant.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PRINTF_H_
#define _PRINTF_H_

#include <stdarg.h>

/**
 * Output a character to a custom device like UART, used by the printf() function
 * This function is declared here only. You have to write your custom implementation somewhere
 * \param character Character to output
 */
// void min_putchar(char character);
static inline void min_putchar(char character)
{
}

/**
 * Tiny printf implementation
 * You have to implement _putchar if you use printf()
 * To avoid conflicts with the regular printf() API it is overridden by macro defines
 * and internal underscore-appended functions like printf_() are used
 * \param format A string that specifies the format of the output
 * \return The number of characters that are written into the array, not counting the terminating null character
 */
int min_printf(const char *format, ...);

/**
 * Tiny sprintf implementation
 * Due to security reasons (buffer overflow) YOU SHOULD CONSIDER USING (V)SNPRINTF INSTEAD!
 * \param buffer A pointer to the buffer where to store the formatted string. MUST be big enough to store the output!
 * \param format A string that specifies the format of the output
 * \return The number of characters that are WRITTEN into the buffer, not counting the terminating null character
 */
int min_sprintf(char *buffer, const char *format, ...);

/**
 * Tiny snprintf/vsnprintf implementation
 * \param buffer A pointer to the buffer where to store the formatted string
 * \param count The maximum number of characters to store in the buffer, including a terminating null character
 * \param format A string that specifies the format of the output
 * \param va A value identifying a variable arguments list
 * \return The number of characters that COULD have been written into the buffer, not counting the terminating
 *         null character. A value equal or larger than count indicates truncation. Only when the returned value
 *         is non-negative and less than count, the string has been completely written.
 */
int min_snprintf(char *buffer, size_t count, const char *format, ...);
int min_vsnprintf(char *buffer, size_t count, const char *format, va_list va);

/**
 * Tiny vprintf implementation
 * \param format A string that specifies the format of the output
 * \param va A value identifying a variable arguments list
 * \return The number of characters that are WRITTEN into the buffer, not counting the terminating null character
 */
int min_vprintf(const char *format, va_list va);

/**
 * printf with output function
 * You may use this as dynamic alternative to printf() with its fixed _putchar() output
 * \param out An output function which takes one character and an argument pointer
 * \param arg An argument pointer for user data passed to output function
 * \param format A string that specifies the format of the output
 * \return The number of characters that are sent to the output function, not counting the terminating null character
 */
int min_fctprintf(void (*out)(char character, void *arg), void *arg, const char *format, ...);

#endif // _PRINTF_H_
```

`kernel/minc/stdio.h`:

```h
#ifndef _KP_STDIO_H_
#define _KP_STDIO_H_

#include "print.h"

#endif
```

`kernel/minc/stdlib.c`:

```c
#include <stdint.h>
#include <stddef.h>

#include "stdlib.h"
#include "ctype.h"
#include "string.h"

static inline int digitval(int ch)
{
    if (ch >= '0' && ch <= '9') {
        return ch - '0';
    } else if (ch >= 'A' && ch <= 'Z') {
        return ch - 'A' + 10;
    } else if (ch >= 'a' && ch <= 'z') {
        return ch - 'a' + 10;
    } else {
        return -1;
    }
}

uintmax_t strntoumax(const char *nptr, char **endptr, int base, size_t n)
{
    int minus = 0;
    uintmax_t v = 0;
    int d;
    while (n && min_isspace((unsigned char)*nptr)) {
        nptr++;
        n--;
    }
    /* Single optional + or - */
    if (n) {
        char c = *nptr;
        if (c == '-' || c == '+') {
            minus = (c == '-');
            nptr++;
            n--;
        }
    }

    if (base == 0) {
        if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) {
            n -= 2;
            nptr += 2;
            base = 16;
        } else if (n >= 1 && nptr[0] == '0') {
            n--;
            nptr++;
            base = 8;
        } else {
            base = 10;
        }
    } else if (base == 16) {
        if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) {
            n -= 2;
            nptr += 2;
        }
    }
    while (n && (d = digitval(*nptr)) >= 0 && d < base) {
        v = v * base + d;
        n--;
        nptr++;
    }
    if (endptr)
        *endptr = (char *)nptr;
    return minus ? -v : v;
}

intmax_t strntoimax(const char *nptr, char **endptr, int base, size_t n)
{
    return (intmax_t)strntoumax(nptr, endptr, base, n);
}

int atoi(const char *nptr)
{
    return (int)strntoumax(nptr, (char **)NULL, 10, ~(size_t)0);
}

long atol(const char *nptr)
{
    return (long)strntoumax(nptr, (char **)NULL, 10, ~(size_t)0);
}

void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, min_comparefunc_t cmp)
{
    while (nmemb) {
        size_t mididx = nmemb / 2;
        const void *midobj = (const char *)base + mididx * size;
        int diff = cmp(key, midobj);

        if (diff == 0)
            return (void *)midobj;

        if (diff > 0) {
            base = (const char *)midobj + size;
            nmemb -= mididx + 1;
        } else
            nmemb = mididx;
    }

    return NULL;
}

static inline size_t newgap(size_t gap)
{
    gap = (gap * 10) / 13;
    if (gap == 9 || gap == 10)
        gap = 11;

    if (gap < 1)
        gap = 1;
    return gap;
}

void qsort(void *base, size_t nmemb, size_t size, min_comparefunc_t cmp)
{
    size_t gap = nmemb;
    size_t i, j;
    char *p1, *p2;
    int swapped;

    if (!nmemb)
        return;

    do {
        gap = newgap(gap);
        swapped = 0;

        for (i = 0, p1 = base; i < nmemb - gap; i++, p1 += size) {
            j = i + gap;
            if (cmp(p1, p2 = (char *)base + j * size) > 0) {
                min_memswap(p1, p2, size);
                swapped = 1;
            }
        }
    } while (gap > 1 || swapped);
}

signed long strtol(const char *nptr, char **endptr, int base)
{
    return (signed long)strntoumax(nptr, endptr, base, ~(size_t)0);
}

signed long long strtoll(const char *nptr, char **endptr, int base)
{
    return (signed long long)strntoumax(nptr, endptr, base, ~(size_t)0);
}

unsigned long strtoul(const char *nptr, char **endptr, int base)
{
    return (signed long)strntoumax(nptr, endptr, base, ~(size_t)0);
}

unsigned long long strtoull(const char *nptr, char **endptr, int base)
{
    return (signed long long)strntoumax(nptr, endptr, base, ~(size_t)0);
}

uintmax_t strtoumax(const char *nptr, char **endptr, int base)
{
    return (uintmax_t)strntoumax(nptr, endptr, base, ~(size_t)0);
}
```

`kernel/minc/stdlib.h`:

```h
#ifndef _KP_STDLIB_H_
#define _KP_STDLIB_H_

#include <stdbool.h>
#include <stdint.h>

inline int abs(int n)
{
    return (n < 0) ? -n : n;
}

int atoi(const char *);
long atol(const char *);
long long atoll(const char *);

inline long labs(long n)
{
    return (n < 0L) ? -n : n;
}

inline long long llabs(long long n)
{
    return (n < 0LL) ? -n : n;
}

long strtol(const char *, char **, int);
long long strtoll(const char *, char **, int);
unsigned long strtoul(const char *, char **, int);
unsigned long long strtoull(const char *, char **, int);

typedef int (*min_comparefunc_t)(const void *, const void *);

void *bsearch(const void *, const void *, size_t, size_t, min_comparefunc_t);
void qsort(void *, size_t, size_t, min_comparefunc_t);

#endif
```

`kernel/minc/string.c`:

```c
#include "string.h"
#include "ctype.h"

#include <stdint.h>

void *min_memccpy(void *dst, const void *src, int c, size_t n)
{
    char *q = dst;
    const char *p = src;
    char ch;
    while (n--) {
        *q++ = ch = *p++;
        if (ch == (char)c)
            return q;
    }
    return 0;
}

void *min_memchr(const void *s, int c, size_t n)
{
    const unsigned char *sp = s;
    while (n--) {
        if (*sp == (unsigned char)c)
            return (void *)sp;
        sp++;
    }
    return 0;
}

int min_memcmp(const void *s1, const void *s2, size_t n)
{
    const unsigned char *c1 = s1, *c2 = s2;
    int d = 0;
    while (n--) {
        d = (int)*c1++ - (int)*c2++;
        if (d)
            break;
    }
    return d;
}

void *min_memcpy(void *dst, const void *src, size_t n)
{
    const char *p = src;
    char *q = dst;
    while (n--) {
        *q++ = *p++;
    }
    return dst;
}

void *min_memmem(const void *haystack, size_t n, const void *needle, size_t m)
{
    const unsigned char *y = (const unsigned char *)haystack;
    const unsigned char *x = (const unsigned char *)needle;

    size_t j, k, l;

    if (m > n || !m || !n)
        return 0;

    if (1 != m) {
        if (x[0] == x[1]) {
            k = 2;
            l = 1;
        } else {
            k = 1;
            l = 2;
        }

        j = 0;
        while (j <= n - m) {
            if (x[1] != y[j + 1]) {
                j += k;
            } else {
                if (!min_memcmp(x + 2, y + j + 2, m - 2) && x[0] == y[j])
                    return (void *)&y[j];
                j += l;
            }
        }
    } else
        do {
            if (*y == *x)
                return (void *)y;
            y++;
        } while (--n);
    return 0;
}

void *min_memmove(void *dst, const void *src, size_t n)
{
    const char *p = src;
    char *q = dst;

    if (q < p) {
        while (n--) {
            *q++ = *p++;
        }
    } else {
        p += n;
        q += n;
        while (n--) {
            *--q = *--p;
        }
    }
    return dst;
}

void *min_memrchr(const void *s, int c, size_t n)
{
    const unsigned char *sp = (const unsigned char *)s + n - 1;

    while (n--) {
        if (*sp == (unsigned char)c)
            return (void *)sp;
        sp--;
    }

    return 0;
}

void *min_memset(void *dst, int c, size_t n)
{
    char *q = dst;
    while (n--) {
        *q++ = c;
    }
    return dst;
}

void min_memswap(void *m1, void *m2, size_t n)
{
    char *p = m1;
    char *q = m2;
    char tmp;

    while (n--) {
        tmp = *p;
        *p = *q;
        *q = tmp;

        p++;
        q++;
    }
}

int min_strcasecmp(const char *s1, const char *s2)
{
    const unsigned char *c1 = (const unsigned char *)s1;
    const unsigned char *c2 = (const unsigned char *)s2;
    unsigned char ch;
    int d = 0;
    while (1) {
        d = min_toupper(ch = *c1++) - min_toupper(*c2++);
        if (d || !ch)
            break;
    }
    return d;
}

char *min_strcat(char *dst, const char *src)
{
    min_strcpy(min_strchr(dst, '\0'), src);
    return dst;
}

char *min_strchr(const char *s, int c)
{
    while (*s != (char)c) {
        if (!*s)
            return 0;
        s++;
    }
    return (char *)s;
}

int min_strcmp(const char *s1, const char *s2)
{
    const unsigned char *c1 = (const unsigned char *)s1;
    const unsigned char *c2 = (const unsigned char *)s2;
    unsigned char ch;
    int d = 0;
    while (1) {
        d = (int)(ch = *c1++) - (int)*c2++;
        if (d || !ch)
            break;
    }
    return d;
}

char *min_strcpy(char *dst, const char *src)
{
    char *q = dst;
    const char *p = src;
    char ch;
    do {
        *q++ = ch = *p++;
    } while (ch);

    return dst;
}

size_t min_strlcat(char *dst, const char *src, size_t size)
{
    size_t bytes = 0;
    char *q = dst;
    const char *p = src;
    char ch;
    while (bytes < size && *q) {
        q++;
        bytes++;
    }
    if (bytes == size)
        return (bytes + min_strlen(src));

    while ((ch = *p++)) {
        if (bytes + 1 < size)
            *q++ = ch;

        bytes++;
    }
    *q = '\0';
    return bytes;
}

size_t min_strlcpy(char *dst, const char *src, size_t size)
{
    size_t bytes = 0;
    char *q = dst;
    const char *p = src;
    char ch;

    while ((ch = *p++)) {
        if (bytes + 1 < size)
            *q++ = ch;

        bytes++;
    }
    if (size)
        *q = '\0';
    return bytes;
}

size_t min_strlen(const char *s)
{
    const char *ss = s;
    while (*ss)
        ss++;
    return ss - s;
}

int min_strncasecmp(const char *s1, const char *s2, size_t n)
{
    const unsigned char *c1 = (const unsigned char *)s1;
    const unsigned char *c2 = (const unsigned char *)s2;
    unsigned char ch;
    int d = 0;
    while (n--) {
        d = min_toupper(ch = *c1++) - min_toupper(*c2++);
        if (d || !ch)
            break;
    }
    return d;
}

char *min_strncat(char *dst, const char *src, size_t n)
{
    char *q = min_strchr(dst, '\0');
    const char *p = src;
    char ch;
    while (n--) {
        *q++ = ch = *p++;
        if (!ch)
            return dst;
    }
    *q = '\0';
    return dst;
}

int min_strncmp(const char *s1, const char *s2, size_t n)
{
    const unsigned char *c1 = (const unsigned char *)s1;
    const unsigned char *c2 = (const unsigned char *)s2;
    unsigned char ch;
    int d = 0;
    while (n--) {
        d = (int)(ch = *c1++) - (int)*c2++;
        if (d || !ch)
            break;
    }
    return d;
}

char *min_strncpy(char *dst, const char *src, size_t n)
{
    char *q = dst;
    const char *p = src;
    char ch;
    while (n) {
        n--;
        *q++ = ch = *p++;
        if (!ch)
            break;
    }
    min_memset(q, 0, n);
    return dst;
}

size_t min_strnlen(const char *s, size_t maxlen)
{
    const char *ss = s;
    while ((maxlen > 0) && *ss) {
        ss++;
        maxlen--;
    }
    return ss - s;
}

char *min_strpbrk(const char *s1, const char *s2)
{
    const char *c = s2;
    if (!*s1)
        return (char *)0;
    while (*s1) {
        for (c = s2; *c; c++) {
            if (*s1 == *c)
                break;
        }
        if (*c)
            break;
        s1++;
    }
    if (*c == '\0')
        s1 = 0;
    return (char *)s1;
}

char *min_strrchr(const char *s, int c)
{
    const char *found = 0;
    while (*s) {
        if (*s == (char)c)
            found = s;
        s++;
    }
    return (char *)found;
}

char *min_strsep(char **stringp, const char *delim)
{
    char *s = *stringp;
    char *e;
    if (!s)
        return 0;
    e = min_strpbrk(s, delim);
    if (e)
        *e++ = '\0';
    *stringp = e;
    return s;
}

size_t min_strspn(const char *s1, const char *s2)
{
    const char *s = s1;
    const char *c;
    while (*s1) {
        for (c = s2; *c; c++) {
            if (*s1 == *c)
                break;
        }
        if (*c == '\0')
            break;
        s1++;
    }
    return s1 - s;
}

char *min_strstr(const char *haystack, const char *needle)
{
    return (char *)min_memmem(haystack, min_strlen(haystack), needle, min_strlen(needle));
}

char *min_strtok(char *s, const char *delim)
{
    static char *holder;
    return min_strtok_r(s, delim, &holder);
}

char *min_strtok_r(char *s, const char *delim, char **holder)
{
    if (s)
        *holder = s;
    do {
        s = min_strsep(holder, delim);
    } while (s && !*s);
    return s;
}
```

`kernel/minc/string.h`:

```h
#ifndef _KP_STRING_H_
#define _KP_STRING_H_

#include <stdint.h>

void *min_memccpy(void *, const void *, int, size_t);
void *min_memchr(const void *, int, size_t);
void *min_memrchr(const void *, int, size_t);
int min_memcmp(const void *, const void *, size_t);
void *min_memcpy(void *, const void *, size_t);
void *min_memmove(void *, const void *, size_t);
void *min_memset(void *, int, size_t);
void *min_memmem(const void *, size_t, const void *, size_t);
void min_memswap(void *, void *, size_t);
void min_bzero(void *, size_t);
int min_strcasecmp(const char *, const char *);
int min_strncasecmp(const char *, const char *, size_t);
char *min_strcat(char *, const char *);
char *min_strchr(const char *, int);
char *min_index(const char *, int);
char *min_strrchr(const char *, int);
char *min_rindex(const char *, int);
int min_strcmp(const char *, const char *);
char *min_strcpy(char *, const char *);
size_t min_strcspn(const char *, const char *);
char *min_strdup(const char *);
char *min_strndup(const char *, size_t);
size_t min_strlen(const char *);
size_t min_strnlen(const char *, size_t);
char *min_strncat(char *, const char *, size_t);
size_t min_strlcat(char *, const char *, size_t);
int min_strncmp(const char *, const char *, size_t);
char *min_strncpy(char *, const char *, size_t);
size_t min_strlcpy(char *, const char *, size_t);
char *min_strpbrk(const char *, const char *);
char *min_strsep(char **, const char *);
size_t min_strspn(const char *, const char *);
char *min_strstr(const char *, const char *);
char *min_strtok(char *, const char *);
char *min_strtok_r(char *, const char *, char **);

inline static int min_strcoll(const char *s1, const char *s2)
{
    return min_strcmp(s1, s2);
}

inline static size_t min_strxfrm(char *dest, const char *src, size_t n)
{
    min_strncpy(dest, src, n);
    return min_strlen(src);
}

#endif
```

`kernel/module/hello/Makefile`:

```
ifndef TARGET_COMPILE
    $(error TARGET_COMPILE is not set)
endif

CC = $(TARGET_COMPILE)gcc
LD = $(TARGET_COMPILE)ld

CFLAGS = -std=c11 -Wall

objs := hello.O

all: kpm_hello

kpm_hello: hello.o ${objs}
	${CC} -fpic -shared -o $@ $^

%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

.PHONY: clean
clean:
	rm -rf kpm_hello
	find . -name "*.o" | xargs rm -f
```

`kernel/module/hello/hello.c`:

```c


int kpm_init()
{
    return 0;
}

int kpm_uninit()
{
    return 0;
}
```

`kernel/module/module.c`:

```c
#include "module.h"
```

`kernel/module/module.h`:

```h
#ifndef _KP_MODULE_H_
#define _KP_MODULE_H_

#define Elf_Shdr Elf64_Shdr
#define Elf_Phdr Elf64_Phdr
#define Elf_Sym Elf64_Sym
#define Elf_Dyn Elf64_Dyn
#define Elf_Ehdr Elf64_Ehdr
#define Elf_Addr Elf64_Addr
#ifdef CONFIG_MODULES_USE_ELF_REL
#define Elf_Rel Elf64_Rel
#endif
#ifdef CONFIG_MODULES_USE_ELF_RELA
#define Elf_Rela Elf64_Rela
#endif
#define ELF_R_TYPE(X) ELF64_R_TYPE(X)
#define ELF_R_SYM(X) ELF64_R_SYM(X)

#endif
```

`kernel/version`:

```
#define MAJOR 0
#define MINOR 1
#define PATCH 0
```

`tools/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

project (kptools)

set(SOURCES
	image.c
	kallsym.c
	kptools.c
	order.c
)

add_executable(
	kptools 
	${SOURCES}
)
```

`tools/Makefile`:

```

CFLAGS = -std=c11 -Wall -Wextra -Wno-unused -Wno-unused-parameter

objs := image.o kallsym.o kptools.o order.o

kptools: ${objs}
	${CC} -o $@ $^

%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

.PHONY: clean
clean:
	rm -rf preset.h
	rm -rf kptools
	find . -name "*.o" | xargs rm -f
```

`tools/image.c`:

```c
#include "image.h"

#include <inttypes.h>
#include <stdio.h>
#include <string.h>

#include "order.h"

#define EFI_MAGIC_SIG "MZ"
#define KERNEL_MAGIC "ARM\x64"

typedef struct
{
    union _entry
    {
        // #ifdef CONFIG_EFI
        struct _efi
        {
            uint8_t mz[4]; // "MZ" signature required by UEFI.
            uint32_t b_insn; // branch to kernel start, magic
        } efi;
        // #else
        struct _nefi
        {
            uint32_t b_insn; // branch to kernel start, magic
            uint32_t reserved0;
        } nefi;
        // #endif
    } hdr;

    uint64_t kernel_offset; // Image load load_offset from start of RAM, little-endian
    uint64_t kernel_size_le; // Effective size of kernel image, little-endian
    uint64_t kernel_flag_le; // Informative flags, little-endian

    uint64_t reserved0;
    uint64_t reserved1;
    uint64_t reserved2;

    char magic[4]; // Magic number "ARM\x64"

    union _pe
    {
        // #ifdef CONFIG_EFI
        uint64_t pe_offset; // Offset to the PE header.
        // #else
        uint64_t npe_reserved;
        // #endif
    } pe;
} arm64_hdr_t;

int32_t get_kernel_info(kernel_info_t *kinfo, char *img, int32_t imglen)
{
    kinfo->is_be = 0;

    arm64_hdr_t *khdr = (arm64_hdr_t *)img;
    if (strncmp(khdr->magic, KERNEL_MAGIC, strlen(KERNEL_MAGIC))) {
        printf("[-] kernel magic error :%s\n", khdr->magic);
        return -1;
    }

    kinfo->uefi = !strncmp((const char *)khdr->hdr.efi.mz, EFI_MAGIC_SIG, strlen(EFI_MAGIC_SIG));

    uint32_t b_primary_entry_insn;
    uint32_t b_stext_insn_offset;
    if (kinfo->uefi) {
        b_primary_entry_insn = khdr->hdr.efi.b_insn;
        b_stext_insn_offset = 4;
    } else {
        b_primary_entry_insn = khdr->hdr.nefi.b_insn;
        b_stext_insn_offset = 0;
    }
    kinfo->b_stext_insn_offset = b_stext_insn_offset;

    b_primary_entry_insn = u32le(b_primary_entry_insn);
    if ((b_primary_entry_insn & 0xFC000000) != 0x14000000) {
        return -1;
    } else {
        uint32_t imm = (b_primary_entry_insn & 0x03ffffff) << 2;
        kinfo->primary_entry_offset = imm + b_stext_insn_offset;
    }

    kinfo->load_offset = u64le(khdr->kernel_offset);
    kinfo->kernel_size = u64le(khdr->kernel_size_le);

    uint8_t flag = u64le(khdr->kernel_flag_le) & 0x0f;
    kinfo->is_be = flag & 0x01;
    if (kinfo->is_be) {
        printf("[-] kernel unexpected arm64 big endian img\n");
        return -1;
    }

    switch ((flag & 0b0110) >> 1) {
    case 2: // 16k
        kinfo->page_shift = 14;
        break;
    case 3: // 64k
        kinfo->page_shift = 16;
        break;
    case 1: // 4k
    default:
        kinfo->page_shift = 12;
    }

    printf("[+] kernel image_size: 0x%08x\n", imglen);
    printf("[+] kernel uefi header: %s\n", kinfo->uefi ? "true" : "false");
    printf("[+] kernel load_offset: 0x%08x\n", kinfo->load_offset);
    printf("[+] kernel kernel_size: 0x%08x\n", kinfo->kernel_size);
    printf("[+] kernel page_shift: %d\n", kinfo->page_shift);
    return 0;
}

int32_t kernel_resize(kernel_info_t *kinfo, char *img, int32_t size)
{
    arm64_hdr_t *khdr = (arm64_hdr_t *)img;
    uint64_t ksize = size;
    if (is_be() ^ kinfo->is_be)
        ksize = u64swp(size);
    khdr->kernel_size_le = ksize;
    return 0;
}
```

`tools/image.h`:

```h
#ifndef _IMAGE_H_
#define _IMAGE_H_

#include <stdint.h>

// /arch/arm64/kernel/head.S

typedef struct
{
    int8_t is_be; // 0: little, 1: big
    int8_t uefi; //
    int32_t load_offset;
    int32_t kernel_size;
    int32_t page_shift;
    int32_t b_stext_insn_offset;
    int32_t primary_entry_offset;
} kernel_info_t;

int32_t get_kernel_info(kernel_info_t *kinfo, char *img, int32_t imglen);
int32_t kernel_resize(kernel_info_t *kinfo, char *img, int32_t size);

#endif

```

`tools/kallsym.c`:

```c
#include "kallsym.h"

#define _GNU_SOURCE
#define __USE_GNU

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "order.h"

static int64_t int_unpack(void *ptr, int32_t size, int32_t is_be)
{
    int16_t res16;
    int32_t res32;
    int64_t res64;
    switch (size) {
    case 8:
        res64 = *(int64_t *)ptr;
        return is_be ? i64be(res64) : i64le(res64);
    case 4:
        res32 = *(int32_t *)ptr;
        return is_be ? i32be(res32) : i32le(res32);
    case 2:
        res16 = *(int16_t *)ptr;
        return is_be ? i16be(res16) : i16le(res16);
    default:
        return *(int8_t *)ptr;
    }
}

static uint64_t uint_unpack(void *ptr, int32_t size, int32_t is_be)
{
    uint16_t res16;
    uint32_t res32;
    uint64_t res64;
    switch (size) {
    case 8:
        res64 = *(uint64_t *)ptr;
        return is_be ? u64be(res64) : u64le(res64);
    case 4:
        res32 = *(uint32_t *)ptr;
        return is_be ? u32be(res32) : u32le(res32);
    case 2:
        res16 = *(uint16_t *)ptr;
        return is_be ? u16be(res16) : u16le(res16);
    default:
        return *(uint8_t *)ptr;
    }
}

static int find_linux_banner(kallsym_t *info, char *img, int32_t imglen)
{
    /*
	// todo: linux_proc_banner
  const char linux_banner[] =
        "Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
        LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
  Linux version 4.9.270-g862f51bac900-ab7613625 (android-build@abfarm-east4-101)
  (Android (7284624, based on r416183b) clang version 12.0.5
  (https://android.googlesource.com/toolchain/llvm-project
  c935d99d7cf2016289302412d708641d52d2f7ee)) #0 SMP PREEMPT Thu Aug 5 07:04:42
  UTC 2021
  */
    char linux_banner_prefix[] = "Linux version ";
    size_t prefix_len = strlen(linux_banner_prefix);

    char *banner = (char *)img;
    while ((banner = (char *)memmem(banner + 1, imglen, linux_banner_prefix, prefix_len)) != NULL)
        if (isdigit(*(banner + prefix_len)) && *(banner + prefix_len + 1) == '.')
            break;

    info->linux_banner_offset = (int32_t)(banner - img);
    printf("[+] kernel linux_banner offset: 0x%08x\n", info->linux_banner_offset);
    printf("[+] kernel linux_banner: %s", banner);

    char *uts_release_start = banner + prefix_len;
    char *space = strchr(banner + prefix_len, ' ');

    char *dot = NULL;
    info->version.major = strtol(uts_release_start, &dot, 10);
    info->version.minor = strtol(dot + 1, &dot, 10);
    info->version.patch = strtol(dot + 1, &dot, 10);

    printf("[+] kernel version major: %d, minor: %d, patch: %d \n", info->version.major, info->version.minor,
           info->version.patch);
    return 0;
}

static int dump_kernel_config(kallsym_t *info, char *img, int32_t imglen)
{
    // todo:
    /*
  kernel configuration
  when CONFIG_IKCONFIG is enabled
  archived in GZip format between the magic string 'IKCFG_ST' and 'IKCFG_ED' in
  the built kernel.
  */
    printf("[!] dump_kernel_config not implemented\n");
    return 0;
}

static int find_token_table(kallsym_t *info, char *img, int32_t imglen)
{
    char nums_syms[20] = { '\0' };
    for (int32_t i = 0; i < 10; i++)
        nums_syms[i * 2] = '0' + i;
    // We just check first 10 letters, not all letters are guaranteed to appear,
    // In fact, the previous numbers may not always appear too.
    char letters_syms[20] = { '\0' };
    for (int32_t i = 0; i < 10; i++)
        letters_syms[i * 2] = 'a' + i;

    char *pos = img;
    char *num_start = NULL;
    char *imgend = img + imglen;
    for (; pos < imgend; pos = num_start + 1) {
        num_start = (char *)memmem(pos, imgend - pos, nums_syms, sizeof(nums_syms));
        if (!num_start) {
            printf("[-] kallsyms find token_table error\n");
            return -1;
        }
        char *num_end = num_start + sizeof(nums_syms);
        if (!*num_end || !*(num_end + 1))
            continue;

        char *letter = num_end;
        for (int32_t i = 0; letter < imgend && i < 'a' - '9' - 1; letter++) {
            if (!*letter)
                i++;
        }
        if (letter != (char *)memmem(letter, sizeof(letters_syms), letters_syms, sizeof(letters_syms)))
            continue;
        break;
    }

    // backward to start
    pos = num_start;
    for (int32_t i = 0; pos > img && i < '0' + 1; pos--) {
        if (!*pos)
            i++;
    }
    int32_t offset = pos + 2 - img;

    info->kallsyms_token_table_offset = offset;
    printf("[+] kallsyms kallsyms_token_table offset: 0x%08x\n", offset);

    // rebuild token_table
    pos = img + info->kallsyms_token_table_offset;
    for (int32_t i = 0; i < KSYM_TOKEN_NUMS; i++) {
        info->kallsyms_token_table[i] = pos;
        while (*(pos++)) {
        };
    }
    // printf("[+] kallsyms token table: ");
    // for (int32_t i = 0; i < KSYM_TOKEN_NUMS; i++) {
    //   printf("%s ", info->kallsyms_token_table[i]);
    // }
    // printf("\n");
    return 0;
}

static int find_token_index(kallsym_t *info, char *img, int32_t imglen)
{
    uint16_t le_index[KSYM_TOKEN_NUMS] = { 0 };
    uint16_t be_index[KSYM_TOKEN_NUMS] = { 0 };

    int32_t start = info->kallsyms_token_table_offset;
    int32_t offset = start;

    // build kallsyms_token_index according to kallsyms_token_table
    for (int32_t i = 0; i < KSYM_TOKEN_NUMS; i++) {
        uint16_t token_index = offset - start;
        le_index[i] = u16le(token_index);
        be_index[i] = u16be(token_index);
        while (img[offset++]) {
        };
    }
    // find kallsyms_token_index
    char *lepos = (char *)memmem(img, imglen, le_index, sizeof(le_index));
    char *bepos = (char *)memmem(img, imglen, be_index, sizeof(be_index));

    if (!lepos && !bepos) {
        printf("[-] kallsyms kallsyms_token_index error\n");
        return -1;
    }
    printf("[+] kallsyms endian: %s\n", lepos ? "little" : "big");

    char *pos = lepos ? lepos : bepos;
    info->is_be = lepos ? 0 : 1;

    info->kallsyms_token_index_offset = pos - img;

    printf("[+] kallsyms kallsyms_token_index offset: 0x%08x\n", info->kallsyms_token_index_offset);
    return 0;
}

static int get_markers_elem_size(kallsym_t *info)
{
    /*
  Before 4.20, type of kallsyms_markers is PTR which
  depends on macro BITS_PER_LONG. When BITS_PER_LONG is 64, PTR is .quad (8
  bytes), otherwise .long (4bytes). Since 4.20, type of kallsyms_markers is
  .long (4 bytes)
  */
    int32_t elem_size = info->asm_long_size;
    if (info->version.major < 4 || (info->version.major == 4 && info->version.minor < 20))
        elem_size = info->asm_PTR_size;
    return elem_size;
}

static int get_num_syms_elem_size(kallsym_t *info)
{
    // the same as kallsyms_markers
    int32_t elem_size = info->asm_long_size;
    if (info->version.major < 4 || (info->version.major == 4 && info->version.minor < 20))
        elem_size = info->asm_PTR_size;
    return elem_size;
}

static inline int get_addresses_elem_size(kallsym_t *info)
{
    return info->asm_PTR_size;
}

static inline int get_offsets_elem_size(kallsym_t *info)
{
    return info->asm_long_size;
}

static int try_find_arm64_relo_table(kallsym_t *info, char *img, int32_t imglen)
{
    if (!info->try_relo)
        return 0;
    uint64_t min_va = 0xffffff8008080000;
    uint64_t max_va = 0xffffffffffffffff;
    uint64_t kernel_va = max_va;
    int32_t cand = 0;
    int rela_num = 0;
    while (cand < imglen - 24) {
        uint64_t r_offset = uint_unpack(img + cand, 8, info->is_be);
        uint64_t r_info = uint_unpack(img + cand + 8, 8, info->is_be);
        uint64_t r_addend = uint_unpack(img + cand + 16, 8, info->is_be);
        if ((r_offset & 0xffff000000000000) == 0xffff000000000000 && r_info == 0x403) {
            cand += 24;
            rela_num++;
            if (!(r_addend & 0xfff) && r_addend >= min_va && r_addend < kernel_va)
                kernel_va = r_addend;
        } else if (rela_num && !r_offset && !r_info && !r_addend) {
            cand += 24;
            rela_num++;
        } else {
            if (rela_num >= ARM64_RELO_MIN_NUM)
                break;
            cand += 8;
            rela_num = 0;
            kernel_va = max_va;
        }
    }
    int32_t cand_start = cand - 24 * rela_num;
    int32_t cand_end = cand - 24;
    while (1) {
        if (*(uint64_t *)(img + cand_end) && *(uint64_t *)(img + cand_end + 8) && *(uint64_t *)(img + cand_end + 16))
            break;
        cand_end -= 24;
    }
    cand_end += 24;

    rela_num = (cand_end - cand_start) / 24;
    if (rela_num < ARM64_RELO_MIN_NUM) {
        printf("[-] kallsyms find arm64 relocation table error\n");
        return 0;
    }
    printf("[+] kallsyms find arm64 relocation table range: [0x%08x, 0x%08x), text_va: 0x%08lx, count: 0x%08x\n",
           cand_start, cand_end, kernel_va, rela_num);

    // apply relocations
    int32_t apply_num = 0;
    for (cand = cand_start; cand < cand_end; cand += 24) {
        uint64_t r_offset = uint_unpack(img + cand, 8, info->is_be);
        uint64_t r_info = uint_unpack(img + cand + 8, 8, info->is_be);
        uint64_t r_addend = uint_unpack(img + cand + 16, 8, info->is_be);
        if (!r_offset && !r_info && !r_addend)
            continue;
        if (r_offset <= kernel_va || r_offset >= max_va - imglen) {
            // printf("[-] kallsyms warn ignore arm64 relocation r_offset: 0x%08lx at 0x%08x\n", r_offset, cand);
            continue;
        }
        int32_t offset = r_offset - kernel_va;
        uint64_t value = uint_unpack(img + offset, 8, info->is_be);
        if (value == r_addend)
            continue;
        *(uint64_t *)(img + offset) = value + r_addend;
        apply_num++;
    }
    printf("[+] kallsyms apply 0x%08x relocation entries\n", apply_num);
    return 0;
}

static int find_approx_addresses(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t sym_num = 0;
    int32_t elem_size = info->asm_PTR_size;
    uint64_t prev_offset = 0;
    int32_t cand = 0;
    for (; cand < imglen - KSYM_MIN_NEQ_SYMS * elem_size; cand += elem_size) {
        uint64_t address = uint_unpack(img + cand, elem_size, info->is_be);
        if (!sym_num) { // first address
            if (address & 0xfff)
                continue;
            if (elem_size == 4 && (address & 0xff800000) != 0xff800000)
                continue;
            if (elem_size == 8 && (address & 0xffff000000000000) != 0xffff000000000000)
                continue;
            prev_offset = address;
            sym_num++;
            continue;
        }
        if (address >= prev_offset) {
            prev_offset = address;
            if (sym_num++ >= KSYM_MIN_NEQ_SYMS)
                break;
        } else {
            prev_offset = 0;
            sym_num = 0;
        }
    }
    if (sym_num < KSYM_MIN_NEQ_SYMS) {
        printf("[-] kallsyms find approximate kallsyms_addresses error\n");
        return -1;
    }

    cand -= KSYM_MIN_NEQ_SYMS * elem_size;
    int32_t approx_offset = cand;
    info->_approx_addresses_or_offsets_offset = approx_offset;

    // approximate kallsyms_addresses end
    prev_offset = 0;
    for (; cand < imglen; cand += elem_size) {
        uint64_t offset = uint_unpack(img + cand, elem_size, info->is_be);
        if (offset < prev_offset)
            break;
        prev_offset = offset;
    }
    // end is not include
    info->_approx_addresses_or_offsets_end = cand;
    info->has_relative_base = 0;
    int32_t approx_num_syms = (cand - approx_offset) / elem_size;
    info->_approx_addresses_or_offsets_num = approx_num_syms;
    printf("[+] kallsyms approximate kallsyms_addresses range: [0x%08x, 0x%08x) "
           "count: 0x%08x\n",
           approx_offset, cand, approx_num_syms);
    return 0;
}

static int find_approx_offsets(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t sym_num = 0;
    int32_t elem_size = info->asm_long_size;
    int64_t prev_offset = 0;
    int32_t cand = 0;
    int32_t MAX_ZERO_OFFSET_NUM = 10;
    int32_t zero_offset_num = 0;
    for (; cand < imglen - KSYM_MIN_NEQ_SYMS * elem_size; cand += elem_size) {
        int64_t offset = int_unpack(img + cand, elem_size, info->is_be);
        if (offset == prev_offset) { // 0 offset
            continue;
        } else if (offset > prev_offset) {
            prev_offset = offset;
            if (sym_num++ >= KSYM_MIN_NEQ_SYMS)
                break;
        } else {
            prev_offset = 0;
            sym_num = 0;
        }
    }
    if (sym_num < KSYM_MIN_NEQ_SYMS) {
        printf("[-] kallsyms find approximate kallsyms_offsets error\n");
        return -1;
    }
    cand -= KSYM_MIN_NEQ_SYMS * elem_size;
    for (;; cand -= elem_size)
        if (!int_unpack(img + cand, elem_size, info->is_be))
            break;
    for (;; cand -= elem_size) {
        if (int_unpack(img + cand, elem_size, info->is_be))
            break;
        if (zero_offset_num++ >= MAX_ZERO_OFFSET_NUM)
            break;
    }
    cand += elem_size;
    int32_t approx_offset = cand;
    info->_approx_addresses_or_offsets_offset = approx_offset;

    // approximate kallsyms_offsets end
    prev_offset = 0;
    for (; cand < imglen; cand += elem_size) {
        int64_t offset = int_unpack(img + cand, elem_size, info->is_be);
        if (offset < prev_offset)
            break;
        prev_offset = offset;
    }
    // note: the last symbol may not be 4k alinged
    // end is not include
    int32_t end = cand;
    info->_approx_addresses_or_offsets_end = end;
    info->has_relative_base = 1;
    int32_t approx_num_syms = (end - approx_offset) / elem_size;
    info->_approx_addresses_or_offsets_num = approx_num_syms;
    // The real interval is contained in this approximate interval
    printf("[+] kallsyms approximate kallsyms_offsets range: [0x%08x, 0x%08x) "
           "count: 0x%08x\n",
           approx_offset, end, approx_num_syms);
    return 0;
}

static int32_t find_approx_addresses_or_offset(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t ret = 0;
    if (info->version.major > 4 || (info->version.major == 4 && info->version.minor >= 6)) {
        // may have kallsyms_relative_base
        ret = find_approx_offsets(info, img, imglen);
        if (!ret)
            return 0;
    }
    ret = find_approx_addresses(info, img, imglen);
    return ret;
}

static int find_num_syms(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t approx_end = info->_approx_addresses_or_offsets_end;
    int32_t num_syms_elem_size = get_num_syms_elem_size(info);
    int32_t approx_num_syms = info->_approx_addresses_or_offsets_num;
    int32_t nsyms = 0;
    int32_t nsyms_max_offset = approx_end + 4096;
    int32_t NSYMS_MAX_GAP = 20;
    int32_t LAST_SYM_EQUAL_NUM = 10;
    int32_t cand = approx_end / num_syms_elem_size * num_syms_elem_size - LAST_SYM_EQUAL_NUM * num_syms_elem_size;

    for (; cand < nsyms_max_offset; cand += num_syms_elem_size) {
        nsyms = (int)int_unpack(img + cand, num_syms_elem_size, info->is_be);
        if (approx_num_syms >= nsyms && approx_num_syms - nsyms < NSYMS_MAX_GAP)
            break;
    }
    if (cand >= nsyms_max_offset) {
        printf("[-] kallsyms kallsyms_num_syms error\n");
        return -1;
    } else {
        info->kallsyms_num_syms = nsyms;
        info->kallsyms_num_syms_offset = cand;
        printf("[+] kallsyms kallsyms_num_syms offset: 0x%08x, value: 0x%08x\n", cand, nsyms);
    }
    return 0;
}

static int find_markers(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t elem_size = get_markers_elem_size(info);
    int32_t cand = info->kallsyms_token_table_offset - elem_size;
    int64_t marker;
    for (;; cand -= elem_size) {
        marker = int_unpack(img + cand, elem_size, info->is_be);
        if (marker)
            break;
    }
    int32_t marker_end = cand + elem_size;
    int64_t last_marker = 0x7fffffff;
    for (;; cand -= elem_size) {
        marker = int_unpack(img + cand, elem_size, info->is_be);
        if (!marker || last_marker <= marker)
            break;
        last_marker = marker;
    }
    int32_t marker_num = (marker_end - cand) / elem_size;
    if (marker || marker_num < KSYM_MIN_MARKER) {
        printf("[-] kallsyms find kallsyms_markers error\n");
        return -1;
    }
    info->kallsyms_markers_offset = cand;
    info->_marker_num = marker_num;
    printf("[+] kallsyms kallsyms_markers range: [0x%08x, 0x%08x), count: 0x%08x\n", cand, marker_end, marker_num);
    return 0;
}

static int decompress_symbol_name(kallsym_t *info, char *img, int32_t *pos_to_next, char *out_type, char *out_symbol)
{
    int32_t pos = *pos_to_next;
    int32_t len = *(uint8_t *)(img + pos++);
    if (len > 0x7F)
        len = (len & 0x7F) + (*(uint8_t *)(img + pos++) << 7);
    if (!len || len >= KSYM_SYMBOL_LEN)
        return -1;

    *pos_to_next = pos + len;
    for (int32_t i = 0; i < len; i++) {
        int32_t tokidx = *(uint8_t *)(img + pos + i);
        char *token = info->kallsyms_token_table[tokidx];
        if (!i) { // first character, symbol type
            if (out_type)
                *out_type = *token;
            token++;
        }
        if (out_symbol)
            strcat(out_symbol, token);
    }
    return 0;
}

static int is_symbol_name_pos(kallsym_t *info, char *img, int32_t pos, char *symbol)
{
    int32_t len = *(uint8_t *)(img + pos++);
    if (len > 0x7F)
        len = (len & 0x7F) + (*(uint8_t *)(img + pos++) << 7);
    if (!len || len >= KSYM_SYMBOL_LEN)
        return 0;
    int32_t symidx = 0;
    for (int32_t i = 0; i < len; i++) {
        int32_t tokidx = *(uint8_t *)(img + pos + i);
        char *token = info->kallsyms_token_table[tokidx];
        if (!i)
            token++; // ignore symbol type
        int32_t toklen = strlen(token);
        if (strncmp(symbol + symidx, token, toklen))
            break;
        symidx += toklen;
    }
    return (int32_t)strlen(symbol) == symidx;
}

static int find_names(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t marker_elem_size = get_markers_elem_size(info);
    int32_t cand = info->_approx_addresses_or_offsets_offset;
    int32_t test_marker_num = -1;
    for (; cand < info->kallsyms_markers_offset; cand++) {
        int32_t pos = cand;
        test_marker_num = KSYM_FIND_NAMES_USED_MARKER; // check n * 256 symbols
        for (int32_t i = 0;; i++) {
            int32_t len = *(uint8_t *)(img + pos++);
            if (len > 0x7F)
                len = (len & 0x7F) + (*(uint8_t *)(img + pos++) << 7);
            if (!len || len >= KSYM_SYMBOL_LEN)
                break;
            pos += len;
            if (pos >= info->kallsyms_markers_offset)
                break;

            if (i && (i & 0xFF) == 0xFF) { // every 256 symbols
                int32_t mark_len = int_unpack(img + info->kallsyms_markers_offset + ((i >> 8) + 1) * marker_elem_size,
                                              marker_elem_size, info->is_be);
                if (pos - cand != mark_len)
                    break;
                if (!--test_marker_num)
                    break;
            }
        }
        if (!test_marker_num)
            break;
    }
    if (test_marker_num) {
        printf("[-] kallsyms find kallsyms_names error\n");
        return -1;
    }
    info->kallsyms_names_offset = cand;
    printf("[+] kallsyms kallsyms_names offset: 0x%08x\n", cand);
    return 0;
}

static int correct_addresses_or_offsets(kallsym_t *info, char *img, int32_t imglen)
{
    int32_t pos = info->kallsyms_names_offset;
    int32_t index = 0;
    char symbol[KSYM_SYMBOL_LEN] = { '\0' };
    // Pick a symbol (linux_banner) whose offset we know, use its index to fix the
    // beginning of the addresses or offsets table
    while (pos < info->kallsyms_markers_offset) {
        memset(symbol, 0, sizeof(symbol));
        int32_t ret = decompress_symbol_name(info, img, &pos, NULL, symbol);
        if (!ret && !strcmp(symbol, "linux_banner")) {
            printf("[+] kallsyms linux_banner index: 0x%08x\n", index);
            break;
        }
        index++;
    }

    // find correct addresses or offsets
    int32_t target_offset = info->linux_banner_offset;
    int32_t elem_size = info->has_relative_base ? get_offsets_elem_size(info) : get_addresses_elem_size(info);
    pos = info->_approx_addresses_or_offsets_offset;
    int32_t end = pos + 4096 + elem_size;
    for (; pos < end; pos += elem_size) {
        uint64_t first_elem_val = uint_unpack(img + pos, elem_size, info->is_be);
        int32_t offset = uint_unpack(img + pos + index * elem_size, elem_size, info->is_be) - first_elem_val;
        if (offset == target_offset)
            break;
    }

    if (pos >= end) {
        printf("[-] kallsyms correct addressed or offsets error\n");
        return -1;
    }

    if (info->has_relative_base) {
        info->kallsyms_offsets_offset = pos;
        printf("[+] kallsyms kallsyms_offsets offset: 0x%08x\n", pos);
    } else {
        info->kallsyms_addresses_offset = pos;
        printf("[+] kallsyms kallsyms_addresses offset: 0x%08x\n", pos);
    }
    return 0;
}

void init_arm64_kallsym_t(kallsym_t *info)
{
    memset(info, 0, sizeof(kallsym_t));
    info->is_64 = 1;
    info->asm_long_size = 4;
    info->asm_PTR_size = 8;
    info->try_relo = 1;
}

void init_not_tested_arch_kallsym_t(kallsym_t *info, int32_t is_64)
{
    memset(info, 0, sizeof(kallsym_t));
    info->is_64 = is_64;
    info->asm_long_size = 4;
    info->asm_PTR_size = 4;
    info->try_relo = 0;
    if (is_64)
        info->asm_PTR_size = 8;
}

/*
R kallsyms_offsets
R kallsyms_relative_base
R kallsyms_num_syms
R kallsyms_names
R kallsyms_markers
R kallsyms_token_table
R kallsyms_token_index
*/
int analyze_kallsym_info(kallsym_t *info, char *img, int32_t imglen, enum arch_type arch, int32_t is_64)
{
    memset(info, 0, sizeof(kallsym_t));
    info->is_64 = is_64;
    info->asm_long_size = 4;
    info->asm_PTR_size = 4;
    if (arch == ARM64)
        info->try_relo = 1;
    if (is_64)
        info->asm_PTR_size = 8;

    int32_t (*funcs[])(kallsym_t *, char *, int32_t) = { find_linux_banner,
                                                         find_token_table,
                                                         find_token_index,
                                                         try_find_arm64_relo_table,
                                                         find_markers,
                                                         find_approx_addresses_or_offset,
                                                         find_names,
                                                         find_num_syms,
                                                         correct_addresses_or_offsets };
    for (int i = 0; i < (int)(sizeof(funcs) / sizeof(funcs[0])); i++) {
        if (funcs[i](info, img, imglen))
            return -1;
    }
    return 0;
}

int32_t get_symbol_index_offset(kallsym_t *info, char *img, int32_t index)
{
    int32_t elem_size;
    int32_t pos;
    if (info->has_relative_base) {
        elem_size = get_offsets_elem_size(info);
        pos = info->kallsyms_offsets_offset;
    } else {
        elem_size = get_addresses_elem_size(info);
        pos = info->kallsyms_addresses_offset;
    }
    uint64_t first = uint_unpack(img + pos, elem_size, info->is_be);
    uint64_t target = uint_unpack(img + pos + index * elem_size, elem_size, info->is_be);
    return (int32_t)(target - first);
}

int32_t get_symbol_offset(kallsym_t *info, char *img, char *symbol)
{
    char decomp[KSYM_SYMBOL_LEN] = { '\0' };
    char type = 0;
    char **tokens = info->kallsyms_token_table;
    int32_t pos = info->kallsyms_names_offset;
    for (int32_t i = 0; i < info->kallsyms_num_syms; i++) {
        memset(decomp, 0, sizeof(decomp));
        decompress_symbol_name(info, img, &pos, &type, decomp);
        if (!strcmp(decomp, symbol)) {
            int32_t offset = get_symbol_index_offset(info, img, i);
            printf("[+] kallsyms %s: type: %c, offset: 0x%08x\n", symbol, type, offset);
            return offset;
        }
    }
    printf("[-] kallsyms can't find symbol: %s\n", symbol);
    return -1;
}

int dump_all_symbols(kallsym_t *info, char *img)
{
    char symbol[KSYM_SYMBOL_LEN] = { '\0' };
    char type = 0;
    char **tokens = info->kallsyms_token_table;
    int32_t pos = info->kallsyms_names_offset;
    for (int32_t i = 0; i < info->kallsyms_num_syms; i++) {
        memset(symbol, 0, sizeof(symbol));
        decompress_symbol_name(info, img, &pos, &type, symbol);
        int32_t offset = get_symbol_index_offset(info, img, i);
        printf("0x%08x %c %s\n", offset, type, symbol);
    }
    return 0;
}

int on_each_symbol(kallsym_t *info, char *img, void *userdata,
                   int32_t (*fn)(int32_t index, char *type, const char *symbol, int32_t offset, void *userdata))
{
    char symbol[KSYM_SYMBOL_LEN] = { '\0' };
    char type = 0;
    char **tokens = info->kallsyms_token_table;
    int32_t pos = info->kallsyms_names_offset;
    for (int32_t i = 0; i < info->kallsyms_num_syms; i++) {
        memset(symbol, 0, sizeof(symbol));
        decompress_symbol_name(info, img, &pos, &type, symbol);
        int32_t offset = get_symbol_index_offset(info, img, i);
        if (fn(i, &type, symbol, offset, userdata))
            return -1;
    }
    return 0;
}

```

`tools/kallsym.h`:

```h
#ifndef _KALLSYM_H_
#define _KALLSYM_H_

#include <stdint.h>

// script/kallsym.c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

#define KSYM_TOKEN_NUMS 256
#define KSYM_SYMBOL_LEN 512

#define KSYM_MIN_NEQ_SYMS 25600
#define KSYM_MIN_MARKER (KSYM_MIN_NEQ_SYMS / 256)
#define KSYM_FIND_NAMES_USED_MARKER 5

#define ARM64_RELO_MIN_NUM 4000

enum ksym_type
{
    // Seen in actual kernels
    ABSOLUTE = 'A',
    BSS = 'B',
    DATA = 'D',
    RODATA = 'R',
    TEXT = 'T',
    WEAK_OBJECT_WITH_DEFAULT = 'V',
    WEAK_SYMBOL_WITH_DEFAULT = 'W',
    // Seen on nm's manpage
    SMALL_DATA = 'G',
    INDIRECT_FUNCTION = 'I',
    DEBUGGING = 'N',
    STACK_UNWIND = 'P',
    COMMON = 'C',
    SMALL_BSS = 'S',
    UNDEFINED = 'U',
    UNIQUE_GLOBAL = 'u',
    WEAK_OBJECT = 'v',
    WEAK_SYMBOL = 'w',
    STABS_DEBUG = '-',
    UNKNOWN = '?',
};

enum arch_type
{
    ARM64 = 1,
    X86_64,
    ARM_BE,
    ARM_LE,
    X86
};

typedef struct
{
    enum arch_type arch;
    int32_t is_64;
    int32_t is_be;

    int32_t linux_banner_offset;
    struct
    {
        uint8_t _;
        uint8_t patch;
        uint8_t minor;
        uint8_t major;
    } version;

    char *kallsyms_token_table[KSYM_TOKEN_NUMS];
    int32_t asm_long_size;
    int32_t asm_PTR_size;
    int32_t kallsyms_num_syms;

    int32_t has_relative_base;
    int32_t kallsyms_addresses_offset;
    int32_t kallsyms_offsets_offset;
    // int32_t kallsyms_relative_base_offset;  // maybe 0
    int32_t kallsyms_num_syms_offset;
    int32_t kallsyms_names_offset;
    int32_t kallsyms_markers_offset;
    //kallsyms_seqs_of_names  // todo: v6.2
    int32_t kallsyms_token_table_offset;
    int32_t kallsyms_token_index_offset;

    int32_t _approx_addresses_or_offsets_offset;
    int32_t _approx_addresses_or_offsets_end;
    int32_t _approx_addresses_or_offsets_num;
    int32_t _marker_num;

    int32_t try_relo;
    int32_t elf64_rela_num;
    int32_t elf64_rela_offset;

} kallsym_t;

int analyze_kallsym_info(kallsym_t *info, char *img, int32_t imglen, enum arch_type arch, int32_t is_64);
int dump_all_symbols(kallsym_t *info, char *img);
int get_symbol_index_offset(kallsym_t *info, char *img, int32_t index);
int32_t get_symbol_offset(kallsym_t *info, char *img, char *symbol);
int on_each_symbol(kallsym_t *info, char *img, void *userdata,
                   int32_t (*fn)(int32_t index, char *type, const char *symbol, int32_t offset, void *userdata));

#endif // _KALLSYM_H_

```

`tools/kptools.c`:

```c

#include <fcntl.h>
#include <getopt.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <string.h>

#include "preset.h"
#include "image.h"
#include "order.h"
#include "kallsym.h"

#define align_floor(x, align) ((uint64_t)(x) & ~((uint64_t)(align)-1))
#define align_ceil(x, align) (((uint64_t)(x) + (uint64_t)(align)-1) & ~((uint64_t)(align)-1))

#define INSN_IS_B(inst) (((inst)&0xFC000000) == 0x14000000)

#define bits32(n, high, low) ((uint32_t)((n) << (31u - (high))) >> (31u - (high) + (low)))

#define sign64_extend(n, len) \
    (((uint64_t)((n) << (63u - (len - 1))) >> 63u) ? ((n) | (0xFFFFFFFFFFFFFFFF << (len))) : n)

static int can_b_imm(uint64_t from, uint64_t to)
{
    // B: 128M
    uint32_t imm26 = 1 << 25 << 2;
    return (to >= from && to - from <= imm26) || (from >= to && from - to <= imm26);
}

static int b(uint32_t *buf, uint64_t from, uint64_t to)
{
    if (can_b_imm(from, to)) {
        buf[0] = 0x14000000u | (((to - from) & 0x0FFFFFFFu) >> 2u);
        return 4;
    }
    return 0;
}

static char image[FILENAME_MAX] = { '\0' };
static char out[FILENAME_MAX] = { '\0' };
static char kpimg[FILENAME_MAX] = { '\0' };
static char superkey[SUPER_KEY_LEN] = { '\0' };

static kernel_info_t kinfo;
static kallsym_t kallsym;

void print_usage()
{
    char *c = "\nkptools. Kernel Image Patch Tools.\n"
              "\n"
              "Usage: ./kptools <command> [args...]\n"
              "  -h, --help\n"
              "    Print this message.\n"
              "\n"
              "  -p, --patch <kernel_image> <--kpimg kpimg> <--skey super_key> [--out image_patched]\n"
              "  Patch kernel_image with kpimg.\n"
              "    If [--out] is not specified, default ${kernel_image}__patched will be used.\n"
              "    super_key: Authentication key for supercall system call.\n"
              "\n"
              "  -d, --dump <kernel_image>\n"
              "    Analyze and dump kallsyms infomations of kernel_image to stdout.\n"
              "\n";
    fprintf(stdout, "%s", c);
}

int dump_kallsym()
{
    FILE *fin = fopen(image, "rb");
    if (!fin) {
        printf("[-] read file %s error\n", image);
        return EXIT_FAILURE;
    }
    fseek(fin, 0, SEEK_END);
    long image_len = ftell(fin);
    fseek(fin, 0, SEEK_SET);

    char *image_buf = (char *)malloc(image_len);
    fread(image_buf, 1, image_len, fin);

    kallsym_t kallsym;
    if (analyze_kallsym_info(&kallsym, image_buf, image_len, ARM64, 1)) {
        fprintf(stderr, "analyze_kallsym_info error\n");
        return -1;
    }
    dump_all_symbols(&kallsym, image_buf);
    free(image_buf);
    return 0;
}

static int32_t relo_branch_func(const char *img, int32_t func_offset)
{
    uint32_t inst = *(uint32_t *)(img + func_offset);
    int32_t relo_offset = func_offset;
    if (INSN_IS_B(inst)) {
        uint64_t imm26 = bits32(inst, 25, 0);
        uint64_t imm64 = sign64_extend(imm26 << 2u, 28u);
        relo_offset = func_offset + (int32_t)imm64;
        fprintf(stdout, "[+] kptools relocate branch function 0x%x to 0x%x\n", func_offset, relo_offset);
    }
    return relo_offset;
}

static void target_endian_preset(setup_preset_t *preset, int32_t target_is_be)
{
    if (!(is_be() ^ target_is_be))
        return;
    preset->kernel_size = i64swp(preset->kernel_size);
    preset->page_shift = i64swp(preset->page_shift);
    preset->kp_offset = i64swp(preset->kp_offset);
    preset->map_offset = i64swp(preset->map_offset);
    preset->map_max_size = i64swp(preset->map_max_size);
    for (int64_t *pos = (int64_t *)&preset->kallsyms_lookup_name_offset;
         pos <= (int64_t *)&preset->kimage_voffset_offset; pos++) {
        *pos = i64swp(*pos);
    }
}

// todo
void select_map_area(int32_t *map_start, int32_t *max_size)
{
    *map_start = 0x200;
    *max_size = 0x800;
}

int patch_image()
{
    if (!strlen(out)) {
        strcpy(out, image);
        strcat(out, "_patched");
    }
    if (!strlen(kpimg)) {
        fprintf(stderr, "[-] kptools kpimg not specified\n");
        return EXIT_FAILURE;
    }

    FILE *fimage = fopen(image, "rb");
    if (!fimage) {
        fprintf(stderr, "[-] kptools open file %s error\n", image);
        return EXIT_FAILURE;
    }
    fseek(fimage, 0, SEEK_END);
    long image_len = ftell(fimage);
    fprintf(stdout, "[+] kptools image size 0x%08lx\n", image_len);

    fseek(fimage, 0, SEEK_SET);

    char *image_buf = (char *)malloc(image_len);
    fread(image_buf, 1, image_len, fimage);
    fclose(fimage);

    FILE *fkpimg = fopen(kpimg, "rb");
    if (!fkpimg) {
        fprintf(stderr, "[-] kptools open file %s error\n", kpimg);
        return EXIT_FAILURE;
    }
    fseek(fimage, 0, SEEK_END);
    long kpimg_len = ftell(fimage);
    fseek(fkpimg, 0, SEEK_SET);
    fprintf(stdout, "[-] kptools kernel patch image size: 0x%08lx\n", kpimg_len);

    long align_image_len = align_ceil(image_len, 4096);
    long out_len = align_image_len + kpimg_len;

    char *out_buf = (char *)malloc(out_len);
    memset(out_buf, 0, out_len);
    memcpy(out_buf, image_buf, image_len);
    fread(out_buf + align_image_len, 1, kpimg_len, fkpimg);
    fclose(fkpimg);

    get_kernel_info(&kinfo, image_buf, image_len);
    long align_kernel_size = align_ceil(kinfo.kernel_size, 4096);

    fprintf(stdout, "[+] kptools kernel new size 0x%08lx\n", align_kernel_size + kpimg_len);

    if (analyze_kallsym_info(&kallsym, image_buf, image_len, ARM64, 1)) {
        fprintf(stderr, "[-] kptools analyze_kallsym_info error\n");
        return -1;
    }

    setup_header_t *sdata = (setup_header_t *)(out_buf + align_image_len);
    setup_preset_t *preset = (setup_preset_t *)(out_buf + align_image_len + 64);

    preset->kernel_size = kinfo.kernel_size;
    preset->start_offset = align_kernel_size;
    preset->page_shift = kinfo.page_shift;
    sdata->kernel_version.major = kallsym.version.major;
    sdata->kernel_version.minor = kallsym.version.minor;
    sdata->kernel_version.patch = kallsym.version.patch;

    memcpy(preset->header_backup, out_buf, sizeof(preset->header_backup));
    preset->kp_offset = align_image_len;

    int32_t map_start, map_max_size;
    select_map_area(&map_start, &map_max_size);
    preset->map_offset = map_start;
    preset->map_max_size = map_max_size;
    fprintf(stdout, "[+] kptools map_start: 0x%x, max_size: 0x%x\n", map_start, map_max_size);

    preset->kallsyms_lookup_name_offset = get_symbol_offset(&kallsym, image_buf, "kallsyms_lookup_name");

    preset->printk_offset = get_symbol_offset(&kallsym, image_buf, "printk");

    int32_t paging_init_offset = get_symbol_offset(&kallsym, image_buf, "paging_init");
    preset->paging_init_offset = relo_branch_func(image_buf, paging_init_offset);

    preset->memblock_reserve_offset = get_symbol_offset(&kallsym, image_buf, "memblock_reserve");

    preset->memblock_alloc_try_nid_offset = get_symbol_offset(&kallsym, image_buf, "memblock_alloc_try_nid");

    if (preset->memblock_alloc_try_nid_offset <= 0)
        preset->memblock_alloc_try_nid_offset = get_symbol_offset(&kallsym, image_buf, "memblock_virt_alloc_try_nid");
    if (preset->memblock_alloc_try_nid_offset <= 0)
        preset->memblock_alloc_try_nid_offset = get_symbol_offset(&kallsym, image_buf, "memblock_phys_alloc_try_nid");

    preset->memstart_addr_offset = get_symbol_offset(&kallsym, image_buf, "memstart_addr");

    if (preset->memstart_addr_offset < 0)
        preset->memstart_addr_offset = 0;

    preset->vabits_actual_offset = get_symbol_offset(&kallsym, image_buf, "vabits_actual");
    if (preset->vabits_actual_offset < 0)
        preset->vabits_actual_offset = 0;

    preset->kimage_voffset_offset = get_symbol_offset(&kallsym, image_buf, "kimage_voffset");
    if (preset->kimage_voffset_offset < 0)
        preset->kimage_voffset_offset = 0;

    if (strlen(superkey) > 0) {
        strncpy((char *)preset->superkey, superkey, SUPER_KEY_LEN);
    } else {
        fprintf(stdout, "[-] kptools warnning use default key is dangerous!\n");
        strcpy((char *)preset->superkey, "kernel_patch");
    }
    fprintf(stdout, "[+] kptools supercall key: %s\n", preset->superkey);

    // todo:
    // kernel_resize(&kinfo, out_buf, align_kernel_size + align_image_len);
    long text_offset = align_image_len + 4096;
    b((uint32_t *)(out_buf + kinfo.b_stext_insn_offset), kinfo.b_stext_insn_offset, text_offset);

    target_endian_preset(preset, kinfo.is_be);

    FILE *fout = fopen(out, "wb");
    if (!fout) {
        fprintf(stderr, "[-] kptools open file:%s error\n", out);
        return EXIT_FAILURE;
    }
    fwrite(out_buf, out_len, 1, fout);
    fclose(fout);
    fprintf(stdout, "[+] kptools patch done: %s\n", out);
    return 0;
}

int main(int argc, char *argv[])
{
    // todo: optional_argument not work
    struct option longopts[] = { { "help", no_argument, NULL, 'h' },
                                 { "patch", required_argument, NULL, 'p' },
                                 { "skey", required_argument, NULL, 's' },
                                 { "out", required_argument, NULL, 'o' },
                                 { "kpimg", required_argument, NULL, 'k' },
                                 { "dump", required_argument, NULL, 'd' },
                                 { 0, 0, 0, 0 } };
    char *optstr = "hp:d:o:";

    int cmd = '\0';
    int opt = -1;
    int opt_index = -1;
    while ((opt = getopt_long(argc, argv, optstr, longopts, &opt_index)) != -1) {
        switch (opt) {
        case 'h':
            cmd = 'h';
            break;
        case 'p':
        case 'd':
            cmd = opt;
            strncpy(image, optarg, FILENAME_MAX - 1);
            break;
        case 'o':
            strncpy(out, optarg, FILENAME_MAX - 1);
            break;
        case 'k':
            strncpy(kpimg, optarg, FILENAME_MAX - 1);
            break;
        case 's':
            strncpy(superkey, optarg, SUPER_KEY_LEN);
            break;
        default:
            break;
        }
    }
    int ret = 0;
    if (cmd == 'h') {
        print_usage();
    } else if (cmd == 'p') {
        ret = patch_image();
    } else if (cmd == 'd') {
        ret = dump_kallsym();
    } else {
        print_usage();
    }
    return ret;
}

```

`tools/order.c`:

```c
#include "order.h"

inline uint16_t u16swp(uint16_t val)
{
    return (val << 8) | (val >> 8);
}

inline int16_t i16swp(int16_t val)
{
    return (val << 8) | ((val >> 8) & 0xFF);
}

uint16_t u16le(uint16_t val)
{
    return is_be() ? u16swp(val) : val;
}

uint16_t u16be(uint16_t val)
{
    return is_be() ? val : u16swp(val);
}

int16_t i16le(int16_t val)
{
    return is_be() ? i16swp(val) : val;
}

int16_t i16be(int16_t val)
{
    return is_be() ? val : i16swp(val);
}

uint32_t u32swp(uint32_t val)
{
    val = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF);
    return (val << 16) | (val >> 16);
}

int32_t i32swp(int32_t val)
{
    val = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF);
    return (val << 16) | ((val >> 16) & 0xFFFF);
}

uint32_t u32le(uint32_t val)
{
    return is_be() ? u32swp(val) : val;
}

uint32_t u32be(uint32_t val)
{
    return is_be() ? val : u32swp(val);
}

int32_t i32le(int32_t val)
{
    return is_be() ? i32swp(val) : val;
}

int32_t i32be(int32_t val)
{
    return is_be() ? val : i32swp(val);
}

int64_t i64swp(int64_t val)
{
    val = ((val << 8) & 0xFF00FF00FF00FF00ULL) | ((val >> 8) & 0x00FF00FF00FF00FFULL);
    val = ((val << 16) & 0xFFFF0000FFFF0000ULL) | ((val >> 16) & 0x0000FFFF0000FFFFULL);
    return (val << 32) | ((val >> 32) & 0xFFFFFFFFULL);
}

uint64_t u64swp(uint64_t val)
{
    val = ((val << 8) & 0xFF00FF00FF00FF00ULL) | ((val >> 8) & 0x00FF00FF00FF00FFULL);
    val = ((val << 16) & 0xFFFF0000FFFF0000ULL) | ((val >> 16) & 0x0000FFFF0000FFFFULL);
    return (val << 32) | (val >> 32);
}

int64_t i64le(int64_t val)
{
    return is_be() ? i64swp(val) : val;
}

int64_t i64be(int64_t val)
{
    return is_be() ? val : i64swp(val);
}

uint64_t u64le(uint64_t val)
{
    return is_be() ? u64swp(val) : val;
}

uint64_t u64be(uint64_t val)
{
    return is_be() ? val : u64swp(val);
}

```

`tools/order.h`:

```h
#ifndef _ORDER_H_
#define _ORDER_H_

#include <stdint.h>

// todo
#define is_be() (*(unsigned char *)&(uint16_t){ 1 } ? 0 : 1)

int16_t i16swp(int16_t val);
int16_t i16le(int16_t val);
int16_t i16be(int16_t val);

uint16_t u16swp(uint16_t val);
uint16_t u16le(uint16_t val);
uint16_t u16be(uint16_t val);

int32_t i32swp(int32_t val);
int32_t i32le(int32_t val);
int32_t i32be(int32_t val);

uint32_t u32swp(uint32_t val);
uint32_t u32le(uint32_t val);
uint32_t u32be(uint32_t val);

int64_t i64swp(int64_t val);
int64_t i64le(int64_t val);
int64_t i64be(int64_t val);

uint64_t u64swp(uint64_t val);
uint64_t u64le(uint64_t val);
uint64_t u64be(uint64_t val);

#endif // _ORDER_H_
```

`tools/version`:

```
#define MAJOR 1
#define MINOR 0
#define PATCH 0
```

`user/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)
project("kpatch")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11")

set(SRCS
        libkp.c
        )

add_library(
        kp
        STATIC
        ${SRCS}
        )

add_executable(
        kpatch
        ${SRCS}
        main.c
        )
```

`user/Makefile`:

```

CFLAGS = -std=c11 -Wall -Wextra -Wno-unused -Wno-unused-parameter

objs := libkp.o 

all: kpatch libkp.a

kpatch: main.o ${objs}
	${CC} -o $@ $^

libkp.a: ${objs}
	${AR} rcs $@ $^

%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

.PHONY: clean
clean:
	rm -rf uapi/*
	rm -rf kpatch
	rm -rf libkp.a 
	find . -name "*.o" | xargs rm -f
```

`user/libkp.c`:

```c
#include "libkp.h"

#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <linux/capability.h>

#include "version"

long su_fork(const char *key)
{
    long ret = 0;
#if 0
    uid_t ruid, euid, suid;
    gid_t rgid, egid, sgid;
    getresuid(&ruid, &euid, &suid);
    getresgid(&rgid, &egid, &sgid);
    fprintf(stdout, "before resuid: %ud, %ud, %ud, resgid: %ud, %ud, %ud\n", ruid, euid, suid, rgid, egid, sgid);

    struct __user_cap_header_struct cap_header;
    struct __user_cap_data_struct cap_data;
    cap_header.pid = getpid();
    cap_header.version = _LINUX_CAPABILITY_VERSION_3;
    ret = syscall(SYS_capget, &cap_header, &cap_data);
    fprintf(stdout, "before capabilities: ret: %ld 0x%x, 0x%x, 0x%x\n", ret, cap_data.effective, cap_data.permitted,
            cap_data.inheritable);
#endif
    ret = sc_su(key);
#if 0
    getresuid(&ruid, &euid, &suid);
    getresgid(&rgid, &egid, &sgid);
    fprintf(stdout, "after resuid: %ud, %ud, %ud, resgid: %ud, %ud, %ud\n", ruid, euid, suid, rgid, egid, sgid);

    cap_header.pid = getpid();
    cap_header.version = _LINUX_CAPABILITY_VERSION_3;
    ret = syscall(SYS_capget, &cap_header, &cap_data);
    fprintf(stdout, "after capabilities: ret: %ld, 0x%x, %x, %x\n", ret, cap_data.effective, cap_data.permitted,
            cap_data.inheritable);
#endif
    /* Default exec shell. */
    if (!ret)
        execlp("/system/bin/sh", "sh", NULL);
    return ret;
}

```

`user/libkp.h`:

```h
#ifndef _KPU_LIBKP_H_
#define _KPU_LIBKP_H_

#include "supercall.h"
#include "version"

static inline uint32_t get_version()
{
    uint32_t version_code = (MAJOR << 16) + (MINOR << 8) + PATCH;
    return version_code;
}

long su_fork(const char *key);

#endif

```

`user/main.c`:

```c
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "libkp.h"

#define SUPER_KEY_LEN 0x20

void print_usage(char **argv)
{
    char *c = "\nkpatch: KernelPatch Userspace Executable.\n"
              "\n"
              "Common Usage:\n"
              "./kpatch -h, --help\n"
              "    Print this message.\n"
              "./kpatch -v, --version\n"
              "    Print kpatch version.\n"
              "\n"
              "SuperCall Usage:\n"
              "./kpatch <super_key> <command> [args...]\n"
              "command:\n"
              "  --hello\n"
              "     Print SuperCall hello message in the kernel. Return 0 if succeed, others if failed!\n"
              "  --kv\n"
              "     Get Kernel version.\n"
              "  --kpv\n"
              "     Get KernelPatch version.\n"
              "  --su\n"
              "     Fork a default root shell.\n"
              "  --load_kpm --arg1 kpm_patch\n"
              "     Load KernelPatch Module\n"
              "     (Unimplemented ...).\n"
              "  --unload_kpm --arg1 kpm_patch\n"
              "     Unload KernelPatch Module\n"
              "     (Unimplemented ...).\n"
              "  --grant_su --arg1 uid\n"
              "     Grant root privileges to the user corresponding to the given uid.\n"
              "     (Unimplemented ...).\n"
              "  --revoke_su --arg1 uid\n"
              "     Revoke root privileges to the user corresponding to the given uid.\n"
              "     (Unimplemented ...).\n"
              "  --thread_su --arg1 tid\n"
              "     Grant root privileges to the thread corresponding to the given tid.\n"
              "  --thread_unsu --arg1 tid\n"
              "     Revoke root privileges to the thread corresponding to the given tid.\n"
              "     (Unimplemented ...).\n"
              "\n";
    fprintf(stdout, "%s", c);
}

int main(int argc, char **argv)
{
    int cmd = -1;
    char *arg1 = 0, *arg2 = 0, *arg3 = 0;

    if (argc == 2) {
        if (!strcmp(argv[1], "-v") || !(strcmp(argv[1], "--version"))) {
            fprintf(stdout, "%x\n", get_version());
            return 0;
        }
    }

    if (argc < 3) {
        print_usage(argv);
        return 0;
    }

    char key[SUPER_KEY_LEN] = { '\0' };
    strncpy(key, argv[1], SUPER_KEY_LEN);

    if (!strnlen(key, SUPER_KEY_LEN)) {
        fprintf(stderr, "Super key must be specified\n");
        return -1;
    }

    struct option longopts[] = { { "arg1", required_argument, NULL, '1' },
                                 { "arg2", required_argument, NULL, '2' },
                                 { "arg3", required_argument, NULL, '3' },
                                 { "hello", no_argument, &cmd, SUPERCALL_HELLO },
                                 { "kv", no_argument, &cmd, SUPERCALL_GET_KERNEL_VERSION },
                                 { "kpv", no_argument, &cmd, SUPERCALL_GET_KP_VERSION },
                                 { "load_kpm", no_argument, NULL, SUPERCALL_LOAD_KPM },
                                 { "unload_kpm", no_argument, NULL, SUPERCALL_UNLOAD_KPM },
                                 { "su", no_argument, &cmd, SUPERCALL_SU },
                                 { "grant_su", no_argument, &cmd, SUPERCALL_GRANT_SU },
                                 { "revoke_su", no_argument, &cmd, SUPERCALL_REVOKE_SU },
                                 { "thread_su", no_argument, &cmd, SUPERCALL_THREAD_SU },
                                 { "thread_unsu", no_argument, &cmd, SUPERCALL_THREAD_UNSU },

                                 { 0, 0, 0, 0 } };
    char *optstr = "1:2:3:";
    int opt = -1;
    int opt_index = -1;
    int verbose = 0;
    while ((opt = getopt_long(argc, argv, optstr, longopts, &opt_index)) != -1) {
        switch (opt) {
        case '1':
            arg1 = optarg;
            break;
        case '2':
            arg2 = optarg;
            break;
        case '3':
            arg3 = optarg;
            break;
        default:
            continue;
        }
    }

    // fprintf(stdout, "command no: %x, arg1: %s, arg2: %s, arg3:%s\n", cmd, arg1, arg2, arg3);

    long ret = 0;
    if (cmd == SUPERCALL_HELLO) {
        ret = sc_hello(key);
        if (ret == SUPERCALL_HELLO_MAGIC)
            ret = 0;
    } else if (cmd == SUPERCALL_GET_KERNEL_VERSION) {
        long kv = sc_get_kernel_version(key);
        fprintf(stdout, "%lx\n", kv);
    } else if (cmd == SUPERCALL_GET_KP_VERSION) {
        long kpv = sc_get_kp_version(key);
        fprintf(stdout, "%lx\n", kpv);
    } else if (cmd == SUPERCALL_SU) {
        ret = su_fork(key);
    } else if (cmd == SUPERCALL_THREAD_SU) {
        if (!arg1) {
            fprintf(stderr, "Empty Tid!\n");
            return -1;
        }
        int pid = atoi(arg1);
        ret = sc_grant_su(key, pid);
    } else if (cmd == SUPERCALL_REVOKE_SU) {
        if (!arg1) {
            fprintf(stderr, "Empty Tid!\n");
            return -1;
        }
        int pid = atoi(arg1);
        ret = sc_revoke_su(key, pid);
    } else {
        fprintf(stderr, "Invalid SuperCall command!\n");
        return 0;
    }
    if (ret == SUPERCALL_RES_NOT_IMPL) {
        fprintf(stdout, "Unimplemented SuperCall\n");
    }
    return ret;
}

```

`user/supercall.h`:

```h
#ifndef _KPU_SUPERCALL_H_
#define _KPU_SUPERCALL_H_

#include "uapi/scdefs.h"

#include <unistd.h>
#include <sys/syscall.h>
#include <stdbool.h>

static inline long sc_hello(const char *key)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_HELLO);
    return ret;
}

static inline bool installed(const char *key)
{
    return sc_hello(key) == SUPERCALL_HELLO_MAGIC;
}

static inline long sc_get_kernel_version(const char *key)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_GET_KERNEL_VERSION);
    return ret;
}

static inline long sc_get_kp_version(const char *key)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_GET_KP_VERSION);
    return ret;
}

static inline long sc_load_kpm(const char *key, const char *path)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_LOAD_KPM, path);
    return ret;
}

static inline long sc_unload_kpm(const char *key, const char *path)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_UNLOAD_KPM, path);
    return ret;
}

static inline long sc_su(const char *key)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_SU);
    return ret;
}

static inline long sc_grant_su(const char *key, uid_t uid)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_GRANT_SU, uid);
    return ret;
}

static inline long sc_revoke_su(const char *key, uid_t uid)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_REVOKE_SU, uid);
    return ret;
}

static inline long sc_thread_su(const char *key, pid_t pid)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_THREAD_SU, pid);
    return ret;
}

static inline long sc_thread_unsu(const char *key, pid_t pid)
{
    long ret = syscall(__NR_supercall, key, hash_key(key), SUPERCALL_THREAD_UNSU, pid);
    return ret;
}

#endif
```

`user/version`:

```
#define MAJOR 0
#define MINOR 1
#define PATCH 0
```