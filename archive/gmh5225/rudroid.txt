Project Path: arc_gmh5225_rudroid_96465zn4

Source Tree:

```txt
arc_gmh5225_rudroid_96465zn4
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Readme.md
â”œâ”€â”€ code
â”‚   â”œâ”€â”€ Cargo.lock
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ Makefile
â”‚   â””â”€â”€ src
â”‚       â”œâ”€â”€ core
â”‚       â”‚   â”œâ”€â”€ android
â”‚       â”‚   â”‚   â”œâ”€â”€ fs
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ fserrors.rs
â”‚       â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â””â”€â”€ syscalls
â”‚       â”‚   â”‚       â”œâ”€â”€ fnctl.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ futex.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ ioctl.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ mman.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ prctl.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ random.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ sched.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ signal.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ stat.rs
â”‚       â”‚   â”‚       â”œâ”€â”€ syscalls.rs
â”‚       â”‚   â”‚       â””â”€â”€ unistd.rs
â”‚       â”‚   â”œâ”€â”€ hooks.rs
â”‚       â”‚   â”œâ”€â”€ loaders
â”‚       â”‚   â”‚   â”œâ”€â”€ elfLoader.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ elfRunner.rs
â”‚       â”‚   â”‚   â””â”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ mmu.rs
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ rudroid.rs
â”‚       â”‚   â””â”€â”€ unicorn
â”‚       â”‚       â”œâ”€â”€ arch
â”‚       â”‚       â”‚   â”œâ”€â”€ arm64.rs
â”‚       â”‚       â”‚   â””â”€â”€ mod.rs
â”‚       â”‚       â”œâ”€â”€ ffi.rs
â”‚       â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚       â””â”€â”€ unicorn_const.rs
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ utilities.rs
â”œâ”€â”€ imgs
â”‚   â”œâ”€â”€ aarch64-system-call.jpeg
â”‚   â”œâ”€â”€ cpu_exec.png
â”‚   â”œâ”€â”€ emulator-cpu-loop.png
â”‚   â”œâ”€â”€ final.png
â”‚   â”œâ”€â”€ kernel-architecture.jpg
â”‚   â”œâ”€â”€ kernel-architecture.png
â”‚   â”œâ”€â”€ linux-kernel-architecture.png
â”‚   â”œâ”€â”€ make.png
â”‚   â”œâ”€â”€ make2.png
â”‚   â”œâ”€â”€ make3.png
â”‚   â”œâ”€â”€ qemu_linux-user_main.png
â”‚   â”œâ”€â”€ rudroid-architecture.png
â”‚   â”œâ”€â”€ strich.png
â”‚   â””â”€â”€ tree.png
â”œâ”€â”€ resources
â”‚   â””â”€â”€ Hello
â”‚       â””â”€â”€ jni
â”‚           â”œâ”€â”€ Android.mk
â”‚           â”œâ”€â”€ Application.mk
â”‚           â”œâ”€â”€ Makefile
â”‚           â””â”€â”€ hello.cpp
â””â”€â”€ run.sh

```

`Dockerfile`:

```
FROM rust:latest

RUN apt update -y
RUN apt install -y nano cmake 

WORKDIR /setup
RUN git clone https://github.com/unicorn-engine/unicorn/
WORKDIR /setup/unicorn/
RUN ./make.sh
RUN ./make.sh install

WORKDIR /setup/
RUN git clone https://github.com/keystone-engine/keystone/
RUN mkdir build
WORKDIR /setup/keystone/build
RUN ../make-share.sh
RUN make install

RUN cp /usr/local/lib/libkeystone.so* /usr/lib/

RUN apt-get install -y clang llvm binutils-dev libunwind-dev
WORKDIR /home/

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Chaithu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Readme.md`:

```md
# Rudroid - Writing the World's worst Android Emulator in Rust ðŸ¦€

## Introduction
Rudroid - this might arguably be one of the worst Android emulators possible. In this blog, we'll write an emulator that can run a 'Hello World' Android ELF binary. While doing this, we will learn how to go about writing our own emulators.

Writing an emulator is an awesome way to study and probably master the low-level details of the system we are trying to emulate. I assume you have some working knowledge of Rust, a Linux machine with Rust installed or a Docker engine, and a lot of patience to go through the documentation of system calls, file formats, and more.

&nbsp;

Topics we need to understand while writing Rudroid:
- Basic Android Operating System Architecture
- What are system calls
- How system calls are handled in AArch64
- How memory mapping works
- How the operating system loads an ELF into memory and runs it
- How we can emulate the behavior of Operating system to load an ELF into memory and run

Let's start by reading the definition of Android:

> Android is an open-source, Linux-based software stack created for a wide array of devices and form factors. The following diagram shows the major components of the Android platform.
&nbsp;

## Kernel Architecture
The basic architecture of Linux kernel:

<img src="./imgs/linux-kernel-architecture.png" alt="Kernel Architecture">

Core functionalities of a kernel are:
- Process management
- Device management
- Memory management
- Interrupt handling
- Block I/O communication
- File System Management

For writing an emulator that just runs an Android ELF binary, the most interesting kernel components are Memory Management, File System Management, Process Management and Interrupt handling, and System Call Interface via which ELF communicates with Kernel.


<img src="./imgs/kernel-architecture.png" alt="Kernel Architecture">
&nbsp;

> <b>Signals</b>: The kernel uses signals to call into a process. For example, signals are
used to notify a process of certain faults, such as division by zero.

> <b>Processes and Scheduler</b>: Creates, schedules, and manages processes.

> <b>Virtual Memory</b>: Allocates and manages virtual memory for processes.

> <b>File Systems</b>: Implements the file and filesystem-related interfaces for user-space to communicate with the underlying disks.

> <b>Traps and faults</b>: Handles traps and faults generated by the processor, such as a memory fault.

> <b>Physical memory</b>: Manages the pool of page frames in real memory and allocates pages for virtual memory. 

> <b>Interrupts</b>: Handles all the interrupts from peripheral devices.

> <b>System calls</b>: The system call is the means by which a process requests a specific kernel service for example read from a file, write to file, execute a program. There are several hundred system calls, which can be roughly grouped into six categories: <br/>
    * file system <br/>
    * process<br/>
    * scheduling<br/>
    * interprocess communication (ipc)<br/>
    * socket (networking)<br/>
    * miscellaneous.


## How do Emulators do what they do?
An emulator usually has an MMU to manage guest's memory requests, an instruction interpreter (decode -> translate -> execute), signal handlers, interrupt handlers.

These are the steps an emulator usually does:
* load the target binary to memory
* figure out the ISA of target binary
* if emulator supports the ISA, initialize CPU
* initialize signal handlers
* initialize interrupt handlers
* initialize syscall handlers
* start CPU loop

What happens inside a  CPU Loop:
* fetch opcode to execute at Program Counter
* increment Program Counter
* decode opcode
* translate opcode from emulated ISA to host ISA
* execute the translated opcode
* handle any raised signals/interrupts
* continue the loop

<img src="./imgs/emulator-cpu-loop.png" alt="emulate cpu loop">


## Rudroid's Architecture

So, our Rudroid is just going to be a binary that implements an ELF loader, memory management, system call interface, filesystem. The final Rudroid's binary should take the ELF that prints 'Hello World' to stdout as command-line argument and execute it on the host. The command should look something like this:

```bash
# ./Rudroid hello_world.elf
hello world
```

We are going to run our Rudroid on a Linux machine. This is how our Rudroid's architecture is going to look like:

<img src="./imgs/rudroid-architecture.png" alt="Rudroid Architecture">

## ELF loading process

We'll try not to dwell too much into the details of the ELF file format. Take a look at this comprehensive ELF standard [here](https://refspecs.linuxfoundation.org/elf/elf.pdf).

Executable (ELFs) and shared object files (libraries) statically represent programs. When you decide to run a binary, the operating system starts by setting up a new process for the program to run. 

ELFs are composed of three major components: 
- an executable header (`Ehdr`)
- Sections (section header are represented as `Shdr`)
- Segments (also known as Program Headers are represented as `Phdr`)

`Ehdr` as defined in `/usr/include/elf.h`

```c
typedef struct {
    unsigned char e_ident[16]; /* Magic number and other info */
    uint16_t e_type; /* Object file type */
    uint16_t e_machine; /* Architecture */
    uint32_t e_version; /* Object file version */
    uint64_t e_entry; /* Entry point virtual address */
    uint64_t e_phoff; /* Program header table file offset */
    uint64_t e_shoff; /* Section header table file offset */
    uint32_t e_flags; /* Processor-specific flags */
    uint16_t e_ehsize; /* ELF header size in bytes */
    uint16_t e_phentsize; /* Program header table entry size */
    uint16_t e_phnum; /* Program header table entry count */
    uint16_t e_shentsize; /* Section header table entry size */
    uint16_t e_shnum; /* Section header table entry count */
    uint16_t e_shstrndx; /* Section header string table index*/
} Elf64_Ehdr;
```
&nbsp;

`Phdr` as defined in `/usr/include/elf.h`
```c
typedef struct elf64_phdr {
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;       /* Segment file offset */
  Elf64_Addr p_vaddr;       /* Segment virtual address */
  Elf64_Addr p_paddr;       /* Segment physical address */
  Elf64_Xword p_filesz;     /* Segment size in file */
  Elf64_Xword p_memsz;      /* Segment size in memory */
  Elf64_Xword p_align;      /* Segment alignment, file & memory */
} Elf64_Phdr;
```
&nbsp;


`Shdr` as defined in `/usr/include/elf.h`
```c
typedef struct elf64_shdr {
  Elf64_Word sh_name;       /* Section name, index in string tbl */
  Elf64_Word sh_type;       /* Type of section */
  Elf64_Xword sh_flags;     /* Miscellaneous section attributes */
  Elf64_Addr sh_addr;       /* Section virtual addr at execution */
  Elf64_Off sh_offset;      /* Section file offset */
  Elf64_Xword sh_size;      /* Size of section in bytes */
  Elf64_Word sh_link;       /* Index of another section */
  Elf64_Word sh_info;       /* Additional section information */
  Elf64_Xword sh_addralign; /* Section alignment */
  Elf64_Xword sh_entsize;   /* Entry size if section holds table */
} Elf64_Shdr;
```

The kernel only really cares about Ehdr and Phdrs and only three types of program header entries:
- PT_LOAD           : Loadable Segment
- PT_INTERP         : Segment holding .interp section
- PT_GNU_STACK      : flag to set program's stack to executable

The ELF loader in the kernel starts loading ELF by first examining the ELF header to check the validity of ELF. After this, the loader now loops over the program header entries, looking for PT_LOAD and PT_INTERP. For every PT_LOAD entry, the loader maps memory at `load_address + phdr_header.p_vaddr` of size `phdr_header.mem_size` and copies the contents of the segment into allocated memory. If PT_INTERP is found, the loader again parses this as an ELF file and maps it into memory, and keeps track of the entrypoints of the main ELF file and interpreter's ELF file.

Once this is done, the loader starts setting up and populating the stack with `auxiliary vector` (ELF tables), environment variables, and command-line arguments passed to the ELF. An ELF auxiliary vector is an (id, value) pair that describes useful information about the program being run and the environment it is running in.

For this, we need an ELF parser in rust. We can either write our own ELF parser or use an already existing [xmas-elf crate](https://github.com/nrc/xmas-elf).

Before we could start writing an ELF loader, we also need a memory manager as we have to map the ELF into memory, manage stack, etc. Let's look at how a memory manager works.

## Memory Management (MMU)

> Linux memory management subsystem is responsible, as the name implies, for managing the memory in the system. This includes implementation of virtual memory and demand paging, memory allocation both for kernel internal structures and userspace programs, mapping of files into processes address space, and many other cool things.
&nbsp;

It provides functionality to `map` and `unmap` memory allocations. We have to implement these functionalities:
- map memory at a given location or of a given size
- unmap memory at a given location or of a given size
- read from memory
- write to memory
- manage permissions of the memory
&nbsp;

Mapping ranges from an address to address + size_of_the_mapping. We can look at `mmap` reference from the manual [here](https://man7.org/linux/man-pages/man2/mmap.2.html).
&nbsp;
```c
void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
````

```
 mmap() creates a new mapping in the virtual address space of the calling process.  The starting address for the new mapping is specified in addr.  The length argument specifies the length of the mapping (which must be greater than 0).
```

Memory protections:

```c
PROT_EXEC
    Pages may be executed.

PROT_READ
    Pages may be read.

PROT_WRITE
    Pages may be written.

PROT_NONE
    Pages may not be accessed.
```

Unicorn Engine offers this functionality:

```rust
    /// Map a memory region in the emulator at the specified address.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_map(&mut self, 
            address: u64, 
            size: libc::size_t, 
            perms: Protection
    ) -> Result<(), uc_error>;


    /// Unmap a memory region.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_unmap(&mut self, 
            address: u64, 
            size: libc::size_t
    ) -> Result<(), uc_error>;


    /// Set the memory permissions for an existing memory region.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_protect(&mut self, 
            address: u64, 
            size: libc::size_t, 
            perms: Protection
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_protect(self.uc, address, size, perms.bits()) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }
```

&nbsp;

We can define protections and mapping as structs in rust:

```rust
bitflags! {
#[repr(C)]
pub struct Protection : u32 {
        const NONE = 0;
        const READ = 1;
        const WRITE = 2;
        const EXEC = 4;
        const ALL = 7;
    }
}

pub struct MapInfo {
    pub memory_start    : u64,
    pub memory_end      : u64,
    pub memory_perms    : Protection,
    pub description     : String,
}
```

Using these `mem_map`, `mem_unmap` functions from Unicorn, We can implement our MMU as a hashmap of starting address and MapInfo struct. 

We'll also look at how system calls work and then start writing our Emulator.

## System Calls

> A system call is a routine that allows a user application to request actions that require special privileges or functionalities. Adding system calls is one of several ways to extend the functions provided by the kernel.
&nbsp;

In AArch64, there are special instructions for making such system calls. These instructions cause an exception, which allows controlled entry into a more privileged Exception level.

- <b>SVC</b> - Supervisor call:
Causes an exception targeting EL1.
Used by an application to call the OS.
- <b>HVC</b> - Hypervisor call: 
Causes an exception targeting EL2.
Used by an OS to call the hypervisor, not available at EL0.
- <b>SMC</b> - Secure monitor call:
Causes an exception targeting EL3.
Used by an OS or hypervisor to call the EL3 firmware, not available at EL0.

<img src='./imgs/aarch64-system-call.jpeg' alt='AArch64 system call'>
&nbsp;

InAArch64, the system call number is passed in `X8` register and the return value in `X0` register. We will use Unicorn's hooks to hook onto these SVC calls and execute the corresponding system call and return the results.

## AArch64 Instruction Emulation

Since writing emulating all the AArch64 instructions is a tedious job, we will make use of Unicorn Engine for emulating the instructions. We will still see how it works.

## impl rudroid 

Finally, we'll start writing the code for our Rudroid. Let's see how easy or complex it will be.

I'm going to use a Linux Docker container on my Apple M1 as the host for running Rudroid. 

Rudroid's Dockerfile:

#### **`Dockerfile`**
```dockerfile
FROM rust:latest

RUN apt update -y
RUN apt install -y nano cmake 

WORKDIR /setup
RUN git clone https://github.com/unicorn-engine/unicorn/
WORKDIR /setup/unicorn/
RUN ./make.sh
RUN ./make.sh install

WORKDIR /setup/
RUN git clone https://github.com/keystone-engine/keystone/
RUN mkdir build
WORKDIR /setup/keystone/build
RUN ../make-share.sh
RUN make install

RUN cp /usr/local/lib/libkeystone.so* /usr/lib/

RUN apt-get install -y clang llvm binutils-dev libunwind-dev
WORKDIR /home/
```

#### **`run.sh`**
```bash
#!/bin/bash
image=Rudroid
docker build -t $image .
docker run --rm -v `pwd`:/home -v `pwd`/resources/:/resources/ -it $image bash
```

```bash
$ chmod +x run.sh
$ run.sh
root@9346e6664ae9:/home/code#
```

Here we are installing the required rust, unicorn-engine, capstone-engine, and keystone-engine. 

We will extend `Unicorn` impl from [Unicorn Rust crate](https://github.com/unicorn-engine/unicorn/blob/next/bindings/rust/) and add system call handlers, file system management, etc. I took only the required files and discarded the remaining. 

```c
âžœ  src git:(main) âœ— tree core/unicorn/ 
| |____
| | |____unicorn_const.rs
| | |____ffi.rs
| | |____mod.rs
| | |____arch
| | | |____arm64.rs
| | | |____mod.rs
```

#### Directory structure
Let's set up the below directory structure:

<img src="./imgs/tree.png" alt="Tree">

&nbsp;

We are going to need `libc` crate to interact/forward our system calls to the host and `xmas-elf` crate for parsing ELF file. Add `libc = "0.2.101"` and `xmas-elf = "0.8.0"`to dependencies in Cargo.toml. Also added some helpers functions in `utilities.rs` to print in color.ðŸŽ¨

#### **`Cargo.toml`**
```yaml
[package]
name = "Rudroid"
version = "0.1.0"
edition = "2018"

[dependencies]
libc = "0.2.101"
bitflags = ">=1.1.0"
xmas-elf = "0.8.0"
byteorder = "1.4.3"
keystone = "0.9.0"
capstone="0.10.0"
nix = "0.22.1"
```

So I deleted the Unicorn `new` implementation and `struct` definition and added a new struct definition inside `core/rudroid.rs`. Our new implementation declares a new struct called Emulator that keeps track of details of the Elf file, filesystem, and Unicorn hooks.

### **`core/rudroid.rs`**
```rust

// #[derive(Debug)]
pub struct Emulator<D>  {
    pub debug               : bool,

    pub rootfs              : String,
    pub elf_path            : String,

    pub machine             : header::Machine,
    pub endian              : header::Data,
    pub arch                : Arch,

    pub uc                  : ffi::uc_handle,
    pub uc_type             : D,

    pub filesystem          : fs::FsScheme,

    // mmu stuff
    pub load_address        : u64,
    pub mmap_address        : u64,
    pub new_stack           : u64,
    pub interp_address      : u64,
    pub entry_point         : u64,
    pub elf_entry           : u64,
    pub brk_address         : u64,

    //elf arguments
    pub args                : Vec<String>,
    pub env                 : Vec<String>,

    pub map_infos           : HashMap<u64, mmu::MapInfo>,

    //hook
    pub code_hooks          : HashMap<*mut libc::c_void, Box<ffi::CodeHook<D>>>,
    pub mem_hooks           : HashMap<*mut libc::c_void, Box<ffi::MemHook<D>>>,
    pub intr_hooks          : HashMap<*mut libc::c_void, Box<ffi::InterruptHook<D>>>,
    pub insn_in_hooks       : HashMap<*mut libc::c_void, Box<ffi::InstructionInHook<D>>>,
    pub insn_out_hooks      : HashMap<*mut libc::c_void, Box<ffi::InstructionOutHook<D>>>,
    pub insn_sys_hooks      : HashMap<*mut libc::c_void, Box<ffi::InstructionSysHook<D>>>,

    // syscalls stuff
    pub sigmap              : HashMap<u64, Vec<u8>>,

    _pin                    : std::marker::PhantomPinned,
}
```

Now we have to implement `Emulator`.

```rust
impl<D> Emulator<D>
{
    pub fn new(elf_path: &str, rootfs: &str, elf: &mut ElfFile, endian: header::Data, args: Vec<String>, env: Vec<String>, data: D, debug: bool) -> Result<Emulator<D>, uc_error> {

        let mut machine = elf.header.pt2.machine().as_machine();

        let (arch, mode) = match machine {
            header::Machine::AArch64 => {
                (Arch::ARM64, Mode::LITTLE_ENDIAN)
            },
            _ => {
                panic!("Not implemented yet!")
            }
        };

        let mut handle = std::ptr::null_mut();

        //uc_open: Create new instance of unicorn engine.
        let err = unsafe { ffi::uc_open(arch, mode, &mut handle) };

        //create a new Emulator and return.
        let mut emu = Emulator {
            debug           : debug,
            rootfs          : String::from(rootfs),

            elf_path        : String::from(elf_path),
            args            : args,
            env             : env,
            
            uc              : handle,
            uc_type         : data,
            
            arch            : arch,
            machine         : machine,
            endian          : endian,

            map_infos       : HashMap::new(),
            entry_point     : 0,
            elf_entry       : 0,
            brk_address     : 0,
            mmap_address    : 0,
            interp_address  : 0,
            new_stack       : 0,
            load_address    : 0,

            //hooks
            code_hooks      : HashMap::new(),
            mem_hooks       : HashMap::new(),
            intr_hooks      : HashMap::new(),
            insn_in_hooks   : HashMap::new(),
            insn_out_hooks  : HashMap::new(),
            insn_sys_hooks  : HashMap::new(),

            _pin            : std::marker::PhantomPinned,
            
            //create a File System object
            filesystem      : fs::FsScheme::new(String::from(rootfs)),
            sigmap          : HashMap::new(),
        };
        
        //parse and load the ELF into memory
        emu.load(elf);

        // display the memory mapping
        emu.display_mapped();

        if err == uc_error::OK {
            Ok(emu)
        } else {
            Err(err)
        }
    }
}
```

Replaced all the implementations of `impl UnicornHandler` with `impl<D> Emulator<D>`. This way, we already have all the capabilities of `Unicorn` like memory management, hooks, instruction interpreter, CPU loop, etc. I think this is called Lazy programming? ðŸ™Š

As explained in the ELF Loader section above, we parse the ELF using `xmas-elf` crate, go through the program headers, and map the respective segments into the memory. We also set up Stack for the program.

### **`core/loaders/elfLoader.rs`**
```rust
impl<D> Emulator<D>
{
    pub fn load(& mut self, elf: &mut ElfFile)
    {
        self.enable_vfp();
        
        let profile = match self.machine {
            header::Machine::AArch64 => {
                (linux::OS64::stack_address, linux::OS64::stack_size)
            },
            _ => {
                    panic!("[load_with_ld] Not implemented yet!")
            }
        };

        let mut stack_address = profile.0 as u64;
        let stack_size      = profile.1 as usize;
        
        //initialise stack
        self.mmu_map(stack_address, stack_size, Protection::READ|Protection::WRITE, "[stack]", self.null_mut());

        // load ELF and linker into memory
        self.load_with_ld(stack_address.checked_add(stack_size as u64).unwrap() , 0, self.machine, elf);

        stack_address = self.new_stack;
        self.reg_write(RegisterARM64::SP as i32, stack_address).unwrap();
    }

    fn load_with_ld(&mut self, stack_address: u64, load_address: u64, archbit: header::Machine, elf: &mut ElfFile) {
        let mut load_address = match load_address {
            0 => {
                match  archbit {
                    header::Machine::AArch64 => {
                        self.mmap_address = linux::OS64::mmap_address as u64;
                        linux::OS64::load_address as u64
                    },
                    _ => {
                        panic!("Shouldn't be here");
                    }
                }
            },
            _ => {
                panic!("Shouldn't be here");
            }
        };
        
        let mut mem_start   : u64 = 0xffff_ffff;
        let mut mem_end     : u64 = 0xffff_ffff;
        let mut mem_s       : u64 = 0;
        let mut mem_e       : u64 = 0;

        let mut interp_path : String = String::new();

        match elf.header.pt2.type_().as_type() {
            header::Type::Executable => {
                load_address = 0;
            },
            header::Type::SharedObject => {
                
            }
            _ => {
                panic!("Some error in head e_type: {:?}", header::Type::SharedObject);
            }
        }

        for header in elf.program_iter() {
            match header.get_type().unwrap() {

                program::Type::Interp => {
                    let offset      = header.offset() as usize;
                    let end_offset  = (header.offset()+header.mem_size()) as usize;
                    let data = elf.input.get(offset..end_offset).unwrap();
                    interp_path = self.null_str(std::str::from_utf8(data).unwrap());
                },

                program::Type::Load => {
                    if mem_start > header.virtual_addr() || mem_start == 0xffff_ffff {
                        mem_start = header.virtual_addr();
                    };

                    if mem_end < header.virtual_addr()+header.mem_size() || mem_end == 0xffff_ffff {
                        mem_end = header.virtual_addr()+header.mem_size();
                    }
                },
                _ => {

                }
            }
        }

        mem_start = self.uc_align_down(mem_start);
        mem_end   = self.uc_align_up(mem_end);

        for header in elf.program_iter() {
            match header.get_type().unwrap() {
                program::Type::Load => {
                    mem_s = self.uc_align_down(load_address + header.virtual_addr());
                    mem_e = self.uc_align_up(load_address + header.virtual_addr() + header.file_size());
                    let perms =  utilities::to_uc_permissions(header.flags());

                    let desc = self.elf_path.clone();
                    self.mmu_map(mem_s, (mem_e-mem_s) as usize, perms, &desc, self.null_mut());
                    
                    let data = elf.input.get(header.offset() as usize..
                                                                (header.offset()+header.file_size()) as usize).unwrap();

                    self.write(load_address+header.virtual_addr(), data);
                },
                _ => {

                }
            }
        }
        
        let loaded_mem_end = load_address + mem_end;

        if loaded_mem_end > mem_e {
            let desc = self.elf_path.clone();
            self.mmu_map( mem_e, (loaded_mem_end-mem_e) as usize, Protection::ALL, &desc, self.null_mut());
        }

        self.elf_entry = elf.header.pt2.entry_point() + load_address;
        self.debug_print(format!("elf_entry {:x}", self.elf_entry));

        self.brk_address = mem_end + load_address + 0x2000; //not sure why?? seems to be used in ql_syscall_brk

        // load interpreter if there is an interpreter
        if !interp_path.is_empty() {
            self.debug_print(format!("Trying to load interpreter: {}{}", self.rootfs, interp_path));

            let mut interp_full_path = String::new();

            interp_full_path.push_str(&self.rootfs);
            interp_full_path.push_str(&interp_path);

            let interp_data = std::fs::read(&interp_full_path).unwrap();
            let interp_elf  = ElfFile::new(interp_data.get(0..).unwrap()).unwrap();

            let mut interp_mem_size: u64 = 0;
            let mut interp_address : u64 = 0;

            for i_header in interp_elf.program_iter() {
                match i_header.get_type().unwrap() {
                    program::Type::Load => {
                        if interp_mem_size < i_header.virtual_addr() + i_header.mem_size() || interp_mem_size == 0 {
                            interp_mem_size = i_header.virtual_addr() + i_header.mem_size();
                        }
                    },
                    _ => {

                    }
                };
            }

            interp_mem_size = self.uc_align_up(interp_mem_size);

            match archbit {
                header::Machine::AArch64 => {
                    interp_address = linux::OS64::interp_address as u64;
                }
                _ => {
                    panic!("what?");
                }
            };

            //map interpreter into memory
            self.mmu_map(interp_address, interp_mem_size as usize , Protection::ALL, &interp_path, self.null_mut());

            for i_header in interp_elf.program_iter() { 
                match i_header.get_type().unwrap() {
                    program::Type::Load => {
                        let data = interp_elf.input.get(i_header.offset()  as usize..
                                                                            (i_header.offset()+i_header.file_size()) as usize
                                                                                    ).unwrap();
                        self.write( interp_address+i_header.physical_addr(), data);
                    },
                    _ => {

                    }
                };
            }

            self.interp_address = interp_address;
            self.entry_point    = interp_elf.header.pt2.entry_point() + self.interp_address;
        }

        // setup elf table
        let mut elf_table: Vec<u8> = Vec::new();

        let mut new_stack = stack_address;

        // copy arg0 on to stack. elf_path
        new_stack = self.copy_str(new_stack, &mut self.elf_path.clone());

        elf_table.extend_from_slice(&self.pack(self.args.len() as u64 + 1)); // + 1 is for arg0 = elf path.
        elf_table.extend_from_slice(&self.pack(new_stack));
        
        let mut argc = self.args.len();

        loop {
            if argc <=0 {
                break;
            }
            argc -= 1;

            let mut arg = self.args[argc].clone();
            new_stack = self.copy_str(new_stack, &mut arg);
            elf_table.extend_from_slice(&self.pack(new_stack));
        }

        elf_table.extend_from_slice(&self.pack(0));
        
        let mut envc = self.env.len();

        loop {
            if envc <=0 {
                break;
            }
            envc -= 1;
            let mut env = self.env[envc].clone();
            new_stack = self.copy_str(new_stack, &mut env);
            elf_table.extend_from_slice(&self.pack(new_stack));
        }

        elf_table.extend_from_slice(&self.pack(0));

        new_stack = self.alignment(new_stack);

        //our super secure random string
        let mut randstr   = "a".repeat(0x10);
        let mut cpustr    = String::from("aarch64");

        let mut addr1 = self.copy_str(new_stack, &mut randstr);
        new_stack = addr1;

        let mut addr2 = self.copy_str(new_stack, &mut cpustr);
        new_stack = addr2;

        new_stack = self.alignment(new_stack);

        // Set AUX
        let head = elf.header;
        
        let elf_phdr    = load_address + head.pt2.ph_offset();
        let elf_phent   = head.pt2.ph_entry_size();
        let elf_phnum   = head.pt2.ph_count();
        let elf_pagesz  = 0x1000;
        let elf_guid    = linux::uid;
        let elf_flags   = 0;
        let elf_entry   = load_address + head.pt2.entry_point();
        let randstraddr = addr1; 
        let cpustraddr  = addr2;

        let elf_hwcap: u64 = match head.pt2.machine().as_machine() {
            header::Machine::AArch64 => {
                0x078bfbfd
            },
            _ => {
                panic!("");
            }
        };

        //setup auxiliary vectors
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHDR  as u64, elf_phdr + mem_start));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHENT as u64, elf_phent as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHNUM as u64, elf_phnum as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PAGESZ as u64, elf_pagesz as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_BASE as u64, self.interp_address));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_FLAGS as u64, elf_flags));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_ENTRY as u64, elf_entry));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_UID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_EUID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_GID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_EGID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_HWCAP as u64, elf_hwcap as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_CLKTCK as u64, 100));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_RANDOM as u64, randstraddr));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PLATFORM as u64, cpustraddr));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_SECURE as u64, 0));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_NULL as u64, 0));


        let len = 0x10 - ((new_stack - elf_table.len() as u64) & 0xf) as usize;
        let padding = std::iter::repeat('0').take(len).collect::<String>();

        elf_table.extend_from_slice(padding.as_bytes());
        
        let addr = new_stack - elf_table.len() as u64;
        self.write( addr, &elf_table);

        new_stack = new_stack - elf_table.len() as u64;

        self.new_stack = new_stack;
        self.load_address = load_address;
    }

    fn new_aux_ent(&self, key: u64, val: u64) -> Vec<u8>
    {
        //pack the aux key-val pair
        let mut aux: Vec<u8> = Vec::new();
        aux.extend_from_slice(&self.pack(key));
        aux.extend_from_slice(&self.pack(val));
        aux
    }

    // Run linker
    pub fn run_linker(&mut self)
    {
        utilities::context_title(Some("Emulating linker64"));
        let res = self.emu_start(self.entry_point, self.elf_entry, 0, 0);
        self.handle_emu_exception(res);
        utilities::context_title(Some("Emulating linker64 done"));
    }
}
```

We add three hooks in `core/hook.rs`

```rust
pub fn add_hooks(emu: &mut rudroid::Emulator<i64>) {
    //handle SVC
    emu.add_intr_hook(android::syscalls::hook_syscall).unwrap();    

    //handle MEM_FETCH_UNMAPPED
    emu.add_mem_hook(unicorn_const::HookType::MEM_FETCH_UNMAPPED, 1, 0, callback_mem_error).unwrap();

    //handle MEM_READ_UNMAPPED
    emu.add_mem_hook(unicorn_const::HookType::MEM_READ_UNMAPPED, 1, 0, callback_mem_error).unwrap();
```

And in `hook_syscall` function, we read the `x8` register from the execution context, match it with syscalls of Android, and try to emulate the syscall. Instead of implementing every syscall in our code, we can just forward some of them to the host system, get the return values and forward them to the emulated binary. 

### **`core/android/syscalls/mod.rs`**
```rust
mod syscalls;
mod unistd;

use crate::{core::{rudroid::Emulator, unicorn::arch::arm64::RegisterARM64}, utilities};

pub fn get_syscall(uc: &mut Emulator<i64>) -> syscalls::Syscalls {
    // syscall_num = UC_ARM64_REG_X8
    let syscall = uc.reg_read(RegisterARM64::X8 as i32).unwrap();
    unsafe { ::std::mem::transmute(syscall) }
}

pub fn hook_syscall(uc: &mut Emulator<i64>, intno: u32) {
    let pc = uc.reg_read(RegisterARM64::PC as i32).unwrap();
    let syscall = get_syscall(uc);
    uc.syscall(syscall);
}

impl<D> Emulator<D> {
    pub fn syscall(&mut self, syscall: syscalls::Syscalls) {
        if self.debug {
            utilities::draw_line();
            self.debug_print(format!("got syscall: {:?}", syscall));
        }
        
        match syscall {

            syscalls::Syscalls::__NR_getpid =>
            {
                self.sys_getpid();
            }
            
            _ => {
                panic!("Syscall {:?} not implemented yet!", syscall);
            }
        }; 
    }

    pub fn empty_syscall_return(&mut self) {
        self.reg_write(RegisterARM64::X0 as i32, 0).unwrap();
    }

    pub fn get_arg(&mut self, num: i32) -> u64 {
        // 'x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7'
        match num {
            0 => {
                self.reg_read(RegisterARM64::X0 as i32).unwrap()
            },
            1 => {
                self.reg_read(RegisterARM64::X1 as i32).unwrap()
            },
            2 => {
                self.reg_read(RegisterARM64::X2 as i32).unwrap()
            },
            3 => {
                self.reg_read(RegisterARM64::X3 as i32).unwrap()
            },
            4 => {
                self.reg_read(RegisterARM64::X4 as i32).unwrap()
            },
            5 => {
                self.reg_read(RegisterARM64::X5 as i32).unwrap()
            },
            6 => {
                self.reg_read(RegisterARM64::X6 as i32).unwrap()
            },
            7 => {
                self.reg_read(RegisterARM64::X7 as i32).unwrap()
            },
            _ => {
                panic!("i do not support any more arguments :/");
            }
        }
    }

    pub fn set_return_val(&mut self, value: u64) {
        self.reg_write(RegisterARM64::X0 as i32, value).unwrap();
    }
}
```
And in `main.rs` file, we parse the command line arguments to Rudroid, take target 'Hello World' ELF and `rootfs` (/system/ directory copied from an android device) folder as 2 arguments, create an Emulator, load the ELF into memory and start the CPU loop.

### **`main.rs`**
```rust
extern crate byteorder;
extern crate capstone;
extern crate keystone;
extern crate nix;
extern crate xmas_elf;

mod utilities;
mod core;

use std::env;
use xmas_elf::ElfFile;

use crate::utilities::context_title;

fn parse_args() -> env::Args {
    //! Parse Command line arguments
    let mut args = env::args();

    if args.len() != 3 {
        panic!("Please provide an ELF library and rootfs folder");
    }
    args
}

fn main()
{
    utilities::context_title(Some("Hello, world!"));
    let mut args = parse_args();
    let mut elf_filename = args.nth(1).unwrap();
    let rootfs       = args.next().unwrap();
    
    let mut elf_data    = std::fs::read(&mut elf_filename).unwrap();
    let mut elf: ElfFile        = ElfFile::new(&mut elf_data).unwrap();

    //our hello world program takes no arguments or environment variables
    let program_args: Vec<String>   = vec![];
    let program_env: Vec<String>    = Vec::new();
    
    let endian =  elf.header.pt1.data();
    let mut emu = core::rudroid::Emulator::new( &elf_filename, &rootfs, &mut elf, endian, program_args, program_env, 0, true).expect("Emulator initialisation failed");
    
    //set up hooks
    core::hooks::add_hooks(&mut emu);

    //run linker to load dependencies of ELF and then run the main from ELF
    emu.run_linker();
    emu.run_elf();

    context_title(Some("Emulator creted"))
}
```
&nbsp;
We are already ready to execute the ELF binary, except that when any syscall is called by the binary we panic with `panic!("Syscall {:?} not implemented yet!", syscall);`

The best part here is, we can just do it on the fly i.e., implement the requested `syscall` that was requested in the above panic. 

Lets' compile and link it with Unicorn/Keystone/capstone.

```Makefile
build:
    RUSTFLAGS="-L /usr/lib/ -lunicorn -L /usr/local/lib/ -lkeystone -Awarnings" cargo run -- /setup/hello  /setup/rootfs/
```
&nbsp;

Now compile and execute with `make`:

<img src="./imgs/make.png" alt="Compile and execute with make">

You can notice in the screenshot above that Emulator panicked with `'Syscall __NR_getpid not implemented yet!'`. So, let's implement __NR_getpid syscall. If you check the documents of getpid (`__NR_getpid`) documented here `https://man7.org/linux/man-pages/man2/getpid.2.html`, just returns the PID of the executing process. Since here we are executing the binary in our own emulator, we can return whatever number as PID in the response. Let's return 1337 as PID.

So we create a file `unistd.rs` inside `syscalls` folder and implement __NR_getpid syscall.

### **`core/android/syscalls/unistd.rs`**
```rust
use std::process;
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_getpid(&mut self) {
        let pid = 1337;
        self.set_return_val(pid as u64);
    }
}
```

&nbsp;

And now we run `make` again to execute.

<img src="./imgs/make2.png" alt="Compile and execute with make">

As you can see, it executed `[DEBUG]:  got syscall: __NR_getpid` and now panicked with `'Syscall __NR3264_mmap not implemented yet!'`. If you are not sure what this syscall does, just search in [bootlin](https://elixir.bootlin.com/linux/latest). For this __NR3264_mmap, it is defined in https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/unistd.h#L645

`__SC_3264(__NR3264_mmap, sys_mmap2, sys_mmap)`

This implements [mmap](https://man7.org/linux/man-pages/man2/mmap.2.html). So, we go ahead and implement this as well.

```rust
impl<D> Emulator<D> {
    pub fn sys_mmap(&mut self) {
        let addr    = self.get_arg(0);
        let len     = self.get_arg(1);
        let prot    = self.get_arg(2);
        let flags   = self.get_arg(3);
        let fd  : i32    = self.get_arg(4) as i32;
        let off     = self.get_arg(5) ;

        let aligned_len = self.align_len(len);

        let mut mmap_base = addr;
        let mut need_map : bool = true;

        if addr == 0 {
            mmap_base         = self.mmap_address;
            self.mmap_address = mmap_base + aligned_len;
        }
        
        else {
            need_map = false;
        }
        
        let is_fixed = (flags & MAP_FIXED) != 0;
        if self.debug {
            self.debug_print(format!("mmap_base 0x{:x} length 0x{:x} fixed: {} = ({:x}, {:x})", addr, len, is_fixed, mmap_base, aligned_len as usize));
        }

        if need_map {
            self.mmu_map(mmap_base, aligned_len as usize, Protection::ALL, "[syscall_mmap]", self.null_mut());
        }

        if (( flags & MAP_ANONYMOUS) == 0 ) && fd < MAX_FDS && fd > 0 {
            let mut data = vec![0u8; len as usize];
            self.filesystem.pread(fd, &mut data, off).unwrap();

            let mem_info: &str = &self.filesystem.get_path(fd).unwrap();

            let map_info = MapInfo {
                memory_start    : mmap_base,
                memory_end      : mmap_base+((len+0x1000-1)/0x1000) * 0x1000,
                memory_perms    : Protection::ALL,
                description     : String::from(mem_info),
            };

            self.add_mapinfo(map_info);
            self.write(mmap_base, &data);
        }

        self.set_return_val(mmap_base);
    }
}
```

&nbsp;

And we `make` again. 

<img src="./imgs/make3.png" alt="Compile and execute with make">

Do you see where I am going? Just keep doing this for few more syscalls till I saw the output 'Hello World' ðŸ’ƒðŸ•ºðŸ’ƒðŸ•º

<img src="./imgs/final.png" alt="Hello World from the binary">

Uffff. That's a long post. Hope it's useful to someone. Please [DM](https://twitter.com/ant4g0nist) me if I made any boo-boo.

&nbsp;


## Resources
- [gamozolabs](https://www.youtube.com/user/gamozolabs)
- [javidx9](https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA)
- [ferrisstreamsstuff](https://www.youtube.com/c/ferrisstreamsstuff)
- https://developer.arm.com/documentation/102374/0101/System-calls

```

`code/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "Rudroid"
version = "0.1.0"
dependencies = [
 "bitflags 1.2.1",
 "byteorder",
 "capstone",
 "keystone",
 "libc",
 "nix",
 "xmas-elf",
]

[[package]]
name = "autocfg"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a"

[[package]]
name = "bitflags"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d"

[[package]]
name = "bitflags"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "capstone"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66b5d1f14c3539b6ff22fcb602fea5f1c4416148c8b7965a2e74860aa169b7b5"
dependencies = [
 "capstone-sys",
 "libc",
]

[[package]]
name = "capstone-sys"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df653a22d0ad34b0d91cc92a6289d96e44aac1c9a96250a094c9aeec4a91084f"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "cc"
version = "1.0.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26a6ce4b6a484fa3edb70f7efa6fc430fd2b87285fe8b84304fd0936faa0dc0"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "keystone"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0409d156f77bf2a5fc3a9f78233b0594ca5cf7a6021fa617403e6c7a2dd421fe"
dependencies = [
 "bitflags 0.7.0",
 "libc",
]

[[package]]
name = "libc"
version = "0.2.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cb00336871be5ed2c8ed44b60ae9959dc5b9f08539422ed43f09e34ecaeba21"

[[package]]
name = "memoffset"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59accc507f1338036a0477ef61afdae33cde60840f4dfe481319ce3ad116ddf9"
dependencies = [
 "autocfg",
]

[[package]]
name = "nix"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7555d6c7164cc913be1ce7f95cbecdabda61eb2ccd89008524af306fb7f5031"
dependencies = [
 "bitflags 1.2.1",
 "cc",
 "cfg-if",
 "libc",
 "memoffset",
]

[[package]]
name = "xmas-elf"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d29b4d8e7beaceb4e77447ba941a7600d23d0319ab52da0461abea214832d5a"
dependencies = [
 "zero",
]

[[package]]
name = "zero"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f1bc8a6b2005884962297587045002d8cfb8dcec9db332f4ca216ddc5de82c5"

```

`code/Cargo.toml`:

```toml
[package]
name = "Rudroid"
version = "0.1.0"
edition = "2018"

[dependencies]
libc = "0.2.101"
bitflags = ">=1.1.0"
xmas-elf = "0.8.0"
byteorder = "1.4.3"
keystone = "0.9.0"
capstone="0.10.0"
nix = "0.22.1"
```

`code/Makefile`:

```
build:
	RUSTFLAGS="-L /usr/lib/ -lunicorn -L /usr/local/lib/ -lkeystone -Awarnings" cargo run -- /setup/hello  /setup/rootfs/

release:
	RUSTFLAGS="-L /usr/lib/ -lunicorn -L /usr/local/lib/ -lkeystone -Awarnings" cargo run  --release -- /home/resources/boo /system/lib64/libgifimage.so /home/resources/rootfs/ /home/resources/seeds/
```

`code/src/core/android/fs/fserrors.rs`:

```rs
use core::{fmt, result};

#[derive(Eq, PartialEq)]
pub struct Error {
    pub errno: i32,
}

pub type Result<T, E = Error> = result::Result<T, E>;

impl Error {
    pub fn new(errno: i32) -> Error {
        Error { errno: errno }
    }

    pub fn mux(result: Result<usize>) -> usize {
        match result {
            Ok(value) => value,
            Err(error) => -error.errno as usize,
        }
    }

    pub fn demux(value: usize) -> Result<usize> {
        let errno = -(value as i32);
        if errno >= 1 && errno < STR_ERROR.len() as i32 {
            Err(Error::new(errno))
        } else {
            Ok(value)
        }
    }

    pub fn text(&self) -> &'static str {
        STR_ERROR.get(self.errno as usize).map(|&x| x).unwrap_or("Unknown Error")
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {
        f.write_str(self.text())
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {
        f.write_str(self.text())
    }
}

pub const EPERM: i32 = 1;  /* Operation not permitted */
pub const ENOENT: i32 = 2;  /* No such file or directory */
pub const ESRCH: i32 = 3;  /* No such process */
pub const EINTR: i32 = 4;  /* Interrupted system call */
pub const EIO: i32 = 5;  /* I/O error */
pub const ENXIO: i32 = 6;  /* No such device or address */
pub const E2BIG: i32 = 7;  /* Argument list too long */
pub const ENOEXEC: i32 = 8;  /* Exec format error */
pub const EBADF: i32 = 9;  /* Bad file number */
pub const ECHILD: i32 = 10;  /* No child processes */
pub const EAGAIN: i32 = 11;  /* Try again */
pub const ENOMEM: i32 = 12;  /* Out of memory */
pub const EACCES: i32 = 13;  /* Permission denied */
pub const EFAULT: i32 = 14;  /* Bad address */
pub const ENOTBLK: i32 = 15;  /* Block device required */
pub const EBUSY: i32 = 16;  /* Device or resource busy */
pub const EEXIST: i32 = 17;  /* File exists */
pub const EXDEV: i32 = 18;  /* Cross-device link */
pub const ENODEV: i32 = 19;  /* No such device */
pub const ENOTDIR: i32 = 20;  /* Not a directory */
pub const EISDIR: i32 = 21;  /* Is a directory */
pub const EINVAL: i32 = 22;  /* Invalid argument */
pub const ENFILE: i32 = 23;  /* File table overflow */
pub const EMFILE: i32 = 24;  /* Too many open files */
pub const ENOTTY: i32 = 25;  /* Not a typewriter */
pub const ETXTBSY: i32 = 26;  /* Text file busy */
pub const EFBIG: i32 = 27;  /* File too large */
pub const ENOSPC: i32 = 28;  /* No space left on device */
pub const ESPIPE: i32 = 29;  /* Illegal seek */
pub const EROFS: i32 = 30;  /* Read-only file system */
pub const EMLINK: i32 = 31;  /* Too many links */
pub const EPIPE: i32 = 32;  /* Broken pipe */
pub const EDOM: i32 = 33;  /* Math argument out of domain of func */
pub const ERANGE: i32 = 34;  /* Math result not representable */
pub const EDEADLK: i32 = 35;  /* Resource deadlock would occur */
pub const ENAMETOOLONG: i32 = 36;  /* File name too long */
pub const ENOLCK: i32 = 37;  /* No record locks available */
pub const ENOSYS: i32 = 38;  /* Function not implemented */
pub const ENOTEMPTY: i32 = 39;  /* Directory not empty */
pub const ELOOP: i32 = 40;  /* Too many symbolic links encountered */
pub const EWOULDBLOCK: i32 = 41;  /* Operation would block */
pub const ENOMSG: i32 = 42;  /* No message of desired type */
pub const EIDRM: i32 = 43;  /* Identifier removed */
pub const ECHRNG: i32 = 44;  /* Channel number out of range */
pub const EL2NSYNC: i32 = 45;  /* Level 2 not synchronized */
pub const EL3HLT: i32 = 46;  /* Level 3 halted */
pub const EL3RST: i32 = 47;  /* Level 3 reset */
pub const ELNRNG: i32 = 48;  /* Link number out of range */
pub const EUNATCH: i32 = 49;  /* Protocol driver not attached */
pub const ENOCSI: i32 = 50;  /* No CSI structure available */
pub const EL2HLT: i32 = 51;  /* Level 2 halted */
pub const EBADE: i32 = 52;  /* Invalid exchange */
pub const EBADR: i32 = 53;  /* Invalid request descriptor */
pub const EXFULL: i32 = 54;  /* Exchange full */
pub const ENOANO: i32 = 55;  /* No anode */
pub const EBADRQC: i32 = 56;  /* Invalid request code */
pub const EBADSLT: i32 = 57;  /* Invalid slot */
pub const EDEADLOCK: i32 = 58; /* Resource deadlock would occur */
pub const EBFONT: i32 = 59;  /* Bad font file format */
pub const ENOSTR: i32 = 60;  /* Device not a stream */
pub const ENODATA: i32 = 61;  /* No data available */
pub const ETIME: i32 = 62;  /* Timer expired */
pub const ENOSR: i32 = 63;  /* Out of streams resources */
pub const ENONET: i32 = 64;  /* Machine is not on the network */
pub const ENOPKG: i32 = 65;  /* Package not installed */
pub const EREMOTE: i32 = 66;  /* Object is remote */
pub const ENOLINK: i32 = 67;  /* Link has been severed */
pub const EADV: i32 = 68;  /* Advertise error */
pub const ESRMNT: i32 = 69;  /* Srmount error */
pub const ECOMM: i32 = 70;  /* Communication error on send */
pub const EPROTO: i32 = 71;  /* Protocol error */
pub const EMULTIHOP: i32 = 72;  /* Multihop attempted */
pub const EDOTDOT: i32 = 73;  /* RFS specific error */
pub const EBADMSG: i32 = 74;  /* Not a data message */
pub const EOVERFLOW: i32 = 75;  /* Value too large for defined data type */
pub const ENOTUNIQ: i32 = 76;  /* Name not unique on network */
pub const EBADFD: i32 = 77;  /* File descriptor in bad state */
pub const EREMCHG: i32 = 78;  /* Remote address changed */
pub const ELIBACC: i32 = 79;  /* Can not access a needed shared library */
pub const ELIBBAD: i32 = 80;  /* Accessing a corrupted shared library */
pub const ELIBSCN: i32 = 81;  /* .lib section in a.out corrupted */
pub const ELIBMAX: i32 = 82;  /* Attempting to link in too many shared libraries */
pub const ELIBEXEC: i32 = 83;  /* Cannot exec a shared library directly */
pub const EILSEQ: i32 = 84;  /* Illegal byte sequence */
pub const ERESTART: i32 = 85;  /* Interrupted system call should be restarted */
pub const ESTRPIPE: i32 = 86;  /* Streams pipe error */
pub const EUSERS: i32 = 87;  /* Too many users */
pub const ENOTSOCK: i32 = 88;  /* Socket operation on non-socket */
pub const EDESTADDRREQ: i32 = 89;  /* Destination address required */
pub const EMSGSIZE: i32 = 90;  /* Message too long */
pub const EPROTOTYPE: i32 = 91;  /* Protocol wrong type for socket */
pub const ENOPROTOOPT: i32 = 92;  /* Protocol not available */
pub const EPROTONOSUPPORT: i32 = 93;  /* Protocol not supported */
pub const ESOCKTNOSUPPORT: i32 = 94;  /* Socket type not supported */
pub const EOPNOTSUPP: i32 = 95;  /* Operation not supported on transport endpoint */
pub const EPFNOSUPPORT: i32 = 96;  /* Protocol family not supported */
pub const EAFNOSUPPORT: i32 = 97;  /* Address family not supported by protocol */
pub const EADDRINUSE: i32 = 98;  /* Address already in use */
pub const EADDRNOTAVAIL: i32 = 99;  /* Cannot assign requested address */
pub const ENETDOWN: i32 = 100; /* Network is down */
pub const ENETUNREACH: i32 = 101; /* Network is unreachable */
pub const ENETRESET: i32 = 102; /* Network dropped connection because of reset */
pub const ECONNABORTED: i32 = 103; /* Software caused connection abort */
pub const ECONNRESET: i32 = 104; /* Connection reset by peer */
pub const ENOBUFS: i32 = 105; /* No buffer space available */
pub const EISCONN: i32 = 106; /* Transport endpoint is already connected */
pub const ENOTCONN: i32 = 107; /* Transport endpoint is not connected */
pub const ESHUTDOWN: i32 = 108; /* Cannot send after transport endpoint shutdown */
pub const ETOOMANYREFS: i32 = 109; /* Too many references: cannot splice */
pub const ETIMEDOUT: i32 = 110; /* Connection timed out */
pub const ECONNREFUSED: i32 = 111; /* Connection refused */
pub const EHOSTDOWN: i32 = 112; /* Host is down */
pub const EHOSTUNREACH: i32 = 113; /* No route to host */
pub const EALREADY: i32 = 114; /* Operation already in progress */
pub const EINPROGRESS: i32 = 115; /* Operation now in progress */
pub const ESTALE: i32 = 116; /* Stale NFS file handle */
pub const EUCLEAN: i32 = 117; /* Structure needs cleaning */
pub const ENOTNAM: i32 = 118; /* Not a XENIX named type file */
pub const ENAVAIL: i32 = 119; /* No XENIX semaphores available */
pub const EISNAM: i32 = 120; /* Is a named type file */
pub const EREMOTEIO: i32 = 121; /* Remote I/O error */
pub const EDQUOT: i32 = 122; /* Quota exceeded */
pub const ENOMEDIUM: i32 = 123; /* No medium found */
pub const EMEDIUMTYPE: i32 = 124; /* Wrong medium type */
pub const ECANCELED: i32 = 125; /* Operation Canceled */
pub const ENOKEY: i32 = 126; /* Required key not available */
pub const EKEYEXPIRED: i32 = 127; /* Key has expired */
pub const EKEYREVOKED: i32 = 128; /* Key has been revoked */
pub const EKEYREJECTED: i32 = 129; /* Key was rejected by service */
pub const EOWNERDEAD: i32 = 130; /* Owner died */
pub const ENOTRECOVERABLE: i32 = 131; /* State not recoverable */

pub static STR_ERROR: [&'static str; 132] = ["Success",
                                             "Operation not permitted",
                                             "No such file or directory",
                                             "No such process",
                                             "Interrupted system call",
                                             "I/O error",
                                             "No such device or address",
                                             "Argument list too long",
                                             "Exec format error",
                                             "Bad file number",
                                             "No child processes",
                                             "Try again",
                                             "Out of memory",
                                             "Permission denied",
                                             "Bad address",
                                             "Block device required",
                                             "Device or resource busy",
                                             "File exists",
                                             "Cross-device link",
                                             "No such device",
                                             "Not a directory",
                                             "Is a directory",
                                             "Invalid argument",
                                             "File table overflow",
                                             "Too many open files",
                                             "Not a typewriter",
                                             "Text file busy",
                                             "File too large",
                                             "No space left on device",
                                             "Illegal seek",
                                             "Read-only file system",
                                             "Too many links",
                                             "Broken pipe",
                                             "Math argument out of domain of func",
                                             "Math result not representable",
                                             "Resource deadlock would occur",
                                             "File name too long",
                                             "No record locks available",
                                             "Function not implemented",
                                             "Directory not empty",
                                             "Too many symbolic links encountered",
                                             "Operation would block",
                                             "No message of desired type",
                                             "Identifier removed",
                                             "Channel number out of range",
                                             "Level 2 not synchronized",
                                             "Level 3 halted",
                                             "Level 3 reset",
                                             "Link number out of range",
                                             "Protocol driver not attached",
                                             "No CSI structure available",
                                             "Level 2 halted",
                                             "Invalid exchange",
                                             "Invalid request descriptor",
                                             "Exchange full",
                                             "No anode",
                                             "Invalid request code",
                                             "Invalid slot",
                                             "Resource deadlock would occur",
                                             "Bad font file format",
                                             "Device not a stream",
                                             "No data available",
                                             "Timer expired",
                                             "Out of streams resources",
                                             "Machine is not on the network",
                                             "Package not installed",
                                             "Object is remote",
                                             "Link has been severed",
                                             "Advertise error",
                                             "Srmount error",
                                             "Communication error on send",
                                             "Protocol error",
                                             "Multihop attempted",
                                             "RFS specific error",
                                             "Not a data message",
                                             "Value too large for defined data type",
                                             "Name not unique on network",
                                             "File descriptor in bad state",
                                             "Remote address changed",
                                             "Can not access a needed shared library",
                                             "Accessing a corrupted shared library",
                                             ".lib section in a.out corrupted",
                                             "Attempting to link in too many shared libraries",
                                             "Cannot exec a shared library directly",
                                             "Illegal byte sequence",
                                             "Interrupted system call should be restarted",
                                             "Streams pipe error",
                                             "Too many users",
                                             "Socket operation on non-socket",
                                             "Destination address required",
                                             "Message too long",
                                             "Protocol wrong type for socket",
                                             "Protocol not available",
                                             "Protocol not supported",
                                             "Socket type not supported",
                                             "Operation not supported on transport endpoint",
                                             "Protocol family not supported",
                                             "Address family not supported by protocol",
                                             "Address already in use",
                                             "Cannot assign requested address",
                                             "Network is down",
                                             "Network is unreachable",
                                             "Network dropped connection because of reset",
                                             "Software caused connection abort",
                                             "Connection reset by peer",
                                             "No buffer space available",
                                             "Transport endpoint is already connected",
                                             "Transport endpoint is not connected",
                                             "Cannot send after transport endpoint shutdown",
                                             "Too many references: cannot splice",
                                             "Connection timed out",
                                             "Connection refused",
                                             "Host is down",
                                             "No route to host",
                                             "Operation already in progress",
                                             "Operation now in progress",
                                             "Stale NFS file handle",
                                             "Structure needs cleaning",
                                             "Not a XENIX named type file",
                                             "No XENIX semaphores available",
                                             "Is a named type file",
                                             "Remote I/O error",
                                             "Quota exceeded",
                                             "No medium found",
                                             "Wrong medium type",
                                             "Operation Canceled",
                                             "Required key not available",
                                             "Key has expired",
                                             "Key has been revoked",
                                             "Key was rejected by service",
                                             "Owner died",
                                             "State not recoverable"];

```

`code/src/core/android/fs/mod.rs`:

```rs
use std::{
    path,
    fs::File,
    fs::OpenOptions,
    io::prelude::*,
    io::{self, Write, Read},
    os::unix::io::FromRawFd,
    os::unix::io::AsRawFd,
    os::unix::io::RawFd,
    os::unix::io::IntoRawFd,
    os::unix::fs::OpenOptionsExt,
    os::unix::fs,
};

use std::collections::HashMap;
pub(crate) mod fserrors;

pub(crate) const MAX_FDS: i32 = 1024;

pub const O_RDONLY  :i32   = 0;
pub const O_WRONLY  :i32   = 1;
pub const O_RDWR    :i32   = 2;
pub const O_APPEND  :i32   = 8;
pub const O_CREAT   :i32   = 512;

pub const O_ACCMODE :i32   = O_CREAT|O_RDWR|O_WRONLY|O_RDONLY;

#[derive(Clone, Debug)]
pub struct oFile {
    pub path    : String,
    // pub file    : File,
    pub fd      : RawFd,
    pub flags   : i32,
    pub seek    : usize,
    pub shared  : bool,
}


#[derive(Debug)]
pub struct FsScheme
{
    pub rootfs        : String,
    pub open_files    : HashMap<RawFd, oFile>
}

impl oFile {
    pub fn new(path: &str, fd: RawFd, flags: i32) -> oFile {
        oFile {
            path   : String::from(path),
            // file  : file,
            fd     : fd,
            flags  : flags,
            seek   : 0,
            shared : false,
        }
    }

    pub fn set_shared(&mut self, shared: bool) {
        self.shared = shared;
    }
}

impl FsScheme {
    pub fn new(rootfs: String) -> FsScheme {
        FsScheme {
            rootfs      : rootfs.clone(),
            open_files  : HashMap::new(),
        }
    }

    pub fn check_for_traversal(&self, path: &str) {
        //! FIX ME. i'm just checking for ../ == ParentDir
        let path = path::Path::new(path);

        for component in path.components().into_iter() {
           match component {
            path::Component::ParentDir => {
                panic!("trying to do dir traversal??/");
            },
            _ => {
                }
           }
        }
    }

    pub fn open(&mut self, path: &str, flags: i32) -> RawFd {

        self.check_for_traversal(path);

        let full_path = self.change_path_if_special(path);

        let file = OpenOptions::new().custom_flags(flags as i32)
                            .create(flags & libc::O_ACCMODE == libc::O_CREAT)
                            .read((flags & libc::O_ACCMODE == libc::O_RDONLY) || (flags & libc::O_ACCMODE == libc::O_RDWR))
                            .write((flags & libc::O_ACCMODE == libc::O_WRONLY) || (flags & libc::O_ACCMODE == libc::O_RDWR))
                            .open(&full_path);

        match file.ok() {
            Some(v) => {
                let fd = v.into_raw_fd();
                let ofile = oFile::new(path, fd, flags);
                self.open_files.insert(fd, ofile);
                fd
            },
            None => {
                -1
            }
        }
    }

    pub fn openat(&mut self, dirfd: RawFd, path: &str, flags: i32, mode: i32) -> RawFd {
        if dirfd >0 && dirfd < 256 {
            unsafe {
                self.check_for_traversal(path);
                let fd = libc::openat(dirfd, path.as_ptr() as *mut libc::c_char, flags);
                let ofile = oFile::new(path, fd, flags);
                self.open_files.insert(fd, ofile);
    
                fd
            }
        }
        else {
            self.open(&path, flags)
        }
    }

    pub fn write(&mut self, fd: RawFd, buffer: &mut [u8]) -> io::Result<usize> {
        unsafe {
            let res = libc::write(fd, buffer.as_mut_ptr() as *mut libc::c_void, buffer.len());
            Ok(res as usize)
        }
    }

    pub fn read(&self, fd: RawFd, buffer: &mut [u8]) -> io::Result<usize> {
        unsafe {
            let res = libc::read(fd, buffer.as_mut_ptr() as *mut libc::c_void, buffer.len());
            Ok(res as usize)
        }
    }

    pub fn pread(&self, fd: RawFd, buf: &mut [u8], offset: u64) -> io::Result<usize> {
        unsafe 
         {
            let orig_off = libc::lseek(fd, 0, libc::SEEK_CUR);
            libc::lseek(fd, offset as i64, libc::SEEK_SET);
            let ret = self.read(fd, buf).unwrap();
            libc::lseek(fd, orig_off as i64, libc::SEEK_SET);
            Ok(ret)
        }
    }

    pub fn close(&mut self, fd: i32) {
        unsafe {
            libc::close(fd);
        }
        let file = self.open_files.get(&fd);
        match file {
            Some(v) => {
                self.open_files.remove(&fd);
            },  
            None => { }
        }
    }

    pub fn get_local_file(&self, fd: RawFd) -> Option<&oFile> {
        for (f, file) in self.open_files.iter() {
            if *f == fd {
                return Some(file);
            }
        }
        None        
    }

    pub fn set_ofile_shared(&mut self, path: &str, shared: bool) {
        for (f, file) in self.open_files.iter_mut() {
            if file.path == path {
                file.set_shared(shared);
            }
        }
    }

    pub fn change_path_if_special(&self, path: &str) -> String {
        if self.is_driver_io(path) {
            return String::from(path);
        }

        let res = match path {
            "/sys/fs/selinux/null" => {
                String::from("/dev/null")
            },
            _ => {
                // let res = format!("{}/{}", self.rootfs, path);
                let mut res = String::new();
                res.push_str(&self.rootfs);
                res.push('/');
                res.push_str(path);
                res
            }
        };
        // println!("{}", res);
        res
    }

    pub fn is_driver_io(&self, path: &str) -> bool {
        match path {
            "/dev/urandom" | "/dev/random"| "/dev/srandom" | "/proc/self/exe" | "/dev/null" => {
                true
            },
            path if path.contains("/proc/self/fd") => {
                true
            },
            _ => {
                false
            }
        }
    }

    pub fn get_path(&mut self, fd: RawFd) -> Result<String, fserrors::Error> {
        for (f, file) in self.open_files.iter() {
            if fd == *f {
                return Ok(file.path.clone());
            }
        }
        Err(fserrors::Error::new(fserrors::ENOENT))
    }
}
```

`code/src/core/android/mod.rs`:

```rs
pub mod fs;
pub mod syscalls;
```

`code/src/core/android/syscalls/fnctl.rs`:

```rs
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_openat(&mut self) {
        // sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
        let dfd = self.get_arg(0);
        let filename_ptr = self.get_arg(1);
        let flags = self.get_arg(2);
        let mode = self.get_arg(3);

        let filename = self.get_string(filename_ptr);
        let fullpath = self.filesystem.change_path_if_special(&filename);
        let path: &str    = &fullpath;
        
        let fd = self.filesystem.openat(dfd as i32, &filename, flags as i32, mode as i32);
        
        // let fd = self.filesystem.open(&filename, flags as i32);
        self.set_return_val(fd as u64);

        if self.debug {
            self.debug_print(format!("sys_openat in: {:x} {} {} {} = {}", dfd, filename, flags, mode, fd));
        }
    }

    pub fn sys_fcntl(&mut self) {
        // sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
        let fd = self.get_arg(0);
        let cmd = self.get_arg(1);
        let arg = self.get_arg(2);
        let res = unsafe {libc::fcntl(fd as i32, cmd as i32)};

        if self.debug {
            self.debug_print(format!("sys_fcntl in: {:x} {:x} {} = {}", fd, cmd, arg, res));
        }

        self.set_return_val(res as u64);   
    }

    pub fn sys_close(&mut self) {
        let fd = self.get_arg(0);
        self.filesystem.close(fd as i32);

        if self.debug {
            self.debug_print(format!("sys_close in: {:x} = {}", fd, 0));
        }

        self.set_return_val(0);
    }    
}
```

`code/src/core/android/syscalls/futex.rs`:

```rs
use std::thread;
use crate::core::rudroid::Emulator;

const FUTEX_WAIT            : u64 = 0;
const FUTEX_WAKE            : u64 = 1;
const FUTEX_FD              : u64 = 2;
const FUTEX_REQUEUE         : u64 = 3;
const FUTEX_CMP_REQUEUE     : u64 = 4;
const FUTEX_WAKE_OP         : u64 = 5;
const FUTEX_LOCK_PI         : u64 = 6;
const FUTEX_UNLOCK_PI       : u64 = 7;
const FUTEX_TRYLOCK_PI      : u64 = 8;
const FUTEX_WAIT_BITSET     : u64 = 9;
const FUTEX_WAKE_BITSET     : u64 = 10;
const FUTEX_WAIT_REQUEUE_PI : u64 = 11;
const FUTEX_CMP_REQUEUE_PI  : u64 = 12;
const FUTEX_PRIVATE_FLAG    : u64 = 128;


impl<D> Emulator<D> {
    pub fn sys_futex(&mut self) {
        // sys_futex(u32 __user *uaddr, int op, u32 val,
        //     struct timespec __user *utime, u32 __user *uaddr2,
        //     u32 val3);
        
        let uaddr   = self.get_arg(0);
        let op      = self.get_arg(1);
        let val     = self.get_arg(2);
        let mut old_val = self.mem_read_as_vec(uaddr, 4).unwrap();
        let mut old_val     = self.unpack(&old_val);
        
        println!("sys_futex: {:x} {} {} op & 0x7f: {}", uaddr, op, val, op & 0x7f);

        match op & 0x7f {
            FUTEX_WAIT => {
                println!("sys_futex: futex_wait {:x} {} {} op & 0x7f: {}", uaddr, op, val, op & 0x7f);
                if old_val == val {
                    if self.debug {
                        println!("futex old = {:x} val = {:x}", old_val, val);
                    }
                    self.emu_stop();
                    self.set_return_val(0);
                }
                
                thread::yield_now();
                let timeout = self.get_arg(3);
                let mytype = val & 0xc000;
                let shared = val & 0x2000;
                // uaddr.setInt(0, mytype | shared);
                let res = mytype | shared;
                self.mem_write(uaddr, &self.pack(res));
                self.set_return_val(0);
            },

            FUTEX_WAKE => {
                self.set_return_val(0);
            },
            _ => {

            }
        }        
    }
}
```

`code/src/core/android/syscalls/ioctl.rs`:

```rs
use libc::ioctl;
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_ioctl(&mut self) {
        // sys_ioctl(unsigned int fd, unsigned int cmd,Â unsigned long arg);
        let fd = self.get_arg(0);
        let cmd = self.get_arg(1);
        let arg = self.get_arg(2);

        unsafe  {
            let res = ioctl(fd as i32, cmd, arg);
            // println!("res: {}", res);
        }
        self.set_return_val(0xffff_ffff)
    }
}
```

`code/src/core/android/syscalls/mman.rs`:

```rs
use xmas_elf::program;

use crate::utilities;
use crate::core::mmu::MapInfo;
use crate::core::rudroid::Emulator;
use crate::core::android::fs::MAX_FDS;
use crate::core::unicorn::unicorn_const::Protection;

const MAP_FIXED      : u64 = 0x10;
const MAP_ANONYMOUS  : u64 = 0x20;
const MREMAP_MAYMOVE : u64 = 0x1;

impl<D> Emulator<D> {
    pub fn sys_mmap(&mut self) {
        let addr    = self.get_arg(0);
        let len     = self.get_arg(1);
        let prot    = self.get_arg(2);
        let flags   = self.get_arg(3);
        let fd  : i32    = self.get_arg(4) as i32;
        let off     = self.get_arg(5) ;

        let aligned_len = self.align_len(len);

        let mut mmap_base = addr;
        let mut need_map : bool = true;

        if addr == 0 {
            mmap_base         = self.mmap_address;
            self.mmap_address = mmap_base + aligned_len;
        }
        
        else {
            need_map = false;
        }
        
        let is_fixed = (flags & MAP_FIXED) != 0;
        if self.debug {
            self.debug_print(format!("mmap_base 0x{:x} length 0x{:x} fixed: {} = ({:x}, {:x})", addr, len, is_fixed, mmap_base, aligned_len as usize));
        }

        if need_map {
            self.mmu_map(mmap_base, aligned_len as usize, Protection::ALL, "[syscall_mmap]", self.null_mut());
        }

        if (( flags & MAP_ANONYMOUS) == 0 ) && fd < MAX_FDS && fd > 0 {
            let mut data = vec![0u8; len as usize];
            self.filesystem.pread(fd, &mut data, off).unwrap();

            let mem_info: &str = &self.filesystem.get_path(fd).unwrap();

            let map_info = MapInfo {
                memory_start    : mmap_base,
                memory_end      : mmap_base+((len+0x1000-1)/0x1000) * 0x1000,
                memory_perms    : Protection::ALL,
                description     : String::from(mem_info),
            };

            self.add_mapinfo(map_info);
            self.write(mmap_base, &data);
        }

        self.set_return_val(mmap_base);
    }

    pub fn sys_mprotect(&mut self) {
        let start  = self.get_arg(0);
        let len    = self.get_arg(1); 
        let prot   = self.get_arg(2);

        if self.debug {
            self.debug_print(format!("mprotect(0x{:x}, 0x{:x}, {})", start, len, prot));
        }
        self.set_return_val(0);
    }

    pub fn sys_munmap(&mut self) {
        let address = self.get_arg(0);
        let len = self.get_arg(1);

        if self.debug {
            self.debug_print(format!("sys_munmap(0x{:x}, 0x{:x})",address, len));
        }
        
        let aligned = ((len + 0x1000 - 1) / 0x1000) * 0x1000;
        self.mmu_unmap(address, aligned as usize);
        // self.munmap(address, len, aligned);
        self.set_return_val(0);
    }

    pub fn munmap(&mut self, address: u64, len: u64, aligned: u64) {
        let removed = self.map_infos.remove_entry(&address);

        let mut nmap_info : MapInfo = MapInfo {
            memory_start    : 0,
            memory_end      : 0,
            memory_perms    : Protection::NONE,
            description     : String::new()  
        };

        match removed {
            Some(v) => {
                let addr = v.0;
                let map_info = v.1;

                let removed_size: u64 = map_info.memory_end - map_info.memory_start;

                if map_info.memory_end - map_info.memory_start != aligned {

                    if aligned >= removed_size {
                        if self.debug {
                            self.debug_print(format!("sys_munmap removed=0x{:x} aligned=0x{:x} start=0x{:x} ",removed_size, aligned, address));
                        }
                        let mut addr = address + removed_size;
                        let mut size = aligned - removed_size;
                        loop {
                            if size == 0 {
                                break;
                            }
    
                            self.map_infos.remove_entry(&addr);
                            addr += removed_size;
                            size -= removed_size;
                        }
                        // return ;
                    }

                    
                    nmap_info = MapInfo {
                        memory_start    : address,
                        memory_end      : address + aligned,
                        memory_perms    : map_info.memory_perms,
                        description     : map_info.description.clone()
                    };
                }

                if self.map_infos.is_empty() {
                    self.mmap_address = address;
                }
            },
            None => {
                for (addr, map_info) in self.map_infos.iter_mut() { 
                     if address > *addr && address < map_info.memory_end {
                        if address + aligned < map_info.memory_end {
                            let new_size = map_info.memory_end - address - aligned;
                            
                            if self.debug {
                                println!("sys_munmap aligned = 0x{:x} start=0x{:x} base=0x{:x} size={}", aligned, address, address+aligned, new_size);
                            }
                            
                            nmap_info = MapInfo {
                                memory_start    : address + aligned,
                                memory_end      : address + aligned + new_size,
                                memory_perms    : map_info.memory_perms,
                                description     : map_info.description.clone()
                            };
                        }
                     } 
                }
            }
        };

        if nmap_info.memory_start != 0 {
            // self.add_mapinfo(nmap_info);
            self.debug_print(format!("sys_munmap address: 0x{:x} len=0x{:x} ",nmap_info.memory_start, (nmap_info.memory_end - nmap_info.memory_start)));

            let desc: &str = &nmap_info.description;
            self.mmu_map(nmap_info.memory_start, (nmap_info.memory_end - nmap_info.memory_start) as usize, nmap_info.memory_perms, "munmap", self.null_mut());
        }               
    }

    pub fn sys_mremap(&mut self) {
        // sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len,Â unsigned long flags, unsigned long new_addr);

        let address = self.get_arg(0);
        let old_len = self.get_arg(1);
        let new_len = self.get_arg(2);
        let flags = self.get_arg(3);
        let new_addr = self.get_arg(4);

        let aligned_old_len = ((old_len + 0x1000 - 1) / 0x1000) * 0x1000;
        let aligned_new_len = ((new_len + 0x1000 - 1) / 0x1000) * 0x1000;

        if self.debug {
            self.debug_print(format!("sys_mremap(0x{:x},0x{:x},0x{:x},0x{:x}, 0x{:x})", address, old_len, new_len, flags, new_addr));
        }

        if old_len == 0 {
            panic!("sys_mremap: old_size is zero");
        }

        if flags & MREMAP_MAYMOVE == 0 {
            panic!("sys_mremap: flags = {:x}", flags);
        }

        let mut nmap_info : MapInfo = MapInfo {
            memory_start    : 0,
            memory_end      : 0,
            memory_perms    : Protection::NONE,
            description     : String::new()  
        };

        for (addr, map_info) in self.map_infos.iter_mut() { 
            if address >= map_info.memory_start && address + old_len <= map_info.memory_end {
                nmap_info = MapInfo {
                    memory_start    : map_info.memory_start,
                    memory_end      : map_info.memory_end,
                    memory_perms    : map_info.memory_perms,
                    description     : map_info.description.clone()
                };
            }
        }

        if nmap_info.memory_start != nmap_info.memory_end && nmap_info.memory_end != 0 {
            
            let len = nmap_info.memory_end - nmap_info.memory_start;
            
            let data = self.mem_read_as_vec(nmap_info.memory_start, len as usize).unwrap();
            self.mmu_unmap(address, len as usize);
            let mmap_base = self.mmap_address;
            self.mmap_address = self.uc_align_down(mmap_base + aligned_new_len);
            self.mmu_map(mmap_base, aligned_new_len as usize, Protection::ALL, "[syscall_mmap]", self.null_mut());
            self.mem_write(mmap_base, &data);
            println!("memory_start {:x} memory_end {:x} memory_perms : {}  description: {}", nmap_info.memory_start, nmap_info.memory_end, nmap_info.memory_perms, nmap_info.description);

            self.set_return_val(mmap_base);
            return;
        }

        self.set_return_val(0xffff_ffff);
    }    

}

```

`code/src/core/android/syscalls/mod.rs`:

```rs
mod syscalls;
mod unistd;
mod mman;
mod futex;
mod sched;
mod signal;
mod prctl;
mod random;
mod fnctl;
mod stat;
mod ioctl;

use crate::{core::{rudroid::Emulator, unicorn::arch::arm64::RegisterARM64}, utilities};

pub fn get_syscall(uc: &mut Emulator<i64>) -> syscalls::Syscalls {
    // syscall_num = UC_ARM64_REG_X8
    let syscall = uc.reg_read(RegisterARM64::X8 as i32).unwrap();
    unsafe { ::std::mem::transmute(syscall) }
}

pub fn hook_syscall(uc: &mut Emulator<i64>, intno: u32) {
    let pc = uc.reg_read(RegisterARM64::PC as i32).unwrap();
    let syscall = get_syscall(uc);
    uc.syscall(syscall);
}

impl<D> Emulator<D> {
    pub fn syscall(&mut self, syscall: syscalls::Syscalls) {
        if self.debug {
            utilities::draw_line();
            self.debug_print(format!("got syscall: {:?}", syscall));
        }
        
        match syscall {
            
            syscalls::Syscalls::__NR3264_mmap =>
            {
                self.sys_mmap();
            },

            syscalls::Syscalls::__NR_getpid =>
            {
                self.sys_getpid();
            },
            
            syscalls::Syscalls::__NR_set_tid_address => {
                self.sys_set_tid_address();
            },
            
            syscalls::Syscalls::__NR_faccessat => {
                self.sys_faccessat();
            },
            
            syscalls::Syscalls::__NR_futex => {
                self.sys_futex();
            },

            syscalls::Syscalls::__NR_sched_getscheduler => {
                self.sys_sched_getscheduler();
            },
            
            syscalls::Syscalls::__NR_mprotect => {
                self.sys_mprotect();
            },
            syscalls::Syscalls::__NR_sigaltstack => {
                self.sys_sigaltstack();
            },

            //prctl
            syscalls::Syscalls::__NR_prctl => {
                self.prctl();
            },

            //random
            syscalls::Syscalls::__NR_getrandom => {
                self.sys_getrandom();
            },
            
            syscalls::Syscalls::__NR_openat => {
                self.sys_openat();
            },
            syscalls::Syscalls::__NR3264_fcntl => {
                self.sys_fcntl()
            },
            syscalls::Syscalls::__NR_close => {
                self.sys_close();
            },

            syscalls::Syscalls::__NR3264_fstatat => {
                self.sys_fstatat();
            },

            syscalls::Syscalls::__NR_readlinkat => {
                self.sys_readlinkat();
            },

            syscalls::Syscalls::__NR_rt_sigaction => {
                self.sys_rt_sigaction();
            },

            syscalls::Syscalls::__NR3264_fstat => {
                self.sys_fstat();
            },

            syscalls::Syscalls::__NR_read => {
                self.sys_read();
            },
            syscalls::Syscalls::__NR_munmap => {
                self.sys_munmap();
            },

            syscalls::Syscalls::__NR3264_fstatfs => {
                self.sys_fstatfs();
            },

            syscalls::Syscalls::__NR_pread64 => {
                self.sys_pread64()
            },

            syscalls::Syscalls::__NR_rt_sigprocmask => {
                self.sys_rt_sigprocmask();
            },

            syscalls::Syscalls::__NR_clock_gettime => {
                self.empty_syscall_return();
            },
            syscalls::Syscalls::__NR_madvise => {
                self.empty_syscall_return();
            },

            syscalls::Syscalls::__NR_getuid => {
                self.sys_getuid()
            },
            syscalls::Syscalls::__NR_write => {
                self.sys_write()
            },

            syscalls::Syscalls::__NR_ioctl => {
                self.sys_ioctl();
            },

            syscalls::Syscalls::__NR_exit_group => {
                self.sys_exit_group();
            },

            _ => {
                panic!("Syscall {:?} not implemented yet!", syscall);
            }
        }; 
    }

    pub fn empty_syscall_return(&mut self) {
        self.reg_write(RegisterARM64::X0 as i32, 0).unwrap();
    }

    pub fn get_arg(&mut self, num: i32) -> u64 {
        // 'x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7'
        match num {
            0 => {
                self.reg_read(RegisterARM64::X0 as i32).unwrap()
            },
            1 => {
                self.reg_read(RegisterARM64::X1 as i32).unwrap()
            },
            2 => {
                self.reg_read(RegisterARM64::X2 as i32).unwrap()
            },
            3 => {
                self.reg_read(RegisterARM64::X3 as i32).unwrap()
            },
            4 => {
                self.reg_read(RegisterARM64::X4 as i32).unwrap()
            },
            5 => {
                self.reg_read(RegisterARM64::X5 as i32).unwrap()
            },
            6 => {
                self.reg_read(RegisterARM64::X6 as i32).unwrap()
            },
            7 => {
                self.reg_read(RegisterARM64::X7 as i32).unwrap()
            },
            _ => {
                panic!("i do not support any more arguments :/");
            }
        }
    }

    pub fn set_return_val(&mut self, value: u64) {
        self.reg_write(RegisterARM64::X0 as i32, value).unwrap();
    }

    pub fn get_string(&mut self, addr: u64) -> String {
        let mut addr = addr;
        let mut string = String::new();

        loop {
            let c = self.mem_read_as_vec(addr, 1).unwrap();
            let c = char::from(c[0]);
            match c {
                '\x20'..='\x7e' => {
                    string.push(c)
                },
                _ => {
                    break;
                }
            };
            addr+=1;
        }
        string
    }    
}
```

`code/src/core/android/syscalls/prctl.rs`:

```rs
use crate::core::rudroid::Emulator;

const PR_SET_NAME       : u64 = 15;
const BIONIC_PR_SET_VMA : u64 = 0x53564d41;
const PR_SET_PTRACER    : u64 = 0x59616d61;

impl<D> Emulator<D> {
    pub fn prctl(&mut self) {
        // sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)

        let option = self.get_arg(0);
        let arg2   = self.get_arg(1);

        self.debug_print(format!("prctl option = 0x{:x}, arg2=0x{:x}",option, arg2));
        self.set_return_val(0);
    }
}
```

`code/src/core/android/syscalls/random.rs`:

```rs
use std::{io::Read, fs::File};
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_getrandom(&mut self) {
        // sys_getrandom(char __user *buf, size_t count, unsigned int flags);
        let buf_ptr = self.get_arg(0);
        let count   = self.get_arg(1);
        let flags   = self.get_arg(2);

        let mut f = File::open("/dev/urandom").unwrap();
        let mut buf = vec![0; count as usize];
        f.read_exact(&mut buf).unwrap();

        if self.debug {
            self.debug_print(format!("sys_getrandom {:x} {} {}", buf_ptr, count, flags));
        }
        
        let res = self.mem_write(buf_ptr, &buf);
        match res.ok() {
            Some(v) => {
                self.set_return_val(count);
            },
            None => {
                self.set_return_val(0xffff_ffff);
            }
        };
    }
}
```

`code/src/core/android/syscalls/sched.rs`:

```rs
use crate::core::android::fs::fserrors;
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_sched_getscheduler(&mut self) {
        // sys_sched_getscheduler(pid_t pid);
        let pid = self.get_arg(0) as u32;
        let pid_s = pid as i32;

        if pid_s < 0 {
            self.set_return_val(fserrors::EINVAL as u64);
            return;
        }

        let res = unsafe { libc::sched_getscheduler(pid_s) };
        self.set_return_val(res as u64);
        self.debug_print(format!("sys_sched_getscheduler: {:} = {:}", pid, res));
    }
}
```

`code/src/core/android/syscalls/signal.rs`:

```rs
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_sigaltstack(&mut self) {
        // sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);
        let ss      = self.get_arg(0);
        let old_ss  = self.get_arg(1);
        self.set_return_val(0);
    }

    pub fn sys_rt_sigaction(&mut self) {
        // sys_rt_sigaction(int, const struct sigaction __user *, struct sigaction __user *, size_t);
        let sig_num = self.get_arg(0);
        let sigaction = self.get_arg(1);        //pointer
        let oldaction =   self.get_arg(2);      //pointer
        
        // sigaction(signum, sigaction, oldaction);
        self.sigaction(sig_num, sigaction, oldaction);
        self.set_return_val(0);
    }   

    pub fn sigaction(&mut self, signum: u64, act: u64, oldact : u64) {
        let mut sig_num = signum;
        let mut prefix = "Unknown";

        self.debug_print(format!("sigaction signum={}, act={:x}, oldact={:x} prefix={}", sig_num, act, oldact, prefix));

        if oldact != 0 {
            let last_act    = self.sigmap.get(&sig_num);
            
            let data = match last_act {
                Some(v) => {
                    last_act.unwrap().clone()
                },
                None => {
                    let res = vec![0u8; 20];
                    res.clone()
                }
            };

            self.write(oldact, &data);
        }

        if act != 0 {
            let mut data = Vec::new();
            for i in 0..5 {
                let addr =  act + 4*i;
                let val = self.mem_read_as_vec(addr, 4).unwrap();
                // let val = self.unpack_32(&val);
                data.extend_from_slice(&val);
            }
            self.sigmap.insert(signum, data);
        }
    }

    pub fn sys_rt_sigprocmask(&mut self) {
        // sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);
        let how         = self.get_arg(0); 
        let set         = self.get_arg(1);
        let oset        = self.get_arg(2);
        let sigsetsize  = self.get_arg(3);

        self.set_return_val(0);
    }

    pub fn sys_exit_group(&mut self) {
        // sys_exit_group(int error_code)
        let error_code = self.get_arg(0);
        self.debug_print(format!("sys_exit_group code: {}", error_code));
        self.emu_stop();
        std::process::exit(1);
    }    

}
```

`code/src/core/android/syscalls/stat.rs`:

```rs
use std::path::Path;
use crate::core::{uid, gid};
use crate::core::rudroid::Emulator;
use nix::sys::stat::{fstatat, fstat};
use nix::sys::statfs::{Statfs, fstatfs};

impl<D> Emulator<D> {
    pub fn sys_fstatat(&mut self) {
        // sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);
        let dirfd         = self.get_arg(0);
        let filename_ptr = self.get_arg(1); 
        let statbuf      = self.get_arg(2);
        let flag         = self.get_arg(3);

        let filename = self.get_string(filename_ptr);
        
        let fullpath = match self.filesystem.is_driver_io(&filename) {
            true => {
                filename
            },
            false => {
                format!("{}/{}", self.rootfs, filename)
            }
        };

        let fullpath: &str = &fullpath;
        if Path::new(fullpath).exists() {
            let result = fstatat(dirfd as i32, fullpath, unsafe { std::mem::transmute(flag as u32) }).unwrap();
            let mut fsstatbuf  = Vec::new();
    
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_dev as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_ino));

            fsstatbuf.extend_from_slice(&self.pack_32(result.st_mode as u32));
            fsstatbuf.extend_from_slice(&self.pack_32(result.st_nlink as u32));
            fsstatbuf.extend_from_slice(&self.pack_32(1000));
            fsstatbuf.extend_from_slice(&self.pack_32(1000));

            fsstatbuf.extend_from_slice(&self.pack_64(result.st_rdev as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(0));
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_size as u64));

            fsstatbuf.extend_from_slice(&self.pack_32(result.st_blksize as u32));
            fsstatbuf.extend_from_slice(&self.pack_32(0));
    
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_blocks as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_atime as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(0));
            
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_mtime as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(0));
    
            fsstatbuf.extend_from_slice(&self.pack_64(result.st_ctime as u64));
            fsstatbuf.extend_from_slice(&self.pack_64(0));  

            self.mem_write(statbuf, &fsstatbuf);
            self.set_return_val(0);

            // println!("sys_fstatat dirfd: {} filename {}: statbuf {:x}", dirfd, fullpath, statbuf);
            if self.debug {
                self.debug_print(format!("sys_fstatat dirfd: {} filename {}: statbuf {}", dirfd, fullpath, statbuf));
            }
        }
        else {
            self.set_return_val(0xffff_ffff);
        }
    }

    pub fn sys_fstat(&mut self) {
        // sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);
        let fd = self.get_arg(0);
        let statbuf = self.get_arg(1);

        let fstat_info = fstat(fd as i32).unwrap();
        let mut fstatbuf = Vec::new();
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_dev as u64));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_ino as u64));
        fstatbuf.extend_from_slice(&self.pack_32(fstat_info.st_mode as u32));
        fstatbuf.extend_from_slice(&self.pack_32(fstat_info.st_nlink as u32));

        fstatbuf.extend_from_slice(&self.pack_32(uid));
        fstatbuf.extend_from_slice(&self.pack_32(gid));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_rdev as u64));
        fstatbuf.extend_from_slice(&self.pack_64(0));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_size  as u64));
        fstatbuf.extend_from_slice(&self.pack_32(fstat_info.st_blksize as u32));
        fstatbuf.extend_from_slice(&self.pack_32(0));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_blocks  as u64));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_atime  as u64));
        fstatbuf.extend_from_slice(&self.pack_64(0));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_mtime as u64));
        fstatbuf.extend_from_slice(&self.pack_64(0));
        fstatbuf.extend_from_slice(&self.pack_64(fstat_info.st_ctime as u64));
        fstatbuf.extend_from_slice(&self.pack_64(0));

        self.mem_write(statbuf, &fstatbuf);

        self.set_return_val(0);
    }

    pub fn sys_fstatfs(&mut self) {
        // sys_fstatfs(unsigned int fd, struct statfs __user *buf);
        let fd = self.get_arg(0) as i32;
        let fstatbuf = self.get_arg(1);
        
        let mut statbuf = Vec::new();

        statbuf.extend_from_slice(&self.pack_64(0xef53));
        statbuf.extend_from_slice(&self.pack_64(0x1000));
        statbuf.extend_from_slice(&self.pack_64(0x3235af));
        statbuf.extend_from_slice(&self.pack_64(0x2b5763));
        statbuf.extend_from_slice(&self.pack_64(0x2b5763));
        statbuf.extend_from_slice(&self.pack_64(0xcccb0));
        statbuf.extend_from_slice(&self.pack_64(0xcbd2e));
        statbuf.extend_from_slice(&self.pack_64(0xd3609fe8));
        statbuf.extend_from_slice(&self.pack_64(0x4970d6b));
        statbuf.extend_from_slice(&self.pack_64(0xff));
        statbuf.extend_from_slice(&self.pack_64(0x1000));
        statbuf.extend_from_slice(&self.pack_64(0x426));
        self.mem_write(fstatbuf, &statbuf);
        self.set_return_val(0);        
    }

}
```

`code/src/core/android/syscalls/syscalls.rs`:

```rs

#[repr(u64)]
#[derive(Debug)]
//taken from android kernel's include/uapi/asm-generic/unistd.h
pub enum Syscalls {
    __NR_io_setup	 = 0,
    __NR_io_destroy	 = 1,
    __NR_io_submit	 = 2,
    __NR_io_cancel	 = 3,
    __NR_io_getevents	 = 4,
    __NR_setxattr	 = 5,
    __NR_lsetxattr	 = 6,
    __NR_fsetxattr	 = 7,
    __NR_getxattr	 = 8,
    __NR_lgetxattr	 = 9,
    __NR_fgetxattr	 = 10,
    __NR_listxattr	 = 11,
    __NR_llistxattr	 = 12,
    __NR_flistxattr	 = 13,
    __NR_removexattr	 = 14,
    __NR_lremovexattr	 = 15,
    __NR_fremovexattr	 = 16,
    __NR_getcwd	 = 17,
    __NR_lookup_dcookie	 = 18,
    __NR_eventfd2	 = 19,
    __NR_epoll_create1	 = 20,
    __NR_epoll_ctl	 = 21,
    __NR_epoll_pwait	 = 22,
    __NR_dup	 = 23,
    __NR_dup3	 = 24,
    __NR3264_fcntl	 = 25,
    __NR_inotify_init1	 = 26,
    __NR_inotify_add_watch	 = 27,
    __NR_inotify_rm_watch	 = 28,
    __NR_ioctl	 = 29,
    __NR_ioprio_set	 = 30,
    __NR_ioprio_get	 = 31,
    __NR_flock	 = 32,
    __NR_mknodat	 = 33,
    __NR_mkdirat	 = 34,
    __NR_unlinkat	 = 35,
    __NR_symlinkat	 = 36,
    __NR_linkat	 = 37,
    __NR_renameat	 = 38,
    __NR_umount2	 = 39,
    __NR_mount	 = 40,
    __NR_pivot_root	 = 41,
    __NR_nfsservctl	 = 42,
    __NR3264_statfs	 = 43,
    __NR3264_fstatfs	 = 44,
    __NR3264_truncate	 = 45,
    __NR3264_ftruncate	 = 46,
    __NR_fallocate	 = 47,
    __NR_faccessat	 = 48,
    __NR_chdir	 = 49,
    __NR_fchdir	 = 50,
    __NR_chroot	 = 51,
    __NR_fchmod	 = 52,
    __NR_fchmodat	 = 53,
    __NR_fchownat	 = 54,
    __NR_fchown	 = 55,
    __NR_openat	 = 56,
    __NR_close	 = 57,
    __NR_vhangup	 = 58,
    __NR_pipe2	 = 59,
    __NR_quotactl	 = 60,
    __NR_getdents64	 = 61,
    __NR3264_lseek	 = 62,
    __NR_read	 = 63,
    __NR_write	 = 64,
    __NR_readv	 = 65,
    __NR_writev	 = 66,
    __NR_pread64	 = 67,
    __NR_pwrite64	 = 68,
    __NR_preadv	 = 69,
    __NR_pwritev	 = 70,
    __NR3264_sendfile	 = 71,
    __NR_pselect6	 = 72,
    __NR_ppoll	 = 73,
    __NR_signalfd4	 = 74,
    __NR_vmsplice	 = 75,
    __NR_splice	 = 76,
    __NR_tee	 = 77,
    __NR_readlinkat	 = 78,
    __NR3264_fstatat	 = 79,
    __NR3264_fstat	 = 80,
    __NR_sync	 = 81,
    __NR_fsync	 = 82,
    __NR_fdatasync	 = 83,
    __NR_sync_file_range2	 = 84,
    // __NR_sync_file_range	 = 84,
    __NR_timerfd_create	 = 85,
    __NR_timerfd_settime	 = 86,
    __NR_timerfd_gettime	 = 87,
    __NR_utimensat	 = 88,
    __NR_acct	 = 89,
    __NR_capget	 = 90,
    __NR_capset	 = 91,
    __NR_personality	 = 92,
    __NR_exit	 = 93,
    __NR_exit_group	 = 94,
    __NR_waitid	 = 95,
    __NR_set_tid_address	 = 96,
    __NR_unshare	 = 97,
    __NR_futex	 = 98,
    __NR_set_robust_list	 = 99,
    __NR_get_robust_list	 = 100,
    __NR_nanosleep	 = 101,
    __NR_getitimer	 = 102,
    __NR_setitimer	 = 103,
    __NR_kexec_load	 = 104,
    __NR_init_module	 = 105,
    __NR_delete_module	 = 106,
    __NR_timer_create	 = 107,
    __NR_timer_gettime	 = 108,
    __NR_timer_getoverrun	 = 109,
    __NR_timer_settime	 = 110,
    __NR_timer_delete	 = 111,
    __NR_clock_settime	 = 112,
    __NR_clock_gettime	 = 113,
    __NR_clock_getres	 = 114,
    __NR_clock_nanosleep	 = 115,
    __NR_syslog	 = 116,
    __NR_ptrace	 = 117,
    __NR_sched_setparam	 = 118,
    __NR_sched_setscheduler	 = 119,
    __NR_sched_getscheduler	 = 120,
    __NR_sched_getparam	 = 121,
    __NR_sched_setaffinity	 = 122,
    __NR_sched_getaffinity	 = 123,
    __NR_sched_yield	 = 124,
    __NR_sched_get_priority_max	 = 125,
    __NR_sched_get_priority_min	 = 126,
    __NR_sched_rr_get_interval	 = 127,
    __NR_restart_syscall	 = 128,
    __NR_kill	 = 129,
    __NR_tkill	 = 130,
    __NR_tgkill	 = 131,
    __NR_sigaltstack	 = 132,
    __NR_rt_sigsuspend	 = 133,
    __NR_rt_sigaction	 = 134,
    __NR_rt_sigprocmask	 = 135,
    __NR_rt_sigpending	 = 136,
    __NR_rt_sigtimedwait	 = 137,
    __NR_rt_sigqueueinfo	 = 138,
    __NR_rt_sigreturn	 = 139,
    __NR_setpriority	 = 140,
    __NR_getpriority	 = 141,
    __NR_reboot	 = 142,
    __NR_setregid	 = 143,
    __NR_setgid	 = 144,
    __NR_setreuid	 = 145,
    __NR_setuid	 = 146,
    __NR_setresuid	 = 147,
    __NR_getresuid	 = 148,
    __NR_setresgid	 = 149,
    __NR_getresgid	 = 150,
    __NR_setfsuid	 = 151,
    __NR_setfsgid	 = 152,
    __NR_times	 = 153,
    __NR_setpgid	 = 154,
    __NR_getpgid	 = 155,
    __NR_getsid	 = 156,
    __NR_setsid	 = 157,
    __NR_getgroups	 = 158,
    __NR_setgroups	 = 159,
    __NR_uname	 = 160,
    __NR_sethostname	 = 161,
    __NR_setdomainname	 = 162,
    __NR_getrlimit	 = 163,
    __NR_setrlimit	 = 164,
    __NR_getrusage	 = 165,
    __NR_umask	 = 166,
    __NR_prctl	 = 167,
    __NR_getcpu	 = 168,
    __NR_gettimeofday	 = 169,
    __NR_settimeofday	 = 170,
    __NR_adjtimex	 = 171,
    __NR_getpid	 = 172,
    __NR_getppid	 = 173,
    __NR_getuid	 = 174,
    __NR_geteuid	 = 175,
    __NR_getgid	 = 176,
    __NR_getegid	 = 177,
    __NR_gettid	 = 178,
    __NR_sysinfo	 = 179,
    __NR_mq_open	 = 180,
    __NR_mq_unlink	 = 181,
    __NR_mq_timedsend	 = 182,
    __NR_mq_timedreceive	 = 183,
    __NR_mq_notify	 = 184,
    __NR_mq_getsetattr	 = 185,
    __NR_msgget	 = 186,
    __NR_msgctl	 = 187,
    __NR_msgrcv	 = 188,
    __NR_msgsnd	 = 189,
    __NR_semget	 = 190,
    __NR_semctl	 = 191,
    __NR_semtimedop	 = 192,
    __NR_semop	 = 193,
    __NR_shmget	 = 194,
    __NR_shmctl	 = 195,
    __NR_shmat	 = 196,
    __NR_shmdt	 = 197,
    __NR_socket	 = 198,
    __NR_socketpair	 = 199,
    __NR_bind	 = 200,
    __NR_listen	 = 201,
    __NR_accept	 = 202,
    __NR_connect	 = 203,
    __NR_getsockname	 = 204,
    __NR_getpeername	 = 205,
    __NR_sendto	 = 206,
    __NR_recvfrom	 = 207,
    __NR_setsockopt	 = 208,
    __NR_getsockopt	 = 209,
    __NR_shutdown	 = 210,
    __NR_sendmsg	 = 211,
    __NR_recvmsg	 = 212,
    __NR_readahead	 = 213,
    __NR_brk	 = 214,
    __NR_munmap	 = 215,
    __NR_mremap	 = 216,
    __NR_add_key	 = 217,
    __NR_request_key	 = 218,
    __NR_keyctl	 = 219,
    __NR_clone	 = 220,
    __NR_execve	 = 221,
    __NR3264_mmap	 = 222,
    __NR3264_fadvise64	 = 223,
    __NR_swapon	 = 224,
    __NR_swapoff	 = 225,
    __NR_mprotect	 = 226,
    __NR_msync	 = 227,
    __NR_mlock	 = 228,
    __NR_munlock	 = 229,
    __NR_mlockall	 = 230,
    __NR_munlockall	 = 231,
    __NR_mincore	 = 232,
    __NR_madvise	 = 233,
    __NR_remap_file_pages	 = 234,
    __NR_mbind	 = 235,
    __NR_get_mempolicy	 = 236,
    __NR_set_mempolicy	 = 237,
    __NR_migrate_pages	 = 238,
    __NR_move_pages	 = 239,
    __NR_rt_tgsigqueueinfo	 = 240,
    __NR_perf_event_open	 = 241,
    __NR_accept4	 = 242,
    __NR_recvmmsg	 = 243,
    __NR_arch_specific_syscall	 = 244,
    __NR_wait4	 = 260,
    __NR_prlimit64	 = 261,
    __NR_fanotify_init	 = 262,
    __NR_fanotify_mark	 = 263,
    __NR_name_to_handle_at	 = 264,
    __NR_open_by_handle_at	 =  265,
    __NR_clock_adjtime	 = 266,
    __NR_syncfs	 = 267,
    __NR_setns	 = 268,
    __NR_sendmmsg	 = 269,
    __NR_process_vm_readv	 = 270,
    __NR_process_vm_writev	 = 271,
    __NR_kcmp	 = 272,
    __NR_finit_module	 = 273,
    __NR_sched_setattr	 = 274,
    __NR_sched_getattr	 = 275,
    __NR_renameat2	 = 276,
    __NR_seccomp	 = 277,
    __NR_getrandom	 = 278,
    __NR_memfd_create	 = 279,
    __NR_bpf	 = 280,
    __NR_execveat	 = 281,
    __NR_userfaultfd	 = 282,
    __NR_membarrier	 = 283,
    __NR_mlock2	 = 284,
    __NR_copy_file_range	 = 285,
    __NR_preadv2	 = 286,
    __NR_pwritev2	 = 287,
    __NR_pkey_mprotect	 = 288,
    __NR_pkey_alloc	 = 289,
    __NR_pkey_free	 = 290,
    __NR_statx	 = 291,
    __NR_syscalls	 = 292,
    __NR_open	 = 1024,
    __NR_link	 = 1025,
    __NR_unlink	 = 1026,
    __NR_mknod	 = 1027,
    __NR_chmod	 = 1028,
    __NR_chown	 = 1029,
    __NR_mkdir	 = 1030,
    __NR_rmdir	 = 1031,
    __NR_lchown	 = 1032,
    __NR_access	 = 1033,
    __NR_rename	 = 1034,
    __NR_readlink	 = 1035,
    __NR_symlink	 = 1036,
    __NR_utimes	 = 1037,
    __NR3264_stat	 = 1038,
    __NR3264_lstat	 = 1039,
    // __NR_syscalls	 = (__NR3264_lstat+1),
    __NR_pipe	 = 1040,
    __NR_dup2	 = 1041,
    __NR_epoll_create	 = 1042,
    __NR_inotify_init	 = 1043,
    __NR_eventfd	 = 1044,
    __NR_signalfd	 = 1045,
    // __NR_syscalls	 = (__NR_signalfd+1),
    __NR_sendfile	 = 1046,
    __NR_ftruncate	 = 1047,
    __NR_truncate	 = 1048,
    __NR_stat	 = 1049,
    __NR_lstat	 = 1050,
    __NR_fstat	 = 1051,
    __NR_fcntl	 = 1052,
    __NR_fadvise64	 = 1053,
    __NR_newfstatat	 = 1054,
    __NR_fstatfs	 = 1055,
    __NR_statfs	 = 1056,
    __NR_lseek	 = 1057,
    __NR_mmap	 = 1058,
    // __NR_syscalls	 = (__NR_mmap+1),
    __NR_alarm	 = 1059,
    __NR_getpgrp	 = 1060,
    __NR_pause	 = 1061,
    __NR_time	 = 1062,
    __NR_utime	 = 1063,
    __NR_creat	 = 1064,
    __NR_getdents	 = 1065,
    __NR_futimesat	 = 1066,
    __NR_select	 = 1067,
    __NR_poll	 = 1068,
    __NR_epoll_wait	 = 1069,
    __NR_ustat	 = 1070,
    __NR_vfork	 = 1071,
    __NR_oldwait4	 = 1072,
    __NR_recv	 = 1073,
    __NR_send	 = 1074,
    __NR_bdflush	 = 1075,
    __NR_umount	 = 1076,
    __NR_uselib	 = 1077,
    __NR__sysctl	 = 1078,
    __NR_fork	 = 1079,
    // __NR_syscalls	 = (__NR_fork+1),
    // __NR_fcntl	 = __NR3264_fcntl,
    // __NR_statfs	 = __NR3264_statfs,
    // __NR_fstatfs	 = __NR3264_fstatfs,
    // __NR_truncate	 = __NR3264_truncate,
    // __NR_ftruncate	 = __NR3264_ftruncate,
    // __NR_lseek	 = __NR3264_lseek,
    // __NR_sendfile	 = __NR3264_sendfile,
    // __NR_newfstatat	 = __NR3264_fstatat,
    // __NR_fstat	 = __NR3264_fstat,
    // __NR_mmap	 = __NR3264_mmap,
    // __NR_fadvise64	 = __NR3264_fadvise64,
    // __NR_stat	 = __NR3264_stat,
    // __NR_lstat	 = __NR3264_lstat,
    // __NR_fcntl64	 = __NR3264_fcntl,
    // __NR_statfs64	 = __NR3264_statfs,
    // __NR_fstatfs64	 = __NR3264_fstatfs,
    // __NR_truncate64	 = __NR3264_truncate,
    // __NR_ftruncate64	 = __NR3264_ftruncate,
    // __NR_llseek	 = __NR3264_lseek,
    // __NR_sendfile64	 = __NR3264_sendfile,
    // __NR_fstatat64	 = __NR3264_fstatat,
    // __NR_fstat64	 = __NR3264_fstat,
    // __NR_mmap2	 = __NR3264_mmap,
    // __NR_fadvise64_64	 = __NR3264_fadvise64,
    // __NR_stat64	 = __NR3264_stat,
    // __NR_lstat64	 = __NR3264_lstat,

    None,
}
```

`code/src/core/android/syscalls/unistd.rs`:

```rs
use std::process;
use crate::core::{uid, gid};
use crate::core::rudroid::Emulator;

impl<D> Emulator<D> {
    pub fn sys_getpid(&mut self) {
        let pid = 1337;
        self.set_return_val(pid as u64);
    }

    pub fn sys_set_tid_address(&mut self) {
        let tidptr       = self.get_arg(0);

        let pid          = process::id();
        let pid_buf  = self.pack_32(pid);

        self.mem_write(tidptr, &pid_buf);
        self.set_return_val(pid as u64);        
    }

    pub fn sys_faccessat(&mut self) {
        // faccessat(int dfd, const char __user *filename, int mode);
        let dfd             = self.get_arg(0);
        let filename_ptr    = self.get_arg(1);
        let mode            = self.get_arg(2);
        let path         = self.get_string(filename_ptr);
        
        let fd = self.filesystem.open(&path, libc::O_RDONLY);

        if self.debug {
            self.debug_print(format!("sys_faccessat {:x} {} {} = {}", dfd, path, mode, fd));
        }
        
        self.set_return_val(fd as u64);
    }

    pub fn sys_readlinkat(&mut self) {
        // sys_readlinkat(int dfd, const char __user *path, char __user *buf,Â int bufsiz);
        let dfd      = self.get_arg(0);
        let path_ptr = self.get_arg(1);
        let buf      = self.get_arg(2);
        let buf_size = self.get_arg(3);

        let path = self.get_string(path_ptr);
        let fullpath = format!("{}/{}", self.rootfs, path);

        if path == "/proc/self/exe" {
            // todo!();
            let mut path = self.elf_path.clone();
            let mut size    = self.elf_path.len() as u64;

            let mut path_buf = Vec::new();

            path_buf.extend_from_slice(&path.as_bytes());
            path_buf.push(0);

            self.debug_print(format!("readlink at {} = {}", path, (self.elf_path.len())));

            self.mem_write(buf, &path_buf);
            self.set_return_val((path_buf.len()-1) as u64);
        }
        
        else if path.contains("/proc/self/fd") {
            self.mem_write(buf, &path.as_bytes());
            self.set_return_val((path.len()-1) as u64);
        }

        else {
            let mut data = vec![0u8; buf_size as usize];
            self.set_return_val(0);
        }
    }

    pub fn sys_read(&mut self) {
        // sys_read(unsigned int fd, char __user *buf, size_t count);
        let fd = self.get_arg(0);
        let buf = self.get_arg(1);
        let count = self.get_arg(2);

        let mut data = vec![0u8; count as usize];
        let res = self.filesystem.read(fd as i32, &mut data);
        
        match res.ok() {
            Some(v) => {
                if self.debug == true {
                    println!("sys_read {} {:x} {:x} = {:x}",fd, buf, count, v);
                }
                self.mem_write(buf, &data);
                self.set_return_val(v as u64);
            },
            None => {
                // println!("sys_read fail {} {:x} {:x} = {:x}",fd, buf, count, -1);
                self.set_return_val(0xffff_ffff);
            }
        }
    }

    pub fn sys_pread64(&mut self) {
        // sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
        let fd = self.get_arg(0);
        let read_buf = self.get_arg(1);
        let read_count = self.get_arg(2);
        let read_pos = self.get_arg(3);

        let mut data = vec![0u8; read_count as usize];
        if read_pos != 0 {
            let res = self.filesystem.pread(fd as i32, &mut data, read_pos).unwrap();
            // println!("sys_pread {} {:x} {:x} {} = {:x}", fd, read_buf, read_count, read_pos, res);
            self.set_return_val(res as u64);
        }

        else {
            self.sys_read();
        }
    }

    pub fn sys_getuid(&mut self) {
        self.set_return_val(uid as u64);
    }

    pub fn sys_write(&mut self) {
        // sys_write(unsigned int fd, const char __user *buf, size_t count);
        let fd = self.get_arg(0);
        let buf_ptr = self.get_arg(1);
        let count  = self.get_arg(2);

        let mut data = self.mem_read_as_vec(buf_ptr, count as usize).unwrap();
        let res = self.filesystem.write(fd as i32, &mut data);
        
        match res.ok() {
            Some(v) => {
                self.set_return_val(v as u64);
            },
            None => {
                self.set_return_val(0xffff_ffff);
            }
        }
    }
    
}
```

`code/src/core/hooks.rs`:

```rs
use capstone::prelude::*;

use super::android;
use super::rudroid;
use super::unicorn::arch::arm64;
use crate::utilities;
use super::unicorn::unicorn_const;

pub fn add_hooks(emu: &mut rudroid::Emulator<i64>) {
    // hook syscalls: https://github.com/unicorn-engine/unicorn/issues/1137
    emu.add_intr_hook(android::syscalls::hook_syscall).unwrap();    
    
    emu.add_mem_hook(unicorn_const::HookType::MEM_FETCH_UNMAPPED, 1, 0, callback_mem_error).unwrap();
    emu.add_mem_hook(unicorn_const::HookType::MEM_READ_UNMAPPED, 1, 0, callback_mem_error).unwrap();
}

// hooks
pub fn callback(uc: &mut rudroid::Emulator<i64>, address: u64, size: u32) {
    // dump_context(uc, address, size as usize);
    println!("addr: {:x}", address);
}

pub fn callback_mem_error(uc: &mut rudroid::Emulator<i64>, memtype: unicorn_const::MemType, address: u64, size: usize, value: i64) {
    println!("callback_mem_error {:x}", address);
    dump_context(uc, address, size);
}

pub fn callback_mem_rw(uc: &mut rudroid::Emulator<i64>, memtype: unicorn_const::MemType, address: u64, size: usize, value: i64) {
    println!("callback_mem_rw {:x}", address);
    dump_context(uc, address, size);
}

pub fn dump_context(uc: &mut rudroid::Emulator<i64>, addr: u64, size: usize) {
    utilities::draw_line();

    let pc  = uc.reg_read(arm64::RegisterARM64::PC  as i32).expect("failed to read PC"); 
    let sp  = uc.reg_read(arm64::RegisterARM64::SP  as i32).expect("failed to read SP" );
    let lr  = uc.reg_read(arm64::RegisterARM64::LR  as i32).expect("failed to read LR" );
    let r0  = uc.reg_read(arm64::RegisterARM64::X0  as i32).expect("failed to read x0" );
    let r1  = uc.reg_read(arm64::RegisterARM64::X1  as i32).expect("failed to read x1" );
    let r2  = uc.reg_read(arm64::RegisterARM64::X2  as i32).expect("failed to read x2" );
    let r3  = uc.reg_read(arm64::RegisterARM64::X3  as i32).expect("failed to read x3" );
    let r4  = uc.reg_read(arm64::RegisterARM64::X4  as i32).expect("failed to read x4" );
    let r5  = uc.reg_read(arm64::RegisterARM64::X5  as i32).expect("failed to read x5" );
    let r6  = uc.reg_read(arm64::RegisterARM64::X6  as i32).expect("failed to read x6" );
    let r7  = uc.reg_read(arm64::RegisterARM64::X7  as i32).expect("failed to read x7" );
    let r8  = uc.reg_read(arm64::RegisterARM64::X8  as i32).expect("failed to read x8" );
    let r9  = uc.reg_read(arm64::RegisterARM64::X9  as i32).expect("failed to read x9" );
    let r10 = uc.reg_read(arm64::RegisterARM64::X10 as i32).expect("failed to read x10");
    let r11 = uc.reg_read(arm64::RegisterARM64::X11 as i32).expect("failed to read x11");
    let r12 = uc.reg_read(arm64::RegisterARM64::X12 as i32).expect("failed to read x12");
    let r13 = uc.reg_read(arm64::RegisterARM64::X13 as i32).expect("failed to read x13");
    let r14 = uc.reg_read(arm64::RegisterARM64::X14 as i32).expect("failed to read x14");
    let r15 = uc.reg_read(arm64::RegisterARM64::X15 as i32).expect("failed to read x15");
    let r18 = uc.reg_read(arm64::RegisterARM64::X18 as i32).expect("failed to read x18");
    let r19 = uc.reg_read(arm64::RegisterARM64::X19 as i32).expect("failed to read x19");
    let r20 = uc.reg_read(arm64::RegisterARM64::X20 as i32).expect("failed to read x20");
    let r21 = uc.reg_read(arm64::RegisterARM64::X21 as i32).expect("failed to read x21");
    let r22 = uc.reg_read(arm64::RegisterARM64::X22 as i32).expect("failed to read x22");
    let r23 = uc.reg_read(arm64::RegisterARM64::X23 as i32).expect("failed to read x23");
    let r24 = uc.reg_read(arm64::RegisterARM64::X24 as i32).expect("failed to read x24");
    let r25 = uc.reg_read(arm64::RegisterARM64::X25 as i32).expect("failed to read x25");
    let r26 = uc.reg_read(arm64::RegisterARM64::X26 as i32).expect("failed to read x26");
    let r27 = uc.reg_read(arm64::RegisterARM64::X27 as i32).expect("failed to read x27");
    let r28 = uc.reg_read(arm64::RegisterARM64::X28 as i32).expect("failed to read x28");
    
    let cpacr_el1 = uc.reg_read(arm64::RegisterARM64::CPACR_EL1 as i32).expect("failed to read CPACR_EL1"); 
    utilities::draw_line();

    println!("$x0 : {:#016x}   $x1 : {:#016x}    $x2: {:#016x}    $x3: {:#016x}", r0, r1, r2, r3);
    println!("$x4 : {:#016x}   $x5 : {:#016x}    $x6: {:#016x}    $x7: {:#016x}", r4, r5, r6, r7);
    println!("$x8 : {:#016x}   $x9 : {:#016x}   $x10: {:#016x}   $x11: {:#016x}", r8, r9, r10, r11);
    println!("$x12: {:#016x}   $x13: {:#016x}   $x14: {:#016x}   $x15: {:#016x}", r12, r13, r14, r15);
    println!("$x18: {:#016x}   $x19: {:#016x}   $x20: {:#016x}   $x21: {:#016x}", r18, r19, r20, r21);
    println!("$x22: {:#016x}   $x23: {:#016x}   $x24: {:#016x}   $x25: {:#016x}", r22, r23, r24, r25);
    println!("$x26: {:#016x}   $x27: {:#016x}   $x28: {:#016x}   ", r26, r27, r28);
    println!("$sp : {:#016x}   $lr : {:#016x}    $pc: {:#016x}", sp, lr, pc);
    println!("$cpacr_el1: {:#016x} \n", cpacr_el1);

    let mut buf = vec![0; size];
    if pc != 0 {
        uc.mem_read(pc, &mut buf).expect("failed to read opcode from memory");
        let cs_arm: Capstone = Capstone::new()
            .arm64()
            .mode(arch::arm64::ArchMode::Arm)
            .detail(true)
            .build().expect("failed to create capstone for ARM");

        let ins = cs_arm.disasm_all(&buf, size as u64).unwrap();
        println!("$pc: {:#016x}", pc);
        println!("{}", ins);
    }

    // let stack = uc.mem_read_as_vec(sp, 0x60).unwrap();
    // utilities::context_title(Some("STACK"));
    // print!("{}",utilities::pretty_hex(&stack, sp));
    
    utilities::draw_line();
}

```

`code/src/core/loaders/elfLoader.rs`:

```rs
use crate::core as linux;
use crate::utilities;
use xmas_elf::{header, ElfFile, program};
use super::super::rudroid::Emulator;
use super::super::unicorn::unicorn_const::Protection;
use super::super::unicorn::arch::arm64::RegisterARM64;


/* Symbolic values for the entries in the auxiliary table
   put on the initial stack */
#[repr(u64)]
enum AUX {
    AT_NULL = 0,
    AT_IGNORE = 1,
    AT_EXECFD = 2,
    AT_PHDR = 3,
    AT_PHENT = 4,
    AT_PHNUM = 5,
    AT_PAGESZ = 6,
    AT_BASE = 7,
    AT_FLAGS = 8,
    AT_ENTRY = 9,
    AT_NOTELF = 10,
    AT_UID = 11,
    AT_EUID = 12,
    AT_GID = 13,
    AT_EGID = 14,
    AT_PLATFORM = 15,
    AT_HWCAP = 16,
    AT_CLKTCK = 17,
    AT_SECURE = 23,
    AT_BASE_PLATFORM = 24,
    AT_RANDOM = 25,
    AT_HWCAP2 = 26,
    AT_EXECFN = 31,
}

use std::io::prelude::*;

impl<D> Emulator<D> {

    pub fn load(& mut self, elf: &mut ElfFile) {
        self.enable_vfp();
        
        let profile = match self.machine {
            header::Machine::AArch64 => {
                (linux::OS64::stack_address, linux::OS64::stack_size)
            },
            _ => {
                    panic!("[load_with_ld] Not implemented yet!")
            }
        };

        let mut stack_address = profile.0 as u64;
        let stack_size      = profile.1 as usize;
        
        self.mmu_map(stack_address, stack_size, Protection::READ|Protection::WRITE, "[stack]", self.null_mut());
        self.load_with_ld(stack_address.checked_add(stack_size as u64).unwrap() , 0, self.machine, elf);
        stack_address = self.new_stack;
        self.reg_write(RegisterARM64::SP as i32, stack_address).unwrap();
    }

    fn load_with_ld(&mut self, stack_address: u64, load_address: u64, archbit: header::Machine, elf: &mut ElfFile) {
        let mut load_address = match load_address {
            0 => {
                match  archbit {
                    header::Machine::AArch64 => {
                        self.mmap_address = linux::OS64::mmap_address as u64;
                        linux::OS64::load_address as u64
                    },
                    _ => {
                        panic!("Shouldn't be here");
                    }
                }
            },
            _ => {
                panic!("Shouldn't be here");
            }
        };
        
        let mut mem_start   : u64 = 0xffff_ffff;
        let mut mem_end     : u64 = 0xffff_ffff;
        let mut mem_s       : u64 = 0;
        let mut mem_e       : u64 = 0;

        let mut interp_path : String = String::new();

        match elf.header.pt2.type_().as_type() {
            header::Type::Executable => {
                load_address = 0;
            },
            header::Type::SharedObject => {
                
            }
            _ => {
                panic!("Some error in head e_type: {:?}", header::Type::SharedObject);
            }
        }

        for header in elf.program_iter() {
            match header.get_type().unwrap() {

                program::Type::Interp => {
                    let offset      = header.offset() as usize;
                    let end_offset  = (header.offset()+header.mem_size()) as usize;
                    let data = elf.input.get(offset..end_offset).unwrap();
                    interp_path = self.null_str(std::str::from_utf8(data).unwrap());
                },

                program::Type::Load => {
                    if mem_start > header.virtual_addr() || mem_start == 0xffff_ffff {
                        mem_start = header.virtual_addr();
                    };

                    if mem_end < header.virtual_addr()+header.mem_size() || mem_end == 0xffff_ffff {
                        mem_end = header.virtual_addr()+header.mem_size();
                    }
                },
                _ => {

                }
            }
        }

        mem_start = self.uc_align_down(mem_start);
        mem_end   = self.uc_align_up(mem_end);

        for header in elf.program_iter() {
            match header.get_type().unwrap() {
                program::Type::Load => {
                    mem_s = self.uc_align_down(load_address + header.virtual_addr());
                    mem_e = self.uc_align_up(load_address + header.virtual_addr() + header.file_size());
                    let perms =  utilities::to_uc_permissions(header.flags());

                    let desc = self.elf_path.clone();
                    self.mmu_map(mem_s, (mem_e-mem_s) as usize, perms, &desc, self.null_mut());
                    
                    let data = elf.input.get(header.offset() as usize..
                                                                (header.offset()+header.file_size()) as usize).unwrap();

                    self.write(load_address+header.virtual_addr(), data);
                },
                _ => {

                }
            }
        }
        
        let loaded_mem_end = load_address + mem_end;

        if loaded_mem_end > mem_e {
            let desc = self.elf_path.clone();
            self.mmu_map( mem_e, (loaded_mem_end-mem_e) as usize, Protection::ALL, &desc, self.null_mut());
        }

        self.elf_entry = elf.header.pt2.entry_point() + load_address;
        self.debug_print(format!("elf_entry {:x}", self.elf_entry));

        self.brk_address = mem_end + load_address + 0x2000; //not sure why?? seems to be used in ql_syscall_brk

        // load interpreter if there is an interpreter
        if !interp_path.is_empty() {
            self.debug_print(format!("Trying to load interpreter: {}{}", self.rootfs, interp_path));

            let mut interp_full_path = String::new();

            interp_full_path.push_str(&self.rootfs);
            interp_full_path.push_str(&interp_path);

            let interp_data = std::fs::read(&interp_full_path).unwrap();
            let interp_elf  = ElfFile::new(interp_data.get(0..).unwrap()).unwrap();

            let mut interp_mem_size: u64 = 0;
            let mut interp_address : u64 = 0;

            for i_header in interp_elf.program_iter() {
                match i_header.get_type().unwrap() {
                    program::Type::Load => {
                        if interp_mem_size < i_header.virtual_addr() + i_header.mem_size() || interp_mem_size == 0 {
                            interp_mem_size = i_header.virtual_addr() + i_header.mem_size();
                        }
                    },
                    _ => {

                    }
                };
            }

            interp_mem_size = self.uc_align_up(interp_mem_size);

            match archbit {
                header::Machine::AArch64 => {
                    interp_address = linux::OS64::interp_address as u64;
                }
                _ => {
                    panic!("what?");
                }
            };

            self.mmu_map(interp_address, interp_mem_size as usize , Protection::ALL, &interp_path, self.null_mut());

            for i_header in interp_elf.program_iter() { 
                match i_header.get_type().unwrap() {
                    program::Type::Load => {
                        let data = interp_elf.input.get(i_header.offset()  as usize..
                                                                            (i_header.offset()+i_header.file_size()) as usize
                                                                                    ).unwrap();
                        self.write( interp_address+i_header.physical_addr(), data);
                    },
                    _ => {

                    }
                };
            }

            self.interp_address = interp_address;
            self.entry_point    = interp_elf.header.pt2.entry_point() + self.interp_address;
        }

        // setup elf table
        let mut elf_table: Vec<u8> = Vec::new();

        let mut new_stack = stack_address;

        // copy arg0 on to stack. elf_path
        new_stack = self.copy_str(new_stack, &mut self.elf_path.clone());

        elf_table.extend_from_slice(&self.pack(self.args.len() as u64 + 1)); // + 1 is for arg0 = elf path.
        elf_table.extend_from_slice(&self.pack(new_stack));
        
        let mut argc = self.args.len();

        loop {
            if argc <=0 {
                break;
            }
            argc -= 1;

            let mut arg = self.args[argc].clone();
            new_stack = self.copy_str(new_stack, &mut arg);
            elf_table.extend_from_slice(&self.pack(new_stack));
        }

        elf_table.extend_from_slice(&self.pack(0));
        
        let mut envc = self.env.len();
        loop {
            if envc <=0 {
                break;
            }
            envc -= 1;
            let mut env = self.env[envc].clone();
            new_stack = self.copy_str(new_stack, &mut env);
            elf_table.extend_from_slice(&self.pack(new_stack));
        }

        elf_table.extend_from_slice(&self.pack(0));

        new_stack = self.alignment(new_stack);

        let mut randstr   = "a".repeat(0x10);
        let mut cpustr    = String::from("aarch64");

        let mut addr1 = self.copy_str(new_stack, &mut randstr);
        new_stack = addr1;

        let mut addr2 = self.copy_str(new_stack, &mut cpustr);
        new_stack = addr2;

        new_stack = self.alignment(new_stack);

        // Set AUX
        let head = elf.header;
        
        let elf_phdr    = load_address + head.pt2.ph_offset();
        let elf_phent   = head.pt2.ph_entry_size();
        let elf_phnum   = head.pt2.ph_count();
        let elf_pagesz  = 0x1000;
        let elf_guid    = linux::uid;
        let elf_flags   = 0;
        let elf_entry   = load_address + head.pt2.entry_point();
        let randstraddr = addr1; 
        let cpustraddr  = addr2;

        let elf_hwcap: u64 = match head.pt2.machine().as_machine() {
            header::Machine::AArch64 => {
                0x078bfbfd
            },
            _ => {
                panic!("");
            }
        };
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHDR  as u64, elf_phdr + mem_start));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHENT as u64, elf_phent as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PHNUM as u64, elf_phnum as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PAGESZ as u64, elf_pagesz as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_BASE as u64, self.interp_address));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_FLAGS as u64, elf_flags));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_ENTRY as u64, elf_entry));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_UID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_EUID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_GID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_EGID as u64, elf_guid as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_HWCAP as u64, elf_hwcap as u64));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_CLKTCK as u64, 100));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_RANDOM as u64, randstraddr));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_PLATFORM as u64, cpustraddr));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_SECURE as u64, 0));
        elf_table.extend_from_slice(&self.new_aux_ent(AUX::AT_NULL as u64, 0));


        let len = 0x10 - ((new_stack - elf_table.len() as u64) & 0xf) as usize;
        let padding = std::iter::repeat('0').take(len).collect::<String>();

        elf_table.extend_from_slice(padding.as_bytes());
        
        let addr = new_stack - elf_table.len() as u64;
        self.write( addr, &elf_table);

        new_stack = new_stack - elf_table.len() as u64;

        self.new_stack = new_stack;
        self.load_address = load_address;
    }

    fn new_aux_ent(&self, key: u64, val: u64) -> Vec<u8> {
        let mut aux: Vec<u8> = Vec::new();
        aux.extend_from_slice(&self.pack(key));
        aux.extend_from_slice(&self.pack(val));
        aux
    }

    pub fn run_linker(&mut self) {
        utilities::context_title(Some("Emulating linker64"));
        let res = self.emu_start(self.entry_point, self.elf_entry, 0, 0);
        self.handle_emu_exception(res);
        utilities::context_title(Some("Emulating linker64 done"));
        // self.display_mapped();
    }
}
```

`code/src/core/loaders/elfRunner.rs`:

```rs
use super::super::unicorn::ffi;
use super::super::rudroid;
use super::super::unicorn::unicorn_const;
use super::super::unicorn::unicorn_const::*;
use crate::utilities;
use capstone::prelude::*;
use keystone::keystone_const;
use keystone::{Keystone, Arch as kArch};
use super::super::unicorn::arch::arm64::RegisterARM64;

use capstone::prelude::*;

impl<D> rudroid::Emulator<D> {
    pub fn run_elf(&mut self) {
        utilities::context_title(Some("Emulating elf"));
        let res = self.emu_start(self.elf_entry, 0, 0, 0);
        self.handle_emu_exception(res);
        utilities::context_title(Some("Emulating elf done."));
    }

    pub fn fuzz_init(&mut self) -> u64 {
        let emu_addr = self.uc_align_up(0x14141414141);
        self.mem_map(emu_addr, 0x1000, Protection::ALL).expect("Code Emulation");
    
        let code = "stp fp, lr, [sp, #-16]!\nmov fp, sp\nmov fp, sp\nblr x12\nldp fp, lr, [sp], #16\nret lr";
        let ks_arm: Keystone = Keystone::new(kArch::ARM64, keystone_const::MODE_LITTLE_ENDIAN).expect("Could not initialize Keystone engine");;
        let result = ks_arm.asm(code.to_string(), 0).expect("Could not asemble");
        self.mem_write(emu_addr, &result.bytes);
        emu_addr
    }

    pub fn call_me(&mut self, func_addr: u64, emu_addr: u64) {
        //assumes arguments are already set
        self.reg_write(RegisterARM64::X12 as i32, func_addr); // function to emulate
        self.reg_write(RegisterARM64::LR as i32, 0);   //should return on 0

        let res = self.emu_start(emu_addr, 0x14141415014, 0, 0);
        self.handle_emu_exception(res);
    }

    pub fn handle_emu_exception(&mut self, err: Result<(), unicorn_const::uc_error>) {
        // self.get_mapped();

        match err.ok() {
            Some(v) => {

            },
            None => {
                self.display_mapped();
                self.dump_context();

                match err.err().unwrap() {
                    unicorn_const::uc_error::FETCH_UNMAPPED => {
                        panic!("- [handle_emu_exception] unicorn::unicorn_const::uc_error::FETCH_UNMAPPED");
                    },
                    _ => {
                        panic!("- [handle_emu_exception] {:?}", err);
                    }
                }
            }
        }
    }

    pub fn dump_context(&mut self) {
        utilities::draw_line();
    
        let pc  = self.reg_read(RegisterARM64::PC  as i32).expect("failed to read r11"); 
        let sp  = self.reg_read(RegisterARM64::SP  as i32).expect("failed to read SP" );
        let lr  = self.reg_read(RegisterARM64::LR  as i32).expect("failed to read LR" );
        let r0  = self.reg_read(RegisterARM64::X0  as i32).expect("failed to read r0" );
        let r1  = self.reg_read(RegisterARM64::X1  as i32).expect("failed to read r1" );
        let r2  = self.reg_read(RegisterARM64::X2  as i32).expect("failed to read r2" );
        let r3  = self.reg_read(RegisterARM64::X3  as i32).expect("failed to read r3" );
        let r4  = self.reg_read(RegisterARM64::X4  as i32).expect("failed to read r4" );
        let r5  = self.reg_read(RegisterARM64::X5  as i32).expect("failed to read r5" );
        let r6  = self.reg_read(RegisterARM64::X6  as i32).expect("failed to read r6" );
        let r7  = self.reg_read(RegisterARM64::X7  as i32).expect("failed to read r7" );
        let r8  = self.reg_read(RegisterARM64::X8  as i32).expect("failed to read r8" );
        let r9  = self.reg_read(RegisterARM64::X9  as i32).expect("failed to read r9" );
        let r10 = self.reg_read(RegisterARM64::X10 as i32).expect("failed to read r10");
        let r11 = self.reg_read(RegisterARM64::X11 as i32).expect("failed to read r11");
        let r12 = self.reg_read(RegisterARM64::X12 as i32).expect("failed to read r11");
        let r13 = self.reg_read(RegisterARM64::X13 as i32).expect("failed to read r11");
        let r14 = self.reg_read(RegisterARM64::X14 as i32).expect("failed to read r11");
        let r15 = self.reg_read(RegisterARM64::X15 as i32).expect("failed to read r11");
        let r18 = self.reg_read(RegisterARM64::X18 as i32).expect("failed to read r11");
        let r19 = self.reg_read(RegisterARM64::X19 as i32).expect("failed to read r11");
        let r20 = self.reg_read(RegisterARM64::X20 as i32).expect("failed to read r11");
        let r21 = self.reg_read(RegisterARM64::X21 as i32).expect("failed to read r11");
        let r22 = self.reg_read(RegisterARM64::X22 as i32).expect("failed to read r11");
        let r23 = self.reg_read(RegisterARM64::X23 as i32).expect("failed to read r11");
        let r24 = self.reg_read(RegisterARM64::X24 as i32).expect("failed to read r11");
        let r25 = self.reg_read(RegisterARM64::X25 as i32).expect("failed to read r11");
        let r26 = self.reg_read(RegisterARM64::X26 as i32).expect("failed to read r11");
        let r27 = self.reg_read(RegisterARM64::X27 as i32).expect("failed to read r11");
        let r28 = self.reg_read(RegisterARM64::X28 as i32).expect("failed to read r11");
        
        let cpacr_el1 = self.reg_read(RegisterARM64::CPACR_EL1 as i32).expect("failed to read r11"); 
        utilities::draw_line();
    
        println!("$r0 : {:#016x}   $r1 : {:#016x}    $r2: {:#016x}    $r3: {:#016x}", r0, r1, r2, r3);
        println!("$r4 : {:#016x}   $r5 : {:#016x}    $r6: {:#016x}    $r7: {:#016x}", r4, r5, r6, r7);
        println!("$r8 : {:#016x}   $r9 : {:#016x}   $r10: {:#016x}   $r11: {:#016x}", r8, r9, r10, r11);
        println!("$r12: {:#016x}   $r13: {:#016x}   $r14: {:#016x}   $r15: {:#016x}", r12, r13, r14, r15);
        println!("$r18: {:#016x}   $r19: {:#016x}   $r20: {:#016x}   $r21: {:#016x}", r18, r19, r20, r21);
        println!("$r22: {:#016x}   $r23: {:#016x}   $r24: {:#016x}   $r25: {:#016x}", r22, r23, r24, r25);
        println!("$r26: {:#016x}   $r27: {:#016x}   $r28: {:#016x}   ", r26, r27, r28);
        println!("$sp : {:#016x}   $lr : {:#016x}    $pc: {:#016x}", sp, lr, pc);
        println!("$cpacr_el1: {:#016x} \n", cpacr_el1);
        
        utilities::draw_line();
    }

}

```

`code/src/core/loaders/mod.rs`:

```rs
pub mod elfLoader;
pub mod elfRunner;
```

`code/src/core/mmu.rs`:

```rs
use libc::c_void;
use xmas_elf::header;
use std::collections::HashMap;

use super::rudroid::Emulator;
use super::unicorn::unicorn_const::Protection;
use super::unicorn::arch::arm64::RegisterARM64;
use byteorder::{ByteOrder, BigEndian, LittleEndian};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
pub struct MapInfo {
    pub memory_start    : u64,
    pub memory_end      : u64,
    pub memory_perms    : Protection,
    pub description     : String,
}

impl Clone for MapInfo {
    fn clone(&self) -> Self {
        MapInfo {
            memory_start    : self.memory_start,
            memory_end      : self.memory_end,
            memory_perms    : self.memory_perms,
            description     : self.description.clone(),
        }
    }    
}

impl std::fmt::Display for MapInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "memory_start {:x} memory_end {:x} memory_perms : {}  description: {}", self.memory_start, self.memory_end, self.memory_perms, self.description).unwrap();
        Ok(())
    }
}

impl<D> Emulator<D> {
    pub fn mmu_map(&mut self, address: u64, size: usize, perms: Protection, description: &str, host_ptr: *mut c_void) -> bool {

        if self.is_mapped(address, size as u64) {
            return true;
        }

        if host_ptr.is_null() {
            // let _ = self.mem_map(address, size, perms).expect("mmu_map failed!");
            let _ = self.mem_map(address, size, perms).unwrap();
        }
        else {
            // Map an existing memory region in the emulator at the specified address.
            //
            // This function is marked unsafe because it is the responsibility of the caller to
            // ensure that `size` matches the size of the passed buffer, an invalid `size` value will
            // likely cause a crash in unicorn.
            //
            // `address` must be aligned to 4kb or this will return `Error::ARG`.
            //
            // `size` must be a multiple of 4kb or this will return `Error::ARG`.
            //
            // `ptr` is a pointer to the provided memory region that will be used by the emulator.                
            let _ = unsafe { self.mem_map_ptr(address, size, perms, host_ptr).expect("mem_map_ptr failed !"); };
        }

        let desc = match description.len() {
            0 => {
                String::from("[mapped]")
            },
            _ => {
                String::from(description)
            }
        };

        let map_info = MapInfo {
            memory_start    : address,
            memory_end      : address.checked_add(size as u64).unwrap(),
            memory_perms    : perms,
            description     : desc,
        };

        self.add_mapinfo(map_info);        

        true
    }

    pub fn add_mapinfo(&mut self, map_info: MapInfo) {
        // self.map_infos.push(map_info);
        self.map_infos.insert(map_info.memory_start, map_info);
    }

    pub fn mmu_unmap(&mut self, address: u64, size: usize) {
        let removed = self.map_infos.remove_entry(&address);
        self.mem_unmap(address, size);
    }

    pub fn is_mapped(&mut self, address: u64, size: u64) -> bool {
        let regions = self.mem_regions().unwrap();
        if regions.len() <= 1 {
            return false;
        } 

        for region in self.mem_regions() {
            let val = (region[0].begin >= address) & ((address + size - 1) <= region[1].begin);
            match val {
                true => {
                    return true;
                },
                _ => {
                    
                }
            }
        };

        false
    }    

    pub fn mmu_mem_set(&mut self, addr: u64, value: char, size: usize) {
        let data = vec![value; size].iter().map(|c| *c as u8).collect::<Vec<_>>();
        self.mem_write(addr, &data).expect("mmu_mem_set failed");
    }

    pub fn get_mapped(&self, address: u64, len: u64) -> Option<&MapInfo> {
        for (addr, map_info) in self.map_infos.iter() {
            if address > *addr && address + len < map_info.memory_end {
                return Some(&map_info);
            }
        }
        None
    }

    pub fn update_mapped_perms(&mut self, address: u64, len: u64, perms: Protection) -> Option<&MapInfo> {
        for (addr, map_info) in self.map_infos.iter_mut() {
            if address > *addr && address + len < map_info.memory_end {
                // return Some(&map_info);
                map_info.memory_perms = perms;
            }
        }
        None
    }

    pub fn get_mapped_with_desc(&self, desc: String) -> HashMap<u64, MapInfo> {
        let mut mappings: HashMap<u64, MapInfo> = HashMap::new();

        for (addr, map_info) in self.map_infos.iter() {
            if map_info.description == desc  {
                mappings.insert(*addr, map_info.clone());
            }
        }

        mappings
    }

    pub fn display_mapped(&self) {
        let mut v: Vec<_> = Vec::new();
        for (addr, map_info) in self.map_infos.iter() {
            v.push((addr, map_info));
        }
        v.sort_by(|x,y| x.0.cmp(&y.0));
        
        for (addr, map_info) in v {
            println!("{}", map_info);
        }
    }

    pub fn read(&self, address: u64, size: usize) -> Vec<u8> {
        self.mem_read_as_vec(address, size).unwrap()
    }

    pub fn write(&mut self, address: u64, data: &[u8]) {
        self.mem_write(address, data).expect("mmu.write");
    }

    pub fn copy_str(&mut self, address: u64, string: &mut str) -> u64 {
        let data = string.as_bytes();
        let address: u64 = ((address as usize)  - data.len() - 1) as u64;
        self.write(address, data);
        address
    }

    fn stack_push(&mut self, value: u64) {
        let mut sp = self.read_sp();
        sp = sp-8;
        self.write_sp(sp);

        self.write(sp, &self.pack_64(value));
    }

    fn stack_pop(&mut self) -> u64 {
        let mut sp = self.read_sp();
        sp = sp-8;
        self.write_sp(sp);

        let data = self.read(sp, 8);
        self.unpack_64(&data)
    }

    fn stack_read(&mut self, offset: u32) -> u64 {
        let mut sp = self.read_sp();
        let data = self.read(sp+ offset as u64, 8);
        self.unpack_64(&data)
    }

    fn stack_write(&mut self, offset: usize, data: &[u8]) {
        let mut sp = self.read_sp() + offset as u64;
        self.write(sp, data);
    }

    fn read_sp(&mut self) -> u64 {
        self.reg_read(RegisterARM64::SP as i32).unwrap()
    }

    fn write_sp(&mut self, value: u64) {
        self.reg_write(RegisterARM64::SP as i32, value);
    }

    fn read_pc(&mut self) -> u64 {
        self.reg_read(RegisterARM64::PC as i32).unwrap()
    }

    fn write_pc(&mut self, value: u64) {
        self.reg_write(RegisterARM64::PC as i32, value);
    }

    // unsigned pack
    pub fn pack(&self, value: u64) -> Vec<u8> { 
        match self.machine {
            header::Machine::AArch64 => {
                self.pack_64(value)
            },
            _ => {
                panic!("");
            }
        }
    }

    // unsigned unpack
    pub fn unpack(&self, value: &[u8]) -> u64 { 
        match self.machine {
            header::Machine::AArch64 => {
                if value.len() == 8 {
                    self.unpack_64(value)
                }
                else if (value.len() == 4) {
                    return self.unpack_32(value) as u64;
                }
                else {
                    panic!("need 4 or 8 byte");
                }   
            },
            _ => {
                panic!("");
            }
        }
    }

    pub fn pack_64(&self, value: u64) -> Vec<u8> {
        match self.endian {
            header::Data::BigEndian  => {
                value.to_be_bytes().to_vec()
            },
            header::Data::LittleEndian => {
                value.to_le_bytes().to_vec()
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }
    
    pub fn pack_64s(&self, value: i64, buf: &mut [u8]) {
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::write_i64(buf, value)
            },
            header::Data::LittleEndian => {
                // LittleEndian::write_i64(buf, value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        };
    }
    
    pub fn unpack_64(&self, value: &[u8]) -> u64 {
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::read_u64(value)
            },
            header::Data::LittleEndian => {
                LittleEndian::read_u64(value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }
    
    pub fn unpack_64s(&self, value: &[u8]) -> i64 {
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::read_i64(value)
            },
            header::Data::LittleEndian => {
                LittleEndian::read_i64(value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }
    
    pub fn pack_32(&self, value: u32) -> Vec<u8> {        
        match self.endian {
            header::Data::BigEndian  => {
                value.to_be_bytes().to_vec()
            },
            header::Data::LittleEndian => {
                value.to_le_bytes().to_vec()
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }
    
    pub fn pack_32s(&self, value: i32, buf: &mut [u8]) {
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::write_i32(buf, value)
            },
            header::Data::LittleEndian => {
                LittleEndian::write_i32(buf, value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        };
    }

    pub fn unpack_32(&self, value: &[u8]) -> u32 {        
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::read_u32(value)
            },
            header::Data::LittleEndian => {
                LittleEndian::read_u32(value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }
    
    pub fn unpack_32s(&self, value: &[u8]) -> i32 {
        match self.endian {
            header::Data::BigEndian  => {
                BigEndian::read_i32(value)
            },
            header::Data::LittleEndian => {
                LittleEndian::read_i32(value)
            },
            _ => {
                panic!("what kiinda endian is this")
            }
        }
    }

    pub fn get_pointer_at(&mut self, addr: u64) -> u64 {
        match self.machine {
            header::Machine::AArch64 => {
                let mem = self.mem_read_as_vec(addr, 8).unwrap();
                self.unpack(&mem)
            },
            _ => {
                panic!("get_pointer_at 0x{:x} failed", addr);
            }
        }
    }
}
```

`code/src/core/mod.rs`:

```rs
pub mod mmu;
pub mod hooks;
pub mod android;
pub mod loaders;
pub mod rudroid;
pub mod unicorn;


const ram_size      : u64 = 0xa00000;
const entry_point   : u64 = 0x1000000;

#[repr(u64)]
pub enum OS64 {
    stack_address       = 0x4ffffffde000,
    stack_size          = 0x30000,
    load_address        = 0x555555554000,
    interp_address      = 0x7fffb7dd5000,
    mmap_address        = 0x7ffff7dd6000,
    vsyscall_address    = 0xffffffffff600000,
    vsyscall_size       = 0x1000,
}

// [KERNEL]
pub const uid : u32 = 0;
pub const gid : u32 = 0;
```

`code/src/core/rudroid.rs`:

```rs

use xmas_elf::header;
use xmas_elf::ElfFile;
use std::collections::HashMap;

use super::mmu;
use super::android::fs;
use super::unicorn::ffi;

use super::unicorn::unicorn_const::{Arch, Mode, uc_error};

// #[derive(Debug)]
pub struct Emulator<D>  {
    pub debug               : bool,

    pub rootfs              : String,
    pub elf_path            : String,

    pub machine             : header::Machine,
    pub endian              : header::Data,
    pub arch                : Arch,

    pub uc                  : ffi::uc_handle,
    pub uc_type             : D,

    pub filesystem          : fs::FsScheme,

    // mmu stuff
    pub load_address        : u64,
    pub mmap_address        : u64,
    pub new_stack           : u64,
    pub interp_address      : u64,
    pub entry_point         : u64,
    pub elf_entry           : u64,
    pub brk_address         : u64,

    //elf arguments
    pub args                : Vec<String>,
    pub env                 : Vec<String>,

    pub map_infos           : HashMap<u64, mmu::MapInfo>,

    //hook
    pub code_hooks          : HashMap<*mut libc::c_void, Box<ffi::CodeHook<D>>>,
    pub mem_hooks           : HashMap<*mut libc::c_void, Box<ffi::MemHook<D>>>,
    pub intr_hooks          : HashMap<*mut libc::c_void, Box<ffi::InterruptHook<D>>>,
    pub insn_in_hooks       : HashMap<*mut libc::c_void, Box<ffi::InstructionInHook<D>>>,
    pub insn_out_hooks      : HashMap<*mut libc::c_void, Box<ffi::InstructionOutHook<D>>>,
    pub insn_sys_hooks      : HashMap<*mut libc::c_void, Box<ffi::InstructionSysHook<D>>>,

    // syscalls stuff
    pub sigmap              : HashMap<u64, Vec<u8>>,

    _pin                    : std::marker::PhantomPinned,
}


impl<D> Emulator<D>
{
    pub fn new(elf_path: &str, rootfs: &str, elf: &mut ElfFile, endian: header::Data, args: Vec<String>, env: Vec<String>, data: D, debug: bool) -> Result<Emulator<D>, uc_error> {
        let mut machine = elf.header.pt2.machine().as_machine();
        let (arch, mode) = match machine {
            header::Machine::AArch64 => {
                (Arch::ARM64, Mode::LITTLE_ENDIAN)
            },
            _ => {
                panic!("Not implemented yet!")
            }
        };

        let mut handle = std::ptr::null_mut();
        let err = unsafe { ffi::uc_open(arch, mode, &mut handle) };
        let mut emu = Emulator {
            debug           : debug,
            rootfs          : String::from(rootfs),

            elf_path        : String::from(elf_path),
            args            : args,
            env             : env,
            
            uc              : handle,
            uc_type         : data,
            
            arch            : arch,
            machine         : machine,
            endian          : endian,

            map_infos       : HashMap::new(),
            entry_point     : 0,
            elf_entry       : 0,
            brk_address     : 0,
            mmap_address    : 0,
            interp_address  : 0,
            new_stack       : 0,
            load_address    : 0,

            //hooks
            code_hooks      : HashMap::new(),
            mem_hooks       : HashMap::new(),
            intr_hooks      : HashMap::new(),
            insn_in_hooks   : HashMap::new(),
            insn_out_hooks  : HashMap::new(),
            insn_sys_hooks  : HashMap::new(),

            _pin            : std::marker::PhantomPinned,

            filesystem      : fs::FsScheme::new(String::from(rootfs)),
            sigmap          : HashMap::new(),
        };
        
        emu.load(elf);
        emu.display_mapped();

        if err == uc_error::OK {
            Ok(emu)
        } else {
            Err(err)
        }
    }
}
```

`code/src/core/unicorn/arch/arm64.rs`:

```rs
// ARM64 registers
#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum RegisterARM64 {
    INVALID = 0,
    FP = 1,
    LR = 2,
    NZCV = 3,
    SP = 4,
    WSP = 5,
    WZR = 6,
    XZR = 7,
    B0 = 8,
    B1 = 9,
    B2 = 10,
    B3 = 11,
    B4 = 12,
    B5 = 13,
    B6 = 14,
    B7 = 15,
    B8 = 16,
    B9 = 17,
    B10 = 18,
    B11 = 19,
    B12 = 20,
    B13 = 21,
    B14 = 22,
    B15 = 23,
    B16 = 24,
    B17 = 25,
    B18 = 26,
    B19 = 27,
    B20 = 28,
    B21 = 29,
    B22 = 30,
    B23 = 31,
    B24 = 32,
    B25 = 33,
    B26 = 34,
    B27 = 35,
    B28 = 36,
    B29 = 37,
    B30 = 38,
    B31 = 39,
    D0 = 40,
    D1 = 41,
    D2 = 42,
    D3 = 43,
    D4 = 44,
    D5 = 45,
    D6 = 46,
    D7 = 47,
    D8 = 48,
    D9 = 49,
    D10 = 50,
    D11 = 51,
    D12 = 52,
    D13 = 53,
    D14 = 54,
    D15 = 55,
    D16 = 56,
    D17 = 57,
    D18 = 58,
    D19 = 59,
    D20 = 60,
    D21 = 61,
    D22 = 62,
    D23 = 63,
    D24 = 64,
    D25 = 65,
    D26 = 66,
    D27 = 67,
    D28 = 68,
    D29 = 69,
    D30 = 70,
    D31 = 71,
    H0 = 72,
    H1 = 73,
    H2 = 74,
    H3 = 75,
    H4 = 76,
    H5 = 77,
    H6 = 78,
    H7 = 79,
    H8 = 80,
    H9 = 81,
    H10 = 82,
    H11 = 83,
    H12 = 84,
    H13 = 85,
    H14 = 86,
    H15 = 87,
    H16 = 88,
    H17 = 89,
    H18 = 90,
    H19 = 91,
    H20 = 92,
    H21 = 93,
    H22 = 94,
    H23 = 95,
    H24 = 96,
    H25 = 97,
    H26 = 98,
    H27 = 99,
    H28 = 100,
    H29 = 101,
    H30 = 102,
    H31 = 103,
    Q0 = 104,
    Q1 = 105,
    Q2 = 106,
    Q3 = 107,
    Q4 = 108,
    Q5 = 109,
    Q6 = 110,
    Q7 = 111,
    Q8 = 112,
    Q9 = 113,
    Q10 = 114,
    Q11 = 115,
    Q12 = 116,
    Q13 = 117,
    Q14 = 118,
    Q15 = 119,
    Q16 = 120,
    Q17 = 121,
    Q18 = 122,
    Q19 = 123,
    Q20 = 124,
    Q21 = 125,
    Q22 = 126,
    Q23 = 127,
    Q24 = 128,
    Q25 = 129,
    Q26 = 130,
    Q27 = 131,
    Q28 = 132,
    Q29 = 133,
    Q30 = 134,
    Q31 = 135,
    S0 = 136,
    S1 = 137,
    S2 = 138,
    S3 = 139,
    S4 = 140,
    S5 = 141,
    S6 = 142,
    S7 = 143,
    S8 = 144,
    S9 = 145,
    S10 = 146,
    S11 = 147,
    S12 = 148,
    S13 = 149,
    S14 = 150,
    S15 = 151,
    S16 = 152,
    S17 = 153,
    S18 = 154,
    S19 = 155,
    S20 = 156,
    S21 = 157,
    S22 = 158,
    S23 = 159,
    S24 = 160,
    S25 = 161,
    S26 = 162,
    S27 = 163,
    S28 = 164,
    S29 = 165,
    S30 = 166,
    S31 = 167,
    W0 = 168,
    W1 = 169,
    W2 = 170,
    W3 = 171,
    W4 = 172,
    W5 = 173,
    W6 = 174,
    W7 = 175,
    W8 = 176,
    W9 = 177,
    W10 = 178,
    W11 = 179,
    W12 = 180,
    W13 = 181,
    W14 = 182,
    W15 = 183,
    W16 = 184,
    W17 = 185,
    W18 = 186,
    W19 = 187,
    W20 = 188,
    W21 = 189,
    W22 = 190,
    W23 = 191,
    W24 = 192,
    W25 = 193,
    W26 = 194,
    W27 = 195,
    W28 = 196,
    W29 = 197,
    W30 = 198,
    X0 = 199,
    X1 = 200,
    X2 = 201,
    X3 = 202,
    X4 = 203,
    X5 = 204,
    X6 = 205,
    X7 = 206,
    X8 = 207,
    X9 = 208,
    X10 = 209,
    X11 = 210,
    X12 = 211,
    X13 = 212,
    X14 = 213,
    X15 = 214,
    IP1 = 215,
    IP0 = 216,
    X18 = 217,
    X19 = 218,
    X20 = 219,
    X21 = 220,
    X22 = 221,
    X23 = 222,
    X24 = 223,
    X25 = 224,
    X26 = 225,
    X27 = 226,
    X28 = 227,
    V0 = 228,
    V1 = 229,
    V2 = 230,
    V3 = 231,
    V4 = 232,
    V5 = 233,
    V6 = 234,
    V7 = 235,
    V8 = 236,
    V9 = 237,
    V10 = 238,
    V11 = 239,
    V12 = 240,
    V13 = 241,
    V14 = 242,
    V15 = 243,
    V16 = 244,
    V17 = 245,
    V18 = 246,
    V19 = 247,
    V20 = 248,
    V21 = 249,
    V22 = 250,
    V23 = 251,
    V24 = 252,
    V25 = 253,
    V26 = 254,
    V27 = 255,
    V28 = 256,
    V29 = 257,
    V30 = 258,
    V31 = 259,

    // pseudo registers
    PC = 260,
    CPACR_EL1 =  261,
}

pub const PAGE_ALIGN: u64 = 0x1000;
```

`code/src/core/unicorn/arch/mod.rs`:

```rs
pub mod arm64;
```

`code/src/core/unicorn/ffi.rs`:

```rs
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use std::fmt;
use std::ffi::c_void;
use std::pin::Pin;
use libc::{c_char, c_int};
use crate::core::rudroid;
use super::unicorn_const::*;

pub type uc_handle = *mut c_void;
pub type uc_hook = *mut c_void;
pub type uc_context = libc::size_t;

extern "C" {
    pub fn uc_version(major: *mut u32, minor: *mut u32) -> u32;
    pub fn uc_arch_supported(arch: Arch) -> bool;
    pub fn uc_open(arch: Arch, mode: Mode, engine: *mut uc_handle) -> uc_error;
    pub fn uc_close(engine: uc_handle) -> uc_error;
    pub fn uc_free(mem: uc_context) -> uc_error;
    pub fn uc_errno(engine: uc_handle) -> uc_error;
    pub fn uc_strerror(error_code: uc_error) -> *const c_char;
    pub fn uc_reg_write(engine: uc_handle, regid: c_int, value: *const c_void) -> uc_error;
    pub fn uc_reg_read(engine: uc_handle, regid: c_int, value: *mut c_void) -> uc_error;
    pub fn uc_mem_write(
        engine: uc_handle,
        address: u64,
        bytes: *const u8,
        size: libc::size_t,
    ) -> uc_error;
    pub fn uc_mem_read(
        engine: uc_handle,
        address: u64,
        bytes: *mut u8,
        size: libc::size_t,
    ) -> uc_error;
    pub fn uc_mem_map(engine: uc_handle, address: u64, size: libc::size_t, perms: u32) -> uc_error;
    pub fn uc_mem_map_ptr(
        engine: uc_handle,
        address: u64,
        size: libc::size_t,
        perms: u32,
        ptr: *mut c_void,
    ) -> uc_error;
    pub fn uc_mem_unmap(engine: uc_handle, address: u64, size: libc::size_t) -> uc_error;
    pub fn uc_mem_protect(engine: uc_handle, address: u64, size: libc::size_t, perms: u32)
        -> uc_error;
    pub fn uc_mem_regions(
        engine: uc_handle,
        regions: *const *const MemRegion,
        count: *mut u32,
    ) -> uc_error;
    pub fn uc_emu_start(
        engine: uc_handle,
        begin: u64,
        until: u64,
        timeout: u64,
        count: libc::size_t,
    ) -> uc_error;
    pub fn uc_emu_stop(engine: uc_handle) -> uc_error;
    pub fn uc_hook_add(
        engine: uc_handle,
        hook: *mut uc_hook,
        hook_type: HookType,
        callback: *mut c_void,
        user_data: *mut c_void,
        begin: u64,
        end: u64,
        ...
    ) -> uc_error;
    pub fn uc_hook_del(engine: uc_handle, hook: uc_hook) -> uc_error;
    pub fn uc_query(engine: uc_handle, query_type: Query, result: *mut libc::size_t) -> uc_error;
    pub fn uc_context_alloc(engine: uc_handle, context: *mut uc_context) -> uc_error;
    pub fn uc_context_save(engine: uc_handle, context: uc_context) -> uc_error;
    pub fn uc_context_restore(engine: uc_handle, context: uc_context) -> uc_error;
}

pub struct CodeHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>, u64, u32)>
}

pub struct MemHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>, MemType, u64, usize, i64)>
}

pub struct InterruptHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>, u32)>
}

pub struct InstructionInHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>, u32, usize)>
}

pub struct InstructionOutHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>, u32, usize, u32)>
}

pub struct InstructionSysHook<D> {
    pub unicorn: *mut rudroid::Emulator<D>,
    pub callback: Box<dyn FnMut(&mut rudroid::Emulator<D>)>
}


pub extern "C" fn code_hook_proxy<D>(uc: uc_handle, address: u64, size: u32, user_data: *mut CodeHook<D>) {
    let mut unicorn = unsafe { &mut *(*user_data).unicorn };
    let callback = &mut unsafe { &mut *(*user_data).callback };
    assert_eq!(uc, unicorn.uc);
    callback(&mut unicorn , address, size);
}

pub extern "C" fn mem_hook_proxy<D>(uc: uc_handle, 
        mem_type: MemType, 
        address: u64, 
        size: u32, 
        value: i64, 
        user_data: *mut MemHook<D>) 
{
    let mut unicorn = unsafe { &mut *(*user_data).unicorn };
    let callback = &mut unsafe { &mut *(*user_data).callback };
    assert_eq!(uc, unicorn.uc);
    callback(&mut unicorn , mem_type, address, size as usize, value);
}

pub extern "C" fn intr_hook_proxy<D>(uc: uc_handle, value: u32, user_data: *mut InterruptHook<D>) {
    let mut unicorn = unsafe { &mut *(*user_data).unicorn };
    let callback = &mut unsafe { &mut *(*user_data).callback };
    assert_eq!(uc, unicorn.uc);
    callback(&mut unicorn , value);
}
```

`code/src/core/unicorn/mod.rs`:

```rs
pub mod arch;
pub mod ffi;
pub mod unicorn_const;

use libc::c_void;
use xmas_elf::header;

use crate::utilities;
use super::rudroid::Emulator;
use arch::arm64;
use unicorn_const::{Arch, uc_error, MemRegion, Protection, HookType, MemType, Query};

#[derive(Debug)]
pub struct Context {
    context: ffi::uc_context,
}

impl Context {
    pub fn new() -> Self {
        Context { context: 0 }
    }
    pub fn is_initialized(&self) -> bool {
        self.context != 0
    }
}

impl Drop for Context {
    fn drop(&mut self) {
        unsafe { ffi::uc_free(self.context) };
    }
}

impl<D> Emulator<D> {
    
    /// Return the architecture of the current emulator.
    pub fn get_arch(&self) -> Arch {
        self.arch
    }

    /// Returns a vector with the memory regions that are mapped in the emulator.
    pub fn mem_regions(&self) -> Result<Vec<MemRegion>, uc_error> {
        let mut nb_regions: u32 = 0;
        let mut p_regions: *const MemRegion = std::ptr::null_mut();
        let err = unsafe { ffi::uc_mem_regions(self.uc, &mut p_regions, &mut nb_regions) };
        if err == uc_error::OK {
            let mut regions = Vec::new();
            for i in 0..nb_regions {
                regions.push(unsafe { std::mem::transmute_copy(&*p_regions.offset(i as isize)) });
            }
            unsafe { libc::free(p_regions as _) };
            Ok(regions)
        } else {
            Err(err)
        }
    }

    /// Read a range of bytes from memory at the specified address.
    pub fn mem_read(&self, address: u64, buf: &mut [u8]) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_read(self.uc, address, buf.as_mut_ptr(), buf.len()) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Return a range of bytes from memory at the specified address as vector.
    pub fn mem_read_as_vec(&self, address: u64, size: usize) -> Result<Vec<u8>, uc_error> {
        let mut buf = vec![0; size];
        let err = unsafe { ffi::uc_mem_read(self.uc, address, buf.as_mut_ptr(), size) };
        if err == uc_error::OK {
            Ok(buf)
        } else {
            Err(err)
        }
    }

    pub fn mem_write(&mut self, address: u64, bytes: &[u8]) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_write(self.uc, address, bytes.as_ptr(), bytes.len()) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Map an existing memory region in the emulator at the specified address.
    ///
    /// This function is marked unsafe because it is the responsibility of the caller to
    /// ensure that `size` matches the size of the passed buffer, an invalid `size` value will
    /// likely cause a crash in unicorn.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    ///
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    ///
    /// `ptr` is a pointer to the provided memory region that will be used by the emulator.
    pub fn mem_map_ptr(&mut self, 
            address: u64, 
            size: usize, 
            perms: Protection, 
            ptr: *mut c_void
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_map_ptr(self.uc, address, size, perms.bits(), ptr) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Map a memory region in the emulator at the specified address.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_map(&mut self, 
            address: u64, 
            size: libc::size_t, 
            perms: Protection
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_map(self.uc, address, size, perms.bits()) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Unmap a memory region.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_unmap(&mut self, 
            address: u64, 
            size: libc::size_t
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_unmap(self.uc, address, size) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Set the memory permissions for an existing memory region.
    ///
    /// `address` must be aligned to 4kb or this will return `Error::ARG`.
    /// `size` must be a multiple of 4kb or this will return `Error::ARG`.
    pub fn mem_protect(&mut self, 
            address: u64, 
            size: libc::size_t, 
            perms: Protection
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_mem_protect(self.uc, address, size, perms.bits()) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Write an unsigned value from a register.
    pub fn reg_write<T: Into<i32>>(&mut self, regid: T, value: u64) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_reg_write(self.uc, regid.into(), &value as *const _ as _) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Write variable sized values into registers.
    /// 
    /// The user has to make sure that the buffer length matches the register size.
    /// This adds support for registers >64 bit (GDTR/IDTR, XMM, YMM, ZMM (x86); Q, V (arm64)).
    pub fn reg_write_long<T: Into<i32>>(&self, regid: T, value: Box<[u8]>) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_reg_write(self.uc, regid.into(), value.as_ptr() as _) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Read an unsigned value from a register.
    /// 
    /// Not to be used with registers larger than 64 bit.
    pub fn reg_read<T: Into<i32>>(&self, regid: T) -> Result<u64, uc_error> {
        let mut value: u64 = 0;
        let err = unsafe { ffi::uc_reg_read(self.uc, regid.into(), &mut value as *mut u64 as _) };
        if err == uc_error::OK {
            Ok(value)
        } else {
            Err(err)
        }
    }

    /// Read 128, 256 or 512 bit register value into heap allocated byte array.
    /// 
    /// This adds safe support for registers >64 bit (GDTR/IDTR, XMM, YMM, ZMM (x86); Q, V (arm64)).
    pub fn reg_read_long<T: Into<i32>>(&self, regid: T) -> Result<Box<[u8]>, uc_error> {
        let err: uc_error;
        let boxed: Box<[u8]>;
        let mut value: Vec<u8>;
        let curr_reg_id = regid.into();
        let curr_arch = self.get_arch();

        // if curr_arch == Arch::X86 {
        //     if curr_reg_id >= x86::RegisterX86::XMM0 as i32 && curr_reg_id <= x86::RegisterX86::XMM31 as i32 {
        //         value = vec![0; 16 as usize];                
        //     } else if curr_reg_id >= x86::RegisterX86::YMM0 as i32 && curr_reg_id <= x86::RegisterX86::YMM31 as i32 {
        //         value = vec![0; 32 as usize];
        //     } else if curr_reg_id >= x86::RegisterX86::ZMM0 as i32 && curr_reg_id <= x86::RegisterX86::ZMM31 as i32 {
        //         value = vec![0; 64 as usize];
        //     } else if curr_reg_id == x86::RegisterX86::GDTR as i32 ||
        //               curr_reg_id == x86::RegisterX86::IDTR as i32 {
        //         value = vec![0; 10 as usize]; // 64 bit base address in IA-32e mode
        //     } else {
        //         return Err(uc_error::ARG)
        //     }
        // } else 
        if curr_arch == Arch::ARM64 {
            if (curr_reg_id >= arm64::RegisterARM64::Q0 as i32 && curr_reg_id <= arm64::RegisterARM64::Q31 as i32) ||
               (curr_reg_id >= arm64::RegisterARM64::V0 as i32 && curr_reg_id <= arm64::RegisterARM64::V31 as i32) {
                value = vec![0; 16 as usize];
            } else {
                return Err(uc_error::ARG)
            }
        } else {
            return Err(uc_error::ARCH)
        }
        
        err = unsafe { ffi::uc_reg_read(self.uc, curr_reg_id, value.as_mut_ptr() as _) };

        if err == uc_error::OK {
            boxed = value.into_boxed_slice();
            Ok(boxed)
        } else {
            Err(err)
        }
    }

    /// Read a signed 32-bit value from a register.
    pub fn reg_read_i32<T: Into<i32>>(&self, regid: T) -> Result<i32, uc_error> {
        let mut value: i32 = 0;
        let err = unsafe { ffi::uc_reg_read(self.uc, regid.into(), &mut value as *mut i32 as _) };
        if err == uc_error::OK {
            Ok(value)
        } else {
            Err(err)
        }
    }

    /// Add a code hook.
    pub fn add_code_hook<F: 'static,>(
        &mut self,
        begin: u64,
        end: u64,
        callback: F,
    ) -> Result<ffi::uc_hook, uc_error>
    where F: FnMut(&mut Emulator<D>, u64, u32)
    {
        let mut hook_ptr = std::ptr::null_mut();
        let mut user_data = Box::new(ffi::CodeHook {
            unicorn: self,
            callback: Box::new(callback),
        });
        
        let err = unsafe {
            ffi::uc_hook_add(
                self.uc,
                &mut hook_ptr,
                HookType::CODE,
                ffi::code_hook_proxy::<D> as _,
                user_data.as_mut() as *mut _ as _,
                begin,
                end,
            )
        };
        if err == uc_error::OK {
            unsafe { self }.code_hooks.insert(hook_ptr, user_data);
            Ok(hook_ptr)
        } else {
            Err(err)
        }
    }

    /// Add a memory hook.
    pub fn add_mem_hook<F: 'static>(
        &mut self,
        hook_type: HookType,
        begin: u64,
        end: u64,
        callback: F,
    ) -> Result<ffi::uc_hook, uc_error>
    where F: FnMut(&mut Emulator<D>, MemType, u64, usize, i64)
    {
        if (hook_type as i32) < 16 || hook_type == HookType::INSN_INVALID {
            return Err(uc_error::ARG);
        }
        
        let mut hook_ptr = std::ptr::null_mut();
        let mut user_data = Box::new(ffi::MemHook {
            unicorn: self,
            callback: Box::new(callback),
        });
        
        let err = unsafe {
            ffi::uc_hook_add(
                self.uc,
                &mut hook_ptr,
                hook_type,
                ffi::mem_hook_proxy::<D> as _,
                user_data.as_mut() as *mut _ as _,
                begin,
                end,
            )
        };
        if err == uc_error::OK {
            unsafe { self}.mem_hooks.insert(hook_ptr, user_data);
            Ok(hook_ptr)
        } else {
            Err(err)
        }
    }

    /// Add an interrupt hook.
    pub fn add_intr_hook<F: 'static>(
        &mut self,
        callback: F,
    ) -> Result<ffi::uc_hook, uc_error>
    where F: FnMut(&mut Emulator<D>, u32)
    { 
        let mut hook_ptr = std::ptr::null_mut();
        let mut user_data = Box::new(ffi::InterruptHook {
            unicorn: self,
            callback: Box::new(callback),
        });
        
        let err = unsafe {
            ffi::uc_hook_add(
                self.uc,
                &mut hook_ptr,
                HookType::INTR,
                ffi::intr_hook_proxy::<D> as _,
                user_data.as_mut() as *mut _ as _,
                0,
                0,
            )
        };
        if err == uc_error::OK {
            unsafe { self }.intr_hooks.insert(hook_ptr, user_data);
            Ok(hook_ptr)
        } else {
            Err(err)
        }
    }

    /// Remove a hook.
    ///
    /// `hook` is the value returned by `add_*_hook` functions.
    pub fn remove_hook(&mut self, hook: ffi::uc_hook) -> Result<(), uc_error> {
        let handle = unsafe { self };
        let err: uc_error;
        // if handle.code_hooks.contains_key(&hook) || 
        //     handle.mem_hooks.contains_key(&hook) ||
        //     handle.intr_hooks.contains_key(&hook) ||
        //     handle.insn_in_hooks.contains_key(&hook) ||
        //     handle.insn_out_hooks.contains_key(&hook) ||
        //     handle.insn_sys_hooks.contains_key(&hook) {
            err = unsafe { ffi::uc_hook_del(handle.uc, hook) };
            // handle.mem_hooks.remove(&hook);
        // } else {
        //     err = uc_error::HOOK;
        // }

        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Allocate and return an empty Unicorn context.
    /// 
    /// To be populated via context_save.
    pub fn context_alloc(&self) -> Result<Context, uc_error> {
        let mut empty_context: ffi::uc_context = Default::default();
        let err = unsafe { ffi::uc_context_alloc(self.uc, &mut empty_context) };
        if err == uc_error::OK {
            Ok(Context { context: empty_context })
        } else {
            Err(err)
        }
    }

    /// Save current Unicorn context to previously allocated Context struct.
    pub fn context_save(&self, context: &mut Context) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_context_save(self.uc, context.context) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Allocate and return a Context struct initialized with the current CPU context.
    /// 
    /// This can be used for fast rollbacks with context_restore.
    /// In case of many non-concurrent context saves, use context_alloc and *_save 
    /// individually to avoid unnecessary allocations.
    pub fn context_init(&self) -> Result<Context, uc_error> {
        let mut new_context: ffi::uc_context = Default::default();
        let err = unsafe { ffi::uc_context_alloc(self.uc, &mut new_context) };
        if err != uc_error::OK {
            return Err(err);
        }
        let err = unsafe { ffi::uc_context_save(self.uc, new_context) };
        if err == uc_error::OK {
            Ok(Context { context: new_context })
        } else {
            unsafe { ffi::uc_free(new_context) };
            Err(err)
        }
    }

    /// Restore a previously saved Unicorn context.
    /// 
    /// Perform a quick rollback of the CPU context, including registers and some
    /// internal metadata. Contexts may not be shared across engine instances with
    /// differing arches or modes. Memory has to be restored manually, if needed.
    pub fn context_restore(&self, context: &Context) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_context_restore(self.uc, context.context) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Emulate machine code for a specified duration.
    ///
    /// `begin` is the address where to start the emulation. The emulation stops if `until`
    /// is hit. `timeout` specifies a duration in microseconds after which the emulation is
    /// stopped (infinite execution if set to 0). `count` is the maximum number of instructions
    /// to emulate (emulate all the available instructions if set to 0).
    pub fn emu_start(&mut self, 
            begin: u64, 
            until: u64, 
            timeout: u64, 
            count: usize
    ) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_emu_start(self.uc, begin, until, timeout, count as _) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Stop the emulation.
    ///
    /// This is usually called from callback function in hooks.
    /// NOTE: For now, this will stop the execution only after the current block.
    pub fn emu_stop(&mut self) -> Result<(), uc_error> {
        let err = unsafe { ffi::uc_emu_stop(self.uc) };
        if err == uc_error::OK {
            Ok(())
        } else {
            Err(err)
        }
    }

    /// Query the internal status of the engine.
    /// 
    /// supported: MODE, PAGE_SIZE, ARCH
    pub fn query(&self, query: Query) -> Result<usize, uc_error> {
        let mut result: libc::size_t = Default::default();
        let err = unsafe { ffi::uc_query(self.uc, query, &mut result) };
        if err == uc_error::OK {
            Ok(result)
        } else {
            Err(err)
        }
    }

    pub fn debug_print(&self, message: String) {
        if self.debug {
            utilities::draw_line(); 
            utilities::log(&message, utilities::DebugLevel::DEBUG);
        }
    }

    pub fn enable_vfp(&mut self) {
        let UC_ARM64_REG_CPACR_EL1 = 261;
        let cpacr_el1 = self.reg_read(UC_ARM64_REG_CPACR_EL1).unwrap();
        self.reg_write(UC_ARM64_REG_CPACR_EL1, cpacr_el1|0x300000 as u64).unwrap();
    }

    pub fn align_len(&self, len: u64) -> u64 {
        ((len+ 0x1000 - 1) / 0x1000) * 0x1000
    }

    pub fn uc_align_down(&self, address: u64) -> u64 {
        (address / 0x1000) * 0x1000
    }

    pub fn uc_align_up(&self, address: u64) -> u64 {
        let re = (address / 0x1000 + 1) * 0x1000;
        re
    }

    pub fn align_size(&self, value: u64, align: u64) -> u64 {
        ( (value -1) / align + 1 ) * align
    }

    pub fn null_mut(&self) -> *mut std::ffi::c_void {
        std::ptr::null_mut()
    }


    pub fn null_str(&self, input: &str) -> String {
        let res = input.trim_matches(char::from(0));
        String::from(res)
    }

    pub fn alignment(&self, address: u64) -> u64 {
        match self.machine {
            header::Machine::AArch64 => {
                (address / 8) * 8
            },
            _ => {
                panic!("");
            }
        }
    }
}


```

`code/src/core/unicorn/unicorn_const.rs`:

```rs
#![allow(non_camel_case_types)]
use bitflags::bitflags;

pub const API_MAJOR: u64 = 1;
pub const API_MINOR: u64 = 0;
pub const VERSION_MAJOR: u64 = 1;
pub const VERSION_MINOR: u64 = 0;
pub const VERSION_EXTRA: u64 = 2;
pub const SECOND_SCALE: u64 = 1000000;
pub const MILISECOND_SCALE: u64 = 1000;

pub const MAX_FDS: i32 = 256;

#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum uc_error {
    OK = 0,
    NOMEM = 1,
    ARCH = 2,
    HANDLE = 3,
    MODE = 4,
    VERSION = 5,
    READ_UNMAPPED = 6,
    WRITE_UNMAPPED = 7,
    FETCH_UNMAPPED = 8,
    HOOK = 9,
    INSN_INVALID = 10,
    MAP = 11,
    WRITE_PROT = 12,
    READ_PROT = 13,
    FETCH_PROT = 14,
    ARG = 15,
    READ_UNALIGNED = 16,
    WRITE_UNALIGNED = 17,
    FETCH_UNALIGNED = 18,
    HOOK_EXIST = 19,
    RESOURCE = 20,
    EXCEPTION = 21,
}

#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum MemType {
    READ = 16,
    WRITE = 17,
    FETCH = 18,
    READ_UNMAPPED = 19,
    WRITE_UNMAPPED = 20,
    FETCH_UNMAPPED = 21,
    WRITE_PROT = 22,
    READ_PROT = 23,
    FETCH_PROT = 24,
    READ_AFTER = 25,
}

#[repr(i32)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum HookType {
    INTR = 1,
    INSN = 2,
    CODE = 4,
    BLOCK = 8,
    MEM_READ_UNMAPPED = 16,
    MEM_WRITE_UNMAPPED = 32,
    MEM_FETCH_UNMAPPED = 64,
    MEM_READ_PROT = 128,
    MEM_WRITE_PROT = 256,
    MEM_FETCH_PROT = 512,
    MEM_READ = 1024,
    MEM_WRITE = 2048,
    MEM_FETCH = 4096,
    MEM_READ_AFTER = 8192,
    INSN_INVALID = 16384,
    MEM_UNMAPPED = 112,
    MEM_PROT = 896,
    MEM_READ_INVALID = 144,
    MEM_WRITE_INVALID = 288,
    MEM_FETCH_INVALID = 576,
    MEM_INVALID = 1008,
    MEM_VALID = 7168,
    MEM_ALL = 8176,
}

#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum Query {
    MODE = 1,
    PAGE_SIZE = 2,
    ARCH = 3,
}

bitflags! {
#[repr(C)]
pub struct Protection : u32 {
        const NONE = 0;
        const READ = 1;
        const WRITE = 2;
        const EXEC = 4;
        const ALL = 7;
    }
}

impl Protection {
    pub fn from_u32(perms: u32) -> Protection {
        
        let mut res = Protection::NONE;

        if perms|1 != 0 {
            res|= Protection::READ;
        }

        if perms|2 != 0 {
            res|= Protection::WRITE;
        }

        if perms|4 != 0 {
            res|= Protection::EXEC;
        }

        if perms|7 != 0 {
            return Protection::ALL;
        }

        res
    }
}

impl std::fmt::Display for Protection {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let mut res = String::new();
        let value = self.bits;
        let checks = [ (1, 'r'), (2, 'w'), (4, 'x')];

        for (k,v) in checks.iter() {
            if k & value !=0 {
                res.push(*v);
            }
            else {
                res.push('-');
            }
        }
        
        write!(f, "{}", res)
    }
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct MemRegion {
    pub begin: u64,
    pub end: u64,
    pub perms: Protection,
}

#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum Arch {
    ARM = 1,
    ARM64 = 2,
    MIPS = 3,
    X86 = 4,
    PPC = 5,
    SPARC = 6,
    M68K = 7,
    MAX = 8,
}

#[repr(C)]
#[derive(PartialEq, Debug, Clone, Copy)]
pub enum Mode {

    LITTLE_ENDIAN = 0,
    BIG_ENDIAN = 1073741824,

    // use LITTLE_ENDIAN.
    // MODE_ARM = 0,
    THUMB = 16,
    MCLASS = 32,
    V8 = 64,
    ARM926 = 128,
    ARM946 = 256,
    ARM1176 = 512,
    // (assoc) MICRO = 16,
    // (assoc) MIPS3 = 32,
    // (assoc) MIPS32R6 = 64,
    MIPS32 = 4,
    MIPS64 = 8,
    MODE_16 = 2,
    // (assoc) MODE_32 = 4,
    // (assoc) MODE_64 = 8,
    // (assoc) PPC32 = 4,
    // (assoc) PPC64 = 8,
    // (assoc) QPX = 16,
    // (assoc) SPARC32 = 4,
    // (assoc) SPARC64 = 8,
    // (assoc) V9 = 16,
}

impl Mode {
    pub const MICRO: Mode = Mode::THUMB;
    pub const MIPS3: Mode = Mode::MCLASS;
    pub const MIPS32R6: Mode = Mode::V8;
    pub const MODE_32: Mode = Mode::MIPS32;
    pub const MODE_64: Mode = Mode::MIPS64;
    pub const PPC32: Mode = Mode::MIPS32;
    pub const PPC64: Mode = Mode::MIPS64;
    pub const QPX: Mode = Mode::THUMB;
    pub const SPARC32: Mode = Mode::MIPS32;
    pub const SPARC64: Mode = Mode::MIPS64;
    pub const V9: Mode = Mode::THUMB;
}
```

`code/src/main.rs`:

```rs
extern crate byteorder;
extern crate capstone;
extern crate keystone;
extern crate nix;
extern crate xmas_elf;

mod utilities;
mod core;

use std::env;
use xmas_elf::ElfFile;

use crate::utilities::context_title;

fn parse_args() -> env::Args {
    //! Parse Command line arguments
    let mut args = env::args();

    if args.len() != 3 {
        panic!("Please provide an ELF library and rootfs folder");
    }
    args
}

fn main()
{
    utilities::context_title(Some("Hello, world!"));
    let mut args = parse_args();
    let mut elf_filename = args.nth(1).unwrap();
    let rootfs       = args.next().unwrap();
    
    let mut elf_data    = std::fs::read(&mut elf_filename).unwrap();
    let mut elf: ElfFile        = ElfFile::new(&mut elf_data).unwrap();

    //our hello world program takes no arguments or environment variables
    let program_args: Vec<String>   = vec![];
    let program_env: Vec<String>    = Vec::new();
    
    let endian =  elf.header.pt1.data();
    let mut emu = core::rudroid::Emulator::new( &elf_filename, &rootfs, &mut elf, endian, program_args, program_env, 0, true).expect("Emulator initialisation failed");
      
    context_title(Some("Emulator created"))
    
    //set up hooks
    core::hooks::add_hooks(&mut emu);

    context_title(Some("Running linker..."))
    //run linker to load dependencies of ELF and then run the main from ELF
    emu.run_linker();
    
    context_title(Some("Executing target ELF..."))
    emu.run_elf();
    
    context_title(Some("The End"))
}

```

`code/src/utilities.rs`:

```rs
use xmas_elf::program;
use crate::core::unicorn::unicorn_const::Protection;

pub struct TerminalSize {
	width : u16,
	height : u16
}

impl Default for TerminalSize {
	fn default() -> Self {
		use libc::ioctl;
		use libc::isatty;
		use libc::{winsize as WinSize, TIOCGWINSZ};
		
		let mut winsize = WinSize {
			ws_row: 0,
			ws_col: 0,
			ws_xpixel: 0,
			ws_ypixel: 0,
		};

		if unsafe { ioctl(libc::STDOUT_FILENO, TIOCGWINSZ.into(), &mut winsize) } == -1 {
			TerminalSize {
				width : 20,
				height : 20
			}
		}	

		else {
			TerminalSize {
				width : winsize.ws_col-1,
				height : winsize.ws_row-1
			}
		}		
	}
}

enum Colors {
	RESET,
	BLACK,
	RED,
	GREEN,
	YELLOW,
	BLUE,
	MAGENTA,
	CYAN,
	WHITE,
	DEFAULT
}

fn give_me_color(color: Colors) -> String {

	match color {
		Colors::RESET => {
			"\x1b[0m".to_string()
		},
		Colors::BLACK => {
			"\x1b[30m".to_string()
		},
		Colors::RED => {
			"\x1b[31m".to_string()
		},
		Colors::GREEN => {
			"\x1b[32m".to_string()
		},
		Colors::YELLOW => {
			"\x1b[33m".to_string()
		},
		Colors::BLUE => {
			"\x1b[34m".to_string()
		},
		Colors::MAGENTA => {
			"\x1b[35m".to_string()
		},
		Colors::CYAN => {
			"\x1b[36m".to_string()
		},
		Colors::WHITE => {
			"\x1b[37m".to_string()
		},
		Colors::DEFAULT => {
			"\x1b[39m".to_string()
		},
	}
}

pub fn draw_line() {
	let horizontal_line = "-";
	let terminal_size : TerminalSize = Default::default();
	
	let line_color = give_me_color(Colors::GREEN);
	let msg_color  = give_me_color(Colors::RED);
	let reset 	   = give_me_color(Colors::RESET);
	
	println!("{} {} {}", line_color, (0..terminal_size.width-2).map(|_|horizontal_line).collect::<String>() , reset);
}

pub fn context_title(msg: Option<&str>) {
	let horizontal_line = "-";
	let terminal_size : TerminalSize = Default::default();
	let line_color = give_me_color(Colors::GREEN);
	let msg_color  = give_me_color(Colors::RED);
	let reset 	   = give_me_color(Colors::RESET);

	match msg {
		Some(msg) => {

            let trail_len: u16 = (msg.len() + 12) as u16;
			let mut title = String::new();

			title.push_str(&give_me_color(Colors::GREEN));
			title.push_str(&format!(" {} [ ", (0..4).map(|_|horizontal_line).collect::<String>()));
			title.push_str(&msg_color);
			title.push_str(msg);
			title.push_str(&give_me_color(Colors::GREEN));
			title.push_str(" ] ");
			if terminal_size.width  > trail_len {
				title.push_str(&(0..terminal_size.width - trail_len).map(|_|horizontal_line).collect::<String>());
			}
			else {
				title.push_str(&(0..20).map(|_|horizontal_line).collect::<String>());
			}
			
			println!("{} {}", title, reset);

		},

		None	  => println!("{} {} {}", line_color, (0..terminal_size.width-2).map(|_|horizontal_line).collect::<String>() , reset),
	}
}

pub enum DebugLevel {
	DEBUG,
	INFO,
	ERROR
}

pub fn log(msg: &str, level: DebugLevel) {
	let mut debug_color = give_me_color(Colors::MAGENTA);
	let mut debug_type 	= "DEFAULT";
	let reset 		= give_me_color(Colors::RESET);

	match level {
		DebugLevel::DEBUG => {
			debug_color = give_me_color(Colors::GREEN);
			debug_type 	= "DEBUG";
		},
		DebugLevel::INFO => {
			debug_color = give_me_color(Colors::CYAN);
			debug_type 		= "INFO";
		},
		DebugLevel::ERROR => {
			debug_color = give_me_color(Colors::RED);
			debug_type 		= "ERROR";
		}
	}
	println!("{}[{}]: {} {}", debug_color, debug_type, reset, msg);	
}

pub fn to_uc_permissions(perms: program::Flags) -> Protection {
	let mut uc_perms: Protection = Protection::NONE;

	if perms.is_execute() {
		uc_perms = uc_perms | Protection::EXEC;
		// assumes read if execute
		uc_perms = uc_perms | Protection::READ;
	}

    if perms.is_write() {
		uc_perms = uc_perms | Protection::WRITE;
    }

    if perms.is_read() {
		uc_perms = uc_perms | Protection::READ;
	}
	
	uc_perms
}
```

`resources/Hello/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)
# LOCAL_XOM := false


# ### build the main ###
include $(CLEAR_VARS)
LOCAL_MODULE := hello
LOCAL_SRC_FILES := hello.cpp

include $(BUILD_EXECUTABLE)
```

`resources/Hello/jni/Application.mk`:

```mk
APP_MODULES := hello
APP_ABI := arm64-v8a
```

`resources/Hello/jni/Makefile`:

```
build:
	arch -x86_64 /Users/ant4g0nist/Downloads/AndroidNDK7599858.app/Contents/NDK/ndk-build

```

`resources/Hello/jni/hello.cpp`:

```cpp
#include <stdio.h>

int main(int argc, char** argv)
{
    printf("Hello World\n");
    return 0;
}

```

`run.sh`:

```sh
#!/bin/bash
image=amulator
docker build -t $image .
docker run --rm -v `pwd`:/home -v `pwd`/resources/:/setup/ -it $image bash
```