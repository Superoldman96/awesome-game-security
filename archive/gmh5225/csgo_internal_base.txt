Project Path: arc_gmh5225_csgo_internal_base_2wqqr2j9

Source Tree:

```txt
arc_gmh5225_csgo_internal_base_2wqqr2j9
├── README.md
├── base
│   ├── base.h
│   ├── debug.h
│   ├── logger.h
│   ├── math.cpp
│   ├── math.h
│   ├── types
│   │   ├── angle.h
│   │   ├── bitfield.h
│   │   ├── color.h
│   │   ├── dimension.h
│   │   ├── matrix.h
│   │   ├── pattern.h
│   │   └── vector.h
│   └── winapi.h
├── core
│   ├── cheat.h
│   ├── config.cpp
│   ├── config.h
│   ├── features
│   │   ├── cache.h
│   │   ├── esp.cpp
│   │   ├── features.h
│   │   ├── misc.cpp
│   │   ├── prediction.cpp
│   │   └── variables.h
│   ├── hooks
│   │   ├── client_dll.cpp
│   │   ├── client_mode.cpp
│   │   ├── entity_list.cpp
│   │   ├── event_mgr.cpp
│   │   ├── proxies.cpp
│   │   ├── studio_render.cpp
│   │   ├── surface.cpp
│   │   ├── vgui.cpp
│   │   └── wnd_proc.cpp
│   ├── hooks.cpp
│   ├── hooks.h
│   ├── input.cpp
│   ├── input.h
│   ├── main.cpp
│   ├── netvars.cpp
│   └── netvars.h
├── crypt
│   ├── crc32.h
│   ├── fnv1a.h
│   └── xorstr.h
├── csgo_internal_base.filters
├── csgo_internal_base.sln
├── csgo_internal_base.user
├── csgo_internal_base.vcxproj
├── csgo_internal_base.vcxproj.user
├── memory
│   ├── address.h
│   ├── detour.cpp
│   ├── detour.h
│   ├── disasm
│   │   ├── disasm.cc
│   │   └── disasm.hh
│   ├── dll.cpp
│   ├── dll.h
│   ├── hook_mgr.h
│   ├── interfaces.cpp
│   ├── interfaces.h
│   └── memory.h
├── render
│   ├── menu
│   │   ├── controls.cpp
│   │   ├── controls.h
│   │   ├── menu.cpp
│   │   └── menu.h
│   ├── render.cpp
│   └── render.h
└── valve
    ├── cs
    │   ├── animations.h
    │   ├── client_class.h
    │   ├── cmd.h
    │   ├── convar.h
    │   ├── cs.h
    │   ├── datatables.h
    │   ├── entity.cpp
    │   ├── entity.h
    │   ├── game_event.h
    │   ├── key_values.cpp
    │   ├── key_values.h
    │   ├── leaf_system.h
    │   ├── material.h
    │   ├── model.h
    │   ├── player.cpp
    │   ├── player.h
    │   ├── studio.h
    │   ├── trace.h
    │   ├── util.h
    │   ├── utl_vector.h
    │   ├── view.h
    │   └── world.h
    ├── se
    │   ├── client.h
    │   ├── datacache.h
    │   ├── engine.h
    │   ├── file_system.h
    │   ├── input_system.h
    │   ├── localize.h
    │   ├── matchmaking.h
    │   ├── material_system.h
    │   ├── net.h
    │   ├── se.h
    │   ├── server.h
    │   ├── studio_render.h
    │   ├── surface.h
    │   ├── tier0.h
    │   ├── vgui2.h
    │   ├── vphysics.h
    │   └── vstdlib.h
    └── steam
        └── steam.h

```

`README.md`:

```md
# csgo_internal_base
Just another internal cheat base for CS:GO.

## Features
* All the necessary Valve interfaces, structs and classes
* Two hooking methods: VMT swapping and detour (custom lib with x86 disassembler)
* Menu framework (ISurface based, incomplete)
* Netvar manager with proxy support
* Config system
* Compile time pattern string conversion
* Zero external dependencies
* Basic cheat features: ESP, chams, engine prediction and some other stuff

```

`base/base.h`:

```h
#pragma once

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-value"
#pragma clang diagnostic ignored "-Wpragma-once-outside-header"
#pragma clang diagnostic ignored "-Wreorder-ctor"
#endif

#include <chrono>
using namespace std::chrono_literals;
#include <cstddef>
#include <cstdint>
#include <thread>

#include "logger.h"
#include "types/angle.h"
#include "types/bitfield.h"
#include "types/color.h"
#include "types/dimension.h"
#include "types/matrix.h"
#include "types/pattern.h"
#include "types/vector.h"

```

`base/debug.h`:

```h
#pragma once

#if __has_include(<stacktrace>) && _HAS_CXX23
#define HAS_STACKTRACE
#include <stacktrace>
#endif

#include "logger.h"

#ifdef HAS_STACKTRACE
static void print_trace() noexcept
{
    auto trace = std::stacktrace::current(2);
    LOG_RAW("Call trace: ");
    for (const auto& entry : trace)
        LOG_RAW("{}", entry.description());
}
#endif

#ifdef NDEBUG
[[noreturn]]
#endif
static void dbg_fail(std::string_view fn, std::string_view msg = "") noexcept
{
#ifdef _DEBUG
    if (msg.empty())
        LOG_ERROR("An error occurred in {}!", fn);
    else
        LOG_ERROR("{} ({})", msg, fn);
#ifdef HAS_STACKTRACE
    print_trace();
#endif
    __debugbreak();
#else
    std::abort();
#endif
}

#ifdef __clang__
#define FUNCTION_NAME __PRETTY_FUNCTION__
#else
#define FUNCTION_NAME __FUNCTION__
#endif
#define ASSERT(expr) do { if (!(expr)) dbg_fail(FUNCTION_NAME); } while (false)
#define ASSERT_MSG(expr, msg) do { if (!(expr)) dbg_fail(FUNCTION_NAME, msg); } while (false)

```

`base/logger.h`:

```h
#pragma once

#include <chrono>
namespace ch = std::chrono;
#include <format>
#include <fstream>
#include <iostream>
#include <string_view>

#include "winapi.h"

#ifdef _DEBUG
#define LOG_SUCCESS(fmt, ...) logger::add<logger::level::success>(fmt, __VA_ARGS__)
#define LOG_INFO(fmt, ...) logger::add<logger::level::info>(fmt, __VA_ARGS__)
#define LOG_ERROR(fmt, ...) logger::add<logger::level::error>(fmt, __VA_ARGS__)
#define LOG_RAW(fmt, ...) logger::add<logger::level::raw>(fmt, __VA_ARGS__)
#else
#define LOG_SUCCESS
#define LOG_INFO
#define LOG_ERROR
#define LOG_RAW
#endif

namespace logger {

    inline HANDLE console{ };
    inline std::wstring log_name{ };

    enum class level {
        success,
        info,
        error,
        raw
    };

    // Use the LOG macros instead of accessing these directly

    template<level lvl, class... va_args>
    void add(std::string_view fmt, va_args&&... args) noexcept
    {
    #ifdef _DEBUG
        if constexpr (lvl != level::raw) {
            std::cout << "[ ";
            switch (lvl) {
            case level::success:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                std::cout << '+';
                break;
            case level::info:
                SetConsoleTextAttribute(console, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
                std::cout << '*';
                break;
            case level::error:
                SetConsoleTextAttribute(console, FOREGROUND_RED);
                std::cout << '!';
                break;
            }

            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
            const auto time = ch::system_clock::to_time_t(ch::system_clock::now());
            std::tm tm{ };
            localtime_s(&tm, &time);
            std::cout << " ] " << std::put_time(&tm, "[%T] ");
        }

        static std::fstream out_file{ log_name, std::fstream::out | std::fstream::app };

        if constexpr (sizeof...(args) > 0) {
            const auto& str = std::vformat(fmt, std::make_format_args(std::forward<decltype(args)>(args)...));
            std::cout << str << '\n';
            if (out_file)
                out_file << str << '\n';
        } else {
            std::cout << fmt << '\n';
            if (out_file)
                out_file << fmt << '\n';
        }
    #endif
    }

    template<level lvl, class... va_args>
    void add(std::wstring_view fmt, va_args&&... args) noexcept
    {
    #ifdef _DEBUG
        if constexpr (lvl != level::raw) {
            std::wcout << L"[ ";
            switch (lvl) {
            case level::success:
                SetConsoleTextAttribute(console, FOREGROUND_GREEN);
                std::wcout << L'+';
                break;
            case level::info:
                SetConsoleTextAttribute(console, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
                std::wcout << L'*';
                break;
            case level::error:
                SetConsoleTextAttribute(console, FOREGROUND_RED);
                std::wcout << L'!';
                break;
            }

            SetConsoleTextAttribute(console, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
            const auto time = ch::system_clock::to_time_t(ch::system_clock::now());
            std::tm tm{ };
            localtime_s(&tm, &time);
            std::wcout << L" ] " << std::put_time(&tm, L"[%T] ");
        }

        static std::wfstream out_file{ log_name, std::wfstream::out | std::wfstream::app };

        if constexpr (sizeof...(args) > 0) {
            const auto& str = std::vformat(fmt, std::make_wformat_args(std::forward<decltype(args)>(args)...));
            std::wcout << str << '\n';
            if (out_file)
                out_file << str << '\n';
        } else {
            std::wcout << fmt << '\n';
            if (out_file)
                out_file << fmt << '\n';
        }
    #endif
    }

    inline void initialize(std::wstring_view console_title, std::wstring_view log_filename) noexcept
    {
    #ifdef _DEBUG
        AllocConsole();
        AttachConsole(ATTACH_PARENT_PROCESS);
        SetConsoleTitleW(console_title.data());

        freopen_s(reinterpret_cast<FILE**>(stdout), "CONOUT$", "w", stdout);
        console = GetStdHandle(STD_OUTPUT_HANDLE);

        log_name = log_filename;
        win::scoped_handle f = CreateFileW(log_name.c_str(), 0, 0, nullptr, CREATE_NEW, 0, nullptr);

        LOG_INFO("Logger initialized.");
    #endif
    }

    inline void end() noexcept
    {
    #ifdef _DEBUG
        fclose(stdout);
        FreeConsole();
    #endif
}

}

```

`base/math.cpp`:

```cpp
#include "math.h"
#include "../memory/interfaces.h"

int math::time_to_ticks(float time) noexcept
{
    return static_cast<int>((time + 0.5f) / interfaces::globals->interval_per_tick);
}

float math::ticks_to_time(int ticks) noexcept
{
    return interfaces::globals->interval_per_tick * ticks;
}

vec3 math::lerp_vector(const vec3& a, const vec3& b, float fraction) noexcept
{
    return vec3{
        std::lerp(a.x, b.x, fraction),
        std::lerp(a.y, b.y, fraction),
        std::lerp(a.z, b.z, fraction)
    };
}

angle math::calculate_angle(const vec3& src, const vec3& dest, const angle& view) noexcept
{
    const vec3 delta = src - dest;
    angle res{
        rad_to_deg(::math::atan(delta.z / std::hypotf(delta.x, delta.y))) - view.x,
        rad_to_deg(::math::atan(delta.y / delta.x)) - view.y,
        0.0f
    };

    if (delta.x >= 0.0f)
        res.y += 180.0f;

    res.clamp();
    res.normalize();
    return res;
}

void math::angle_to_vectors(const angle& src, vec3* forward, vec3* right, vec3* up) noexcept
{
    vec3 sin{ }, cos{ };
#ifdef __clang__
    sin = { sind(src.x), sind(src.y), sind(src.z) };
    cos = { cosd(src.x), cosd(src.y), cosd(src.z) };
#else
    __m128 cos_res{ };
    const auto sin_res = _mm_sincos_ps(&cos_res,
                                       _mm_set_ps(deg_to_rad(src.x),
                                                  deg_to_rad(src.y),
                                                  deg_to_rad(src.z), 0)).m128_f32;
    sin = { sin_res[3], sin_res[2], sin_res[1] };
    cos = { cos_res.m128_f32[3], cos_res.m128_f32[2], cos_res.m128_f32[1] };
#endif

    if (forward) {
        forward->x = cos.x * cos.y;
        forward->y = cos.x * sin.y;
        forward->z = -sin.x;
    }
    if (right) {
        right->x = -sin.z * sin.x * cos.y + -cos.z * -sin.y;
        right->y = -sin.z * sin.x * sin.y + -cos.z * cos.y;
        right->z = -sin.z * cos.x;
    }
    if (up) {
        up->x = cos.z * sin.x * cos.y + -sin.z * -sin.y;
        up->y = cos.z * sin.x * sin.y + -sin.z * cos.y;
        up->z = cos.z * cos.x;
    }
}

bool math::world_to_screen(const vec3& world, vec2& screen) noexcept
{
    const auto& matrix = interfaces::engine->world_to_screen_matrix();
    const float width = matrix[3][0] * world.x + matrix[3][1] * world.y + matrix[3][2] * world.z + matrix[3][3];

    if (width < 0.001f)
        return false;

    const float inverse = 1.0f / width;
    const d2 screen_size = interfaces::engine->get_screen_size();
    screen = { screen_size.x / 2.0f, screen_size.y / 2.0f };
    screen.x *= 1.0f + (matrix[0][0] * world.x + matrix[0][1] * world.y + matrix[0][2] * world.z + matrix[0][3]) * inverse;
    screen.y *= 1.0f - (matrix[1][0] * world.x + matrix[1][1] * world.y + matrix[1][2] * world.z + matrix[1][3]) * inverse;

    return true;
}

```

`base/math.h`:

```h
#pragma once

#include <intrin.h>
#include <numbers>
#include <random>

#include "base.h"

namespace math {

    static constexpr auto pi = std::numbers::pi_v<float>;

    constexpr float rad_to_deg(float rad) noexcept
    {
        return rad * (180.0f / pi);
    }

    constexpr float deg_to_rad(float deg) noexcept
    {
        return deg * (pi / 180.0f);
    }

    inline float sin(float x) noexcept
    {
    #ifdef __clang__
        return __builtin_sinf(x);
    #else
        return _mm_cvtss_f32(_mm_sin_ps(_mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    inline float cos(float x) noexcept
    {
    #ifdef __clang__
        return __builtin_cosf(x);
    #else
        return _mm_cvtss_f32(_mm_cos_ps(_mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    inline float sind(float x) noexcept
    {
        return ::math::sin(deg_to_rad(x));
    }

    inline float cosd(float x) noexcept
    {
        return ::math::cos(deg_to_rad(x));
    }

    inline float asin(float x) noexcept
    {
    #ifdef __clang__
        return __builtin_asinf(x);
    #else
        return _mm_cvtss_f32(_mm_asin_ps(_mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    inline float acos(float x) noexcept
    {
    #ifdef __clang__
        return __builtin_acosf(x);
    #else
        return _mm_cvtss_f32(_mm_acos_ps(_mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    inline float atan(float x) noexcept
    {
    #ifdef __clang__
        return __builtin_atanf(x);
    #else
        return _mm_cvtss_f32(_mm_atan_ps(_mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    inline float atan2(float y, float x) noexcept
    {
    #ifdef __clang__
        return __builtin_atan2f(y, x);
    #else
        return _mm_cvtss_f32(_mm_atan2_ps(_mm_set_ps(0.f, 0.f, 0.f, y),
                                          _mm_set_ps(0.f, 0.f, 0.f, x)));
    #endif
    }

    int time_to_ticks(float time) noexcept;
    float ticks_to_time(int ticks) noexcept;
    vec3 lerp_vector(const vec3& a, const vec3& b, float fraction) noexcept;
    angle calculate_angle(const vec3& src, const vec3& dest, const angle& view) noexcept;
    void angle_to_vectors(const angle& src, vec3* forward = nullptr, vec3* right = nullptr,
                          vec3* up = nullptr) noexcept;
    bool world_to_screen(const vec3& world, vec2& screen) noexcept;

    namespace random {

        inline std::mt19937 engine{ std::random_device{ }() };

        template<std::integral ix>
        inline ix get(ix min, ix max) noexcept
        {
            return std::uniform_int_distribution{ min, max }(engine);
        }

        template<std::floating_point fp>
        inline fp get(fp min, fp max) noexcept
        {
            return std::uniform_real_distribution{ min, max }(engine);
        }

        template<enumerator en>
        inline en get(en min, en max) noexcept
        {
            return static_cast<en>(get(std::to_underlying(min), std::to_underlying(max)));
        }

    }

}

```

`base/types/angle.h`:

```h
#pragma once

#include <limits>

struct angle {
    float x{ }, y{ }, z{ };

    constexpr angle() noexcept = default;
    constexpr angle(float x, float y, float z) noexcept
        : x(x), y(y), z(z) { }

    bool operator==(const angle& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) <= std::numeric_limits<float>::epsilon() &&
            std::abs(y - rhs.y) <= std::numeric_limits<float>::epsilon() &&
            std::abs(z - rhs.z) <= std::numeric_limits<float>::epsilon());
    }

    bool operator!=(const angle& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) > std::numeric_limits<float>::epsilon() ||
            std::abs(y - rhs.y) > std::numeric_limits<float>::epsilon() ||
            std::abs(z - rhs.z) > std::numeric_limits<float>::epsilon());
    }

    constexpr angle operator+(const angle& rhs) const noexcept
    {
        return angle(x + rhs.x, y + rhs.y, z + rhs.z);
    }

    constexpr angle operator-(const angle& rhs) const noexcept
    {
        return angle(x - rhs.x, y - rhs.y, z - rhs.z);
    }

    constexpr angle operator*(const angle& rhs) const noexcept
    {
        return angle(x * rhs.x, y * rhs.y, z * rhs.z);
    }

    constexpr angle operator/(const angle& rhs) const noexcept
    {
        return angle(x / rhs.x, y / rhs.y, z / rhs.z);
    }

    constexpr angle operator+(const float rhs) const noexcept
    {
        return angle(x + rhs, y + rhs, z + rhs);
    }

    constexpr angle operator-(const float rhs) const noexcept
    {
        return angle(x - rhs, y - rhs, z - rhs);
    }

    constexpr angle operator*(const float rhs) const noexcept
    {
        return angle(x * rhs, y * rhs, z * rhs);
    }

    constexpr angle operator/(const float rhs) const noexcept
    {
        return angle(x / rhs, y / rhs, z / rhs);
    }

    constexpr angle& operator=(const angle& rhs) noexcept
    {
        x = rhs.x;
        y = rhs.y;
        z = rhs.z;
        return *this;
    }

    constexpr angle& operator+=(const angle& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

    constexpr angle& operator-=(const angle& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

    constexpr angle& operator*=(const angle& rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        z *= rhs.z;
        return *this;
    }

    constexpr angle& operator/=(const angle& rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        z /= rhs.z;
        return *this;
    }

    constexpr angle& operator+=(const float rhs) noexcept
    {
        x += rhs;
        y += rhs;
        z += rhs;
        return *this;
    }

    constexpr angle& operator-=(const float rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        z -= rhs;
        return *this;
    }

    constexpr angle& operator*=(const float rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        z *= rhs;
        return *this;
    }

    constexpr angle& operator/=(const float rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        z /= rhs;
        return *this;
    }

    constexpr void clamp() noexcept
    {
        x = std::clamp(x, -89.0f, 89.0f);
        y = std::clamp(y, -180.0f, 180.0f);
        z = 0.0f;
    }

    constexpr auto length_sqr() const noexcept
    {
        return (x * x + y * y + z * z);
    }

    constexpr auto length2d_sqr() const noexcept
    {
        return (x * x + y * y);
    }

    auto length() const noexcept
    {
        return sqrtf(length_sqr());
    }

    auto length2d() const noexcept
    {
        return sqrtf(length2d_sqr());
    }

    void normalize() noexcept
    {
        x = std::isfinite(x) ? std::remainder(x, 360.0f) : 0.0f;
        y = std::isfinite(y) ? std::remainder(y, 360.0f) : 0.0f;
        z = 0.0f;
    }
};

#include <format>

template<>
struct std::formatter<angle> : std::formatter<std::string> {
    auto format(angle a, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}]", a.x, a.y, a.z), ctx);
    }
};

```

`base/types/bitfield.h`:

```h
#pragma once

#include <compare>

template<class ty>
concept enumerator = __is_enum(ty);

namespace bitfield_ops {

    template<enumerator en>
    constexpr bool operator!(en bit) noexcept
    {
        return bit == static_cast<en>(0);
    }

    template<enumerator en>
    constexpr en operator&(en lhs, en rhs) noexcept
    {
        return static_cast<en>(std::to_underlying(lhs) & std::to_underlying(rhs));
    }

    template<enumerator en>
    constexpr en operator|(en lhs, en rhs) noexcept
    {
        return static_cast<en>(std::to_underlying(lhs) | std::to_underlying(rhs));
    }

    template<enumerator en>
    constexpr en operator^(en lhs, en rhs) noexcept
    {
        return static_cast<en>(std::to_underlying(lhs) ^ std::to_underlying(rhs));
    }

    template<enumerator en>
    constexpr en operator~(en bit) noexcept
    {
        return static_cast<en>(~std::to_underlying(bit));
    }

    template<enumerator en>
    en& operator|=(en& lhs, en rhs) noexcept
    {
        return lhs = static_cast<en>(std::to_underlying(lhs) | std::to_underlying(rhs));
    }

    template<enumerator en>
    en& operator&=(en& lhs, en rhs) noexcept
    {
        return lhs = static_cast<en>(std::to_underlying(lhs) &= std::to_underlying(rhs));
    }

    template<enumerator en>
    constexpr bool has_bit(en lhs, en rhs) noexcept
    {
        return operator&(lhs, rhs) != static_cast<en>(0);
    }

}

using namespace bitfield_ops;

template<enumerator en>
class bitfield {
public:
    constexpr bitfield() noexcept = default;
    constexpr bitfield(en bits) noexcept
#ifndef __clang__
        : bits(bits) { }
#else
    {
        this->bits.value = bits;
    }
#endif
    constexpr bitfield(std::underlying_type_t<en> bits) noexcept
#ifndef __clang__
        : bits(static_cast<en>(bits)) { }
#else
    {
        this->bits.raw = bits;
    }
#endif

    constexpr operator bool() { return bits.raw; }
    constexpr operator en() noexcept { return value(); }
    constexpr auto operator=(int32_t rhs) noexcept { bits.value = static_cast<en>(rhs); }

    constexpr auto value() const noexcept { return bits.value; }
    constexpr auto& value() noexcept { return bits.value; }
    constexpr auto raw() const noexcept { return bits.raw; }
    constexpr auto& raw() noexcept { return bits.raw; }

    constexpr bool is_empty() const noexcept
    {
        return !bits.raw;
    }

    template<class... es> requires(std::same_as<es, en> && ...)
    constexpr bool is_set(es... t) const noexcept
    {
        return bits.raw & (std::to_underlying(t) | ...);
    }

    template<class... es> requires(std::same_as<es, en> && ...)
    constexpr void set(es... t) noexcept
    {
        bits.raw |= (std::to_underlying(t) | ...);
    }

    template<class... es> requires(std::same_as<es, en> && ...)
    constexpr void unset(es... t) noexcept
    {
        bits.raw &= (~std::to_underlying(t) | ...);
    }

    template<class... es> requires(std::same_as<es, en> && ...)
    constexpr void toggle(es... t) noexcept
    {
        bits.raw ^= (std::to_underlying(t) | ...);
    }

    constexpr void empty() noexcept
    {
        bits = en();
    }

private:
    union {
        en value;
        std::underlying_type_t<en> raw;
    } bits{ };
};

```

`base/types/color.h`:

```h
#pragma once

struct clr3;

struct clr4 {
    uint8_t r{ }, g{ }, b{ }, a{ };

    constexpr clr4() noexcept = default;

    template<std::integral ix, std::integral ax>
    constexpr clr4(ix r, ix g, ix b, ax a) noexcept
        : r(r), g(g), b(b), a(a) { }

    template<std::floating_point fp>
    constexpr clr4(fp r, fp g, fp b, fp a) noexcept
        : r(static_cast<uint8_t>(r * 255)), g(static_cast<uint8_t>(g * 255)),
          b(static_cast<uint8_t>(b * 255)), a(static_cast<uint8_t>(a * 255)) { }

    float r_base() const noexcept { return r / 255.f; }
    float g_base() const noexcept { return g / 255.f; }
    float b_base() const noexcept { return b / 255.f; }
    float a_base() const noexcept { return a / 255.f; }

    static clr4 white(uint8_t a = 255) noexcept { return clr4(255, 255, 255, a); }
    static clr4 black(uint8_t a = 255) noexcept { return clr4(0, 0, 0, a); }
    static clr4 red(uint8_t a = 255) noexcept { return clr4(255, 0, 0, a); }
    static clr4 green(uint8_t a = 255) noexcept { return clr4(0, 255, 0, a); }
    static clr4 blue(uint8_t a = 255) noexcept { return clr4(0, 0, 255, a); }
};

struct clr3 {
    uint8_t r{ }, g{ }, b{ };

    constexpr clr3() noexcept = default;
    constexpr clr3(uint8_t r, uint8_t g, uint8_t b) noexcept
        : r(r), g(g), b(b) { }

    auto to_clr4(uint8_t alpha = 255) const noexcept
    {
        return clr4(r, g, b, alpha);
    }
};

```

`base/types/dimension.h`:

```h
#pragma once

struct d2 {
    int x{ }, y{ };

    constexpr d2() noexcept = default;
    constexpr d2(int x, int y) noexcept
        : x(x), y(y) { }

    constexpr bool operator==(d2 rhs) const noexcept
    {
        return x == rhs.x && y == rhs.y;
    }

    constexpr bool operator!=(d2 rhs) const noexcept
    {
        return x != rhs.x || y != rhs.y;
    }

    constexpr d2 operator+(d2 rhs) const noexcept
    {
        return d2(x + rhs.x, y + rhs.y);
    }

    constexpr d2 operator-(d2 rhs) const noexcept
    {
        return d2(x - rhs.x, y - rhs.y);
    }

    constexpr d2 operator*(d2 rhs) const noexcept
    {
        return d2(x * rhs.x, y * rhs.y);
    }

    constexpr d2 operator/(d2 rhs) const noexcept
    {
        return d2(x / rhs.x, y / rhs.y);
    }

    constexpr d2 operator+(const int rhs) const noexcept
    {
        return d2(x + rhs, y + rhs);
    }

    constexpr d2 operator-(const int rhs) const noexcept
    {
        return d2(x - rhs, y - rhs);
    }

    constexpr d2 operator*(const int rhs) const noexcept
    {
        return d2(x * rhs, y * rhs);
    }

    constexpr d2 operator/(const int rhs) const noexcept
    {
        return d2(x / rhs, y / rhs);
    }

    constexpr d2& operator+=(d2 rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }

    constexpr d2& operator-=(d2 rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }

    constexpr d2& operator*=(d2 rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        return *this;
    }

    constexpr d2& operator/=(d2 rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        return *this;
    }

    constexpr d2& operator+=(int rhs) noexcept
    {
        x += rhs;
        y += rhs;
        return *this;
    }

    constexpr d2& operator-=(int rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        return *this;
    }

    constexpr d2& operator*=(int rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        return *this;
    }

    constexpr d2& operator/=(int rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        return *this;
    }
};

```

`base/types/matrix.h`:

```h
#pragma once

using mat3x3 = float[3][3];

struct mat3x4 {
    float data[3][4]{ };

    float* operator[](int i) noexcept
    {
        return data[i];
    }

    const float* operator[](int i) const noexcept
    {
        return data[i];
    }
};

struct mat4x4 {
    float data[4][4]{ };

    float* operator[](int i) noexcept
    {
        return data[i];
    }

    const float* operator[](int i) const noexcept
    {
        return data[i];
    }
};

```

`base/types/pattern.h`:

```h
#pragma once

#include <array>

template<size_t len>
struct string_literal {
    size_t length = len - 1;
    std::array<char, len - 1> value{ };

    consteval string_literal(const char(&str)[len])
    {
        for (size_t i{ }; i < len - 1; i++)
            value[i] = str[i];
    }
};

static consteval bool is_hex_char(char c)
{
    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F');
}

static consteval int hex_char_to_int(char c)
{
    return (c > '9') ? (c & ~0x20) - 'A' + 10 : (c - '0');
}

static consteval int make_hex_digits(char a, char b)
{
    return 16 * hex_char_to_int(a) + hex_char_to_int(b);
}

template<string_literal str>
struct pattern {
    struct length_t {
        static consteval auto get()
        {
            size_t ret{ };
            bool was_digit{ };

            for (size_t i{ }; i < str.length; i++) {
                if (is_hex_char(str.value[i])) {
                    if (!was_digit)
                        ret++;
                    was_digit = true;
                } else if (str.value[i] == '?') {
                    ret++;
                    was_digit = false;
                } else if (str.value[i] == ' ')
                    was_digit = false;

            }
            return ret;
        }
    };

    static consteval auto value()
    {
        constexpr auto len = length_t::get();
        static_assert(len > 0);
        std::array<int, len> ret{ };

        for (size_t i{ }, j{ }; i < str.length; i++) {
            if (str.value[i] == ' ')
                continue;
            if (is_hex_char(str.value[i])) {
                i++;
                if (j < len) {
                    if (is_hex_char(str.value[i]))
                        ret[j++] = make_hex_digits(str.value[i - 1], str.value[i]);
                }
            } else if (str.value[i] == '?')
                ret[j++] = -1;
        }
        return ret;
    }
};

#define PATTERN(str) pattern<str>::value()

```

`base/types/vector.h`:

```h
#pragma once

struct vec2 {
    float x{ }, y{ };

    constexpr vec2() noexcept = default;
    constexpr vec2(float x, float y) noexcept
        : x(x), y(y) { }
};

struct vec3 {
    float x{ }, y{ }, z{ };

    constexpr vec3() noexcept = default;
    constexpr vec3(float x, float y, float z) noexcept
        : x(x), y(y), z(z) { }

    bool operator==(const vec3& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) <= std::numeric_limits<float>::epsilon() &&
            std::abs(y - rhs.y) <= std::numeric_limits<float>::epsilon() &&
            std::abs(z - rhs.z) <= std::numeric_limits<float>::epsilon());
    }

    bool operator!=(const vec3& rhs) const noexcept
    {
        return (std::abs(x - rhs.x) > std::numeric_limits<float>::epsilon() ||
            std::abs(y - rhs.y) > std::numeric_limits<float>::epsilon() ||
            std::abs(z - rhs.z) > std::numeric_limits<float>::epsilon());
    }

    constexpr vec3 operator+(const vec3& rhs) const noexcept
    {
        return vec3(x + rhs.x, y + rhs.y, z + rhs.z);
    }

    constexpr vec3 operator-(const vec3& rhs) const noexcept
    {
        return vec3(x - rhs.x, y - rhs.y, z - rhs.z);
    }

    constexpr vec3 operator*(const vec3& rhs) const noexcept
    {
        return vec3(x * rhs.x, y * rhs.y, z * rhs.z);
    }

    constexpr vec3 operator/(const vec3& rhs) const noexcept
    {
        return vec3(x / rhs.x, y / rhs.y, z / rhs.z);
    }

    constexpr vec3 operator+(const float rhs) const noexcept
    {
        return vec3(x + rhs, y + rhs, z + rhs);
    }

    constexpr vec3 operator-(const float rhs) const noexcept
    {
        return vec3(x - rhs, y - rhs, z - rhs);
    }

    constexpr vec3 operator*(const float rhs) const noexcept
    {
        return vec3(x * rhs, y * rhs, z * rhs);
    }

    constexpr vec3 operator/(const float rhs) const noexcept
    {
        return vec3(x / rhs, y / rhs, z / rhs);
    }

    constexpr vec3& operator=(const vec3& rhs) noexcept
    {
        x = rhs.x;
        y = rhs.y;
        z = rhs.z;
        return *this;
    }

    constexpr vec3& operator+=(const vec3& rhs) noexcept
    {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return *this;
    }

    constexpr vec3& operator-=(const vec3& rhs) noexcept
    {
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
        return *this;
    }

    constexpr vec3& operator*=(const vec3& rhs) noexcept
    {
        x *= rhs.x;
        y *= rhs.y;
        z *= rhs.z;
        return *this;
    }

    constexpr vec3& operator/=(const vec3& rhs) noexcept
    {
        x /= rhs.x;
        y /= rhs.y;
        z /= rhs.z;
        return *this;
    }

    constexpr vec3& operator+=(const float rhs) noexcept
    {
        x += rhs;
        y += rhs;
        z += rhs;
        return *this;
    }

    constexpr vec3& operator-=(const float rhs) noexcept
    {
        x -= rhs;
        y -= rhs;
        z -= rhs;
        return *this;
    }

    constexpr vec3& operator*=(const float rhs) noexcept
    {
        x *= rhs;
        y *= rhs;
        z *= rhs;
        return *this;
    }

    constexpr vec3& operator/=(const float rhs) noexcept
    {
        x /= rhs;
        y /= rhs;
        z /= rhs;
        return *this;
    }

    constexpr void inverse() noexcept
    {
        x = -x;
        y = -y;
        z = -z;
    }

    constexpr void clear() noexcept
    {
        x = { };
        y = { };
        z = { };
    }

    float length_sqr() const noexcept
    {
        return dot_product(*this);
    }

    float length() const noexcept
    {
        return sqrtf(length_sqr());
    }

    float length2d_sqr() const noexcept
    {
        return (x * x + y * y);
    }

    float length2d() const noexcept
    {
        return sqrtf(length2d_sqr());
    }

    float distance_to(const vec3& other) const noexcept
    {
        return (*this - other).length();
    }

    float dot_product(const vec3& v) const noexcept
    {
        return (x * v.x + y * v.y + z * v.z);
    }

    vec3 cross_product(const vec3& v) const noexcept
    {
        return vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);
    }

    vec3 transform(const mat3x4& mat) noexcept
    {
        return vec3(dot_product({ mat[0][0], mat[0][1], mat[0][2] }) + mat[0][3],
          dot_product({ mat[1][0], mat[1][1], mat[1][2] }) + mat[1][3],
          dot_product({ mat[2][0], mat[2][1], mat[2][2] }) + mat[2][3]);
    }

    void normalize() noexcept
    {
        *this /= length();
    }

    auto to_vec2() const noexcept
    {
        return vec2(x, y);
    }
};

struct vec4 {
    float x{ }, y{ }, z{ }, w{ };
};

#include <format>

template<>
struct std::formatter<vec2> : std::formatter<std::string> {
    auto format(vec2 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}]", v.x, v.y), ctx);
    }
};

template<>
struct std::formatter<vec3> : std::formatter<std::string> {
    auto format(vec3 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}]", v.x, v.y, v.z), ctx);
    }
};

template<>
struct std::formatter<vec4> : std::formatter<std::string> {
    auto format(vec4 v, format_context& ctx)
    {
        return formatter<string>::format(std::format("[{}, {}, {}, {}]", v.x, v.y, v.z, v.w), ctx);
    }
};

```

`base/winapi.h`:

```h
#pragma once

#include <filesystem>
namespace fs = std::filesystem;
#include <string_view>
#include <Windows.h>
#include <TlHelp32.h>

struct dll;

namespace win {

    // Only usable for handles closed via CloseHandle()!
    struct scoped_handle {
        HANDLE handle{ };

        scoped_handle(HANDLE handle) noexcept
            : handle(handle) { }
        ~scoped_handle()
        {
            if (is_valid())
                CloseHandle(handle);
        }

        operator bool() noexcept { return is_valid(); }
        operator HANDLE() noexcept { return handle; }

        bool is_valid() const noexcept
        {
            return handle != nullptr && handle != INVALID_HANDLE_VALUE;
        }
    };

    inline bool get_module_path(HMODULE mod, fs::path& path) noexcept
    {
        WCHAR tmp[MAX_PATH]{ };
        bool ret{ };
        if ((ret = GetModuleFileNameW(mod, tmp, MAX_PATH)) != 0)
            path.assign(tmp);
        return ret;
    }

    inline void iterate_processes(std::invocable<PROCESSENTRY32W&> auto&& callback) noexcept
    {
        scoped_handle snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        PROCESSENTRY32W entry{ sizeof(entry) };

        if (Process32FirstW(snapshot, &entry)) {
            do
                callback(entry);
            while (Process32NextW(snapshot, &entry));
        }
    }

    inline DWORD get_process_id(std::wstring_view name) noexcept
    {
        DWORD ret{ };
        iterate_processes([&](const PROCESSENTRY32W& entry) {
            if (!name.compare(entry.szExeFile))
                ret = entry.th32ProcessID;
        });
        return ret;
    }

    inline scoped_handle get_process_handle(std::wstring_view name, DWORD access_flags) noexcept
    {
        return OpenProcess(access_flags, FALSE, get_process_id(name));
    }

}

```

`core/cheat.h`:

```h
#pragma once

#include "../memory/interfaces.h"
#include "../memory/hook_mgr.h"
#include "../valve/cs/player.h"
#include "netvars.h"
#include "config.h"

namespace cheat {

    inline cs::local_player local{ };
    inline bool should_unhook{ };

    inline void initialize() noexcept
    {
        logger::initialize(L"csgo", L"log.txt");
        dlls::initialize();
        interfaces::initialize();
        netvars::initialize();
        hooks::initialize();
        cfg::initialize();

        LOG_SUCCESS("Cheat initialized. Last full build: {} {}", __DATE__, __TIME__);
    }

    inline DWORD end(LPVOID instance) noexcept
    {
        interfaces::input_system->enable_input();
        hooks::end();
        logger::end();

        FreeLibraryAndExitThread(static_cast<HMODULE>(instance), EXIT_SUCCESS);
        return EXIT_SUCCESS;
    }

}

```

`core/config.cpp`:

```cpp
#include "config.h"
#include "../base/debug.h"

void cfg::initialize() noexcept
{
    if (!fs::exists("csgo_internal_base"))
        fs::create_directory("csgo_internal_base");

    path = fs::current_path() / "csgo_internal_base";

    if (!fs::exists(path / "default.cfg"))
        write(L"default.cfg");

    read(L"default.cfg");
}

void cfg::read(std::wstring_view name) noexcept
{
    const auto index_from_hash = [](const hash_t name) {
        for (size_t i{ }; i < items.size(); i++) {
            if (items[i].name == name)
                return i;
        }
        ASSERT(false);
        return std::numeric_limits<hash_t>::max();
    };

    const auto cfg_path = path / name.data();
    std::ifstream cfg{ cfg_path };
    if (!cfg)
        LOG_ERROR(L"Could not open config {} for reading!", cfg_path.c_str());
    else {
        std::string line{ };
        // Separate into lines
        while (getline(cfg, line)) {
            // Separate into tokens
            std::istringstream stream{ line };
            hash_t hash{ };
            stream >> hash;
            auto& cur_item = items[index_from_hash(hash)];

            std::string token{ };
            stream >> token; // Type
            switch (fnv1a::hash(token)) {
            case "i32"_hash:
                stream >> cur_item.get<int32_t>();
                break;
            case "f32"_hash:
                stream >> cur_item.get<float_t>();
                break;
            case "bool"_hash:
                stream >> cur_item.get<bool>();
                break;
            case "c3"_hash:
                stream >> cur_item.get<clr3>().r >> cur_item.get<clr3>().g >> cur_item.get<clr3>().b;
                break;
            case "c4"_hash: {
                auto& clr = cur_item.get<clr4>();
                /* This abomination forces the stream to read the whole number instead of one char. */
                int tmp{ };
                stream >> tmp; clr.r = static_cast<uint8_t>(tmp);
                stream >> tmp; clr.g = static_cast<uint8_t>(tmp);
                stream >> tmp; clr.b = static_cast<uint8_t>(tmp);
                stream >> tmp; clr.a = static_cast<uint8_t>(tmp);
                break;
            }
            case "vec"_hash: {
                stream.ignore(); // Skip space
                auto& vec = cur_item.get<std::vector<bool>>();
                for (size_t i{ }; i < vec.size(); i++)
                    vec[i] = (stream.get() == '1'); // Anything other than 1 is false
                break;
            }
            case "key"_hash: {
                auto& key = cur_item.get<keybind>();
                stream >> key.code;
                int type{ };
                stream >> type;
                key.type = static_cast<input::key_type>(type);
                break;
            }
            default:
                LOG_ERROR("Unknown config item type!");
            }
        }
        LOG_INFO(L"Read from {}.", name);
    }
}

void cfg::write(std::wstring_view name) noexcept
{
    const auto cfg_path = path / name.data();
    std::ofstream cfg{ cfg_path, std::ios::out | std::ios::trunc };
    if (!cfg)
        LOG_ERROR(L"Could not open config {} for writing!", cfg_path.c_str());
    else {
        for (auto& var : items) {
            cfg << var.name << ' ';
            switch (var.type) {
            case item_type::i32:
                cfg << "i32 " << var.get<int32_t>() << '\n';
                break;
            case item_type::f32:
                cfg << "f32 " << var.get<float_t>() << '\n';
                break;
            case item_type::boolean:
                cfg << "bool " << var.get<bool>() << '\n';
                break;
            case item_type::clr3: {
                const auto& clr = var.get<clr3>();
                cfg << "c3 " << static_cast<int>(clr.r) << ' ' << static_cast<int>(clr.g) << ' '
                    << static_cast<int>(clr.b) << '\n';
                break;
            }
            case item_type::clr4: {
                const auto& clr = var.get<clr4>();
                cfg << "c4 " << static_cast<int>(clr.r) << ' ' << static_cast<int>(clr.g) << ' '
                    << static_cast<int>(clr.b) << ' ' << static_cast<int>(clr.a) << '\n';
                break;
            }
            case item_type::bool_vec:
                cfg << "vec ";
                for (const auto& b : var.get<std::vector<bool>>())
                    cfg << static_cast<int>(b);
                cfg << '\n';
                break;
            case item_type::keybind: {
                const auto& key = var.get<keybind>();
                cfg << "key " << key.code << ' ' << std::to_underlying(key.type) << '\n';
                break;
            }
            }
        }
        LOG_INFO(L"Wrote to {}.", name);
    }
}

```

`core/config.h`:

```h
#pragma once

#include <filesystem>
namespace fs = std::filesystem;
#include <variant>

#include "../base/base.h"
#include "../crypt/fnv1a.h"
#include "input.h"

template<class ty, class... ts>
concept any_of = (std::same_as<ty, ts> || ...);

namespace cfg {

    enum class item_type {
        i32,
        f32,
        boolean,
        clr3,
        clr4,
        bool_vec,
        keybind
    };

    template<class ty>
    concept configurable = any_of<ty, int, float, bool, clr3, clr4, std::vector<bool>, keybind>;

    struct item {
        std::variant<int, float, bool, clr3, clr4, std::vector<bool>, keybind> var{ };
        hash_t name{ };
        item_type type{ };

        constexpr item(configurable auto&& preset, hash_t name, item_type type) noexcept
            : var(preset), name(name), type(type) { }

        template<configurable ty>
        ty& get() noexcept
        {
            return std::get<ty>(var);
        }
    };

    inline std::vector<item> items{ };
    inline fs::path path{ };

    void initialize() noexcept;
    void read(std::wstring_view name) noexcept;
    void write(std::wstring_view name) noexcept;

    inline size_t add_item(item&& it) noexcept
    {
        items.push_back(it);
        return items.size() - 1;
    }

    template<class ty>
    ty& get(size_t idx) noexcept
    {
        return items[idx].get<ty>();
    }

}

```

`core/features/cache.h`:

```h
#pragma once

#include <ranges>

#include "../../valve/cs/entity.h"
#include "../../valve/cs/player.h"
#include "features.h"

namespace cs {

    enum class player_filter {
        dormant = (1 << 0),
        dead = (1 << 1),
        team = (1 << 2) /* Based on is_enemy(), not just the team id */
    };

    struct cached_entity {
        explicit cached_entity(base_entity* ptr, entity_type type) noexcept
            : ptr(ptr), type(type) { }

        cs::base_entity* ptr;
        cs::entity_type type;
    };

}

namespace cache {

    inline std::vector<cs::cached_entity> entities{ };

    inline void clear() noexcept
    {
        entities.clear();
    }

    inline void initialize() noexcept
    {
        if (!interfaces::engine->is_in_game())
            return;

        clear();

        for (int i{ 1 }; i < interfaces::entity_list->get_highest_index(); i++) {
            if (auto entity = interfaces::entity_list->get(i))
                entities.push_back(cs::cached_entity(entity, entity->get_entity_type()));
        }
    }

    inline void add(cs::base_entity* entity) noexcept
    {
        const auto type = entity->get_entity_type();
        entities.push_back(cs::cached_entity(entity, type));
    }

    inline void remove(cs::base_entity* entity) noexcept
    {
        auto it = std::ranges::find_if(entities, [entity](auto& e) { return e.ptr == entity; });
        if (it != entities.cend())
            entities.erase(it);
    }

    void iterate_entities(std::invocable<cs::base_entity*> auto&& callback,
                          bitfield<cs::entity_type> types = { } /* = all */) noexcept
    {
        if (entities.empty())
            return;

        if (types.is_empty()) {
            for (auto& a : entities)
                callback(a.ptr);

            return;
        }

        auto view = entities | std::views::filter([t = types.value()](const cs::cached_entity& e) {
            return has_bit(e.type, t);
        });

        for (auto& a : view)
            callback(a.ptr);
    }

    void iterate_players(std::invocable<cs::player*> auto&& callback,
                         bitfield<cs::player_filter> filter = { } /* = all */) noexcept
    {
        iterate_entities([callback, filter](cs::base_entity* entity)
        {
            auto player = static_cast<cs::player*>(entity);

            if (filter.is_set(cs::player_filter::dormant))
                if (player->is_dormant())
                    return;
            if (filter.is_set(cs::player_filter::dead))
                if (!player->is_alive())
                    return;
            if (filter.is_set(cs::player_filter::team))
                if (!player->is_enemy())
                    return;

            callback(player);
        }, cs::entity_type::player);
    }

}

```

`core/features/esp.cpp`:

```cpp
#include "features.h"
#include "cache.h"
#include "../../base/math.h"
#include "../../render/render.h"

bool visuals::esp::generate_box(cs::base_entity* entity) noexcept
{
    const uint8_t alpha = [entity]() -> uint8_t
    {
        if (entity->is_dormant()) {
            float delta = interfaces::globals->cur_time - entity->get_simulation_time();
            if (delta > 8.0f)
                return 0;

            if (delta > 4.0f) {
                float scalar = ((delta - 4.0f) * 100 / 4.0f) / 100;
                scalar = 1 - scalar;
                scalar = std::powf(scalar, 3);
                return static_cast<uint8_t>(scalar * 255);
            }
        }
        return 255;
    }();

    if (!alpha)
        return false;

    const vec3 min = entity->get_collideable()->obb_mins();
    const vec3 max = entity->get_collideable()->obb_maxs();

    std::array<vec3, 8> points{
        vec3{ min.x, min.y, min.z },
        vec3{ min.x, max.y, min.z },
        vec3{ max.x, max.y, min.z },
        vec3{ max.x, min.y, min.z },
        vec3{ max.x, max.y, max.z },
        vec3{ min.x, max.y, max.z },
        vec3{ min.x, min.y, max.z },
        vec3{ max.x, min.y, max.z }
    };

    int left = std::numeric_limits<int>::max();
    int top = left;
    int right = std::numeric_limits<int>::min();
    int bottom = right;

    const auto& coordinate_frame = entity->get_coordinate_frame();

    for (size_t i{ }; i < points.size(); i++) {
        vec2 screen;
        if (!math::world_to_screen(points[i].transform(coordinate_frame), screen))
            return false;

        const int x = static_cast<int>(screen.x);
        const int y = static_cast<int>(screen.y);
        left = std::min(left, x);
        top = std::min(top, y);
        right = std::max(right, x);
        bottom = std::max(bottom, y);
    }

    box = { left, top, right, bottom, right - left, bottom - top, alpha };
    return true;
}

void visuals::esp::draw_box() noexcept
{
    render::outlined_rect({ box.left, box.top }, { box.width, box.height }, clr4::white(box.alpha));
    render::outlined_rect({ box.left - 1, box.top - 1 }, { box.width + 2, box.height + 2 }, clr4::black(box.alpha));
    render::outlined_rect({ box.left + 1, box.top + 1 }, { box.width - 2, box.height - 2 }, clr4::black(box.alpha));
}

void visuals::esp::draw_name(std::string_view name) noexcept
{
    const auto wname = std::wstring(name.begin(), name.end());
    render::text(render::fonts::esp, { box.left + box.width / 2, box.top - 12 },
                 wname, render::text_flag::centered_x, clr4::white(box.alpha));
}

void visuals::esp::draw_weapon(cs::weapon* weapon) noexcept
{
    if (!weapon)
        return;

    const auto info = weapon->get_info();
    if (!info)
        return;

    const auto wname = interfaces::localize->find_safe(info->weapon_name);
    render::text(render::fonts::esp, { box.left + box.width / 2, box.bottom },
                 wname, render::text_flag::centered_x, { 255, 255, 255, box.alpha });
}

void visuals::esp::draw_health(int health) noexcept
{
    const auto hp = std::clamp(health, 0, 100);
    const auto height = hp * box.height / 100;
    const auto r_g = static_cast<int>(2.55f * hp);

    render::outlined_rect({ box.left - 6, box.top - 1 }, { 4, box.height + 2 }, clr4::black(box.alpha));
    render::outlined_rect({ box.left - 5, box.bottom - height }, { 2, height }, clr4(255 - r_g, r_g, 0, box.alpha));

    if (hp == 100)
        return;

    auto hp_str = std::to_wstring(hp);
    auto hp_size = render::get_text_size(render::fonts::esp, hp_str);

    render::text(render::fonts::esp, { box.left - 4 - hp_size.x / 2, box.bottom - height - 8 },
                 hp_str, { }, clr4::white(box.alpha));
}

void visuals::esp::run() noexcept
{
    if (!cfg::get<bool>(vars::esp))
        return;

    if (!local || !local.in_game)
        return;

    cache::iterate_entities([](cs::base_entity* entity)
    {
        if (entity->get_owner_entity_handle().is_valid())
            return;

        if (!generate_box(entity))
            return;

        draw_box();
        draw_weapon(static_cast<cs::weapon*>(entity));
    }, cs::entity_type::weapon);

    cs::player_info info{ };
    cache::iterate_players([&info](cs::player* player)
    {
        if (!generate_box(player->get_base_entity()))
            return;

        draw_box();

        if (player->get_info(info))
            draw_name(info.name);

        draw_weapon(player->get_active_weapon());
        draw_health(player->get_health());
    }, cs::player_filter::dead | cs::player_filter::team);
}

```

`core/features/features.h`:

```h
#pragma once

#include "../../base/base.h"
#include "../../valve/cs/cs.h"
#include "../../memory/interfaces.h"
#include "../cheat.h"
#include "variables.h"

inline namespace features {

    using cheat::local;

    namespace prediction {

        struct {
            bool is_in_prediction{ };
            bool is_first_time_predicted{ };
            float cur_time{ };
            float frame_time{ };
            int tick_count{ };
        } backup;
        inline int* seed{ };
        inline cs::player** player{ };
        inline cs::move_data move_data{ };

        void start(cs::user_cmd* cmd) noexcept;
        void end() noexcept;

    }

    namespace visuals {

        namespace esp {

            struct {
                int left{ };
                int top{ };
                int right{ };
                int bottom{ };
                int width{ };
                int height{ };
                uint8_t alpha{ };
            } inline box;

            void run() noexcept;
            void draw_box() noexcept;
            void draw_name(std::string_view name) noexcept;
            void draw_weapon(cs::weapon* weapon) noexcept;
            void draw_health(int health) noexcept;
            bool generate_box(cs::base_entity* entity) noexcept;

        }

    }

    namespace misc {


    }

}

```

`core/features/misc.cpp`:

```cpp
#include "features.h"


```

`core/features/prediction.cpp`:

```cpp
#include "features.h"
#include "../../base/math.h"

static void update() noexcept
{
    if (interfaces::client_state->delta_tick > 0)
        interfaces::prediction->update(interfaces::client_state->delta_tick, true,
                                   interfaces::client_state->last_cmd_acknowledged,
                                   interfaces::client_state->last_outgoing_cmd +
                                   interfaces::client_state->choked_cmds);
}

static void update_button_state(bitfield<cs::cmd_button>& cmd_buttons) noexcept
{
    auto buttons = local->get_buttons();
    local->get_button_last() = *buttons;

    *buttons = cmd_buttons;
    const auto buttons_changed = local->get_button_last().raw() ^ buttons->raw();

    local->get_button_pressed() = buttons_changed & buttons->raw();
    local->get_button_released() = buttons_changed & (~buttons->raw());
}

void prediction::start(cs::user_cmd* cmd) noexcept
{
    if (!cfg::get<bool>(vars::prediction))
        return;

    [[maybe_unused]] static bool once = []
    {
        seed = *dlls::client.find(PATTERN("8B 0D ? ? ? ? BA ? ? ? ? E8 ? ? ? ? 83 C4 04"))
            .offset(0x2).cast<int**>();
        player = *dlls::client.find(PATTERN("89 35 ? ? ? ? F3 0F 10 48 20"))
            .offset(0x2).cast<cs::player***>();
        return true;
    }();

    update();

    *seed = cmd->random_seed;
    *player = static_cast<cs::player*>(local);

    backup.is_in_prediction = interfaces::prediction->is_in_prediction;
    backup.is_first_time_predicted = interfaces::prediction->is_first_time_predicted;
    backup.cur_time = interfaces::globals->cur_time;
    backup.frame_time = interfaces::globals->frame_time;
    backup.tick_count = interfaces::globals->tick_count;

    interfaces::globals->cur_time = math::ticks_to_time(local->get_tick_base());
    interfaces::globals->frame_time = interfaces::prediction->is_engine_paused ? 0.0f :
                                      interfaces::globals->interval_per_tick;
    interfaces::globals->tick_count = local->get_tick_base();
    interfaces::prediction->is_in_prediction = true;
    interfaces::prediction->is_first_time_predicted = false;

    update_button_state(cmd->buttons);

    interfaces::prediction->check_moving_ground(local, interfaces::globals->frame_time);

    local->set_local_view_angles(cmd->view_angles);

    if (local->physics_run_think(cs::think_method::all_functions))
        local->pre_think();

    const int think_tick = local->get_next_think_tick();
    if (think_tick > 0 && think_tick <= local->get_tick_base()) {
        local->get_next_think_tick() = cs::tick_never_think;
        local->think();
    }

    interfaces::move_helper->set_host(local);

    interfaces::prediction->setup_move(local, cmd, interfaces::move_helper, &move_data);
    interfaces::movement->process_movement(local, &move_data);
    interfaces::prediction->finish_move(local, cmd, &move_data);

    if (const auto weapon = local->get_active_weapon())
        weapon->update_accuracy_penalty();

    interfaces::prediction->is_in_prediction = backup.is_in_prediction;
    interfaces::prediction->is_first_time_predicted = backup.is_first_time_predicted;
}

void prediction::end() noexcept
{
    if (!cfg::get<bool>(vars::prediction))
        return;

    interfaces::move_helper->set_host(nullptr);

    interfaces::globals->cur_time = backup.cur_time;
    interfaces::globals->frame_time = backup.frame_time;
    interfaces::globals->tick_count = backup.tick_count;

    *seed = -1;
    *player = nullptr;

    interfaces::movement->reset();
}

```

`core/features/variables.h`:

```h
#pragma once

#include "../config.h"

#define ADD_VARIABLE(name, type, preset) inline auto name = cfg::add_item({ preset, fnv1a::hash(#name), cfg::item_type::type })
#define ADD_INT(name, preset) ADD_VARIABLE(name, i32, preset)
#define ADD_FLOAT(name, preset) ADD_VARIABLE(name, f32, preset)
#define ADD_BOOL(name, preset) ADD_VARIABLE(name, boolean, preset)
#define ADD_COLOR3(name, preset) ADD_VARIABLE(name, clr3, preset)
#define ADD_COLOR4(name, preset) ADD_VARIABLE(name, clr4, preset)
#define ADD_BOOL_VEC(name, preset) ADD_VARIABLE(name, bool_vec, preset)
#define ADD_KEYBIND(name, preset) ADD_VARIABLE(name, keybind, preset)

namespace vars {

    ADD_BOOL(prediction, false);

    ADD_BOOL(radar_reveal, false);
    ADD_BOOL(esp, false);
    ADD_FLOAT(fov, 90.0f);
    ADD_FLOAT(viewmodel_fov, 68.0f);
    ADD_BOOL(disable_postprocessing, true);

    ADD_BOOL(infinite_crouch, false);
    ADD_KEYBIND(panic_key, (keybind{ VK_DELETE, input::key_type::toggle }));

    ADD_INT(test_multi, 0);
    ADD_COLOR3(test_clr3, (clr3{ 255, 255, 255 }));
    ADD_COLOR4(test_clr4, (clr4{ 255, 0, 255, 0 }));
    ADD_BOOL_VEC(test_vec, (std::vector<bool>{ false, true, false, true }));

}

```

`core/hooks.cpp`:

```cpp
#include "hooks.h"
#include "cheat.h"
#include "features/cache.h"
#include "../memory/hook_mgr.h"
#include "../memory/interfaces.h"

void hooks::initialize() noexcept
{
    D3DDEVICE_CREATION_PARAMETERS creation_params{ };
    interfaces::dx9_device->GetCreationParameters(&creation_params);

    ASSERT(creation_params.hFocusWindow);
    game_window = creation_params.hFocusWindow;
    original_wnd_proc = reinterpret_cast<WNDPROC>(SetWindowLongPtr(game_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wnd_proc)));

    SET_VT_HOOK(interfaces::client, level_init_post_entity, 6);
    SET_VT_HOOK(interfaces::client, level_shutdown, 7);
    SET_VT_HOOK(interfaces::client, frame_stage_notify, 37);
    SET_VT_HOOK(interfaces::client, create_move_proxy, 22);
    SET_VT_HOOK(interfaces::client_mode, override_view, 18);
    SET_VT_HOOK(interfaces::client_mode, get_viewmodel_fov, 35);
    SET_VT_HOOK(interfaces::vgui, paint, 14);
    SET_VT_HOOK(interfaces::studio_render, draw_model, 29);
    SET_VT_HOOK(interfaces::surface, lock_cursor, 67);

    SET_SIG_HOOK(dlls::client, "55 8B EC 51 8B 45 0C 53 56 8B F1 57", on_add_entity);
    SET_SIG_HOOK(dlls::client, "55 8B EC 51 8B 45 0C 53 8B D9 56 57 83 F8 FF 75 07", on_remove_entity);
    SET_SIG_HOOK(dlls::engine, "55 8B EC 83 E4 F8 83 EC 0C 8B C1 53 56", fire_event_intern);

    SET_PROXY("CBaseEntity->m_bSpotted", spotted);

    LOG_INFO("Hooks initialized.");

    auto example = dlls::client.get_import(dlls::tier0, "DevMsg"_hash);

    cache::initialize();
}

void hooks::end() noexcept
{
    for (auto a : interfaces::hooked_tables)
        static_cast<interface_holder<void*>*>(a)->restore();

    for (auto& a : hooked_fns)
        a.second.remove();

    netvars::unset_proxy("CBaseEntity->m_bSpotted"_hash, spotted::original);

    SetWindowLongPtr(game_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(original_wnd_proc));
}

```

`core/hooks.h`:

```h
#pragma once

#include <Windows.h>

#include "../valve/cs/cs.h"
#include "../valve/se/se.h"

#define DECLARE_HOOK(name, ret, base, ... /* args */) namespace name { \
using ty = ret(__thiscall*)(base* ecx, __VA_ARGS__); \
inline ty original; \
ret __fastcall fn(base* ecx, int, __VA_ARGS__); \
}

#define DECLARE_PROXY(name, prop_name) namespace name { \
inline cs::recv_proxy_fn original{ }; \
void proxy(cs::recv_proxy_data* data, void*, void*); \
}

namespace hooks {

    inline HWND game_window{ };
    inline WNDPROC original_wnd_proc{ };
    extern LRESULT CALLBACK wnd_proc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam);

    DECLARE_HOOK(level_init_post_entity, void, se::client_dll)
    DECLARE_HOOK(level_shutdown, void, se::client_dll)
    DECLARE_HOOK(create_move_proxy, void, se::client_dll, int, float, bool)
    DECLARE_HOOK(frame_stage_notify, void, se::client_dll, cs::frame_stage)
    DECLARE_HOOK(override_view, void, se::client_mode, cs::view_setup*)
    DECLARE_HOOK(get_viewmodel_fov, float, se::client_mode)
    DECLARE_HOOK(on_add_entity, void, se::entity_list, cs::handle_entity*, cs::base_handle)
    DECLARE_HOOK(on_remove_entity, void, se::entity_list, cs::handle_entity*, cs::base_handle)
    DECLARE_HOOK(fire_event_intern, bool, se::event_manager, cs::game_event*, bool, bool)
    DECLARE_HOOK(draw_model, void, se::studio_render, cs::draw_model_results*,
        const cs::draw_model_info&, mat3x4*, float*, float*, const vec3&, int)
    DECLARE_HOOK(lock_cursor, void, se::surface)
    DECLARE_HOOK(paint, void, se::vgui, cs::paint_mode)

    DECLARE_PROXY(spotted, "CBaseEntity->m_bSpotted")

}

#undef DECLARE_HOOK
#undef DECLARE_PROXY

```

`core/hooks/client_dll.cpp`:

```cpp
#include "../hooks.h"
#include "../features/cache.h"
#include "../features/features.h"

void __fastcall hooks::level_init_post_entity::fn(se::client_dll* ecx, int)
{
    cache::initialize();
    local.update();

    return original(ecx);
}

void __fastcall hooks::level_shutdown::fn(se::client_dll* ecx, int)
{
    cache::clear();
    local.reset();

    return original(ecx);
}

static void __stdcall create_move(int sequence_nr, float input_sample_time, bool is_active, bool& send_packet)
{
    hooks::create_move_proxy::original(interfaces::client, sequence_nr, input_sample_time, is_active);

    if (!interfaces::game_rules)
        interfaces::game_rules = **dlls::client.find(PATTERN("A1 ? ? ? ? 85 C0 0F 84 ? ? ? ? 80 B8 ? ? ? ? ? 74 7A"))
        .offset(0x1).cast<se::game_rules***>();

    if (!is_active || !send_packet)
        return;

    if (!local.update())
        return;

    auto cmd = &interfaces::input->cmds[sequence_nr % cs::multiplayer_backup];
    auto verified_cmd = &interfaces::input->verified_cmds[sequence_nr % cs::multiplayer_backup];
    if (!cmd || !verified_cmd)
        return;

    local.cur_cmd = cmd;

    if (cfg::get<bool>(vars::infinite_crouch))
        cmd->buttons.set(cs::cmd_button::bullrush);

    prediction::start(cmd);
    // aimbot::run(cmd);
    prediction::end();

    local.view = cmd->view_angles;

    verified_cmd->cmd = *cmd;
    verified_cmd->crc = cmd->get_checksum();
}

__declspec(naked) void __fastcall hooks::create_move_proxy::fn(se::client_dll* ecx, int, int sequence_nr,
    float input_sample_time, bool is_active)
{
    __asm {
        push ebp
        mov  ebp, esp

        push  ebx // send_packet
        push  esp
        push  dword ptr[ebp + 16]
        push  dword ptr[ebp + 12]
        push  dword ptr[ebp + 8]
        call  create_move
        pop   ebx

        pop   ebp
        ret   12
    }
}

void __fastcall hooks::frame_stage_notify::fn(se::client_dll* ecx, int, cs::frame_stage frame_stage)
{
    if (!local.in_game)
        return original(ecx, frame_stage);

    static auto override_postprocessing_disable = *dlls::client.find(PATTERN("83 EC 4C 80 3D")).offset(0x5).cast<bool**>();

    switch (frame_stage) {
    case cs::frame_stage::render_start:
        *override_postprocessing_disable = cfg::get<bool>(vars::disable_postprocessing);
        break;
    case cs::frame_stage::net_update_post_data_update_end:
        local.update();
        break;
    default:
        break;
    }

    return original(ecx, frame_stage);
}

```

`core/hooks/client_mode.cpp`:

```cpp
#include "../hooks.h"
#include "../features/features.h"

void __fastcall hooks::override_view::fn(se::client_mode* ecx, int, cs::view_setup* view)
{
    if (!local || !local.in_game)
        return original(ecx, view);

    if (!local->is_scoping())
        view->fov = cfg::get<float>(vars::fov);

    return original(ecx, view);
}

float __fastcall hooks::get_viewmodel_fov::fn(se::client_mode* ecx, int)
{
    if (!local || local->is_scoping())
        return original(ecx);

    return cfg::get<float>(vars::viewmodel_fov);
}

```

`core/hooks/entity_list.cpp`:

```cpp
#include "../hooks.h"
#include "../features/features.h"
#include "../features/cache.h"

void __fastcall hooks::on_add_entity::fn(se::entity_list* ecx, int, cs::handle_entity* handle_entity, cs::base_handle handle)
{
    auto unknown = reinterpret_cast<cs::unknown*>(handle_entity);
    auto base_entity = unknown->get_base_entity();
    if (base_entity)
        cache::add(base_entity);

    return original(ecx, handle_entity, handle);
}

void __fastcall hooks::on_remove_entity::fn(se::entity_list* ecx, int, cs::handle_entity* handle_entity, cs::base_handle handle)
{
    auto unknown = reinterpret_cast<cs::unknown*>(handle_entity);
    auto base_entity = unknown->get_base_entity();
    if (base_entity)
        cache::remove(base_entity);

    return original(ecx, handle_entity, handle);
}

```

`core/hooks/event_mgr.cpp`:

```cpp
#include "../hooks.h"
#include "../features/features.h"

bool __fastcall hooks::fire_event_intern::fn(se::event_manager* ecx, int, cs::game_event* evt, bool server, bool client)
{
    if (!evt)
        return original(ecx, evt, server, client);

    switch (fnv1a::hash(evt->get_name())) {
    case "bullet_impact"_hash:
        if (evt->get_int("userid") != interfaces::engine->get_local_player())
            break;

        auto start = local->get_abs_origin() + local->get_view_offset();
        start.z -= 5.0f; // For better visibility
        auto end = vec3{ evt->get_float("x"), evt->get_float("y"), evt->get_float("z") };

        cs::beam_info beam_info{ start, end, { 100, 0, 200, 255 }, 0.0f, 2.5f, cs::beam_flag::fade_out };
        auto beam = interfaces::render_beams->create_beam_points(&beam_info);
        interfaces::render_beams->draw_beam(beam);
        break;
    }

    return original(ecx, evt, server, client);
}

```

`core/hooks/proxies.cpp`:

```cpp
#include "../hooks.h"
#include "../netvars.h"
#include "../features/variables.h"

void hooks::spotted::proxy(cs::recv_proxy_data* data, void* arg0, void* arg1)
{
    if (cfg::get<bool>(vars::radar_reveal))
        data->value.integer = 1;

    return original(data, arg0, arg1);
}

```

`core/hooks/studio_render.cpp`:

```cpp
#include "../hooks.h"
#include "../features/features.h"

static auto create_material() noexcept
{
    // return interfaces::material_system->find_material("debug/debugambientcube");

    const auto kv = new cs::key_values[36];
    kv->init("VertexLitGeneric");
    kv->load_from_buffer("default.vmt", R"#("VertexLitGeneric" {
        "$basetexture"  "vgui/white_additive"
        "$ignorez"      "0"
        "$model"	"1"
        "$flat"		"0"
        "$nocull"	"1"
        "$halflambert"	"1"
        "$nofog"	"1"
        "$wireframe"	"0"
    })#");

    return interfaces::material_system->create_material("default.vmt", kv);
}

void __fastcall hooks::draw_model::fn(se::studio_render* ecx, int, cs::draw_model_results* results, const cs::draw_model_info& info,
    mat3x4* bone_to_world, float* flex_weights, float* flex_delayed_weights, const vec3& origin, int flags)
{
    if (!local || !local.in_game)
        return original(ecx, results, info, bone_to_world, flex_weights, flex_delayed_weights, origin, flags);

    if (!info.client_entity || ecx->is_forced_material_override())
        return original(ecx, results, info, bone_to_world, flex_weights, flex_delayed_weights, origin, flags);

    bool clear{ };
    const auto draw_chams = [&](const clr4& clr, bool occluded)
    {
        static auto material = create_material();
        material->set_flag(cs::material_flag::ignore_z, occluded);
        material->modulate(clr);
        ecx->forced_material_override(material);
        original(ecx, results, info, bone_to_world, flex_weights, flex_delayed_weights, origin, flags);
        clear = true;
    };

    auto unknown = info.client_entity->get_client_unknown();
    const auto class_id = unknown->get_networkable()->get_client_class()->id;
    if (class_id == cs::class_id::cs_player &&
        static_cast<cs::player*>(unknown->get_base_entity())->is_enemy()) {
        draw_chams({ 75, 75, 200, 255 }, true);
        draw_chams({ 200, 60, 60, 255 }, false);
    }

    original(ecx, results, info, bone_to_world, flex_weights, flex_delayed_weights, origin, flags);
    if (clear)
        interfaces::studio_render->forced_material_override(nullptr);
}

```

`core/hooks/surface.cpp`:

```cpp
#include "../hooks.h"
#include "../../render/menu/menu.h"

void __fastcall hooks::lock_cursor::fn(se::surface* ecx, int)
{
    return menu::is_open ? ecx->unlock_cursor() : original(ecx);
}

```

`core/hooks/vgui.cpp`:

```cpp
#include "../hooks.h"
#include "../features/features.h"
#include "../../render/menu/menu.h"

void __fastcall hooks::paint::fn(se::vgui* ecx, int, cs::paint_mode mode)
{
    [[maybe_unused]] static bool once = [] { return render::initialize(); }();

    if (ecx->static_transition_panel && has_bit(mode, cs::paint_mode::ui_panels)) {
        interfaces::surface->start_drawing();

        visuals::esp::run();
        menu::draw_watermark();
        menu::run();

        interfaces::surface->finish_drawing();
    }

    return original(ecx, mode);
}

```

`core/hooks/wnd_proc.cpp`:

```cpp
#include "../hooks.h"
#include "../cheat.h"
#include "../features/variables.h"
#include "../../render/menu/menu.h"

LRESULT CALLBACK hooks::wnd_proc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    input::process(msg, wparam, lparam);

    if (input::is_key_active({ VK_INSERT, input::key_type::toggle }))
        menu::toggle();

    if (input::is_key_active(cfg::get<keybind>(vars::panic_key)))
        cheat::should_unhook = true;

    interfaces::input_system->enable_input(!menu::is_open);

    return menu::is_open ? TRUE : CallWindowProcA(original_wnd_proc, wnd, msg, wparam, lparam);
}

```

`core/input.cpp`:

```cpp
#include <windowsx.h>

#include "input.h"
#include "../memory/interfaces.h"

bool input::is_key_active(keybind key) noexcept
{
    switch (key.type) {
    case key_type::always:
        return true;
    case key_type::hold:
        return key_states[key.code] == key_state::down ||
               key_states[key.code] == key_state::toggled;
    case key_type::release:
        return key_states[key.code] == key_state::up;
    case key_type::toggle:
        if (key_states[key.code] == key_state::toggled) {
            key_states[key.code] = key_state::up;
            return true;
        }
        return false;
    case key_type::off:
    default:
        return false;
    }
}

bool input::is_hovering_item(d2 item_pos, d2 item_size) noexcept
{
    return (mouse_pos.x >= item_pos.x && mouse_pos.y >= item_pos.y &&
        mouse_pos.x <= item_pos.x + item_size.x && mouse_pos.y <= item_pos.y + item_size.y);
}

void input::process(UINT msg, WPARAM wparam, LPARAM lparam) noexcept
{
    uint32_t key{ };
    key_state state{ };
    static key_state last_state{ };

    switch (msg) {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        key = wparam;
        state = key_state::down;
        break;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        key = wparam;
        state = key_state::up;
        break;
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
        key = VK_LBUTTON;
        state = msg == WM_LBUTTONUP ? key_state::up : key_state::down;
        break;
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
        key = VK_RBUTTON;
        state = msg == WM_RBUTTONUP ? key_state::up : key_state::down;
        break;
    case WM_MOUSEMOVE:
        mouse_pos = { GET_X_LPARAM(lparam), GET_Y_LPARAM(lparam) };
        break;
    default:
        return;
    }

    if (key_states[key] == key_state::up && state == key_state::down) {
        if (last_state == key_state::down)
            key_states[key] = key_state::down;
        else
            key_states[key] = key_state::toggled;
    }
    else
    	key_states[key] = state;

    last_state = state;
}

```

`core/input.h`:

```h
#pragma once

#include <array>
#include <Windows.h>
#ifdef small
#undef small
#endif

#include "../base/types/dimension.h"

namespace input {

    enum class key_state {
        up,
        down,
        toggled
    };

    enum class key_type {
        off,
        always,
        hold,
        toggle,
        release
    };

    struct keybind {
        uint32_t code{ };
        key_type type{ };

        constexpr keybind() noexcept = default;
        constexpr keybind(uint32_t code, key_type type) noexcept
            : code(code), type(type) { }
    };

    inline std::array<key_state, 255u> key_states{ };
    inline d2 mouse_pos{ };

    bool is_key_active(keybind key) noexcept;
    bool is_hovering_item(d2 item_pos, d2 item_size) noexcept;
    void process(UINT msg, WPARAM wparam, LPARAM lparam) noexcept;

}

using input::keybind;

```

`core/main.cpp`:

```cpp
#include "cheat.h"

static DWORD WINAPI on_attach(LPVOID);

BOOL APIENTRY DllMain(HMODULE instance, DWORD call_reason, LPVOID)
{
    if (call_reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(instance);
        if (const auto thread = CreateThread(nullptr, 0, on_attach, instance, 0, nullptr))
            CloseHandle(thread);
    }

    return TRUE;
}

static DWORD WINAPI on_attach(LPVOID instance)
{
    cheat::initialize();

    while (!cheat::should_unhook)
        std::this_thread::sleep_for(100ms);

    return cheat::end(instance);
}

```

`core/netvars.cpp`:

```cpp
#include "netvars.h"
#include "../memory/interfaces.h"
#include "../crypt/fnv1a.h"

void netvars::initialize() noexcept
{
    for (auto list = interfaces::client->get_all_classes(); list; list = list->next) {
        if (!list->recv_table)
            continue;

        dump_table(list->network_name, list->recv_table, 0);
    }
    LOG_INFO("Netvars initialized.");
}

void netvars::dump_table(std::string_view base_class, cs::recv_table* table, ptrdiff_t offset) noexcept
{
    for (int i{ }; i < table->prop_amt; i++) {
        const auto prop = &table->props[i];

        // Skip useless classes.
        if (isdigit(prop->var_name[0]) || fnv1a::hash(prop->var_name) == "baseclass"_hash)
            continue;

        // Follow to the next datatable, provided it has props.
        if (prop->data_table && prop->recv_type == cs::send_prop_type::dpt_datatable
            && prop->data_table->net_table_name[0] == 'D' && prop->data_table->prop_amt > 0)
            dump_table(base_class, prop->data_table, offset + prop->offset);

        const auto name = std::string(base_class.data()) + "->" + prop->var_name;
        const auto hash = fnv1a::hash(name);

        static std::fstream file{ "netvars.txt", std::fstream::out | std::fstream::trunc };
        if (file.good())
            file << name << '\n';

        var_map[hash] = std::make_pair(static_cast<uint32_t>(offset + prop->offset), prop);
    }
}

void netvars::set_proxy(hash_t name, cs::recv_proxy_fn proxy, cs::recv_proxy_fn& original) noexcept
{
    auto prop = var_map[name].second;
    original = prop->proxy_fn;
    prop->proxy_fn = proxy;
    LOG_SUCCESS("Set proxy for prop {}.", prop->var_name);
}

void netvars::unset_proxy(hash_t name, cs::recv_proxy_fn original) noexcept
{
    auto prop = var_map[name].second;
    prop->proxy_fn = original;
}

ptrdiff_t netvars::get_datamap_offset(cs::datamap* map, hash_t field_name) noexcept
{
    while (map) {
        for (int i{ }; i < map->data_fields_count; i++) {
            if (!map->data_description[i].field_name)
                continue;

            if (field_name == fnv1a::hash(map->data_description[i].field_name))
                return map->data_description[i].field_offset;

            // If we didn't find it, search recursively.
            if (map->data_description[i].type != cs::field_type::embedded ||
                !map->data_description[i].data_map)
                continue;

            const auto offset = get_datamap_offset(map->data_description[i].data_map, field_name);
            if (!offset)
                continue;

            return offset;
        }
        map = map->base_map;
    }
    return 0;
}

```

`core/netvars.h`:

```h
#pragma once

#include <unordered_map>

#include "../base/base.h"
#include "../crypt/fnv1a.h"
#include "../valve/cs/datatables.h"

#define SET_PROXY(name, fn) netvars::set_proxy(name##_hash, fn::proxy, fn::original)

namespace netvars {

    inline std::unordered_map<hash_t, std::pair<uint32_t, cs::recv_prop*>> var_map{ };

    void initialize() noexcept;
    void dump_table(std::string_view base_class, cs::recv_table* table, ptrdiff_t offset) noexcept;
    void set_proxy(hash_t name, cs::recv_proxy_fn proxy, cs::recv_proxy_fn& original) noexcept;
    void unset_proxy(hash_t name, cs::recv_proxy_fn original) noexcept;
    ptrdiff_t get_datamap_offset(cs::datamap* map, hash_t field_name) noexcept;

    inline hash_t get(hash_t hash) noexcept
    {
        return var_map[hash].first;
    };

}

#define NETVAR(name, type, var_name) NETVAR_OFFSET(name, type, var_name, 0)

#define NETVAR_OFFSET(name, type, var_name, offset) \
inline type& name() { \
    constexpr auto hash = fnv1a::hash(var_name); \
    return *reinterpret_cast<type*>(reinterpret_cast<uintptr_t>(this) + netvars::get(hash) + offset); \
}

#define PTR_NETVAR(name, type, var_name) PTR_NETVAR_OFFSET(name, type, var_name, 0)

#define PTR_NETVAR_OFFSET(name, type, var_name, offset) \
inline std::add_pointer_t<type> name() { \
    constexpr auto hash = fnv1a::hash(var_name); \
    return std::add_pointer_t<type>(reinterpret_cast<uintptr_t>(this) + netvars::get(hash) + offset); \
}

#define ARRAY_NETVAR(name, type, size, var_name) \
inline auto& name() { \
    constexpr auto hash = fnv1a::hash(var_name); \
    return *reinterpret_cast<std::add_pointer_t<std::array<type, size>>>(reinterpret_cast<uintptr_t>(this) + netvars::get(hash)); \
}

#define DATAMAP_FIELD(name, type, map, var_name) \
inline auto name() { \
    constexpr auto hash = fnv1a::hash(var_name); \
    static const auto offset = netvars::get_datamap_offset(map, hash); \
    return *reinterpret_cast<std::add_pointer_t<type>>(reinterpret_cast<uintptr_t>(this) + offset); \
}

#define PTR_DATAMAP_FIELD(name, type, map, var_name) \
inline auto name() { \
    constexpr auto hash = fnv1a::hash(var_name); \
    static const auto offset = netvars::get_datamap_offset(map, hash); \
    return reinterpret_cast<std::add_pointer_t<type>>(reinterpret_cast<uintptr_t>(this) + offset); \
}

#define OFFSET(name, type, diff) \
inline auto& name() { \
    return *reinterpret_cast<type*>(reinterpret_cast<uintptr_t>(this) + diff); \
}

#define PTR_OFFSET(name, type, diff) \
inline auto* name() { \
    return reinterpret_cast<type*>(reinterpret_cast<uintptr_t>(this) + diff); \
}

```

`crypt/crc32.h`:

```h
#pragma once

using crc32_t = uint32_t;

inline namespace crypt {

    namespace crc32 {

        template<class ty, size_t len = sizeof(ty)>
        void process_data(crc32_t& crc, const ty* data) noexcept
        {
            static constexpr crc32_t lookup_table[256]{
                0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
                0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
                0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
                0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
                0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
                0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
                0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
                0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
                0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
                0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
                0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
                0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
                0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
                0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
                0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
                0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
                0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
                0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
                0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
                0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
                0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
                0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
                0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
                0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
                0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
                0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
                0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
                0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
                0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
                0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
                0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
                0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
                0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
                0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
                0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
                0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
                0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
                0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
                0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
                0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
                0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
                0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
                0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
                0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
                0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
                0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
                0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
                0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
                0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
                0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
                0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
                0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
                0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
                0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
                0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
                0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
                0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
                0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
                0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
                0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
                0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
                0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
                0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
                0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
            };

            auto* byte = reinterpret_cast<const uint8_t*>(data);
            size_t n = len;
            while (n--)
                crc = (crc >> 8) ^ lookup_table[(crc & 0xff) ^ *byte++];
        }

    }

}

```

`crypt/fnv1a.h`:

```h
#pragma once

using hash_t = uint_fast32_t;

template<class ty>
concept string_like = requires(ty t) {
    t.data();
    t.substr();
};

inline namespace crypt {

    namespace fnv1a {

        constexpr hash_t basis = 0x811c9dc5;
        constexpr hash_t prime = 0x1000193;

        template<std::integral ch = char>
        constexpr hash_t hash(const ch* str) noexcept
        {
            const auto len = [str]() {
                size_t i{ };
                while (str[i])
                    i++;
                return i;
            }();

            auto hashed = basis;
            for (size_t i{ }; i < len; i++) {
                hashed ^= str[i];
                hashed *= prime;
            }
            return hashed;
        }

        template<string_like st = std::string_view>
        inline hash_t hash(const st& str) noexcept
        {
            return hash(str.data());
        }

        namespace literals {

            constexpr auto operator""_hash(const char* str, size_t len) noexcept
            {
                return hash(str);
            }

            constexpr auto operator""_hash(const wchar_t* str, size_t len) noexcept
            {
                return hash(str);
            }

        }

    }

}

using namespace fnv1a::literals;

```

`crypt/xorstr.h`:

```h
#pragma once

#include <array>
#include <string>
#include <utility>

inline namespace crypt {

    namespace xorstr_ {



    }

}

```

`csgo_internal_base.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="base\types\angle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\types\color.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\types\matrix.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\types\vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\base.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\logger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\math.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\winapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\input.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="crypt\fnv1a.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="crypt\xorstr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\address.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\dll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\iat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\interface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory\hook_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\cs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\cmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\types\bitfield.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\client_class.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\convar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\utl_vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\net.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\se.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\game_event.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\input_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\surface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\vgui2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\view.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\datatables.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\netvars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="render\menu\menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="render\render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\localize.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\trace.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\mem_alloc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="render\menu\controls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\features\events.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\features\features.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\cheat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\animations.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\key_values.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\model.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\material.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\features\variables.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\entity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="base\types\dimension.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\material_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\studio_render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\studio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\engine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\vstdlib.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\file_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\datacache.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\cs\leaf_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\vphysics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\steam\steam.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\server.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\se\matchmaking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\config.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\input.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory\interface.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="base\math.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="render\render.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="render\menu\menu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="render\menu\controls.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\netvars.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\cs\player.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\cs\entity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\features\prediction.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\features\misc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`csgo_internal_base.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "csgo_internal_base", "csgo_internal_base.vcxproj", "{723020FB-4470-440B-80E8-A0249CC3348B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{723020FB-4470-440B-80E8-A0249CC3348B}.Debug|x86.ActiveCfg = Debug|Win32
		{723020FB-4470-440B-80E8-A0249CC3348B}.Debug|x86.Build.0 = Debug|Win32
		{723020FB-4470-440B-80E8-A0249CC3348B}.Release|x86.ActiveCfg = Release|Win32
		{723020FB-4470-440B-80E8-A0249CC3348B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {716E0305-13B6-4390-AD4A-50820DAB3370}
	EndGlobalSection
EndGlobal

```

`csgo_internal_base.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`csgo_internal_base.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="packages\Microsoft.Windows.CppWinRT.2.0.210806.1\build\native\Microsoft.Windows.CppWinRT.props" Condition="Exists('packages\Microsoft.Windows.CppWinRT.2.0.210806.1\build\native\Microsoft.Windows.CppWinRT.props')" />
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="base\base.h" />
    <ClInclude Include="base\debug.h" />
    <ClInclude Include="base\logger.h" />
    <ClInclude Include="base\math.h" />
    <ClInclude Include="base\types\angle.h" />
    <ClInclude Include="base\types\bitfield.h" />
    <ClInclude Include="base\types\color.h" />
    <ClInclude Include="base\types\dimension.h" />
    <ClInclude Include="base\types\matrix.h" />
    <ClInclude Include="base\types\pattern.h" />
    <ClInclude Include="base\types\vector.h" />
    <ClInclude Include="base\winapi.h" />
    <ClInclude Include="core\config.h" />
    <ClInclude Include="core\cheat.h" />
    <ClInclude Include="core\features\cache.h" />
    <ClInclude Include="core\features\features.h" />
    <ClInclude Include="core\features\variables.h" />
    <ClInclude Include="core\hooks.h" />
    <ClInclude Include="core\input.h" />
    <ClInclude Include="core\netvars.h" />
    <ClInclude Include="crypt\crc32.h" />
    <ClInclude Include="crypt\fnv1a.h" />
    <ClInclude Include="crypt\xorstr.h" />
    <ClInclude Include="memory\address.h" />
    <ClInclude Include="memory\detour.h" />
    <ClInclude Include="memory\disasm\disasm.hh" />
    <ClInclude Include="memory\dll.h" />
    <ClInclude Include="memory\memory.h" />
    <ClInclude Include="memory\interfaces.h" />
    <ClInclude Include="memory\hook_mgr.h" />
    <ClInclude Include="render\menu\controls.h" />
    <ClInclude Include="render\menu\menu.h" />
    <ClInclude Include="render\render.h" />
    <ClInclude Include="valve\cs\animations.h" />
    <ClInclude Include="valve\cs\client_class.h" />
    <ClInclude Include="valve\cs\convar.h" />
    <ClInclude Include="valve\cs\cs.h" />
    <ClInclude Include="valve\cs\datatables.h" />
    <ClInclude Include="valve\cs\game_event.h" />
    <ClInclude Include="valve\cs\key_values.h" />
    <ClInclude Include="valve\cs\leaf_system.h" />
    <ClInclude Include="valve\cs\material.h" />
    <ClInclude Include="valve\cs\model.h" />
    <ClInclude Include="valve\cs\player.h" />
    <ClInclude Include="valve\cs\entity.h" />
    <ClInclude Include="valve\cs\studio.h" />
    <ClInclude Include="valve\cs\trace.h" />
    <ClInclude Include="valve\cs\cmd.h" />
    <ClInclude Include="valve\cs\util.h" />
    <ClInclude Include="valve\cs\utl_vector.h" />
    <ClInclude Include="valve\cs\view.h" />
    <ClInclude Include="valve\cs\world.h" />
    <ClInclude Include="valve\se\client.h" />
    <ClInclude Include="valve\se\datacache.h" />
    <ClInclude Include="valve\se\engine.h" />
    <ClInclude Include="valve\se\file_system.h" />
    <ClInclude Include="valve\se\matchmaking.h" />
    <ClInclude Include="valve\se\material_system.h" />
    <ClInclude Include="valve\se\tier0.h" />
    <ClInclude Include="valve\se\input_system.h" />
    <ClInclude Include="valve\se\localize.h" />
    <ClInclude Include="valve\se\net.h" />
    <ClInclude Include="valve\se\server.h" />
    <ClInclude Include="valve\se\vgui2.h" />
    <ClInclude Include="valve\se\studio_render.h" />
    <ClInclude Include="valve\se\surface.h" />
    <ClInclude Include="valve\se\vphysics.h" />
    <ClInclude Include="valve\se\vstdlib.h" />
    <ClInclude Include="valve\se\se.h" />
    <ClInclude Include="valve\steam\steam.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="base\math.cpp" />
    <ClCompile Include="core\config.cpp" />
    <ClCompile Include="core\features\misc.cpp" />
    <ClCompile Include="core\features\prediction.cpp" />
    <ClCompile Include="core\features\esp.cpp" />
    <ClCompile Include="core\hooks.cpp" />
    <ClCompile Include="core\hooks\client_dll.cpp" />
    <ClCompile Include="core\hooks\client_mode.cpp" />
    <ClCompile Include="core\hooks\entity_list.cpp" />
    <ClCompile Include="core\hooks\event_mgr.cpp" />
    <ClCompile Include="core\hooks\proxies.cpp" />
    <ClCompile Include="core\hooks\studio_render.cpp" />
    <ClCompile Include="core\hooks\surface.cpp" />
    <ClCompile Include="core\hooks\vgui.cpp" />
    <ClCompile Include="core\hooks\wnd_proc.cpp" />
    <ClCompile Include="core\input.cpp" />
    <ClCompile Include="core\netvars.cpp" />
    <ClCompile Include="core\main.cpp" />
    <ClCompile Include="memory\detour.cpp" />
    <ClCompile Include="memory\disasm\disasm.cc" />
    <ClCompile Include="memory\dll.cpp" />
    <ClCompile Include="memory\interfaces.cpp" />
    <ClCompile Include="render\menu\controls.cpp" />
    <ClCompile Include="render\menu\menu.cpp" />
    <ClCompile Include="render\render.cpp" />
    <ClCompile Include="valve\cs\entity.cpp" />
    <ClCompile Include="valve\cs\key_values.cpp" />
    <ClCompile Include="valve\cs\player.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{723020fb-4470-440b-80e8-a0249cc3348b}</ProjectGuid>
    <RootNamespace>csgo_internal_base</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)\bin\$(Configuration)\</OutDir>
    <IntDir>int\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)\bin\$(Configuration)\</OutDir>
    <IntDir>int\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgAutoLink>false</VcpkgAutoLink>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_HAS_EXCEPTIONS=0;WIN32;WIN32_LEAN_AND_MEAN;NOMINMAX;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ExceptionHandling>false</ExceptionHandling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_HAS_EXCEPTIONS=0;WIN32;WIN32_LEAN_AND_MEAN;NOMINMAX;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`csgo_internal_base.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`memory/address.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include "../base/debug.h"

struct address {
    uintptr_t value{ };

    address() = default;
    address(uintptr_t value) noexcept
        : value(value) { }
    address(uintptr_t* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(uint8_t* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(void* value) noexcept
        : value(reinterpret_cast<uintptr_t>(value)) { }
    address(std::nullptr_t value) noexcept
        : value(0) { }

    operator bool() const noexcept { return value != 0; }
    operator void*() noexcept { return reinterpret_cast<void*>(value); }

    template<class ty>
    constexpr ty cast() noexcept
    {
        ASSERT(value != 0);
        return reinterpret_cast<ty>(value);
    }

    constexpr address& offset(ptrdiff_t offset) noexcept
    {
        value += offset;
        return *this;
    }

    template<class ty>
    ty& dereference() noexcept
    {
        ASSERT(value != 0);
        return *reinterpret_cast<ty*>(value);
    }

    template<class ty>
    ty absolute(ptrdiff_t rel_offset = 0x1, ptrdiff_t abs_offset = 0x0) noexcept
    {
        ASSERT(value != 0);
        const auto jmp = value + rel_offset;
        const auto target = *reinterpret_cast<int32_t*>(jmp);
        if (target)
            // Base address + offset + size of next instruction + target address.
            return reinterpret_cast<ty>(jmp + abs_offset + 4 + target);
        return ty();
    }
};

```

`memory/detour.cpp`:

```cpp
#include "disasm/disasm.hh"
#include "detour.h"
#include "memory.h"

static constexpr uint8_t jmp_rel = 0xe9;
static constexpr size_t jmp_size = 5;

static bool is_page_rwx(void* addr) noexcept
{
    MEMORY_BASIC_INFORMATION mem_info{ };
    return (VirtualQuery(addr, &mem_info, sizeof(mem_info)) &&
            mem_info.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY));
}

static void set_jmp(void* dst, void* src) noexcept
{
    auto ptr = static_cast<uint8_t*>(src);
    *ptr = jmp_rel;
    *reinterpret_cast<uintptr_t*>(ptr + 1) = reinterpret_cast<uintptr_t>(dst) - reinterpret_cast<uintptr_t>(ptr) - jmp_size;
}

bool detour::hook::set(bool enable) noexcept
{
    if (!memory::is_address_valid(target) || !memory::is_address_valid(hook_fn))
        return false;

    if (!is_page_rwx(target))
        return false;

    static constexpr size_t max_trampoline_size = 40;
    memory::virtual_alloc trampoline_mem{ max_trampoline_size, PAGE_EXECUTE_READWRITE };
    trampoline = trampoline_mem.address;
    if (!trampoline)
        return false;

    auto target = static_cast<uint8_t*>(this->target);
    disasm::u32 size{ };
    while (size < jmp_size) {
        auto insn = disasm::disasm(target + size);
        size += insn.length;
        if (insn.error() || !insn.length || size >= max_trampoline_size)
            return false;
    }
    std::copy(target, target + size, static_cast<uint8_t*>(trampoline));
    std::copy(target, target + jmp_size, real_bytes.data());
    set_jmp(target + size, static_cast<uint8_t*>(trampoline) + size);

    trampoline_mem.free = false;
    *original = trampoline;

    if (enable)
        this->enable();

    return true;
}

void detour::hook::enable() noexcept
{
    memory::virtual_protect vp{ target, jmp_size, PAGE_EXECUTE_READWRITE };
    set_jmp(hook_fn, target);
}

void detour::hook::disable() noexcept
{
    memory::virtual_protect vp{ target, jmp_size, PAGE_EXECUTE_READWRITE };
    std::ranges::copy(real_bytes, static_cast<uint8_t*>(target));
}

void detour::hook::remove() noexcept
{
    disable();
    VirtualFree(trampoline, 0, MEM_RELEASE);
}

```

`memory/detour.h`:

```h
#pragma once

#include <array>

namespace detour {

    class hook {
    public:
        explicit hook(void* target, void* detour, void** original) noexcept
            : target(target), hook_fn(detour), original(original) { }

        bool set(bool enable = true) noexcept;
        void enable() noexcept;
        void disable() noexcept;
        void remove() noexcept;

    private:
        void* target{ };
        void* hook_fn{ };
        void** original{ };
        void* trampoline{ };
        std::array<uint8_t, 5> real_bytes{ };
    };

}

```

`memory/disasm/disasm.cc`:

```cc
#include "disasm.hh"

#define MODRM_RM(byte)  ((u8)byte & 0b111)
#define MODRM_REG(byte) (((u8)byte >> 3) & 0b111)
#define MODRM_MOD(byte) (((u8)byte >> 6) & 0b11)

#define SIB_BASE(byte)  ((u8)byte & 0b111)
#define SIB_INDEX(byte) (((u8)byte >> 3) & 0b111)
#define SIB_SCALE(byte) (((u8)byte >> 6) & 0b11)

/* TODO:
*  error on bad operand size if only one size allowed
*  3 byte opcodes
*  add some missing ring 3 instructions
*  support x87, sse, avx instructions?
*  mark default sregs (pop ds etc)
*  add flag for mem [addr] instead of mem [reg]
*/

using enum disasm::operand_type;

namespace disasm {

struct decoder {
    bool parse_prefixes(u32& pref);
    void parse_modrm(insn& ins, u8& reg_op, u8& reg_op2, u8 byte);
    void parse_imm_args(operand& op, bool op_16b);

    inline void advance(u32 n = 1)
    {
        code += n;
        pos += n;
    }

    u8* code{};
    u32 pos{};
};

constexpr static auto no_mod(u8 b1, u8 b2, operand_type t1 = none, operand_type t2 = none)
{
    return insn(b1, b2, 0, t1, t2, none, insn_no_mod);
}

constexpr static auto reg_ext(u8 b1, u8 b2, operand_type t1 = none, operand_type t2 = none,
    operand_type t3 = none)
{
    return insn(b1, b2, 0, t1, t2, t3, insn_reg_ext);
}

constexpr static auto digit(u8 b1, u8 b2, u32 d, operand_type t1 = none, operand_type t2 = none)
{
    return insn(b1, b2, 0, t1, t2, none, d);
}

/* Instructions without a modrm byte. */
static const insn no_mod_tbl[]{
    no_mod(/* "aaa", */ 0x37, 0x00),                           // aaa
    no_mod(/* "aad", */ 0xd5, 0x0a),                           // aad
    no_mod(/* "aam", */ 0xd4, 0x0a),                           // aam
    no_mod(/* "aas", */ 0x3f, 0x00),                           // aas
    no_mod(/* "adc", */ 0x14, 0x00, al, imm8),                 // adc al, imm8
    no_mod(/* "adc", */ 0x15, 0x00, eax, imm16_32),            // adc (e)ax, imm{16,32}
    no_mod(/* "add", */ 0x04, 0x00, al, imm8),                 // add al, imm8
    no_mod(/* "add", */ 0x05, 0x00, eax, imm16_32),            // add (e)ax, imm{16,32}
    no_mod(/* "and", */ 0x24, 0x00, al, imm8),                 // and al, imm8
    no_mod(/* "and", */ 0x25, 0x00, eax, imm16_32),            // and (e)ax, imm{16,32}
    no_mod(/* "bswap", */ 0x0f, 0xc8, builtin32),              // bswap reg32
    no_mod(/* "call", */ 0xe8, 0x00, imm16_32),                // call near rel{16,32}
    no_mod(/* "cwde", */ 0x98, 0x00),                          // cwde
    no_mod(/* "cdq", */ 0x99, 0x00),                           // cdq
    no_mod(/* "clc", */ 0xf8, 0x00),                           // clc
    no_mod(/* "cld", */ 0xfc, 0x00),                           // cld
    no_mod(/* "cmc", */ 0xf5, 0x00),                           // cmc
    no_mod(/* "cmp", */ 0x3c, 0x00, al, imm8),                 // cmp al, imm8
    no_mod(/* "cmp", */ 0x3d, 0x00, eax, imm16_32),            // cmp (e)ax, imm{16,32}
    no_mod(/* "cmpsb", */ 0xa6, 0x00),                         // cmpsb
    no_mod(/* "cmpsd", */ 0xa7, 0x00),                         // cmps{d,w}
    no_mod(/* "cpuid", */ 0x0f, 0xa2),                         // cpuid
    no_mod(/* "daa", */ 0x27, 0x00),                           // daa
    no_mod(/* "das", */ 0x2f, 0x00),                           // das
    no_mod(/* "dec", */ 0x48, 0x00, builtin16_32),             // dec reg{16,32}
    no_mod(/* "in", */ 0xe4, 0x00, al, imm8),                  // in al, imm8
    no_mod(/* "in", */ 0xe5, 0x00, eax, imm16_32),             // in (e)ax, imm{16,32}
    no_mod(/* "in", */ 0xec, 0x00, al, dx),                    // in al, dx
    no_mod(/* "in", */ 0xed, 0x00, eax, dx),                   // in (e)ax, dx
    no_mod(/* "inc", */ 0x40, 0x00, builtin16_32),             // inc reg{16,32}
    no_mod(/* "insb", */ 0x6c, 0x00),                          // ins [edi], dx
    no_mod(/* "insd", */ 0x6d, 0x00),                          // ins{d,w} [edi], dx
    no_mod(/* "int", */ 0xcd, 0x00, imm8),                     // int imm8
    no_mod(/* "int 3", */ 0xcc, 0x00),                         // int 3
    no_mod(/* "into", */ 0xce, 0x00),                          // into
    no_mod(/* "jo", */ 0x70, 0x00, imm8),                      // jo rel8off
    no_mod(/* "jo", */ 0x0f, 0x80, imm16_32),                  // jo rel{16,32}off
    no_mod(/* "jno", */ 0x71, 0x00, imm8),                     // jno rel8off
    no_mod(/* "jno", */ 0x0f, 0x81, imm16_32),                 // jno rel{16,32}off
    no_mod(/* "jb", */ 0x72, 0x00, imm8),                      // jb/jc/jnae rel8off
    no_mod(/* "jb", */ 0x0f, 0x82, imm16_32),                  // jb/jc/jnae rel{16,32}off
    no_mod(/* "jae", */ 0x73, 0x00, imm8),                     // jae/jnb/jnc rel8off
    no_mod(/* "jae", */ 0x0f, 0x83, imm16_32),                 // jae/jnb/jnc rel{16,32}off
    no_mod(/* "je", */ 0x74, 0x00, imm8),                      // je/jz rel8off
    no_mod(/* "je", */ 0x0f, 0x84, imm16_32),                  // je/jz rel{16,32}off
    no_mod(/* "jne", */ 0x75, 0x00, imm8),                     // jne/jnz rel8off
    no_mod(/* "jne", */ 0x0f, 0x85, imm16_32),                 // jne/jnz rel{16,32}off
    no_mod(/* "jbe", */ 0x76, 0x00, imm8),                     // jbe rel8off
    no_mod(/* "jbe", */ 0x0f, 0x86, imm16_32),                 // jbe rel{16,32}off
    no_mod(/* "ja", */ 0x77, 0x00, imm8),                      // ja/jnbe rel8off
    no_mod(/* "ja", */ 0x0f, 0x87, imm16_32),                  // ja/jnbe rel{16,32}off
    no_mod(/* "js", */ 0x78, 0x00, imm8),                      // js rel8off
    no_mod(/* "js", */ 0x0f, 0x88, imm16_32),                  // js rel{16,32}off
    no_mod(/* "jns", */ 0x79, 0x00, imm8),                     // jns rel8off
    no_mod(/* "jns", */ 0x0f, 0x89, imm16_32),                 // jns rel{16,32}off
    no_mod(/* "jp", */ 0x7a, 0x00, imm8),                      // jp/jpe rel8off
    no_mod(/* "jp", */ 0x0f, 0x8a, imm16_32),                  // jp/jpe rel{16,32}off
    no_mod(/* "jnp", */ 0x7b, 0x00, imm8),                     // jnp/jpo rel8off
    no_mod(/* "jnp", */ 0x0f, 0x8b, imm16_32),                 // jnp/jpo rel{16,32}off
    no_mod(/* "jl", */ 0x7c, 0x00, imm8),                      // jl/jnge rel8off
    no_mod(/* "jl", */ 0x0f, 0x8c, imm16_32),                  // jl/jnge rel{16,32}off
    no_mod(/* "jge", */ 0x7d, 0x00, imm8),                     // jge/jnl rel8off
    no_mod(/* "jge", */ 0x0f, 0x8d, imm16_32),                 // jge/jnl rel{16,32}off
    no_mod(/* "jle", */ 0x7e, 0x00, imm8),                     // jle/jng rel8off
    no_mod(/* "jle", */ 0x0f, 0x8e, imm16_32),                 // jle/jng rel{16,32}off
    no_mod(/* "jg", */ 0x7f, 0x00, imm8),                      // jg/jnle rel8off
    no_mod(/* "jg", */ 0x0f, 0x8f, imm16_32),                  // jg/jnle rel{16,32}off
    no_mod(/* "jmp", */ 0xeb, 0x00, imm8),                     // jmp near rel8off
    no_mod(/* "jmp", */ 0xe9, 0x00, imm16_32),                 // jmp near rel{16,32}off
    no_mod(/* "lahf", */ 0x9f, 0x00),                          // lahf
    no_mod(/* "leave", */ 0xc9, 0x00),                         // leave
    no_mod(/* "lodsb", */ 0xac, 0x00, mem8),                   // lods mem8
    no_mod(/* "lodsd", */ 0xad, 0x00, mem16_32),               // lods{d,w} mem{16,32}
    no_mod(/* "mov", */ 0xa0, 0x00, al, m_off),                // mov al, moffset8
    no_mod(/* "mov", */ 0xa1, 0x00, eax, m_off),               // mov (e)ax, moffset{16,32}
    no_mod(/* "mov", */ 0xa2, 0x00, m_off, al),                // mov moffset8, al
    no_mod(/* "mov", */ 0xa3, 0x00, m_off, eax),               // mov moffset{16,32}, (e)ax
    no_mod(/* "mov", */ 0xb0, 0x00, builtin8, imm8),           // mov reg8, imm8
    no_mod(/* "mov", */ 0xb8, 0x00, builtin16_32, imm16_32),   // mov reg{16,32}, imm{16,32}
    no_mod(/* "movsb", */ 0xa4, 0x00, mem8, mem8),             // movsb mem8, mem8
    no_mod(/* "movsd", */ 0xa5, 0x00),                         // movs{d,w} mem{16,32}, mem{16,32}
    no_mod(/* "nop", */ 0x90, 0x00),                           // nop
    no_mod(/* "or", */ 0x0c, 0x00, al, imm8),                  // or al, imm8
    no_mod(/* "or", */ 0x0d, 0x00, eax, imm16_32),             // or (e)ax, imm{16,32}
    no_mod(/* "out", */ 0xe6, 0x00, imm8, al),                 // out imm8, al
    no_mod(/* "out", */ 0xe7, 0x00, imm8, eax),                // out imm8, (e)ax
    no_mod(/* "out", */ 0xee, 0x00, dx, al),                   // out dx, al
    no_mod(/* "out", */ 0xef, 0x00, dx, eax),                  // out dx, (e)ax
    no_mod(/* "outsb", */ 0x6e, 0x00),                         // outsb
    no_mod(/* "outsd", */ 0x6f, 0x00),                         // outs{d,w}
    no_mod(/* "pause", */ 0xf3, 0x90),                         // pause
    no_mod(/* "pop", */ 0x58, 0x00, builtin16_32),             // pop reg{16,32}
    no_mod(/* "pop ds", */ 0x1f, 0x00),                        // pop ds
    no_mod(/* "pop es", */ 0x07, 0x00),                        // pop es
    no_mod(/* "pop ss", */ 0x17, 0x00),                        // pop ss
    no_mod(/* "pop fs", */ 0x0f, 0xa1),                        // pop fs
    no_mod(/* "pop gs", */ 0x0f, 0xa9),                        // pop gs
    no_mod(/* "popad", */ 0x61, 0xa9),                         // popa(d)
    no_mod(/* "popfd", */ 0x9d, 0x00),                         // popf(d)
    no_mod(/* "push", */ 0x50, 0x00, builtin16_32),            // push reg{16,32}
    no_mod(/* "push", */ 0x6a, 0x00, imm8),                    // push imm8
    no_mod(/* "push", */ 0x68, 0x00, imm16_32),                // push imm{16,32}
    no_mod(/* "push cs", */ 0x0e, 0x00),                       // push cs
    no_mod(/* "push ss", */ 0x16, 0x00),                       // push ss
    no_mod(/* "push ds", */ 0x1e, 0x00),                       // push ds
    no_mod(/* "push es", */ 0x06, 0x00),                       // push es
    no_mod(/* "push fs", */ 0x0f, 0xa0),                       // push fs
    no_mod(/* "push gs", */ 0x0f, 0xa8),                       // push gs
    no_mod(/* "pushad", */ 0x60, 0x00),                        // pushad/pusha
    no_mod(/* "pushfd", */ 0x9c, 0x00),                        // pushfd/pushf
    no_mod(/* "rdtsc", */ 0x0f, 0x31),                         // rdtsc
    no_mod(/* "ret", */ 0xc3, 0x00),                           // ret
    no_mod(/* "ret", */ 0xc2, 0x00, imm16),                    // ret imm16
    no_mod(/* "retf", */ 0xcb, 0x00),                          // retf
    no_mod(/* "retf", */ 0xca, 0x00, imm16),                   // retf imm16
    no_mod(/* "sahf", */ 0x9e, 0x00),                          // sahf
    no_mod(/* "sal", */ 0x1c, 0x00, al, imm8),                 // sbb al, imm8
    no_mod(/* "sbb", */ 0x1d, 0x00, eax, imm8),                // sbb (e)ax, imm{16,32}
    no_mod(/* "scasb", */ 0xae, 0x00),                         // scasb
    no_mod(/* "scasd", */ 0xaf, 0x00),                         // scas{d,w}
    no_mod(/* "stc", */ 0xf9, 0x00),                           // stc
    no_mod(/* "std", */ 0xfd, 0x00),                           // std
    no_mod(/* "stosb", */ 0xaa, 0x00),                         // stosb
    no_mod(/* "stosd", */ 0xab, 0x00),                         // stos{d,w}
    no_mod(/* "sub", */ 0x2c, 0x00, al, imm8),                 // sub al, imm8
    no_mod(/* "sub", */ 0x2d, 0x00, eax, imm16_32),            // sub (e)ax, imm{16,32}
    no_mod(/* "test", */ 0xa8, 0x00, al, imm8),                // test al, imm8
    no_mod(/* "test", */ 0xa9, 0x00, eax, imm16_32),           // test (e)ax, imm{16,32}
    no_mod(/* "ud0", */ 0x0f, 0xff),                           // ud0
    no_mod(/* "ud2", */ 0x0f, 0x0b),                           // ud2
    no_mod(/* "xchg", */ 0x90, 0x00, eax, reg16_32),           // xchg (e)ax, reg{16,32}
    no_mod(/* "xlatb", */ 0xd7, 0x00),                         // xlatb
    no_mod(/* "xor", */ 0x34, 0x00, al, imm8),                 // xor al, imm8
    no_mod(/* "xor", */ 0x35, 0x00, eax, imm16_32),            // xor al, imm{16,32}
};

/* /0-7 instructions. */
static const insn ext_tbl[]{
    digit(/* "adc", */ 0x80, 0x00, 2, rm8, imm8),             // adc r/m8, imm8
    digit(/* "adc", */ 0x81, 0x00, 2, imm16_32, imm16_32),    // adc r/m{16,32}, imm{16,32}
    digit(/* "adc", */ 0x83, 0x00, 2, rm16_32, imm8),         // adc r/m{16,32}, imm8
    digit(/* "add", */ 0x80, 0x00, 0, rm8, imm8),             // add r/m8, imm8
    digit(/* "add", */ 0x81, 0x00, 0, rm16_32, imm16_32),     // add r/m{16,32}, imm{16,32}
    digit(/* "add", */ 0x83, 0x00, 0, rm16_32, imm8),         // add r/m{16,32}, imm8
    digit(/* "and", */ 0x80, 0x00, 4, rm8, imm8),             // and r/m8, imm8
    digit(/* "and", */ 0x81, 0x00, 4, rm16_32, imm16_32),     // and r/m{16,32}, imm{16,32}
    digit(/* "and", */ 0x83, 0x00, 4, rm16_32, imm8),         // and r/m{16,32}, imm8
    digit(/* "bt", */ 0x0f, 0xba, 4, rm16_32, imm8),          // bt r/m{16,32}, imm8
    digit(/* "btc", */ 0x0f, 0xba, 7, rm16_32, imm8),         // bts r/m{16,32}, imm8
    digit(/* "btr", */ 0x0f, 0xba, 6, rm16_32, imm8),         // btr r/m{16,32}, imm8
    digit(/* "bts", */ 0x0f, 0xba, 5, rm16_32, imm8),         // bts r/m{16,32}, imm8
    digit(/* "call", */ 0xff, 0x00, 2, rm16_32),              // call near r/m{16,32}
    digit(/* "cmp", */ 0x80, 0x00, 7, rm8, imm8),             // cmp r/m8, imm8
    digit(/* "cmp", */ 0x81, 0x00, 7, rm16_32, imm16_32),     // cmp r/m{16,32}, imm{16,32}
    // add signed operand_type?
    digit(/* "cmp", */ 0x83, 0x00, 7, rm16_32, imm16_32),     // cmp r/m{16,32}, imm{16,32} (signed)
    digit(/* "dec", */ 0xfe, 0x00, 1, rm8),                   // dec r/m8
    digit(/* "dec", */ 0xff, 0x00, 1, rm16_32),               // dec r/m{16,32}
    digit(/* "div", */ 0xf6, 0x00, 6, rm8),                   // div r/m8
    digit(/* "div", */ 0xf7, 0x00, 6, rm16_32),               // div r/m{16,32}
    digit(/* "idiv", */ 0xf6, 0x00, 7, rm8),                  // idiv r/m8
    digit(/* "idiv", */ 0xf7, 0x00, 7, rm16_32),              // idiv r/m{16,32}
    digit(/* "imul", */ 0xf6, 0x00, 5, rm8),                  // imul r/m8
    digit(/* "imul", */ 0xf7, 0x00, 5, rm16_32),              // imul r/m{16,32}
    digit(/* "inc", */ 0xfe, 0x00, 0, rm8),                   // inc r/m8
    digit(/* "inc", */ 0xff, 0x00, 0, rm16_32),               // inc r/m{16,32}
    digit(/* "jmp", */ 0xff, 0x00, 4, rm16_32),               // jmp r/m{16,32}
    digit(/* "mov", */ 0xc6, 0x00, 0, rm8, imm8),             // mov r/m8, imm8
    digit(/* "mov", */ 0xc7, 0x00, 0, rm16_32, imm16_32),     // mov r/m{16,32}, imm{16,32}
    digit(/* "mul", */ 0xf6, 0x00, 4, al, rm8),               // mul al, r/m8
    digit(/* "mul", */ 0xf7, 0x00, 4, ax, rm16_32),           // mul ax, r/m16
    digit(/* "neg", */ 0xf6, 0x00, 3, rm8),                   // neg r/m8
    digit(/* "neg", */ 0xf7, 0x00, 3, rm16_32),               // neg r/m{16,32}
    digit(/* "nop", */ 0x0f, 0x1f, 0, rm16),                  // nop r/m16
    digit(/* "nop", */ 0x0f, 0x1f, 0, rm16_32),               // nop r/m{16,32}
    digit(/* "not", */ 0xf6, 0x00, 2, rm8),                   // not r/m8
    digit(/* "not", */ 0xf7, 0x00, 2, rm16_32),               // not r/m{16,32}
    digit(/* "or", */ 0x80, 0x00, 1, rm8, imm8),              // or r/m8, imm8
    digit(/* "or", */ 0x81, 0x00, 1, rm16_32, imm16_32),      // or r/m{16,32}, imm{16,32}
    digit(/* "or", */ 0x83, 0x00, 1, rm16_32, imm8),          // or r/m{16,32}, imm8
    digit(/* "pop", */ 0x8f, 0x00, 0, rm16_32),               // pop r/m{16,32}
    digit(/* "push", */ 0xff, 0x00, 0, rm16_32),              // push r/m{16,32}
    digit(/* "rcl", */ 0xd0, 0x00, 2, rm8),                   // rcl r/m8, 1
    digit(/* "rcl", */ 0xd2, 0x00, 2, rm8, cl),               // rcl r/m8, cl
    digit(/* "rcl", */ 0xc0, 0x00, 2, rm8, imm8),             // rcl r/m8, imm8
    digit(/* "rcl", */ 0xd1, 0x00, 2, rm16_32),               // rcl r/m{16,32}, 1
    digit(/* "rcl", */ 0xd3, 0x00, 2, rm16_32, cl),           // rcl r/m{16,32}, cl
    digit(/* "rcl", */ 0xc1, 0x00, 2, rm16_32, imm8),         // rcl r/m{16,32}, imm8
    digit(/* "rcr", */ 0xd0, 0x00, 3, rm8),                   // rcr r/m8, 1
    digit(/* "rcr", */ 0xd2, 0x00, 3, rm8, cl),               // rcr r/m8, cl
    digit(/* "rcr", */ 0xc0, 0x00, 3, rm8, imm8),             // rcr r/m8, imm8
    digit(/* "rcr", */ 0xd1, 0x00, 3, rm16_32),               // rcr r/m{16,32}, 1
    digit(/* "rcr", */ 0xd3, 0x00, 3, rm16_32, cl),           // rcr r/m{16,32}, cl
    digit(/* "rcr", */ 0xc1, 0x00, 3, rm16_32, imm8),         // rcr r/m{16,32}, imm8
    digit(/* "rdrand", */ 0x0f, 0xc7, 6, reg16_32),           // rdrand reg{16,32}
    digit(/* "rdseed", */ 0x0f, 0xc7, 7, reg16_32),           // rdseed reg{16,32}
    digit(/* "rol", */ 0xd0, 0x00, 0, rm8),                   // rol r/m8, 1
    digit(/* "rol", */ 0xd2, 0x00, 0, rm8, cl),               // rol r/m8, cl
    digit(/* "rol", */ 0xc0, 0x00, 0, rm8, imm8),             // rol r/m8, imm8
    digit(/* "rol", */ 0xd1, 0x00, 0, rm16_32),               // rol r/m{16,32}, 1
    digit(/* "rol", */ 0xd3, 0x00, 0, rm16_32, cl),           // rol r/m{16,32}, cl
    digit(/* "rol", */ 0xc1, 0x00, 0, rm16_32, imm8),         // rol r/m{16,32}, imm8
    digit(/* "ror", */ 0xd0, 0x00, 1, rm8),                   // ror r/m8, 1
    digit(/* "ror", */ 0xd2, 0x00, 1, rm8, cl),               // ror r/m8, cl
    digit(/* "ror", */ 0xc0, 0x00, 1, rm8, imm8),             // ror r/m8, imm8
    digit(/* "ror", */ 0xd1, 0x00, 1, rm16_32),               // ror r/m{16,32}, 1
    digit(/* "ror", */ 0xd3, 0x00, 1, rm16_32, cl),           // ror r/m{16,32}, cl
    digit(/* "ror", */ 0xc1, 0x00, 1, rm16_32, imm8),         // ror r/m{16,32}, imm8
    digit(/* "sal", */ 0xd0, 0x00, 4, rm8),                   // sal r/m8, 1
    digit(/* "sal", */ 0xd2, 0x00, 4, rm8, cl),               // sal r/m8, cl
    digit(/* "sal", */ 0xc0, 0x00, 4, rm8, imm8),             // sal r/m8, imm8
    digit(/* "sal", */ 0xd1, 0x00, 4, rm16_32),               // sal r/m{16,32}, 1
    digit(/* "sal", */ 0xd3, 0x00, 4, rm16_32, cl),           // sal r/m{16,32}, cl
    digit(/* "sal", */ 0xc1, 0x00, 4, rm16_32, imm8),         // sal r/m{16,32}, imm8
    digit(/* "sar", */ 0xd0, 0x00, 7, rm8),                   // sar r/m8, 1
    digit(/* "sar", */ 0xd2, 0x00, 7, rm8, cl),               // sar r/m8, cl
    digit(/* "sar", */ 0xc0, 0x00, 7, rm8, imm8),             // sar r/m8, imm8
    digit(/* "sar", */ 0xd1, 0x00, 7, rm16_32),               // sar r/m{16,32}, 1
    digit(/* "sar", */ 0xd3, 0x00, 7, rm16_32, cl),           // sar r/m{16,32}, cl
    digit(/* "sar", */ 0xc1, 0x00, 7, rm16_32, imm8),         // sar r/m{16,32}, imm8
    digit(/* "sbb", */ 0x80, 0x00, 3, rm8, imm8),             // sbb r/m8, imm8
    digit(/* "sbb", */ 0x81, 0x00, 3, rm16_32, imm16_32),     // sbb r/m{16,32}, imm{16,32}
    digit(/* "sbb", */ 0x83, 0x00, 3, rm16_32, imm8),         // sbb r/m{16,32}, imm8
    digit(/* "seto", */ 0x0f, 0x90, 0, rm8),                  // seto r/m8
    digit(/* "setno", */ 0x0f, 0x91, 0, rm8),                 // setno r/m8
    digit(/* "setb", */ 0x0f, 0x92, 0, rm8),                  // setb r/m8
    digit(/* "setae", */ 0x0f, 0x93, 0, rm8),                 // setae r/m8
    digit(/* "sete", */ 0x0f, 0x94, 0, rm8),                  // sete r/m8
    digit(/* "setne", */ 0x0f, 0x95, 0, rm8),                 // setne r/m8
    digit(/* "setbe", */ 0x0f, 0x96, 0, rm8),                 // setbe r/m8
    digit(/* "seta", */ 0x0f, 0x97, 0, rm8),                  // seta r/m8
    digit(/* "sets", */ 0x0f, 0x98, 0, rm8),                  // sets r/m8
    digit(/* "setns", */ 0x0f, 0x99, 0, rm8),                 // setns r/m8
    digit(/* "setp", */ 0x0f, 0x9a, 0, rm8),                  // setp r/m8
    digit(/* "setnp", */ 0x0f, 0x9b, 0, rm8),                 // setnp r/m8
    digit(/* "setl", */ 0x0f, 0x9c, 0, rm8),                  // setl r/m8
    digit(/* "setge", */ 0x0f, 0x9d, 0, rm8),                 // setge r/m8
    digit(/* "setle", */ 0x0f, 0x9e, 0, rm8),                 // setle r/m8
    digit(/* "setg", */ 0x0f, 0x9f, 0, rm8),                  // setg r/m8
    digit(/* "shr", */ 0xd0, 0x00, 7, rm8),                   // shr r/m8, 1
    digit(/* "shr", */ 0xd2, 0x00, 5, rm8, cl),               // shr r/m8, cl
    digit(/* "shr", */ 0xc0, 0x00, 5, rm8, imm8),             // shr r/m8, imm8
    digit(/* "shr", */ 0xd1, 0x00, 5, rm16_32),               // shr r/m{16,32}, 1
    digit(/* "shr", */ 0xd3, 0x00, 5, rm16_32, cl),           // shr r/m{16,32}, cl
    digit(/* "shr", */ 0xc1, 0x00, 5, rm16_32, imm8),         // shr r/m{16,32}, imm8
    digit(/* "sub", */ 0x80, 0x00, 5, rm8, imm8),             // sub r/m8, imm8
    digit(/* "sub", */ 0x81, 0x00, 5, rm16_32, imm16_32),     // sub r/m{16,32}, imm{16,32}
    digit(/* "sub", */ 0x83, 0x00, 5, rm16_32, imm8),         // sub r/m{16,32}, imm8
    digit(/* "test", */ 0xf6, 0x00, 0, rm8, imm8),            // test r/m8, imm8
    digit(/* "test", */ 0xf7, 0x00, 0, rm16_32, imm16_32),    // test r/m{16,32}, imm{16,32}
    digit(/* "xor", */ 0x80, 0x00, 6, rm8, imm8),             // xor r/m8, imm8
    digit(/* "xor", */ 0x81, 0x00, 6, rm16_32, imm16_32),     // xor r/m{16,32}, imm{16,32}
    digit(/* "xor", */ 0x83, 0x00, 6, rm16_32, imm8),         // xor r/m{16,32}, imm8
};

/* /r instructions. */
static const insn reg_ext_tbl[]{
    reg_ext(/* "adc", */ 0x10, 0x00, rm8, reg8),                    // adc r/m8, reg8
    reg_ext(/* "adc", */ 0x11, 0x00, rm16_32, reg16_32),            // adc r/m{16,32}, reg{16,32}
    reg_ext(/* "adc", */ 0x12, 0x00, reg8, rm8),                    // adc reg8, r/m8
    reg_ext(/* "adc", */ 0x13, 0x00, reg16_32, rm16_32),            // adc reg{16,32}, r/m{16,32}
    reg_ext(/* "add", */ 0x00, 0x00, rm8, reg8),                    // add r/m8, reg8
    reg_ext(/* "add", */ 0x01, 0x00, rm16_32, reg16_32),            // add r/m{16,32}, reg{16,32}
    reg_ext(/* "add", */ 0x02, 0x00, reg8, rm8),                    // add reg8, r/m8
    reg_ext(/* "add", */ 0x03, 0x00, reg16_32, rm16_32),            // add reg{16,32}, r/m{16,32}
    reg_ext(/* "and", */ 0x20, 0x00, rm8, reg8),                    // and r/m8, reg8
    reg_ext(/* "and", */ 0x21, 0x00, imm16_32),                     // and r/m{16,32}, reg{16,32}
    reg_ext(/* "and", */ 0x22, 0x00, reg8, rm8),                    // and reg8, r/m8
    reg_ext(/* "and", */ 0x23, 0x00, reg16_32, rm16_32),            // and reg{16,32}, r/m{16,32}
    reg_ext(/* "bound", */ 0x62, 0x00, reg16_32, mem16_32),         // bound reg{16,32}, mem{16,32}
    reg_ext(/* "bsf", */ 0x0f, 0xbc, reg16_32, mem16_32),           // bsf reg{16,32}, mem{16,32}
    reg_ext(/* "bsr", */ 0x0f, 0xbd, reg16_32, mem16_32),           // bsr reg{16,32}, mem{16,32}
    reg_ext(/* "bt", */ 0x0f, 0xa3),                                // bt r/m{16,32}, reg{16,32}
    reg_ext(/* "btc", */ 0x0f, 0xbb),                               // btc r/m{16,32}, reg{16,32}
    reg_ext(/* "btr", */ 0x0f, 0xb3),                               // btr r/m{16,32}, reg{16,32}
    reg_ext(/* "bts", */ 0x0f, 0xab),                               // bts r/m, reg
    reg_ext(/* "cmovae", */ 0x0f, 0x43, reg16_32, rm16_32),         // cmovae reg{16,32}, r/m{16,32}
    reg_ext(/* "cmove", */ 0x0f, 0x44, reg16_32, rm16_32),          // cmovz reg{16,32}, r/m{16,32} (= cmovz)
    reg_ext(/* "cmovne", */ 0x0f, 0x45, reg16_32, rm16_32),         // cmovne reg{16,32}, r/m{16,32} (= cmovnz)
    reg_ext(/* "cmovbe", */ 0x0f, 0x46, reg16_32, rm16_32),         // cmovnbe reg{16,32}, r/m{16,32} (= cmovna)
    reg_ext(/* "cmova", */ 0x0f, 0x47, reg16_32, rm16_32),          // cmova reg{16,32}, r/m{16,32} (= cmovnbe)
    reg_ext(/* "cmovs", */ 0x0f, 0x48, reg16_32, rm16_32),          // cmovs reg{16,32}, r/m{16,32}
    reg_ext(/* "cmovns", */ 0x0f, 0x49, reg16_32, rm16_32),         // cmovns reg{16,32}, r/m{16,32}
    reg_ext(/* "cmovp", */ 0x0f, 0x4a, reg16_32, rm16_32),          // cmovp reg{16,32}, r/m{16,32} (= cmovpe)
    reg_ext(/* "cmovnp", */ 0x0f, 0x4b, reg16_32, rm16_32),         // cmovnp reg{16,32}, r/m{16,32} (= cmovpo)
    reg_ext(/* "cmovl", */ 0x0f, 0x4c, reg16_32, rm16_32),          // cmovl reg{16,32}, r/m{16,32} (= cmovnge)
    reg_ext(/* "cmovge", */ 0x0f, 0x4d, reg16_32, rm16_32),         // cmovge reg{16,32}, r/m{16,32} (= cmovnl)
    reg_ext(/* "cmovle", */ 0x0f, 0x4e, reg16_32, rm16_32),         // cmovle reg{16,32}, r/m{16,32} (= cmovng)
    reg_ext(/* "cmovg", */ 0x0f, 0x4f, reg16_32, rm16_32),          // cmovg reg{16,32}, r/m{16,32} (= cmovnle)
    reg_ext(/* "cmp", */ 0x38, 0x00, rm8, reg8),                    // cmp r/m8, reg8
    reg_ext(/* "cmp", */ 0x39, 0x00, rm16_32, reg16_32),            // cmp r/m{16,32}, reg{16,32}
    reg_ext(/* "cmp", */ 0x3a, 0x00, reg8, rm8),                    // cmp reg8, r/m8
    reg_ext(/* "cmp", */ 0x3b, 0x00, reg16_32, rm16_32),            // cmp reg{16,32}, r/m{16,32}
    reg_ext(/* "cmpxchg", */ 0x0f, 0xb0, rm8, reg8),                // cmpxchg r/m8, reg8
    reg_ext(/* "cmpxchg", */ 0x0f, 0xb1),                           // cmpxchg r/m{16,32}, reg{16,32}
    // CMPXCHG8B CMPXCHG16B
    reg_ext(/* "imul", */ 0x0f, 0xaf, reg16_32, rm16_32),           // imul reg{16,32}, r/m{16,32}
    reg_ext(/* "imul", */ 0x6b, 0x00, reg16_32, rm16_32, imm8),     // imul reg{16,32}, r/m{16,32}, imm8
    reg_ext(/* "imul", */ 0x69, 0x00, reg16_32, rm16_32, imm16_32), // imul reg{16,32}, r/m{16,32}, imm{16,32}
    // LDS LES LFS LGS LSS
    reg_ext(/* "lea", */ 0x8d, 0x00, reg16_32, mem16_32),           // lea reg{16,32}, mem
    // LOOP
    // LZCNT
    reg_ext(/* "mov", */ 0x88, 0x00, rm8, reg8),                    // mov r/m8, reg8
    reg_ext(/* "mov", */ 0x89, 0x00, rm16_32, reg16_32),            // mov r/m{16,32}, reg{16,32}
    reg_ext(/* "mov", */ 0x8a, 0x00, reg8, rm8),                    // mov reg8, r/m8
    reg_ext(/* "mov", */ 0x8b, 0x00, reg16_32, rm16_32),            // mov reg{16,32}, r/m{16,32}
    // FIXME - encode both reg16,32 and mem16
    reg_ext(/* "mov", */ 0x8c, 0x00, rm16_32, sreg),                // mov reg{16,32}/mem16, sreg
    reg_ext(/* "mov", */ 0x8e, 0x00, sreg, rm16),                   // mov sreg, r/m16
    reg_ext(/* "movsx", */ 0x0f, 0xbe, reg16_32, rm8),              // movsx reg{16,32}, r/m8
    reg_ext(/* "movsx", */ 0x0f, 0xbf, reg32, rm16),                // movsx reg32, r/m16
    reg_ext(/* "movzx", */ 0x0f, 0xb6, reg16_32, rm8),              // movzx reg{16,32}, r/m8
    reg_ext(/* "movzx", */ 0x0f, 0xb7, reg32, rm16),                // movzx reg32, r/m16
    reg_ext(/* "or", */ 0x08, 0x00, rm8, reg8),                     // or r/m8, reg8
    reg_ext(/* "or", */ 0x09, 0x00, rm16_32, reg16_32),             // or reg{16,32}, r/m{16,32}
    reg_ext(/* "or", */ 0x0a, 0x00, reg8, rm8),                     // or reg8, r/m8
    reg_ext(/* "or", */ 0x0b, 0x00, reg16_32, rm16_32),             // or reg{16,32}, r/m{16,32}
    // POPCNT
    reg_ext(/* "sbb", */ 0x18, 0x00, rm8, reg8),                    // sbb r/m8, reg8
    reg_ext(/* "sbb", */ 0x19, 0x00, rm16_32, reg16_32),            // sbb r/m{16,32}, reg{16,32}
    reg_ext(/* "sbb", */ 0x1a, 0x00, reg16_32, rm8),                // sbb reg{16,32}, rm8
    reg_ext(/* "sbb", */ 0x1b, 0x00, reg16_32, rm16_32),            // sbb reg{16,32}, r/m{16,32}
    reg_ext(/* "shld", */ 0x0f, 0xa4, rm16_32, reg16_32, imm8),     // shld r/m{16,32}, reg{16,32}, imm8
    reg_ext(/* "shld", */ 0x0f, 0xa5, rm16_32, reg16_32, cl),       // shld r/m{16,32}, reg{16,32}, cl
    reg_ext(/* "shrd", */ 0x0f, 0xac, rm16_32, reg16_32, imm8),     // shrd r/m{16,32}, reg{16,32}, imm8
    reg_ext(/* "shrd", */ 0x0f, 0xad, rm16_32, reg16_32, cl),       // shrd r/m{16,32}, reg{16,32}, cl
    reg_ext(/* "sub", */ 0x28, 0x00, rm8, reg8),                    // sub r/m8, reg8
    reg_ext(/* "sub", */ 0x29, 0x00, rm16_32, reg16_32),            // sub r/m{16,32}, reg{16,32}
    reg_ext(/* "sub", */ 0x2a, 0x00, reg8, rm16_32),                // sub reg8, r/m{16,32}
    reg_ext(/* "sub", */ 0x2b, 0x00, reg16_32, rm16_32),            // sub reg{16,32}, r/m{16,32}
    reg_ext(/* "test", */ 0x84, 0x00, rm8, reg8),                   // test r/m8, reg8
    reg_ext(/* "test", */ 0x85, 0x00, rm16_32, reg16_32),           // test r/m{16,32}, reg{16,32}
    reg_ext(/* "ud1", */ 0x0f, 0xb9),                               // ud1
    reg_ext(/* "xadd", */ 0x0f, 0xc0, rm8, reg8),                   // xadd r/m8, reg8
    reg_ext(/* "xadd", */ 0x0f, 0xc1, rm16_32, reg16_32),           // xadd r/m{16,32}, reg{16,32}
    reg_ext(/* "xchg", */ 0x86, 0x00, rm8, reg8),                   // xchg r/m8, reg8
    reg_ext(/* "xchg", */ 0x87, 0x00, rm16_32, reg16_32),           // xchg r/m{16,32}, reg{16,32}
    reg_ext(/* "xor", */ 0x30, 0x00, rm8, reg8),                    // xor r/m8, reg8
    reg_ext(/* "xor", */ 0x31, 0x00, rm16_32, reg16_32),            // xor r/m{16,32}, reg{16,32}
    reg_ext(/* "xor", */ 0x32, 0x00, reg8, rm8),                    // xor reg8, r/m8
    reg_ext(/* "xor", */ 0x33, 0x00, reg16_32, rm16_32),            // xor reg{16,32}, r/m{16,32}
};

static insn lookup(u8* code, u8 byte, u8 byte2)
{
    for (const auto& ins : reg_ext_tbl) {
        if (ins.byte == byte && ins.byte2 == byte2)
            return ins;
    }
    for (const auto& ins : no_mod_tbl) {
        if (ins.byte == byte && ins.byte2 == byte2)
            return ins;
    }
    u8 modrm = *code;
    u8 ext = MODRM_REG(modrm);
    for (const auto& ins : ext_tbl) {
        if (ins.byte == byte && ins.byte2 == byte2
            && (ins.flags & insn_ext_mask) == ext)
            return ins;
    }
    return {};
}

enum class reg_type : u8 {
    r8, r16 = 4, r32 = 8, sreg = 12
};

/* conversion from modrm.reg:
*  r8:   (.reg + 1)
*  r16:  (.reg + 1) << 4
*  r32:  (.reg + 1) << 8
*  sreg: (.reg + 1) << 12
*/
static reg make_reg(u8 r, reg_type type)
{
    if (r == 0xff)
        return reg::none;
    return (reg)((r + 1) << (u8)type);
}

static insn decode_bswap(u8 byte2)
{
    auto ins = no_mod(0x0f, byte2, builtin32);
    ins.op.reg = make_reg(byte2 & 0b111, reg_type::r32);
    ins.length = 2;
    return ins;
}

static insn decode_enter(u8* code)
{
    insn ins{ 0xc8, 0x00, 0x00, imm16, imm8, operand_type::none, 0 };
    ins.op.imm.word = *(u16*)code;
    code += 2;
    ins.op2.imm.byte = *code;
    ins.length = 4;
    return ins;
}

static void fix_naming(insn& ins)
{
    if (ins.name.ends_with("sd"))
        ins.name[ins.name.length() - 1] = 'w';
    else if (ins.name.ends_with("ad") || ins.name.ends_with("fd"))
        ins.name.pop_back();
    else if (ins.name == "cwde")
        ins.name = "cbw";
    else if (ins.name == "cdq")
        ins.name = "cwd";
}

void decoder::parse_imm_args(operand& op, bool op_16b)
{
    if (op.type == imm8) {
        op.imm.byte = *code;
        advance();
    } else if (op.type == imm16 || (op_16b && op.type == imm16_32)) {
        op.imm.word = *(u16*)code;
        advance(2);
    } else if (op.type == imm16_32 || op.type == m_off) {
        op.imm.dword = *(u32*)code;
        advance(4);
    }
}

enum prefix : u8 {
    lock = 0xf0, repne = 0xf2, repe = 0xf3,
    es = 0x26, cs = 0x2e, ss = 0x36, ds = 0x3e, fs = 0x64, gs = 0x65,
    ext_pref = 0x0f,
    op_ovr = 0x66, addr_ovr = 0x67,
};

bool decoder::parse_prefixes(u32& pref)
{
    switch (*code) {
    case lock:                  pref |= pref_lock; return true;
    case repe: /* rep, repz */  pref |= pref_repe; return true;
    case repne: /* repnz */     pref |= pref_repne; return true;
    case es: case cs: case ss:
    case ds: case fs: case gs:  pref |= pref_sreg; return true;
    case op_ovr:                pref |= pref_op_ovr; return true;
    case addr_ovr:              pref |= pref_addr_ovr; return true;
    default: return false;
    }
}

void decoder::parse_modrm(insn& ins, u8& reg_op, u8& reg_op2, u8 byte)
{
    ins.modrm = *code;
    advance();
    u8 mod = MODRM_MOD(ins.modrm);
    u8 rm = MODRM_RM(ins.modrm);
    u8 reg = MODRM_REG(ins.modrm);

    bool addr_16b = ins.prefixes & pref_addr_ovr;

    /* Handle nonexistent/disallowed sregs */
    if (byte == 0x8c) {
        if (reg > 0b101 /* none */)
            ins.flags |= insn_err;
    } else if (byte == 0x8e) {
        if (reg == 0b001 /* cs */ || reg > 0b101 /* none */)
            ins.flags |= insn_err;
    }

    /* Check addressing mode */
    if (mod == 0b11) {
        if (ins.op.is_mem() || ins.op2.is_mem())
            ins.flags |= insn_err;
    } else {
        ins.flags |= insn_use_mem;
        if (rm == 0b100 && !addr_16b)
            ins.flags |= insn_has_sib;
    }

    /* Get first register (+ displacement size) */
    if (mod == 0b00) {
        if (rm == 0b110 && addr_16b)
            ins.disp_size = 2;
        else if (rm == 0b101)
            ins.disp_size = 4;
        else
            reg_op = rm;
    } else {
        reg_op = rm;
        if (mod == 0b01)
            ins.disp_size = 1;
        else if (mod == 0b10)
            ins.disp_size = addr_16b ? 2 : 4;
    }

    /* If /r, get second register */
    if (ins.flags & insn_reg_ext) {
        reg_op2 = reg;
        /* src/dst are "swapped" in the modrm table */
        if (ins.op2.is_rm() || ins.op2.is_mem() || ins.op.type == sreg)
            std::swap(reg_op, reg_op2);
    }

    /* Parse sib byte */
    if (ins.flags & insn_has_sib) {
        ins.sib = *code;
        advance();
        ins.sib_base = make_reg(SIB_BASE(ins.sib), reg_type::r32);
        ins.sib_index = make_reg(SIB_INDEX(ins.sib), reg_type::r32);
        switch (SIB_SCALE(ins.sib)) {
        case 0b00: ins.sib_scale = 1; break;
        case 0b01: ins.sib_scale = 2; break;
        case 0b10: ins.sib_scale = 4; break;
        case 0b11: ins.sib_scale = 8; break;
        }
    }

    /* Get displacement */
    switch (ins.disp_size) {
    case 0: break;
    case 1: ins.disp = *code; break;
    case 2: ins.disp = *(u16*)code; break;
    case 4: ins.disp = *(u32*)code; break;
    }
    advance(ins.disp_size);
}

static void fill_regs(insn& ins, u8 reg_op, u8 reg_op2)
{
    bool op_16b = ins.prefixes & pref_op_ovr;
    auto fill_builtin = [op_16b](operand& op) {
        switch (op.type) {
        case al: op.reg = reg::al; return true;
        case ax: op.reg = reg::ax; return true;
        case eax: op.reg = op_16b ? reg::ax : reg::eax; return true;
        case cl: op.reg = reg::cl; return true;
        case dx: op.reg = reg::dx; return true;
        default: return false;
        }
    };

    auto get_reg_type = [mem = ins.flags & insn_use_mem](operand& op, u32 pref) {
        switch (op.type) {
        case builtin8:
        case reg8:     return reg_type::r8;
        case reg16:    return reg_type::r16;
        case reg32:
        case builtin32:
        case mem8:
        case mem16:
        case mem16_32: return reg_type::r32;
        case builtin16_32:
        case reg16_32: return pref & pref_op_ovr ? reg_type::r16 : reg_type::r32;
        case rm8:      return mem ? reg_type::r32 : reg_type::r8;
        case rm16:     return mem ? reg_type::r32 : reg_type::r16;
        case rm16_32:  return mem ? reg_type::r32 : pref & pref_op_ovr ? reg_type::r16 : reg_type::r32;
        case sreg:     return reg_type::sreg;
        default:       __debugbreak(); return reg_type::r8; // prevent compiler warning
        }
    };
    if (ins.op.type != none && !ins.op.is_imm() && !fill_builtin(ins.op))
        ins.op.reg = make_reg(reg_op, get_reg_type(ins.op, ins.prefixes));
    if ((ins.op2.is_reg() || ins.op2.is_rm() || ins.op2.is_mem()) && !(ins.flags & insn_has_sib) && !fill_builtin(ins.op2))
        ins.op2.reg = make_reg(reg_op2, get_reg_type(ins.op2, ins.prefixes));
    fill_builtin(ins.op3);
}

insn disasm(u8* bytes)
{
    decoder dc{};
    dc.code = bytes;
    dc.pos = 0;

    u32 pref{};
    for (u32 i{}; i <= 15; i++) {
        if (!dc.parse_prefixes(pref))
            break;
        dc.advance();
    }

    u8 byte = *dc.code;
    dc.advance();
    u8 byte2{};
    if (byte == ext_pref || byte == 0xd4 /* aad */ || byte == 0xd5 /* aam */) {
        byte2 = *dc.code;
        dc.advance();
    }

    insn ins{};
    /* Ignore last 3 bits if +rb/+rw/+rd */
    if ((byte >= 0x40 && byte <= 0x5f) || (byte >= 0x90 && byte <= 0x97)
    || (byte >= 0xb8 && byte <= 0xbf))
        ins = lookup(dc.code, byte & 0xf8, byte2);
    /* Kind of a hack but I can't find a better approach for these 2 */
    else if (byte == ext_pref && byte2 >= 0xc8 && byte2 <= 0xcf)
        return decode_bswap(byte2);
    else if (byte == 0xc8)
        return decode_enter(dc.code);
    else
        ins = lookup(dc.code, byte, byte2);

    ins.prefixes = pref;
    bool op_16b = pref & pref_op_ovr;

    if (op_16b) {
        /* Handle prefixes for some mov insns */
        if (byte >= 0xa0 && byte <= 0xa3) {
            if (pref & pref_addr_ovr)
                ins.prefixes |= pref_op_ovr;
            else
                ins.prefixes &= ~pref_op_ovr;
        }
        /* Some insn names change with operand size */
        fix_naming(ins);
    }

    u8 reg_op{ 0xff }, reg_op2{ 0xff };

    if ((ins.flags & 0xf) != insn_no_mod) {
        dc.parse_modrm(ins, reg_op, reg_op2, byte);
    } else if (ins.prefixes & pref_lock) {
        ins.flags |= insn_err;
    } else if (ins.op.type == builtin8 || ins.op.type == builtin16_32) {
        if (byte2)
            reg_op = byte2 & 0b111;
        else
            reg_op = byte & 0b111;
    }

    dc.parse_imm_args(ins.op, op_16b);
    dc.parse_imm_args(ins.op2, op_16b);
    dc.parse_imm_args(ins.op3, op_16b);

    /* Shift insn with 0x1 as default */
    if (ins.byte == 0xd0 || ins.byte == 0xd1) {
        ins.op2.type = imm8;
        ins.op2.imm.byte = 0x1;
    }

    fill_regs(ins, reg_op, reg_op2);

    ins.length = dc.pos;
    if (ins.length > 15)
        ins.flags |= insn_err;

    return ins;
}

}

```

`memory/disasm/disasm.hh`:

```hh
#pragma once

#include <cstdint>
#include <string>

namespace disasm {

using u8 = uint8_t;
using u16 = uint16_t;
using u32 = uint32_t;
using s8 = int8_t;
using s16 = int16_t;
using s32 = int32_t;

enum insn_flag : u32 {
    /* Internal usage only - assigned on construction */
    insn_ext_mask = (0b111),
    insn_reg_ext = (1 << 3),
    insn_no_mod = (insn_ext_mask | insn_reg_ext),

    /* Added while decoding */
    insn_use_mem = (1 << 5),
    insn_has_sib = (1 << 6),
    insn_err = (1 << 7),
};

enum prefix_flag : u8 {
    pref_lock = (1 << 0),
    pref_repe = (1 << 1),
    pref_repne = (1 << 2),
    pref_sreg = (1 << 3),
    pref_op_ovr = (1 << 4),
    pref_addr_ovr = (1 << 5),
};

enum class reg : u32 {
    /* 8 bit */
    al = 1, cl, dl, bl, ah, ch, dh, bh,
    /* 16 bit */
    ax = al << 4, cx = cl << 4, dx = dl << 4, bx = bl << 4,
    sp = ah << 4, bp = ch << 4, si = dh << 4, di = bh << 4,
    /* 32 bit */
    eax = al << 8, ecx = cl << 8, edx = dl << 8, ebx = bl << 8,
    esp = ah << 8, ebp = ch << 8, esi = dh << 8, edi = bh << 8,
    /* Segment */
    es = al << 12, cs = cl << 12, ss = dl << 12,
    ds = bl << 12, fs = ah << 12, gs = ch << 12,

    none = 0xffffffff,
};

enum class operand_type : u32 {
    none,
    imm8, imm16, imm16_32,
    rm8, rm16, rm16_32,
    mem8, mem16, mem16_32, m_off,
    builtin8, builtin16_32, builtin32,
    reg8, reg16, reg16_32, reg32,
    sreg,
    al, ax, eax,
    cl, dx
};

struct operand {
    constexpr operand() = default;

    operand_type type{};
    reg reg{ reg::none };
    union {
        u8 byte;
        s8 sbyte;
        u16 word;
        s16 sword;
        u32 dword;
        s32 sdword;
    } imm;

    bool is_imm() const
    {
        return type == operand_type::imm8 || type == operand_type::imm16 || type == operand_type::imm16_32;
    }

    bool is_rm() const
    {
        return type == operand_type::rm8 || type == operand_type::rm16 || type == operand_type::rm16_32;
    }

    bool is_reg() const
    {
        return type >= operand_type::reg8 && type <= operand_type::dx;
    }

    bool is_mem() const
    {
        return type == operand_type::mem8 || type == operand_type::mem16 || type == operand_type::mem16_32;
    }
};

struct insn {
    constexpr insn() = default;
    constexpr insn(u8 b1, u8 b2, u8 b3, operand_type t1, operand_type t2, operand_type t3, u8 f)
        : byte(b1), byte2(b2), byte3(b3), flags(f)
    {
        op.type = t1;
        op2.type = t2;
        op3.type = t3;
    }

    const auto& dst() const { return op; }
    const auto& src() const { return op2; }
    bool error() const { return flags & insn_err; }

    std::string name{ "???" };   // mnemonic
    u8 byte{};                   // 1st opcode byte
    u8 byte2{};                  // 2nd opcode byte
    u8 byte3{};                  // 3rd opcode byte
    operand op{};                // 1st operand (dst if 2)
    operand op2{};               // 2nd operand (src)
    operand op3{};               // 3rd operand
    u8 modrm{};                  // modrm byte
    u8 sib{};                    // scale index byte
    u8 sib_scale{};              // sib scale
    reg sib_index{ reg::none };  // sib index register
    reg sib_base{ reg::none };   // sib base register
    u8 disp_size{};              // displacement size
    s32 disp{};                  // displacement (also immediate memory operands)
    u32 prefixes{};              // prefix bytes
    u32 flags{};                 // flags
    u32 length{};                // total bytes
};

insn disasm(u8* bytes);

}

```

`memory/dll.cpp`:

```cpp
#include "dll.h"

address dll::get_export(hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return address();

    const auto optional_hdr = &nt_hdrs->OptionalHeader;
    const auto dir_addr = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(
        base + optional_hdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    const auto functions = reinterpret_cast<uint32_t*>(base + dir_addr->AddressOfFunctions);
    const auto names = reinterpret_cast<uint32_t*>(base + dir_addr->AddressOfNames);
    const auto ordinals = reinterpret_cast<uint16_t*>(base + dir_addr->AddressOfNameOrdinals);

    for (DWORD i{ }; i < dir_addr->NumberOfFunctions; i++) {
        const auto name = reinterpret_cast<const char*>(base + names[i]);
        if (fnv1a::hash(name) == hash)
            return address(base + functions[ordinals[i]]);
    }

    return address();
}

address dll::get_import(const dll& from, hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return address();

    const auto optional_hdr = &nt_hdrs->OptionalHeader;
    auto import_desc = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
        base + optional_hdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    while (import_desc->Name) {
        auto cur_dll = reinterpret_cast<char*>(base) + import_desc->Name;
        if (!from.name.compare(cur_dll)) {
            auto thunk_data = reinterpret_cast<IMAGE_THUNK_DATA*>(base + import_desc->OriginalFirstThunk);
            for (int i = 0; thunk_data->u1.Function; i++, thunk_data++) {
                char* cur_fn = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(base + thunk_data->u1.AddressOfData)->Name;
                if (fnv1a::hash(cur_fn) == hash) {
                    auto table = reinterpret_cast<uintptr_t*>(base + import_desc->FirstThunk);
                    return address(table[i]);
                }
            }
            return address();
        }
        import_desc++;
    }

    return address();
}

IMAGE_SECTION_HEADER* dll::get_section(hash_t hash) const noexcept
{
    const auto nt_hdrs = get_nt_headers();
    if (!nt_hdrs)
        return nullptr;

    auto section = IMAGE_FIRST_SECTION(nt_hdrs);
    if (!section)
        return nullptr;

    for (WORD i{ }; i <= nt_hdrs->FileHeader.NumberOfSections; i++, section++) {
        const auto name = reinterpret_cast<const char*>(section->Name);
        if (fnv1a::hash(name) == hash)
            return section;
    }

    return nullptr;
}

bool dll::is_within_section(address addr, hash_t section_hash) const noexcept
{
    auto section = get_section(section_hash);
    if (!section)
        return false;

    return is_within_section(addr, section);
}

bool dll::is_within_section(address addr, IMAGE_SECTION_HEADER* section) const noexcept
{
    if (!section)
        return false;

    const auto start = base + section->VirtualAddress;
    const auto end = start + section->SizeOfRawData;

    return addr.value >= start && addr.value < end;
}

```

`memory/dll.h`:

```h
#pragma once

#include <unordered_map>
#include <Windows.h>
#include <winternl.h>

#include "../base/base.h"
#include "../crypt/fnv1a.h"
#include "memory.h"

struct dll;
namespace dlls { inline std::vector<dll*> list; }

struct dll {
    std::string name{ };
    uintptr_t base{ };
    size_t size{ };
    address create_interface{ }; // Only relevant to game DLLs

    explicit dll(std::string_view name) noexcept
        : name(name)
    {
        dlls::list.push_back(this);
    }

    template<size_t len> requires(len > 0)
    address find(std::array<int, len>&& pattern) const noexcept
    {
        auto bytes = reinterpret_cast<uint8_t*>(base);
        for (size_t i{ }; i < size - len; i++) {
            for (size_t j{ }; j < len; j++) {
                if (bytes[i + j] != pattern[j] && pattern[j] != -1)
                    break;
                if (j + 1 == len)
                    return address(&bytes[i]);
            }
        }

        LOG_ERROR("{}: did not find pattern {}", name, [&]()
        {
            /* Slow, but this only runs when something goes wrong. */
            std::stringstream ss{ };
            for (auto byte : pattern) {
                if (byte == -1)
                    ss << '?';
                else
                    ss << std::uppercase << std::hex << std::setfill('0') << std::setw(2) << byte;
                ss << ' ';
            }
            return ss.str();
        }());
        return address();
    }

    inline IMAGE_NT_HEADERS* get_nt_headers() const noexcept
    {
        auto dos = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
        if (dos->e_magic != IMAGE_DOS_SIGNATURE)
            return nullptr;

        auto nt = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos->e_lfanew);
        if (nt->Signature != IMAGE_NT_SIGNATURE)
            return nullptr;

        return nt;
    }

    address get_import(const dll& from, hash_t hash) const noexcept;
    address get_export(hash_t hash) const noexcept;
    IMAGE_SECTION_HEADER* get_section(hash_t hash) const noexcept;
    bool is_within_section(address addr, hash_t section_hash) const noexcept;
    bool is_within_section(address addr, IMAGE_SECTION_HEADER* section) const noexcept;
};

namespace dlls {

    inline dll client{ "client.dll" };
    inline dll datacache{ "datacache.dll" };
    inline dll engine{ "engine.dll" };
    inline dll file_system{ "filesystem_stdio.dll" };
    inline dll game_overlay_renderer{ "gameoverlayrenderer.dll" };
    inline dll input_system{ "inputsystem.dll" };
    inline dll localize{ "localize.dll" };
    inline dll material_system{ "materialsystem.dll" };
    inline dll matchmaking{ "matchmaking.dll" };
    inline dll server{ "server.dll" };
    inline dll shader_api_dx9{ "shaderapidx9.dll" };
    inline dll steam_api{ "steam_api.dll" };
    inline dll studio_render{ "studiorender.dll" };
    inline dll tier0{ "tier0.dll" };
    inline dll vgui_mat_surface{ "vguimatsurface.dll" };
    inline dll vgui2{ "vgui2.dll" };
    inline dll vphysics{ "vphysics.dll" };
    inline dll vstdlib{ "vstdlib.dll" };

    inline void initialize() noexcept
    {
        struct ldr_data_table_entry {
            LIST_ENTRY InMemoryOrderLinks;
            PAD(0x8)
            PVOID DllBase;
            PAD(0x4)
            ULONG SizeOfImage;
            PAD(0x8)
            UNICODE_STRING BaseDllName;
            PAD(0x7c)
        };

        std::unordered_map<hash_t, ldr_data_table_entry*> loaded{ };

        const auto peb = reinterpret_cast<const PEB*>(__readfsdword(0x30));
        auto cur = CONTAINING_RECORD(peb->Ldr->InMemoryOrderModuleList.Flink,
                                     ldr_data_table_entry,
                                     InMemoryOrderLinks);

        while (cur->BaseDllName.Length) {
            loaded.insert_or_assign(fnv1a::hash(cur->BaseDllName.Buffer), cur);
            LOG_INFO(L"Found module {} at {}", cur->BaseDllName.Buffer, cur->DllBase);
            cur = reinterpret_cast<ldr_data_table_entry*>(cur->InMemoryOrderLinks.Flink);
        }

        for (auto entry : list) {
            const auto res = loaded.find(fnv1a::hash(entry->name));
            ASSERT_MSG(res != loaded.cend(), "DLL not loaded yet?");
            const auto dll = res->second;
            entry->base = reinterpret_cast<uintptr_t>(dll->DllBase);
            entry->size = dll->SizeOfImage;
        }
    }

};

```

`memory/hook_mgr.h`:

```h
#pragma once

#include <map>

#include "memory.h"
#include "detour.h"
#include "../base/debug.h"

#define SET_SIG_HOOK(dll, sig, name) set(dll, PATTERN(sig), reinterpret_cast<void*>(name::fn), reinterpret_cast<void**>(&name::original))
#define SET_VT_HOOK(vmt, name, index) set(vmt, index, name::fn, name::original)

namespace hooks {

    inline std::map<uintptr_t, detour::hook> hooked_fns{ }; /* Only contains signature hooks */

    void initialize() noexcept;
    void end() noexcept;

    template<class ty, class fn>
    void set(interface_holder<ty*>& vmt, int index, void* hook, fn& original) noexcept
    {
        ASSERT_MSG(vmt.replacement_vmt, "Trying to set hook with replace_vmt = false!");
        vmt.replacement_vmt[index + 1] = reinterpret_cast<uintptr_t>(hook);
        original = reinterpret_cast<fn>(vmt.real_vmt[index]);
    }

    template<size_t len>
    void set(dll& dll, std::array<int, len>&& sig, void* hook, void** original) noexcept
    {
        auto target = dll.find<len>(std::move(sig));
        ASSERT(target);
        ASSERT(dll.is_within_section(target, ".text"_hash));
        detour::hook hk{ target, hook, original };
        if (hk.set())
            hooked_fns.emplace(reinterpret_cast<uintptr_t>(hook), std::move(hk));
        else
            LOG_ERROR("Error while hooking function!"); /* Not fatal, but we should warn about it */
    }

}

```

`memory/interfaces.cpp`:

```cpp
#include "interfaces.h"
#include "../crypt/xorstr.h"

static void collect_interfaces(dll& dll) noexcept;
template<bool replace_vmt = false, class ty>
static void get_cached_interface(interface_holder<ty*>& ptr, std::string_view version_string) noexcept;
template<bool replace_vmt = false, class ty>
static void find_interface(interface_holder<ty*>& ptr, dll& dll, std::string_view version_string) noexcept;

void interfaces::initialize() noexcept
{
    collect_interfaces(dlls::client);
    collect_interfaces(dlls::datacache);
    collect_interfaces(dlls::engine);
    collect_interfaces(dlls::file_system);
    collect_interfaces(dlls::input_system);
    collect_interfaces(dlls::localize);
    collect_interfaces(dlls::matchmaking);
    collect_interfaces(dlls::material_system);
    collect_interfaces(dlls::studio_render);
    collect_interfaces(dlls::vgui_mat_surface);
    collect_interfaces(dlls::vgui2);
    collect_interfaces(dlls::vphysics);
    collect_interfaces(dlls::vstdlib);

    get_cached_interface<true>(client, "VClient0");
    get_cached_interface(console, "GameConsole0");
    get_cached_interface(cvar, "VEngineCvar0");
    get_cached_interface(debug_overlay, "VDebugOverlay0");
    get_cached_interface(effects, "VEngineEffects0");
    get_cached_interface(effects_client, "IEffects0");
    get_cached_interface(engine, "VEngineClient0");
    get_cached_interface(entity_list, "VClientEntityList0");
    get_cached_interface(event_manager, "GAMEEVENTSMANAGER002");
    get_cached_interface(file_system, "VFileSystem0");
    get_cached_interface(game_types, "VENGINE_GAMETYPES_VERSION0");
    get_cached_interface(input_system, "InputSystemVersion0");
    get_cached_interface(leaf_system, "ClientLeafSystem0");
    get_cached_interface(localize, "Localize_0");
    get_cached_interface(match_framework, "MATCHFRAMEWORK_0");
    get_cached_interface(material_system, "VMaterialSystem0");
    get_cached_interface(mdl_cache, "MDLCache0");
    get_cached_interface(model_info, "VModelInfoClient0");
    get_cached_interface<true>(model_render, "VEngineModel0");
    get_cached_interface(movement, "GameMovement0");
    get_cached_interface(net_support, "INETSUPPORT_0");
    get_cached_interface(physics_props, "VPhysicsSurfaceProps0");
    get_cached_interface(prediction,"VClientPrediction0");
    get_cached_interface(render_view, "VEngineRenderView0");
    get_cached_interface(server, "ServerGameDLL0");
    get_cached_interface(sound, "IEngineSoundClient0");
    get_cached_interface(network_string_table, "VEngineClientStringTable0");
    get_cached_interface<true>(studio_render, "VStudioRender0");
    get_cached_interface(trace, "EngineTraceClient0");
    get_cached_interface(ui, "GameUI0");
    get_cached_interface<true>(vgui, "VEngineVGui0");

    // Not sure why but these only work manually...
    find_interface(panel, dlls::vgui2, "VGUI_Panel0");
    find_interface<true>(surface, dlls::vgui_mat_surface, "VGUI_Surface0");

    client_mode.initialize<true>(**memory::get_virtual(client, 10).offset(0x5).cast<se::client_mode***>());
    globals.initialize(**memory::get_virtual(client, 11).offset(0xa).cast<se::global_vars_base***>());
    input.initialize(*memory::get_virtual(client, 16).offset(0x1).cast<se::client_input**>());
    client_state.initialize(**memory::get_virtual(engine, 12).offset(0x10).cast<se::client_state***>());

    game_rules.initialize(**dlls::client.find(PATTERN("A1 ? ? ? ? 85 C0 0F 84 ? ? ? ? 80 B8 ? ? ? ? ? 74 7A")).offset(0x1).cast<se::game_rules***>());
    glow_manager.initialize(*dlls::client.find(PATTERN("0F 11 05 ? ? ? ? 83 C8 01")).offset(0x3).cast<se::glow_manager**>());
    move_helper.initialize(**dlls::client.find(PATTERN("8B 0D ? ? ? ? 8B 45 ? 51 8B D4 89 02 8B 01")).offset(0x2).cast<se::move_helper***>());
    player_resource.initialize(*dlls::client.find(PATTERN("8B 1D ? ? ? ? 89 5C 24 40")).offset(0x2).cast<se::player_resource**>());
    render_beams.initialize(*dlls::client.find(PATTERN("B9 ? ? ? ? FF 50 24 C2 04 00")).offset(0x1).cast<se::render_beams**>());
    weapon_system.initialize(*dlls::client.find(PATTERN("8B 35 ? ? ? ? FF 10 0F B7 C0")).offset(0x2).cast<se::weapon_system**>());
    view_render.initialize(**dlls::client.find(PATTERN("8B 0D ? ? ? ? D9 5D F0 8B 01")).offset(0x2).cast<se::view_render***>());
    dx9_device.initialize(**dlls::shader_api_dx9.find(PATTERN("A1 ? ? ? ? 50 8B 08 FF 51 0C")).offset(0x1).cast<IDirect3DDevice9***>());

    bsp_query.initialize(engine->get_bsp_tree_query());

    steam::user       = dlls::steam_api.get_export("SteamAPI_GetHSteamUser"_hash).cast<steam::h_user(*)()>()();
    steam::pipe       = dlls::steam_api.get_export("SteamAPI_GetHSteamPipe"_hash).cast<steam::h_pipe(*)()>()();
    steam_api_ctx     = engine->get_steam_api_context();
    steam_client      = steam_api_ctx->steam_client;
    game_coordinator  = static_cast<steam::game_coordinator*>(steam_client->get_generic_interface(steam::user, steam::pipe, "SteamGameCoordinator001"));
    steam_friends     = steam_api_ctx->steam_friends;
    matchmaking       = steam_api_ctx->steam_matchmaking;
    user_stats        = steam_api_ctx->steam_user_stats;

    mem_alloc         = *dlls::tier0.get_export("g_pMemAlloc"_hash).cast<se::mem_alloc**>();
    key_values_system = dlls::vstdlib.get_export("KeyValuesSystem"_hash).cast<se::key_values_system_fn>()();

    LOG_INFO("Interfaces initialized.");
}

namespace se {

struct interface_reg {
    std::add_pointer_t<void*()> create_fn{ };
    const char* name{ };
    interface_reg* next{ };
};

}

static auto get_interface_regs(dll& dll) noexcept
{
    if (!dll.create_interface) {
        dll.create_interface = dll.get_export("CreateInterface"_hash);
        ASSERT(dll.create_interface);
    }

    // Follow jmp instruction inside function to get to CreateInterfaceInternal(), where the global interface list is moved into ESI.
    const auto reg_list = **dll.create_interface.absolute<se::interface_reg***>(0x5, 0x6);
    ASSERT(reg_list);
    return reg_list;
}

static void collect_interfaces(dll& dll) noexcept
{
    for (auto cur = get_interface_regs(dll); cur; cur = cur->next) {
        LOG_INFO("{}: found interface {}", dll.name, cur->name);
        interfaces::list.push_back(std::make_pair(cur->name, cur->create_fn()));
    }
}

// Version strings may be partial.

template<bool replace_vmt, class ty>
static void find_interface(interface_holder<ty*>& ptr, dll& dll, std::string_view version_string) noexcept
{
    for (auto cur = get_interface_regs(dll); cur; cur = cur->next) {
        if (std::string(cur->name).starts_with(version_string)) {
            LOG_SUCCESS("Found interface {}.", cur->name);
            ptr.template initialize<replace_vmt>(static_cast<ty*>(cur->create_fn()));
            return;
        }
    }
    ASSERT(false);
}

template<bool replace_vmt, class ty>
static void get_cached_interface(interface_holder<ty*>& ptr, std::string_view version_string) noexcept
{
    for (const auto& [name, iface] : interfaces::list) {
        if (name.starts_with(version_string.data())) {
            ptr.template initialize<replace_vmt>(static_cast<ty*>(iface));
            return;
        }
    }
}

```

`memory/interfaces.h`:

```h
#pragma once

#include <d3d9.h>

#include "../valve/se/se.h"

namespace interfaces {

    inline std::vector<void*> hooked_tables{ };
    inline std::vector<std::pair<std::string, void*>> list{ };

}

template<class ptr> requires std::is_pointer_v<ptr>
struct interface_holder {
    ptr instance{ };
    uintptr_t* real_vmt{ };
    std::unique_ptr<uintptr_t[]> replacement_vmt{ };

    constexpr ptr operator->() const noexcept { return instance; }
    constexpr void operator=(ptr rhs) noexcept { instance = rhs; }
    constexpr operator bool() const noexcept { return instance; }
    constexpr operator ptr() noexcept { return instance; }

    // Pass false to replace_vmt if you don't hook anything from the table or if get_vmt_length() is crashing
    template<bool replace_vmt = false>
    inline void initialize(ptr vptr) noexcept
    {
        constexpr int dynamic_cast_info_len = 1;

        instance = vptr;

        if constexpr (replace_vmt) {
            real_vmt = *reinterpret_cast<uintptr_t**>(instance);

            const auto len = memory::get_vmt_length(real_vmt) + dynamic_cast_info_len;
            replacement_vmt = std::make_unique<uintptr_t[]>(len);
            std::ranges::copy(real_vmt - dynamic_cast_info_len, real_vmt + len - dynamic_cast_info_len, replacement_vmt.get());

            *reinterpret_cast<uintptr_t**>(instance) = replacement_vmt.get() + dynamic_cast_info_len;

            interfaces::hooked_tables.push_back(this);
        }
    }

    inline void restore() noexcept
    {
        *reinterpret_cast<uintptr_t**>(instance) = real_vmt;
    }
};

namespace interfaces {

inline interface_holder<se::client_dll*>             client{ };
inline interface_holder<se::client_input*>           input{ };
inline interface_holder<se::client_mode*>            client_mode{ };
inline interface_holder<se::client_state*>           client_state{ };
inline interface_holder<se::cvar*>                   cvar{ };
inline interface_holder<se::debug_overlay*>          debug_overlay{ };
inline interface_holder<se::effects_client*>         effects_client{ };
inline interface_holder<se::effects*>                effects{ };
inline interface_holder<se::engine_client*>          engine{ };
inline interface_holder<se::engine_trace*>           trace{ };
inline interface_holder<se::entity_list*>            entity_list{ };
inline interface_holder<se::event_manager*>          event_manager{ };
inline interface_holder<se::file_system*>            file_system{ };
inline interface_holder<se::game_console*>           console{ };
inline interface_holder<se::game_movement*>          movement{ };
inline interface_holder<se::game_rules*>             game_rules{ };
inline interface_holder<se::game_types*>             game_types{ };
inline interface_holder<se::game_ui*>                ui{ };
inline interface_holder<se::global_vars_base*>       globals{ };
inline interface_holder<se::glow_manager*>           glow_manager{ };
inline interface_holder<se::input_system*>           input_system{ };
inline interface_holder<se::leaf_system*>            leaf_system{ };
inline interface_holder<se::localize*>               localize{ };
inline interface_holder<se::match_framework*>        match_framework{ };
inline interface_holder<se::material_system*>        material_system{ };
inline interface_holder<se::mdl_cache*>              mdl_cache{ };
inline interface_holder<se::model_info*>             model_info{ };
inline interface_holder<se::model_render*>           model_render{ };
inline interface_holder<se::move_helper*>            move_helper{ };
inline interface_holder<se::net_channel*>            net_channel{ };
inline interface_holder<se::net_support*>            net_support{ };
inline interface_holder<se::panel*>                  panel{ };
inline interface_holder<se::player_resource*>        player_resource{ };
inline interface_holder<se::physics_surface_props*>  physics_props{ };
inline interface_holder<se::prediction*>             prediction{ };
inline interface_holder<se::render_beams*>           render_beams{ };
inline interface_holder<se::render_view*>            render_view{ };
inline interface_holder<se::server_dll*>             server{ };
inline interface_holder<se::sound*>                  sound{ };
inline interface_holder<se::spatial_query*>          bsp_query{ };
inline interface_holder<se::string_table_container*> network_string_table{ };
inline interface_holder<se::studio_render*>          studio_render{ };
inline interface_holder<se::surface*>                surface{ };
inline interface_holder<se::vgui*>                   vgui{ };
inline interface_holder<se::view_render*>            view_render{ };
inline interface_holder<se::weapon_system*>          weapon_system{ };

inline se::key_values_system*   key_values_system{ };
inline se::mem_alloc*           mem_alloc{ };

inline steam::api_context*      steam_api_ctx{ };
inline steam::client*           steam_client{ };
inline steam::game_coordinator* game_coordinator{ };
inline steam::friends*          steam_friends{ };
inline steam::matchmaking*      matchmaking{ };
inline steam::user_stats*       user_stats{ };

inline interface_holder<IDirect3DDevice9*> dx9_device{ };

void initialize() noexcept;

}

```

`memory/memory.h`:

```h
#pragma once

#define CONCAT_IMPL(x, y) x##y
#define CONCAT(x, y) CONCAT_IMPL(x, y)
#define PAD(size) private: [[maybe_unused]] std::byte CONCAT(pad, __COUNTER__)[size]{ }; public:

#include <intrin.h>

#include "address.h"
#include "dll.h"

namespace memory {

    struct virtual_alloc {
        LPVOID address{ };
        bool free{ };

        explicit virtual_alloc(SIZE_T size, DWORD flags) noexcept
        {
            address = VirtualAlloc(nullptr, size, MEM_RESERVE | MEM_COMMIT, flags);
            if (address)
                free = true;
        }

        ~virtual_alloc()
        {
            if (free)
                VirtualFree(address, 0, MEM_RELEASE);
        }
    };

    struct virtual_protect {
        LPVOID address{ };
        SIZE_T size{ };
        DWORD flags{ };

        explicit virtual_protect(LPVOID addr, SIZE_T size, DWORD flags) noexcept
            : address(addr), size(size)
        {
            VirtualProtect(address, size, flags, &flags);
        }

        ~virtual_protect()
        {
            VirtualProtect(address, size, flags, &flags);
        }
    };

    template<class ty, int i, class... va_args>
    ty call_virtual(void* base, va_args... args) noexcept
    {
        return (*static_cast<ty(__thiscall***)(void*, va_args...)>(base))[i](base, args...);
    }

    template<class ty = address>
    ty get_virtual(void* base, int index) noexcept
    {
        return (*static_cast<ty**>(base))[index];
    }

    inline address get_frame_address() noexcept
    {
        return address(reinterpret_cast<uintptr_t>(_AddressOfReturnAddress()) - sizeof(uintptr_t));
    }

    inline bool is_address_valid(address addr) noexcept
    {
        if (!addr)
            return false;

        MEMORY_BASIC_INFORMATION info{ };
        if (!VirtualQuery(addr, &info, sizeof(info)))
            return false;

        return info.State & MEM_COMMIT && !(info.Protect & PAGE_NOACCESS);
    }

    inline size_t get_vmt_length(uintptr_t* vptr) noexcept
    {
        size_t length{ };
        MEMORY_BASIC_INFORMATION info{ };

        while (VirtualQuery(reinterpret_cast<LPCVOID>(vptr[length]), &info, sizeof(info)) &&
               info.State & MEM_COMMIT &&
               info.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
            ++length;

        return length;
    }

    template<class ty>
    bool read(address addr, ty& data, SIZE_T size = sizeof(ty)) noexcept
    {
        return ReadProcessMemory(HANDLE(-1), addr, &data, size, nullptr);
    }

    template<class ty>
    bool write(address addr, ty& data, SIZE_T size = sizeof(ty)) noexcept
    {
        return WriteProcessMemory(HANDLE(-1), addr, &data, size, nullptr);
    }

    inline bool protect(address addr, DWORD flags, SIZE_T size) noexcept
    {
        DWORD _;
        return VirtualProtect(addr, size, flags, &_);
    }

    inline bool query(address addr, MEMORY_BASIC_INFORMATION& mem_info) noexcept
    {
        return VirtualQuery(addr, &mem_info, sizeof(mem_info));
    }

}

#define VIRTUAL_FUNCTION(name, ret, idx, params, args) \
inline ret name params noexcept \
{ \
    return memory::call_virtual<ret, idx>args; \
}

// Parameters and arguments are reversed, only way I could get this macro to work properly.
#define VIRTUAL_FUNCTION_SIG(name, ret, dll, sig, args, ... /* params */) \
inline ret name(__VA_ARGS__) noexcept \
{ \
    static ret(__thiscall* fn)(void*, __VA_ARGS__) = dll.find(PATTERN(sig)).cast<decltype(fn)>(); \
    return fn args; \
}

```

`render/menu/controls.cpp`:

```cpp
#include "controls.h"

void menu::controls::tab(std::wstring_view str, tab_id id) noexcept
{
    constexpr d2 region_size{ 90, 30 };
    const d2 pos{ base_pos.x + region_size.x * static_cast<int>(id), base_pos.y };
    clr4 text_clr{ 255, 255, 255, 255 };
    clr4 line_clr{ 30, 30, 30, 255 };

    if (input::is_hovering_item(pos, region_size)) {
        text_clr = hover_color;
        if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
            cur_tab = id;
    }

    if (id == cur_tab)
        line_clr = text_clr = accent_color;

    text(fonts::tab, { pos.x + static_cast<int>(region_size.x / 2), pos.y + static_cast<int>(region_size.y / 2) }, str,
         text_flag::centered, text_clr);
    line(pos.x + 1, pos.y + 1, pos.x + region_size.x + 1, pos.y + 1, line_clr);
}

void menu::controls::checkbox(std::wstring_view str, bool& var) noexcept
{
    constexpr d2 box_size{ 16, 16 };
    const d2 text_size = get_text_size(fonts::menu, str);
    const d2 pos = calculate_position(ctrl_type::checkbox, fnv1a::hash(str));
    clr4 fill_clr = inactive_color;

    outlined_rect(pos, box_size, clr4::black());

    if (var)
        fill_clr = accent_color;

    if (input::is_hovering_item(pos, { box_size.x + text_size.x, box_size.y })) {
        if (!var)
            fill_clr = hover_color;
        if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
            var = !var;
    }

    filled_rect(pos.x + 2, pos.y + 2, pos.x + box_size.x - 2, pos.y + box_size.y - 2, fill_clr);
    text(fonts::menu, { pos.x + box_size.x + 5, pos.y }, str);
}

void menu::controls::button(std::wstring_view str, std::function<void(void)> callback, d2 size) noexcept
{
    const d2 pos = calculate_position(ctrl_type::button, fnv1a::hash(str));
    clr4 fill_clr{ 30, 30, 30, 255 };
    clr4 text_clr{ 255, 255, 255, 255 };

    outlined_rect(pos, size);
    fill_clr = inactive_color;

    if (input::is_hovering_item(pos, size)) {
        text_clr = hover_color;
        if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
            callback();
    }

    filled_rect(pos.x + 1, pos.y + 1, pos.x + size.x - 1, pos.y + size.y + 2, fill_clr);
    text(fonts::menu, { pos.x + size.x / 2, pos.y + size.y / 2 }, str, text_flag::centered, text_clr);
}

void menu::controls::slider(std::wstring_view str, int& var, int min, int max) noexcept
{
    constexpr d2 region_size{ 120, 18 };
    const d2 pos = calculate_position(ctrl_type::slider, fnv1a::hash(str));
    const auto scaled = std::abs(static_cast<float>(min) / region_size.x - static_cast<float>(max) / region_size.x);
    const auto fill_width = var / scaled - (min / scaled);

    outlined_rect(pos.x, pos.y, pos.x + region_size.x, pos.y + region_size.y, clr4::black());
    filled_rect(pos.x + 2, pos.y + 2, pos.x + region_size.x - 2, pos.y + region_size.y - 2, inactive_color);
    filled_rect(pos.x + 2, pos.y + 2, pos.x + static_cast<int>(fill_width) - 2, pos.y + region_size.y - 2, accent_color);

    if (input::is_hovering_item(pos, region_size)) {
        if (holding_lmb())
            var = static_cast<int>((static_cast<float>(input::mouse_pos.x - pos.x)) / region_size.x * (max - min) + min);
    }

    text(fonts::menu, { pos.x + region_size.x / 2, pos.y + region_size.y / 2 }, std::to_wstring(var),
                 text_flag::centered);
    text(fonts::menu, { pos.x + region_size.x + 5, pos.y }, str);
}

void menu::controls::slider(std::wstring_view str, float& var, float min, float max, int precision) noexcept
{
    constexpr d2 region_size{ 120, 18 };
    const d2 pos = calculate_position(ctrl_type::slider, fnv1a::hash(str));
    const float scaled = std::abs(min / region_size.x - max / region_size.x);
    const float fill_width = var / scaled - (min / scaled);

    outlined_rect(pos.x, pos.y, pos.x + region_size.x, pos.y + region_size.y, clr4::black());
    filled_rect(pos.x + 2, pos.y + 2, pos.x + region_size.x - 2, pos.y + region_size.y - 2, inactive_color);
    filled_rect(pos.x + 2, pos.y + 2, pos.x + static_cast<int>(fill_width - 2), pos.y + region_size.y - 2, accent_color);

    if (input::is_hovering_item(pos, region_size)) {
        if (holding_lmb())
            var = static_cast<float>(static_cast<float>(input::mouse_pos.x - pos.x) / region_size.x * (max - min) + min);
    }

    std::wostringstream stream{ };
    stream << std::fixed << std::setprecision(precision) << var;

    text(fonts::menu, { pos.x + region_size.x / 2, pos.y + region_size.y / 2 }, stream.str(), text_flag::centered);
    text(fonts::menu, { pos.x + region_size.x + 5, pos.y }, str);
}

void menu::controls::multibox(std::wstring_view str, const std::vector<std::wstring_view>& names, std::vector<bool>& vars) noexcept
{
    constexpr d2 region_size{ 120, 18 };
    const d2 picker_size{ 100, static_cast<int>(region_size.y * vars.size()) };
    const d2 pos = calculate_position(ctrl_type::dropdown, fnv1a::hash(str));
    clr4 item_color = { 255, 255, 255, 255 };

    outlined_rect(pos, region_size, clr4::black());
    filled_rect(pos.x + 2, pos.y + 2, pos.x + region_size.x - 2, pos.y + region_size.y - 2, inactive_color);

    static bool is_active{ };
    if (input::is_hovering_item(pos, region_size)) {
        item_color = hover_color;
        if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
            is_active = !is_active;
    }

    bool empty{ true };
    std::wstring selected{ };
    int selected_amt{ };

    for (size_t i{ }; i < vars.size(); i++) {
        if (vars[i]) {
            empty = false;
            selected_amt++;
            if (i != 0 && selected_amt > 1)
                selected += L", ";
            selected += names[i];
            item_color = accent_color;
        } else
            item_color = { 255, 255, 255, 255 };

        if (is_active) {
            const int h = region_size.y * i;
            if (input::is_hovering_item({ pos.x, pos.y + static_cast<int>(region_size.y * (i + 1)) }, region_size)) {
                text(fonts::menu, { pos.x + 5, pos.y + region_size.y + h }, names[i], { }, hover_color);
                if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
                    vars[i] = !vars[i];
            } else
                text(fonts::menu, { pos.x + 5, pos.y + region_size.y + h }, names[i], { }, item_color);
        }
    }

    if (selected.size() > 22) {
        selected.resize(22);
        selected += L"...";
    }

    text(fonts::menu, { pos.x + 5, pos.y + 2 }, empty ? L"None" : selected);
    text(fonts::menu, { pos.x + region_size.x + 5, pos.y }, str);
}

d2 menu::controls::calculate_position(ctrl_type type, hash_t hash) noexcept
{
    /* TODO - when using multiple columns, x will not be constant anymore
       and one map for every column will be needed */

    constexpr size_t tab_count = static_cast<size_t>(tab_id::count);
    constexpr size_t ctrl_count = static_cast<size_t>(ctrl_type::count);

    constexpr std::array<int, ctrl_count> y_offsets{
        20, // Checkbox
        40, // Button
        20, // Slider
        20, // Dropdown
    };

    static std::array<std::unordered_map<hash_t, d2>, tab_count> all_items{ };
    static std::array<int, tab_count> total_y_offsets{ };
    [[maybe_unused]] static bool once = []
    {
        std::ranges::fill(total_y_offsets, 34);
        return true;
    }();

    auto& items = all_items[static_cast<size_t>(cur_tab)];
    int& y_offset = total_y_offsets[static_cast<size_t>(cur_tab)];

    if (items.find(hash) == items.cend()) {
        items[hash] = { 10, y_offset };
        y_offset += static_cast<int>(y_offsets[static_cast<size_t>(type)]);
    }

    return menu::base_pos + items.at(hash);
}

```

`render/menu/controls.h`:

```h
#pragma once

#include <functional>

#include "menu.h"

namespace menu::controls {

    using namespace render;

#pragma region internal
    d2 calculate_position(ctrl_type type, hash_t id) noexcept;

    inline bool holding_lmb() noexcept
    {
        return input::is_key_active({ VK_LBUTTON, input::key_type::hold });
    }
#pragma endregion

#pragma region items
    void tab(std::wstring_view str, tab_id id) noexcept;
    void checkbox(std::wstring_view str, bool& var) noexcept;
    void button(std::wstring_view str, std::function<void(void)> callback, d2 size) noexcept;
    void slider(std::wstring_view str, int& var, int min, int max) noexcept;
    void slider(std::wstring_view str, float& var, float min, float max, int precision = 0) noexcept;
    void multibox(std::wstring_view str, const std::vector<std::wstring_view>& names, std::vector<bool>& vars) noexcept;
    // void colorpicker(std::wstring_view str, clr3& clr) noexcept;
    // void colorpicker(std::wstring_view str, clr4& clr) noexcept;
    // void inputbox(std::wstring_view str, std::wstring& var) noexcept;
    // void keybinder(uint32_t& key) noexcept;

    template<class ty> requires std::integral<ty> || enumerator<ty>
    void listbox(std::wstring_view str, const std::vector<std::wstring_view>& names, ty& var) noexcept
    {
        constexpr d2 region_size{ 120, 18 };
        const d2 picker_size{ region_size.x, static_cast<int>(region_size.y * (1 + names.size())) };
        const d2 pos = calculate_position(ctrl_type::dropdown, fnv1a::hash(str));

        render::outlined_rect(pos, region_size, clr4::black());
        render::filled_rect(pos.x + 2, pos.y + 2, pos.x + region_size.x - 2, pos.y + region_size.y - 2, inactive_color);

        static bool is_active{ };
        if (input::is_hovering_item(pos, region_size)) {
            if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
                is_active = !is_active;
        }

        text(fonts::menu, { pos.x + 5, pos.y + 2 }, names[var]);
        text(fonts::menu, { pos.x + region_size.x + 5, pos.y }, str);

        if (is_active) {
            for (size_t i{ }; i < names.size(); i++) {
                const int h = region_size.y * i;
                if (input::is_hovering_item({ pos.x, pos.y + static_cast<int>(region_size.y * (i + 1)) }, region_size)) {
                    if (input::is_key_active({ VK_LBUTTON, input::key_type::toggle }))
                        var = static_cast<ty>(i);
                    text(fonts::menu, { pos.x + 2, pos.y + region_size.y + h }, names[i], { }, hover_color);
                } else {
                    text(fonts::menu, { pos.x + 2, pos.y + region_size.y + h }, names[i], { },
                                 var == i ? accent_color : clr4::white());
                }
            }
        }
    }
#pragma endregion

}

```

`render/menu/menu.cpp`:

```cpp
#include "menu.h"
#include "../../core/cheat.h"
#include "../../core/features/variables.h"
#include "controls.h"

void menu::run() noexcept
{
    using namespace controls;

    if (!is_open)
        return;

    handle_movement();

    /* Menu bounds */
    render::filled_rect({ base_pos.x, base_pos.y + 1 }, size, { 30, 30, 30, 255 });
    render::line(base_pos.x + 1, base_pos.y, base_pos.x + size.x - 1, base_pos.y, accent_color);

    tab(L"AIMBOT", tab_id::aimbot);
    tab(L"VISUALS", tab_id::visuals);
    tab(L"MISC", tab_id::misc);
    tab(L"SKINS", tab_id::skins);
    tab(L"CONFIG", tab_id::config);

    static float float_slider{ };
    static int int_slider{ };
    static bool check{ };

    switch (cur_tab) {
    case tab_id::aimbot:
        checkbox(L"Checkbox", check);
        slider(L"Int slider", int_slider, 0, 100);
        slider(L"Float slider", float_slider, -20.f, 20.f, 2);
        listbox(L"Listbox", { L"One", L"Two", L"Three" }, cfg::get<int>(vars::test_multi));
        multibox(L"Multibox", { L"First", L"Second", L"Third", L"Fourth" }, cfg::get<std::vector<bool>>(vars::test_vec));
        break;
    case tab_id::visuals: {
        checkbox(L"Radar reveal", cfg::get<bool>(vars::radar_reveal));
        checkbox(L"ESP", cfg::get<bool>(vars::esp));
        slider(L"FOV", cfg::get<float>(vars::fov), 30.0f, 130.0f);
        slider(L"Viewmodel FOV", cfg::get<float>(vars::viewmodel_fov), 20.0f, 150.0f);
        checkbox(L"Disable postprocessing", cfg::get<bool>(vars::disable_postprocessing));
        break;
    }
    case tab_id::misc:
        checkbox(L"Infinite crouch", cfg::get<bool>(vars::infinite_crouch));
        break;
    case tab_id::skins:
        break;
    case tab_id::config:
        button(L"Write default", [] { cfg::write(L"default.cfg"); }, { 100, 30 });
        button(L"Read default", [] { cfg::read(L"default.cfg"); }, { 100, 30 });
        button(L"Unhook", [] { cheat::should_unhook = true; }, { 55, 30 });
        break;
    default:
        break;
    }
}

void menu::draw_watermark() noexcept
{
    std::string watermark_str{ "hello" };

    /* Time */
    std::time_t time;
    std::tm tm;
    char tm_str[9];
    time = std::time(nullptr);
    localtime_s(&tm, &time);
    std::strftime(tm_str, sizeof(tm_str), "%T", &tm);

    watermark_str += " | ";
    watermark_str += tm_str;

    /* -insecure */
    static const bool insecure = []
    {
        const auto peb = reinterpret_cast<const PEB*>(__readfsdword(0x30));
        return wcsstr(peb->ProcessParameters->CommandLine.Buffer, L"-insecure");
    }();

    if (insecure)
        watermark_str += " | insecure";

    auto size = render::get_text_size(render::fonts::watermark, watermark_str);
    render::filled_rect({ 2, 2 }, { size.x + 5, size.y + 4 }, clr4::black(150));
    render::text(render::fonts::watermark, { 5, 5 }, watermark_str);
}

void menu::handle_movement() noexcept
{
    static bool in_move{ };
    static d2 last_pos{ };

    if (in_move)
        base_pos += (input::mouse_pos - last_pos);

    if (input::is_hovering_item(base_pos, { size.x, 30 })) {
        if (controls::holding_lmb()) {
            in_move = true;
            last_pos = input::mouse_pos;
        } else if (in_move)
            in_move = false;
    }
}

```

`render/menu/menu.h`:

```h
#pragma once

#include "../render.h"
#include "../../core/input.h"

namespace menu {

    enum class tab_id {
        aimbot,
        visuals,
        misc,
        skins,
        config,

        count
    };

    enum class ctrl_type {
        checkbox,
        button,
        slider,
        dropdown,

        count
    };

    /* State */
    inline bool is_open{ };
    inline tab_id cur_tab{ };
    inline d2 base_pos{ 90, 90 };
    inline d2 size{ 600, 500 };

    /* Colors */
    constexpr clr4 inactive_color{ 64, 64, 64, 255 };
    constexpr clr4 hover_color{ 200, 100, 0, 255 };
    inline clr4 accent_color{ 255, 125, 0, 255 };

    void run() noexcept;
    void draw_watermark() noexcept;
    void handle_movement() noexcept;

    inline void toggle() noexcept
    {
        is_open = !is_open;
    }

}

```

`render/render.cpp`:

```cpp
#include "render.h"

bool render::initialize() noexcept
{
    fonts::menu = create_font("Tahoma", 13, 350, font_flag::outline);
    fonts::tab = create_font("Verdana", 13, 350, font_flag::antialias);
    fonts::watermark = create_font("Tahoma", 12, 300, font_flag::outline);
    fonts::esp = create_font("Verdana", 12, 350, cs::font_flag::dropshadow | cs::font_flag::antialias);

    LOG_INFO("Renderer initialized.");
    return true;
}

h_font render::create_font(std::string_view name, int height, int weight, bitfield<font_flag> flags) noexcept
{
    auto font = interfaces::surface->create_font();
    interfaces::surface->set_font_glyph_set(font, name.data(), height, weight, 0, 0, flags.raw());
    return font;
}

d2 render::get_text_size(h_font font, std::wstring_view str) noexcept
{
    d2 ret{ };
    interfaces::surface->get_text_size(font, str.data(), &ret.x, &ret.y);
    return ret;
}

d2 render::get_text_size(h_font font, std::string_view str) noexcept
{
    return get_text_size(font, std::wstring(str.begin(), str.end()));
}

void render::line(int x0, int y0, int x1, int y1, const clr4& clr) noexcept
{
    interfaces::surface->draw_set_color(clr.r, clr.g, clr.b, clr.a);
    interfaces::surface->draw_line(x0, y0, x1, y1);
}

void render::line(d2 pos, d2 size, const clr4& clr) noexcept
{
    return line(pos.x, pos.y, pos.x + size.x, pos.y + size.y, clr);
}

void render::filled_rect(int x0, int y0, int x1, int y1, const clr4& clr) noexcept
{
    interfaces::surface->draw_set_color(clr.r, clr.g, clr.b, clr.a);
    interfaces::surface->draw_filled_rect(x0, y0, x1, y1);
}

void render::filled_rect(d2 pos, d2 size, const clr4& clr) noexcept
{
    return filled_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y, clr);
}

void render::outlined_rect(int x0, int y0, int x1, int y1, const clr4& clr) noexcept
{
    interfaces::surface->draw_set_color(clr.r, clr.g, clr.b, clr.a);
    interfaces::surface->draw_outlined_rect(x0, y0, x1, y1);
}

void render::outlined_rect(d2 pos, d2 size, const clr4& clr) noexcept
{
    return outlined_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y, clr);
}

void render::outlined_circle(d2 center_pos, int radius, int segments, const clr4& clr) noexcept
{
    interfaces::surface->draw_set_color(clr.r, clr.g, clr.b, clr.a);
    interfaces::surface->draw_outlined_circle(center_pos.x, center_pos.y, radius, segments);
}

void render::text(h_font font, d2 pos, std::wstring_view str, bitfield<text_flag> flags, const clr4& clr) noexcept
{
    interfaces::surface->draw_set_text_color(clr.r, clr.g, clr.b, clr.a);
    interfaces::surface->draw_set_text_font(font);

    auto text_pos = pos;
    if (!flags.is_empty()) {
        auto size = get_text_size(font, str);
        if (flags.is_set(text_flag::centered_x))
            text_pos.x -= size.x / 2;
        if (flags.is_set(text_flag::centered_y))
            text_pos.y -= size.y / 2;
    }

    interfaces::surface->draw_set_text_pos(text_pos.x, text_pos.y);
    interfaces::surface->draw_print_text(str.data(), str.length());
}

void render::text(h_font font, d2 pos, std::string_view str, bitfield<text_flag> flags, const clr4& clr) noexcept
{
    return text(font, pos, std::wstring(str.begin(), str.end()), flags, clr);
}

```

`render/render.h`:

```h
#pragma once

#include "../base/math.h"
#include "../memory/interfaces.h"

namespace render {

    namespace fonts {
        inline h_font menu{ };
        inline h_font tab{ };
        inline h_font watermark{ };
        inline h_font esp{ };
    }

    enum class text_flag {
        none,
        centered_x = (1 << 0),
        centered_y = (1 << 1),
        centered = (centered_x | centered_y),
    };

    enum class flag {
        none,
        filled = (1 << 0),
        outlined = (1 << 1)
    };

    bool initialize() noexcept;

    h_font create_font(std::string_view name, int height, int weight, bitfield<font_flag> flags = { }) noexcept;
    d2 get_text_size(h_font font, std::wstring_view str) noexcept;
    d2 get_text_size(h_font font, std::string_view str) noexcept;
    void line(int x0, int y0, int x1, int y1, const clr4& clr = clr4::white()) noexcept;
    void line(d2 pos, d2 size, const clr4& clr = clr4::white()) noexcept;
    void filled_rect(int x0, int y0, int x1, int y1, const clr4& clr = clr4::white()) noexcept;
    void filled_rect(d2 pos, d2 size, const clr4& clr = clr4::white()) noexcept;
    void outlined_rect(int x0, int y0, int x1, int y1, const clr4& clr = clr4::white()) noexcept;
    void outlined_rect(d2 pos, d2 size, const clr4& clr = clr4::white()) noexcept;
    void outlined_circle(d2 center_pos, int radius, int segments = 12, const clr4& clr = clr4::white()) noexcept;
    void text(h_font font, d2 pos, std::wstring_view str, bitfield<text_flag> flags = { }, const clr4& clr = clr4::white()) noexcept;
    void text(h_font font, d2 pos, std::string_view str, bitfield<text_flag> flags = { }, const clr4& clr = clr4::white()) noexcept;

}

```

`valve/cs/animations.h`:

```h
#pragma once

#include "../../memory/memory.h"
#include "utl_vector.h"

namespace cs {

constexpr int max_pose_param = 24;
constexpr int max_anim_layers = 15;
constexpr int max_bones = 256;

struct player;
struct studio_seq_desc;
struct studio_hdr;
struct studio_hdr_t;
struct weapon;

enum class anim_layer {
    aim_matrix,
    weapon_action,
    weapon_action_recrouch,
    adjust,
    movement_jump_or_fall,
    movement_land_or_climb,
    movement_move,
    movement_strafe_change,
    whole_body,
    flashed,
    flinch,
    alive_loop,
    lean
};

enum class anim_layer_activity {
    die_stand = 953,
    die_stand_headshot,
    die_crouch,
    die_crouch_headshot,
    null,
    defuse,
    defuse_with_kit,
    flashbang_reaction,
    fire_primary,
    fire_primary_opt_1,
    fire_primary_opt_2,
    fire_secondary,
    fire_secondary_opt_1,
    fire_secondary_opt_2,
    reload,
    reload_start,
    reload_loop,
    reload_end,
    operate,
    deploy,
    _catch,
    silencer_detach,
    silencer_attach,
    twitch,
    twitch_buyzone,
    plant_bomb,
    idle_turn_balance_adjust,
    idle_adjust_stopped_moving,
    alive_loop,
    flinch,
    flinch_head,
    flinch_molotov,
    jump,
    fall,
    climb_ladder,
    land_light,
    land_heavy,
    exit_ladder_top,
    exit_ladder_bottom
};

enum class pose_param {
    lean_yaw,
    speed,
    ladder_speed,
    ladder_yaw,
    move_yaw,
    run,
    body_yaw,
    body_pitch,
    death_yaw,
    stand,
    jump_fall,
    aim_blend_stand_idle,
    aim_blend_crouch_idle,
    strafe_dir,
    aim_blend_stand_walk,
    aim_blend_stand_run,
    aim_blend_crouch_walk,
    move_blend_walk,
    move_blend_run,
    move_blend_crouch_walk
};

using pose_params = std::array<float, max_pose_param>;

struct base_animating;

struct anim_layer_t {
    float layer_anim_time{ };
    float layer_fadeout_time{ };
    studio_hdr* dispatched_studio_hdr{ };
    int dispatched_src{ };
    int dispatched_dest{ };
    int order{ };
    int sequence{ };
    float prev_cycle{ };
    float weight{ };
    float weight_delta_rate{ };
    float playback_rate{ };
    float cycle{ };
    base_animating* owner{ };
    int invalidate_physics_bits{ };
};

struct anim_state {
    VIRTUAL_FUNCTION_SIG(reset, void, dlls::client, "56 6A 01 68 ? ? ? ? 8B F1", (this))
    VIRTUAL_FUNCTION_SIG(update, void, dlls::client, "55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24", (this, eye_pitch, eye_yaw, force),
        float eye_yaw, float eye_pitch, bool force)

    int* layer_order_preset{ };
    bool first_run_since_init{ };
    PAD(0x5b)
    base_animating* entity{ };
    weapon* cur_weapon{ };
    weapon* last_weapon{ };
    float last_update_time{ };
    int last_update_frame{ };
    float last_update_increment{ };
    float eye_yaw{ };
    float eye_pitch{ };
    float foot_yaw{ };
    float last_foot_yaw{ };
    float move_yaw{ };
    float move_yaw_ideal{ };
    float move_yaw_cur_to_ideal{ };
    PAD(0x4)
    float primary_cycle{ };
    float move_weight{ };
    PAD(0x4)
    float anim_duck_amount{ };
    float duck_additional{ };
    PAD(0x4)
    vec3 cur_position{ };
    vec3 last_position{ };
    vec3 velocity{ };
    vec3 velocity_normalized{ };
    vec3 velocity_normalized_non_zero{ };
    float velocity_length_xy{ };
    float velocity_length_z{ };
    float speed_as_portion_of_run_top_speed{ };
    float speed_as_portion_of_walk_top_speed{ };
    float speed_as_portion_of_crouch_top_speed{ };
    float duration_moving{ };
    float duration_still{ };
    bool is_on_ground{ };
    bool is_landing{ };
    PAD(0x6)
    float duration_in_air{ };
    float left_ground_height{ };
    float land_anim_multiplier{ };
    float walk_to_run_transition{ };
    PAD(0x4)
    float in_air_smooth_value{ };
    bool is_on_ladder{ };
    PAD(0x2f)
    float last_velocity_test_time{ };
    vec3 last_velocity{ };
    vec3 target_acceleration{ };
    vec3 acceleration{ };
    float acceleration_weight{ };
    PAD(0xc)
    float strafe_change_weight{ };
    PAD(0x4)
    float strafe_change_cycle{ };
    int strafe_sequence{ };
    PAD(0x184)
    float camera_smooth_height{ };
    bool smooth_height_valid{ };
    PAD(0xb)
    float aim_yaw_min{ };
    float aim_yaw_max{ };
    float aim_pitch_min{ };
    float aim_pitch_max{ };
    int anim_state_version{ };
};

struct ik_target {
    int frame_count{ };
    PAD(0x51)
};

struct ik_context {
    VIRTUAL_FUNCTION_SIG(construct, void, dlls::client,
        "53 8B D9 F6 C3 03 74 0B FF 15 ?? ?? ?? ?? 84 C0 74 01 CC C7 83 ?? ?? ?? ?? ?? ?? ?? ?? 8B CB", (this))
    VIRTUAL_FUNCTION_SIG(destruct, void, dlls::client,
        "56 8B F1 57 8D 8E ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 8E ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 BE", (this))
    VIRTUAL_FUNCTION_SIG(init, void, dlls::client, "55 8B EC 83 EC ? 8B 45 ? 56 57 8B F9 8D 8F",
        (this, hdr, angles, pos, time, frame_counter, bone_mask),
        studio_hdr* hdr, angle& angles, vec3& pos, float time, int frame_counter, int bone_mask)
    VIRTUAL_FUNCTION_SIG(add_dependencies, void, dlls::client, "55 8B EC 81 EC ? ? ? ? 53 56 57 8B F9 0F 28 CB F3 0F 11 4D",
        (this, seq_desc, sequence, cycle, pose_params, weight),
        studio_seq_desc& seq_desc, int sequence, float cycle, const float* pose_params, float weight)
    VIRTUAL_FUNCTION_SIG(solve_dependencies, void, dlls::client, "55 8B EC 83 E4 ? 81 EC ? ? ? ? 8B 81 ? ? ? ? 56 57",
        (this, pos, q, bone_to_world, bone_computed), vec3* pos, vec4* q, mat3x4* bone_to_world, uint8_t* bone_computed)
    VIRTUAL_FUNCTION_SIG(update_targets, void, dlls::client, "55 8B EC 83 E4 ? 81 EC ? ? ? ? 33 D2 89 4C 24 ? 56 57",
        (this, pos, q, bone_to_world, bone_computed), vec3* pos, vec4* q, mat3x4* bone_to_world, uint8_t* bone_computed)
    VIRTUAL_FUNCTION_SIG(copy_to, void, dlls::client, "55 8B EC 83 EC 24 8B 45 08 57 8B F9 89 7D F4 85 C0",
        (this, other, remapping), ik_context* other, const unsigned short* remapping)
};

enum class bone_flag {
    always_procedural = (1 << 2),
    used_by_anything = 0xfff00,
    used_by_hitbox = (1 << 8),
    used_by_bone_merge = (1 << 18)
};

struct bone_cache {
    mat3x4* cached_bones{ };
    PAD(0x8)
    uint32_t count{ };
};

struct bone_merge_cache {
    struct merged_bone {
        unsigned short my_bone{ };
        unsigned short parent_bone{ };
    };

    base_animating* owner{ };
    base_animating* follow{ };
    studio_hdr* follow_hdr{ };
    const studio_hdr_t* follow_render_hdr{ };
    studio_hdr* owner_hdr{ };
    const studio_hdr_t* owner_render_hdr{ };
    int copied_framecount{ };
    bitfield<bone_flag> follow_bone_setup_mask{ };
    pose_param owner_to_follow_pose_param_mapping[max_pose_param]{ };
    utl_vec<merged_bone> merged_bones{ };
    uint32_t* bone_merge_bits{ };
    unsigned short raw_index_mapping[max_bones]{ };
    bool force_cache_clear{ };
};

struct bone_accessor {
    base_animating* animating{ };
    mat3x4* bones{ };
    int readable_bones{ };
    int writable_bones{ };
};

struct bone_setup {
    void init_pose(const studio_hdr* hdr, vec3* pos, vec4* q, int bone_mask) noexcept
    {
        static void(* init_pose_fn)(const studio_hdr*, vec3*, vec4*, int) =
            dlls::client.find(PATTERN("55 8B EC 83 EC 10 53 8B D9 89 ? ? 56 57 89")).cast<decltype(init_pose_fn)>();
        return init_pose_fn(hdr, pos, q, bone_mask);
    }

    VIRTUAL_FUNCTION_SIG(accumulate_pose, void, dlls::client, "55 8B EC 83 E4 ? B8 ? ? ? ? E8 ? ? ? ? A1 ? ? ? ? 56 57 8B F9",
        (this, pos, q, sequence, cycle, weight, time, ik_ctx),
        vec3* pos, vec4* q, int sequence, float cycle, float weight, float time, ik_context* ik_ctx)
};

}

```

`valve/cs/client_class.h`:

```h
#pragma once

#include <type_traits>

namespace cs {

struct networkable;

enum class class_id {
    ai_base_npc,
    weapon_ak47,
    base_animating,
    base_animating_overlay,
    base_attributable_item,
    base_button,
    base_combat_character,
    base_combat_weapon,
    base_cs_grenade,
    base_cs_grenade_projectile,
    base_door,
    base_entity,
    base_flex,
    base_grenade,
    base_particle_entity,
    base_player,
    base_prop_door,
    base_team_objective_resource,
    base_temp_entity,
    base_toggle,
    base_trigger,
    base_viewmodel,
    base_vphysics_trigger,
    base_weapon_world_model,
    beam,
    beam_spotlight,
    bone_follower,
    br_c4_target,
    breach_charge,
    breach_charge_projectile,
    breakable_prop,
    breakable_surface,
    bump_mine,
    bump_mine_projectile,
    c4,
    cascade_light,
    chicken,
    color_correction,
    color_correction_volume,
    cs_gamerules_proxy,
    cs_player,
    cs_player_resource,
    cs_ragdoll,
    cs_team,
    dangerzone,
    dangerzone_controller,
    deagle,
    decoy_grenade,
    decoy_projectile,
    drone,
    drone_gun,
    dynamic_light,
    dynamic_prop,
    econ_entity,
    econ_wearable,
    embers,
    entity_dissolve,
    entity_flame,
    entity_freezing,
    entity_particle_trail,
    env_ambient_light,
    env_detail_controller,
    env_dof_controller,
    env_gas_canister,
    env_particle_script,
    env_projected_texture,
    env_quadratic_beam,
    env_screen_effect,
    env_screen_overlay,
    env_tonemap_controller,
    env_wind,
    fe_player_decal,
    firecracker_blast,
    fire_smoke,
    fire_trail,
    fish,
    fists,
    flashbang,
    fog_controller,
    footstep_control,
    func_dust,
    func_lod,
    func_area_portal_window,
    func_brush,
    func_conveyor,
    func_ladder,
    func_monitor,
    func_move_linear,
    func_occluder,
    func_reflective_glass,
    func_rotating,
    func_smoke_volume,
    func_track_train,
    gamerules_proxy,
    grass_burn,
    handle_test,
    he_grenade,
    hostage,
    hostage_carriable_prop,
    incendiary_grenade,
    inferno,
    info_ladder_dismount,
    info_map_region,
    info_overlay_accessor,
    item_healthshot,
    item_cash,
    item_dogtags,
    knife,
    knife_gg,
    light_glow,
    map_veto_pick_controller,
    material_modify_control,
    melee,
    molotov_grenade,
    molotov_projectile,
    movie_display,
    paradrop_chopper,
    particle_fire,
    particle_performance_monitor,
    particle_system,
    phys_box,
    phys_box_multiplayer,
    physics_prop,
    physics_prop_multiplayer,
    phys_magnet,
    phys_prop_ammo_box,
    phys_prop_loot_crate,
    phys_prop_radar_jammer,
    phys_prop_weapon_upgrade,
    planted_c4,
    plasma,
    player_ping,
    player_resource,
    point_camera,
    point_comment_arynode,
    point_world_text,
    pose_controller,
    post_process_controller,
    precipitation,
    precipitation_blocker,
    predicted_view_model,
    prop_hallucination,
    prop_counter,
    prop_door_rotating,
    prop_jeep,
    prop_vehicle_driveable,
    ragdoll_manager,
    ragdoll_prop,
    ragdoll_prop_attached,
    rope_keyframe,
    weapon_scar17,
    scene_entity,
    sensor_grenade,
    sensor_grenade_projectile,
    shadow_control,
    slide_show_display,
    smoke_grenade,
    smoke_grenade_projectile,
    smoke_stack,
    snowball,
    snowball_pile,
    snowball_projectile,
    spatial_entity,
    spotlight_end,
    sprite,
    sprite_oriented,
    sprite_trail,
    statue_prop,
    steamjet,
    sun,
    sunlight_shadow_control,
    survival_spawn_chopper,
    tablet,
    team,
    team_playround_based_rules_proxy,
    tear_morricochet,
    te_base_beam,
    te_beam_ent_point,
    te_beam_ents,
    te_beam_follow,
    te_beam_laser,
    te_beam_points,
    te_beam_ring,
    te_beam_ring_point,
    te_beam_spline,
    te_blood_sprite,
    te_blood_stream,
    te_break_model,
    te_bsp_decal,
    te_bubbles,
    te_bubble_trail,
    te_client_projectile,
    te_decal,
    te_dust,
    te_dynamic_light,
    te_effect_dispatch,
    te_energy_splash,
    te_explosion,
    te_fire_bullets,
    te_fizz,
    te_footprint_decal,
    te_foundry_helpers,
    te_gauss_explosion,
    te_glow_sprite,
    te_impact,
    te_kill_player_attachments,
    te_large_funnel,
    te_metal_sparks,
    te_muzzle_flash,
    te_particle_system,
    te_physics_prop,
    te_plant_bomb,
    te_player_anim_event,
    te_player_decal,
    te_projected_decal,
    te_radioicon,
    te_shatter_surface,
    te_show_line,
    te_sla,
    te_smoke,
    te_sparks,
    te_sprite,
    te_sprite_spray,
    test_proxy_toggle_networkable,
    test_trace_line,
    te_world_decal,
    trigger_player_movement,
    trigger_sound_operator,
    vgui_screen,
    vote_controller,
    water_bullet,
    water_lod_control,
    weapon_aug,
    weapon_awp,
    weapon_base_item,
    weapon_ppbizon,
    weapon_cs_base,
    weapon_cs_base_gun,
    weapon_cycler,
    weapon_dual_berettas,
    weapon_famas,
    weapon_fiveseven,
    weapon_g3sg1,
    weapon_galil,
    weapon_galil_ar,
    weapon_glock18,
    weapon_p2000,
    weapon_m249,
    weapon_m3,
    weapon_m4a4,
    weapon_mac10,
    weapon_mag7,
    weapon_mp5sd,
    weapon_mp7,
    weapon_mp9,
    weapon_negev,
    weapon_nova,
    weapon_p228,
    weapon_p250,
    weapon_p90,
    weapon_sawedoff,
    weapon_scar20,
    weapon_scout,
    weapon_sg550,
    weapon_sg552,
    weapon_sg553,
    weapon_ballistic_shield,
    weapon_ssg08,
    weapon_zeusx27,
    weapon_tec9,
    weapon_tmp,
    weapon_ump45,
    weapon_usp,
    weapon_xm1014,
    world,
    world_vgui_text,
    dust_trail,
    movie_explosion,
    particle_smoke_grenade,
    rocket_trail,
    smoke_trail,
    spore_explosion,
    spore_trail
};

struct recv_table;

struct client_class {
    std::add_pointer_t<cs::networkable*(int, int)> create_client_class_fn{ };
    std::add_pointer_t<cs::networkable*()> create_event_fn{ };
    const char* network_name{ };
    recv_table* recv_table{ };
    client_class* next{ };
    class_id id{ };
};

}

```

`valve/cs/cmd.h`:

```h
#pragma once

#include "../../crypt/crc32.h"

namespace cs {

enum class cmd_button {
    attack = (1 << 0),
    jump = (1 << 1),
    duck = (1 << 2),
    forward = (1 << 3),
    back = (1 << 4),
    use = (1 << 5),
    cancel = (1 << 6),
    left = (1 << 7),
    right = (1 << 8),
    move_left = (1 << 9),
    move_right = (1 << 10),
    second_attack = (1 << 11),
    run = (1 << 12),
    reload = (1 << 13),
    left_alt = (1 << 14),
    right_alt = (1 << 15),
    score = (1 << 16),
    speed = (1 << 17),
    walk = (1 << 18),
    zoom = (1 << 19),
    first_weapon = (1 << 20),
    second_weapon = (1 << 21),
    bullrush = (1 << 22),
    first_grenade = (1 << 23),
    second_grenade = (1 << 24),
    middle_attack = (1 << 25),
    use_or_reload = (1 << 26)
};

struct user_cmd {
    PAD(0x4)
    int number{ };
    int tick_count{ };
    angle view_angles{ };
    vec3 aim_direction{ };
    vec3 move_direction{ };
    bitfield<cmd_button> buttons{ };
    char impulse{ };
    int weapon_select{ };
    int weapon_subtype{ };
    int random_seed{ };
    short mouse_dx{ };
    short mouse_dy{ };
    bool has_been_predicted{ };
    PAD(0x18)

    inline crc32_t get_checksum() const noexcept
    {
        crc32_t ret{ std::numeric_limits<crc32_t>::max() };

        crc32::process_data(ret, &number);
        crc32::process_data(ret, &tick_count);
        crc32::process_data(ret, &view_angles);
        crc32::process_data(ret, &aim_direction);
        crc32::process_data(ret, &move_direction);
        crc32::process_data(ret, &buttons);
        crc32::process_data(ret, &impulse);
        crc32::process_data(ret, &weapon_select);
        crc32::process_data(ret, &weapon_subtype);
        crc32::process_data(ret, &random_seed);
        crc32::process_data(ret, &mouse_dx);
        crc32::process_data(ret, &mouse_dy);

        return ~ret;
    }
};

struct verified_user_cmd {
    user_cmd cmd{ };
    crc32_t crc{ };
};

struct move_data {
    bool first_run_of_functions : 1{ };
    bool game_code_moved_player : 1{ };
    bool no_air_control : 1{ };
    unsigned long player_handle{ };
    int impulse_cmd{ };
    angle view_angles{ };
    angle abs_view_angles{ };
    bitfield<cmd_button> buttons{ };
    bitfield<cmd_button> old_buttons{ };
    vec3 move_direction{ };
    float max_speed{ };
    float max_client_speed{ };
    vec3 velocity{ };
    vec3 trailing_velocity{ };
    float trailing_velocity_time{ };
    angle angles{ };
    angle old_angles{ };
    float out_step_height{ };
    vec3 out_wish_velocity{ };
    vec3 out_jump_velocity{ };
    vec3 constraint_center{ };
    float constraint_radius{ };
    float constraint_width{ };
    float constraint_speed_factor{ };
    bool constraint_past_radius{ };
    vec3 abs_origin{ };
};

}

```

`valve/cs/convar.h`:

```h
#pragma once

#include "../../memory/memory.h"

#include "utl_vector.h"

namespace cs {

enum class convar_flag {
    development_only = (1 << 1),
    cheat = (1 << 14)
};

struct convar_value {
    char* string{ };
    int string_length{ };
    float float_value{ };
    int int_value;
};

struct command_base {
    VIRTUAL_FUNCTION(is_flag_set, bool, 2, (convar_flag flag), (this, flag))
    VIRTUAL_FUNCTION(add_flags, void, 3, (convar_flag flags), (this, flags))
    VIRTUAL_FUNCTION(remove_flags, void, 4, (convar_flag flags), (this, flags))
    VIRTUAL_FUNCTION(get_next, command_base*, 9, (), (this))
};

struct convar : command_base {
    VIRTUAL_FUNCTION(get_name, const char*, 5, (), (this))
    VIRTUAL_FUNCTION(get_base_name, const char*, 6, (), (this))

    auto get_float() noexcept
    {
        auto xored = *reinterpret_cast<uintptr_t*>(&parent->original.float_value) ^ reinterpret_cast<uintptr_t>(this);
        return *reinterpret_cast<float*>(&xored);
    }

    auto get_int() noexcept
    {
        return static_cast<int>(parent->original.int_value ^ reinterpret_cast<uintptr_t>(this));
    }

    auto get_bool() noexcept
    {
        return !!get_int();
    }

    auto get_string() noexcept
    {
        return parent->original.string ? parent->original.string : "";
    }

    VIRTUAL_FUNCTION(set_value, void, 14, (const char* value), (this, value))
    VIRTUAL_FUNCTION(set_value, void, 15, (float value), (this, value))
    VIRTUAL_FUNCTION(set_value, void, 16, (int value), (this, value))

    PAD(0x4)
    convar* next{ };
    int registered{ };
    char* name{ };
    char* help_string{ };
    bitfield<convar_flag> flags{ };
    PAD(0x4)
    convar* parent{ };
    char* default_value{ };
    convar_value original{ };
    convar_value backup{ };
    int has_min{ };
    float min{ };
    int has_max{ };
    float max{ };
    utl_vec<std::add_pointer_t<void(convar*, const char*, float)>> on_change_callbacks{ };
};

}

```

`valve/cs/cs.h`:

```h
#pragma once

#include "../../base/base.h"

#include "animations.h"
#include "client_class.h"
#include "cmd.h"
#include "convar.h"
#include "datatables.h"
#include "entity.h"
#include "game_event.h"
#include "key_values.h"
#include "leaf_system.h"
#include "material.h"
#include "model.h"
#include "player.h"
#include "studio.h"
#include "trace.h"
#include "util.h"
#include "utl_vector.h"
#include "view.h"
#include "world.h"

#include "util.h"

```

`valve/cs/datatables.h`:

```h
#pragma once

namespace cs {

enum class send_prop_type {
    dpt_int,
    dpt_float,
    dpt_vector,
    dpt_vector_xy,
    dpt_string,
    dpt_array,
    dpt_datatable,
    dpt_int64
};

struct d_variant {
    union {
        float flt;
        long integer;
        char* string;
        void* data_tables;
        vec3 vector;
        int64_t int64;
    };
};

struct recv_prop;

struct recv_proxy_data {
    const recv_prop* recv_prop{ };
    d_variant value{ };
    int element{ };
    int object_id{ };
};

using recv_proxy_fn = std::add_pointer_t<void(recv_proxy_data*, void*, void*)>;

struct recv_table {
    recv_prop* props{ };
    int prop_amt{ };
    void* decoder{ };
    char* net_table_name{ };
    bool is_initialized{ };
    bool is_in_main_list{ };
};

struct recv_prop {
    char* var_name{ };
    send_prop_type recv_type{ };
    int flags{ };
    int string_buffer_size{ };
    bool is_inside_array{ };
    const void* extra_data{ };
    recv_prop* array_prop{ };
    void* array_length_proxy{ };
    recv_proxy_fn proxy_fn{ };
    void* data_table_proxy_fn{ };
    recv_table* data_table{ };
    int offset{ };
    int element_stride{ };
    int elements{ };
    const char* parent_array_prop_name{ };
};

enum class offset_type {
    normal,
    packed
};

enum class field_type {
    _void,
    _float,
    string,
    vector,
    quaternion,
    integer,
    boolean,
    _short,
    character,
    color32,
    embedded,
    custom,
    classptr,
    ehandle,
    edict,
    position_vector,
    time,
    tick,
    modelname,
    soundname,
    input,
    function,
    vmatrix,
    vmatrix_worldspace,
    matrix3x4_worldspace,
    interval,
    modelindex,
    materialindex,
    vector2d
};

struct datamap;
struct input_data;

using input_fn = void(*)(input_data&);

struct type_description {
    field_type type{ };
    const char* field_name{ };
    int field_offset{ };
    uint16_t field_size{ };
    uint16_t flags{ };
    const char* external_name{ };
    uintptr_t* save_restore_ops{ };
    input_fn input_fn{ };
    datamap* data_map{ };
    uint32_t field_size_in_bytes{ };
    type_description* override_field{ };
    uint32_t override_count{ };
    float field_tolerance{ };
    int flat_offset[2]{ };
    uint16_t flat_group{ };
};

struct datamap {
    type_description* data_description{ };
    int data_fields_count{ };
    char const* data_class_name{ };
    datamap* base_map{ };

    bool chains_validated{ };
    bool packed_offsets_computed{ };
    int packed_size{ };
};

}

```

`valve/cs/entity.cpp`:

```cpp
#include "entity.h"
#include "../../memory/interfaces.h"

namespace cs {

entity_type base_entity::get_entity_type() noexcept
{
    switch (get_client_class()->id) {
    case class_id::cs_player:
        return entity_type::player;
    case class_id::base_cs_grenade_projectile:
    case class_id::breach_charge_projectile:
    case class_id::decoy_projectile:
    case class_id::molotov_projectile:
    case class_id::sensor_grenade_projectile:
    case class_id::smoke_grenade_projectile:
    case class_id::base_cs_grenade:
    case class_id::breach_charge:
    case class_id::decoy_grenade:
    case class_id::flashbang:
    case class_id::he_grenade:
    case class_id::incendiary_grenade:
    case class_id::molotov_grenade:
    case class_id::sensor_grenade:
    case class_id::smoke_grenade:
    case class_id::particle_smoke_grenade:
    case class_id::inferno:
        return entity_type::grenade;
    case class_id::c4:
    case class_id::planted_c4:
        return entity_type::bomb;
    case class_id::weapon_ak47:
    case class_id::deagle:
    case class_id::weapon_aug:
    case class_id::weapon_awp:
    case class_id::weapon_base_item:
    case class_id::weapon_ppbizon:
    case class_id::weapon_cs_base:
    case class_id::weapon_cs_base_gun:
    case class_id::weapon_cycler:
    case class_id::weapon_dual_berettas:
    case class_id::weapon_famas:
    case class_id::weapon_fiveseven:
    case class_id::weapon_g3sg1:
    case class_id::weapon_galil:
    case class_id::weapon_galil_ar:
    case class_id::weapon_glock18:
    case class_id::weapon_p2000:
    case class_id::weapon_m249:
    case class_id::weapon_m3:
    case class_id::weapon_m4a4:
    case class_id::weapon_mac10:
    case class_id::weapon_mag7:
    case class_id::weapon_mp5sd:
    case class_id::weapon_mp7:
    case class_id::weapon_mp9:
    case class_id::weapon_negev:
    case class_id::weapon_nova:
    case class_id::weapon_p228:
    case class_id::weapon_p250:
    case class_id::weapon_p90:
    case class_id::weapon_sawedoff:
    case class_id::weapon_scar20:
    case class_id::weapon_scout:
    case class_id::weapon_sg550:
    case class_id::weapon_sg552:
    case class_id::weapon_sg553:
    case class_id::weapon_ballistic_shield:
    case class_id::weapon_ssg08:
    case class_id::weapon_zeusx27:
    case class_id::weapon_tec9:
    case class_id::weapon_tmp:
    case class_id::weapon_ump45:
    case class_id::weapon_usp:
    case class_id::weapon_xm1014:
        return entity_type::weapon;
    default:
        return entity_type::unknown;
    }

}

weapon_info* weapon::get_info() noexcept
{
    return interfaces::weapon_system->get_weapon_data(get_item_id());
}

float planted_c4::get_remaining_time() noexcept
{
    return std::clamp(get_blow_time() - interfaces::globals->cur_time, 0.0f, get_total_time());
}

float planted_c4::get_remaining_defuse_time() noexcept
{
    return std::clamp(get_defuse_countdown() - interfaces::globals->cur_time, 0.0f, get_defuse_length());
}

}

```

`valve/cs/entity.h`:

```h
#pragma once

#include "../../core/netvars.h"
#include "../../memory/memory.h"

#include "animations.h"
#include "client_class.h"
#include "cmd.h"
#include "utl_vector.h"
#include "view.h"

namespace cs {

static constexpr int invalid_handle = -1;

struct base_entity;
struct model;
struct client_class;
struct datamap;
struct ray;
struct trace;

enum class solid_type {
    none,
    bsp,
    bbox,
    obb,
    obb_yaw,
    custom,
    vphysics
};

enum class solid_flag {
    customraytest = (1 << 0),
    customboxtest = (1 << 1),
    not_solid = (1 << 2),
    trigger = (1 << 3),
    not_standable = (1 << 4),
    volume_contents = (1 << 5),
    force_world_aligned = (1 << 6),
    use_trigger_bounds = (1 << 7),
    root_parent_aligned = (1 << 8),
    trigger_touch_debris = (1 << 9),
    trigger_touch_player = (1 << 10),
    not_moveable = (1 << 11)
};

enum class data_update_type {
    created,
    datatable_changed,
    post_update
};

struct base_handle {
    uint32_t value{ };

    bool is_valid() const noexcept
    {
        return value != invalid_handle;
    }

    operator uint32_t() noexcept
    {
        return value;
    }

    bool operator==(const base_handle handle) const noexcept
    {
        return value == handle.value;
    }
};

struct unknown;

struct collideable {
    virtual void* get_entity_handle() = 0;
    virtual vec3& obb_mins() const = 0;
    virtual vec3& obb_maxs() const = 0;
    virtual void world_space_trigger_bounds(vec3* mins, vec3* maxs) const = 0;
    virtual bool test_collision(const cs::ray& ray, unsigned int mask, cs::trace& trace) = 0;
    virtual bool test_hitboxes(const cs::ray& ray, unsigned int mask, cs::trace& trace) = 0;
    virtual int get_collision_model_index() = 0;
    virtual const cs::model* get_collision_model() = 0;
    virtual const vec3& get_collision_origin() const = 0;
    virtual const angle& get_collision_angles() const = 0;
    virtual const mat3x4& collision_to_world_transform() const = 0;
    virtual cs::solid_type get_solid_type() const = 0;
    virtual int get_solid_flags() const = 0;
    virtual unknown* get_client_unknown() = 0;
    virtual int get_collision_group() const = 0;
};

struct renderable {
    virtual unknown* get_client_unknown() = 0;
    virtual vec3 const& get_render_origin() = 0;
    virtual angle const& get_render_angles() = 0;
    virtual bool should_draw() = 0;
    virtual int get_render_flags() = 0;
    virtual void is_transparent() = 0;
    virtual uint16_t get_shadow_handle() const = 0;
    virtual uint16_t& get_render_handle() = 0;
    virtual const cs::model* get_model() const = 0;
    virtual int draw_model(int flags, uint8_t alpha) = 0;
    virtual int get_body() = 0;
    virtual void get_color_modulation(float* color) = 0;
    virtual bool lod_test() = 0;
    virtual bool setup_bones(mat3x4* bones, int max, int mask, float time) = 0;
    virtual void do_animation_events() = 0;
    virtual void* get_pvs_notify_interface() = 0;
    virtual void get_render_bounds(vec3& mins, vec3& maxs) = 0;
};

struct networkable {
    virtual unknown* get_client_unknown() = 0;
    virtual void release() = 0;
    virtual cs::client_class* get_client_class() = 0;
    virtual void notify_should_transmit(int state) = 0;
    virtual void on_pre_data_changed(cs::data_update_type update_type) = 0;
    virtual void on_data_changed(cs::data_update_type update_type) = 0;
    virtual void pre_data_update(cs::data_update_type update_type) = 0;
    virtual void post_data_update(cs::data_update_type update_type) = 0;
    virtual void on_data_unchanged_in_pvs() = 0;
    virtual bool is_dormant() const = 0;
    virtual int	get_index() const = 0;
    virtual void receive_message(cs::class_id class_index, void* msg) = 0;
    virtual void* get_data_table_base_ptr() = 0;
    virtual void set_destroyed_on_recreate_entities() = 0;
};

struct thinkable {
    virtual unknown* get_client_unknown() = 0;
    virtual void client_think() = 0;
    virtual void* think_handle() = 0;
    virtual void set_think_handle(void* think) = 0;
    virtual void release() = 0;
};

struct handle_entity {
    virtual	~handle_entity() = default;
    virtual void set_ref_handle(const base_handle& handle) = 0;
    virtual const base_handle& get_ref_handle() = 0;
};

struct client_entity;

struct unknown : handle_entity {
    virtual collideable* get_collideable() = 0;
    virtual networkable* get_networkable() = 0;
    virtual renderable* get_renderable() = 0;
    virtual client_entity* get_client_entity() = 0;
    virtual cs::base_entity* get_base_entity() = 0;
    virtual thinkable* get_thinkable() = 0;
    virtual void* get_alpha_property() = 0;
};

struct client_entity : public unknown, public renderable, public networkable, public thinkable {
    VIRTUAL_FUNCTION(get_data_desc_map, cs::datamap*, 15, (), (this))
    VIRTUAL_FUNCTION(get_pred_desc_map, cs::datamap*, 17, (), (this))
};

enum class item_id {
    weapon_none = 0,
    desert_eagle,
    dual_berettas,
    fiveseven,
    glock18,
    ak47 = 7,
    aug,
    awp,
    famas,
    g3sg1,
    galil_ar = 13,
    m249,
    m4a4 = 16,
    mac10,
    p90 = 19,
    repulsor_device,
    mp5sd = 23,
    ump45,
    xm1014,
    ppbizon,
    mag7,
    negev,
    sawedoff,
    tec9,
    zeus_x27,
    p2000,
    mp7,
    mp9,
    nova,
    p250,
    ballistic_shield,
    scar20,
    sg_553,
    ssg_08,
    knife_gold,
    knife_default_ct,
    grenade_flashbang,
    grenade_he,
    grenade_smoke,
    grenade_molotov,
    grenade_decoy,
    grenade_incendiary,
    c4,
    kevlar,
    kevlar_helmet,
    heavy_assault_suit,
    defuse_kit = 55,
    rescue_kit,
    medishot,
    knife_default_t = 59,
    m4a1s,
    usps,
    cz75a = 63,
    r8_revolver,
    grenade_ta = 68,
    bare_hands,
    breach_charge,
    tablet = 72,
    melee = 74,
    axe,
    hammer,
    wrench = 78,
    knife_spectral_shiv = 80,
    grenade_fire_bomb,
    grenade_diversion_device,
    grenade_frag,
    snowball,
    bump_mine,
    knife_bayonet = 500,
    knife_classic = 503,
    knife_flip = 505,
    knife_gut,
    knife_karambit,
    knife_m9_bayonet,
    knife_huntsman,
    knife_falchion = 512,
    knife_bowie = 514,
    knife_butterfly,
    knife_shadow_daggers,
    knife_paracord,
    knife_survival,
    knife_ursus,
    knife_navaja,
    knife_nomad,
    knife_stiletto,
    knife_talon,
    knife_skeleton = 525,
    glove_brokenfang = 4725,
    glove_bloodhound = 5027,
    glove_default_t,
    glove_default_ct,
    glove_sport,
    glove_driver,
    glove_hand_wraps,
    glove_moto,
    glove_specialist,
    glove_hydra,
    agent_t_map_based,
    agent_ct_map_based,
    agent_t_anarchist,
    agent_t_anarchist_a,
    agent_t_anarchist_b,
    agent_t_anarchist_c,
    agent_t_anarchist_d,
    agent_t_pirate,
    agent_t_pirate_a,
    agent_t_pirate_b,
    agent_t_pirate_c,
    agent_t_pirate_d,
    agent_t_professional,
    agent_t_professional_a,
    agent_t_professional_b,
    agent_t_professional_c,
    agent_t_professional_d,
    agent_t_separatist,
    agent_t_separatist_a,
    agent_t_separatist_b,
    agent_t_separatist_c,
    agent_t_separatist_d,
    agent_ct_gign,
    agent_ct_gign_a,
    agent_ct_gign_b,
    agent_ct_gign_c,
    agent_ct_gign_d,
    agent_ct_gsg9,
    agent_ct_gsg9_a,
    agent_ct_gsg9_b,
    agent_ct_gsg9_c,
    agent_ct_gsg9_d,
    agent_ct_idf,
    agent_ct_idf_b,
    agent_ct_idf_c,
    agent_ct_idf_d,
    agent_ct_idf_e,
    agent_ct_idf_f,
    agent_ct_swat,
    agent_ct_swat_a,
    agent_ct_swat_b,
    agent_ct_swat_c,
    agent_ct_swat_d,
    agent_ct_sas_a,
    agent_ct_sas_b,
    agent_ct_sas_c,
    agent_ct_sas_d,
    agent_ct_st6,
    agent_ct_st6_a,
    agent_ct_st6_b,
    agent_ct_st6_c,
    agent_ct_st6_d,
    agent_t_balkan,
    agent_t_balkan_a,
    agent_t_balkan_b,
    agent_t_balkan_c,
    agent_t_balkan_d,
    agent_t_jumpsuit_a,
    agent_t_jumpsuit_b,
    agent_t_jumpsuit_c,
    agent_t_heavy,
    agent_ct_heavy,
    agent_t_leet_a = 5100,
    agent_t_leet_b,
    agent_t_leet_c,
    agent_t_leet_d,
    agent_t_leet_e,
    agent_t_elite_crew_ground_rebel,
    agent_t_elite_crew_osiris,
    agent_t_elite_crew_prof_shahmat,
    agent_t_elite_crew_mr_muhlik,
    agent_t_phoenix = 5200,
    agent_t_phoenix_a,
    agent_t_phoenix_b,
    agent_t_phoenix_c,
    agent_t_phoenix_d,
    agent_t_phoenix_soldier,
    agent_t_phoenix_enforcer,
    agent_t_phoenix_slingshot,
    agent_t_phoenix_i,
    agent_ct_fbi = 5300,
    agent_ct_fbi_a,
    agent_ct_fbi_c,
    agent_ct_fbi_d,
    agent_ct_fbi_e,
    agent_ct_fbi_f,
    agent_ct_fbi_g,
    agent_ct_fbi_h,
    agent_ct_fbi_b,
    agent_ct_st6_k = 5400,
    agent_ct_st6_e,
    agent_ct_st6_g,
    agent_ct_st6_m,
    agent_ct_st6_i,
    agent_ct_st6_j = 4619,
    agent_ct_st6_l = 4680,
    agent_t_balkan_f = 5500,
    agent_t_balkan_i,
    agent_t_balkan_g,
    agent_t_balkan_j,
    agent_t_balkan_h,
    agent_t_balkan_k = 4718,
    agent_t_balkan_l = 5505,
    agent_ct_sas = 5600,
    agent_ct_sas_b_squadron_officer,
    agent_ct_swat_e = 4711,
    agent_ct_swat_f,
    agent_ct_swat_g,
    agent_ct_swat_h,
    agent_ct_swat_i,
    agent_ct_swat_j,
    agent_t_professional_e = 4726,
    agent_t_professional_f_1 = 4733,
    agent_t_professional_f_2,
    agent_t_professional_f_3,
    agent_t_professional_f_4,
    agent_t_professional_g = 4727,
    agent_t_professional_h,
    agent_t_professional_i = 4732,
    agent_t_professional_j = 4730
};

enum class weapon_type {
    knife,
    pistol,
    smg,
    rifle,
    shotgun,
    sniper,
    machinegun,
    c4,
    grenade = 9,
    health_shot = 11,
    fists,
    breach_charge,
    bumpmine,
    tablet,
    melee
};

enum class entity_flag {
    on_ground = (1 << 0),
    ducking = (1 << 1),
    anim_ducking = (1 << 2),
    water_jump = (1 << 3),
    frozen = (1 << 6),
    in_water = (1 << 10),
    godmode = (1 << 15)
};

enum class eflag {
    dirty_abs_transform = (1 << 11),
    dirty_abs_velocity = (1 << 12),
    dirty_abs_ang_velocity = (1 << 13),
    no_think_function = (1 << 22),
    no_game_physics_simulation = (1 << 23)
};

enum class effect {
    no_interpolation = (1 << 3)
};

enum class move_type {
    none,
    walk = 2,
    noclip = 8,
    ladder = 9,
    observer = 10
};

enum class hitbox {
    head,
    neck,
    pelvis,
    stomach,
    lower_chest,
    chest,
    upper_chest,
    right_thigh,
    left_thigh,
    right_calf,
    left_calf,
    right_foot,
    left_foot,
    right_hand,
    left_hand,
    right_upper_arm,
    right_forearm,
    left_upper_arm,
    left_forearm
};

enum class hitgroup {
    invalid = -1,
    generic,
    head,
    chest,
    stomach,
    left_arm,
    right_arm,
    left_leg,
    right_leg,
    gear = 10
};

enum class team {
    unassigned,
    spectator,
    t,
    ct
};

enum class think_method {
    all_functions
};

enum class interpolation_flag {
    latch_animation_var = (1 << 0),
    latch_simulation_var = (1 << 1)
};

/* An entity is only ever one of these, but setting this up
   as a bitfield makes it easier to filter them. */
enum class entity_type {
    player = (1 << 0),
    weapon = (1 << 1),
    grenade = (1 << 2),
    bomb = (1 << 3),
    unknown = (1 << 4),
    all_items = weapon | grenade | bomb,
    all = player | weapon | grenade | bomb | unknown,
};

enum class anim_lod_flag : uint32_t {
    outside_view_frustum = (1 << 1),
    dormant = (1 << 3)
};

struct studio_hdr;
struct weapon;

struct weapon_info {
    PAD(0x4);
    const char* class_name{ };
    PAD(0xc);
    int max_clip1{ };
    PAD(0x70);
    const char* weapon_name{ };
    PAD(0x2)
    bool is_melee_weapon{ };
    PAD(0x9)
    float weapon_weight{ };
    PAD(0x28)
    weapon_type type{ };
    PAD(0x4)
    int price{ };
    PAD(0x8)
    float cycle_time{ };
    PAD(0xc)
    bool full_auto{ };
    PAD(0x1f)
    float range{ };
    float range_modifier{ };
    float throw_velocity{ };
    PAD(0xc)
    bool has_silencer{ };
    PAD(0xb)
    char* bullet_type{ };
    float max_speed{ };
    float max_speed_alt{ };
    float spread{ };
    float spread_alt{ };
    PAD(0x5c)
    float recoil_magnitude{ };
    float recoil_magnitude_alt{ };
    PAD(0x10)
    float recovery_time_stand{ };
};

struct base_entity : public client_entity {
    NETVAR(get_simulation_time, float, "CBaseEntity->m_flSimulationTime")
    NETVAR(get_anim_time, float, "CBaseEntity->m_flAnimTime")
    NETVAR(get_origin, vec3, "CBaseEntity->m_vecOrigin")
    NETVAR(get_rotation, angle, "CBaseEntity->m_angRotation")
    NETVAR(get_model_index, int, "CBaseEntity->m_nModelIndex")
    NETVAR(get_team, team, "CBaseEntity->m_iTeamNum")
    NETVAR(get_owner_entity_handle, base_handle, "CBaseEntity->m_hOwnerEntity")
    NETVAR(is_spotted, bool, "CBaseEntity->m_bSpotted")

    NETVAR_OFFSET(get_old_simulation_time, float, "CBaseEntity->m_flSimulationTime", 0x4)
    NETVAR_OFFSET(get_move_type, move_type, "CBaseEntity->m_nRenderMode", 0x1)
    NETVAR_OFFSET(get_coordinate_frame, mat3x4, "CBaseEntity->m_CollisionGroup", -0x30)

    OFFSET(get_effects, bitfield<effect>, 0xf0)

    DATAMAP_FIELD(get_button_last, bitfield<cmd_button>, get_pred_desc_map(), "m_afButtonLast")
    DATAMAP_FIELD(get_button_pressed, bitfield<cmd_button>, get_pred_desc_map(), "m_afButtonPressed")
    DATAMAP_FIELD(get_button_released, bitfield<cmd_button>, get_pred_desc_map(), "m_afButtonReleased")
    DATAMAP_FIELD(get_eflags, bitfield<entity_flag>, get_pred_desc_map(), "m_iEFlags")
    DATAMAP_FIELD(get_abs_rotation, angle, get_data_desc_map(), "m_angAbsRotation")
    DATAMAP_FIELD(get_abs_velocity, vec3, get_data_desc_map(), "m_angAbsVelocity")
    PTR_DATAMAP_FIELD(get_buttons, bitfield<cmd_button>, get_pred_desc_map(), "m_nButtons")

    VIRTUAL_FUNCTION(get_abs_origin, vec3&, 10, (), (this))
    VIRTUAL_FUNCTION(get_abs_angles, angle&, 11, (), (this))
    VIRTUAL_FUNCTION(set_model_index, void, 75, (int index), (this, index))
    VIRTUAL_FUNCTION(get_attachment, bool, 84, (int index, vec3* origin), (this, index, origin))
    VIRTUAL_FUNCTION(on_latch_interpolated_variables, void, 107, (bitfield<interpolation_flag> flags), (this, flags.raw()))
    VIRTUAL_FUNCTION(think, void, 138, (), (this))
    VIRTUAL_FUNCTION(is_player, bool, 158, (), (this))
    VIRTUAL_FUNCTION(is_weapon, bool, 166, (), (this))
    VIRTUAL_FUNCTION(get_active_weapon, weapon*, 268, (), (this))
    VIRTUAL_FUNCTION(pre_think, void, 318, (), (this))
    VIRTUAL_FUNCTION(select_item, void, 330, (const char* name, int subtype), (this, name, subtype))
    VIRTUAL_FUNCTION(update_collision_bounds, void, 340, (), (this))
    VIRTUAL_FUNCTION(get_weapon_info, weapon_info*, 461, (), (this))

    VIRTUAL_FUNCTION_SIG(set_abs_origin, void, dlls::client, "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8 ? ? ? ? 8B 7D",
        (this, std::cref(origin)), const vec3& origin)
    VIRTUAL_FUNCTION_SIG(set_abs_angles, void, dlls::client, "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1",
        (this, std::cref(angles)), const angle& angles)
    VIRTUAL_FUNCTION_SIG(physics_run_think, bool, dlls::client, "55 8B EC 83 EC 10 53 56 57 8B F9 8B 87",
        (this, method), think_method method)

    entity_type get_entity_type() noexcept;
};

struct base_attributable_item : public base_entity {
    NETVAR(get_item_id, short, "CBaseAttributableItem->m_iItemDefinitionIndex")
    NETVAR(get_account_id, int, "CBaseAttributableItem->m_iAccountID")
    NETVAR(get_quality, int, "CBaseAttributableItem->m_iEntityQuality")
    NETVAR(get_id_high, int, "CBaseAttributableItem->m_iItemIDHigh")
    NETVAR(get_id_low, int, "CBaseAttributableItem->m_iItemIDLow")
    NETVAR(get_xuid_low, int, "CBaseAttributableItem->m_OriginalOwnerXuidLow")
    NETVAR(get_xuid_high, int, "CBaseAttributableItem->m_OriginalOwnerXuidHigh")
    NETVAR(get_fallback_paintkit, int, "CBaseAttributableItem->m_nFallbackPaintKit")
    NETVAR(get_fallback_seed, int, "CBaseAttributableItem->m_nFallbackSeed")
    NETVAR(get_fallback_wear, float, "CBaseAttributableItem->m_flFallbackWear")
    NETVAR(get_fallback_stat_trak, int, "CBaseAttributableItem->m_nFallbackStatTrak")
};

struct base_animating : public base_entity {
    NETVAR(get_sequence, int, "CBaseAnimating->m_nSequence")
    NETVAR(get_cycle, int, "CBaseAnimating->m_flCycle")
    NETVAR(get_playback_rate, int, "CBaseAnimating->m_flPlaybackRate")
    NETVAR(get_pose_params, pose_params, "CBaseAnimating->m_flPoseParameter")
    NETVAR(use_client_side_animation, bool, "CBaseAnimating->m_bClientSideAnimation")

    OFFSET(get_anim_lod_flags, bitfield<anim_lod_flag>, 0xa28)
    OFFSET(get_computed_lod_frame, int, 0xa30)
    OFFSET(get_ik_ctx, ik_context*, 0x266c)
    OFFSET(get_most_recent_model_bone_counter, unsigned long, 0x268c)
    OFFSET(get_bone_merge_cache, bone_merge_cache*, 0x2908)
    OFFSET(get_last_bone_setup_time, float, 0x2924)
    OFFSET(is_jiggle_bones_enabled, bool, 0x2928)
    OFFSET(get_studio_hdr, studio_hdr*, 0x294c)
    OFFSET(get_anim_layers, utl_vec<anim_layer_t>, 0x298c)
    PTR_OFFSET(get_bone_accessor, bone_accessor, 0x26a0)
    PTR_OFFSET(get_bone_cache, bone_cache, 0x2910)

    VIRTUAL_FUNCTION(update_ik_locks, void, 192, (float cur_time), (this, cur_time))
    VIRTUAL_FUNCTION(calculate_ik_locks, void, 193, (float cur_time), (this, cur_time))
    VIRTUAL_FUNCTION(set_sequence, void, 219, (int sequence), (this, sequence))
    VIRTUAL_FUNCTION(studio_frame_advance, void, 220, (), (this))
    VIRTUAL_FUNCTION(update_client_side_animation, void, 224, (), (this))
    VIRTUAL_FUNCTION(update_dispatch_layer, void, 247, (anim_layer_t* layer, studio_hdr* hdr, int sequence), (this, layer, hdr, sequence))
};

struct base_view_model : base_animating {
    NETVAR(get_model_index, int, "CBaseViewModel->m_nModelIndex")
    NETVAR(get_owner_handle, base_handle, "CBaseViewModel->m_hOwner")
    NETVAR(get_weapon_handle, base_handle, "CBaseViewModel->m_hWeapon")
};

struct weapon : public base_attributable_item {
    NETVAR(get_next_primary_attack, float, "CBaseCombatWeapon->m_flNextPrimaryAttack")
    NETVAR(get_next_secondary_attack, float, "CBaseCombatWeapon->m_flNextSecondaryAttack")
    NETVAR(get_ammo, int, "CBaseCombatWeapon->m_iClip1")
    NETVAR(get_reserve_ammo, int, "CBaseCombatWeapon->m_iPrimaryReserveAmmoCount")
    NETVAR(get_view_model_index, int, "CBaseCombatWeapon->m_iViewModelIndex")
    NETVAR(get_world_model_index, int, "CBaseCombatWeapon->m_iWorldModelIndex")
    NETVAR(get_world_model_handle, base_handle, "CBaseCombatWeapon->m_hWeaponWorldModel")

    NETVAR(get_accuracy_penalty, float, "CWeaponCSBase->m_fAccuracyPenalty")
    NETVAR(get_last_shot_time, float, "CWeaponCSBase->m_fLastShotTime")
    NETVAR(get_recoil_index, float, "CWeaponCSBase->m_flRecoilIndex")
    NETVAR(is_burst_mode, bool, "CWeaponCSBase->m_bBurstMode")
    NETVAR(get_fire_ready_time, float, "CWeaponCSBase->m_flPostponeFireReadyTime")

    NETVAR(get_zoom_level, int, "CWeaponCSBaseGun->m_zoomLevel")
    NETVAR(get_burst_shots_remaining, int, "CWeaponCSBaseGun->m_iBurstShotsRemaining")

    DATAMAP_FIELD(is_reloading, bool, get_pred_desc_map(), "m_bInReload")

    VIRTUAL_FUNCTION(get_spread, float, 453, (), (this))
    VIRTUAL_FUNCTION(get_inaccuracy, float, 483, (), (this))
    VIRTUAL_FUNCTION(update_accuracy_penalty, void, 484, (), (this))

    weapon_info* get_info() noexcept;
};

struct grenade : public base_animating {
    NETVAR(get_dmg_radius, float, "CBaseGrenade->m_DmgRadius")
    NETVAR(get_velocity, vec3, "CBaseGrenade->m_vecVelocity")
    NETVAR(get_thrower_handle, base_handle, "CBaseGrenade->m_hThrower")

    NETVAR(is_pin_pulled, bool, "CBaseCSGrenade->m_bPinPulled")
    NETVAR(get_throw_time, float, "CBaseCSGrenade->m_fThrowTime")
    NETVAR(get_throw_strength, float, "CBaseCSGrenade->m_flThrowStrength")
};

struct inferno : public base_entity {
    ARRAY_NETVAR(get_fire_x_delta, int, 100, "CInferno->m_fireXDelta")
    ARRAY_NETVAR(get_fire_y_delta, int, 100, "CInferno->m_fireYDelta")
    ARRAY_NETVAR(get_fire_z_delta, int, 100, "CInferno->m_fireZDelta")
    NETVAR(get_effect_tick_begin, int, "CInferno->m_nFireEffectTickBegin")
};

enum class bomb_site {
    a,
    b
};

struct planted_c4 : public base_animating {
    NETVAR(is_ticking, bool, "CPlantedC4->m_bBombTicking")
    NETVAR(get_blow_time, float, "CPlantedC4->m_flC4Blow")
    NETVAR(get_total_time, float, "CPlantedC4->m_flTimerLength")
    NETVAR(get_bomb_site, bomb_site, "CPlantedC4->m_nBombSite")
    NETVAR(is_defused, bool, "CPlantedC4->m_bBombDefused")
    NETVAR(get_defuse_countdown, float, "CPlantedC4->m_flDefuseCountDown")
    NETVAR(get_defuse_length, float, "CPlantedC4->m_flDefuseLength")
    NETVAR(get_defuser_handle, base_handle, "CPlantedC4->m_hBombDefuser")

    float get_remaining_time() noexcept;
    float get_remaining_defuse_time() noexcept;
};

enum class precipitation_type {
    rain,
    snow,
    ash,
    snowfall,
    particle_rain,
    particle_ash,
    particle_rainstorm,
    particle_snow
};

struct precipitation : public base_entity {
    NETVAR(get_type, precipitation_type, "CPrecipitation->m_nPrecipType")
};

struct tonemap_controller : base_entity {
    NETVAR(use_custom_auto_exposure_min, bool, "CEnvTonemapController->m_bUseCustomAutoExposureMin")
    NETVAR(use_custom_auto_exposure_max, bool, "CEnvTonemapController->m_bUseCustomAutoExposureMax")
    NETVAR(use_custom_bloom_scale, bool, "CEnvTonemapController->m_bUseCustomBloomScale")
    NETVAR(get_custom_auto_exposure_min, float, "CEnvTonemapController->m_flCustomAutoExposureMin")
    NETVAR(get_custom_auto_exposure_max, float, "CEnvTonemapController->m_flCustomAutoExposureMax")
    NETVAR(get_custom_bloom_scale, float, "CEnvTonemapController->m_flCustomBloomScale")
    NETVAR(get_custom_bloom_scale_min, float, "CEnvTonemapController->m_flCustomBloomScaleMinimum")
    NETVAR(get_bloom_exponent, float, "CEnvTonemapController->m_flBloomExponent")
    NETVAR(get_bloom_saturation, float, "CEnvTonemapController->m_flBloomSaturation")
};

struct glow_object_definition {
    int next_free_slot{ };
    cs::base_entity* entity{ };
    vec3 color{ };
    float alpha{ };
    PAD(0x9)
    float pulse_overdrive;
    bool render_occluded{ true };
    bool render_unoccluded{ false };
    PAD(0x5)
    int style{ };

    static constexpr int end_of_free_list = -1;
    static constexpr int entry_in_use = -2;

    bool is_unused() const noexcept
    {
        return next_free_slot != entry_in_use;
    }

    void set(const vec4& clr) noexcept
    {
        color = { clr.x, clr.y, clr.z };
        alpha = clr.w;
    }
};

}

```

`valve/cs/game_event.h`:

```h
#pragma once

#include "../../memory/memory.h"
#include "client_class.h"

namespace cs {

struct event_info {
    cs::class_id class_id{ };
    float fire_delay{ };
    PAD(0x4)
    client_class* client_class{ };
    void* data{ };
    PAD(0x24)
    event_info* next{ };
};

struct game_event {
    VIRTUAL_FUNCTION(get_name, const char*, 1, (), (this))
    VIRTUAL_FUNCTION(get_bool, bool, 5, (const char* name, bool default_value = false), (this, name, default_value))
    VIRTUAL_FUNCTION(get_int, int, 6, (const char* name, int default_value = 0), (this, name, default_value))
    VIRTUAL_FUNCTION(get_uint64, uint64_t, 7, (const char* name, unsigned long default_value = 0), (this, name, default_value))
    VIRTUAL_FUNCTION(get_float, float, 8, (const char* name, float default_value = 0.0f), (this, name, default_value))
    VIRTUAL_FUNCTION(get_string, const char*, 9, (const char* name, const char* default_value = ""), (this, name, default_value))
    VIRTUAL_FUNCTION(get_wstring, const wchar_t*, 10, (const char* name, const wchar_t* default_value = L""), (this, name, default_value))
    VIRTUAL_FUNCTION(get_ptr, const void*, 11, (const char* name, const void* default_value = nullptr), (this, name, default_value))
};

}

```

`valve/cs/key_values.cpp`:

```cpp
#include "key_values.h"
#include "../../memory/memory.h"
#include "../../memory/interfaces.h"

namespace cs {

	void* key_values::operator new[](size_t alloc_size)
	{
		return memory::call_virtual<void*, 2>(interfaces::key_values_system, alloc_size);
	}

	void key_values::operator delete[](void* mem)
	{
		return memory::call_virtual<void, 3>(interfaces::key_values_system, mem);
	}

}

```

`valve/cs/key_values.h`:

```h
#pragma once

#include "../../memory/memory.h"

namespace cs {

    struct key_values {
        void* operator new[](size_t alloc_size);
        void operator delete[](void* memory);

        void init(const char* name)
        {
            static void(__thiscall * init_fn)(key_values*, const char*, int, int) =
                dlls::client.find(PATTERN("55 8B EC 51 33 C0 C7 45")).cast<decltype(init_fn)>();
            return init_fn(this, name, 0, 0);
        }

        void load_from_buffer(const char* resource_name, const char* buffer /* Omitted unnecessary arguments */) noexcept
        {
            static void(__thiscall * load_from_buffer_fn)(key_values*, const char*, const char*, void*, const char*, void*, void*) =
                dlls::client.find(PATTERN("55 8B EC 83 E4 F8 83 EC 34 53 8B 5D 0C 89")).cast<decltype(load_from_buffer_fn)>();
            return load_from_buffer_fn(this, resource_name, buffer, nullptr, nullptr, nullptr, nullptr);
        }

        VIRTUAL_FUNCTION_SIG(find_key, key_values*, dlls::client, "55 8B EC 83 EC 1C 53 8B D9 85 DB", (this, key_name, create_new),
                             const char* key_name, bool create_new)

        void set_string(const char* key_name, const char* value) noexcept
        {
            static void(__thiscall * set_string_fn)(key_values*, void*, const char*) =
                dlls::client.find(PATTERN("55 8B EC A1 ? ? ? ? 53 56 57 8B F9 8B 08 8B 01")).cast<decltype(set_string_fn)>();

            const auto key = find_key(key_name, false);
            if (!key)
                return;

            set_string_fn(this, key, value);
        }

        PAD(0x24)
    };

}

```

`valve/cs/leaf_system.h`:

```h
#pragma once

namespace cs {

enum class render_flag : uint32_t {
    bounds_always_recompute = (1 << 6),
    force_opaque_pass = (1 << 8)
};

struct renderable_info {
    cs::renderable* renderable{ };
    PAD(0x4)
    int enum_count{ };
    int render_frame{ };
    unsigned short first_shadow{ };
    unsigned short leaf_list{ };
    short area{ };
    bitfield<render_flag> flags{ };
    vec3 bloated_abs_mins{ };
    vec3 bloated_abs_maxs{ };
    vec3 abs_mins{ };
    vec3 abs_maxs{ };
};

struct renderable_entry {
    cs::renderable* renderable{ };
    unsigned short world_list_into_leaf{ };
    uint8_t alpha{ };
    uint8_t flags{ };
    bool is_combined_model{ };
};

enum render_group {
    opaque,
    translucent,
    translucent_ignore_z,
    count
};

struct world_list_info {
    int view_fog_volume{ };
    int leaf_count{ };
    bool has_water{ };
    uint64_t* leaf_data_list{ };
};

struct renderables_list {
    float max_dist_sqr{ };
    float min_dist_sqr{ };
    float falloff_factor{ };
    renderable_entry render_groups[render_group::count][4096]{ };
    int render_group_counts[render_group::count]{ };
    int bone_setup_dependency_count{ };
    cs::renderable* bone_setup_dependency[64];
};

struct setup_render_info {
    mutable world_list_info* world_list_info{ };
    mutable renderables_list* render_list{ };
};

}

```

`valve/cs/material.h`:

```h
#pragma once

namespace cs {

struct material_var {
    VIRTUAL_FUNCTION(set_value, void, 4, (float value), (this, value))
    VIRTUAL_FUNCTION(set_vector_value, void, 11, (float x, float y, float z), (this, x, y, z))
    VIRTUAL_FUNCTION(set_vector_component_value, void, 26, (float x, int component), (this, x, component))
};

enum class material_flag {
    debug = (1 << 0),
    no_debug_override = (1 << 1),
    no_draw = (1 << 2),
    use_in_fillrate_mode = (1 << 3),
    vertex_color = (1 << 4),
    vertex_alpha = (1 << 5),
    self_illum = (1 << 6),
    additive = (1 << 7),
    alphatest = (1 << 8),
    z_nearer = (1 << 10),
    model = (1 << 11),
    flat = (1 << 12),
    no_cull = (1 << 13),
    no_fog = (1 << 14),
    ignore_z = (1 << 15),
    decal = (1 << 16),
    base_alpha_env_map_mask = (1 << 20),
    translucent = (1 << 21),
    normal_map_alpha_env_map_mask = (1 << 22),
    opaque_texture = (1 << 24),
    suppress_decals = (1 << 26),
    half_lambert = (1 << 27),
    wireframe = (1 << 28)
};

struct material {
    VIRTUAL_FUNCTION(get_name, const char*, 0, (), (this))
    VIRTUAL_FUNCTION(get_texture_group_name, const char*, 1, (), (this))
    VIRTUAL_FUNCTION(find_var, material_var*, 11, (const char* name, bool* found, bool complain = true), (this, name, found, complain))
    VIRTUAL_FUNCTION(increment_ref_count, void, 12, (), (this))
    VIRTUAL_FUNCTION(modulate_alpha, void, 27, (float alpha), (this, alpha))
    VIRTUAL_FUNCTION(modulate_color, void, 28, (float r, float g, float b), (this, r, g, b))
    VIRTUAL_FUNCTION(set_flag, void, 29, (material_flag var_flag, bool state), (this, var_flag, state))
    VIRTUAL_FUNCTION(get_flag, bool, 30, (material_flag var_flag), (this, var_flag))
    VIRTUAL_FUNCTION(set_shader, void, 34, (const char* shader), (this, shader))
    VIRTUAL_FUNCTION(is_error_material, bool, 42, (), (this))
    VIRTUAL_FUNCTION(set_shader_and_params, void, 48, (cs::key_values* key_values), (this, key_values))

    inline void modulate(const clr4& clr) noexcept
    {
        modulate_color(clr.r / 255.f, clr.g / 255.f, clr.b / 255.f);
        modulate_alpha(clr.a / 255.f);
    }
};

struct mat_render_context;

}

```

`valve/cs/model.h`:

```h
#pragma once

namespace cs {

enum class model_type {
    bad,
    brush,
    sprite,
    studio
};

struct model {
    PAD(0x4)
    char name[MAX_PATH]{ };
    int	load_flags{ };
    int server_count{ };
    model_type type{ };
    int	flags{ };
    vec3 vec_mins{ };
    vec3 vec_maxs{ };
    float radius{ };
    key_values* key_values{ };
};

struct model_render_info {
    vec3 origin{ };
    vec3 angles{ };
    PAD(0x4)
    cs::renderable* renderable{ };
    const model* model{ };
    const mat3x4* model_to_world{ };
    const mat3x4* lighting_offset{ };
    const vec3* lighting_origin{ };
    int flags{ };
    int entity_index{ };
};

struct draw_model_results;

}

```

`valve/cs/player.cpp`:

```cpp
#include "player.h"
#include "../../memory/interfaces.h"
#include "../../core/cheat.h"

namespace cs {

bool player::is_enemy(player* other) noexcept
{
    static const auto teammates_are_enemies = interfaces::cvar->find_var("mp_teammates_are_enemies");
    const auto cmp = other ? other : cheat::local.ptr;

    if (get_index() == cmp->get_index())
        return false;

    if (teammates_are_enemies->get_bool() && get_team() == cmp->get_team())
        return true;

    return get_team() != cmp->get_team();
}

bool player::get_info(player_info& info) noexcept
{
    return interfaces::engine->get_player_info(get_index(), &info);
}

bool local_player::update() noexcept
{
    in_game = interfaces::client_state->signon_state == cs::signon_state::full;
    if (!in_game)
        return false;

    if (!ptr)
        ptr = interfaces::entity_list->get<cs::player*>(interfaces::engine->get_local_player());

    if (!ptr)
        return false;

    return true;
}

void local_player::reset() noexcept
{
    ptr = nullptr;
    cur_cmd = nullptr;
    view = { };
    in_game = false;
}

}

```

`valve/cs/player.h`:

```h
#pragma once

#include "../../core/netvars.h"
#include "../../memory/memory.h"

#include "entity.h"

namespace cs {

static constexpr int max_players = 64;
static constexpr int multiplayer_backup = 150;
static constexpr int tick_never_think = -1;

struct studio_hdr;

enum class life_state {
    alive,
    dead = 2
};

enum class move_state {
    idle,
    walk,
    run
};

enum class user_message {
    vote_start = 46,
    vote_pass = 47,
    vote_failed = 48,
    server_rank_reveal_all = 50
};

enum class invalidate_physics_bit {
    angles_changed = (1 << 1),
    animation_changed = (1 << 3),
    sequence_changed = (1 << 5)
};

struct player_info {
    uint64_t version{ };
    union {
        uint64_t full;
        struct {
            uint32_t low;
            uint32_t high;
        };
    } xuid{ };
    char               name[128]{ };
    int                uid{ };
    char               guid[33]{ };
    uint32_t           friends_id{ };
    char               friends_name[128]{ };
    bool               is_fake_player{ };
    bool               is_hltv{ };
    int                custom_files[4]{ };
    unsigned char      files_downloaded{ };
};

struct base_combat_character : public base_animating {
    NETVAR(get_next_attack, float, "CBaseCombatCharacter->m_flNextAttack")
    NETVAR(get_active_weapon_handle, base_handle, "CBaseCombatCharacter->m_hActiveWeapon")
    PTR_NETVAR(get_weapons, base_handle, "CBaseCombatCharacter->m_hMyWeapons")
    PTR_NETVAR(get_wearables, base_handle, "CBaseCombatCharacter->m_hMyWearables")
};

struct base_player : public base_combat_character {
    NETVAR(get_viewpunch_angle, angle, "CBasePlayer->m_viewPunchAngle")
    NETVAR(get_aimpunch_angle, angle, "CBasePlayer->m_aimPunchAngle")
    NETVAR(get_aimpunch_angle_velocity, vec3, "CBasePlayer->m_aimPunchAngleVel")
    NETVAR(get_view_offset, vec3, "CBasePlayer->m_vecViewOffset[0]")
    NETVAR(get_tick_base, int, "CBasePlayer->m_nTickBase")
    NETVAR(get_next_think_tick, int, "CBasePlayer->m_nNextThinkTick")
    NETVAR(get_fall_velocity, float, "CBasePlayer->m_flFallVelocity")
    NETVAR(get_health, int, "CBasePlayer->m_iHealth")
    NETVAR(get_life_state, life_state, "CBasePlayer->m_lifeState")
    NETVAR(get_ammo, int, "CBasePlayer->m_iAmmo")
    NETVAR(get_flags, bitfield<entity_flag>, "CBasePlayer->m_fFlags")
    NETVAR(get_observer_mode, observer_mode, "CBasePlayer->m_iObserverMode")
    NETVAR(get_observer_target_handle, base_handle, "CBasePlayer->m_hObserverTarget")
    NETVAR(get_viewmodel_handle, base_handle, "CBasePlayer->m_hViewModel[0]")
    NETVAR(get_duck_amount, float, "CBasePlayer->m_flDuckAmount")
    NETVAR(get_duck_speed, float, "CBasePlayer->m_flDuckSpeed")
    NETVAR(get_water_level, int, "CBasePlayer->m_nWaterLevel")

    DATAMAP_FIELD(get_collision_state, int, get_pred_desc_map(), "CBasePlayer->m_vphysicsCollisionState");
};

struct anim_state;

struct player : public base_player {
    NETVAR(get_money, int, "CCSPlayer->m_iAccount")
    NETVAR(get_total_hits, int, "CCSPlayer->m_totalHitsOnServer")
    NETVAR(get_shots_fired, int, "CCSPlayer->m_iShotsFired")
    NETVAR(has_helmet, bool, "CCSPlayer->m_bHasHelmet")
    NETVAR(has_heavy_armor, bool, "CCSPlayer->m_bHasHeavyArmor")
    NETVAR(has_defuser, bool, "CCSPlayer->m_bHasDefuser")
    NETVAR(is_immune, bool, "CCSPlayer->m_bGunGameImmunity")
    NETVAR(is_in_buy_zone, bool, "CCSPlayer->m_bInBuyZone")
    NETVAR(get_move_state, move_state, "CCSPlayer->m_iMoveState")
    NETVAR(is_scoping, bool, "CCSPlayer->m_bIsScoped")
    NETVAR(get_armor, int, "CCSPlayer->m_ArmorValue")
    NETVAR(get_flash_duration, float, "CCSPlayer->m_flFlashDuration")
    NETVAR(get_lby, float, "CCSPlayer->m_flLowerBodyYawTarget")
    NETVAR(get_velocity_modifier, float, "CCSPlayer->m_flVelocityModifier")
    PTR_NETVAR(get_max_flash_alpha, float, "CCSPlayer->m_flFlashMaxAlpha")

    NETVAR_OFFSET(get_flash_alpha, float, "CCSPlayer->m_flFlashMaxAlpha", -0x8)
    NETVAR_OFFSET(get_anim_state, anim_state*, "CCSPlayer->m_bIsScoped", -0x14)

    VIRTUAL_FUNCTION(get_eye_angles, angle&, 169, (), (this))
    VIRTUAL_FUNCTION(set_local_view_angles, void, 373, (const angle& angles), (this, std::cref(angles)))

    VIRTUAL_FUNCTION_SIG(post_think_v_physics, void, dlls::client, "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB", (this))
    VIRTUAL_FUNCTION_SIG(simulate_player_simulated_entities, void, dlls::client, "56 8B F1 57 8B BE ? ? ? ? 83 EF 01 78 74", (this))
    VIRTUAL_FUNCTION_SIG(invalidate_physics_recursive, void, dlls::client,
        "55 8B EC 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3 56", (this, invalidate_physics_flags), int invalidate_physics_flags)

    bool is_enemy(player* other = nullptr /* = local */) noexcept;
    bool get_info(player_info& info) noexcept;

    inline bool is_alive() noexcept
    {
        return get_health() > 0 && get_life_state() == life_state::alive;
    }
};

struct local_player {
    player* ptr{ };
    user_cmd* cur_cmd{ };
    angle view{ };
    bool in_game{ };

    auto operator->() noexcept { return ptr; }
    operator bool() noexcept { return ptr; }
    operator base_player*() noexcept { return ptr; }
    operator player*() noexcept { return ptr; }

    bool update() noexcept;
    void reset() noexcept;
};

}

```

`valve/cs/studio.h`:

```h
#pragma once

namespace cs {

enum class draw_model_flag {
    entire_model,
    opaque_only = (1 << 0),
    translucent_only = (1 << 1),
    group_mask = (opaque_only | translucent_only),
    no_flexes = (1 << 2),
    static_lighting = (1 << 3),
    accuratetime = (1 << 4),
    no_shadows = (1 << 5),
    get_perf_stats = (1 << 6),
    wireframe = (1 << 7),
    item_blink = (1 << 8),
    shadow_depth_texture = (1 << 9),
    ssao_depth_texture = (1 << 12),
    generate_stats = (1 << 15)
};

struct studio_seq_desc {
    int base_ptr{ };
    int label_index{ };
    int activity_name_index{ };
    int flags{ };
    int activity{ };
    int activity_weight{ };
    int event_count{ };
    int event_index{ };
    vec3 bb_min{ };
    vec3 bb_max{ };
    int blend_count{ };
    int anim_index{ };
    int movement_index{ };
    int group_size[2]{ };
    int param_index[2]{ };
    float param_start[2]{ };
    float param_end[2]{ };
    int param_parent{ };
    float fade_in_time{ };
    float fadeout_time{ };
    int local_entry_node{ };
    int local_exit_node{ };
    int node_flags{ };
    float entry_phase{ };
    float exit_phase{ };
    float last_frame{ };
    int next_sequence{ };
    int pose{ };
    int ik_rule_count{ };
    int auto_layer_count{ };
    int auto_layer_index{ };
    int weight_list_index{ };
    int pose_key_index{ };
    int ik_lock_count{ };
    int ik_lock_index{ };
    int key_value_index{ };
    int key_value_size{ };
    int cycle_pose_index{ };
    int activity_modifier_index{ };
    int activity_modifier_count{ };
    int anim_tag_index{ };
    int anim_tag_count{ };
    PAD(0xc)
};

struct studio_bbox {
    int bone{ };
    int group{ };
    vec3 bb_min{ };
    vec3 bb_max{ };
    int hitbox_name_index{ };
    angle offset_rotation{ };
    float capsule_radius{ };
};

struct studio_hitbox_set {
    int name_index{ };
    int hitbox_count{ };
    int hitbox_index{ };

    inline auto get_name() const noexcept
    {
        return reinterpret_cast<const char*>(reinterpret_cast<uintptr_t>(this) + name_index);
    }

    inline auto get_hitbox(int i) const noexcept
    {
        return reinterpret_cast<studio_bbox*>(reinterpret_cast<uintptr_t>(this) + hitbox_index) + i;
    }
};

struct studio_bone {
    int name_index{ };
    int parent{ };
    int bone_controller[6]{ };
    vec3 position{ };
    vec4 quaternion{ };
    vec3 rotation{ };
    vec3 position_scale{ };
    vec3 rotation_scale{ };
    mat3x4 pose_to_bone{ };
    vec4 alignment{ };
    bitfield<bone_flag> flags{ };
    int procedure_type{ };
    int procedure_index{ };
    mutable int physics_bone{ };
    int surface_prop_index{ };
    int contents{ };
    int surface_prop_lookup{ };

    inline auto get_name() const noexcept
    {
        return reinterpret_cast<const char*>(reinterpret_cast<uintptr_t>(this) + name_index);
    }
};

struct studio_hdr_t {
    int id{ };
    int version{ };
    int checksum{ };
    char name[64]{ };
    int length{ };
    vec3 eye_position{ };
    vec3 illum_position{ };
    vec3 hull_min{ };
    vec3 hull_max{ };
    vec3 view_bb_min{ };
    vec3 view_bb_max{ };
    int flags{ };
    int bone_count{ };
    int bone_index{ };
    int bone_controller_count{ };
    int bone_controller_index{ };
    int hitbox_set_count{ };
    int hitbox_set_index{ };
    int local_anim_count{ };
    int local_anim_index{ };
    int local_seq_count{ };
    int local_seq_index{ };

    inline auto get_bone(int i) const noexcept
    {
        return reinterpret_cast<studio_bone*>(reinterpret_cast<uintptr_t>(this) + bone_index) + i;
    }

    inline auto get_hitbox_set(int i) const noexcept
    {
        return reinterpret_cast<studio_hitbox_set*>(reinterpret_cast<uintptr_t>(this) + hitbox_set_index) + i;
    }

    inline auto get_local_seq_desc(int i) const noexcept
    {
        return reinterpret_cast<studio_seq_desc*>(reinterpret_cast<uintptr_t>(this) + sizeof(studio_seq_desc) * i + local_seq_index);
    }
};

struct studio_hdr {
    studio_hdr_t* hdr;
    void* virtual_model{ };
    void* softbody{ };
    mutable utl_vec<const studio_hdr_t*> hdr_cache{ };
    mutable int frame_unlock_counter{ };
    int* p_frame_unlock_counter{ };
    PAD(0x8)
    utl_vec<int> bone_flags{ };
    utl_vec<int> bone_parent{ };
    void* activity_to_sequence{ };
};

struct draw_model_info {
    studio_hdr_t* hdr{ };
    void* studio_hw_data{ };
    uint16_t decals{ };
    int skin{ };
    int body{ };
    int hitbox_set_index{ };
    renderable* client_entity{ };
    int lod{ };
    void* clr_meshes{ };
    bool static_lighting{ };
    char lighting_state[440]{ };
};

struct draw_model_state {
    studio_hdr_t* studio_hdr{ };
    void* studio_hw_data{ };
    cs::renderable* renderable{ };
    const mat3x4* bones{ };
};

}

```

`valve/cs/trace.h`:

```h
#pragma once

namespace cs {

enum class collision_group {
    none,
    breakable_glass = 6,
    push_away = 17,
};

enum class surface_flag : uint16_t {
    no_draw = (1 << 7),
    hitbox = (1 << 15)
};

struct surface {
    const char* name{ };
    int16_t surface_props{ };
    bitfield<surface_flag> flags{ };
};

struct ray {
    // All of these are actually 4-dimensional, but w is unneeded so they're all padded.
    vec3 start{ };
    PAD(0x4)
    vec3 delta{ };
    PAD(0x4)
    vec3 start_offset{ };
    PAD(0x4)
    vec3 extents{ };
    PAD(0x4)
    const mat3x4* world_axis_transform{ };
    bool is_ray{ true };
    bool is_swept{ };

    ray(const vec3& start, const vec3& end, const vec3& mins, const vec3& maxs) noexcept
        : delta(end - start), start_offset(mins + maxs), extents(maxs - mins)
    {
        is_swept = (delta.x || delta.y || delta.z);
        extents *= 0.5f;
        is_ray = (extents.length_sqr() < 1e-6);
        start_offset *= 0.5f;
        this->start = start + start_offset;
        start_offset.inverse();
    };

    ray(const vec3& start, const vec3& end) noexcept
        : start(start), delta(end - start)
    {
        is_swept = (delta.x || delta.y || delta.z);
        start_offset.clear();
        extents.clear();
    };
};

using contents_t = int;

namespace contents {

    constexpr contents_t empty = 0;
    constexpr contents_t solid = (1 << 0);
    constexpr contents_t window = (1 << 1);
    constexpr contents_t grate = (1 << 3);
    constexpr contents_t slime = (1 << 4);
    constexpr contents_t water = (1 << 5);
    constexpr contents_t moveable = (1 << 14);
    constexpr contents_t playerclip = (1 << 16);
    constexpr contents_t monster = (1 << 25);
    constexpr contents_t debris = (1 << 26);
    constexpr contents_t hitbox = (1 << 30);

}

using trace_mask_t = int;

namespace trace_mask {

    constexpr trace_mask_t all = -1;
    constexpr trace_mask_t solid = (contents::solid | contents::moveable | contents::window | contents::monster | contents::grate);
    constexpr trace_mask_t player_solid = (contents::solid | contents::moveable | contents::playerclip | contents::window
        | contents::monster | contents::grate);
    constexpr trace_mask_t water = (contents::water | contents::moveable | contents::slime);
    constexpr trace_mask_t shot = (contents::solid | contents::moveable | contents::monster | contents::window | contents::debris
        | contents::grate | contents::hitbox);
    constexpr trace_mask_t shot_brush_only = (contents::solid | contents::moveable | contents::window | contents::debris);
    constexpr trace_mask_t shot_hull = (contents::solid | contents::moveable | contents::monster | contents::window | contents::debris
        | contents::grate);
    constexpr trace_mask_t solid_brush_only = (contents::solid | contents::moveable | contents::window | contents::grate);
    constexpr trace_mask_t player_solid_brush_only = (contents::solid | contents::moveable | contents::window | contents::playerclip
        | contents::grate);

}

struct trace {
    vec3 start_pos{ };
    vec3 end_pos{ };
    vec3 plane{ };
    PAD(0x8)
    float fraction{ };
    int contents{ };
    uint16_t disp_flags{ };
    bool all_solid{ };
    bool start_solid{ };
    float fraction_left_solid{ };
    surface	surface{ };
    hitgroup hitgroup{ };
    PAD(0x4)
    base_entity* hit_entity{ };
    hitbox hitbox{ };

    inline int get_entity_index() const noexcept
    {
        return (hit_entity ? hit_entity->get_index() : -1);
    };

    inline bool did_hit() const noexcept
    {
        return (fraction < 1.0f || all_solid || start_solid);
    };

    inline bool did_hit_world() const noexcept
    {
        return !get_entity_index();
    };

    inline bool did_hit_non_world_entity() const noexcept
    {
        return (hit_entity != nullptr && !did_hit_world());
    };
};

enum class trace_type {
    everything,
    world_only,
    entities_only,
    everything_filter_props
};

struct trace_filter {
    virtual bool should_hit_entity(base_entity* entity, int mask) const = 0;
    virtual trace_type get_trace_type() const = 0;
};

struct trace_filter_skip_two_entities : public trace_filter {
    base_entity* first{ }, *second{ };

    trace_filter_skip_two_entities() noexcept = default;
    trace_filter_skip_two_entities(base_entity* first, base_entity* second) noexcept
        : first(first), second(second) { }

    inline bool should_hit_entity(base_entity* entity, trace_mask_t) const noexcept override
    {
        return entity != first && entity != second;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return trace_type::everything;
    }
};

struct trace_filter_world_only : public trace_filter {
    inline bool should_hit_entity(base_entity*, trace_mask_t) const noexcept override
    {
        return false;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return trace_type::world_only;
    }
};

struct trace_filter_world_and_props_only : public trace_filter {
    inline bool should_hit_entity(base_entity*, trace_mask_t) const noexcept override
    {
        return false;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return trace_type::everything;
    }
};

struct trace_filter_no_players : public trace_filter {
    base_entity* skip{ };
    trace_type type{ };

    trace_filter_no_players() noexcept = default;
    trace_filter_no_players(base_entity* skip, trace_type type = trace_type::everything) noexcept
        : skip(skip), type(type) { }

    inline bool should_hit_entity(base_entity*, trace_mask_t) const noexcept override
    {
        return false;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return type;
    }
};

struct trace_entity : public trace_filter {
    base_entity* hit{ };

    trace_entity() noexcept = default;
    trace_entity(base_entity* hit) noexcept
        : hit(hit) { }

    inline bool should_hit_entity(base_entity* entity, trace_mask_t) const noexcept override
    {
        return entity == hit;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return trace_type::entities_only;
    }
};

using should_hit_fn = std::add_pointer_t<bool(base_entity*, contents_t)>;

struct trace_filter_simple : public trace_filter {
    const base_entity* pass_entity{ };
    collision_group group{ };
    should_hit_fn extra_should_hit_check{ };

    trace_filter_simple() noexcept = default;
    trace_filter_simple(const base_entity* pass_entity, collision_group group, should_hit_fn extra_should_hit_check = nullptr) noexcept
        : pass_entity(pass_entity), group(group), extra_should_hit_check(extra_should_hit_check) { }

    inline bool should_hit_entity(base_entity*, trace_mask_t) const noexcept override
    {
        return false;
    }

    inline trace_type get_trace_type() const noexcept override
    {
        return trace_type::everything;
    }
};

}

```

`valve/cs/util.h`:

```h
#pragma once

#include <functional>

#include "../../memory/interfaces.h"

namespace cs {

namespace util {

    inline auto player_from_event(game_event* evt, std::string_view name = "userid") noexcept
    {
        return interfaces::entity_list->get<player*>(interfaces::engine->get_player_for_uid(evt->get_int(name.data())));
    }

    inline bool is_targetable_player(base_entity* entity) noexcept
    {
        if (!entity || !entity->is_player())
            return false;

        const auto player = reinterpret_cast<cs::player*>(entity);
        return player->is_alive() && !player->is_dormant() && !player->is_immune();
    }

}

}

```

`valve/cs/utl_vector.h`:

```h
#pragma once

namespace cs {

template<class ty>
struct utl_vec {
    ty* data{ };
    int alloc_count{ };
    int grow_size{ };
    int size{ };
    ty* elements{ };

    constexpr ty& operator[](int i) noexcept
    {
        return data[i];
    }

    constexpr const ty& operator[](int i) const noexcept
    {
        return data[i];
    }
};

}

```

`valve/cs/view.h`:

```h
#pragma once

namespace cs {

struct base_entity;

enum class frame_stage {
    start,
    net_update_start,
    net_update_post_data_update_start,
    net_update_post_data_update_end,
    net_update_end,
    render_start,
    render_end
};

enum class observer_mode {
    none,
    deathcam,
    freezecam,
    fixed,
    in_eye,
    chase,
    roaming,
    other
};

struct view_setup {
    int x{ };
    int old_x{ };
    int y{ };
    int old_y{ };
    int width{ };
    int old_width{ };
    int height{ };
    int old_height{ };
    bool ortho{ };
    float ortho_left{ };
    float ortho_top{ };
    float ortho_right{ };
    float ortho_bottom{ };
    bool custom_view_matrix{ };
    mat3x4 custom_matrix{ };
    PAD(0x48)
    float fov{ };
    float viewmodel_fov{ };
    vec3 origin{ };
    angle angles{ };
};

}

```

`valve/cs/world.h`:

```h
#pragma once

namespace cs {

    struct beam;

    enum class beam_flag {
        start_entity = (1 << 0),
        end_entity = (1 << 1),
        fade_in = (1 << 2),
        fade_out = (1 << 3),
        sine_noise = (1 << 4),
        solid = (1 << 5),
        shade_in = (1 << 6),
        shade_out = (1 << 7),
        only_noise_once = (1 << 8),
        no_tile = (1 << 9),
        use_hitboxes = (1 << 10),
        start_visible = (1 << 11),
        end_visible = (1 << 12),
        is_active = (1 << 13),
        forever = (1 << 14),
        halo_beam = (1 << 15),
        reversed = (1 << 16)
    };

    enum class beam_type {
        points,
        sprite,
        disk,
        cylinder,
        follow,
        ring,
        spline,
        ring_point,
        laser,
        tesla
    };

    struct beam_info {
        beam_type type{ beam_type::points };
        base_entity* start_entity{ };
        int start_attachment{ };
        base_entity* end_entity{ };
        int end_attachment{ };
        vec3 start{ };
        vec3 end{ };
        int model_index{ -1 };
        const char* model_name{ };
        int halo_index{ -1 };
        const char* halo_name{ };
        float halo_scale{ };
        float life{ };
        float width{ 1.0 };
        float end_width{ 1.0 };
        float fade_length{ 100.0f };
        float amplitude{ };
        float brightness{ 255 };
        float speed{ };
        int start_frame{ };
        float frame_rate{ };
        float red{ };
        float green{ };
        float blue{ };
        bool renderable{ true };
        int segments{ -1 };
        bitfield<beam_flag> flags{ };
        vec3 center{ };
        float start_radius{ };
        float end_radius{ };

        explicit beam_info(const vec3& start, const vec3& end, const clr4& clr, float amplitude, float life, bitfield<beam_flag> flags = { },
                           const char* model_name = "sprites/physbeam.vmt") noexcept
            : start(start), end(end), amplitude(amplitude), life(life), flags(flags), model_name(model_name)
        {
            red = clr.r;
            green = clr.g;
            blue = clr.b;
            brightness = clr.a;
        }
    };

    struct dlight {
        enum class flag {
            no_world_illumination,
            no_model_illumination,
            add_displacement_alpha,
            sub_displacement_alpha
        };

        bitfield<flag> flags{ };
        vec3 origin{ };
        float radius{ };
        clr3 color{ };
        float die{ };
        float decay{ };
        float min_light{ };
        int key{ };
        int style{ };
        vec3 direction{ };
        float inner_angle{ };
        float outer_angle{ };
    };

}

```

`valve/se/client.h`:

```h
#pragma once

#include "../../memory/memory.h"

#include "../cs/client_class.h"
#include "../cs/game_event.h"
#include "../cs/utl_vector.h"
#include "../cs/entity.h"
#include "../cs/world.h"

namespace cs {

struct base_player;
struct hud_chat;
struct user_cmd;

enum class hud_filter {
    print_notify, // Same as print_console
    print_console,
    print_talk,   // Chat + console
    print_center
};

enum class signon_state {
    none,
    challenge,
    connected,
    _new,
    prespawn,
    spawn,
    full,
    change_level
};

}

namespace se {

struct client_dll {
    VIRTUAL_FUNCTION(get_all_classes, cs::client_class*, 8, (), (this))
    VIRTUAL_FUNCTION(dispatch_user_message, bool, 38, (int msg_type, int flags, int size, const void* msg = nullptr),
        (this, msg_type, flags, size, msg))
};

struct client_input {
    PAD(0xa9)
    bool is_camera_in_thirdperson{ };
    PAD(0x2)
    vec3 camera_offset{ };
    PAD(0x38)
    cs::user_cmd* cmds{ };
    cs::verified_user_cmd* verified_cmds{ };
};

struct hud_chat;

struct client_mode {
    auto get_hud_chat() noexcept
    {
        return *reinterpret_cast<hud_chat**>(reinterpret_cast<uintptr_t>(this) + 0x1c);
    }
};

struct net_channel;

struct client_state {
    // CBaseClientState
    PAD(0x9c)
    net_channel* net_channel{ };
    unsigned int challenge_number{ };
    PAD(0x4)
    double connect_time{ };
    int retry_number{ };
    PAD(0x54)
    cs::signon_state signon_state{ };
    PAD(0x4)
    double next_cmd_time{ };
    int server_count{ };
    int cur_sequence{ };
    PAD(0x48)
    int server_tick{ };
    int client_tick{ };
    int delta_tick{ };
    PAD(0x4)
    int view_entity{ };
    int player_slot{ };
    bool is_paused{ };
    PAD(0x3)
    char level_name[MAX_PATH]{ };
    char level_name_short[40]{ };
    PAD(0xd4)
    int max_clients{ };
    PAD(0x4994)
    // CClientState
    int old_tick_count{ };
    float tick_remainder{ };
    float frame_time{ };
    int last_outgoing_cmd{ };
    int choked_cmds{ };
    int last_cmd_acknowledged{ };
    int last_server_tick{ };
    int cmd_acknowledged{ };
    int sound_sequence{ };
    int last_progress_percent{ };
    bool is_hltv{ };
    PAD(0x4b)
    angle view_angles{ };
    PAD(0xcc)
    cs::event_info* events{ };
};

struct effects_client {
    VIRTUAL_FUNCTION(smoke, void, 2, (const vec3& origin, int model_index, float scale, float framerate),
        (this, std::cref(origin), model_index, scale, framerate))
    VIRTUAL_FUNCTION(sparks, void, 3, (const vec3& position, int magnitude = 1, int trail_length = 1, const vec3* direction = nullptr),
        (this, std::cref(position), magnitude, trail_length, direction))
    VIRTUAL_FUNCTION(dust, void, 4, (const vec3& position, const vec3& direction, float size, float speed),
        (this, std::cref(position), std::cref(direction), size, speed))
    VIRTUAL_FUNCTION(muzzle_flash, void, 5, (const vec3& origin, const vec3& angles, float scale, int type),
        (this, std::cref(origin), std::cref(angles), scale, type))
    VIRTUAL_FUNCTION(metal_sparks, void, 6, (const vec3& position, const vec3& direction), (this, std::cref(position), std::cref(direction)))
    VIRTUAL_FUNCTION(energy_splash, void, 7, (const vec3& position, const vec3& direction, bool explosive = false),
        (this, std::cref(position), std::cref(direction), explosive))
    VIRTUAL_FUNCTION(ricochet, void, 8, (const vec3& position, const vec3& direction), (this, std::cref(position), std::cref(direction)))
};

struct entity_list {
    template<class ty = cs::base_entity*>
    VIRTUAL_FUNCTION(get, ty, 3, (int index), (this, index))
    template<class ty = cs::base_entity*>
    VIRTUAL_FUNCTION(get_from_handle, ty, 4, (int handle), (this, handle))
    VIRTUAL_FUNCTION(get_highest_index, int, 6, (), (this))
};

struct game_console {
    VIRTUAL_FUNCTION(activate, void, 1, (), (this))
    VIRTUAL_FUNCTION(hide, void, 3, (), (this))
    VIRTUAL_FUNCTION(clear, void, 4, (), (this))
    VIRTUAL_FUNCTION(is_console_visible, bool, 5, (), (this))
};

struct game_movement {
    VIRTUAL_FUNCTION(process_movement, void, 1, (cs::base_player* player, cs::move_data* move_data), (this, player, move_data))
    VIRTUAL_FUNCTION(reset, void, 2, (), (this))
};

struct game_rules {
    NETVAR(is_warmup_period, bool, "CCSGameRulesProxy->m_bWarmupPeriod")
    NETVAR(is_freeze_period, bool, "CCSGameRulesProxy->m_bFreezePeriod")
    NETVAR(is_valve_ds, bool, "CCSGameRulesProxy->m_bIsValveDS")
    NETVAR(is_bomb_planted, bool, "CCSGameRulesProxy->m_bBombPlanted")
};

struct game_ui {
    VIRTUAL_FUNCTION(create_command_msg_box, void, 19, (const char* title, const char* message, bool show_ok = true, bool show_cancel = false,
        const char* ok_command = nullptr, const char* cancel_command = nullptr, const char* closed_command = nullptr, const char* legend = nullptr,
        const char* unknown = nullptr), (this, title, message, show_ok, show_cancel, ok_command, cancel_command, closed_command, legend, unknown))
};

struct global_vars_base {
    float real_time{ };
    int	frame_count{ };
    float absolute_frame_time{ };
    float absolute_frame_start_time_dev{ };
    float cur_time{ };
    float frame_time{ };
    int max_clients{ };
    int tick_count{ };
    float interval_per_tick{ };
    float interpolation_amount{ };
    int sim_ticks_this_frame{ };
};

struct glow_manager {
    cs::utl_vec<cs::glow_object_definition> glow_objects{ };
    int first_free_slot{ };
};

struct hud_chat {
    template<class... va_args>
    void printf(cs::hud_filter filter, const char* fmt, va_args... args) noexcept
    {
        (*reinterpret_cast<void(***)(void*, cs::hud_filter, const char*, ...)>(this))[26](this, filter, fmt, args...);
    }

    template<class... va_args>
    void wprintf(cs::hud_filter filter, const wchar_t* fmt, va_args... args) noexcept
    {
        (*reinterpret_cast<void(***)(void*, cs::hud_filter, const wchar_t*, ...)>(this))[27](this, filter, fmt, args...);
    }
};

struct leaf_system;

struct move_helper {
    VIRTUAL_FUNCTION(set_host, void, 1, (cs::base_player* host), (this, host))
    VIRTUAL_FUNCTION(process_impacts, void, 4, (), (this))
};

struct player_resource {
    NETVAR(get_c4_carrier, int, "CCSPlayerResource->m_iPlayerC4")
    NETVAR(bombsite_a_pos, vec3, "CCSPlayerResource->m_bombsiteCenterA")
    NETVAR(bombsite_b_pos, vec3, "CCSPlayerResource->m_bombsiteCenterB")
};

struct prediction {
    VIRTUAL_FUNCTION(update, void, 3, (int start_frame, bool valid_frame, int incoming_acknowledged, int outgoing_command),
        (this, start_frame, valid_frame, incoming_acknowledged, outgoing_command))
    VIRTUAL_FUNCTION(set_local_view_angles, void, 13, (const angle& angles), (this, std::cref(angles)))
    VIRTUAL_FUNCTION(setup_move, void, 20, (cs::base_player* player, cs::user_cmd* cmd, se::move_helper* helper, cs::move_data* move),
        (this, player, cmd, helper, move))
    VIRTUAL_FUNCTION(finish_move, void, 21, (cs::base_player* player, cs::user_cmd* cmd, cs::move_data* move), (this, player, cmd, move))
    VIRTUAL_FUNCTION(check_moving_ground, void, 18, (cs::base_player* player, double frame_time), (this, player, frame_time))

    PAD(0x8)
    bool is_in_prediction{ };
    PAD(0x1)
    bool is_engine_paused{ };
    PAD(0xd)
    bool is_first_time_predicted{ };
};

struct render_beams {
    VIRTUAL_FUNCTION(draw_beam, void, 6, (cs::beam* beam), (this, beam))
    VIRTUAL_FUNCTION(create_beam_points, cs::beam*, 12, (cs::beam_info* beam_info), (this, beam_info))
};

struct view_render;

struct weapon_system {
    VIRTUAL_FUNCTION(get_weapon_data, cs::weapon_info*, 2, (short item_id), (this, item_id))
};

}

```

`valve/se/datacache.h`:

```h
#pragma once

namespace cs { using mdl_handle = unsigned short; }

namespace se {

struct mdl_cache {
    VIRTUAL_FUNCTION(find_model, cs::mdl_handle, 11, (const char* relative_path), (this, relative_path))
    VIRTUAL_FUNCTION(begin_lock, void, 33, (), (this))
    VIRTUAL_FUNCTION(end_lock, void, 34, (), (this))
};

class mdl_cache_critical_section {
public:
    explicit mdl_cache_critical_section(mdl_cache* ptr) noexcept
        : cache(ptr)
    {
        cache->begin_lock();
    }

    ~mdl_cache_critical_section()
    {
        cache->end_lock();
    }

private:
    mdl_cache* cache{ };
};

}

```

`valve/se/engine.h`:

```h
#pragma once

#include "../cs/trace.h"

namespace cs {

struct dlight;
struct material;
struct player_info;

enum class game_type {
    unknown = -1,
    classic,
    gungame,
    training,
    custom,
    cooperative,
    skirmish,
    freeforall
};

enum class game_mode {
    unknown = 0,
    casual,
    competitive,
    wingman,
    arms_race,
    demolition,
    deathmatch,
    guardian,
    coopstrike,
    danger_zone
};

}

namespace steam { struct api_context; }

namespace se {

struct debug_overlay {
    VIRTUAL_FUNCTION(add_box_overlay, void, 1, (const vec3* origin, const vec3* mins, const vec3* maxs, const angle* angles, const clr4* clr,
        float duration), (this, origin, mins, maxs, angles, clr, duration))
    VIRTUAL_FUNCTION(add_line_overlay, void, 4, (const vec3* origin, const vec3* dest, const clr4& clr, bool no_depth_test, float duration),
        (this, origin, dest, clr, no_depth_test, duration))
    VIRTUAL_FUNCTION(screen_position, int, 13, (const vec3* point, vec3* screen), (this, point, screen))
    VIRTUAL_FUNCTION(add_capsule_overlay, void, 23, (const vec3* start, const vec3* end, float* radius, const clr4* clr, float duration,
        bool ignore_z), (this, start, end, radius, clr, duration, ignore_z))
};

struct effects {
    VIRTUAL_FUNCTION(alloc_dlight, cs::dlight*, 4, (int key), (this, key))
    VIRTUAL_FUNCTION(alloc_elight, cs::dlight*, 5, (int key), (this, key))
};

struct spatial_query;
struct net_channel_info;

struct engine_client {
    VIRTUAL_FUNCTION(get_screen_size, void, 5, (int& width, int& height), (this, std::ref(width), std::ref(height)))
    VIRTUAL_FUNCTION(get_player_info, bool, 8, (int entity_index, cs::player_info* player_info), (this, entity_index, player_info))
    VIRTUAL_FUNCTION(get_player_for_uid, int, 9, (int uid), (this, uid))
    VIRTUAL_FUNCTION(get_local_player, int, 12, (), (this))
    VIRTUAL_FUNCTION(get_view_angles, void, 18, (angle& angles), (this, std::ref(angles)))
    VIRTUAL_FUNCTION(set_view_angles, void, 19, (angle& angles), (this, std::ref(angles)))
    VIRTUAL_FUNCTION(get_max_clients, int, 20, (), (this))
    VIRTUAL_FUNCTION(is_in_game, bool, 26, (), (this))
    VIRTUAL_FUNCTION(is_connected, bool, 27, (), (this))
    VIRTUAL_FUNCTION(world_to_screen_matrix, const mat4x4&, 37, (), (this))
    VIRTUAL_FUNCTION(get_bsp_tree_query, spatial_query*, 43, (), (this))
    VIRTUAL_FUNCTION(get_level_name, const char*, 52, (), (this))
    VIRTUAL_FUNCTION(get_level_name_short, const char*, 53, (), (this))
    VIRTUAL_FUNCTION(get_net_channel_info, net_channel_info*, 78, (), (this))
    VIRTUAL_FUNCTION(is_paused, bool, 90, (), (this))
    VIRTUAL_FUNCTION(is_taking_screenshot, bool, 92, (), (this))
    VIRTUAL_FUNCTION(is_hltv, bool, 93, (), (this))
    VIRTUAL_FUNCTION(get_engine_build_number, unsigned int, 104, (), (this))
    VIRTUAL_FUNCTION(get_product_version_string, const char*, 105, (), (this))
    VIRTUAL_FUNCTION(exec_client_cmd, void, 114, (const char* cmd, bool from_console_or_keybind = false), // Unrestricted version
        (this, cmd, from_console_or_keybind))
    VIRTUAL_FUNCTION(get_steam_api_context, steam::api_context*, 185, (), (this))
    VIRTUAL_FUNCTION(is_voice_recording, bool, 224, (), (this))

    d2 get_screen_size() noexcept
    {
        int x{ }, y{ };
        get_screen_size(x, y);
        return d2{ x, y };
    }

    angle get_view_angles() noexcept
    {
        angle ret{ };
        get_view_angles(ret);
        return ret;
    }
};

class engine_trace {
private:
    VIRTUAL_FUNCTION(trace_ray, void, 5, (const cs::ray& ray, cs::trace_mask_t contents_mask, const cs::trace_filter& filter,
        cs::trace& trace), (this, std::cref(ray), contents_mask, std::cref(filter), std::ref(trace)))

public:
    VIRTUAL_FUNCTION(get_point_contents, int, 0, (const vec3& pos, cs::trace_mask_t mask = cs::trace_mask::all,
        cs::base_entity** entity = nullptr), (this, std::cref(pos), mask, entity))
    VIRTUAL_FUNCTION(clip_ray_to_entity, void, 3, (const cs::ray& ray, cs::trace_mask_t mask, cs::base_entity* entity, cs::trace* trace),
        (this, std::cref(ray), mask, entity, trace))

    inline void trace_line(const vec3& src, const vec3& dest, cs::trace_mask_t contents_mask, cs::base_entity* entity,
        cs::collision_group group, cs::trace& trace, cs::should_hit_fn extra_should_hit_check = nullptr) noexcept
    {
        trace_ray(cs::ray(src, dest), contents_mask, cs::trace_filter_simple(entity, group, extra_should_hit_check), trace);
    }

};

struct event_listener {
    static constexpr int event_debug_id_init = 42;

    virtual ~event_listener() { }
    virtual void fire_game_event(cs::game_event* event) = 0;
    virtual int get_event_debug_id() { return event_debug_id_init; }
};

struct event_manager {
    VIRTUAL_FUNCTION(add_listener, bool, 3, (event_listener* listener, const char* name, bool server_side = false),
        (this, listener, name, server_side))
    VIRTUAL_FUNCTION(remove_listener, void, 5, (event_listener* listener), (this, listener))
};

struct game_types {
    VIRTUAL_FUNCTION(get_current_game_type, cs::game_type, 8, (), (this))
    VIRTUAL_FUNCTION(get_current_game_mode, cs::game_mode, 9, (), (this))
};

struct model_info {
    VIRTUAL_FUNCTION(get_model, cs::model*, 1, (int index), (this, index))
    VIRTUAL_FUNCTION(get_model_index, int, 2, (const char* name), (this, name))
    VIRTUAL_FUNCTION(get_model_name, const char*, 3, (const cs::model* model), (this, model))
    VIRTUAL_FUNCTION(get_studio_model, cs::studio_hdr_t*, 32, (const cs::model* model), (this, model))
};

struct model_render {
    VIRTUAL_FUNCTION(forced_material_override, void, 1, (cs::material* material, int override_type = 0, int overrides = 0),
        (this, material, override_type, overrides))
    VIRTUAL_FUNCTION(is_forced_material_override, bool, 2, (), (this))
};

struct string_table {
    VIRTUAL_FUNCTION(add_string, void, 8, (bool is_server, const char* value, int length = -1, const void* user_data = nullptr),
        (this, is_server, value, length, user_data))
};

struct string_table_container {
    VIRTUAL_FUNCTION(find_table, string_table*, 3, (const char* table_name), (this, table_name))
};

struct render_view {
    VIRTUAL_FUNCTION(set_blend, void, 4, (float blend), (this, blend))
    VIRTUAL_FUNCTION(set_color, void, 6, (float* value), (this, value))
};

struct sound;

struct vgui {
    PAD(0x48)
    void* static_transition_panel;

    VIRTUAL_FUNCTION(get_panel, cs::vpanel, 1, (cs::vgui_panel panel), (this, panel))
};

}

```

`valve/se/file_system.h`:

```h
#pragma once

namespace se {

struct file_system;

}

```

`valve/se/input_system.h`:

```h
#pragma once

namespace cs {

enum class button_code {
    invalid = -1,
    none = 0,

    key_first = 0,
    key_none = key_first,

    key_0,
    key_1,
    key_2,
    key_3,
    key_4,
    key_5,
    key_6,
    key_7,
    key_8,
    key_9,
    key_a,
    key_b,
    key_c,
    key_d,
    key_e,
    key_f,
    key_g,
    key_h,
    key_i,
    key_j,
    key_k,
    key_l,
    key_m,
    key_n,
    key_o,
    key_p,
    key_q,
    key_r,
    key_s,
    key_t,
    key_u,
    key_v,
    key_w,
    key_x,
    key_y,
    key_z,
    pad_0,
    pad_1,
    pad_2,
    pad_3,
    pad_4,
    pad_5,
    pad_6,
    pad_7,
    pad_8,
    pad_9,
    pad_divide,
    pad_multiply,
    pad_minus,
    pad_plus,
    pad_enter,
    pad_decimal,
    lbracket,
    rbracket,
    semicolon,
    apostrophe,
    backquote,
    comma,
    period,
    slash,
    backslash,
    minus,
    equal,
    enter,
    space,
    backspace,
    tab,
    capslock,
    numlock,
    escape,
    scrolllock,
    insert,
    key_delete,
    home,
    end,
    pageup,
    pagedown,
    key_break,
    lshift,
    rshift,
    lalt,
    ralt,
    lcontrol,
    rcontrol,
    lwin,
    rwin,
    app,
    up,
    left,
    down,
    right,
    f1,
    f2,
    f3,
    f4,
    f5,
    f6,
    f7,
    f8,
    f9,
    f10,
    f11,
    f12,
    capslocktoggle,
    numlocktoggle,
    scrolllocktoggle,

    key_last = scrolllocktoggle,
    key_count = key_last - key_first + 1,

    mouse_first = key_last + 1,

    mouse_left = mouse_first,
    mouse_right,
    mouse_middle,
    mouse_4,
    mouse_5,
    mouse_wheel_up,
    mouse_wheel_down,

    mouse_last = mouse_wheel_down,
    mouse_count = mouse_last - mouse_first + 1,
};

}

namespace se {

struct input_system {
    VIRTUAL_FUNCTION(enable_input, void, 11, (bool value = true), (this, value))
    VIRTUAL_FUNCTION(is_button_down, bool, 15, (cs::button_code btn_code), (this, btn_code))
    VIRTUAL_FUNCTION(reset_input_state, void, 39, (), (this))
    VIRTUAL_FUNCTION(button_code_to_string, const char*, 40, (cs::button_code btn_code), (this, btn_code))
    VIRTUAL_FUNCTION(virtual_key_to_button_code, cs::button_code, 45, (int virtual_key), (this, virtual_key))
    VIRTUAL_FUNCTION(button_code_to_virtual_key, int, 46, (cs::button_code btn_code), (this, btn_code))
};

}

```

`valve/se/localize.h`:

```h
#pragma once

namespace se {

struct localize {
    VIRTUAL_FUNCTION(find, wchar_t*, 11, (const char* token_name), (this, token_name))
    VIRTUAL_FUNCTION(find_safe, const wchar_t*, 12, (const char* token_name), (this, token_name))
    VIRTUAL_FUNCTION(ansi_to_unicode, int, 13, (const char* ansi, wchar_t* unicode, int unicode_buf_size_in_bytes),
        (this, ansi, unicode, unicode_buf_size_in_bytes))
    VIRTUAL_FUNCTION(unicode_to_ansi, int, 14, (const wchar_t* unicode, char* ansi, int ansi_buf_size), (this, unicode, ansi, ansi_buf_size))
};

}

```

`valve/se/matchmaking.h`:

```h
#pragma once

namespace cs { struct key_values; }

namespace se {

struct match_session;

struct match_framework {
    VIRTUAL_FUNCTION(get_match_session, match_session*, 13, (), (this))
    VIRTUAL_FUNCTION(create_session, void, 16, (cs::key_values* settings), (this, settings))
    VIRTUAL_FUNCTION(accept_invite, void, 18, (int controller), (this, controller))
    VIRTUAL_FUNCTION(close_session, void, 19, (), (this))
};

struct match_session {
    VIRTUAL_FUNCTION(get_session_system_data, cs::key_values*, 0, (), (this))
    VIRTUAL_FUNCTION(get_session_settings, cs::key_values*, 1, (), (this))
    VIRTUAL_FUNCTION(update_session_settings, void, 2, (cs::key_values* settings), (this, settings))
    VIRTUAL_FUNCTION(command, void, 3, (cs::key_values* cmd), (this, cmd))
};

}

```

`valve/se/material_system.h`:

```h
#pragma once

#include <array>

namespace cs {

struct key_values;
struct material;
using mat_handle = unsigned short;

struct material_system_config {
    PAD(0x32)
    unsigned int flags{ };
    PAD(0x11)
    bool fullbright{ };
};

using texture_group_t = const char*;

namespace texture_group {

    constexpr texture_group_t world = "World textures";
    constexpr texture_group_t model = "Model textures";
    constexpr texture_group_t static_prop = "StaticProp textures";
    constexpr texture_group_t particle = "Particle textures";
    constexpr texture_group_t sky_box = "SkyBox textures";
    constexpr texture_group_t client_effect = "ClientEffect textures";
    constexpr texture_group_t other = "Other textures";

}

}

namespace se {

struct material_system {
    VIRTUAL_FUNCTION(create_material, cs::material*, 83, (const char* name, cs::key_values* key_values), (this, name, key_values))
    VIRTUAL_FUNCTION(find_material, cs::material*, 84, (const char* name, cs::texture_group_t texture_group = cs::texture_group::model,
        bool complain = true, const char* complain_prefix = nullptr), (this, name, texture_group, complain, complain_prefix))
    VIRTUAL_FUNCTION(first_material, cs::mat_handle, 86, (), (this))
    VIRTUAL_FUNCTION(next_material, cs::mat_handle, 87, (cs::mat_handle handle), (this, handle))
    VIRTUAL_FUNCTION(get_material, cs::material*, 89, (cs::mat_handle handle), (this, handle))
    VIRTUAL_FUNCTION(get_material_count, int, 90, (), (this))
};

}

```

`valve/se/net.h`:

```h
#pragma once

namespace se { struct net_channel; }

namespace cs {

enum class flow_direction {
    outgoing, incoming
};

enum class netaddr_type {
    null,
    loopback,
    broadcast,
    ip
};

struct netaddr {
    netaddr_type type{ };
    unsigned char ip[4]{ };
    unsigned short port{ };
};

struct server_info {
    netaddr net_addr{ };
    netaddr net_addr_online{ };
    uint16_t port{ };

    bool active{ };
    bool dedicated{ };
    bool lobby_exclusive{ };
    bool group_exclusive{ };
    bool in_main_menu_background{ };

    char const* server_name{ };
    char const* map_name{ };
    char const* map_group_name{ };

    int max_human_players{ };
    int human_players{ };
};

struct client_info {
    int signon_state{ };
    int socket{ };
    se::net_channel* net_channel{ };
    int human_players{ };
};

enum class clc_msg {
    file_crc_check = 14
};

enum class message_group {
    voice = 9
};

}

namespace se {

struct net_channel_info {
    VIRTUAL_FUNCTION(get_name, const char*, 0, (), (this))
    VIRTUAL_FUNCTION(get_address, const char*, 1, (), (this))
    VIRTUAL_FUNCTION(get_latency, float, 9, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_avg_latency, float, 10, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_avg_loss, float, 11, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_avg_choke, float, 12, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_avg_data, float, 13, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_avg_packets, float, 14, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(get_sequence_number, int, 17, (cs::flow_direction flow), (this, flow))
    VIRTUAL_FUNCTION(is_valid_packet, bool, 18, (cs::flow_direction flow, int frame_number), (this, flow, frame_number))
};

struct net_message {
    VIRTUAL_FUNCTION(get_type, cs::clc_msg, 7, (), (this))
    VIRTUAL_FUNCTION(get_group, cs::message_group, 8, (), (this))
};

struct net_channel : public net_channel_info {
    PAD(0x14)
    bool processing_messages{ };
    bool should_delete{ };
    PAD(0x2)
    int	out_sequence_number{ };
    int	in_sequence_number{ };
    int out_sequence_number_acknowledged{ };
    int out_reliable_state{ };
    int in_reliable_state{ };
    int choked_packets{ };
};

struct net_support {
    VIRTUAL_FUNCTION(get_server_info, void, 2, (cs::server_info* info), (this, info))
    VIRTUAL_FUNCTION(get_client_info, void, 3, (cs::client_info* info), (this, info))
};

}

```

`valve/se/se.h`:

```h
#pragma once

#include "../../base/base.h"

#include "client.h"
#include "datacache.h"
#include "surface.h"
#include "engine.h"
#include "file_system.h"
#include "input_system.h"
#include "localize.h"
#include "matchmaking.h"
#include "material_system.h"
#include "net.h"
#include "server.h"
#include "studio_render.h"
#include "tier0.h"
#include "vgui2.h"
#include "vphysics.h"
#include "vstdlib.h"

#include "../steam/steam.h"

```

`valve/se/server.h`:

```h
#pragma once

namespace se {

struct server_dll;

}

```

`valve/se/studio_render.h`:

```h
#pragma once

#include "../cs/material.h"

namespace cs {

    enum class override_type {
        normal,
        build_shadows,
        depth_write,
        selective,
        ssao_depth_write
    };

}

namespace se {

struct studio_render {
    VIRTUAL_FUNCTION(set_color_modulation, void, 27, (const clr3& clr), (this, clr))
    VIRTUAL_FUNCTION(set_alpha_modulation, void, 28, (float alpha), (this, alpha))
    VIRTUAL_FUNCTION(forced_material_override, void, 33, (cs::material* material,
        cs::override_type type = cs::override_type::normal, int overrides = 0), (this, material, type, overrides))

    PAD(0x240)
    float color_modulation[3]{ };
    float alpha_modulation{ };
    cs::material* forced_material[4]{ };
    cs::override_type forced_material_type{ };
    int forced_material_index[4]{ };
    int forced_material_index_count{ };

    inline bool is_forced_material_override() const noexcept
    {
        if (!forced_material[0])
            return forced_material_type == cs::override_type::depth_write || forced_material_type == cs::override_type::ssao_depth_write;

        return *reinterpret_cast<const uint32_t*>(forced_material[0]->get_name() + 4) == 'wolg';
    }

    inline void set_color(const clr4& clr) noexcept
    {
        color_modulation[0] = clr.r_base();
        color_modulation[1] = clr.g_base();
        color_modulation[2] = clr.b_base();
        alpha_modulation = clr.a_base();
    }

};

}

```

`valve/se/surface.h`:

```h
#pragma once

namespace cs {

using h_font = unsigned long;

enum class font_draw_type {
    _default,
    nonadditive,
    additive
};

enum class font_flag {
    none,
    italic = (1 << 0),
    underline = (1 << 1),
    strikeout = (1 << 2),
    symbol = (1 << 3),
    antialias = (1 << 4),
    gaussian_blur = (1 << 5),
    rotary = (1 << 6),
    dropshadow = (1 << 7),
    additive = (1 << 8),
    outline = (1 << 9),
    custom = (1 << 10),
    bitmap = (1 << 11)
};

using vpanel = uint32_t;

enum class paint_mode {
    ui_panels = (1 << 0),
    ingame_panels = (1 << 1)
};

enum class vgui_panel {
    root,
    game_ui_dll,
    client_dll,
    tools,
    ingame_screens,
    game_dll,
    client_dll_tools
};

}

using cs::h_font;
using cs::font_draw_type;
using cs::font_flag;

struct vertex {
    vec3 pos{ };
    vec3 tex_coord{ };
};

namespace se {

struct surface {
    VIRTUAL_FUNCTION(draw_set_color, void, 15, (int r, int g, int b, int a), (this, r, g, b, a))
    VIRTUAL_FUNCTION(draw_set_color, void, 15, (const clr4& clr), (this, clr))
    VIRTUAL_FUNCTION(draw_filled_rect, void, 16, (int x0, int y0, int x1, int y1), (this, x0, y0, x1, y1))
    VIRTUAL_FUNCTION(draw_outlined_rect, void, 18, (int x0, int y0, int x1, int y1), (this, x0, y0, x1, y1))
    VIRTUAL_FUNCTION(draw_line, void, 19, (int x0, int y0, int x1, int y1), (this, x0, y0, x1, y1))
    VIRTUAL_FUNCTION(draw_poly_line, void, 20, (int* px, int* py, int points), (this, px, py, points))
    VIRTUAL_FUNCTION(draw_set_text_font, void, 23, (h_font font), (this, font))
    VIRTUAL_FUNCTION(draw_set_text_color, void, 25, (int r, int g, int b, int a), (this, r, g, b, a))
    VIRTUAL_FUNCTION(draw_set_text_pos, void, 26, (int x, int y), (this, x, y))
    VIRTUAL_FUNCTION(draw_print_text, void, 28, (const wchar_t* text, int len, font_draw_type draw_type = font_draw_type::_default),
        (this, text, len, draw_type))
    VIRTUAL_FUNCTION(draw_set_texture_rgba, void, 37, (int id, const unsigned char* rgba, int width, int height), (this, id, rgba, width, height))
    VIRTUAL_FUNCTION(draw_set_texture, void, 38, (int id), (this, id))
    VIRTUAL_FUNCTION(draw_textured_rect, void, 41, (int x0, int y0, int x1, int y1), (this, x0, y0, x1, y1))
    VIRTUAL_FUNCTION(create_new_texture_id, int, 43, (bool procedural = false), (this, procedural))
    VIRTUAL_FUNCTION(unlock_cursor, void, 66, (), (this))
    VIRTUAL_FUNCTION(create_font, h_font, 71, (), (this))
    VIRTUAL_FUNCTION(set_font_glyph_set, void, 72,
        (h_font font, const char* win_font_name, int height, int weight, int blur, int scanlines, int flags, int min_range = 0, int max_range = 0),
        (this, font, win_font_name, height, weight, blur, scanlines, flags, min_range, max_range))
    VIRTUAL_FUNCTION(get_text_size, void, 79, (h_font font, const wchar_t* text, int* width, int* height), (this, font, text, width, height))
    VIRTUAL_FUNCTION(play_sound, void, 82, (const char* filename), (this, filename))
    VIRTUAL_FUNCTION(draw_outlined_circle, void, 103, (int x, int y, int radius, int segments), (this, x, y, radius, segments))
    VIRTUAL_FUNCTION(draw_textured_polygon, void, 106, (int n, vertex* vertice, bool clip_vertices = true), (this, n, vertice, clip_vertices))
    VIRTUAL_FUNCTION(draw_colored_circle, void, 162, (int x, int y, float radius, int r, int g, int b, int a), (this, x, y, radius, r, g, b, a))

    VIRTUAL_FUNCTION_SIG(start_drawing, void, dlls::vgui_mat_surface, "55 8B EC 83 E4 C0 83 EC 38", (this))
    VIRTUAL_FUNCTION_SIG(finish_drawing, void, dlls::vgui_mat_surface, "8B 0D ? ? ? ? 56 C6 05", (this))
};

}

```

`valve/se/tier0.h`:

```h
#pragma once

namespace se {

struct mem_alloc {
    template<class ty>
    VIRTUAL_FUNCTION(alloc, ty, 1, (size_t size), (this, size))
    template<class ty>
    VIRTUAL_FUNCTION(realloc, ty, 3, (ty mem, size_t size), (this, mem, size))
    template<class ty>
    VIRTUAL_FUNCTION(free, void, 5, (ty mem), (this, mem))
};

}

```

`valve/se/vgui2.h`:

```h
#pragma once

namespace se {

struct panel {
    VIRTUAL_FUNCTION(get_panel_name, const char*, 36, (cs::vgui_panel panel_id), (this, panel_id))
};

}

```

`valve/se/vphysics.h`:

```h
#pragma once

namespace cs {

struct surface_data {
    PAD(0x58)
    float penetration_modifier{ };
    float damage_modifier{ };
    mat_handle material{ };
};

}

namespace se {

struct physics_surface_props {
    VIRTUAL_FUNCTION(get_surface_data, cs::surface_data*, 5, (int index), (this, index))
};

}

```

`valve/se/vstdlib.h`:

```h
#pragma once

#include "../cs/convar.h"

namespace se {

struct cvar {
    VIRTUAL_FUNCTION(find_cmd_line_value, const char*, 11, (const char* name), (this, name))
    VIRTUAL_FUNCTION(find_var, cs::convar*, 14, (const char* var_name), (this, var_name))

    class iterator {
    public:
        VIRTUAL_FUNCTION(set_first, void, 0, (), (this))
        VIRTUAL_FUNCTION(next, void, 1, (), (this))
        VIRTUAL_FUNCTION(is_valid, bool, 2, (), (this))
        VIRTUAL_FUNCTION(get, cs::command_base*, 3, (), (this))
    };

    VIRTUAL_FUNCTION(factory_internal_iterator, iterator*, 42, (), (this))

    cs::utl_vec<std::add_pointer_t<void(cs::convar*, const char*, float)>> global_change_callbacks{ };
    PAD(0x1c)
    cs::convar* cmd_list{ };
};

struct key_values_system;

using key_values_system_fn = key_values_system*(*)();

}

```

`valve/steam/steam.h`:

```h
#pragma once

#include "../../memory/memory.h"

namespace steam {

using h_pipe = uint32_t;
using h_user = uint32_t;

// Initialized in interface.cpp, use with client::get_generic_interface()
inline h_pipe pipe{ };
inline h_user user{ };

struct id {
    union {
        struct {
            uint32_t acc_id : 32;
            uint32_t acc_instance : 20;
            uint32_t acc_type : 4;
            int32_t universe : 8;
        };
        uint64_t full{ };
    };
};

enum class gc_result {
    ok,
    no_message,
    buffer_too_small,
    not_logged_on,
    invalid_message
};

struct client {
    VIRTUAL_FUNCTION(get_generic_interface, void*, 12, (h_user user, h_pipe pipe, const char* version), (this, user, pipe, version))
};

struct friends {
    VIRTUAL_FUNCTION(get_persona_name, const char*, 0, (), (this))
};

struct game_coordinator {
    VIRTUAL_FUNCTION(send_message, gc_result, 0, (uint32_t msg_type, const void* data, uint32_t cub_data), (this, msg_type, data, cub_data))
    VIRTUAL_FUNCTION(is_message_available, bool, 1, (uint32_t* cub_msg_size), (this, cub_msg_size))
    VIRTUAL_FUNCTION(retrieve_message, gc_result, 2, (uint32_t* msg_type, void* dest, uint32_t cub_dest, uint32_t* cub_msg_size),
        (this, msg_type, dest, cub_dest, cub_msg_size))
};

struct matchmaking {
    VIRTUAL_FUNCTION(create_lobby, int, 13, (int lobby_type, int max_members), (this, lobby_type, max_members))
    VIRTUAL_FUNCTION(join_lobby, int, 14, (id lobby_id), (this, lobby_id))
    VIRTUAL_FUNCTION(leave_lobby, void, 15, (id lobby_id), (this, lobby_id))
    VIRTUAL_FUNCTION(invite_user_to_lobby, bool, 16, (id lobby_id, id steam_invite_id), (this, lobby_id, steam_invite_id))
    VIRTUAL_FUNCTION(send_lobby_chat_msg, bool, 26, (id lobby_id, const void* msg_body, int size), (this, lobby_id, msg_body, size))
    VIRTUAL_FUNCTION(set_lobby_type, bool, 33, (id lobby_id, int lobby_type), (this, lobby_id, lobby_type))
    VIRTUAL_FUNCTION(set_lobby_joinable, bool, 34, (id lobby_id, bool joinable), (this, lobby_id, joinable))
    VIRTUAL_FUNCTION(set_lobby_owner, bool, 36, (id lobby_id, id new_owner), (this, lobby_id, new_owner))
};

struct user_stats {
    virtual bool request_current_stats() = 0;
    virtual bool get_stat(const char* name, int* data) = 0;
    virtual bool get_stat(const char* name, float* data) = 0;
    virtual bool set_stat(const char* name, int data) = 0;
    virtual bool set_stat(const char* name, float data) = 0;
    virtual bool update_average_rate_stat(const char* name, float count_this_session, double session_length) = 0;
    virtual bool get_achievement(const char* name, bool* achieved) = 0;
    virtual bool set_achievement(const char* name) = 0;
    virtual bool clear_achievement(const char* name) = 0;
    virtual bool get_achievement_and_unlock_time(const char* name, bool* achieved, uint32_t* unlock_time) = 0;
    virtual bool store_stats() = 0;
    virtual int get_achievement_icon(const char* name) = 0;
    virtual const char* get_achievement_display_attribute(const char* name, const char* key) = 0;
    virtual bool indicate_achievement_progress(const char* name, uint32_t current_progress, uint32_t max_progress) = 0;
    virtual uint32_t achievement_count() = 0;
    virtual const char* get_achievement_name(uint32_t achievement) = 0;
};

struct api_context {
    client* steam_client{ };
    void* steam_user{ };
    friends* steam_friends{ };
    void* steam_utils{ };
    matchmaking* steam_matchmaking{ };
    void* steam_game_search{ };
    user_stats* steam_user_stats{ };
    void* steam_apps{ };
    void* steam_matchmaking_servers{ };
    void* steam_networking{ };
    void* steam_remote_storage{ };
    void* steam_steam_screenshots{ };
    void* steam_http{ };
    void* controller{ };
    void* steam_ugc{ };
    void* steam_app_list{ };
    void* steam_music{ };
    void* steam_music_remote{ };
    void* steam_html_surface{ };
    void* steam_inventory{ };
    void* steam_video{ };
    void* steam_parental_settings{ };
    void* steam_input{ };
};

}

```