Project Path: arc_gmh5225_kevboy_r5sjnzu6

Source Tree:

```txt
arc_gmh5225_kevboy_r5sjnzu6
├── Cargo.lock
├── Cargo.toml
├── LICENSE.md
├── README.md
├── icon
│   ├── crystal.png
│   ├── github-mark-white.svg
│   ├── github-mark.svg
│   ├── icon.ico
│   ├── icon.png
│   ├── kirby2.png
│   └── shantae.png
├── rustfmt.toml
└── src
    ├── apu
    │   └── apu.rs
    ├── cartridge
    │   ├── base_cartridge.rs
    │   ├── mbc
    │   │   ├── mbc1.rs
    │   │   ├── mbc2.rs
    │   │   ├── mbc3.rs
    │   │   ├── mbc5.rs
    │   │   ├── mod.rs
    │   │   └── no_mbc.rs
    │   └── mod.rs
    ├── cpu
    │   ├── cpu.rs
    │   ├── debug
    │   │   ├── mod.rs
    │   │   └── opcode.rs
    │   ├── interrupts.rs
    │   └── registers.rs
    ├── emulator.rs
    ├── input
    │   ├── joypad.rs
    │   └── mod.rs
    ├── main.rs
    ├── mmu
    │   ├── bus.rs
    │   ├── hdma_transfer.rs
    │   ├── mmio.rs
    │   ├── mod.rs
    │   ├── serial.rs
    │   └── timer.rs
    ├── ppu
    │   ├── color_palette.rs
    │   ├── ppu.rs
    │   ├── ppu_regs.rs
    │   ├── sprite.rs
    │   └── tile_attributes.rs
    └── ui
        ├── control_panel.rs
        ├── frame_history.rs
        ├── memory_viewer.rs
        ├── palette_picker.rs
        ├── sound_settings.rs
        └── ui.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "ab_glyph"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5110f1c78cf582855d895ecd0746b653db010cec6d9f5575293f27934d980a39"
dependencies = [
 "ab_glyph_rasterizer",
 "owned_ttf_parser",
]

[[package]]
name = "ab_glyph_rasterizer"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71b1793ee61086797f5c80b6efa2b8ffa6d5dd703f118545808a7f2e27f7046"

[[package]]
name = "accesskit"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02c98a5d094590335462354da402d754fe2cb78f0e6ce5024611c28ed539c1de"
dependencies = [
 "enumn",
 "serde",
]

[[package]]
name = "accesskit_consumer"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca541e0fdb600916d196a940228df99b86d804fd2e6ef13894d7814f2799db43"
dependencies = [
 "accesskit",
]

[[package]]
name = "accesskit_macos"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4baea9413f0daf1cd4aab199bc09f8139cd726ce7673d523c27d186b8b878325"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "objc2",
 "once_cell",
]

[[package]]
name = "accesskit_unix"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4d1517421278cc8e67422d0786a18cf4291093ebe49eadf1cf989ff80e57f90"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "async-channel",
 "atspi",
 "futures-lite",
 "serde",
 "zbus",
]

[[package]]
name = "accesskit_windows"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e11c7f177739f23bd19bb856e4a64fdd96eb8638ec0a6a6dde9a7019a9e91c53"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "arrayvec",
 "once_cell",
 "paste",
 "windows 0.44.0",
]

[[package]]
name = "accesskit_winit"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14f1bd64cd0b480cafb7bdd91eb489a1ff50f0f5702437b9efa32a25b8bb82a1"
dependencies = [
 "accesskit",
 "accesskit_macos",
 "accesskit_unix",
 "accesskit_windows",
 "winit",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c99f64d1e06488f620f932677e24bc6e2897582980441ae90a671415bd7ec2f"
dependencies = [
 "cfg-if",
 "once_cell",
 "serde",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56fc6cf8dc8c4158eed8649f9b8b0ea1518eb62b544fe9490d66fa0b349eafe9"

[[package]]
name = "alsa"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8512c9117059663fb5606788fbca3619e2a91dac0e3fe516242eab1fa6be5e44"
dependencies = [
 "alsa-sys",
 "bitflags 1.3.2",
 "libc",
 "nix 0.24.3",
]

[[package]]
name = "alsa-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db8fee663d06c4e303404ef5f40488a53e062f89ba8bfed81f42325aafad1527"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "android-activity"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40bc1575e653f158cbdc6ebcd917b9564e66321c5325c232c3591269c257be69"
dependencies = [
 "android-properties",
 "bitflags 1.3.2",
 "cc",
 "jni-sys",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys",
 "num_enum 0.6.1",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "anyhow"
version = "1.0.71"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c7d0618f0e0b7e8ff11427422b64564d5fb0be1940354bfe2e0529b18a9d9b8"

[[package]]
name = "arboard"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6041616acea41d67c4a984709ddab1587fd0b10efe5cc563fee954d2f011854"
dependencies = [
 "clipboard-win",
 "log",
 "objc",
 "objc-foundation",
 "objc_id",
 "once_cell",
 "parking_lot",
 "thiserror",
 "winapi",
 "x11rb",
]

[[package]]
name = "arrayref"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"

[[package]]
name = "arrayvec"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"

[[package]]
name = "async-broadcast"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c48ccdbf6ca6b121e0f586cbc0e73ae440e56c67c30fa0873b4e110d9c26d2b"
dependencies = [
 "event-listener",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81953c529336010edd6d8e358f886d9581267795c61b19475b71314bffa46d35"
dependencies = [
 "concurrent-queue",
 "event-listener",
 "futures-core",
]

[[package]]
name = "async-executor"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fa3dc5f2a8564f07759c008b9109dc0d39de92a88d5588b8a5036d286383afb"
dependencies = [
 "async-lock",
 "async-task",
 "concurrent-queue",
 "fastrand 1.9.0",
 "futures-lite",
 "slab",
]

[[package]]
name = "async-fs"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "279cf904654eeebfa37ac9bb1598880884924aab82e290aa65c9e77a0e142e06"
dependencies = [
 "async-lock",
 "autocfg",
 "blocking",
 "futures-lite",
]

[[package]]
name = "async-io"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fc5b45d93ef0529756f812ca52e44c221b35341892d3dcc34132ac02f3dd2af"
dependencies = [
 "async-lock",
 "autocfg",
 "cfg-if",
 "concurrent-queue",
 "futures-lite",
 "log",
 "parking",
 "polling",
 "rustix 0.37.27",
 "slab",
 "socket2",
 "waker-fn",
]

[[package]]
name = "async-lock"
version = "2.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa24f727524730b077666307f2734b4a1a1c57acb79193127dcc8914d5242dd7"
dependencies = [
 "event-listener",
]

[[package]]
name = "async-process"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a9d28b1d97e08915212e2e45310d47854eafa69600756fc735fb788f75199c9"
dependencies = [
 "async-io",
 "async-lock",
 "autocfg",
 "blocking",
 "cfg-if",
 "event-listener",
 "futures-lite",
 "rustix 0.37.27",
 "signal-hook",
 "windows-sys 0.48.0",
]

[[package]]
name = "async-recursion"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e97ce7de6cf12de5d7226c73f5ba9811622f4db3a5b91b55c53e987e5f91cba"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "async-task"
version = "4.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc7ab41815b3c653ccd2978ec3255c81349336702dfdf62ee6f7069b12a3aae"

[[package]]
name = "async-trait"
version = "0.1.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc6dde6e4ed435a4c1ee4e73592f5ba9da2151af10076cc04858746af9352d09"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "atk-sys"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11ad703eb64dc058024f0e57ccfa069e15a413b98dbd50a1a950e743b7f11148"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "atomic-waker"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1181e1e0d1fce796a03db1ae795d67167da795f9cf4a39c37589e85ef57f26d3"

[[package]]
name = "atomic_refcell"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79d6dc922a2792b006573f60b2648076355daeae5ce9cb59507e5908c9625d31"

[[package]]
name = "atspi"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "674e7a3376837b2e7d12d34d58ac47073c491dc3bf6f71a7adaf687d4d817faa"
dependencies = [
 "async-recursion",
 "async-trait",
 "atspi-macros",
 "enumflags2",
 "futures-lite",
 "serde",
 "tracing",
 "zbus",
 "zbus_names",
]

[[package]]
name = "atspi-macros"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb4870a32c0eaa17e35bca0e6b16020635157121fb7d45593d242c295bc768"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "bindgen"
version = "0.64.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4243e6031260db77ede97ad86c27e501d646a27ab57b59a574f725d98ab1fb4"
dependencies = [
 "bitflags 1.3.2",
 "cexpr",
 "clang-sys",
 "lazy_static",
 "lazycell",
 "peeking_take_while",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn 1.0.109",
]

[[package]]
name = "bit_field"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc827186963e592360843fb5ba4b973e145841266c1357f7180c43526f2e5b61"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "630be753d4e58660abd17930c71b647fe46c27ea6b63cc59e1e3851406972e42"

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-sys"
version = "0.1.0-beta.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa55741ee90902547802152aaf3f8e5248aab7e21468089560d4c8840561146"
dependencies = [
 "objc-sys",
]

[[package]]
name = "block2"
version = "0.2.0-alpha.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8dd9e63c1744f755c2f60332b88de39d341e5e86239014ad839bd71c106dec42"
dependencies = [
 "block-sys",
 "objc2-encode",
]

[[package]]
name = "blocking"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77231a1c8f801696fc0123ec6150ce92cffb8e164a02afb9c8ddee0e9b65ad65"
dependencies = [
 "async-channel",
 "async-lock",
 "async-task",
 "atomic-waker",
 "fastrand 1.9.0",
 "futures-lite",
 "log",
]

[[package]]
name = "bumpalo"
version = "3.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3e2c3daef883ecc1b5d58c15adae93470a91d425f3532ba1695849656af3fc1"

[[package]]
name = "bytemuck"
version = "1.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17febce684fd15d89027105661fec94afb475cb995fbc59d2865198446ba2eea"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdde5c9cd29ebd706ce1b35600920a33550e402fc998a2e53ad3b42c3c47a192"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "bytes"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"

[[package]]
name = "cairo-sys-rs"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c48f4af05fabdcfa9658178e1326efa061853f040ce7d72e33af6885196f421"
dependencies = [
 "libc",
 "system-deps",
]

[[package]]
name = "calloop"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52e0d00eb1ea24371a97d2da6201c6747a633dc6dc1988ef503403b4c59504a8"
dependencies = [
 "bitflags 1.3.2",
 "log",
 "nix 0.25.1",
 "slotmap",
 "thiserror",
 "vec_map",
]

[[package]]
name = "cc"
version = "1.0.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"
dependencies = [
 "jobserver",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-expr"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "215c0072ecc28f92eeb0eea38ba63ddfcb65c2828c46311d646f1a3ff5f9841c"
dependencies = [
 "smallvec",
 "target-lexicon",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "cgl"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ced0551234e87afee12411d535648dd89d2e7f34c78b753395567aff3d447ff"
dependencies = [
 "libc",
]

[[package]]
name = "clang-sys"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c688fc74432808e3eb684cae8830a86be1d66a2bd58e1f248ed0960a590baf6f"
dependencies = [
 "glob",
 "libc",
 "libloading 0.7.4",
]

[[package]]
name = "clipboard-win"
version = "4.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7191c27c2357d9b7ef96baac1773290d4ca63b24205b82a3fd8a0637afcf0362"
dependencies = [
 "error-code",
 "str-buf",
 "winapi",
]

[[package]]
name = "cocoa"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f425db7937052c684daec3bd6375c8abe2d146dca4b8b143d6db777c39138f3a"
dependencies = [
 "bitflags 1.3.2",
 "block",
 "cocoa-foundation",
 "core-foundation",
 "core-graphics",
 "foreign-types",
 "libc",
 "objc",
]

[[package]]
name = "cocoa-foundation"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "931d3837c286f56e3c58423ce4eba12d08db2374461a785c86f672b08b5650d6"
dependencies = [
 "bitflags 1.3.2",
 "block",
 "core-foundation",
 "core-graphics-types",
 "foreign-types",
 "libc",
 "objc",
]

[[package]]
name = "color_quant"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d7b894f5411737b7867f4827955924d7c254fc9f4d91a6aad6b097804b1018b"

[[package]]
name = "combine"
version = "4.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35ed6e9d84f0b51a7f52daf1c7d71dd136fd7a3f41a8462b8cdb8c78d920fad4"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62ec6771ecfa0762d24683ee5a32ad78487a3d3afdc0fb8cae19d2c5deb50b7c"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "core-foundation"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "194a7a9e6de53fa55116934067c844d9d749312f75c6f6d0980e8c252f8c2146"
dependencies = [
 "core-foundation-sys 0.8.4",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b"

[[package]]
name = "core-foundation-sys"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"

[[package]]
name = "core-graphics"
version = "0.22.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2581bbab3b8ffc6fcbd550bf46c355135d16e9ff2a6ea032ad6b9bf1d7efe4fb"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-graphics-types",
 "foreign-types",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bb142d41022986c1d8ff29103a1411c8a3dfad3552f87a4f8dc50d61d4f4e33"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "libc",
]

[[package]]
name = "coreaudio-rs"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb17e2d1795b1996419648915df94bc7103c28f7b48062d7acf4652fc371b2ff"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation-sys 0.6.2",
 "coreaudio-sys",
]

[[package]]
name = "coreaudio-sys"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f034b2258e6c4ade2f73bf87b21047567fb913ee9550837c2316d139b0262b24"
dependencies = [
 "bindgen",
]

[[package]]
name = "cpal"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d959d90e938c5493000514b446987c07aed46c668faaa7d34d6c7a67b1a578c"
dependencies = [
 "alsa",
 "core-foundation-sys 0.8.4",
 "coreaudio-rs",
 "dasp_sample",
 "jni 0.19.0",
 "js-sys",
 "libc",
 "mach2",
 "ndk",
 "ndk-context",
 "oboe",
 "once_cell",
 "parking_lot",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows 0.46.0",
]

[[package]]
name = "cpufeatures"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a17b76ff3a4162b0b27f354a0c87015ddad39d35f9c0c36607a3bdd175dde1f1"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef"
dependencies = [
 "cfg-if",
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7"
dependencies = [
 "autocfg",
 "cfg-if",
 "crossbeam-utils",
 "memoffset 0.9.0",
 "scopeguard",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crunchy"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "dasp_sample"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c87e182de0887fd5361989c677c4e8f5000cd9491d6d563161a8f3a5519fc7f"

[[package]]
name = "data-url"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d7439c3735f405729d52c3fbbe4de140eaf938a1fe47d227c27f8254d4302a5"

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "directories-next"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "339ee130d97a610ea5a5872d2bbb130fdf68884ff09d3028b81bec8a1ac23bbc"
dependencies = [
 "cfg-if",
 "dirs-sys-next",
]

[[package]]
name = "dirs-sys-next"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d"
dependencies = [
 "libc",
 "redox_users",
 "winapi",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading 0.8.0",
]

[[package]]
name = "downcast-rs"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"

[[package]]
name = "ecolor"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e479a7fa3f23d4e794f8b2f8b3568dd4e47886ad1b12c9c095e141cb591eb63"
dependencies = [
 "bytemuck",
 "serde",
]

[[package]]
name = "eframe"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf4596583a2c680c55b6feaa748f74890c4f9cb9c7cb69d6117110444cb65b2f"
dependencies = [
 "bytemuck",
 "cocoa",
 "directories-next",
 "egui",
 "egui-winit",
 "egui_glow",
 "glow",
 "glutin",
 "glutin-winit",
 "image",
 "js-sys",
 "log",
 "objc",
 "percent-encoding",
 "raw-window-handle",
 "ron",
 "serde",
 "thiserror",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "winapi",
 "winit",
]

[[package]]
name = "egui"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3aef8ec3ae1b772f340170c65bf27d5b8c28f543a0116c844d2ac08d01123e7"
dependencies = [
 "accesskit",
 "ahash",
 "epaint",
 "log",
 "nohash-hasher",
 "ron",
 "serde",
]

[[package]]
name = "egui-phosphor"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c20b33023d92696a165857bcb3d87a698894b0d8d04f9383fd890b945ba0b23f"
dependencies = [
 "egui",
]

[[package]]
name = "egui-winit"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a49155fd4a0a4fb21224407a91de0030847972ef90fc64edb63621caea61cb2"
dependencies = [
 "accesskit_winit",
 "arboard",
 "egui",
 "instant",
 "log",
 "raw-window-handle",
 "serde",
 "smithay-clipboard",
 "webbrowser",
 "winit",
]

[[package]]
name = "egui_extras"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9278f4337b526f0d57e5375e5a7340a311fa6ee8f9fcc75721ac50af13face02"
dependencies = [
 "egui",
 "resvg",
 "serde",
 "tiny-skia",
 "usvg",
]

[[package]]
name = "egui_glow"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f8c2752cdf1b0ef5fcda59a898cacabad974d4f5880e92a420b2c917022da64"
dependencies = [
 "bytemuck",
 "egui",
 "glow",
 "log",
 "memoffset 0.6.5",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "either"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"

[[package]]
name = "emath"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3857d743a6e0741cdd60b622a74c7a36ea75f5f8f11b793b41d905d2c9721a4b"
dependencies = [
 "bytemuck",
 "serde",
]

[[package]]
name = "enumflags2"
version = "0.7.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c041f5090df68b32bcd905365fd51769c8b9d553fe87fde0b683534f10c01bd2"
dependencies = [
 "enumflags2_derive",
 "serde",
]

[[package]]
name = "enumflags2_derive"
version = "0.7.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e9a1f9f7d83e59740248a6e14ecf93929ade55027844dfcea78beafccc15745"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "enumn"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9838a970f5de399d3070ae1739e131986b2f5dcc223c7423ca0927e3a878522"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "epaint"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09333964d4d57f40a85338ba3ca5ed4716070ab184dcfed966b35491c5c64f3b"
dependencies = [
 "ab_glyph",
 "ahash",
 "atomic_refcell",
 "bytemuck",
 "ecolor",
 "emath",
 "log",
 "nohash-hasher",
 "parking_lot",
 "serde",
]

[[package]]
name = "equivalent"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88bffebc5d80432c9b140ee17875ff173a8ab62faad5b257da912bd2f6c1c0a1"

[[package]]
name = "errno"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a"
dependencies = [
 "errno-dragonfly",
 "libc",
 "windows-sys 0.48.0",
]

[[package]]
name = "errno-dragonfly"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "error-code"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64f18991e7bf11e7ffee451b5318b5c1a73c52d0d0ada6e5a3017c8c1ced6a21"
dependencies = [
 "libc",
 "str-buf",
]

[[package]]
name = "event-listener"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"

[[package]]
name = "exr"
version = "1.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85a7b44a196573e272e0cf0bcf130281c71e9a0c67062954b3323fd364bfdac9"
dependencies = [
 "bit_field",
 "flume",
 "half",
 "lebe",
 "miniz_oxide",
 "rayon-core",
 "smallvec",
 "zune-inflate",
]

[[package]]
name = "fastrand"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
dependencies = [
 "instant",
]

[[package]]
name = "fastrand"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6999dc1837253364c2ebb0704ba97994bd874e8f195d665c50b7548f6ea92764"

[[package]]
name = "fdeflate"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d329bdeac514ee06249dabc27877490f17f5d371ec693360768b838e19f3ae10"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "flate2"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b9429470923de8e8cbd4d2dc513535400b4b3fef0319fb5c4e1f520a7bef743"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "float-cmp"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98de4bbd547a563b716d8dfa9aad1cb19bfab00f4fa09a6a4ed21dbcf44ce9c4"

[[package]]
name = "flume"
version = "0.10.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1657b4441c3403d9f7b3409e47575237dac27b1b5726df654a6ecbf92f0f7577"
dependencies = [
 "futures-core",
 "futures-sink",
 "nanorand",
 "pin-project",
 "spin",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a62bc1cf6f830c2ec14a513a9fb124d0a213a629668a4186f329db21fe045652"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures-core"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4bca583b7e26f571124fe5b7561d49cb2868d79116cfa0eefce955557c6fee8c"

[[package]]
name = "futures-io"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fff74096e71ed47f8e023204cfd0aa1289cd54ae5430a9523be060cdb849964"

[[package]]
name = "futures-lite"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49a9d51ce47660b1e808d3c990b4709f2f415d928835a17dfd16991515c46bce"
dependencies = [
 "fastrand 1.9.0",
 "futures-core",
 "futures-io",
 "memchr",
 "parking",
 "pin-project-lite",
 "waker-fn",
]

[[package]]
name = "futures-sink"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"

[[package]]
name = "futures-task"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76d3d132be6c0e6aa1534069c705a74a5997a356c0dc2f86a47765e5617c5b65"

[[package]]
name = "futures-util"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26b01e40b772d54cf6c6d721c1d1abd0647a0106a12ecaa1c186273392a69533"
dependencies = [
 "futures-core",
 "futures-io",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "gdk-pixbuf-sys"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3092cf797a5f1210479ea38070d9ae8a5b8e9f8f1be9f32f4643c529c7d70016"
dependencies = [
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "gdk-sys"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76354f97a913e55b984759a997b693aa7dc71068c9e98bcce51aa167a0a5c5a"
dependencies = [
 "cairo-sys-rs",
 "gdk-pixbuf-sys",
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "pango-sys",
 "pkg-config",
 "system-deps",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "gethostname"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1ebd34e35c46e00bb73e81363248d627782724609fe1b6396f553f68fe3862e"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "getrandom"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi",
 "wasm-bindgen",
]

[[package]]
name = "gif"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80792593675e051cf94a4b111980da2ba60d4a83e43e0048c5693baab3977045"
dependencies = [
 "color_quant",
 "weezl",
]

[[package]]
name = "gilrs"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62fd19844d0eb919aca41d3e4ea0e0b6bf60e1e827558b101c269015b8f5f27a"
dependencies = [
 "fnv",
 "gilrs-core",
 "log",
 "serde",
 "uuid",
 "vec_map",
]

[[package]]
name = "gilrs-core"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f85b0f27572f0560cfc4a067a2978a4a490f9fa5cf1326d30b142a288312a965"
dependencies = [
 "core-foundation",
 "io-kit-sys",
 "js-sys",
 "libc",
 "libudev-sys",
 "log",
 "nix 0.26.2",
 "serde",
 "uuid",
 "vec_map",
 "wasm-bindgen",
 "web-sys",
 "windows 0.46.0",
]

[[package]]
name = "gio-sys"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e9b693b8e39d042a95547fc258a7b07349b1f0b48f4b2fa3108ba3c51c0b5229"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
 "winapi",
]

[[package]]
name = "gl_generator"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a95dfc23a2b4a9a2f5ab41d194f8bfda3cabec42af4e39f08c339eb2a0c124d"
dependencies = [
 "khronos_api",
 "log",
 "xml-rs",
]

[[package]]
name = "glib-sys"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61a4f46316d06bfa33a7ac22df6f0524c8be58e3db2d9ca99ccb1f357b62a65"
dependencies = [
 "libc",
 "system-deps",
]

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "glow"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "807edf58b70c0b5b2181dd39fe1839dbdb3ba02645630dc5f753e23da307f762"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "glutin"
version = "0.30.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23b0385782048be65f0a9dd046c469d6a758a53fe1aa63a8111dea394d2ffa2f"
dependencies = [
 "bitflags 1.3.2",
 "cfg_aliases",
 "cgl",
 "core-foundation",
 "dispatch",
 "glutin_egl_sys",
 "glutin_glx_sys",
 "glutin_wgl_sys",
 "libloading 0.7.4",
 "objc2",
 "once_cell",
 "raw-window-handle",
 "wayland-sys 0.30.1",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "glutin-winit"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "629a873fc04062830bfe8f97c03773bcd7b371e23bcc465d0a61448cd1588fa4"
dependencies = [
 "cfg_aliases",
 "glutin",
 "raw-window-handle",
 "winit",
]

[[package]]
name = "glutin_egl_sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b3bcbddc51573b977fc6dca5d93867e4f29682cdbaf5d13e48f4fa4346d4d87"
dependencies = [
 "gl_generator",
 "windows-sys 0.45.0",
]

[[package]]
name = "glutin_glx_sys"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b53cb5fe568964aa066a3ba91eac5ecbac869fb0842cd0dc9e412434f1a1494"
dependencies = [
 "gl_generator",
 "x11-dl",
]

[[package]]
name = "glutin_wgl_sys"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef89398e90033fc6bc65e9bd42fd29bbbfd483bda5b56dc5562f455550618165"
dependencies = [
 "gl_generator",
]

[[package]]
name = "gobject-sys"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3520bb9c07ae2a12c7f2fbb24d4efc11231c8146a86956413fb1a79bb760a0f1"
dependencies = [
 "glib-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "gtk-sys"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89b5f8946685d5fe44497007786600c2f368ff6b1e61a16251c89f72a97520a3"
dependencies = [
 "atk-sys",
 "cairo-sys-rs",
 "gdk-pixbuf-sys",
 "gdk-sys",
 "gio-sys",
 "glib-sys",
 "gobject-sys",
 "libc",
 "pango-sys",
 "system-deps",
]

[[package]]
name = "half"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b4af3693f1b705df946e9fe5631932443781d0aabb423b62fcd4d73f6d2fd0"
dependencies = [
 "crunchy",
]

[[package]]
name = "hashbrown"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashlink"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "312f66718a2d7789ffef4f4b7b213138ed9f1eb3aa1d0d82fc99f88fb3ffd26f"
dependencies = [
 "hashbrown",
 "serde",
]

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "hermit-abi"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "home"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5444c27eef6923071f7ebcc33e3444508466a76f7a2b93da00ed6e19f30c1ddb"
dependencies = [
 "windows-sys 0.48.0",
]

[[package]]
name = "idna"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d20d6b07bfbc108882d88ed8e37d39636dcc260e15e30c45e6ba089610b917c"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "image"
version = "0.24.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "527909aa81e20ac3a44803521443a765550f09b5130c2c2fa1ea59c2f8f50a3a"
dependencies = [
 "bytemuck",
 "byteorder",
 "color_quant",
 "exr",
 "gif",
 "jpeg-decoder",
 "num-rational",
 "num-traits",
 "png",
 "qoi",
 "tiff",
]

[[package]]
name = "imagesize"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df19da1e92fbfec043ca97d622955381b1f3ee72a180ec999912df31b1ccd951"

[[package]]
name = "indexmap"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "io-kit-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b2d4429acc1deff0fbdece0325b4997bdb02b2c245ab7023fd5deca0f6348de"
dependencies = [
 "core-foundation-sys 0.8.4",
 "mach2",
]

[[package]]
name = "io-lifetimes"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys 0.48.0",
]

[[package]]
name = "jni"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6df18c2e3db7e453d3c6ac5b3e9d5182664d28788126d39b91f2d1e22b017ec"
dependencies = [
 "cesu8",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
]

[[package]]
name = "jni"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "039022cdf4d7b1cf548d31f60ae783138e5fd42013f6271049d7df7afadef96c"
dependencies = [
 "cesu8",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
]

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
dependencies = [
 "libc",
]

[[package]]
name = "jpeg-decoder"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc0000e42512c92e31c2252315bda326620a4e034105e900c98ec492fa077b3e"
dependencies = [
 "rayon",
]

[[package]]
name = "js-sys"
version = "0.3.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445dde2150c55e483f3d8416706b97ec8e8237c307e5b7b4b8dd15e6af2a0730"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "kevboy"
version = "0.3.1"
dependencies = [
 "anyhow",
 "eframe",
 "egui",
 "egui-phosphor",
 "egui_extras",
 "gilrs",
 "hashlink",
 "image",
 "rfd",
 "rodio",
 "serde",
]

[[package]]
name = "khronos_api"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2db585e1d738fc771bf08a151420d3ed193d9d895a36df7f6f8a9456b911ddc"

[[package]]
name = "kurbo"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a53776d271cfb873b17c618af0298445c88afc52837f3e948fa3fafd131f449"
dependencies = [
 "arrayvec",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "lebe"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03087c2bad5e1034e8cace5926dec053fb3790248370865f5117a7d0213354c8"

[[package]]
name = "libc"
version = "0.2.147"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libloading"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d580318f95776505201b28cf98eb1fa5e4be3b689633ba6a3e6cd880ff22d8cb"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "libudev-sys"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c8469b4a23b962c1396b9b451dda50ef5b283e8dd309d69033475fa9b334324"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "linux-raw-sys"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"

[[package]]
name = "linux-raw-sys"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09fc20d2ca12cb9f044c93e3bd6d32d523e6e2ec3db4f7b2939cd99026ecd3f0"

[[package]]
name = "lock_api"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4"

[[package]]
name = "mach2"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d0d1830bcd151a6fc4aea1369af235b36c1528fe976b8ff678683c9995eade8"
dependencies = [
 "libc",
]

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "memchr"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "memoffset"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4"
dependencies = [
 "autocfg",
]

[[package]]
name = "memoffset"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
dependencies = [
 "autocfg",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
dependencies = [
 "adler",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "927a765cd3fc26206e66b296465fa9d3e5ab003e651c1b3c060e7956d96b19d2"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "nanorand"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a51313c5820b0b02bd422f4b44776fbf47961755c74ce64afc73bfad10226c3"
dependencies = [
 "getrandom",
]

[[package]]
name = "ndk"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "451422b7e4718271c8b5b3aadf5adedba43dc76312454b387e98fae0fc951aa0"
dependencies = [
 "bitflags 1.3.2",
 "jni-sys",
 "ndk-sys",
 "num_enum 0.5.11",
 "raw-window-handle",
 "thiserror",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.4.1+23.1.7779620"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf2aae958bd232cac5069850591667ad422d263686d75b52a065f9badeee5a3"
dependencies = [
 "jni-sys",
]

[[package]]
name = "nix"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.6.5",
]

[[package]]
name = "nix"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f346ff70e7dbfd675fe90590b92d59ef2de15a8779ae305ebcbfd3f0caf59be4"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.6.5",
]

[[package]]
name = "nix"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.7.1",
 "static_assertions",
]

[[package]]
name = "nohash-hasher"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "num-derive"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "876a53fff98e03a936a674b29568b0e605f06b29372c2489ff4de23f1949743d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num-integer"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9"
dependencies = [
 "autocfg",
 "num-traits",
]

[[package]]
name = "num-rational"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_cpus"
version = "1.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "num_enum"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
dependencies = [
 "num_enum_derive 0.5.11",
]

[[package]]
name = "num_enum"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a015b430d3c108a207fd776d2e2196aaf8b1cf8cf93253e3a097ff3085076a1"
dependencies = [
 "num_enum_derive 0.6.1",
]

[[package]]
name = "num_enum_derive"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num_enum_derive"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96667db765a921f7b295ffee8b60472b686a51d4f21c2ee4ffdb94c7013b65a6"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
]

[[package]]
name = "objc-foundation"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1add1b659e36c9607c7aab864a76c7a4c2760cd0cd2e120f3fb8b952c7e22bf9"
dependencies = [
 "block",
 "objc",
 "objc_id",
]

[[package]]
name = "objc-sys"
version = "0.2.0-beta.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b9834c1e95694a05a828b59f55fa2afec6288359cda67146126b3f90a55d7"

[[package]]
name = "objc2"
version = "0.3.0-beta.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe31e5425d3d0b89a15982c024392815da40689aceb34bad364d58732bcfd649"
dependencies = [
 "block2",
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2-encode"
version = "2.0.0-pre.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abfcac41015b00a120608fdaa6938c44cb983fee294351cc4bac7638b4e50512"
dependencies = [
 "objc-sys",
]

[[package]]
name = "objc_id"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c92d4ddb4bd7b50d730c215ff871754d0da6b2178849f8a2a2ab69712d0c073b"
dependencies = [
 "objc",
]

[[package]]
name = "oboe"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8868cc237ee02e2d9618539a23a8d228b9bb3fc2e7a5b11eed3831de77c395d0"
dependencies = [
 "jni 0.20.0",
 "ndk",
 "ndk-context",
 "num-derive",
 "num-traits",
 "oboe-sys",
]

[[package]]
name = "oboe-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f44155e7fb718d3cfddcf70690b2b51ac4412f347cd9e4fbe511abe9cd7b5f2"
dependencies = [
 "cc",
]

[[package]]
name = "once_cell"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"

[[package]]
name = "orbclient"
version = "0.3.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "221d488cd70617f1bd599ed8ceb659df2147d9393717954d82a0f5e8032a6ab1"
dependencies = [
 "redox_syscall 0.3.5",
]

[[package]]
name = "ordered-stream"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
dependencies = [
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "owned_ttf_parser"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "706de7e2214113d63a8238d1910463cfce781129a6f263d13fdb09ff64355ba4"
dependencies = [
 "ttf-parser",
]

[[package]]
name = "pango-sys"
version = "0.16.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e134909a9a293e04d2cc31928aa95679c5e4df954d0b85483159bd20d8f047f"
dependencies = [
 "glib-sys",
 "gobject-sys",
 "libc",
 "system-deps",
]

[[package]]
name = "parking"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14f2252c834a40ed9bb5422029649578e63aa341ac401f74e719dd1afda8394e"

[[package]]
name = "parking_lot"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.3.5",
 "smallvec",
 "windows-targets 0.48.1",
]

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "peeking_take_while"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"

[[package]]
name = "percent-encoding"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b2a4787296e9989611394c33f193f676704af1686e70b8f8033ab5ba9a35a94"

[[package]]
name = "pico-args"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5be167a7af36ee22fe3115051bc51f6e6c7054c9348e28deb4f49bd6f705a315"

[[package]]
name = "pin-project"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "030ad2bc4db10a8944cb0d837f158bdfec4d4a4873ab701a95046770d11f8842"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec2e072ecce94ec471b13398d5402c188e76ac03cf74dd1a975161b23a3f6d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "pin-project-lite"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c40d25201921e5ff0c862a505c6557ea88568a4e3ace775ab55e93f2f4f9d57"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26072860ba924cbfa98ea39c8c19b4dd6a4a25423dbdf219c1eca91aa0cf6964"

[[package]]
name = "png"
version = "0.17.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59871cc5b6cce7eaccca5a802b4173377a1c2ba90654246789a8fa2334426d11"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "polling"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b2d323e8ca7996b3e23126511a523f7e62924d93ecd5ae73b333815b0eb3dce"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "concurrent-queue",
 "libc",
 "log",
 "pin-project-lite",
 "windows-sys 0.48.0",
]

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b368fba921b0dce7e60f5e04ec15e565b3303972b42bcfde1d0713b881959eb"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "qoi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f6d64c71eb498fe9eae14ce4ec935c555749aef511cca85b5568910d6e48001"
dependencies = [
 "bytemuck",
]

[[package]]
name = "quote"
version = "1.0.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "573015e8ab27661678357f27dc26460738fd2b6c86e46f386fde94cb5d913105"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "raw-window-handle"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2ff9a1f06a88b01621b7ae906ef0211290d1c8a168a15542486a8f61c0833b9"

[[package]]
name = "rayon"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d"
dependencies = [
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-utils",
 "num_cpus",
]

[[package]]
name = "rctree"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b42e27ef78c35d3998403c1d26f3efd9e135d3e5121b0a4845cc5cc27547f4f"

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_users"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
dependencies = [
 "getrandom",
 "redox_syscall 0.2.16",
 "thiserror",
]

[[package]]
name = "regex"
version = "1.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0ab3ca65655bb1e41f2a8c8cd662eb4fb035e67c3f78da1d61dffe89d07300f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436b050e76ed2903236f032a59761c1eb99e1b0aead2c257922771dab1fc8c78"

[[package]]
name = "resvg"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c115863f2d3621999cf187e318bc92b16402dfeff6a48c74df700d77381394c1"
dependencies = [
 "log",
 "pico-args",
 "rgb",
 "svgtypes",
 "tiny-skia",
 "usvg",
]

[[package]]
name = "rfd"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fe664af397d2b6a13a8ba1d172a2b5c87c6c5149039edbf8fa122b98c9ed96f"
dependencies = [
 "async-io",
 "block",
 "dispatch",
 "futures-util",
 "glib-sys",
 "gobject-sys",
 "gtk-sys",
 "js-sys",
 "log",
 "objc",
 "objc-foundation",
 "objc_id",
 "raw-window-handle",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows 0.44.0",
]

[[package]]
name = "rgb"
version = "0.8.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20ec2d3e3fc7a92ced357df9cebd5a10b6fb2aa1ee797bf7e9ce2f17dffc8f59"
dependencies = [
 "bytemuck",
]

[[package]]
name = "rodio"
version = "0.17.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdf1d4dea18dff2e9eb6dca123724f8b60ef44ad74a9ad283cdfe025df7e73fa"
dependencies = [
 "cpal",
]

[[package]]
name = "ron"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "300a51053b1cb55c80b7a9fde4120726ddf25ca241a1cbb926626f62fb136bff"
dependencies = [
 "base64",
 "bitflags 1.3.2",
 "serde",
]

[[package]]
name = "roxmltree"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b9de9831a129b122e7e61f242db509fa9d0838008bf0b29bb0624669edfe48a"
dependencies = [
 "xmlparser",
]

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustix"
version = "0.37.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fea8ca367a3a01fe35e6943c400addf443c0f57670e6ec51196f71a4b8762dd2"
dependencies = [
 "bitflags 1.3.2",
 "errno",
 "io-lifetimes",
 "libc",
 "linux-raw-sys 0.3.8",
 "windows-sys 0.48.0",
]

[[package]]
name = "rustix"
version = "0.38.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a962918ea88d644592894bc6dc55acc6c0956488adcebbfb6e273506b7fd6e5"
dependencies = [
 "bitflags 2.3.3",
 "errno",
 "libc",
 "linux-raw-sys 0.4.3",
 "windows-sys 0.48.0",
]

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "sctk-adwaita"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cda4e97be1fd174ccc2aae81c8b694e803fa99b34e8fd0f057a9d70698e3ed09"
dependencies = [
 "ab_glyph",
 "log",
 "memmap2",
 "smithay-client-toolkit",
 "tiny-skia",
]

[[package]]
name = "serde"
version = "1.0.166"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d01b7404f9d441d3ad40e6a636a7782c377d2abdbe4fa2440e2edcc2f4f10db8"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.166"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd83d6dde2b6b2d466e14d9d1acce8816dedee94f735eac6395808b3483c6d6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "serde_repr"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8725e1dfadb3a50f7e5ce0b1a540466f6ed3fe7a0fca2ac2b8b831d31316bd00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "serde_spanned"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96426c9936fd7a0124915f9185ea1d20aa9445cc9821142f0a73bc9207a2e186"
dependencies = [
 "serde",
]

[[package]]
name = "sha1"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8621587d4798caf8eb44879d42e56b9a93ea5dcd315a6487c357130095b62801"
dependencies = [
 "libc",
 "signal-hook-registry",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
dependencies = [
 "libc",
]

[[package]]
name = "simd-adler32"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "238abfbb77c1915110ad968465608b68e869e0772622c9656714e73e5a1a522f"

[[package]]
name = "simplecss"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a11be7c62927d9427e9f40f3444d5499d868648e2edbc4e2116de69e7ec0e89d"
dependencies = [
 "log",
]

[[package]]
name = "siphasher"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7bd3e3206899af3f8b12af284fafc038cc1dc2b41d1b89dd17297221c5d225de"

[[package]]
name = "slab"
version = "0.4.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
dependencies = [
 "autocfg",
]

[[package]]
name = "slotmap"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1e08e261d0e8f5c43123b7adf3e4ca1690d655377ac93a03b2c9d3e98de1342"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0"

[[package]]
name = "smithay-client-toolkit"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f307c47d32d2715eb2e0ece5589057820e0e5e70d07c247d1063e844e107f454"
dependencies = [
 "bitflags 1.3.2",
 "calloop",
 "dlib",
 "lazy_static",
 "log",
 "memmap2",
 "nix 0.24.3",
 "pkg-config",
 "wayland-client",
 "wayland-cursor",
 "wayland-protocols",
]

[[package]]
name = "smithay-clipboard"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a345c870a1fae0b1b779085e81b51e614767c239e93503588e54c5b17f4b0e8"
dependencies = [
 "smithay-client-toolkit",
 "wayland-client",
]

[[package]]
name = "socket2"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64a4a911eed85daf18834cfaa86a79b7d266ff93ff5ba14005426219480ed662"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "str-buf"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e08d8363704e6c71fc928674353e6b7c23dcea9d82d7012c8faf2a3a025f8d0"

[[package]]
name = "strict-num"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6637bab7722d379c8b41ba849228d680cc12d0a45ba1fa2b48f2a30577a06731"
dependencies = [
 "float-cmp",
]

[[package]]
name = "svgtypes"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22975e8a2bac6a76bb54f898a6b18764633b00e780330f0b689f65afb3975564"
dependencies = [
 "siphasher",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59fb7d6d8281a51045d62b8eb3a7d1ce347b76f312af50cd3dc0af39c87c1737"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "system-deps"
version = "6.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30c2de8a4d8f4b823d634affc9cd2a74ec98c53a756f317e529a48046cbf71f3"
dependencies = [
 "cfg-expr",
 "heck",
 "pkg-config",
 "toml",
 "version-compare",
]

[[package]]
name = "target-lexicon"
version = "0.12.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b1c7f239eb94671427157bd93b3694320f3668d4e1eff08c7285366fd777fac"

[[package]]
name = "tempfile"
version = "3.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5486094ee78b2e5038a6382ed7645bc084dc2ec433426ca4c3cb61e2007b8998"
dependencies = [
 "cfg-if",
 "fastrand 2.0.0",
 "redox_syscall 0.3.5",
 "rustix 0.38.4",
 "windows-sys 0.48.0",
]

[[package]]
name = "thiserror"
version = "1.0.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c16a64ba9387ef3fdae4f9c1a7f07a0997fce91985c0336f1ddc1822b3b37802"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d14928354b01c4d6a4f0e549069adef399a284e7995c7ccca94e8a07a5346c59"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "tiff"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7449334f9ff2baf290d55d73983a7d6fa15e01198faef72af07e2a8db851e471"
dependencies = [
 "flate2",
 "jpeg-decoder",
 "weezl",
]

[[package]]
name = "tiny-skia"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df8493a203431061e901613751931f047d1971337153f96d0e5e363d6dbf6a67"
dependencies = [
 "arrayref",
 "arrayvec",
 "bytemuck",
 "cfg-if",
 "png",
 "tiny-skia-path",
]

[[package]]
name = "tiny-skia-path"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adbfb5d3f3dd57a0e11d12f4f13d4ebbbc1b5c15b7ab0a156d030b21da5f677c"
dependencies = [
 "arrayref",
 "bytemuck",
 "strict-num",
]

[[package]]
name = "tinyvec"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "toml"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ebafdf5ad1220cb59e7d17cf4d2c72015297b75b19a10472f99b89225089240"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.19.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "266f016b7f039eec8a1a80dfe6156b633d208b9fccca5e4db1d6775b0c4e34a7"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tracing"
version = "0.1.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8"
dependencies = [
 "cfg-if",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f4f31f56159e98206da9efd823404b79b6ef3143b4a7ab76e67b1751b25a4ab"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
]

[[package]]
name = "tracing-core"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
dependencies = [
 "once_cell",
]

[[package]]
name = "ttf-parser"
version = "0.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a464a4b34948a5f67fddd2b823c62d9d92e44be75058b99939eae6c5b6960b33"

[[package]]
name = "typenum"
version = "1.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"

[[package]]
name = "uds_windows"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce65604324d3cce9b966701489fbd0cf318cb1f7bd9dd07ac9a4ee6fb791930d"
dependencies = [
 "tempfile",
 "winapi",
]

[[package]]
name = "unicode-bidi"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"

[[package]]
name = "unicode-ident"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22049a19f4a68748a168c0fc439f9516686aa045927ff767eca0a85101fb6e73"

[[package]]
name = "unicode-normalization"
version = "0.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
dependencies = [
 "tinyvec",
]

[[package]]
name = "url"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50bff7831e19200a85b17131d085c25d7811bc4e186efdaf54bbd132994a88cb"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "usvg"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b5b7c2b30845b3348c067ca3d09e20cc6e327c288f0ca4c48698712abf432e9"
dependencies = [
 "base64",
 "data-url",
 "flate2",
 "imagesize",
 "kurbo",
 "log",
 "rctree",
 "roxmltree",
 "simplecss",
 "siphasher",
 "strict-num",
 "svgtypes",
]

[[package]]
name = "uuid"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79daa5ed5740825c40b389c5e50312b9c86df53fccd33f281df655642b43869d"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version-compare"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "579a42fc0b8e0c63b76519a339be31bed574929511fa53c1a3acae26eb258f29"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "waker-fn"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d5b2c62b4012a3e1eca5a7e077d13b3bf498c4073e33ccd58626607748ceeca"

[[package]]
name = "walkdir"
version = "2.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36df944cda56c7d8d8b7496af378e6b16de9284591917d307c9b4d313c44e698"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7706a72ab36d8cb1f80ffbf0e071533974a60d0a308d01a5d0375bf60499a342"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.23",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f219e0d211ba40266969f6dbdd90636da12f75bee4fc9d6c23d1260dadb51454"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dee495e55982a3bd48105a7b947fd2a9b4a8ae3010041b9e0faab3f9cd028f1d"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.23",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca6ad05a4870b2bf5fe995117d3728437bd27d7cd5f06f13c17443ef369775a1"

[[package]]
name = "wayland-client"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f3b068c05a039c9f755f881dc50f01732214f5685e379829759088967c46715"
dependencies = [
 "bitflags 1.3.2",
 "downcast-rs",
 "libc",
 "nix 0.24.3",
 "scoped-tls",
 "wayland-commons",
 "wayland-scanner",
 "wayland-sys 0.29.5",
]

[[package]]
name = "wayland-commons"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8691f134d584a33a6606d9d717b95c4fa20065605f798a3f350d78dced02a902"
dependencies = [
 "nix 0.24.3",
 "once_cell",
 "smallvec",
 "wayland-sys 0.29.5",
]

[[package]]
name = "wayland-cursor"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6865c6b66f13d6257bef1cd40cbfe8ef2f150fb8ebbdb1e8e873455931377661"
dependencies = [
 "nix 0.24.3",
 "wayland-client",
 "xcursor",
]

[[package]]
name = "wayland-protocols"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b950621f9354b322ee817a23474e479b34be96c2e909c14f7bc0100e9a970bc6"
dependencies = [
 "bitflags 1.3.2",
 "wayland-client",
 "wayland-commons",
 "wayland-scanner",
]

[[package]]
name = "wayland-scanner"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
dependencies = [
 "proc-macro2",
 "quote",
 "xml-rs",
]

[[package]]
name = "wayland-sys"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be12ce1a3c39ec7dba25594b97b42cb3195d54953ddb9d3d95a7c3902bc6e9d4"
dependencies = [
 "dlib",
 "lazy_static",
 "pkg-config",
]

[[package]]
name = "wayland-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b2a02ac608e07132978689a6f9bf4214949c85998c247abadd4f4129b1aa06"
dependencies = [
 "dlib",
 "lazy_static",
 "log",
 "pkg-config",
]

[[package]]
name = "web-sys"
version = "0.3.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e33b99f4b23ba3eec1a53ac264e35a755f00e966e0065077d6027c0f575b0b97"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webbrowser"
version = "0.8.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd222aa310eb7532e3fd427a5d7db7e44bc0b0cf1c1e21139c345325511a85b6"
dependencies = [
 "core-foundation",
 "home",
 "jni 0.21.1",
 "log",
 "ndk-context",
 "objc",
 "raw-window-handle",
 "url",
 "web-sys",
]

[[package]]
name = "weezl"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9193164d4de03a926d909d3bc7c30543cecb35400c02114792c2cae20d5e2dbb"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-wsapoll"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c17110f57155602a80dca10be03852116403c9ff3cd25b079d666f2aa3df6e"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.44.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e745dab35a0c4c77aa3ce42d595e13d2003d6902d6b08c9ef5fc326d08da12b"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-targets 0.42.2",
]

[[package]]
name = "windows"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-implement"
version = "0.44.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ce87ca8e3417b02dc2a8a22769306658670ec92d78f1bd420d6310a67c245c6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-interface"
version = "0.44.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "853f69a591ecd4f810d29f17e902d40e349fb05b0b11fff63b08b826bfe39c7f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.1",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f"
dependencies = [
 "windows_aarch64_gnullvm 0.48.0",
 "windows_aarch64_msvc 0.48.0",
 "windows_i686_gnu 0.48.0",
 "windows_i686_msvc 0.48.0",
 "windows_x86_64_gnu 0.48.0",
 "windows_x86_64_gnullvm 0.48.0",
 "windows_x86_64_msvc 0.48.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"

[[package]]
name = "winit"
version = "0.28.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "866db3f712fffba75d31bf0cdecf357c8aeafd158c5b7ab51dba2a2b2d47f196"
dependencies = [
 "android-activity",
 "bitflags 1.3.2",
 "cfg_aliases",
 "core-foundation",
 "core-graphics",
 "dispatch",
 "instant",
 "libc",
 "log",
 "mio",
 "ndk",
 "objc2",
 "once_cell",
 "orbclient",
 "percent-encoding",
 "raw-window-handle",
 "redox_syscall 0.3.5",
 "sctk-adwaita",
 "smithay-client-toolkit",
 "wasm-bindgen",
 "wayland-client",
 "wayland-commons",
 "wayland-protocols",
 "wayland-scanner",
 "web-sys",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "winnow"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca0ace3845f0d96209f0375e6d367e3eb87eb65d27d445bdc9f1843a26f39448"
dependencies = [
 "memchr",
]

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "x11rb"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "592b4883219f345e712b3209c62654ebda0bb50887f330cbd018d0f654bfd507"
dependencies = [
 "gethostname",
 "nix 0.24.3",
 "winapi",
 "winapi-wsapoll",
 "x11rb-protocol",
]

[[package]]
name = "x11rb-protocol"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56b245751c0ac9db0e006dc812031482784e434630205a93c73cfefcaabeac67"
dependencies = [
 "nix 0.24.3",
]

[[package]]
name = "xcursor"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "463705a63313cd4301184381c5e8042f0a7e9b4bb63653f216311d4ae74690b7"
dependencies = [
 "nom",
]

[[package]]
name = "xdg-home"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2769203cd13a0c6015d515be729c526d041e9cf2c0cc478d57faee85f40c6dcd"
dependencies = [
 "nix 0.26.2",
 "winapi",
]

[[package]]
name = "xml-rs"
version = "0.8.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a56c84a8ccd4258aed21c92f70c0f6dea75356b6892ae27c24139da456f9336"

[[package]]
name = "xmlparser"
version = "0.13.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d25c75bf9ea12c4040a97f829154768bbbce366287e2dc044af160cd79a13fd"

[[package]]
name = "zbus"
version = "3.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31de390a2d872e4cd04edd71b425e29853f786dc99317ed72d73d6fcf5ebb948"
dependencies = [
 "async-broadcast",
 "async-executor",
 "async-fs",
 "async-io",
 "async-lock",
 "async-process",
 "async-recursion",
 "async-task",
 "async-trait",
 "blocking",
 "byteorder",
 "derivative",
 "enumflags2",
 "event-listener",
 "futures-core",
 "futures-sink",
 "futures-util",
 "hex",
 "nix 0.26.2",
 "once_cell",
 "ordered-stream",
 "rand",
 "serde",
 "serde_repr",
 "sha1",
 "static_assertions",
 "tracing",
 "uds_windows",
 "winapi",
 "xdg-home",
 "zbus_macros",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "zbus_macros"
version = "3.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d1794a946878c0e807f55a397187c11fc7a038ba5d868e7db4f3bd7760bc9d"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "regex",
 "syn 1.0.109",
 "zvariant_utils",
]

[[package]]
name = "zbus_names"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb80bb776dbda6e23d705cf0123c3b95df99c4ebeaec6c2599d4a5419902b4a9"
dependencies = [
 "serde",
 "static_assertions",
 "zvariant",
]

[[package]]
name = "zune-inflate"
version = "0.2.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73ab332fe2f6680068f3582b16a24f90ad7096d5d39b974d1c0aff0125116f02"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "zvariant"
version = "3.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44b291bee0d960c53170780af148dca5fa260a63cdd24f1962fa82e03e53338c"
dependencies = [
 "byteorder",
 "enumflags2",
 "libc",
 "serde",
 "static_assertions",
 "zvariant_derive",
]

[[package]]
name = "zvariant_derive"
version = "3.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "934d7a7dfc310d6ee06c87ffe88ef4eca7d3e37bb251dece2ef93da8f17d8ecd"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "zvariant_utils",
]

[[package]]
name = "zvariant_utils"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7234f0d811589db492d16893e3f21e8e2fd282e6d01b0cddee310322062cc200"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

```

`Cargo.toml`:

```toml
[package]
name = "kevboy"
version = "0.3.1"
edition = "2021"
authors = ["xkevio"]

[profile.release]
strip = true
lto = "thin"
codegen-units = 1

[dependencies]
anyhow = "1.0.68"
eframe = {version = "0.22.0", features = ["persistence"] }
egui = { version = "0.22.0", features = ["serde"] }
egui-phosphor = "0.2.0"
egui_extras = { version = "0.22.0", features = ["svg"] }
gilrs = { version = "0.10.2", features = ["serde-serialize"] }
hashlink = { version = "0.8.1", features = ["serde", "serde_impl"] }
image = "0.24.5"
rfd = "0.11.4"
rodio = { version = "0.17.0", default-features = false }
serde = "1.0.152"

```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2023 Kevin K.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# WIP Game Boy & Game Boy Color Emulator

<p float="left" align="middle">
<img src="icon/crystal.png" alt="Pokemon Crystal Title Screen" width="450" />
<img src="icon/shantae.png" alt="Shantae Title Screen" width="350" />
</p>

## Installation

#### Pre-built Binaries:

Check the [`Releases`](https://github.com/xkevio/kevboy/releases) page and download an already built version of `Kevboy`.

Our CI workflow currently produces binaries for:

- Windows 64-bit (`x86_64-pc-windows-msvc`)
- Ubuntu 64-bit (`x86_64-unknown-linux-gnu`)
- Mac OS x86 (`x86_64-apple-darwin`)

#### Manual:

- Clone with `git@github.com:xkevio/kevboy.git`
- Build the project in release mode with [`cargo`](https://rustup.rs/): `cargo build --release`

## Usage

Open a ROM via `File > Open ROM`.

A boot rom is not provided, the state of the Game Boy after the boot rom finishes is emulated.

Serial (link cable) is emulated in so far that games that rely on it do work, though no emulation of actual linking between two Game Boys is implemented.

**Supported Memory Bank Controllers:**

- **MBC0**
- **MBC1**
- **MBC2**
- **MBC3** (without RTC)
- **MBC5**

## Controls:

Controls may be customized via `Options > Controls`. For manual editing (not recommended, key order needs to be preserved), settings are stored here:

- Linux: `/home/UserName/.local/share/Kevboy`
- macOS: `/Users/UserName/Library/Application Support/Kevboy`
- Windows: `C:\Users\UserName\AppData\Roaming\Kevboy`

Some keys might not be supported.

For a full list, see: https://docs.rs/egui/latest/egui/enum.Key.html

|   **Keyboard**   | **Game Boy** |
|:----------------:|:------------:|
|   <kbd>O</kbd>   |     `B`      |
|   <kbd>P</kbd>   |     `A`      |
|   <kbd>W</kbd>   |     `Up`     |
|   <kbd>A</kbd>   |    `Left`    |
|   <kbd>S</kbd>   |    `Down`    |
|   <kbd>D</kbd>   |   `Right`    |
| <kbd>Enter</kbd> |   `Start`    |
|   <kbd>Q</kbd>   |   `Shift`    |

## Passed tests:

### CPU tests:

| Test              | Status |
|-------------------|--------|
| `cpu_instrs.gb`   | ✅      |
| `mem-timing.gb`   | ✅      |
| `instr_timing.gb` | ✅      |

### PPU tests:

| Test                           | Status |
|--------------------------------|--------|
| `dmg-acid2.gb`, `cgb-acid2.gb` | ✅      |
| `sprite_priority.gb`           | ✅      |

#### Timer tests:

| Test                      | Status |
|---------------------------|---------|
| `div_write.gb`            | ✅      |
| `tim00.gb`                | ✅      |
| `tim00_div_trigger.gb`    | ✅      |
| `tim01.gb`                | ✅      |
| `tim01_div_trigger.gb`    | ✅      |
| `tim10.gb`                | ✅      |
| `tim10_div_trigger.gb`    | ✅      |
| `tim11.gb`                | ✅      |
| `tim11_div_trigger.gb`    | ✅      |
| `tima_reload.gb`          | ✅      |
| `tima_write_reloading.gb` | ✅      |
| `tma_write_reloading.gb`  | ✅      |

## TODO

- [x] Implement fast-forward feature
- [x] Gamepad support
- [x] Implement enabling and disabling individual sound channels
- [ ] More automatic saving (`mmap`)
- [ ] Implement the Real Time Clock (RTC) in MBC3

```

`icon/github-mark-white.svg`:

```svg
<svg width="98" height="96" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>
```

`icon/github-mark.svg`:

```svg
<svg width="98" height="96" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#24292f"/></svg>
```

`rustfmt.toml`:

```toml
single_line_if_else_max_width = 80
```

`src/apu/apu.rs`:

```rs
use crate::mmu::mmio::MMIO;
use rodio::{buffer::SamplesBuffer, OutputStream, OutputStreamHandle, Sink};

// WAVE DUTY CYCLES
const WAVE_DUTY_CYCLES: [[u8; 8]; 4] = [
    [0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 0],
];

/// Channel 1 produces square waves and uses both envelope and sweep
/// functionality. Uses the wave constants above to produce said signals.
struct ChannelOne {
    volume: u8,
    vol_timer: u8,

    sweep_timer: u8,

    len_counter: u8,
    duty_cycle: u8,
    freq_timer: u16,

    nr10: u8,
    nr11: u8,
    nr12: u8,
    nr13: u8,
    nr14: u8,
}

impl Default for ChannelOne {
    fn default() -> Self {
        Self {
            volume: 0,
            vol_timer: 0,

            sweep_timer: 0,

            len_counter: 0,
            duty_cycle: 0,
            freq_timer: 0,

            nr10: 0x80,
            nr11: 0xBF,
            nr12: 0xF3,
            nr13: 0xFF,
            nr14: 0xBF,
        }
    }
}

impl ChannelOne {
    /// Frequency timer ticks every T-cycle.
    pub fn duty_cycle(&mut self) {
        self.freq_timer -= 1;

        if self.freq_timer == 0 {
            let freq = ((self.nr14 & 0b111) as u16) << 8 | self.nr13 as u16;
            self.freq_timer = (2048 - freq) * 4;
            self.duty_cycle = (self.duty_cycle + 1) % 8;
        }
    }

    pub fn tick(&mut self, div_apu: u8, nr52: &mut u8) {
        if div_apu % 2 == 0 {
            if self.len_counter > 0 && self.nr14 & (1 << 6) != 0 {
                self.len_counter -= 1;

                // Turn channel off when length counter reaches zero
                if self.len_counter == 0 {
                    *nr52 &= !(1);
                }
            }
        }

        // Frequency sweep
        if div_apu % 4 == 0 {
            let sweep_pace = (self.nr10 & 0x70) >> 4;
            if sweep_pace != 0 {
                if self.sweep_timer > 0 {
                    self.sweep_timer -= 1;
                }

                if self.sweep_timer == 0 {
                    self.sweep_timer = sweep_pace;

                    let wave_length = ((self.nr14 & 0b111) as u16) << 8 | self.nr13 as u16;
                    let slope = self.nr10 & 0b111;

                    // 0 = increase, 1 = decrease
                    let new_wave_length = if self.nr10 & 0x08 == 0 {
                        wave_length + (wave_length / 2u16.pow(slope as u32))
                    } else {
                        wave_length - (wave_length / 2u16.pow(slope as u32))
                    };

                    // Turn channel off when wave length overflows 11 bit value in addition mode
                    if self.nr10 & 0x08 == 0 && new_wave_length > 0x7FF {
                        *nr52 &= !(1);
                    }

                    self.nr13 = new_wave_length as u8;
                    self.nr14 |= ((new_wave_length & 0x700) >> 8) as u8;
                }
            }
        }

        // Volume envelope
        if div_apu % 8 == 0 {
            if self.nr12 & 0b111 != 0 {
                if self.vol_timer > 0 {
                    self.vol_timer -= 1;
                }

                if self.vol_timer == 0 {
                    self.vol_timer = self.nr12 & 0b111;

                    if self.nr12 & 0x08 == 0 {
                        if self.volume > 0 {
                            self.volume -= 1
                        }
                    } else {
                        if self.volume < 0xF {
                            self.volume += 1
                        }
                    }
                }
            }
        }
    }

    /// Returns current sample of the square wave.
    ///
    /// Uses the DAC if it's on, otherwise returns zero.
    pub fn sample(&self) -> f32 {
        let sample = WAVE_DUTY_CYCLES[((self.nr11 & 0xC0) >> 6) as usize][self.duty_cycle as usize]
            * self.volume;

        if self.is_dac_on() {
            (sample as f32 / 7.5) - 1.0
        } else {
            0.0
        }
    }

    pub fn clear(&mut self) {
        self.nr10 = 0;
        self.nr11 = 0;
        self.nr12 = 0;
        self.nr13 = 0;
        self.nr14 = 0;
    }

    /// Turn channel on when setting bit 7 of NRx4 and DAC is on.
    /// Bit check is in the `write` method of APU.
    pub fn trigger(&mut self, nr52: &mut u8) {
        if self.len_counter == 0 {
            self.len_counter = 64;
        }

        self.volume = (self.nr12 & 0xF0) >> 4;
        self.vol_timer = self.nr12 & 0b111;
        self.freq_timer = self.nr12 as u16 & 0b111;
        self.sweep_timer = 0;

        // Only enable channel if DAC is on
        if self.is_dac_on() {
            *nr52 |= 1;
        }
    }

    fn is_dac_on(&self) -> bool {
        self.nr12 & 0xF8 != 0
    }
}

/// Channel 2 produces square waves and uses just the envelope functionality.
/// Uses the wave constants above to produce said signals.
struct ChannelTwo {
    volume: u8,
    vol_timer: u8,

    len_counter: u8,
    duty_cycle: u8,
    freq_timer: u16,

    nr21: u8,
    nr22: u8,
    nr23: u8,
    nr24: u8,
}

impl Default for ChannelTwo {
    fn default() -> Self {
        Self {
            volume: 0,
            vol_timer: 0,

            len_counter: 0,
            duty_cycle: 0,
            freq_timer: 0,

            nr21: 0x3F,
            nr22: 0x00,
            nr23: 0xFF,
            nr24: 0xBF,
        }
    }
}

impl ChannelTwo {
    /// Frequency timer ticks every T-cycle.
    pub fn duty_cycle(&mut self) {
        self.freq_timer -= 1;

        if self.freq_timer == 0 {
            let freq = ((self.nr24 & 0b111) as u16) << 8 | self.nr23 as u16;
            self.freq_timer = (2048 - freq) * 4;
            self.duty_cycle = (self.duty_cycle + 1) % 8;
        }
    }

    /// Ticks based on bit 4 of DIV, does length timing and volume envelope
    pub fn tick(&mut self, div_apu: u8, nr52: &mut u8) {
        // Length counter
        if div_apu % 2 == 0 {
            // Tick length counter
            if self.len_counter > 0 && self.nr24 & (1 << 6) != 0 {
                self.len_counter -= 1;

                // Turn channel off when length counter reaches zero
                if self.len_counter == 0 {
                    *nr52 &= !(1 << 1);
                }
            }
        }

        // Volume envelope
        if div_apu % 8 == 0 {
            if self.nr22 & 0b111 != 0 {
                if self.vol_timer > 0 {
                    self.vol_timer -= 1;
                }

                if self.vol_timer == 0 {
                    self.vol_timer = self.nr22 & 0b111;

                    if self.nr22 & 0x08 == 0 {
                        if self.volume > 0 {
                            self.volume -= 1
                        }
                    } else {
                        if self.volume < 0xF {
                            self.volume += 1
                        }
                    }
                }
            }
        }
    }

    /// Returns current sample of the square wave.
    ///
    /// Uses the DAC if it's on, otherwise returns zero.
    pub fn sample(&self) -> f32 {
        let sample = WAVE_DUTY_CYCLES[((self.nr21 & 0xC0) >> 6) as usize][self.duty_cycle as usize]
            * self.volume;

        if self.is_dac_on() {
            (sample as f32 / 7.5) - 1.0
        } else {
            0.0
        }
    }

    pub fn clear(&mut self) {
        self.nr21 = 0;
        self.nr22 = 0;
        self.nr23 = 0;
        self.nr24 = 0;
    }

    /// Turn channel on when setting bit 7 of NRx4 and DAC is on.
    /// Bit check is in the `write` method of APU.
    pub fn trigger(&mut self, nr52: &mut u8) {
        if self.len_counter == 0 {
            self.len_counter = 64;
        }

        self.volume = (self.nr22 & 0xF0) >> 4;
        self.vol_timer = self.nr22 & 0b111;
        self.freq_timer = self.nr22 as u16 & 0b111;

        // Only enable channel if DAC is on
        if self.is_dac_on() {
            *nr52 |= 1 << 1;
        }
    }

    fn is_dac_on(&self) -> bool {
        self.nr22 & 0xF8 != 0
    }
}

/// Channel 3 can produce custom waves from 4 bit samples based on Wave RAM.
struct ChannelThree {
    current_index: u8,
    len_counter: u16,
    freq_timer: u16,

    nr30: u8,
    nr31: u8,
    nr32: u8,
    nr33: u8,
    nr34: u8,
}

impl Default for ChannelThree {
    fn default() -> Self {
        Self {
            current_index: 0,
            len_counter: 0,
            freq_timer: 0,

            nr30: 0x7F,
            nr31: 0xFF,
            nr32: 0x9F,
            nr33: 0xFF,
            nr34: 0xBF,
        }
    }
}

impl ChannelThree {
    /// Frequency timer ticks every T-cycle.
    pub fn duty_cycle(&mut self) {
        self.freq_timer -= 1;

        if self.freq_timer == 0 {
            let freq = ((self.nr34 & 0b111) as u16) << 8 | self.nr33 as u16;
            self.freq_timer = (2048 - freq) * 2;
            self.current_index = (self.current_index + 1) % 32;
        }
    }

    pub fn tick(&mut self, div_apu: u8, nr52: &mut u8) {
        if div_apu % 2 == 0 {
            if self.len_counter > 0 && self.nr34 & (1 << 6) != 0 {
                self.len_counter -= 1;

                // Turn channel off when length counter reaches zero
                if self.len_counter == 0 {
                    *nr52 &= !(1 << 2);
                }
            }
        }
    }

    /// Returns current sample of wave RAM.
    ///
    /// Uses the DAC if it's on, otherwise returns zero.
    pub fn sample(&self, wave_ram: &[u8]) -> f32 {
        let raw_sample = if self.current_index % 2 == 0 {
            (wave_ram[(self.current_index / 2) as usize] & 0xF0) >> 4
        } else {
            wave_ram[(self.current_index / 2) as usize] & 0x0F
        };

        let sample = match (self.nr32 & 0x60) >> 5 {
            0b00 => 0,
            0b01 => raw_sample,
            0b10 => raw_sample >> 1,
            0b11 => raw_sample >> 2,
            _ => unreachable!(),
        };

        if self.is_dac_on() {
            (sample as f32 / 7.5) - 1.0
        } else {
            0.0
        }
    }

    pub fn clear(&mut self) {
        self.nr30 = 0;
        self.nr31 = 0;
        self.nr32 = 0;
        self.nr33 = 0;
        self.nr34 = 0;
    }

    /// Turn channel on when setting bit 7 of NRx4 and DAC is on.
    /// Bit check is in the `write` method of APU.
    pub fn trigger(&mut self, nr52: &mut u8) {
        if self.len_counter == 0 {
            self.len_counter = 256;
        }

        // Quirk: ch3 starts at index 1, lower nibble of first byte
        self.current_index = 1;

        // Only enable channel if DAC is on
        if self.is_dac_on() {
            *nr52 |= 1 << 2;
        }
    }

    fn is_dac_on(&self) -> bool {
        self.nr30 & (1 << 7) != 0
    }
}

/// Channel 4 can produce pseudo random noise and also uses envelope.
struct ChannelFour {
    volume: u8,
    vol_timer: u8,

    len_counter: u8,
    lfsr: u16, // technically a 15 bit register
    freq_timer: u16,

    nr41: u8,
    nr42: u8,
    nr43: u8,
    nr44: u8,
}

impl Default for ChannelFour {
    fn default() -> Self {
        Self {
            volume: 0,
            vol_timer: 0,

            len_counter: 0,
            lfsr: 0,
            freq_timer: 0,

            nr41: 0xFF,
            nr42: 0x00,
            nr43: 0x00,
            nr44: 0xBF,
        }
    }
}

impl ChannelFour {
    /// Frequency timer ticks every T-cycle.
    pub fn duty_cycle(&mut self) {
        self.freq_timer -= 1;

        if self.freq_timer == 0 {
            let base_divisor = ((self.nr43 & 0b111) * 16).max(8) as u16;
            let clock_shift = (self.nr43 & 0xF0) >> 4;

            self.freq_timer = base_divisor << clock_shift;

            let xor_bit = (self.lfsr & 1) ^ ((self.lfsr & 2) >> 1);
            self.lfsr = (self.lfsr >> 1) & !(1 << 14);
            self.lfsr |= xor_bit << 14; // set bit 14 (15 bit register)

            // set bit 6 as well if LFSR width mode is set
            if self.nr43 & 0x08 != 0 {
                self.lfsr &= !(1 << 6);
                self.lfsr |= xor_bit << 6;
            }
        }
    }

    pub fn tick(&mut self, div_apu: u8, nr52: &mut u8) {
        if div_apu % 2 == 0 {
            if self.len_counter > 0 && self.nr44 & (1 << 6) != 0 {
                self.len_counter -= 1;

                // Turn channel off when length counter reaches zero
                if self.len_counter == 0 {
                    *nr52 &= !(1 << 3);
                }
            }
        }

        // Volume envelope
        if div_apu % 8 == 0 {
            if self.nr42 & 0b111 != 0 {
                if self.vol_timer > 0 {
                    self.vol_timer -= 1;
                }

                if self.vol_timer == 0 {
                    self.vol_timer = self.nr42 & 0b111;

                    if self.nr42 & 0x08 == 0 {
                        if self.volume > 0 {
                            self.volume -= 1
                        }
                    } else {
                        if self.volume < 0xF {
                            self.volume += 1
                        }
                    }
                }
            }
        }
    }

    /// Returns current sample of the LFSR bit.
    ///
    /// Uses the DAC if it's on, otherwise returns zero.
    pub fn sample(&self) -> f32 {
        let sample = (!(self.lfsr as u8) & 1) * self.volume;

        if self.is_dac_on() {
            (sample as f32 / 7.5) - 1.0
        } else {
            0.0
        }
    }

    pub fn clear(&mut self) {
        self.nr41 = 0;
        self.nr42 = 0;
        self.nr43 = 0;
        self.nr44 = 0;
    }

    /// Turn channel on when setting bit 7 of NRx4 and DAC is on.
    /// Bit check is in the `write` method of APU.
    pub fn trigger(&mut self, nr52: &mut u8) {
        if self.len_counter == 0 {
            self.len_counter = 64;
        }

        self.lfsr = u16::MAX;
        self.volume = (self.nr42 & 0xF0) >> 4;
        self.vol_timer = self.nr42 & 0b111;

        let base_divisor = ((self.nr43 & 0b111) * 16).max(8) as u16;
        let clock_shift = (self.nr43 & 0xF0) >> 4;

        self.freq_timer = base_divisor << clock_shift;

        // Only enable channel if DAC is on
        if self.is_dac_on() {
            *nr52 |= 1 << 3;
        }
    }

    fn is_dac_on(&self) -> bool {
        self.nr42 & 0xF8 != 0
    }
}

/// The APU consists of four channels:
///
/// - **Channel 1:** Square waves (envelope + sweep)
/// - **Channel 2:** Square waves (envelope)
/// - **Channel 3:** Custom waves based on 4 bit samples in Wave RAM
/// - **Channel 4:** Noise (envelope)
///
/// Uses an internal `div_apu` timer based on bit 4 of DIV.
#[allow(clippy::upper_case_acronyms)]
pub struct APU {
    /// Wave RAM holds 16 bytes of custom 4 bit samples for channel 3
    pub wave_ram: [u8; 0x10],
    /// Track T-cycles to play sound at correct time depending on sample rate
    internal_cycles: u16,

    /// Internal counter which increases based on falling edge of DIV
    div_apu: u8,
    /// Keep previous bit to detect falling edge
    div_bit: u8,

    ch1: ChannelOne,
    ch2: ChannelTwo,
    ch3: ChannelThree,
    ch4: ChannelFour,

    /// Global settings: master volume
    nr50: u8,
    /// Global settings: panning
    nr51: u8,
    /// Global settings: On/Off switch
    nr52: u8,

    /// Buffer that holds the sound samples before being queued into the audio queue
    buffer: Vec<f32>,

    /// Queue to append samples to, never stops playing
    pub sink: Sink,
    /// Rodio frontend streams to play sound
    streams: (OutputStream, OutputStreamHandle),
    /// Fast-forward the APU
    pub speed: bool,
    /// Frontend communication for enabling/disabling individual channels
    pub ch_enable: (bool, bool, bool, bool),

    capacitor: f32,
}

impl Default for APU {
    fn default() -> Self {
        let streams = OutputStream::try_default().unwrap();
        let sink = Sink::try_new(&streams.1).unwrap();

        Self {
            wave_ram: [0xFF; 0x10],
            internal_cycles: 0,

            div_apu: 0,
            div_bit: 0,

            ch1: ChannelOne::default(),
            ch2: ChannelTwo::default(),
            ch3: ChannelThree::default(),
            ch4: ChannelFour::default(),

            nr50: 0x77,
            nr51: 0xF3,
            nr52: 0xF1,

            buffer: Vec::with_capacity(1024),

            sink,
            streams,
            speed: false,
            ch_enable: (true, true, true, true),

            capacitor: 0.0,
        }
    }
}

impl MMIO for APU {
    // Here, we mask on reads and not writes since write-only bits are very present
    // and should always read back as 1. Plus, it makes clearing easier.
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0xFF10 => self.ch1.nr10 | 0x80,
            0xFF11 => self.ch1.nr11 | 0x3F,
            0xFF12 => self.ch1.nr12,
            0xFF13 => self.ch1.nr13 | 0xFF,
            0xFF14 => self.ch1.nr14 | 0xBF,

            0xFF16 => self.ch2.nr21 | 0x3F,
            0xFF17 => self.ch2.nr22,
            0xFF18 => self.ch2.nr23 | 0xFF,
            0xFF19 => self.ch2.nr24 | 0xBF,

            0xFF1A => self.ch3.nr30 | 0x7F,
            0xFF1B => self.ch3.nr31 | 0xFF,
            0xFF1C => self.ch3.nr32 | 0x9F,
            0xFF1D => self.ch3.nr33 | 0xFF,
            0xFF1E => self.ch3.nr34 | 0xBF,

            0xFF20 => self.ch4.nr41 | 0xFF,
            0xFF21 => self.ch4.nr42,
            0xFF22 => self.ch4.nr43,
            0xFF23 => self.ch4.nr44 | 0xBF,

            0xFF24 => self.nr50,
            0xFF25 => self.nr51,
            0xFF26 => self.nr52 | 0x70,

            0xFF30..=0xFF3F => self.wave_ram[(address - 0xFF30) as usize],
            _ => 0xFF,
        }
    }

    fn write(&mut self, address: u16, value: u8) {
        // NR52 is writable even with APU turned off
        if address == 0xFF26 {
            self.nr52 = (value & (1 << 7)) | (self.nr52 & 0x70);

            // Turning the APU off clears all registers besides NR52
            if !self.is_apu_enabled() {
                self.ch1.clear();
                self.ch2.clear();
                self.ch3.clear();
                self.ch4.clear();

                self.nr50 = 0;
                self.nr51 = 0;
            }
        }

        // Wave RAM is also readable and writable no matter the APU state
        if (0xFF30..=0xFF3F).contains(&address) {
            self.wave_ram[(address - 0xFF30) as usize] = value;
        }

        // All registers are read-only when APU is turned off
        if self.is_apu_enabled() {
            match address {
                0xFF10 => self.ch1.nr10 = value,
                0xFF11 => {
                    self.ch1.len_counter = 64 - (value & 0x3F);
                    self.ch1.nr11 = value;
                }
                0xFF12 => {
                    if value & 0xF8 == 0 {
                        // Turn DAC and ch1 off
                        self.nr52 &= !(1);
                    }
                    self.ch1.nr12 = value;
                }
                0xFF13 => self.ch1.nr13 = value,
                0xFF14 => {
                    if value & (1 << 7) != 0 {
                        self.ch1.trigger(&mut self.nr52);
                    }
                    self.ch1.nr14 = value;
                }

                0xFF16 => {
                    self.ch2.len_counter = 64 - (value & 0x3F);
                    self.ch2.nr21 = value;
                }
                0xFF17 => {
                    if value & 0xF8 == 0 {
                        // Turn DAC and ch2 off
                        self.nr52 &= !(1 << 1);
                    }
                    self.ch2.volume = (value & 0xF0) >> 4;
                    self.ch2.nr22 = value;
                }
                0xFF18 => self.ch2.nr23 = value,
                0xFF19 => {
                    if value & (1 << 7) != 0 {
                        self.ch2.trigger(&mut self.nr52);
                    }
                    self.ch2.nr24 = value;
                }

                0xFF1A => {
                    if value & (1 << 7) == 0 {
                        // Turn DAC and ch3 off
                        self.nr52 &= !(1 << 2);
                    }
                    self.ch3.nr30 = value;
                }
                0xFF1B => {
                    self.ch3.len_counter = 256 - value as u16;
                    self.ch3.nr31 = value;
                }
                0xFF1C => self.ch3.nr32 = value,
                0xFF1D => self.ch3.nr33 = value,
                0xFF1E => {
                    if value & (1 << 7) != 0 {
                        self.ch3.trigger(&mut self.nr52);
                    }
                    self.ch3.nr34 = value;
                }

                0xFF20 => {
                    self.ch4.len_counter = 64 - (value & 0x3F);
                    self.ch4.nr41 = value;
                }
                0xFF21 => {
                    if value & 0xF8 == 0 {
                        // Turn DAC and ch4 off
                        self.nr52 &= !(1 << 3);
                    }
                    self.ch4.nr42 = value;
                }
                0xFF22 => self.ch4.nr43 = value,
                0xFF23 => {
                    if value & (1 << 7) != 0 {
                        self.ch4.trigger(&mut self.nr52);
                    }
                    self.ch4.nr44 = value;
                }

                0xFF24 => self.nr50 = value,
                0xFF25 => self.nr51 = value,
                _ => {}
            }
        }
    }
}

impl APU {
    #[rustfmt::skip]
    pub fn tick(&mut self, div: u8) {
        self.ch1.duty_cycle();
        self.ch2.duty_cycle();
        self.ch3.duty_cycle();
        self.ch4.duty_cycle();

        // DIV-APU is increased when bit 4 of DIV (upper byte) goes from 1 to 0. (falling edge)
        if self.is_apu_enabled() && (div & (1 << 4)) != 0x10 && self.div_bit == 1 {
            self.div_apu += 1;

            self.ch1.tick(self.div_apu, &mut self.nr52);
            self.ch2.tick(self.div_apu, &mut self.nr52);
            self.ch3.tick(self.div_apu, &mut self.nr52);
            self.ch4.tick(self.div_apu, &mut self.nr52);
        }

        // Magic number (cpu_freq / 44.1kHz or 48kHz) where cpu_freq ~ 4MHz
        while self.internal_cycles < 87 * (4 * self.speed as u16 + 1) {
            self.internal_cycles -= 87 * (4 * self.speed as u16 + 1);

            let ch1_sample = if self.is_ch1_enabled() && self.ch_enable.0 { self.ch1.sample() } else { 0.0 };
            let ch2_sample = if self.is_ch2_enabled() && self.ch_enable.1 { self.ch2.sample() } else { 0.0 };
            let ch3_sample = if self.is_ch3_enabled() && self.ch_enable.2 { self.ch3.sample(&self.wave_ram) } else { 0.0 };
            let ch4_sample = if self.is_ch4_enabled() && self.ch_enable.3 { self.ch4.sample() } else { 0.0 };

            // Sound panning via NR51
            let left_output = (self.nr51 & 0xF0) >> 4;
            let mut left_mix_sample = 0.0;

            let right_output = self.nr51 & 0x0F;
            let mut right_mix_sample = 0.0;

            for (i, sample) in [ch1_sample, ch2_sample, ch3_sample, ch4_sample]
                .iter()
                .enumerate()
            {
                left_mix_sample += if left_output & (1 << i) != 0 {
                    *sample
                } else {
                    0.0
                };

                right_mix_sample += if right_output & (1 << i) != 0 {
                    *sample
                } else {
                    0.0
                };
            }

            left_mix_sample /= 4.0;
            right_mix_sample /= 4.0;

            // Play silence when channel is disabled, otherwise mix DAC sample for left and right channel
            let left_sample = left_mix_sample.signum()
                * (left_mix_sample.abs() * ((((self.nr50 & 0x70) >> 4) as f32 + 1.0) / 8.0));
            let right_sample = right_mix_sample.signum()
                * (right_mix_sample.abs() * (((self.nr50 & 0b111) as f32 + 1.0) / 8.0));

            let ls = self.high_pass(left_sample);
            let rs = self.high_pass(right_sample);

            self.buffer.extend([ls, rs]);

            // len() of sink does not return amount of samples but amount of SamplesBuffer, hence 1 SamplesBuffer = 1024 sample
            if self.buffer.len() >= 1024 {
                while self.sink.len() > 2 {}
                self.sink.append(SamplesBuffer::new(2, 48000, self.buffer.clone()));
                self.buffer.clear();
            }
        }

        self.internal_cycles += 1;
        self.div_bit = (div & (1 << 4)) >> 4;
    }

    /// Checks if the APU is enabled by checking bit 7 of NR52.
    ///
    /// - If **on**, channels get ticked and internal values updated
    /// - If **off**, only duty cycles and internal cycles get updated
    fn is_apu_enabled(&self) -> bool {
        self.nr52 & (1 << 7) != 0
    }

    /// High-Pass filter capacitor which slowly removes DC offset.
    ///
    /// Runs after DAC conversion so that a digital volume of 0 which gets converted to -1
    /// slowly gets removed and turned back to silence.
    ///
    /// Charge factor: 0.999958^(4MHz / sample rate)
    fn high_pass(&mut self, in_sample: f32) -> f32 {
        let out = in_sample - self.capacitor;
        self.capacitor = in_sample - out * 0.996;

        out
    }

    // -------- CHANNEL STATUS --------
    fn is_ch1_enabled(&self) -> bool {
        self.nr52 & (1) != 0
    }

    fn is_ch2_enabled(&self) -> bool {
        self.nr52 & (1 << 1) != 0
    }

    fn is_ch3_enabled(&self) -> bool {
        self.nr52 & (1 << 2) != 0
    }

    fn is_ch4_enabled(&self) -> bool {
        self.nr52 & (1 << 3) != 0
    }
}

```

`src/cartridge/base_cartridge.rs`:

```rs
use crate::cartridge::mbc::mbc1::MBC1;
use crate::cartridge::mbc::mbc2::MBC2;
use crate::cartridge::mbc::mbc3::MBC3;
use crate::cartridge::mbc::mbc5::MBC5;
use crate::cartridge::mbc::no_mbc::NoMBC;
use crate::mmu::mmio::MMIO;

#[allow(clippy::upper_case_acronyms)]
#[derive(PartialEq, Eq)]
pub enum CartridgeType {
    NoMBC(NoMBC),
    MBC1(MBC1),
    MBC2(Box<MBC2>),
    MBC3(MBC3),
    MBC5(MBC5),
}

pub struct Cartridge {
    pub cartridge_type: CartridgeType,
    pub title: String,
}

impl Cartridge {
    pub fn new(cartridge_type: CartridgeType, title: &str) -> Self {
        Self {
            cartridge_type,
            title: title.to_string(),
        }
    }

    // TODO: create per_cartridge! macro to avoid repetition
    /// Loads in a `.sav` file and puts its contents
    /// into cartridge RAM
    pub fn load_sram(&mut self, save: &[u8]) {
        match &mut self.cartridge_type {
            CartridgeType::MBC1(mbc1) => {
                for (i, bank) in save.chunks(0x2000).enumerate() {
                    mbc1.external_ram[i] = bank.try_into().unwrap();
                }
            }
            CartridgeType::MBC2(mbc2) => {
                mbc2.built_in_ram = save.try_into().unwrap();
            }
            CartridgeType::MBC3(mbc3) => {
                for (i, bank) in save.chunks(0x2000).enumerate() {
                    mbc3.external_ram[i] = bank.try_into().unwrap();
                }
            }
            CartridgeType::MBC5(mbc5) => {
                for (i, bank) in save.chunks(0x2000).enumerate() {
                    mbc5.external_ram[i] = bank.try_into().unwrap();
                }
            }
            _ => {}
        }
    }

    /// Dumps all of SRAM into a Vec of bytes by joining
    /// the banks together.
    ///
    /// Returns `None` if no cartridge RAM is present.
    pub fn dump_sram(&self) -> Option<Vec<u8>> {
        match &self.cartridge_type {
            CartridgeType::MBC1(mbc1) => Some(mbc1.external_ram.concat()),
            CartridgeType::MBC2(mbc2) => Some(mbc2.built_in_ram.to_vec()),
            CartridgeType::MBC3(mbc3) => Some(mbc3.external_ram.concat()),
            CartridgeType::MBC5(mbc5) => Some(mbc5.external_ram.concat()),
            _ => None,
        }
    }
}

impl Default for Cartridge {
    fn default() -> Self {
        Self {
            cartridge_type: CartridgeType::NoMBC(NoMBC::new(&[])),
            title: String::from(""),
        }
    }
}

impl MMIO for Cartridge {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        match &mut self.cartridge_type {
            CartridgeType::NoMBC(nombc) => nombc.read(address),
            CartridgeType::MBC1(mbc1) => mbc1.read(address),
            CartridgeType::MBC2(mbc2) => mbc2.read(address),
            CartridgeType::MBC3(mbc3) => mbc3.read(address),
            CartridgeType::MBC5(mbc5) => mbc5.read(address),
        }
    }

    #[inline(always)]
    fn write(&mut self, address: u16, value: u8) {
        match &mut self.cartridge_type {
            CartridgeType::MBC1(mbc1) => mbc1.write(address, value),
            CartridgeType::MBC2(mbc2) => mbc2.write(address, value),
            CartridgeType::MBC3(mbc3) => mbc3.write(address, value),
            CartridgeType::MBC5(mbc5) => mbc5.write(address, value),
            _ => {}
        }
    }
}

```

`src/cartridge/mbc/mbc1.rs`:

```rs
use crate::mmu::mmio::MMIO;

#[derive(PartialEq, Eq)]
pub struct MBC1 {
    pub rom: Vec<u8>,
    pub external_ram: Vec<[u8; 0x2000]>,

    rom_size: usize,
    ram_size: u8,

    ram_enable: bool,
    rom_bank_number: u8,
    ram_or_upper_rom: u8,
    banking_mode: u8,
}

impl MBC1 {
    pub fn new(rom: &[u8], rom_size: usize, ram_size: u8) -> Self {
        Self {
            rom: rom.to_vec(),
            external_ram: vec![[0xFF; 0x2000]; (ram_size / 8) as usize],

            rom_size,
            ram_size,

            ram_enable: false,
            rom_bank_number: 0x01,
            ram_or_upper_rom: 0x00,
            banking_mode: 0x00,
        }
    }
}

impl MMIO for MBC1 {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0x0000..=0x3FFF => {
                if self.banking_mode == 0 || self.rom_size < 1024 {
                    self.rom[address as usize]
                } else {
                    let rom_bank = self.ram_or_upper_rom << 5;
                    let address = (rom_bank as u32 * 0x4000) + address as u32;

                    self.rom[address as usize & (self.rom.len() - 1)]
                }
            }
            0x4000..=0x7FFF => {
                let rom_bank = if self.rom_size < 1024 {
                    self.rom_bank_number
                } else {
                    (self.ram_or_upper_rom << 5) | self.rom_bank_number
                };

                let address = (rom_bank as u32 * 0x4000) + (address as u32 - 0x4000);
                self.rom[address as usize & (self.rom.len() - 1)]
            }
            0xA000..=0xBFFF => {
                if self.ram_enable && self.ram_size > 0 {
                    if self.banking_mode == 0 || self.ram_size <= 8 {
                        self.external_ram[0][address as usize - 0xA000]
                    } else {
                        self.external_ram[self.ram_or_upper_rom as usize][address as usize - 0xA000]
                    }
                } else {
                    0xFF
                }
            }
            _ => unreachable!(),
        }
    }

    #[inline(always)]
    fn write(&mut self, address: u16, value: u8) {
        match address {
            0x0000..=0x1FFF => self.ram_enable = (value & 0xF) == 0xA,
            0x2000..=0x3FFF => {
                let rom_bank = if value & 0x1F == 0 { 1 } else { value & 0x1F };
                let max_banks_bits = self.rom_size / 16;

                // check if bank number higher than number in cart and mask
                if (rom_bank as usize) >= max_banks_bits {
                    self.rom_bank_number = rom_bank & ((max_banks_bits - 1) as u8);
                } else {
                    self.rom_bank_number = rom_bank;
                }
            }
            0x4000..=0x5FFF => {
                if self.rom_size >= 1024 || self.ram_size >= 32 {
                    self.ram_or_upper_rom = value & 0x3;
                }
            }
            0x6000..=0x7FFF => {
                self.banking_mode = value & 0x1;
            }
            0xA000..=0xBFFF => {
                if self.ram_enable && self.ram_size > 0 {
                    if self.banking_mode == 0 {
                        self.external_ram[0][address as usize - 0xA000] = value;
                    } else {
                        self.external_ram[self.ram_or_upper_rom as usize]
                            [address as usize - 0xA000] = value;
                    }
                }
            }
            _ => unreachable!(),
        }
    }
}

```

`src/cartridge/mbc/mbc2.rs`:

```rs
use crate::mmu::mmio::MMIO;

#[derive(PartialEq, Eq)]
pub struct MBC2 {
    pub rom: Vec<u8>,
    pub built_in_ram: [u8; 512],

    rom_bank: u8,
    ram_enable: bool,
}

impl MBC2 {
    pub fn new(rom: &[u8]) -> Self {
        Self {
            rom: rom.to_vec(),
            built_in_ram: [0xFF; 512],

            rom_bank: 0x01,
            ram_enable: false,
        }
    }
}

impl MMIO for MBC2 {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0x0000..=0x3FFF => self.rom[address as usize],
            0x4000..=0x7FFF => {
                let address = (self.rom_bank as u32 * 0x4000) + (address as u32 - 0x4000);
                self.rom[address as usize & (self.rom.len() - 1)]
            }
            // upper 4 bits ignored but mooneye tests expects them to be open bus (1)
            0xA000..=0xA1FF => {
                if self.ram_enable {
                    0xF0 | (self.built_in_ram[(address - 0xA000) as usize] & 0xF)
                } else {
                    0xFF
                }
            }
            0xA200..=0xBFFF => {
                if self.ram_enable {
                    0xF0 | (self.built_in_ram[(address % 0x200) as usize] & 0xF)
                } else {
                    0xFF
                }
            }
            _ => unreachable!(),
        }
    }

    #[inline(always)]
    fn write(&mut self, address: u16, value: u8) {
        match address {
            0x0000..=0x3FFF => {
                let bit8 = (address & 0x100) >> 8;

                if bit8 == 0 {
                    self.ram_enable = (value & 0xF) == 0xA;
                } else {
                    let rom_bank = value & 0xF;
                    self.rom_bank = if rom_bank == 0 { 1 } else { rom_bank };
                }
            }
            0xA000..=0xA1FF => {
                if self.ram_enable {
                    self.built_in_ram[(address - 0xA000) as usize] = value & 0xF;
                }
            }
            0xA200..=0xBFFF => {
                if self.ram_enable {
                    self.built_in_ram[(address % 0x200) as usize] = value & 0xF;
                }
            }
            _ => {}
        }
    }
}

```

`src/cartridge/mbc/mbc3.rs`:

```rs
use crate::mmu::mmio::MMIO;

#[derive(PartialEq, Eq)]
pub struct MBC3 {
    pub rom: Vec<u8>,
    pub external_ram: Vec<[u8; 0x2000]>,

    rtc: RealTimeClock,

    ram_timer_enable: bool,
    rom_bank_number: u8,
    ram_bank_rtc: u8,
    latch_data: u8,
}

#[derive(Default, PartialEq, Eq)]
struct RealTimeClock {
    seconds: u8,
    minutes: u8,
    hours: u8,

    dl: u8,
    dh: u8,
}

impl MMIO for RealTimeClock {
    fn read(&mut self, address: u16) -> u8 {
        // no masking on read as we mask on write already
        match address {
            0x08 => self.seconds,
            0x09 => self.minutes,
            0x0A => self.hours,
            0x0B => self.dl,
            0x0C => self.dh,
            _ => unreachable!(),
        }
    }

    fn write(&mut self, address: u16, value: u8) {
        match address {
            0x08 => self.seconds = value & 0x3B,
            0x09 => self.minutes = value & 0x3B,
            0x0A => self.hours = value & 0x17,
            0x0B => self.dl = value,
            0x0C => self.dh = value,
            _ => unreachable!(),
        }
    }
}

impl MBC3 {
    pub fn new(rom: &[u8]) -> Self {
        MBC3 {
            rom: rom.to_vec(),
            external_ram: vec![[0xFF; 0x2000]; 4],

            rtc: RealTimeClock::default(),

            ram_timer_enable: false,
            rom_bank_number: 0x01,
            ram_bank_rtc: 0x00,
            latch_data: 0x00,
        }
    }
}

impl MMIO for MBC3 {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0x0000..=0x3FFF => self.rom[address as usize],
            0x4000..=0x7FFF => {
                let address = (self.rom_bank_number as u32) * 0x4000 + (address as u32 - 0x4000);
                self.rom[address as usize]
            }
            0xA000..=0xBFFF => {
                if self.ram_timer_enable {
                    if self.ram_bank_rtc <= 0x03 {
                        self.external_ram[(self.ram_bank_rtc & 0x03) as usize]
                            [(address - 0xA000) as usize]
                    } else if self.ram_bank_rtc >= 0x08 && self.ram_bank_rtc <= 0x0C {
                        self.rtc.read(self.ram_bank_rtc as u16)
                    } else {
                        0xFF
                    }
                } else {
                    0xFF
                }
            }
            _ => unreachable!(),
        }
    }

    #[inline(always)]
    fn write(&mut self, address: u16, value: u8) {
        match address {
            0x0000..=0x1FFF => self.ram_timer_enable = (value & 0xF) == 0xA,
            0x2000..=0x3FFF => self.rom_bank_number = value & 0x7F,
            0x4000..=0x5FFF => {
                // 0x00 - 0x03 -> RAM, 0x08 - 0x0C -> RTC
                self.ram_bank_rtc = value;
            }
            0x6000..=0x7FFF => {
                // TODO: Latch Clock Data
            }
            0xA000..=0xBFFF => {
                if self.ram_timer_enable {
                    if self.ram_bank_rtc <= 0x03 {
                        self.external_ram[(self.ram_bank_rtc & 0x03) as usize]
                            [(address - 0xA000) as usize] = value;
                    } else {
                        if self.ram_bank_rtc >= 0x08 && self.ram_bank_rtc <= 0x0C {
                            self.rtc.write(self.ram_bank_rtc as u16, value);
                        }
                    }
                }
            }
            _ => {}
        }
    }
}

```

`src/cartridge/mbc/mbc5.rs`:

```rs
use crate::mmu::mmio::MMIO;

#[derive(PartialEq, Eq)]
pub struct MBC5 {
    pub rom: Vec<u8>,
    pub external_ram: Vec<[u8; 0x2000]>,

    rom_size: usize,
    ram_size: u8,

    ram_enable: bool,
    rom_bank_number: u8,
    rom_bank_bit9: u8,
    ram_bank_number: u8,
}

impl MBC5 {
    pub fn new(rom: &[u8], rom_size: usize, ram_size: u8) -> Self {
        Self {
            rom: rom.to_vec(),
            external_ram: vec![[0xFF; 0x2000]; (ram_size / 8) as usize],

            rom_size,
            ram_size,

            ram_enable: false,
            rom_bank_number: 0x01,
            rom_bank_bit9: 0x00,
            ram_bank_number: 0x00,
        }
    }
}

impl MMIO for MBC5 {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0x0000..=0x3FFF => self.rom[address as usize],
            0x4000..=0x7FFF => {
                let rom_bank: u16 =
                    ((self.rom_bank_bit9 as u16) << 8) | (self.rom_bank_number as u16);

                let address = (rom_bank as u32 * 0x4000) + (address as u32 - 0x4000);
                self.rom[address as usize & (self.rom.len() - 1)]
            }
            0xA000..=0xBFFF => {
                if self.ram_enable {
                    let l = self.external_ram.len() - 1;
                    self.external_ram[self.ram_bank_number as usize & l][address as usize - 0xA000]
                } else {
                    0xFF
                }
            }
            _ => unreachable!(),
        }
    }

    #[inline(always)]
    fn write(&mut self, address: u16, value: u8) {
        match address {
            // 0x0A for enable, 0x00 for disable (technically any other value)
            0x0000..=0x1FFF => self.ram_enable = (value & 0xF) == 0xA,
            0x2000..=0x2FFF => self.rom_bank_number = value,
            0x3000..=0x3FFF => self.rom_bank_bit9 = value & 0x1,
            0x4000..=0x5FFF => self.ram_bank_number = value & 0x0F,
            0xA000..=0xBFFF => {
                if self.ram_enable {
                    let l = self.external_ram.len() - 1;
                    self.external_ram[self.ram_bank_number as usize & l]
                        [address as usize - 0xA000] = value;
                }
            }
            _ => {}
        }
    }
}

```

`src/cartridge/mbc/mod.rs`:

```rs
pub mod mbc1;
pub mod mbc2;
pub mod mbc3;
pub mod mbc5;
pub mod no_mbc;

```

`src/cartridge/mbc/no_mbc.rs`:

```rs
use crate::mmu::mmio::MMIO;

#[derive(PartialEq, Eq)]
pub struct NoMBC {
    pub rom: Vec<u8>,
}

impl NoMBC {
    pub fn new(rom: &[u8]) -> Self {
        Self { rom: rom.to_vec() }
    }
}

impl MMIO for NoMBC {
    #[inline(always)]
    fn read(&mut self, address: u16) -> u8 {
        if address < 0x8000 {
            self.rom[address as usize]
        } else {
            0xFF
        }
    }

    fn write(&mut self, _address: u16, _value: u8) {
        unimplemented!("MBC0 doesn't write to ROM or RAM")
    }
}

```

`src/cartridge/mod.rs`:

```rs
pub mod base_cartridge;
pub mod mbc;

```

`src/cpu/cpu.rs`:

```rs
use crate::{
    cpu::registers::{Flag, Registers, Regs},
    mmu::{bus::Bus, mmio::MMIO},
};

pub mod debug;
pub mod interrupts;
pub mod registers;

macro_rules! reg8 {
    ($self:ident, $bits:expr, $bus:ident) => {
        match $bits {
            0 => $self.registers.B,
            1 => $self.registers.C,
            2 => $self.registers.D,
            3 => $self.registers.E,
            4 => $self.registers.H,
            5 => $self.registers.L,
            6 => $bus.read($self.registers.get_hl()),
            7 => $self.registers.A,
            _ => unreachable!("Invalid register!"),
        }
    };
}

#[allow(clippy::upper_case_acronyms)]
pub struct CPU {
    pub registers: Registers,
    pub ime: bool,
    pub halt: bool,
    pub stopped: bool,

    ei: bool,
    ime_req: bool,
    halt_bug: bool,
    pub cgb: bool,
}

impl CPU {
    pub fn new() -> Self {
        Self {
            registers: Registers::new_dmg(0),
            ime: false,
            halt: false,
            stopped: false,

            ei: false,
            ime_req: false,
            halt_bug: false,
            cgb: false,
        }
    }

    // Returns m-cycles
    #[rustfmt::skip]
    pub fn tick(&mut self, bus: &mut Bus) -> u8 {
        if self.halt {
            bus.tick(1);
            return 1;
        }

        // ei() is delayed by one instruction inbetween?
        if self.ei {
            self.ime_req = true;
            self.ei = false;
        }

        if self.ime_req {
            self.ime = true;
            self.ime_req = false;
        }

        let opcode = self.fetch_operand(bus);
        if self.halt_bug {
            self.registers.PC -= 1;
            self.halt_bug = false;
        }

        if opcode == 0xCB {
            let cb_opcode = self.fetch_operand(bus);

            match cb_opcode {
                0x00 => { self.registers.B = self.rlc(self.registers.B); 2 }
                0x01 => { self.registers.C = self.rlc(self.registers.C); 2 }
                0x02 => { self.registers.D = self.rlc(self.registers.D); 2 }
                0x03 => { self.registers.E = self.rlc(self.registers.E); 2 }
                0x04 => { self.registers.H = self.rlc(self.registers.H); 2 }
                0x05 => { self.registers.L = self.rlc(self.registers.L); 2 }
                0x06 => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.rlc(hl_byte),
                    );
                    4
                }
                0x07 => { self.registers.A = self.rlc(self.registers.A); 2 }
                0x08 => { self.registers.B = self.rrc(self.registers.B); 2 }
                0x09 => { self.registers.C = self.rrc(self.registers.C); 2 }
                0x0A => { self.registers.D = self.rrc(self.registers.D); 2 }
                0x0B => { self.registers.E = self.rrc(self.registers.E); 2 }
                0x0C => { self.registers.H = self.rrc(self.registers.H); 2 }
                0x0D => { self.registers.L = self.rrc(self.registers.L); 2 }
                0x0E => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.rrc(hl_byte),
                    );
                    4
                }
                0x0F => { self.registers.A = self.rrc(self.registers.A); 2 }
                0x10 => { self.registers.B = self.rl(self.registers.B); 2 }
                0x11 => { self.registers.C = self.rl(self.registers.C); 2 }
                0x12 => { self.registers.D = self.rl(self.registers.D); 2 }
                0x13 => { self.registers.E = self.rl(self.registers.E); 2 }
                0x14 => { self.registers.H = self.rl(self.registers.H); 2 }
                0x15 => { self.registers.L = self.rl(self.registers.L); 2 }
                0x16 => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.rl(hl_byte),
                    );
                    4
                }
                0x17 => { self.registers.A = self.rl(self.registers.A); 2 }
                0x18 => { self.registers.B = self.rr(self.registers.B); 2 }
                0x19 => { self.registers.C = self.rr(self.registers.C); 2 }
                0x1A => { self.registers.D = self.rr(self.registers.D); 2 }
                0x1B => { self.registers.E = self.rr(self.registers.E); 2 }
                0x1C => { self.registers.H = self.rr(self.registers.H); 2 }
                0x1D => { self.registers.L = self.rr(self.registers.L); 2 }
                0x1E => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.rr(hl_byte),
                    );
                    4
                }
                0x1F => { self.registers.A = self.rr(self.registers.A); 2 }
                0x20 => { self.registers.B = self.sla(self.registers.B); 2 }
                0x21 => { self.registers.C = self.sla(self.registers.C); 2 }
                0x22 => { self.registers.D = self.sla(self.registers.D); 2 }
                0x23 => { self.registers.E = self.sla(self.registers.E); 2 }
                0x24 => { self.registers.H = self.sla(self.registers.H); 2 }
                0x25 => { self.registers.L = self.sla(self.registers.L); 2 }
                0x26 => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.sla(hl_byte),
                    );
                    4
                }
                0x27 => { self.registers.A = self.sla(self.registers.A); 2 }
                0x28 => { self.registers.B = self.sra(self.registers.B); 2 }
                0x29 => { self.registers.C = self.sra(self.registers.C); 2 }
                0x2A => { self.registers.D = self.sra(self.registers.D); 2 }
                0x2B => { self.registers.E = self.sra(self.registers.E); 2 }
                0x2C => { self.registers.H = self.sra(self.registers.H); 2 }
                0x2D => { self.registers.L = self.sra(self.registers.L); 2 }
                0x2E => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.sra(hl_byte),
                    );
                    4
                }
                0x2F => { self.registers.A = self.sra(self.registers.A); 2 }
                0x30 => { self.registers.B = self.swap(self.registers.B); 2 }
                0x31 => { self.registers.C = self.swap(self.registers.C); 2 }
                0x32 => { self.registers.D = self.swap(self.registers.D); 2 }
                0x33 => { self.registers.E = self.swap(self.registers.E); 2 }
                0x34 => { self.registers.H = self.swap(self.registers.H); 2 }
                0x35 => { self.registers.L = self.swap(self.registers.L); 2 }
                0x36 => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.swap(hl_byte),
                    );
                    4
                }
                0x37 => { self.registers.A = self.swap(self.registers.A); 2 }
                0x38 => { self.registers.B = self.srl(self.registers.B); 2 }
                0x39 => { self.registers.C = self.srl(self.registers.C); 2 }
                0x3A => { self.registers.D = self.srl(self.registers.D); 2 }
                0x3B => { self.registers.E = self.srl(self.registers.E); 2 }
                0x3C => { self.registers.H = self.srl(self.registers.H); 2 }
                0x3D => { self.registers.L = self.srl(self.registers.L); 2 }
                0x3E => {
                    let hl_byte = bus.read(self.registers.get_hl());
                    bus.write(
                        self.registers.get_hl(),
                        self.srl(hl_byte),
                    );
                    4
                }
                0x3F => { self.registers.A = self.srl(self.registers.A); 2 }
                0x40..=0x7F => {
                    let bit = (cb_opcode >> 3) & 0b111;
                    let reg = cb_opcode & 0b111;

                    self.bit(bit, reg8!(self, reg, bus));

                    // 3 cycles if reg == (HL)
                    if reg == 0b110 {
                        3
                    } else {
                        2
                    }
                }
                0x80..=0xBF => {
                    let bit = (cb_opcode >> 3) & 0b111;
                    let reg = cb_opcode & 0b111;

                    match reg {
                        0 => { self.registers.B = self.res(bit, self.registers.B); 2 }
                        1 => { self.registers.C = self.res(bit, self.registers.C); 2 }
                        2 => { self.registers.D = self.res(bit, self.registers.D); 2 }
                        3 => { self.registers.E = self.res(bit, self.registers.E); 2 }
                        4 => { self.registers.H = self.res(bit, self.registers.H); 2 }
                        5 => { self.registers.L = self.res(bit, self.registers.L); 2 }
                        6 => {
                            let hl_byte = bus.read(self.registers.get_hl());
                            bus.write(
                                self.registers.get_hl(),
                                self.res(bit, hl_byte)
                            );
                            4
                        }
                        7 => { self.registers.A = self.res(bit, self.registers.A); 2 }
                        _ => panic!("Invalid register!")
                    }
                }
                0xC0..=0xFF => {
                    let bit = (cb_opcode >> 3) & 0b111;
                    let reg = cb_opcode & 0b111;

                    match reg {
                        0 => { self.registers.B = self.set(bit, self.registers.B); 2 }
                        1 => { self.registers.C = self.set(bit, self.registers.C); 2 }
                        2 => { self.registers.D = self.set(bit, self.registers.D); 2 }
                        3 => { self.registers.E = self.set(bit, self.registers.E); 2 }
                        4 => { self.registers.H = self.set(bit, self.registers.H); 2 }
                        5 => { self.registers.L = self.set(bit, self.registers.L); 2 }
                        6 => {
                            let hl_byte = bus.read(self.registers.get_hl());
                            bus.write(
                                self.registers.get_hl(),
                                self.set(bit, hl_byte)
                            );
                            4
                        }
                        7 => { self.registers.A = self.set(bit, self.registers.A); 2 }
                        _ => panic!("Invalid register!")
                    }
                }
            }
        } else {
            match opcode {
                0x00 => { self.nop(); 1 }
                0x01 | 0x11 | 0x21 | 0x31 => {
                    let reg = (opcode >> 4) & 0b11;

                    let low = self.fetch_operand(bus);
                    let high = self.fetch_operand(bus);

                    match reg {
                        0 => { self.ld16(Regs::BC, low, high) }
                        1 => { self.ld16(Regs::DE, low, high) }
                        2 => { self.ld16(Regs::HL, low, high) }
                        3 => { self.ld16(Regs::SP, low, high) }
                        _ => { panic!("Invalid register!") }
                    }

                    3
                }
                0x02 | 0x12 | 0x22 | 0x32 => {
                    let reg = (opcode >> 4) & 0b11;

                    match reg {
                        0 => { self.st_a(bus, self.registers.get_bc()) }
                        1 => { self.st_a(bus, self.registers.get_de()) }
                        2 => {
                            self.st_a(bus, self.registers.get_hl());
                            self.inc16(Regs::HL);
                        }
                        3 => {
                            self.st_a(bus, self.registers.get_hl());
                            self.dec16(Regs::HL);
                        }
                        _ => { panic!("Invalid register!") }
                    }

                    2
                }
                0x03 | 0x13 | 0x23 | 0x33 => {
                    let reg = (opcode >> 4) & 0b11;

                    match reg {
                        0 => { self.inc16(Regs::BC) }
                        1 => { self.inc16(Regs::DE) }
                        2 => { self.inc16(Regs::HL) }
                        3 => { self.inc16(Regs::SP) }
                        _ => { panic!("Invalid register!") }
                    }

                    bus.tick(1);

                    2
                }
                0x04 | 0x14 | 0x24 | 0x34 | 0x0C | 0x1C | 0x2C | 0x3C => {
                    let reg = (opcode >> 3) & 0b111;

                    match reg {
                        0 => { self.registers.B = self.inc8(self.registers.B); 1 }
                        1 => { self.registers.C = self.inc8(self.registers.C); 1 }
                        2 => { self.registers.D = self.inc8(self.registers.D); 1 }
                        3 => { self.registers.E = self.inc8(self.registers.E); 1 }
                        4 => { self.registers.H = self.inc8(self.registers.H); 1 }
                        5 => { self.registers.L = self.inc8(self.registers.L); 1 }
                        6 => {
                            let hl_byte = bus.read(self.registers.get_hl());
                            bus.write(
                                self.registers.get_hl(),
                                self.inc8(hl_byte)
                            );
                            3
                        }
                        7 => { self.registers.A = self.inc8(self.registers.A); 1 }
                        _ => { panic!("Invalid register!") }
                    }
                }
                0x05 | 0x15 | 0x25 | 0x35 | 0x0D | 0x1D | 0x2D | 0x3D => {
                    let reg = (opcode >> 3) & 0b111;

                    match reg {
                        0 => { self.registers.B = self.dec8(self.registers.B); 1 }
                        1 => { self.registers.C = self.dec8(self.registers.C); 1 }
                        2 => { self.registers.D = self.dec8(self.registers.D); 1 }
                        3 => { self.registers.E = self.dec8(self.registers.E); 1 }
                        4 => { self.registers.H = self.dec8(self.registers.H); 1 }
                        5 => { self.registers.L = self.dec8(self.registers.L); 1 }
                        6 => {
                            let hl_byte = bus.read(self.registers.get_hl());
                            bus.write(
                                self.registers.get_hl(),
                                self.dec8(hl_byte)
                            );
                            3
                        }
                        7 => { self.registers.A = self.dec8(self.registers.A); 1 }
                        _ => { panic!("Invalid register!") }
                    }
                }
                0x06 | 0x16 | 0x26 | 0x36 | 0x0E | 0x1E | 0x2E | 0x3E => {
                    let reg = (opcode >> 3) & 0b111;

                    let value = self.fetch_operand(bus);
                    self.ld8(bus, reg, value);

                    // 3 cycles if LD (HL), u8
                    if reg == 6 { 3 } else { 2 }
                }
                0x07 => { self.rlca(); 1 }
                0x08 => {
                    let address = bus.read_16(self.registers.PC);
                    bus.write_16(address, self.registers.SP);

                    self.registers.PC += 2;
                    5
                }
                0x09 | 0x19 | 0x29 | 0x39 => {
                    let reg = (opcode >> 4) & 0b11;

                    match reg {
                        0 => { self.add_hl(Regs::BC) }
                        1 => { self.add_hl(Regs::DE) }
                        2 => { self.add_hl(Regs::HL) }
                        3 => { self.add_hl(Regs::SP) }
                        _ => { panic!("Invalid register!") }
                    }

                    bus.tick(1);

                    2
                }
                0x0A | 0x1A | 0x2A | 0x3A => {
                    let reg = (opcode >> 4) & 0b11;

                    match reg {
                        0 => { self.ld_a(bus.read(self.registers.get_bc())) }
                        1 => { self.ld_a(bus.read(self.registers.get_de())) }
                        2 => {
                            self.ld_a(bus.read(self.registers.get_hl()));
                            self.inc16(Regs::HL);
                        }
                        3 => {
                            self.ld_a(bus.read(self.registers.get_hl()));
                            self.dec16(Regs::HL);
                        }
                        _ => { panic!("Invalid register!") }
                    }

                    2
                }
                0x0B | 0x1B | 0x2B | 0x3B => {
                    let reg = (opcode >> 4) & 0b11;

                    match reg {
                        0 => { self.dec16(Regs::BC) }
                        1 => { self.dec16(Regs::DE) }
                        2 => { self.dec16(Regs::HL) }
                        3 => { self.dec16(Regs::SP) }
                        _ => { panic!("Invalid register!") }
                    }

                    bus.tick(1);

                    2
                }
                0x0F => { self.rrca(); 1 }
                0x10 => {
                    if self.cgb {
                        // Prepare for speed switch (bit 0 is set)
                        if bus.key1 & 1 == 1 {
                            bus.change_speed();
                        }

                        // TODO: pause for 2050 cycles?
                    }

                    bus.timer.div = 0;
                    1
                }
                0x17 => { self.rla(); 1 }
                0x18 => {
                    let value = self.fetch_operand(bus);
                    self.jr(value, bus);

                    3
                }
                0x1F => { self.rra(); 1 }
                0x20 | 0x28 | 0x30 | 0x38 => {
                    let condition = (opcode >> 3) & 0b11;
                    let value = self.fetch_operand(bus);

                    match condition {
                        0 | 1 => self.jr_flag(Flag::Zero, value, condition != 0, bus),
                        2 | 3 => self.jr_flag(Flag::Carry, value, condition != 2, bus),
                        _ => panic!("Invalid condition!")
                    }
                }
                0x27 => { self.daa(); 1 }
                0x2F => { self.cpl_a(); 1 }
                0x37 => { self.scf(); 1 }
                0x3F => { self.ccf(); 1 }
                0x40..=0x7F => {
                    let dest = (opcode >> 3) & 0b111;
                    let source = opcode & 0b111;

                    // LD (HL), (HL) doesn't exist, 0x76 is HALT
                    if dest == 6 && source == 6 {
                        self.halt(bus);
                        return 1;
                    }

                    match source {
                        0b110 => {
                            let reg8 = reg8!(self, source, bus);
                            self.ld8(bus, dest, reg8);

                            2
                        }
                        _ => {
                            let reg8 = reg8!(self, source, bus);
                            self.ld8(bus, dest, reg8);

                            // (HL)
                            if dest == 0b110 {
                                2
                            } else {
                                1
                            }
                        }
                    }
                }
                0x80..=0xBF => {
                    let reg8 = reg8!(self, opcode & 0b111, bus);
                    let cycles = if opcode & 0b111 == 0b110 { 2 } else { 1 };

                    match opcode {
                        0x80..=0x87 => { self.add_a(reg8); cycles }
                        0x88..=0x8F => { self.adc_a(reg8); cycles }
                        0x90..=0x97 => { self.sub_a(reg8); cycles }
                        0x98..=0x9F => { self.sbc_a(reg8); cycles }
                        0xA0..=0xA7 => { self.and_a(reg8); cycles }
                        0xA8..=0xAF => { self.xor_a(reg8); cycles }
                        0xB0..=0xB7 => { self.or_a(reg8); cycles }
                        0xB8..=0xBF => { self.cp_a(reg8); cycles }
                        _ => { panic!("Out of range!") }
                    }
                }
                0xC0 | 0xC8 | 0xD0 | 0xD8 => {
                    let condition = (opcode >> 3) & 0b11;
                    bus.tick(1);

                    match condition {
                        0 | 1 => self.ret_flag(bus, Flag::Zero, condition != 0),
                        2 | 3 => self.ret_flag(bus, Flag::Carry, condition != 2),
                        _ => panic!("Invalid condition!")
                    }
                }
                0xC1 => { self.pop(Regs::BC, bus); 3 }
                0xD1 => { self.pop(Regs::DE, bus); 3 }
                0xE1 => { self.pop(Regs::HL, bus); 3 }
                0xF1 => { self.pop(Regs::AF, bus); 3 }
                0xC2 | 0xCA | 0xD2 | 0xDA => {
                    let condition = (opcode >> 3) & 0b11;
                    let value = bus.read_16(self.registers.PC);

                    self.registers.PC += 2;

                    match condition {
                        0 | 1 => self.jp_flag(Flag::Zero, value, condition != 0, bus),
                        2 | 3 => self.jp_flag(Flag::Carry, value, condition != 2, bus),
                        _ => panic!("Invalid condition!")
                    }
                }
                0xC3 => {
                    self.jp(bus.read_16(self.registers.PC));
                    bus.tick(1);

                    4
                }
                0xC4 | 0xCC | 0xD4 | 0xDC => {
                    let condition = (opcode >> 3) & 0b11;
                    let value = bus.read_16(self.registers.PC);

                    self.registers.PC += 2;

                    match condition {
                        0 | 1 => self.call_flag(bus, Flag::Zero, value, condition != 0),
                        2 | 3 => self.call_flag(bus, Flag::Carry, value, condition != 2),
                        _ => panic!("Invalid condition!")
                    }
                }
                0xC5 => { self.push(Regs::BC, bus); 4 }
                0xD5 => { self.push(Regs::DE, bus); 4 }
                0xE5 => { self.push(Regs::HL, bus); 4 }
                0xF5 => { self.push(Regs::AF, bus); 4 }
                0xC6 | 0xCE | 0xD6 | 0xDE | 0xE6 | 0xEE | 0xF6 | 0xFE => {
                    let value = self.fetch_operand(bus);

                    match opcode {
                        0xC6 => self.add_a(value),
                        0xCE => self.adc_a(value),
                        0xD6 => self.sub_a(value),
                        0xDE => self.sbc_a(value),
                        0xE6 => self.and_a(value),
                        0xEE => self.xor_a(value),
                        0xF6 => self.or_a(value),
                        0xFE => self.cp_a(value),
                        _ => panic!("Invalid instruction!")
                    }

                    2
                }
                0xC7 | 0xD7 | 0xE7 | 0xF7 | 0xCF | 0xDF | 0xEF | 0xFF => {
                    let rst_vec = opcode & 0b00111000;
                    self.rst(bus, rst_vec);

                    4
                }
                0xC9 => { self.ret(bus); 4 }
                0xCD => {
                    let address = bus.read_16(self.registers.PC);

                    self.registers.PC += 2;
                    self.call(bus, address);

                    6
                }
                0xD9 => { self.reti(bus); 4 }
                0xE0 => {
                    let address = 0xFF00 + (self.fetch_operand(bus) as u16);
                    bus.write(address, self.registers.A);

                    3
                }
                0xF0 => {
                    let address = 0xFF00 + (self.fetch_operand(bus) as u16);
                    self.registers.A = bus.read(address);

                    3
                }
                0xE2 => {
                    let address = 0xFF00 + (self.registers.C as u16);
                    bus.write(address, self.registers.A);

                    2
                }
                0xF2 => {
                    let address = 0xFF00 + (self.registers.C as u16);
                    self.registers.A = bus.read(address);

                    2
                }
                0xF3 => { self.di(); 1 }
                0xFB => { self.ei(); 1 }
                0xE8 => {
                    // wrapping_add, adding unsigned to signed
                    let value = self.fetch_operand(bus);
                    self.add_sp(value);
                    bus.tick(1);
                    bus.tick(1);

                    4
                }
                0xE9 => { self.jp_hl(); 1 }
                0xEA => {
                    let address = bus.read_16(self.registers.PC);
                    bus.write(address, self.registers.A);

                    self.registers.PC += 2;

                    4
                }
                0xFA => {
                    let address = bus.read_16(self.registers.PC);
                    self.registers.A = bus.read(address);

                    self.registers.PC += 2;

                    4
                }
                0xF8 => {
                    let old_sp = self.registers.SP;
                    let value = self.fetch_operand(bus);

                    self.add_sp(value);

                    self.registers.set_hl(self.registers.SP);
                    self.registers.SP = old_sp;

                    bus.tick(1);

                    3
                }
                0xF9 => { self.registers.SP = self.registers.get_hl(); bus.tick(1); 2 }
                _ => { panic!("Illegal or invalid opcode: {:#04X}", opcode) }
            }
        }

    }

    /// Calls the interrupt service routine between every instruction if necessary
    pub fn handle_interrupts(&mut self, bus: &mut Bus) -> bool {
        if self.ime {
            for interrupt in bus
                .interrupt_handler
                .get_enabled_interrupts()
                .into_iter()
                .flatten()
            {
                if bus.interrupt_handler.is_interrupt_requested(interrupt) {
                    bus.interrupt_handler.reset_if(interrupt);
                    self.ime = false;
                    self.halt = false;

                    bus.tick(2); // 2 nop delay
                    self.call(bus, interrupt as u16);

                    return true;
                }
            }
        } else {
            if bus.interrupt_handler.inte & bus.interrupt_handler.intf & 0x1F != 0 {
                self.halt = false;
            }
        }

        false
    }

    // ------------------------------
    // opcode handling
    // ------------------------------

    /// Read next operand at PC and increase PC after.
    fn fetch_operand(&mut self, bus: &mut Bus) -> u8 {
        let operand = bus.read(self.registers.PC);
        self.registers.PC += 1;

        operand
    }

    fn rlc(&mut self, reg8: u8) -> u8 {
        self.registers.set_flag(Flag::Carry, reg8 & (1 << 7) != 0);

        let reg8 = reg8.rotate_left(1);

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn rrc(&mut self, reg8: u8) -> u8 {
        self.registers.set_flag(Flag::Carry, reg8 & 0b1 != 0);

        let reg8 = reg8.rotate_right(1);

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn rl(&mut self, reg8: u8) -> u8 {
        let bit7 = reg8 & (1 << 7);
        let mut reg8 = reg8 << 1;

        if self.registers.get_flag(Flag::Carry) {
            reg8 |= 1;
        } else {
            reg8 &= !(1);
        }

        self.registers.set_flag(Flag::Carry, bit7 != 0);
        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn rr(&mut self, reg8: u8) -> u8 {
        let bit0 = reg8 & 0b1;
        let mut reg8 = reg8 >> 1;

        if self.registers.get_flag(Flag::Carry) {
            reg8 |= 1 << 7;
        } else {
            reg8 &= !(1 << 7);
        }

        self.registers.set_flag(Flag::Carry, bit0 != 0);
        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn sla(&mut self, reg8: u8) -> u8 {
        self.registers.set_flag(Flag::Carry, reg8 & (1 << 7) != 0);

        let mut reg8 = reg8 << 1;
        reg8 &= !(1);

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn sra(&mut self, reg8: u8) -> u8 {
        self.registers.set_flag(Flag::Carry, reg8 & 0b1 != 0);

        let bit7 = reg8 & (1 << 7);
        let reg8 = if bit7 == 0 { reg8 >> 1 } else { (reg8 >> 1) | (1 << 7) };

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn swap(&mut self, reg8: u8) -> u8 {
        let higher_four_bits = reg8 & 0xF0;
        let reg8 = (reg8 << 4) | (higher_four_bits >> 4);

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
        self.registers.set_flag(Flag::Carry, false);

        reg8
    }

    fn srl(&mut self, reg8: u8) -> u8 {
        self.registers.set_flag(Flag::Carry, reg8 & 0b1 != 0);

        let mut reg8 = reg8 >> 1;
        reg8 &= !(1 << 7);

        self.registers.set_flag(Flag::Zero, reg8 == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);

        reg8
    }

    fn bit(&mut self, bit: u8, reg8: u8) {
        let reg_bit = (reg8 & (1 << bit)) >> bit;

        self.registers.set_flag(Flag::Zero, reg_bit == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, true);
    }

    #[inline(always)]
    fn res(&mut self, bit: u8, reg8: u8) -> u8 {
        reg8 & !(1 << bit)
    }

    #[inline(always)]
    fn set(&mut self, bit: u8, reg8: u8) -> u8 {
        reg8 | 1 << bit
    }

    fn ld8(&mut self, bus: &mut Bus, reg8_code: u8, value: u8) {
        match reg8_code {
            0 => self.registers.B = value,
            1 => self.registers.C = value,
            2 => self.registers.D = value,
            3 => self.registers.E = value,
            4 => self.registers.H = value,
            5 => self.registers.L = value,
            6 => bus.write(self.registers.get_hl(), value),
            7 => self.registers.A = value,
            _ => panic!("Invalid register!"),
        }
    }

    fn ld_a(&mut self, value: u8) {
        self.registers.A = value;
    }

    fn st_a(&mut self, bus: &mut Bus, value: u16) {
        bus.write(value, self.registers.A);
    }

    fn add_sp(&mut self, value: u8) {
        let signed_operand = -(value.wrapping_neg() as i8);

        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(
                self.registers.SP,
                signed_operand as u16,
                0xF,
                u16::wrapping_add,
            ),
        );

        self.registers.set_flag(
            Flag::Carry,
            self.hc(
                self.registers.SP,
                signed_operand as u16,
                0xFF,
                u16::wrapping_add,
            ),
        );

        self.registers.SP += signed_operand as u16;

        self.registers.set_flag(Flag::Zero, false);
        self.registers.set_flag(Flag::Substraction, false);
    }

    /// Load 2 bytes of data into `reg16`.
    ///
    /// `low` is the first byte of immediate data
    ///
    /// `high` is the second byte of immediate data
    fn ld16(&mut self, reg16: Regs, low: u8, high: u8) {
        match reg16 {
            Regs::BC => {
                self.registers.C = low;
                self.registers.B = high;
            }
            Regs::DE => {
                self.registers.E = low;
                self.registers.D = high;
            }
            Regs::HL => {
                self.registers.L = low;
                self.registers.H = high;
            }
            Regs::SP => {
                self.registers.SP = (high as u16) << 8 | low as u16;
            }
            _ => {}
        }
    }

    fn inc8(&mut self, value: u8) -> u8 {
        let value = value + 1;

        self.registers.set_flag(Flag::Zero, value == 0);
        self.registers.set_flag(Flag::Substraction, false);

        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(value - 1, 1, 0xF, u8::wrapping_add),
        );

        value
    }

    fn dec8(&mut self, value: u8) -> u8 {
        let value = value - 1;

        self.registers.set_flag(Flag::Zero, value == 0);
        self.registers.set_flag(Flag::Substraction, true);

        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(value + 1, 1, 0xF, u8::wrapping_sub),
        );

        value
    }

    fn inc16(&mut self, reg16: Regs) {
        match reg16 {
            Regs::BC => self.registers.set_bc(self.registers.get_bc() + 1),
            Regs::DE => self.registers.set_de(self.registers.get_de() + 1),
            Regs::HL => self.registers.set_hl(self.registers.get_hl() + 1),
            Regs::SP => self.registers.SP += 1,
            _ => {}
        }
    }

    fn dec16(&mut self, reg16: Regs) {
        match reg16 {
            Regs::BC => self.registers.set_bc(self.registers.get_bc() - 1),
            Regs::DE => self.registers.set_de(self.registers.get_de() - 1),
            Regs::HL => self.registers.set_hl(self.registers.get_hl() - 1),
            Regs::SP => self.registers.SP -= 1,
            _ => {}
        }
    }

    fn add_hl(&mut self, reg16: Regs) {
        let carry: bool;
        let half_carry: bool;

        match reg16 {
            Regs::BC => {
                half_carry = self.hc(
                    self.registers.get_hl(),
                    self.registers.get_bc(),
                    0xFFF,
                    u16::wrapping_add,
                );

                let (result, cy) = self
                    .registers
                    .get_hl()
                    .overflowing_add(self.registers.get_bc());
                self.registers.set_hl(result);

                carry = cy;
            }
            Regs::DE => {
                half_carry = self.hc(
                    self.registers.get_hl(),
                    self.registers.get_de(),
                    0xFFF,
                    u16::wrapping_add,
                );

                let (result, cy) = self
                    .registers
                    .get_hl()
                    .overflowing_add(self.registers.get_de());
                self.registers.set_hl(result);

                carry = cy;
            }
            Regs::HL => {
                half_carry = self.hc(
                    self.registers.get_hl(),
                    self.registers.get_hl(),
                    0xFFF,
                    u16::wrapping_add,
                );

                let (result, cy) = self
                    .registers
                    .get_hl()
                    .overflowing_add(self.registers.get_hl());
                self.registers.set_hl(result);

                carry = cy;
            }
            Regs::SP => {
                half_carry = self.hc(
                    self.registers.get_hl(),
                    self.registers.SP,
                    0xFFF,
                    u16::wrapping_add,
                );

                let (result, cy) = self.registers.get_hl().overflowing_add(self.registers.SP);
                self.registers.set_hl(result);

                carry = cy;
            }
            _ => {
                carry = false;
                half_carry = false;
            }
        }

        self.registers.set_flag(Flag::Carry, carry);
        self.registers.set_flag(Flag::HalfCarry, half_carry);
        self.registers.set_flag(Flag::Substraction, false);
    }

    fn add_a(&mut self, value: u8) {
        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(self.registers.A, value, 0xF, u8::wrapping_add),
        );

        let (result, carry) = self.registers.A.overflowing_add(value);
        self.registers.A = result;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Carry, carry);
        self.registers.set_flag(Flag::Substraction, false);
    }

    fn adc_a(&mut self, value: u8) {
        let carry_bit = self.registers.get_flag(Flag::Carry) as u8;

        self.registers.set_flag(
            Flag::HalfCarry,
            ((self.registers.A & 0xF) + (value & 0xF) + carry_bit) & 0x10 == 0x10,
        );

        let (intermediate_result, c1) = self.registers.A.overflowing_add(value);
        let (result, c2) = intermediate_result.overflowing_add(carry_bit);

        self.registers.A = result;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Carry, c1 || c2);
        self.registers.set_flag(Flag::Substraction, false);
    }

    fn sub_a(&mut self, value: u8) {
        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(self.registers.A, value, 0xF, u8::wrapping_sub),
        );

        let (result, carry) = self.registers.A.overflowing_sub(value);
        self.registers.A = result;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Carry, carry);
        self.registers.set_flag(Flag::Substraction, true);
    }

    fn sbc_a(&mut self, value: u8) {
        let carry_bit = self.registers.get_flag(Flag::Carry) as u8;

        self.registers.set_flag(
            Flag::HalfCarry,
            ((self.registers.A & 0xF) - (value & 0xF) - carry_bit) & 0x10 == 0x10,
        );

        let (intermediate_result, c1) = self.registers.A.overflowing_sub(value);
        let (result, c2) = intermediate_result.overflowing_sub(carry_bit);

        self.registers.A = result;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Carry, c1 || c2);
        self.registers.set_flag(Flag::Substraction, true);
    }

    fn and_a(&mut self, value: u8) {
        self.registers.A &= value;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, true);
        self.registers.set_flag(Flag::Carry, false);
    }

    fn xor_a(&mut self, value: u8) {
        self.registers.A ^= value;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
        self.registers.set_flag(Flag::Carry, false);
    }

    fn or_a(&mut self, value: u8) {
        self.registers.A |= value;

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
        self.registers.set_flag(Flag::Carry, false);
    }

    fn cp_a(&mut self, value: u8) {
        self.registers.set_flag(
            Flag::HalfCarry,
            self.hc(self.registers.A, value, 0xF, u8::wrapping_sub),
        );

        let (result, carry) = self.registers.A.overflowing_sub(value);

        // A and value are equal
        self.registers.set_flag(Flag::Zero, result == 0);
        self.registers.set_flag(Flag::Carry, carry);
        self.registers.set_flag(Flag::Substraction, true);
    }

    fn cpl_a(&mut self) {
        self.registers.A = !self.registers.A;
        self.registers.set_flag(Flag::Substraction, true);
        self.registers.set_flag(Flag::HalfCarry, true);
    }

    fn ccf(&mut self) {
        self.registers.F ^= 1 << 4;
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    fn scf(&mut self) {
        self.registers.set_flag(Flag::Carry, true);

        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    fn jr(&mut self, value: u8, bus: &mut Bus) {
        let value = -(value.wrapping_neg() as i8);
        self.registers.PC = self.registers.PC.wrapping_add(value as u16);

        bus.tick(1);
    }

    fn jp_hl(&mut self) {
        self.registers.PC = self.registers.get_hl();
    }

    fn nop(&mut self) {
        // self.registers.PC += 1;
    }

    fn rlca(&mut self) {
        self.registers
            .set_flag(Flag::Carry, self.registers.A & (1 << 7) != 0);

        self.registers.A = self.registers.A.rotate_left(1);

        self.registers.set_flag(Flag::Zero, false);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    fn rla(&mut self) {
        let bit7 = self.registers.A & (1 << 7);
        self.registers.A <<= 1;

        if self.registers.get_flag(Flag::Carry) {
            self.registers.A |= 1;
        } else {
            self.registers.A &= !(1);
        }

        self.registers.set_flag(Flag::Carry, bit7 != 0);
        self.registers.set_flag(Flag::Zero, false);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    /// Only for `Zero` and `Carry` flag.
    ///
    /// Maps to `jr nz`, `jr nc`, `jr z` and `jr c`.  
    ///
    /// Returns the m-cycles it took depending on the condition
    fn jr_flag(&mut self, flag: Flag, value: u8, condition: bool, bus: &mut Bus) -> u8 {
        if self.registers.get_flag(flag) == condition {
            self.jr(value, bus);
            return 3;
        }

        2
    }

    fn rrca(&mut self) {
        self.registers
            .set_flag(Flag::Carry, self.registers.A & 0b1 != 0);

        self.registers.A = self.registers.A.rotate_right(1);

        self.registers.set_flag(Flag::Zero, false);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    fn rra(&mut self) {
        let bit0 = self.registers.A & 0b1;
        self.registers.A >>= 1;

        if self.registers.get_flag(Flag::Carry) {
            self.registers.A |= 1 << 7;
        } else {
            self.registers.A &= !(1 << 7);
        }

        self.registers.set_flag(Flag::Carry, bit0 != 0);
        self.registers.set_flag(Flag::Zero, false);
        self.registers.set_flag(Flag::Substraction, false);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    /// Turn register A into a binary-coded decimal (BCD)
    ///
    /// https://forums.nesdev.org/viewtopic.php?t=15944
    fn daa(&mut self) {
        if self.registers.get_flag(Flag::Substraction) {
            if self.registers.get_flag(Flag::Carry) {
                self.registers.A -= 0x60;
            }
            if self.registers.get_flag(Flag::HalfCarry) {
                self.registers.A -= 0x6;
            }
        } else {
            if self.registers.get_flag(Flag::Carry) || self.registers.A > 0x99 {
                self.registers.A += 0x60;
                self.registers.set_flag(Flag::Carry, true);
            }
            if self.registers.get_flag(Flag::HalfCarry) || (self.registers.A & 0x0F) > 0x09 {
                self.registers.A += 0x6;
            }
        }

        self.registers.set_flag(Flag::Zero, self.registers.A == 0);
        self.registers.set_flag(Flag::HalfCarry, false);
    }

    fn jp(&mut self, value: u16) {
        self.registers.PC = value;
    }

    /// `value` is a 16 bit immediate operand.
    /// Second byte (after opcode) is the lower byte, third is higher byte.
    fn jp_flag(&mut self, flag: Flag, value: u16, condition: bool, bus: &mut Bus) -> u8 {
        if self.registers.get_flag(flag) == condition {
            self.registers.PC = value;
            bus.tick(1);

            return 4;
        }

        3
    }

    fn pop(&mut self, reg16: Regs, bus: &mut Bus) {
        match reg16 {
            Regs::BC => {
                self.registers.C = bus.read(self.registers.SP);
                self.registers.SP += 1;
                self.registers.B = bus.read(self.registers.SP);
            }
            Regs::DE => {
                self.registers.E = bus.read(self.registers.SP);
                self.registers.SP += 1;
                self.registers.D = bus.read(self.registers.SP);
            }
            Regs::HL => {
                self.registers.L = bus.read(self.registers.SP);
                self.registers.SP += 1;
                self.registers.H = bus.read(self.registers.SP);
            }
            Regs::AF => {
                self.registers.F = bus.read(self.registers.SP);
                self.registers.SP += 1;
                self.registers.A = bus.read(self.registers.SP);

                // clear out lower nibble since it should always be zero
                self.registers.F &= !(0xF);
            }
            _ => {}
        }

        self.registers.SP += 1;
    }

    fn push(&mut self, reg16: Regs, bus: &mut Bus) {
        bus.tick(1);

        match reg16 {
            Regs::BC => {
                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.B);

                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.C);
            }
            Regs::DE => {
                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.D);

                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.E);
            }
            Regs::HL => {
                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.H);

                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.L);
            }
            Regs::AF => {
                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.A);

                self.registers.SP -= 1;
                bus.write(self.registers.SP, self.registers.F);
            }
            _ => {}
        }
    }

    fn call(&mut self, bus: &mut Bus, value: u16) {
        bus.tick(1);

        self.registers.SP -= 1;
        bus.write(self.registers.SP, ((self.registers.PC) >> 8) as u8);
        self.registers.SP -= 1;
        bus.write(self.registers.SP, self.registers.PC as u8);

        self.registers.PC = value;
    }

    fn call_flag(&mut self, bus: &mut Bus, flag: Flag, value: u16, condition: bool) -> u8 {
        if self.registers.get_flag(flag) == condition {
            self.call(bus, value);
            return 6;
        }

        3
    }

    fn ei(&mut self) {
        self.ei = true;
    }

    fn di(&mut self) {
        self.ime = false;
    }

    fn ret(&mut self, bus: &mut Bus) {
        let lower_byte = bus.read(self.registers.SP);
        let higher_byte = bus.read(self.registers.SP + 1);

        self.registers.PC = (higher_byte as u16) << 8 | lower_byte as u16;
        self.registers.SP += 2;

        bus.tick(1);
    }

    fn ret_flag(&mut self, bus: &mut Bus, flag: Flag, condition: bool) -> u8 {
        if self.registers.get_flag(flag) == condition {
            self.ret(bus);
            return 5;
        }

        2
    }

    fn reti(&mut self, bus: &mut Bus) {
        self.ime = true;
        self.ret(bus);
    }

    fn rst(&mut self, bus: &mut Bus, value: u8) {
        self.call(bus, value as u16);
    }

    fn halt(&mut self, bus: &Bus) {
        let ie = bus.interrupt_handler.inte;
        let if_flag = bus.interrupt_handler.intf;

        if self.ime {
            if ie & if_flag & 0x1F == 0 {
                self.halt = true;
            }
        } else if ie & if_flag & 0x1F == 0 {
            self.halt = true;
        } else {
            self.halt_bug = true;
        }
    }

    // ---------------------------
    // half-carry shenanigans
    // ---------------------------

    /// https://robdor.com/2016/08/10/gameboy-emulator-half-carry-flag/
    ///
    /// `F` should really **only** be `std::ops::Add:add` or `std::ops::Sub::sub` or the wrapping variants.
    fn hc<T, F>(&self, a: T, b: T, pos: T, op: F) -> bool
    where
        T: std::ops::BitAnd<Output = T> + Eq + std::ops::Add<Output = T> + TryFrom<u16> + Copy,
        F: Fn(T, T) -> T,
    {
        op(a & pos, b & pos) & (pos + T::try_from(1).unwrap_or_else(|_| unreachable!()))
            == pos + T::try_from(1).unwrap_or_else(|_| unreachable!())
    }
}

```

`src/cpu/debug/mod.rs`:

```rs
pub mod opcode;

```

`src/cpu/debug/opcode.rs`:

```rs
#[rustfmt::skip]
pub const INSTRUCTIONS: [OpCode; 256] = [
    OpCode {name: "NOP", op_code: 0x00, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD BC, u16", op_code: 0x01, bytes: 3, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (BC), A", op_code: 0x02, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC BC", op_code: 0x03, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC B", op_code: 0x04, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC BC", op_code: 0x05, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, u8", op_code: 0x06, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLCA", op_code: 0x07, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (a16), SP", op_code: 0x08, bytes: 3, m_cycles: 5, t_cycles: 20},
    OpCode {name: "ADD HL, BC", op_code: 0x09, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, (BC)", op_code: 0x0A, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DEC BC", op_code: 0x0B, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC C", op_code: 0x0C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC C", op_code: 0x0D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, u8", op_code: 0x0E, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRCA", op_code: 0x0F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "STOP", op_code: 0x10, bytes: 2, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD DE, u16", op_code: 0x11, bytes: 3, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (DE), A", op_code: 0x12, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC DE", op_code: 0x13, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC D", op_code: 0x14, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC D", op_code: 0x15, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, u8", op_code: 0x16, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLA", op_code: 0x17, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JR s8", op_code: 0x18, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "ADD HL, DE", op_code: 0x19, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, (DE)", op_code: 0x1A, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DEC DE", op_code: 0x1B, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC E", op_code: 0x1C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC E", op_code: 0x1D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, u8", op_code: 0x1E, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRA", op_code: 0x1F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JR NZ, s8", op_code: 0x20, bytes: 2, m_cycles: 3, t_cycles: 12}, // TODO
    OpCode {name: "LD HL, u16", op_code: 0x21, bytes: 3, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (HL+), A", op_code: 0x22, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC HL", op_code: 0x23, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC H", op_code: 0x24, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC H", op_code: 0x25, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, u8", op_code: 0x26, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DAA", op_code: 0x27, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JR Z, s8", op_code: 0x28, bytes: 2, m_cycles: 3, t_cycles: 12}, // TODO
    OpCode {name: "ADD HL, HL", op_code: 0x29, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, (HL+)", op_code: 0x2A, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DEC HL", op_code: 0x2B, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC L", op_code: 0x2C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC L", op_code: 0x2D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, u8", op_code: 0x2E, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "CPL", op_code: 0x2F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JR NC, s8", op_code: 0x30, bytes: 2, m_cycles: 3, t_cycles: 12}, // TODO
    OpCode {name: "LD SP, u16", op_code: 0x31, bytes: 3, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (HL-), A", op_code: 0x32, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC SP", op_code: 0x33, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC (HL)", op_code: 0x34, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "DEC (HL)", op_code: 0x35, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (HL), u8", op_code: 0x36, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "SCF", op_code: 0x37, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JR C, s8", op_code: 0x38, bytes: 2, m_cycles: 3, t_cycles: 12}, // TODO
    OpCode {name: "ADD HL, SP", op_code: 0x39, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, (HL-)", op_code: 0x3A, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DEC SP", op_code: 0x3B, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "INC A", op_code: 0x3C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "DEC A", op_code: 0x3D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, u8", op_code: 0x3E, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "CCF", op_code: 0x3F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, B", op_code: 0x40, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, C", op_code: 0x41, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, D", op_code: 0x42, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, E", op_code: 0x43, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, H", op_code: 0x44, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, L", op_code: 0x45, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD B, (HL)", op_code: 0x46, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD B, A", op_code: 0x47, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, B", op_code: 0x48, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, C", op_code: 0x49, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, D", op_code: 0x4A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, E", op_code: 0x4B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, H", op_code: 0x4C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, L", op_code: 0x4D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD C, (HL)", op_code: 0x4E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD C, A", op_code: 0x4F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, B", op_code: 0x50, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, C", op_code: 0x51, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, D", op_code: 0x52, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, E", op_code: 0x53, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, H", op_code: 0x54, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, L", op_code: 0x55, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD D, (HL)", op_code: 0x56, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD D, A", op_code: 0x57, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, B", op_code: 0x58, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, C", op_code: 0x59, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, D", op_code: 0x5A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, E", op_code: 0x5B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, H", op_code: 0x5C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, L", op_code: 0x5D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD E, (HL)", op_code: 0x5E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD E, A", op_code: 0x5F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, B", op_code: 0x60, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, C", op_code: 0x61, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, D", op_code: 0x62, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, E", op_code: 0x63, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, H", op_code: 0x64, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, L", op_code: 0x65, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD H, (HL)", op_code: 0x66, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD H, A", op_code: 0x67, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, B", op_code: 0x68, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, C", op_code: 0x69, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, D", op_code: 0x6A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, E", op_code: 0x6B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, H", op_code: 0x6C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, L", op_code: 0x6D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD L, (HL)", op_code: 0x6E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD L, A", op_code: 0x6F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), B", op_code: 0x70, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), C", op_code: 0x71, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), D", op_code: 0x72, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), E", op_code: 0x73, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), H", op_code: 0x74, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), L", op_code: 0x75, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "HALT", op_code: 0x76, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (HL), A", op_code: 0x77, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, B", op_code: 0x78, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, C", op_code: 0x79, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, D", op_code: 0x7A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, E", op_code: 0x7B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, H", op_code: 0x7C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, L", op_code: 0x7D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD A, (HL)", op_code: 0x7E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, A", op_code: 0x7F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, B", op_code: 0x80, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, C", op_code: 0x81, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, D", op_code: 0x82, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, E", op_code: 0x83, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, H", op_code: 0x84, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, L", op_code: 0x85, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADD A, (HL)", op_code: 0x86, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "ADD A, A", op_code: 0x87, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, B", op_code: 0x88, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, C", op_code: 0x89, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, D", op_code: 0x8A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, E", op_code: 0x8B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, H", op_code: 0x8C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, L", op_code: 0x8D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ADC A, (HL)", op_code: 0x8E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "ADC A, A", op_code: 0x8F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB B", op_code: 0x90, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB C", op_code: 0x91, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB D", op_code: 0x92, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB E", op_code: 0x93, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB H", op_code: 0x94, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB L", op_code: 0x95, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SUB (HL)", op_code: 0x96, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SUB A", op_code: 0x97, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, B", op_code: 0x98, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, C", op_code: 0x99, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, D", op_code: 0x9A, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, E", op_code: 0x9B, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, H", op_code: 0x9C, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, L", op_code: 0x9D, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, (HL)", op_code: 0x9E, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SBC A, A", op_code: 0x9F, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND B", op_code: 0xA0, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND C", op_code: 0xA1, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND D", op_code: 0xA2, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND E", op_code: 0xA3, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND H", op_code: 0xA4, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND L", op_code: 0xA5, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "AND (HL)", op_code: 0xA6, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "AND A", op_code: 0xA7, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR B", op_code: 0xA8, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR C", op_code: 0xA9, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR D", op_code: 0xAA, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR E", op_code: 0xAB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR H", op_code: 0xAC, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR L", op_code: 0xAD, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR (HL)", op_code: 0xAE, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "XOR A", op_code: 0xAF, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR B", op_code: 0xB0, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR C", op_code: 0xB1, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR D", op_code: 0xB2, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR E", op_code: 0xB3, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR H", op_code: 0xB4, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR L", op_code: 0xB5, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "OR (HL)", op_code: 0xB6, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "OR A", op_code: 0xB7, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP B", op_code: 0xB8, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP C", op_code: 0xB9, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP D", op_code: 0xBA, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP E", op_code: 0xBB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP H", op_code: 0xBC, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP L", op_code: 0xBD, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP (HL)", op_code: 0xBE, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "CP A", op_code: 0xBF, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "RET NZ", op_code: 0xC0, bytes: 1, m_cycles: 5, t_cycles: 20}, // TODO
    OpCode {name: "POP BC", op_code: 0xC1, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "JP NZ, u16", op_code: 0xC2, bytes: 3, m_cycles: 4, t_cycles: 16}, // TODO
    OpCode {name: "JP u16", op_code: 0xC3, bytes: 3, m_cycles: 4, t_cycles: 16},
    OpCode {name: "CALL NZ, u16", op_code: 0xC4, bytes: 3, m_cycles: 6, t_cycles: 24}, // TODO
    OpCode {name: "PUSH BC", op_code: 0xC5, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "ADD A, u8", op_code: 0xC6, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 0", op_code: 0xC7, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RET Z", op_code: 0xC8, bytes: 1, m_cycles: 5, t_cycles: 20}, // TODO
    OpCode {name: "RET", op_code: 0xC9, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "JP Z, u16", op_code: 0xCA, bytes: 3, m_cycles: 4, t_cycles: 16}, // TODO
    OpCode {name: "0xCB INSTRUCTION WRONG TABLE", op_code: 0xCB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CALL Z, u16", op_code: 0xCC, bytes: 3, m_cycles: 6, t_cycles: 24}, // TODO
    OpCode {name: "CALL u16", op_code: 0xCD, bytes: 3, m_cycles: 6, t_cycles: 24},
    OpCode {name: "ADC A, u8", op_code: 0xCE, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 1", op_code: 0xCF, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RET NC", op_code: 0xD0, bytes: 1, m_cycles: 5, t_cycles: 20}, // TODO
    OpCode {name: "POP DE", op_code: 0xD1, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "JP NC, u16", op_code: 0xD2, bytes: 3, m_cycles: 4, t_cycles: 16}, // TODO
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xD3, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CALL NC, u16", op_code: 0xD4, bytes: 3, m_cycles: 6, t_cycles: 24}, // TODO
    OpCode {name: "PUSH DE", op_code: 0xD5, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SUB u8", op_code: 0xD6, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 2", op_code: 0xD7, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "RET C", op_code: 0xD8, bytes: 1, m_cycles: 5, t_cycles: 20}, // TODO
    OpCode {name: "RETI", op_code: 0xD9, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "JP C, u16", op_code: 0xDA, bytes: 3, m_cycles: 4, t_cycles: 16}, // TODO
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xDB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CALL C, u16", op_code: 0xDC, bytes: 3, m_cycles: 6, t_cycles: 24}, // TODO
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xDD, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "SBC A, u8", op_code: 0xDE, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 3", op_code: 0xDF, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "LD (u8), A", op_code: 0xE0, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "POP HL", op_code: 0xE1, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD (C), A", op_code: 0xE2, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xE3, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xE4, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "PUSH HL", op_code: 0xE5, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "AND u8", op_code: 0xE6, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 4", op_code: 0xE7, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "ADD SP, s8", op_code: 0xE8, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "JP HL", op_code: 0xE9, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "LD (u16), A", op_code: 0xEA, bytes: 3, m_cycles: 4, t_cycles: 16},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xEB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xEC, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xED, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "XOR u8", op_code: 0xEE, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 5", op_code: 0xEF, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "LD A, (u8)", op_code: 0xF0, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "POP AF", op_code: 0xF1, bytes: 1, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD A, (C)", op_code: 0xF2, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "DI", op_code: 0xF3, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xF4, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "PUSH AF", op_code: 0xF5, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "OR u8", op_code: 0xF6, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 6", op_code: 0xF7, bytes: 1, m_cycles: 4, t_cycles: 16},
    OpCode {name: "LD HL, SP + s8", op_code: 0xF8, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "LD SP, HL", op_code: 0xF9, bytes: 1, m_cycles: 2, t_cycles: 8},
    OpCode {name: "LD A, (u16)", op_code: 0xFA, bytes: 3, m_cycles: 4, t_cycles: 16},
    OpCode {name: "EI", op_code: 0xFB, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xFC, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "ILLEGAL OPCODE", op_code: 0xFD, bytes: 1, m_cycles: 1, t_cycles: 4},
    OpCode {name: "CP u8", op_code: 0xFE, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RST 7", op_code: 0xFF, bytes: 1, m_cycles: 4, t_cycles: 16},
];

#[rustfmt::skip]
pub const CB_INSTRUCTIONS: [OpCode; 256] = [
    OpCode {name: "RLC B", op_code: 0x00, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC C", op_code: 0x01, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC D", op_code: 0x02, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC E", op_code: 0x03, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC H", op_code: 0x04, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC L", op_code: 0x05, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RLC (HL)", op_code: 0x06, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RLC A", op_code: 0x07, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC B", op_code: 0x08, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC C", op_code: 0x09, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC D", op_code: 0x0A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC E", op_code: 0x0B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC H", op_code: 0x0C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC L", op_code: 0x0D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RRC (HL)", op_code: 0x0E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RRC A", op_code: 0x0F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL B", op_code: 0x10, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL C", op_code: 0x11, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL D", op_code: 0x12, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL E", op_code: 0x13, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL H", op_code: 0x14, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL L", op_code: 0x15, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RL (HL)", op_code: 0x16, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RL A", op_code: 0x17, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR B", op_code: 0x18, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR C", op_code: 0x19, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR D", op_code: 0x1A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR E", op_code: 0x1B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR H", op_code: 0x1C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR L", op_code: 0x1D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RR (HL)", op_code: 0x1E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RR A", op_code: 0x1F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA B", op_code: 0x20, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA C", op_code: 0x21, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA D", op_code: 0x22, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA E", op_code: 0x23, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA H", op_code: 0x24, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA L", op_code: 0x25, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SLA (HL)", op_code: 0x26, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SLA A", op_code: 0x27, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA B", op_code: 0x28, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA C", op_code: 0x29, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA D", op_code: 0x2A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA E", op_code: 0x2B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA H", op_code: 0x2C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA L", op_code: 0x2D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRA (HL)", op_code: 0x2E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SRA A", op_code: 0x2F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP B", op_code: 0x30, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP C", op_code: 0x31, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP D", op_code: 0x32, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP E", op_code: 0x33, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP H", op_code: 0x34, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP L", op_code: 0x35, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SWAP (HL)", op_code: 0x36, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SWAP A", op_code: 0x37, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL B", op_code: 0x38, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL C", op_code: 0x39, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL D", op_code: 0x3A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL E", op_code: 0x3B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL H", op_code: 0x3C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL L", op_code: 0x3D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SRL (HL)", op_code: 0x3E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SRL A", op_code: 0x3F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, B", op_code: 0x40, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, C", op_code: 0x41, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, D", op_code: 0x42, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, E", op_code: 0x43, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, H", op_code: 0x44, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, L", op_code: 0x45, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 0, (HL)", op_code: 0x46, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 0, A", op_code: 0x47, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, B", op_code: 0x48, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, C", op_code: 0x49, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, D", op_code: 0x4A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, E", op_code: 0x4B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, H", op_code: 0x4C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, L", op_code: 0x4D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 1, (HL)", op_code: 0x4E, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 1, A", op_code: 0x4F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, B", op_code: 0x50, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, C", op_code: 0x51, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, D", op_code: 0x52, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, E", op_code: 0x53, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, H", op_code: 0x54, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, L", op_code: 0x55, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 2, (HL)", op_code: 0x56, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 2, A", op_code: 0x57, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, B", op_code: 0x58, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, C", op_code: 0x59, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, D", op_code: 0x5A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, E", op_code: 0x5B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, H", op_code: 0x5C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, L", op_code: 0x5D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 3, (HL)", op_code: 0x5E, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 3, A", op_code: 0x5F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, B", op_code: 0x60, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, C", op_code: 0x61, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, D", op_code: 0x62, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, E", op_code: 0x63, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, H", op_code: 0x64, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, L", op_code: 0x65, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 4, (HL)", op_code: 0x66, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 4, A", op_code: 0x67, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, B", op_code: 0x68, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, C", op_code: 0x69, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, D", op_code: 0x6A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, E", op_code: 0x6B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, H", op_code: 0x6C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, L", op_code: 0x6D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 5, (HL)", op_code: 0x6E, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 5, A", op_code: 0x6F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, B", op_code: 0x70, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, C", op_code: 0x71, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, D", op_code: 0x72, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, E", op_code: 0x73, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, H", op_code: 0x74, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, L", op_code: 0x75, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 6, (HL)", op_code: 0x76, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 6, A", op_code: 0x77, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, B", op_code: 0x78, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, C", op_code: 0x79, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, D", op_code: 0x7A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, E", op_code: 0x7B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, H", op_code: 0x7C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, L", op_code: 0x7D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "BIT 7, (HL)", op_code: 0x7E, bytes: 2, m_cycles: 3, t_cycles: 12},
    OpCode {name: "BIT 7, A", op_code: 0x7F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, B", op_code: 0x80, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, C", op_code: 0x81, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, D", op_code: 0x82, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, E", op_code: 0x83, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, H", op_code: 0x84, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, L", op_code: 0x85, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 0, (HL)", op_code: 0x86, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 0, A", op_code: 0x87, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, B", op_code: 0x88, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, C", op_code: 0x89, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, D", op_code: 0x8A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, E", op_code: 0x8B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, H", op_code: 0x8C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, L", op_code: 0x8D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 1, (HL)", op_code: 0x8E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 1, A", op_code: 0x8F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, B", op_code: 0x90, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, C", op_code: 0x91, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, D", op_code: 0x92, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, E", op_code: 0x93, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, H", op_code: 0x94, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, L", op_code: 0x95, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 2, (HL)", op_code: 0x96, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 2, A", op_code: 0x97, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, B", op_code: 0x98, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, C", op_code: 0x99, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, D", op_code: 0x9A, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, E", op_code: 0x9B, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, H", op_code: 0x9C, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, L", op_code: 0x9D, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 3, (HL)", op_code: 0x9E, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 3, A", op_code: 0x9F, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, B", op_code: 0xA0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, C", op_code: 0xA1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, D", op_code: 0xA2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, E", op_code: 0xA3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, H", op_code: 0xA4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, L", op_code: 0xA5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 4, (HL)", op_code: 0xA6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 4, A", op_code: 0xA7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, B", op_code: 0xA8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, C", op_code: 0xA9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, D", op_code: 0xAA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, E", op_code: 0xAB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, H", op_code: 0xAC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, L", op_code: 0xAD, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 5, (HL)", op_code: 0xAE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 5, A", op_code: 0xAF, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, B", op_code: 0xB0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, C", op_code: 0xB1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, D", op_code: 0xB2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, E", op_code: 0xB3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, H", op_code: 0xB4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, L", op_code: 0xB5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 6, (HL)", op_code: 0xB6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 6, A", op_code: 0xB7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, B", op_code: 0xB8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, C", op_code: 0xB9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, D", op_code: 0xBA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, E", op_code: 0xBB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, H", op_code: 0xBC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, L", op_code: 0xBD, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "RES 7, (HL)", op_code: 0xBE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "RES 7, A", op_code: 0xBF, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, B", op_code: 0xC0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, C", op_code: 0xC1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, D", op_code: 0xC2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, E", op_code: 0xC3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, H", op_code: 0xC4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, L", op_code: 0xC5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 0, (HL)", op_code: 0xC6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 0, A", op_code: 0xC7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, B", op_code: 0xC8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, C", op_code: 0xC9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, D", op_code: 0xCA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, E", op_code: 0xCB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, H", op_code: 0xCC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, L", op_code: 0xCD, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 1, (HL)", op_code: 0xCE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 1, A", op_code: 0xCF, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, B", op_code: 0xD0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, C", op_code: 0xD1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, D", op_code: 0xD2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, E", op_code: 0xD3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, H", op_code: 0xD4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, L", op_code: 0xD5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 2, (HL)", op_code: 0xD6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 2, A", op_code: 0xD7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, B", op_code: 0xD8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, C", op_code: 0xD9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, D", op_code: 0xDA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, E", op_code: 0xDB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, H", op_code: 0xDC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, L", op_code: 0xDD, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 3, (HL)", op_code: 0xDE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 3, A", op_code: 0xDF, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, B", op_code: 0xE0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, C", op_code: 0xE1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, D", op_code: 0xE2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, E", op_code: 0xE3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, H", op_code: 0xE4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, L", op_code: 0xE5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 4, (HL)", op_code: 0xE6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 4, A", op_code: 0xE7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, B", op_code: 0xE8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, C", op_code: 0xE9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, D", op_code: 0xEA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, E", op_code: 0xEB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, H", op_code: 0xEC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, L", op_code: 0xED, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 5, (HL)", op_code: 0xEE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 5, A", op_code: 0xEF, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, B", op_code: 0xF0, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, C", op_code: 0xF1, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, D", op_code: 0xF2, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, E", op_code: 0xF3, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, H", op_code: 0xF4, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, L", op_code: 0xF5, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 6, (HL)", op_code: 0xF6, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 6, A", op_code: 0xF7, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, B", op_code: 0xF8, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, C", op_code: 0xF9, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, D", op_code: 0xFA, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, E", op_code: 0xFB, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, H", op_code: 0xFC, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, L", op_code: 0xFD, bytes: 2, m_cycles: 2, t_cycles: 8},
    OpCode {name: "SET 7, (HL)", op_code: 0xFE, bytes: 2, m_cycles: 4, t_cycles: 16},
    OpCode {name: "SET 7, A", op_code: 0xFF, bytes: 2, m_cycles: 2, t_cycles: 8},
];

#[derive(Debug, Clone, Copy)]
pub struct OpCode<'a> {
    pub name: &'a str,
    pub op_code: u8,
    pub bytes: u8,
    pub m_cycles: u8,
    pub t_cycles: u8,
}

```

`src/cpu/interrupts.rs`:

```rs
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Clone, Copy)]
pub enum Interrupt {
    VBlank = 0x40,
    STAT = 0x48,
    Timer = 0x50,
    Serial = 0x58,
    Joypad = 0x60,
}

pub struct InterruptHandler {
    pub inte: u8,
    pub intf: u8,
}

impl Default for InterruptHandler {
    fn default() -> Self {
        Self {
            inte: 0x00,
            intf: 0xE1,
        }
    }
}

impl InterruptHandler {
    // TODO: refactor
    pub fn get_enabled_interrupts(&self) -> [Option<Interrupt>; 5] {
        let vblank = ((self.inte & 0b1) != 0).then_some(Interrupt::VBlank);
        let stat = ((self.inte & 0b10) != 0).then_some(Interrupt::STAT);
        let timer = ((self.inte & 0b100) != 0).then_some(Interrupt::Timer);
        let serial = ((self.inte & 0b1000) != 0).then_some(Interrupt::Serial);
        let joypad = ((self.inte & 0b10000) != 0).then_some(Interrupt::Joypad);

        [vblank, stat, timer, serial, joypad]
    }

    pub fn is_interrupt_requested(&self, interrupt: Interrupt) -> bool {
        match interrupt {
            Interrupt::VBlank => self.intf & 0b1 != 0,
            Interrupt::STAT => self.intf & 0b10 != 0,
            Interrupt::Timer => self.intf & 0b100 != 0,
            Interrupt::Serial => self.intf & 0b1000 != 0,
            Interrupt::Joypad => self.intf & 0b10000 != 0,
        }
    }

    pub fn request_interrupt(&mut self, interrupt: Interrupt) {
        match interrupt {
            Interrupt::VBlank => self.intf |= 0b1,
            Interrupt::STAT => self.intf |= 0b10,
            Interrupt::Timer => self.intf |= 0b100,
            Interrupt::Serial => self.intf |= 0b1000,
            Interrupt::Joypad => self.intf |= 0b10000,
        }
    }

    pub fn reset_if(&mut self, interrupt: Interrupt) {
        match interrupt {
            Interrupt::VBlank => self.intf &= !(0b1),
            Interrupt::STAT => self.intf &= !(0b10),
            Interrupt::Timer => self.intf &= !(0b100),
            Interrupt::Serial => self.intf &= !(0b1000),
            Interrupt::Joypad => self.intf &= !(0b10000),
        }
    }
}

```

`src/cpu/registers.rs`:

```rs
#[allow(non_snake_case)]
#[derive(Default)]
pub struct Registers {
    pub A: u8,
    pub F: u8,
    pub B: u8,
    pub C: u8,
    pub D: u8,
    pub E: u8,
    pub H: u8,
    pub L: u8,
    pub SP: u16,
    pub PC: u16,
}

#[derive(Debug, Clone, Copy)]
pub enum Flag {
    Zero,
    Substraction,
    HalfCarry,
    Carry,
}

#[derive(Debug, Clone, Copy)]
pub enum Regs {
    AF,
    BC,
    DE,
    HL,
    SP,
}

impl Registers {
    /// Sets up register values after booting, so running the BOOT ROM is not needed.
    ///
    /// `header_checksum` is `$014D` and is responsible for the Carry and Half-Carry flag.
    pub fn new_dmg(header_checksum: u8) -> Self {
        let flag = if header_checksum == 0x00 { 0b10000000 } else { 0b10110000 };

        Self {
            A: 0x01,
            F: flag,
            B: 0x00,
            C: 0x13,
            D: 0x00,
            E: 0xD8,
            H: 0x01,
            L: 0x4D,
            SP: 0xFFFE,
            PC: 0x100,
        }
    }

    pub fn new_cgb() -> Self {
        Self {
            A: 0x11,
            F: 0x80,
            B: 0x00,
            C: 0x00,
            D: 0xFF,
            E: 0x56,
            H: 0x00,
            L: 0x0D,
            SP: 0xFFFE,
            PC: 0x100,
        }
    }

    pub fn get_af(&self) -> u16 {
        (self.A as u16) << 8 | self.F as u16
    }

    pub fn get_bc(&self) -> u16 {
        (self.B as u16) << 8 | self.C as u16
    }

    pub fn get_de(&self) -> u16 {
        (self.D as u16) << 8 | self.E as u16
    }

    pub fn get_hl(&self) -> u16 {
        (self.H as u16) << 8 | self.L as u16
    }

    pub fn set_af(&mut self, value: u16) {
        let bytes = value.to_be_bytes();

        self.A = bytes[0];
        self.F = bytes[1];
    }

    pub fn set_bc(&mut self, value: u16) {
        let bytes = value.to_be_bytes();

        self.B = bytes[0];
        self.C = bytes[1];
    }

    pub fn set_de(&mut self, value: u16) {
        let bytes = value.to_be_bytes();

        self.D = bytes[0];
        self.E = bytes[1];
    }

    pub fn set_hl(&mut self, value: u16) {
        let bytes = value.to_be_bytes();

        self.H = bytes[0];
        self.L = bytes[1];
    }

    // sets the lower bits (4-7) of the AF register (F) according to a flag
    pub fn set_flag(&mut self, flag: Flag, bit: bool) {
        if bit {
            self.set_flag_bit(flag);
        } else {
            self.unset_flag_bit(flag);
        }
    }

    pub fn get_flag(&self, flag: Flag) -> bool {
        match flag {
            Flag::Zero => (self.F & (1 << 7)) != 0,
            Flag::Substraction => (self.F & (1 << 6)) != 0,
            Flag::HalfCarry => (self.F & (1 << 5)) != 0,
            Flag::Carry => (self.F & (1 << 4)) != 0,
        }
    }

    fn set_flag_bit(&mut self, flag: Flag) {
        match flag {
            Flag::Zero => self.F |= 1 << 7,
            Flag::Substraction => self.F |= 1 << 6,
            Flag::HalfCarry => self.F |= 1 << 5,
            Flag::Carry => self.F |= 1 << 4,
        }
    }

    fn unset_flag_bit(&mut self, flag: Flag) {
        match flag {
            Flag::Zero => self.F &= !(1 << 7),
            Flag::Substraction => self.F &= !(1 << 6),
            Flag::HalfCarry => self.F &= !(1 << 5),
            Flag::Carry => self.F &= !(1 << 4),
        }
    }
}

```

`src/emulator.rs`:

```rs
use crate::cartridge::base_cartridge::{Cartridge, CartridgeType};
use crate::cartridge::mbc::mbc1::MBC1;
use crate::cartridge::mbc::mbc2::MBC2;
use crate::cartridge::mbc::mbc3::MBC3;
use crate::cartridge::mbc::mbc5::MBC5;
use crate::cartridge::mbc::no_mbc::NoMBC;
use crate::cpu::registers::Registers;
use crate::cpu::CPU;
use crate::mmu::bus::Bus;

pub struct Emulator {
    pub cpu: CPU,
    pub bus: Bus,
    pub rom: Vec<u8>,
    pub cycle_count: u16,
    cgb: bool,
}

impl Emulator {
    pub fn new() -> Self {
        Self {
            cpu: CPU::new(),
            bus: Bus::new(),
            rom: Vec::new(),
            cycle_count: 0,
            cgb: false,
        }
    }

    /// Load ROM and dispatch correct MBC based on header bytes.
    ///
    /// Read out title, RAM and ROM size and set flags based on header
    /// checksum. Initializes `Cartridge` for the Bus.
    pub fn load_rom(&mut self, rom: &[u8]) {
        self.reset();

        let rom_size_kb = 32 * (1 << rom[0x0148]);
        let ram_size_kb = match rom[0x0149] {
            0x00 => 0,
            0x02 => 8,
            0x03 => 32,
            0x04 => 128,
            0x05 => 64,
            _ => unimplemented!("RAM size not supported!"),
        };

        let cartridge_type = match rom[0x0147] {
            0x00 => CartridgeType::NoMBC(NoMBC::new(rom)),
            0x01..=0x03 => CartridgeType::MBC1(MBC1::new(rom, rom_size_kb, ram_size_kb)),
            0x05 | 0x06 => CartridgeType::MBC2(Box::new(MBC2::new(rom))),
            0x0F..=0x13 => CartridgeType::MBC3(MBC3::new(rom)),
            0x19..=0x1E => CartridgeType::MBC5(MBC5::new(rom, rom_size_kb, ram_size_kb)),
            _ => unimplemented!("Cartridge type not supported!"),
        };

        let title = std::str::from_utf8(&rom[0x0134..=0x0143])
            .or_else(|_| std::str::from_utf8(&rom[0x0134..=0x0142]))
            .or_else(|_| std::str::from_utf8(&rom[0x0134..=0x013E]))
            .unwrap();

        self.cgb = rom[0x0143] == 0x80 || rom[0x0143] == 0xC0;
        self.bus.cartridge = Cartridge::new(cartridge_type, title);
        self.rom = rom.to_vec(); // TODO: redundant?

        if self.cgb {
            self.cpu.cgb = true;
            self.cpu.registers = Registers::new_cgb();
            self.bus.ppu.enable_cgb();
        } else {
            self.cpu.registers = Registers::new_dmg(rom[0x014D]);
        }
    }

    /// Step emulator by ticking CPU, advancing it one instruction and returning
    /// the cycles it took.
    ///
    /// `Bus` is passed for sub-instruction level accuracy so that the bus
    /// and its components can tick during instructions.
    ///
    /// Handles interrupts and returns the appropriate amount of cycles if one occured.
    pub fn step(&mut self) -> u8 {
        if self.cpu.handle_interrupts(&mut self.bus) {
            self.cycle_count += 5;
        }

        self.cpu.tick(&mut self.bus)
    }

    // ------------ CARTRIDGE INFO FOR DISPLAY ---------------
    pub fn get_full_mbc_title(&self) -> Option<&str> {
        if self.rom.is_empty() {
            return None;
        }

        match self.rom[0x0147] {
            0x00 => Some("ROM ONLY"),
            0x01 => Some("MBC1"),
            0x02 => Some("MBC1+RAM"),
            0x03 => Some("MBC1+RAM+BATTERY"),
            0x05 => Some("MBC2"),
            0x06 => Some("MBC2+BATTERY"),
            0x0F => Some("MBC3+TIMER+BATTERY"),
            0x10 => Some("MBC3+TIMER+RAM+BATTERY"),
            0x11 => Some("MBC3"),
            0x12 => Some("MBC3+RAM"),
            0x13 => Some("MBC3+RAM+BATTERY"),
            0x19 => Some("MBC5"),
            0x1A => Some("MBC5+RAM"),
            0x1B => Some("MBC5+RAM+BATTERY"),
            0x1C => Some("MBC5+RUMBLE"),
            0x1D => Some("MBC5+RUMBLE+RAM"),
            0x1E => Some("MBC5+RUMBLE+RAM+BATTERY"),
            0x20 => Some("MBC6"),
            0x22 => Some("MBC7+SENSOR+RUMBLE+RAM+BATTERY"),
            _ => None,
        }
    }

    pub fn get_destination_code(&self) -> Option<&str> {
        if self.rom.is_empty() {
            return None;
        }

        match self.rom[0x14A] {
            0x00 => Some("Japan (and possibly overseas)"),
            0x01 => Some("Overseas only"),
            _ => None,
        }
    }

    pub fn get_rom_size(&self) -> Option<usize> {
        if self.rom.is_empty() {
            return None;
        }

        Some(32 * (1 << self.rom[0x0148]))
    }

    pub fn get_ram_size(&self) -> Option<u8> {
        if self.rom.is_empty() {
            return None;
        }

        match self.rom[0x0149] {
            0x00 => Some(0),
            0x02 => Some(8),
            0x03 => Some(32),
            0x04 => Some(128),
            0x05 => Some(64),
            _ => unimplemented!("RAM size not supported!"),
        }
    }
    // ------------ CARTRIDGE INFO FOR DISPLAY ---------------

    pub fn reset(&mut self) {
        self.cpu = CPU::new();
        self.bus = Bus::new();
        self.rom = Vec::new();
        self.cycle_count = 0;
        self.cgb = false;
    }

    pub fn is_cgb(&self) -> bool {
        self.cgb
    }
}

```

`src/input/joypad.rs`:

```rs
use std::time::Duration;

use eframe::egui::{Context, Key};
use gilrs::{ev::filter::Repeat, Axis, Button, Event, EventType, Filter, Gilrs};
use hashlink::LinkedHashMap;

use crate::{
    cpu::interrupts::{Interrupt, InterruptHandler},
    mmu::mmio::MMIO,
};

#[derive(Debug, Clone, Copy)]
pub struct Joypad {
    /// The raw register value depending on the selected button type.
    joyp: u8,
    /// Temporary storage for IRQ check.
    prev_joyp: u8,

    /// Cached direction state.
    dir_state: u8,
    /// Cached action state.
    action_state: u8,
}

#[derive(Clone, Copy, Debug, PartialEq)]
enum ButtonType {
    Action,
    Direction,
    None,
}

impl Default for Joypad {
    fn default() -> Self {
        Self {
            joyp: 0xCF,
            prev_joyp: 0xCF,

            dir_state: 0xF,
            action_state: 0xF,
        }
    }
}

impl MMIO for Joypad {
    fn read(&mut self, _address: u16) -> u8 {
        match self.get_button_type() {
            ButtonType::Action => 0xC0 | (self.joyp & 0x30) | self.action_state,
            ButtonType::Direction => 0xC0 | (self.joyp & 0x30) | self.dir_state,
            _ => 0xCF,
        }
    }

    fn write(&mut self, _address: u16, value: u8) {
        self.joyp = 0xC0 | (value & 0x30) | (self.joyp & 0xF); // bit 7 and 6 unused and always 1
    }
}

impl Joypad {
    /// Handles input once per frame and caches the state
    /// for both direction and action buttons.
    pub fn tick(
        &mut self,
        ctx: &Context,
        interrupt_handler: &mut InterruptHandler,
        action_keys: &LinkedHashMap<String, (Key, Button)>,
        direction_keys: &LinkedHashMap<String, (Key, Button)>,
        gilrs: &mut Gilrs,
    ) {
        self.action_state = self.handle_key_input(ctx, action_keys, gilrs);
        self.dir_state = self.handle_key_input(ctx, direction_keys, gilrs);

        // Joypad IRQ gets requested when (the lower 4 bits of) JOYP changes from 0xF to anything else.
        if (self.prev_joyp & 0xF == 0xF) && (self.read(0) & 0xF != 0xF) {
            interrupt_handler.request_interrupt(Interrupt::Joypad);
        }

        self.prev_joyp = self.read(0);
    }

    /// Set all 4 key bits to 1 as that stands for "not pressed".
    pub fn reset_pressed_keys(&mut self) {
        self.joyp |= 0xF;
    }

    /// `key1`: **A** or **Right**
    ///
    /// `key2`: **B** or **Left**
    ///
    /// `key3`: **Select** or **Up**
    ///
    /// `key4`: **Start** or **Down**
    ///
    /// Takes `keys` from `ControlPanel` to ensure separation
    /// between UI and backend. Meaning, two extra references will
    /// have to be passed every tick.
    ///
    /// This implicit order is based on the bits of JOYP.
    fn handle_key_input(
        &mut self,
        ctx: &Context,
        keys: &LinkedHashMap<String, (Key, Button)>,
        gilrs: &mut Gilrs,
    ) -> u8 {
        keys.iter()
            .enumerate()
            .fold(0xF, |mut acc, (bit, (name, (key, button)))| {
                if ctx.input(|i| i.key_down(*key))
                    || self.is_gamepad_button_down(gilrs, button, name)
                {
                    acc &= !(0x1 << bit as u8);
                }

                acc
            })
    }

    /// Checks if a controller button is pressed instead.
    ///
    /// Repeats the input as one input is too few for most games polling.
    fn is_gamepad_button_down(&self, gilrs: &mut Gilrs, button: &Button, name: &str) -> bool {
        let left_stick = gilrs.gamepads().any(|(_, g)| {
            if let (Some(axis_x), Some(axis_y)) =
                (g.axis_data(Axis::LeftStickX), g.axis_data(Axis::LeftStickY))
            {
                axis_x.value() > 0.5 && name == "Right"
                    || axis_x.value() < -0.5 && name == "Left"
                    || axis_y.value() > 0.5 && name == "Up"
                    || axis_y.value() < -0.5 && name == "Down"
            } else {
                false
            }
        });

        left_stick || gilrs
            .next_event()
            .filter_ev(
                &Repeat {
                    after: Duration::from_millis(0),
                    every: Duration::from_millis(10),
                },
                gilrs,
            )
            .map_or(false, |Event { event, .. }| {
                matches!(event, EventType::ButtonRepeated(b, _) if b == *button)
            })
    }

    fn get_button_type(&self) -> ButtonType {
        if self.joyp & 0x20 == 0 {
            ButtonType::Action
        } else if self.joyp & 0x10 == 0 {
            ButtonType::Direction
        } else {
            ButtonType::None
        }
    }
}

```

`src/input/mod.rs`:

```rs
pub mod joypad;

```

`src/main.rs`:

```rs
#![allow(dead_code)]
#![allow(clippy::collapsible_if)]
#![allow(clippy::collapsible_else_if)]
#![windows_subsystem = "windows"]

use anyhow::Result;
use eframe::IconData;
use egui::FontDefinitions;
use image::{codecs::png::PngDecoder, DynamicImage};
use ui::Kevboy;

#[path = "apu/apu.rs"]
mod apu;
mod cartridge;
#[path = "cpu/cpu.rs"]
mod cpu;
mod emulator;
mod input;
mod mmu;
#[path = "ppu/ppu.rs"]
mod ppu;
#[path = "ui/ui.rs"]
mod ui;

fn main() -> Result<()> {
    let icon = include_bytes!("../icon/icon.png");
    let icon_data = DynamicImage::from_decoder(PngDecoder::new(&icon[..])?)?;

    let native_options = eframe::NativeOptions {
        vsync: false,
        centered: true,
        icon_data: Some(IconData {
            rgba: icon_data.as_bytes().to_vec(),
            width: 256,
            height: 256,
        }),
        ..Default::default()
    };

    eframe::run_native(
        "Kevboy",
        native_options,
        Box::new(|cc| {
            let mut fonts = FontDefinitions::default();
            egui_phosphor::add_to_fonts(&mut fonts, egui_phosphor::Variant::Regular);
            cc.egui_ctx.set_fonts(fonts);

            // Read in rom per command line
            let kevboy = match std::env::args().nth(1) {
                Some(rom) => Kevboy::with_rom(&std::fs::read(rom).unwrap(), cc),
                None => Kevboy::new(cc),
            };
            Box::new(kevboy)
        }),
    )
    .map_err(|e| anyhow::anyhow!(e.to_string()))
}

```

`src/mmu/bus.rs`:

```rs
use crate::{
    apu::APU,
    cartridge::base_cartridge::Cartridge,
    cpu::interrupts::{Interrupt, InterruptHandler},
    input::joypad::Joypad,
    mmu::{mmio::MMIO, serial::Serial, timer::Timers},
    ppu::{DMATransferState, PPU},
};

use super::hdma_transfer::Hdma;

pub struct Bus {
    pub cartridge: Cartridge,

    pub vram: [[u8; 0x2000]; 2],
    pub wram: [[u8; 0x1000]; 8],
    pub oam: [u8; 0xA0],

    pub joypad: Joypad,
    pub serial: Serial,
    pub timer: Timers,
    pub ppu: PPU,

    pub apu: APU,

    pub hram: [u8; 0xAF],
    pub interrupt_handler: InterruptHandler,

    disable_boot_rom: u8,
    vbk: u8,
    svbk: u8,

    hdma: Hdma,

    pub double_speed: bool,
    pub key1: u8,
}

// ----------------------------
// MMIO trait for read/write (access via bus causes tick)
// ----------------------------

impl MMIO for Bus {
    #[rustfmt::skip]
    fn read(&mut self, address: u16) -> u8 {
        if self.ppu.get_dma_state() != DMATransferState::Transferring && !self.hdma.halted {
            self.tick(1);
        }

        // Only matching on the top 4 bits seems to give better codegen and a
        // better jump table with less checks. (this function gets called a lot!)
        match (address & 0xF000) >> 12 {
            0x0..=0x7 => self.cartridge.read(address),
            0x8 | 0x9 => {
                let vbk = if self.ppu.cgb { self.vbk & 1 } else { 0 };
                self.vram[vbk as usize][address as usize - 0x8000]
            },
            0xA | 0xB => self.cartridge.read(address),
            0xC => self.wram[0][address as usize & 0x0FFF],
            0xD | 0xE => {
                // Echo RAM.
                if address > 0xDFFF && address < 0xF000 {
                    return self.wram[0][address as usize & 0x0FFF];
                }

                let wram_bank = if self.svbk & 0x07 == 0 { 1 } else { (self.svbk & 0x07) as usize };
                self.wram[if self.ppu.cgb { wram_bank } else { 1 }][address as usize & 0x0FFF]
            }
            0xF => {
                if address < 0xFE00 {
                    let wram_bank = if self.svbk & 0x07 == 0 { 1 } else { (self.svbk & 0x07) as usize };
                    return self.wram[if self.ppu.cgb { wram_bank } else { 1 }][address as usize & 0x0FFF];
                }

                match address & 0x0FFF {
                    0xE00..=0xE9F => self.oam[address as usize - 0xFE00],
                    0xEA0..=0xEFF => 0xFF, // usage of this area not prohibited, may trigger oam corruption
                    0xF00..=0xF7F => match address {
                        0xFF00 => self.joypad.read(address),
                        0xFF01 | 0xFF02 => self.serial.read(address),
                        0xFF04..=0xFF07 => self.timer.read(address),
                        0xFF0F => self.interrupt_handler.intf,
                        0xFF10..=0xFF3F => self.apu.read(address),
                        0xFF40..=0xFF4B | 0xFF68..=0xFF6B => self.ppu.read(address),
                        0xFF4D => self.key1,
                        0xFF4F => self.vbk,
                        0xFF50 => self.disable_boot_rom,
                        0xFF51..=0xFF55 => self.hdma.read(address),
                        0xFF70 => self.svbk,
                        _ => 0xFF,
                    },
                    0xF80..=0xFFE => self.hram[address as usize - 0xFF80],
                    0xFFF => self.interrupt_handler.inte,
                    _ => unreachable!()
                }
            }
            _ => unreachable!()
        }
    }

    #[rustfmt::skip]
    fn write(&mut self, address: u16, value: u8) {
        if self.ppu.get_dma_state() != DMATransferState::Transferring {
            self.tick(1);
        }

        match address {
            0x0000..=0x7FFF => self.cartridge.write(address, value),
            0x8000..=0x9FFF => {
                let vbk = if self.ppu.cgb { self.vbk & 1 } else { 0 };
                self.vram[vbk as usize][address as usize - 0x8000] = value;
            },
            0xA000..=0xBFFF => self.cartridge.write(address, value),
            0xC000..=0xCFFF => self.wram[0][address as usize & 0x0FFF] = value,
            0xD000..=0xFDFF => {
                // Echo RAM.
                if address > 0xDFFF && address < 0xF000 {
                    self.wram[0][address as usize & 0x0FFF] = value;
                } else {
                    let wram_bank = if self.svbk & 0x07 == 0 { 1 } else { (self.svbk & 0x07) as usize };
                    self.wram[if self.ppu.cgb { wram_bank } else { 1 }][address as usize & 0x0FFF] = value;
                }
            }
            0xFE00..=0xFE9F => self.oam[address as usize - 0xFE00] = value,
            0xFEA0..=0xFEFF => {} // not usable area
            0xFF00..=0xFF7F => match address {
                0xFF00 => self.joypad.write(address, value),
                0xFF01 | 0xFF02 => self.serial.write(address, value),
                0xFF04..=0xFF07 => self.timer.write(address, value),
                0xFF0F => self.interrupt_handler.intf = value | 0b1110_0000,
                0xFF10..=0xFF3F => self.apu.write(address, value),
                0xFF40..=0xFF4B | 0xFF68..=0xFF6B => {
                    self.ppu
                        .write_with_callback(address, value, || self.interrupt_handler.request_interrupt(Interrupt::STAT))
                }
                0xFF4D => self.key1 = (self.key1 & 0xFE) | (value & 1),
                0xFF4F => if self.ppu.cgb { self.vbk = 0xFE | value },
                0xFF51..=0xFF55 => {
                    self.hdma.write(address, value);
                    if address == 0xFF55 && self.ppu.cgb {
                        if (value & (1 << 7)) >> 7 == 0 && self.hdma.hdma_in_progress {
                            self.hdma.terminate_transfer();
                        } else {
                            self.vram_dma_transfer();
                        }
                    }
                },
                0xFF70 => if self.ppu.cgb { self.svbk = 0xF8 | (value & 0x07) },
                _ => {}
            },
            0xFF80..=0xFFFE => self.hram[address as usize - 0xFF80] = value,
            0xFFFF => self.interrupt_handler.inte = value,
        }
    }
}

// ----------------------------
// Normal impl for Bus
// ----------------------------

impl Bus {
    pub fn new() -> Self {
        Self {
            cartridge: Cartridge::default(),

            vram: [[0xFF; 0x2000]; 2],
            wram: [[0xFF; 0x1000]; 8],
            oam: [0xFF; 0xA0],

            joypad: Joypad::default(),
            serial: Serial::default(),
            timer: Timers::new(),
            ppu: PPU::new(),

            apu: APU::default(),

            hram: [0xFF; 0xAF],
            interrupt_handler: InterruptHandler::default(),
            disable_boot_rom: 0xFF, // not writable once unmapped
            vbk: 0xFF,
            svbk: 0xF8,

            hdma: Hdma::default(),

            double_speed: false,
            key1: 0x7E,
        }
    }

    /// Ticks the bus in M-Cycles. Called every mem read/write
    /// and for extra cycles in certain instructions.
    ///
    /// Advances timer, serial and PPU for now.
    pub fn tick(&mut self, cycles_passed: u16) {
        let double_factor = if self.double_speed { 2 } else { 1 };

        let prev_tima = self.timer.tima;
        self.timer.tick(cycles_passed * double_factor);

        if self.timer.irq && prev_tima == 0 {
            self.timer.reload_tima();
            self.interrupt_handler.request_interrupt(Interrupt::Timer);
        }

        // TODO: Clock in T-cycles or M-cycles?
        for _ in 0..((cycles_passed * 4) / double_factor) {
            self.apu.tick((self.timer.div >> 8) as u8);
        }

        self.serial.tick(
            &mut self.interrupt_handler,
            cycles_passed * double_factor,
            self.timer.div,
        );

        // If an HDMA is in progress, we prepare 10 bytes and read those into the HDMA buffer.
        // To not tick during those reads, we set halted to false.
        // The PPU state machine then uses these bytes during HBlank.
        if self.ppu.cgb && self.hdma.hdma_in_progress {
            self.hdma.halted = true;
            for i in 0..0x10 {
                self.hdma.bytes[i] = self.read(self.hdma.source() + i as u16);
            }
            self.hdma.halted = false;
        }

        // PPU ticks 4 times per M-cycle
        for _ in 0..((cycles_passed * 4) / double_factor) {
            self.ppu.tick(
                &mut self.vram,
                &self.oam,
                &mut self.interrupt_handler,
                &mut self.hdma,
                self.vbk & 1,
            );
        }

        // DMA is delayed one cycle -- write -> nothing -> DMA
        match self.ppu.get_dma_state() {
            DMATransferState::Pending => self.ppu.set_dma_enable(),
            DMATransferState::Transferring => self.oam_dma_transfer(),
            DMATransferState::Disabled => {}
        }
    }

    pub fn read_16(&mut self, address: u16) -> u16 {
        let lower_byte = self.read(address);
        let higher_byte = self.read(address + 1);

        (higher_byte as u16) << 8 | lower_byte as u16
    }

    pub fn write_16(&mut self, address: u16, value: u16) {
        let bytes = value.to_le_bytes();

        self.write(address, bytes[0]);
        self.write(address + 1, bytes[1]);
    }

    pub fn change_speed(&mut self) {
        let current_speed = (self.key1 & 0x80) >> 7;
        if current_speed == 0 {
            self.key1 = (self.key1 & 0x7F) | (1 << 7);
            self.double_speed = true;
        } else {
            self.key1 = (self.key1 & 0x7F) & !(1 << 7);
            self.double_speed = false;
        }

        self.key1 &= !1;
    }

    fn oam_dma_transfer(&mut self) {
        let source_start = (self.ppu.read(0xFF46) as u16) * 0x100;
        let source_end = source_start + 0x9F;

        for (dest_ind, addr) in (source_start..=source_end).enumerate() {
            self.oam[dest_ind] = self.read(addr);
        }

        self.ppu.reset_dma();
    }

    fn vram_dma_transfer(&mut self) {
        let source = self.hdma.source();
        let dest = self.hdma.dest();
        let len = self.hdma.length();

        if self.hdma.is_gdma() && !self.hdma.hdma_in_progress {
            self.hdma.halted = true;

            for i in 0..len {
                self.vram[(self.vbk & 1) as usize][(dest + i) as usize] = self.read(source + i);
            }

            self.hdma.complete_transfer();
        } else {
            let hdma5 = self.hdma.read(0xFF55);
            self.hdma.write(0xFF55, hdma5 & 0x7F);
            self.hdma.hdma_in_progress = true;
        }
    }
}

```

`src/mmu/hdma_transfer.rs`:

```rs
use super::mmio::MMIO;

pub struct Hdma {
    /// HDMA source (high, low)
    hdma1: u8,
    hdma2: u8,

    /// HDMA dest (high, low)
    hdma3: u8,
    hdma4: u8,

    /// VRAM DMA length/mode/start
    hdma5: u8,

    pub halted: bool,
    pub hdma_in_progress: bool,
    pub bytes: [u8; 0x10],
}

impl Hdma {
    pub fn is_gdma(&self) -> bool {
        (self.hdma5 & 0x80) >> 7 == 0
    }

    #[inline(always)]
    pub fn source(&self) -> u16 {
        u16::from_be_bytes([self.hdma1, self.hdma2])
    }

    pub fn dest(&self) -> u16 {
        u16::from_be_bytes([self.hdma3, self.hdma4])
    }

    pub fn length(&self) -> u16 {
        ((self.hdma5 & 0x7F) as u16 + 1) * 0x10
    }

    pub fn update_remaining(&mut self) {
        let new_source = self.source() + 0x10;
        let new_dest = self.dest() + 0x10;

        self.hdma1 = new_source.to_be_bytes()[0];
        self.hdma2 = new_source.to_be_bytes()[1];

        self.hdma3 = new_dest.to_be_bytes()[0];
        self.hdma4 = new_dest.to_be_bytes()[1];

        self.hdma5 -= 1;
    }

    pub fn complete_transfer(&mut self) {
        self.hdma_in_progress = false;
        self.halted = false;
        self.hdma5 = 0xFF;
    }

    pub fn terminate_transfer(&mut self) {
        self.hdma_in_progress = false;
        self.halted = false;
        self.hdma5 = 0x80 | (self.hdma5 - 1);
    }
}

impl Default for Hdma {
    fn default() -> Self {
        Self {
            hdma1: 0xFF,
            hdma2: 0xFF,
            hdma3: 0xFF,
            hdma4: 0xFF,
            hdma5: 0xFF,
            halted: false,
            hdma_in_progress: false,
            bytes: [0xFF; 0x10],
        }
    }
}

impl MMIO for Hdma {
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0xFF51 => self.hdma1,
            0xFF52 => self.hdma2,
            0xFF53 => self.hdma3,
            0xFF54 => self.hdma4,
            0xFF55 => self.hdma5,
            _ => unreachable!(),
        }
    }

    fn write(&mut self, address: u16, value: u8) {
        match address {
            0xFF51 => self.hdma1 = value,
            0xFF52 => self.hdma2 = value & 0xF0,
            0xFF53 => self.hdma3 = value & 0x1F,
            0xFF54 => self.hdma4 = value & 0xF0,
            0xFF55 => self.hdma5 = value,
            _ => {}
        }
    }
}

```

`src/mmu/mmio.rs`:

```rs
/// Trait for read / write functions separate from the bus
///
/// Ideal for memory mapped registers.
#[allow(clippy::upper_case_acronyms)]
pub trait MMIO {
    fn read(&mut self, address: u16) -> u8;
    fn write(&mut self, address: u16, value: u8);

    fn write_with_callback<F: FnMut()>(&mut self, address: u16, value: u8, _cb: F) {
        self.write(address, value);
    }
}

```

`src/mmu/mod.rs`:

```rs
pub mod bus;
pub mod hdma_transfer;
pub mod mmio;
pub mod serial;
pub mod timer;

```

`src/mmu/serial.rs`:

```rs
use crate::cpu::interrupts::{Interrupt, InterruptHandler};
use crate::mmu::mmio::MMIO;

pub struct Serial {
    sb: u8,
    sc: u8,

    counter: u8,
    and_result_falling_edge: bool,
}

impl Default for Serial {
    fn default() -> Self {
        Self {
            sb: 0x00,
            sc: 0x7E,

            counter: 1,
            and_result_falling_edge: false,
        }
    }
}

impl MMIO for Serial {
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0xFF01 => self.sb,
            0xFF02 => self.sc,
            _ => unreachable!(),
        }
    }

    fn write(&mut self, address: u16, value: u8) {
        match address {
            0xFF01 => self.sb = value,
            0xFF02 => self.sc = value | 0b0111_1110,
            _ => unreachable!(),
        }
    }
}

impl Serial {
    pub fn tick(&mut self, interrupt_handler: &mut InterruptHandler, cycles_passed: u16, div: u16) {
        for _ in 0..(cycles_passed * 4) {
            if self.and_result_falling_edge && !self.get_serial_falling_edge(div) {
                if self.counter <= 8 {
                    self.sb = (self.sb << self.counter) | (0xFF >> (8 - self.counter));
                    self.counter += 1;
                }

                if self.counter > 8 {
                    self.counter = 1;
                    self.sc = 0x01;

                    interrupt_handler.request_interrupt(Interrupt::Serial);
                }
            }

            self.and_result_falling_edge = self.get_serial_falling_edge(div);
        }
    }

    /// Serial timer is based on DIV, bit 8: 8kHz, and falling edge (see schematic)
    fn get_serial_falling_edge(&self, div: u16) -> bool {
        ((div & (1 << 8)) != 0) & self.is_internal_clock() & self.is_transfer_requested()
    }

    fn is_transfer_requested(&self) -> bool {
        self.sc & (1 << 7) != 0
    }

    // bit 0 is internal or external clock -- external clock is effectively disable for emulation
    fn is_internal_clock(&self) -> bool {
        self.sc & 1 != 0
    }
}

```

`src/mmu/timer.rs`:

```rs
use crate::mmu::mmio::MMIO;

pub struct Timers {
    pub div: u16,
    pub tima: u8,
    pub tma: u8,
    pub tac: u8,

    pub irq: bool,
    and_result_falling_edge: bool,
    reload: bool,
}

impl MMIO for Timers {
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0xFF04 => (self.div >> 8) as u8,
            0xFF05 => self.tima,
            0xFF06 => self.tma,
            0xFF07 => self.tac,
            _ => unreachable!("Unreachable timer register read"),
        }
    }

    fn write(&mut self, address: u16, value: u8) {
        match address {
            0xFF04 => self.div = 0,
            0xFF05 => {
                // during the cycle before the reload,
                // cancel irq if TIMA gets written to
                if self.irq && self.tima == 0 {
                    self.irq = false;
                    self.reload = false;
                }

                if !self.reload {
                    self.tima = value;
                }
            }
            0xFF06 => {
                if self.reload {
                    self.tima = value;
                }

                self.tma = value;
            }
            0xFF07 => {
                // let prev_enable = self.is_timer_enabled();
                self.tac = value | 0b1111_1000;

                // if prev_enable && !self.is_timer_enabled() {
                //     self.tick_tima();
                // }
            }
            _ => unreachable!("Unreachable timer register write"),
        }
    }
}

impl Timers {
    pub fn new() -> Self {
        Self {
            div: 0xABCC,
            tima: 0,
            tma: 0,
            tac: 0xF8,

            irq: false,
            and_result_falling_edge: false,
            reload: false,
        }
    }

    /// Ticks the timer by advancing DIV and TIMA,
    /// also updates internal falling edge.
    pub fn tick(&mut self, cycles_tima: u16) {
        self.reload = false;

        // increase each clock (t-cycle)
        for _ in 0..(cycles_tima * 4) {
            self.tick_div();
            self.tick_tima();

            self.and_result_falling_edge = self.get_timer_falling_edge();
        }
    }

    /// Reloads TIMA when overflow by writing TMA into TIMA
    ///
    /// Sets internal reload bool to true for detection of TIMA write reloading.
    pub fn reload_tima(&mut self) {
        self.tima = self.tma;
        self.irq = false;
        self.reload = true;
    }

    /// Get bit of DIV in position specified by the lower 2 bits of the TAC register
    fn get_sys_counter_bit(&self) -> bool {
        match self.tac & 0b11 {
            0 => (self.div & (1 << 9)) != 0,
            1 => (self.div & (1 << 3)) != 0,
            2 => (self.div & (1 << 5)) != 0,
            3 => (self.div & (1 << 7)) != 0,
            _ => panic!("Invalid TAC frequency!"),
        }
    }

    /// Upper bits increase every 64 m-cycles
    fn tick_div(&mut self) {
        self.div = self.div.wrapping_add(1);
    }

    /// Increased at frequency specified by TAC
    /// TODO: rapid_toggle
    fn tick_tima(&mut self) {
        if !self.irq {
            // check for falling edge of "AND Result" -- bit of DIV & timer enable bit -- only then increase TIMA
            // obscure behavior, not necessary for most games but more accurate
            if self.and_result_falling_edge && !self.get_timer_falling_edge() {
                let (result, overflow) = self.tima.overflowing_add(1);

                if overflow {
                    self.tima = 0x00; // set to tma next cycle
                    self.irq = true;
                } else {
                    self.tima = result;
                }
            }
        }
    }

    /// TIMA increase is based on TAC frequency and DIV
    fn get_timer_falling_edge(&self) -> bool {
        self.get_sys_counter_bit() & self.is_timer_enabled()
    }

    fn is_timer_enabled(&self) -> bool {
        (self.tac & 0b100) != 0
    }
}

```

`src/ppu/color_palette.rs`:

```rs
use eframe::epaint::Color32;
use std::sync::atomic::{AtomicBool, Ordering};

/// Washes out the colors while converting from rgb555.
///
/// Global variables bad yes but this is ok. :clueless:
pub static COLOR_CORRECTION: AtomicBool = AtomicBool::new(false);

/// Palette enum with the according palette register as the associated value.
///
/// In CGB mode, `BGP` represents a value between 0 and 7.
///
/// `OBP` shall be used for both obp0 and obp1 as long as the correct palette is passed.
#[allow(clippy::upper_case_acronyms)]
#[derive(Clone, Copy)]
pub enum Palette {
    BGP(u8),
    OBP(u8),
}

/// Abstraction for screen color, does not hold color information on its own.
///
/// Saves color index to resolve priority later.
///
/// Gets transformed into chosen color palette by the UI.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ScreenColor {
    White(u8),
    LightGray(u8),
    Gray(u8),
    Black(u8),
    FullColor(Color32, u8),
}

// Pre-defined color palettes based on associated constants
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Monochrome;
impl Monochrome {
    pub const WHITE: Color32 = Color32::WHITE;
    pub const LIGHT_GRAY: Color32 = Color32::LIGHT_GRAY;
    pub const GRAY: Color32 = Color32::GRAY;
    pub const BLACK: Color32 = Color32::BLACK;
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Green;
impl Green {
    pub const WHITE: Color32 = Color32::from_rgb(127, 134, 15);
    pub const LIGHT_GRAY: Color32 = Color32::from_rgb(87, 124, 68);
    pub const GRAY: Color32 = Color32::from_rgb(54, 93, 72);
    pub const BLACK: Color32 = Color32::from_rgb(42, 69, 59);
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Chocolate;
impl Chocolate {
    pub const WHITE: Color32 = Color32::from_rgb(255, 228, 194);
    pub const LIGHT_GRAY: Color32 = Color32::from_rgb(220, 164, 86);
    pub const GRAY: Color32 = Color32::from_rgb(169, 96, 76);
    pub const BLACK: Color32 = Color32::from_rgb(66, 41, 54);
}

/// Takes the color value byte and transforms into the correct color based on the palette register
pub(super) fn convert_to_color(value: u8, palette: Palette, cgb: bool, cram: &[u8]) -> ScreenColor {
    match palette {
        Palette::BGP(bgp) if !cgb => match value {
            0b00 => color_from_value(bgp & 0b11, value),
            0b01 => color_from_value((bgp & 0b1100) >> 2, value),
            0b10 => color_from_value((bgp & 0b110000) >> 4, value),
            0b11 => color_from_value((bgp & 0b11000000) >> 6, value),
            _ => unreachable!(),
        },
        Palette::BGP(bgp) if cgb => {
            let palette = (bgp * 8 + value * 2) as usize;
            let color_bytes = u16::from_le_bytes([cram[palette], cram[palette + 1]]);
            ScreenColor::FullColor(rgb555_to_color(color_bytes), value)
        }
        Palette::OBP(obp) if !cgb => match value {
            0b01 => color_from_value((obp & 0b1100) >> 2, value),
            0b10 => color_from_value((obp & 0b110000) >> 4, value),
            0b11 => color_from_value((obp & 0b11000000) >> 6, value),
            _ => unreachable!(),
        },
        Palette::OBP(obp) if cgb => {
            let palette = (obp * 8 + value * 2) as usize;
            let color_bytes = u16::from_le_bytes([cram[palette], cram[palette + 1]]);
            ScreenColor::FullColor(rgb555_to_color(color_bytes), value)
        }
        _ => unreachable!(),
    }
}

fn color_from_value(value: u8, index: u8) -> ScreenColor {
    match value {
        0b00 => ScreenColor::White(index),
        0b01 => ScreenColor::LightGray(index),
        0b10 => ScreenColor::Gray(index),
        0b11 => ScreenColor::Black(index),
        _ => unreachable!(),
    }
}

// https://saveweb.github.io/near.sh/articles/video/color-emulation.html
fn rgb555_to_color(rgb: u16) -> Color32 {
    let red = (rgb & 0x1F) as u8;
    let green = ((rgb >> 5) & 0x1F) as u8;
    let blue = ((rgb >> 10) & 0x1F) as u8;

    if COLOR_CORRECTION.load(Ordering::SeqCst) {
        let r = red as u16 * 26 + green as u16 * 4 + blue as u16 * 2;
        let g = green as u16 * 24 + blue as u16 * 8;
        let b = red as u16 * 6 + green as u16 * 4 + blue as u16 * 22;

        let r = (r.min(960) >> 2) as u8;
        let g = (g.min(960) >> 2) as u8;
        let b = (b.min(960) >> 2) as u8;

        Color32::from_rgb(r, g, b)
    } else {
        Color32::from_rgb(
            (red << 3) | (red >> 2),
            (green << 3) | (green >> 2),
            (blue << 3) | (blue >> 2),
        )
    }
}

```

`src/ppu/ppu.rs`:

```rs
#![allow(clippy::if_same_then_else)]

use crate::{
    cpu::interrupts::{Interrupt, InterruptHandler},
    mmu::{hdma_transfer::Hdma, mmio::MMIO},
    ppu::{
        color_palette::*,
        ppu_regs::PPURegisters,
        sprite::Sprite,
        tile_attributes::{BgOamPrio, TileAttribute},
    },
};

pub mod color_palette;
pub mod ppu_regs;
pub mod sprite;
pub mod tile_attributes;

// --------- PPU constants ---------
pub const LCD_WIDTH: usize = 160;
pub const LCD_HEIGHT: usize = 144;

const MODE3_START: i16 = 80;
const HBLANK_START: i16 = 252;
const LINE_END: i16 = 455;
// --------------------------------

#[derive(PartialEq, Clone, Copy, Debug)]
pub enum Mode {
    HBlank = 0,
    VBlank = 0b1,
    Mode2 = 0b10,
    Mode3 = 0b11,
}

#[derive(PartialEq, Clone, Copy, Debug)]
pub enum DMATransferState {
    Pending,
    Transferring,
    Disabled,
}

#[allow(clippy::upper_case_acronyms)]
pub struct PPU {
    /// LCD screen array, current viewport (double buffering)
    pub frame_buffer: Box<[ScreenColor; LCD_WIDTH * LCD_HEIGHT]>,
    pub ui_frame_buffer: Box<[ScreenColor; LCD_WIDTH * LCD_HEIGHT]>,

    /// Raw 256x256 background for debugging purposes
    pub raw_frame: Vec<ScreenColor>,

    /// Color RAM for CGB mode, stored as RGB555
    bg_cram: [u8; 64],
    bgpi: u8,

    obj_cram: [u8; 64],
    obpi: u8,

    /// Contains pixels for the current line
    current_line: Vec<(ScreenColor, BgOamPrio)>,
    /// Contains up to 10 sprites that will be rendered this line
    current_sprites: Vec<Sprite>,

    /// All PPU registers needed for DMG, MMIO
    regs: PPURegisters,
    /// Current dot the PPU is at relative to beginning of a line
    dots: i16,

    /// Current mode, based on bits 1-0 of STAT
    current_mode: Mode,
    /// Stores previous STAT line to detect rising edge
    stat_block: bool,
    /// Current DMA state to properly delay DMA transfer one m-cycle
    dma_state: DMATransferState,

    internal_window_line: u8,
    pub cgb: bool,
}

impl MMIO for PPU {
    fn read(&mut self, address: u16) -> u8 {
        match address {
            0xFF40 => self.regs.lcdc,
            0xFF41 => self.regs.stat,
            0xFF42 => self.regs.scy,
            0xFF43 => self.regs.scx,
            0xFF44 => self.regs.ly,
            0xFF45 => self.regs.lyc,
            0xFF46 => self.regs.dma,
            0xFF47 => self.regs.bgp,
            0xFF48 => self.regs.opb0,
            0xFF49 => self.regs.opb1,
            0xFF4A => self.regs.wy,
            0xFF4B => self.regs.wx,
            0xFF68 => self.bgpi,
            0xFF69 => {
                if self.cgb {
                    let address = self.bgpi & 0x3F;
                    self.bg_cram[address as usize]
                } else {
                    0xFF
                }
            }
            0xFF6A => self.obpi,
            0xFF6B => {
                if self.cgb {
                    let address = self.obpi & 0x3F;
                    self.obj_cram[address as usize]
                } else {
                    0xFF
                }
            }
            _ => unreachable!(),
        }
    }

    fn write(&mut self, _address: u16, _value: u8) {
        unimplemented!()
    }

    fn write_with_callback<F: FnMut()>(&mut self, address: u16, value: u8, mut irq_stat: F) {
        match address {
            0xFF40 => {
                self.regs.lcdc = value;

                if value & 0x80 == 0 {
                    self.turn_lcd_off();
                } else {
                    // LY=LYC comparison clock starts again after LCD is enabled,
                    // this passes the stat_lyc_on_off test.
                    if self.regs.ly_lyc() {
                        self.regs.stat |= 0b100;
                    } else {
                        self.regs.stat &= !(0b100);
                    }

                    if self.check_stat_interrupt() {
                        irq_stat();
                    }
                }
            }
            0xFF41 => {
                self.regs.stat = (1 << 7) | (value & !(0b111)) | (self.regs.stat & 0b111);

                if self.check_stat_interrupt() {
                    irq_stat();
                }
            }
            0xFF42 => self.regs.scy = value,
            0xFF43 => self.regs.scx = value,
            0xFF44 => {} // LY should be read-only from Bus
            0xFF45 => {
                self.regs.lyc = value;

                if self.regs.is_lcd_on() {
                    if self.regs.ly_lyc() {
                        self.regs.stat |= 0b100;
                    } else {
                        self.regs.stat &= !(0b100);
                    }
                }

                if self.check_stat_interrupt() {
                    irq_stat();
                }
            }
            0xFF46 => {
                self.regs.dma = value;
                self.dma_state = DMATransferState::Pending;
            }
            0xFF47 => self.regs.bgp = value,
            0xFF48 => self.regs.opb0 = value,
            0xFF49 => self.regs.opb1 = value,
            0xFF4A => self.regs.wy = value,
            0xFF4B => self.regs.wx = value,
            0xFF68 => self.bgpi = value,
            0xFF69 => {
                if self.cgb {
                    let auto_inc = (self.bgpi & 0x80) >> 7 != 0;
                    let address = self.bgpi & 0x3F;

                    if auto_inc {
                        self.bgpi = (self.bgpi & 0x80) | (address + 1);
                    }
                    self.bg_cram[address as usize] = value;
                }
            }
            0xFF6A => self.obpi = value,
            0xFF6B => {
                if self.cgb {
                    let auto_inc = (self.obpi & 0x80) >> 7 != 0;
                    let address = self.obpi & 0x3F;

                    if auto_inc {
                        self.obpi = (self.obpi & 0x80) | (address + 1);
                    }
                    self.obj_cram[address as usize] = value;
                }
            }
            _ => unreachable!(),
        }
    }
}

impl PPU {
    pub fn new() -> Self {
        Self {
            frame_buffer: vec![ScreenColor::White(0); LCD_WIDTH * LCD_HEIGHT]
                .into_boxed_slice()
                .try_into()
                .unwrap(),
            ui_frame_buffer: vec![ScreenColor::White(0); LCD_WIDTH * LCD_HEIGHT]
                .into_boxed_slice()
                .try_into()
                .unwrap(),

            raw_frame: vec![ScreenColor::White(0); 256 * 256],
            bg_cram: [0xFF; 64],
            bgpi: 0xC8,

            obj_cram: [0xFF; 64],
            obpi: 0xD0,

            current_line: Vec::with_capacity(256),
            current_sprites: Vec::with_capacity(10),

            regs: PPURegisters::default(),
            dots: 0,

            current_mode: Mode::HBlank,
            stat_block: false,
            dma_state: DMATransferState::Disabled,

            internal_window_line: 0,
            cgb: false,
        }
    }

    // Should tick 4 times per m-cycle
    // 456 clocks per scanline (see lengths below)
    // 80 (Mode2) - 172 (Mode3) - 204 (HBlank) - VBlank
    pub fn tick(
        &mut self,
        vram: &mut [[u8; 0x2000]],
        oam: &[u8],
        interrupt_handler: &mut InterruptHandler,
        hdma: &mut Hdma,
        vbk: u8,
    ) {
        if self.regs.is_lcd_on() {
            // LY = 0 after lcd turn on: special behavior
            match &self.current_mode {
                Mode::Mode2 => {
                    if self.dots >= MODE3_START {
                        self.change_mode(Mode::Mode3, interrupt_handler);
                    }

                    // Scan OAM for (up to) 10 sprites
                    if self.dots == 0 {
                        self.current_sprites = sprite::get_current_sprites_per_line(
                            oam,
                            self.regs.ly,
                            self.regs.is_sprite_8x8(),
                            self.cgb,
                        );
                    }
                }
                Mode::Mode3 => {
                    // Get pixels of current line ("draw" at end of mode)
                    if self.dots >= HBLANK_START {
                        // Important: draw later during Mode3 to fix parts of pocket.gb
                        if self.current_line.is_empty() {
                            self.update_current_line(vram);
                        }

                        if self.regs.is_window_visible()
                            && self.regs.ly >= self.regs.wy
                            && self.regs.is_window_enabled()
                        {
                            self.internal_window_line += 1;
                        }

                        self.draw_current_line(); // -> side effect: clears self.current_line and self.current_sprites
                        self.change_mode(Mode::HBlank, interrupt_handler);
                    }
                }
                Mode::HBlank => {
                    if self.dots >= LINE_END {
                        self.regs.ly += 1;

                        if hdma.hdma_in_progress {
                            for i in 0..0x10 {
                                vram[vbk as usize][hdma.dest() as usize + i as usize] =
                                    hdma.bytes[i as usize];
                            }

                            if hdma.read(0xFF55) == 0x00 {
                                hdma.complete_transfer();
                            } else {
                                hdma.update_remaining();
                            }
                        }

                        // Check STAT irq for LY change
                        if self.regs.ly_lyc() {
                            self.regs.stat |= 0b100;
                        } else {
                            self.regs.stat &= !(0b100);
                        }

                        if self.check_stat_interrupt() {
                            interrupt_handler.request_interrupt(Interrupt::STAT);
                        }

                        if self.regs.ly >= 144 {
                            self.change_mode(Mode::VBlank, interrupt_handler);
                            self.internal_window_line = 0;

                            // Swap buffers to avoid screen tearing on VBlank
                            std::mem::swap(&mut self.frame_buffer, &mut self.ui_frame_buffer);
                        } else {
                            self.change_mode(Mode::Mode2, interrupt_handler);
                        }

                        self.dots = -1;
                    }
                }
                Mode::VBlank => {
                    if self.dots >= LINE_END {
                        self.regs.ly += 1;

                        if self.regs.ly_lyc() {
                            self.regs.stat |= 0b100;
                        } else {
                            self.regs.stat &= !(0b100);
                        }

                        if self.check_stat_interrupt() {
                            interrupt_handler.request_interrupt(Interrupt::STAT);
                        }

                        // TODO: 1 m-cycle after ly is set to 153, it is set to 0 NOT immediately
                        if self.regs.ly >= 153 {
                            self.regs.ly = 0;

                            if self.regs.ly_lyc() {
                                self.regs.stat |= 0b100;
                            } else {
                                self.regs.stat &= !(0b100);
                            }

                            self.change_mode(Mode::Mode2, interrupt_handler);
                        }

                        self.dots = -1;
                    }
                }
            };

            self.dots += 1;
        }
    }

    pub fn enable_cgb(&mut self) {
        self.cgb = true;
    }

    // --------------------------
    //          DMA
    // --------------------------

    pub fn get_dma_state(&self) -> DMATransferState {
        self.dma_state
    }

    pub fn set_dma_enable(&mut self) {
        self.dma_state = DMATransferState::Transferring;
    }

    pub fn reset_dma(&mut self) {
        self.dma_state = DMATransferState::Disabled;
    }

    // --------------------------

    fn turn_lcd_off(&mut self) {
        self.regs.ly = 0;
        self.internal_window_line = 0;

        self.dots = 0;
        self.regs.stat &= !(0b11);
        self.current_mode = Mode::HBlank;
    }

    // -------------------------
    // Rendering logic (bg & win)
    // -------------------------

    // -------- DEBUGGING STUFF --------

    /// Dumps 256x256 BG map for the vram viewer
    pub fn dump_bg_map(&mut self, vram: &[[u8; 0x2000]]) {
        let mut current_line: Vec<(ScreenColor, BgOamPrio)> = Vec::with_capacity(256);

        for y in 0..=255 {
            let unsigned_addressing = self.regs.lcdc & 0b10000 != 0;
            let bg_tile_map_area =
                if self.regs.lcdc & 0b1000 == 0 { 0x9800 - 0x8000 } else { 0x9C00 - 0x8000 };

            let tile_map_start = bg_tile_map_area + (((y / 8) as usize) * 0x20);

            for index in tile_map_start..=(tile_map_start + 0x1F) {
                let tile_row = self.get_tile_row(vram, unsigned_addressing, index, y);
                current_line.extend(tile_row);
            }

            for (x, cl) in current_line.iter().enumerate() {
                self.raw_frame[y as usize * 256 + x] = cl.0;
            }

            current_line.clear();
        }
    }

    // -------- ACTUAL RENDERING --------

    fn update_current_line(&mut self, vram: &[[u8; 0x2000]]) {
        self.update_bg_win_line(vram);
        self.update_sprite_line(vram);
    }

    fn update_bg_win_line(&mut self, vram: &[[u8; 0x2000]]) {
        if !self.cgb && !self.regs.is_bg_enabled() {
            self.current_line = vec![(ScreenColor::White(255), BgOamPrio::BGPrio); 256];
        }

        let unsigned_addressing = self.regs.lcdc & 0b10000 != 0;
        let bg_tile_map_area = if (self.regs.lcdc & 0b1000) >> 3 == 0 {
            0x9800 - 0x8000
        } else {
            0x9C00 - 0x8000
        };

        let adjusted_y = self.regs.ly + self.regs.scy;
        let tile_map_start = bg_tile_map_area + (((adjusted_y / 8) as usize) * 0x20);

        for index in tile_map_start..=(tile_map_start + 0x1F) {
            let tile_row = self.get_tile_row(vram, unsigned_addressing, index, adjusted_y);
            self.current_line.extend(tile_row);
        }

        // Apply SCX to the current scanline in the background layer
        self.current_line.rotate_left(self.regs.scx as usize);

        // Draw window over bg if enabled and visible
        if self.regs.is_window_enabled()
            && self.regs.is_window_visible()
            && self.regs.ly >= self.regs.wy
        {
            let win_tile_map_area = if (self.regs.lcdc & 0x40) >> 6 == 0 {
                0x9800 - 0x8000
            } else {
                0x9C00 - 0x8000
            };

            let win_y = self.internal_window_line;
            let tile_map_start = win_tile_map_area + (((win_y / 8) as usize) * 0x20);

            for (j, index) in (tile_map_start..=(tile_map_start + 0x1F)).enumerate() {
                let tile_row = self.get_tile_row(vram, unsigned_addressing, index, win_y);

                for (i, tile_px) in tile_row.iter().enumerate() {
                    let signed_wx = self.regs.wx as i16;
                    let win_index = (signed_wx - 7) + i as i16 + (j as i16 * 8);
                    if (0..256).contains(&win_index) {
                        self.current_line[win_index as usize] = *tile_px;
                    }
                }
            }
        }
    }

    // -------------------------
    // Sprites
    // -------------------------

    fn update_sprite_line(&mut self, vram: &[[u8; 0x2000]]) {
        if self.regs.is_obj_enabled() {
            for sprite in self.current_sprites.iter().rev() {
                let vbk = if self.cgb { sprite.vbk() as usize } else { 0 };
                let upper_tile = sprite.tile_index & 0xFE;
                let lower_tile = sprite.tile_index | 0x1;

                let real_x_pos = sprite.x_pos as i16 - 8;
                let real_y_pos = sprite.y_pos as i16 - 16;

                let current_tile = if self.regs.is_sprite_8x8() {
                    sprite.tile_index
                } else {
                    if sprite.is_y_flipped() {
                        if real_y_pos.abs_diff(self.regs.ly as i16) >= 8 {
                            upper_tile
                        } else {
                            lower_tile
                        }
                    } else {
                        if real_y_pos.abs_diff(self.regs.ly as i16) >= 8 {
                            lower_tile
                        } else {
                            upper_tile
                        }
                    }
                };

                let sprite_tile = (current_tile as usize) * 16;
                let ly_bytes = (real_y_pos.abs_diff(self.regs.ly as i16) % 8) as usize;

                let palette = if !self.cgb {
                    if sprite.get_dmg_obp_num() == 0 {
                        Palette::OBP(self.regs.opb0)
                    } else {
                        Palette::OBP(self.regs.opb1)
                    }
                } else {
                    Palette::OBP(sprite.get_cgb_obp_num())
                };

                let first_byte = if !sprite.is_y_flipped() {
                    vram[vbk][sprite_tile + (2 * ly_bytes)]
                } else {
                    vram[vbk][sprite_tile + (2 * (7 - ly_bytes))]
                };

                let second_byte = if !sprite.is_y_flipped() {
                    vram[vbk][sprite_tile + (2 * ly_bytes + 1)]
                } else {
                    vram[vbk][sprite_tile + (2 * (7 - ly_bytes) + 1)]
                };

                for i in (0..8).rev() {
                    let lsb = (first_byte & (1 << i)) >> i;
                    let msb = (second_byte & (1 << i)) >> i;

                    let x_flip = if sprite.is_x_flipped() { i } else { 7 - i };

                    if real_x_pos + x_flip < 0 {
                        continue;
                    }

                    let x = (real_x_pos + x_flip) as usize;
                    if (msb << 1 | lsb) != 0 {
                        let color = self.resolve_bg_to_obj_prio(
                            sprite,
                            self.current_line[x].0,
                            msb << 1 | lsb,
                            palette,
                            self.current_line[x].1,
                        );

                        self.current_line[x].0 = color;
                    }
                }
            }
        }
    }

    /// Gets the 8 pixels of the current bg/win tile
    ///
    /// Can't use it for sprites because of the obj prio bit and flip bits
    fn get_tile_row(
        &self,
        vram: &[[u8; 0x2000]],
        unsigned_addressing: bool,
        index: usize,
        y: u8,
    ) -> [(ScreenColor, BgOamPrio); 8] {
        let mut current_line: [(ScreenColor, BgOamPrio); 8] =
            [(ScreenColor::White(255), BgOamPrio::BGPrio); 8];

        let tile_attribute = TileAttribute::from(vram[1][index]);

        let vbk = if self.cgb { tile_attribute.vram_bank as usize } else { 0 };
        let bgp = if self.cgb { tile_attribute.bgp } else { self.regs.bgp };
        let v_flip = if self.cgb { tile_attribute.v_flip } else { false };

        let line_index = (vram[0][index] as usize) * 16;
        let ly_bytes = if !v_flip { (y % 8) as usize } else { (7 - (y % 8)) as usize };

        let (first_byte, second_byte) = if unsigned_addressing {
            (
                vram[vbk][line_index + (2 * ly_bytes)],
                vram[vbk][line_index + (2 * ly_bytes + 1)],
            )
        } else {
            let first_byte = if vram[0][index] <= 127 {
                vram[vbk][(0x9000 - 0x8000) + line_index + (2 * ly_bytes)]
            } else {
                let line_index = ((vram[0][index] as usize) % 128) * 16;
                vram[vbk][(0x8800 - 0x8000) + line_index + (2 * ly_bytes)]
            };

            let second_byte = if vram[0][index] <= 127 {
                vram[vbk][(0x9000 - 0x8000) + line_index + (2 * ly_bytes + 1)]
            } else {
                let line_index = ((vram[0][index] as usize) % 128) * 16;
                vram[vbk][(0x8800 - 0x8000) + line_index + (2 * ly_bytes + 1)]
            };

            (first_byte, second_byte)
        };

        for i in (0..8).rev() {
            let lsb = (first_byte & (1 << i)) >> i;
            let msb = (second_byte & (1 << i)) >> i;
            let h_index = if tile_attribute.h_flip && self.cgb { i } else { 7 - i };

            current_line[h_index] = (
                convert_to_color(msb << 1 | lsb, Palette::BGP(bgp), self.cgb, &self.bg_cram),
                tile_attribute.bg_to_oam,
            );
        }

        current_line
    }

    /// BG to OBJ priority gets resolved like this:
    ///
    /// 1. If the BG color index is 0, OBJ has priority
    /// 2. Otherwise, if LCDC bit 0 is clear, OBJ has priority
    /// 3. Otherwise, if BG attributes and OAM attributes have bit 7 clear, OBJ has priority
    /// 4. Otherwise, BG has priority.
    fn resolve_bg_to_obj_prio(
        &self,
        sprite: &Sprite,
        current_color: ScreenColor,
        index: u8,
        palette: Palette,
        prio: BgOamPrio,
    ) -> ScreenColor {
        if self.cgb {
            let obj = convert_to_color(
                index,
                Palette::OBP(sprite.get_cgb_obp_num()),
                true,
                &self.obj_cram,
            );

            if matches!(current_color, ScreenColor::FullColor(_, 0))
                || (self.regs.lcdc & 1 == 0)
                || (prio == BgOamPrio::OAMPrio && sprite.is_obj_prio())
            {
                obj
            } else {
                current_color
            }
        } else {
            if sprite.is_obj_prio() {
                convert_to_color(index, palette, false, &self.obj_cram)
            } else {
                if matches!(
                    current_color,
                    ScreenColor::White(0)
                        | ScreenColor::LightGray(0)
                        | ScreenColor::Gray(0)
                        | ScreenColor::Black(0)
                ) {
                    convert_to_color(index, palette, false, &self.obj_cram)
                } else {
                    current_color
                }
            }
        }
    }

    fn draw_current_line(&mut self) {
        let y = self.regs.ly as usize;

        for i in 0..LCD_WIDTH {
            self.frame_buffer[y * LCD_WIDTH + i] = self.current_line[i].0;
        }

        self.current_line.clear();
        self.current_sprites.clear();
    }

    // ----------------------------
    // PPU STAT irq and mode change
    // ----------------------------

    fn change_mode(&mut self, to: Mode, interrupt_handler: &mut InterruptHandler) {
        match to {
            Mode::VBlank => interrupt_handler.request_interrupt(Interrupt::VBlank),
            _ if to == self.current_mode => return,
            _ => {}
        };

        self.regs.stat &= !(0b11);
        self.regs.stat |= to as u8;
        self.current_mode = to;

        if self.check_stat_interrupt() {
            interrupt_handler.request_interrupt(Interrupt::STAT);
        }
    }

    fn check_stat_interrupt(&mut self) -> bool {
        let prev_stat = self.stat_block;
        let current_stat = (self.regs.ly_lyc() && self.regs.stat & (1 << 6) != 0)
            || ((self.current_mode == Mode::HBlank) && self.regs.stat & (1 << 3) != 0)
            || ((self.current_mode == Mode::Mode2) && self.regs.stat & (1 << 5) != 0)
            || ((self.current_mode == Mode::VBlank)
                && ((self.regs.stat & (1 << 4) != 0) | (self.regs.stat & (1 << 5) != 0)));

        self.stat_block = current_stat;
        !prev_stat && current_stat
    }
}

```

`src/ppu/ppu_regs.rs`:

```rs
#[derive(Debug)]
pub struct PPURegisters {
    pub lcdc: u8,
    pub stat: u8,
    pub scy: u8,
    pub scx: u8,
    pub ly: u8,
    pub lyc: u8,
    pub wy: u8,
    pub wx: u8,
    pub bgp: u8,
    pub opb0: u8,
    pub opb1: u8,
    pub dma: u8,
}

impl Default for PPURegisters {
    fn default() -> Self {
        Self {
            lcdc: 0x91,
            stat: 0x85,
            scy: 0x00,
            scx: 0x00,
            ly: 0x00,
            lyc: 0x00,
            wy: 0x00,
            wx: 0x00,
            bgp: 0xFC,
            opb0: 0x00,
            opb1: 0x00,
            dma: 0xFF,
        }
    }
}

impl PPURegisters {
    pub fn is_lcd_on(&self) -> bool {
        self.lcdc & (1 << 7) != 0
    }

    pub fn ly_lyc(&self) -> bool {
        self.ly == self.lyc
    }

    pub fn is_bg_enabled(&self) -> bool {
        self.lcdc & 0x1 != 0
    }

    pub fn is_obj_enabled(&self) -> bool {
        self.lcdc & 0x2 != 0
    }

    pub fn is_window_enabled(&self) -> bool {
        self.lcdc & 0x20 != 0
    }

    pub fn is_window_visible(&self) -> bool {
        (0..=166).contains(&self.wx) && (0..=143).contains(&self.wy)
    }

    pub fn is_sprite_8x8(&self) -> bool {
        self.lcdc & 0x4 == 0
    }
}

```

`src/ppu/sprite.rs`:

```rs
#[derive(Debug, Clone, Copy)]
pub struct Sprite {
    pub y_pos: u8,
    pub x_pos: u8,
    pub tile_index: u8,
    attr: u8,
}

/// OAM goes from: $FE00-$FE9F.
/// We have 10 sprites per scanline and sort by x-coordinates
/// and OAM order in DMG or just order in CGB.
pub fn get_current_sprites_per_line(
    oam: &[u8],
    ly: u8,
    height_mode: bool,
    cgb: bool,
) -> Vec<Sprite> {
    let mut sprites: Vec<Sprite> = Vec::new();

    for attributes in oam.chunks(4) {
        let y = attributes[0]; // y + 16, bottom line of sprite
        let sprite_height = if height_mode { 8 } else { 16 };

        let ly_range = (y as i16 - 16)..(y as i16 - 16 + sprite_height as i16);

        if ly_range.contains(&(ly as i16)) && sprites.len() < 10 {
            let x = attributes[1]; // x + 8, right side of sprite
            let upper_tile_index = attributes[2];
            let attr = attributes[3];

            sprites.push(Sprite::new(y, x, upper_tile_index, attr));
        }
    }

    if !cgb {
        sprites.sort_by(|a, b| a.x_pos.cmp(&b.x_pos));
    }
    sprites
}

impl Sprite {
    pub fn new(y_pos: u8, x_pos: u8, tile_index: u8, attr: u8) -> Self {
        Self {
            y_pos,
            x_pos,
            tile_index,
            attr,
        }
    }

    pub fn is_y_flipped(&self) -> bool {
        self.attr & 0x40 != 0
    }

    pub fn is_x_flipped(&self) -> bool {
        self.attr & 0x20 != 0
    }

    /// 0 = OBP0
    ///
    /// 1 = OBP1
    pub fn get_dmg_obp_num(&self) -> u8 {
        (self.attr & 0x10) >> 4
    }

    pub fn get_cgb_obp_num(&self) -> u8 {
        self.attr & 0x07
    }

    pub fn vbk(&self) -> u8 {
        (self.attr & 0x08) >> 3
    }

    /// True if bit 7 of byte 3 is 0
    pub fn is_obj_prio(&self) -> bool {
        self.attr & 0x80 == 0
    }
}

```

`src/ppu/tile_attributes.rs`:

```rs
#[derive(Clone, Copy, Debug)]
pub struct TileAttribute {
    pub bg_to_oam: BgOamPrio,
    pub v_flip: bool,
    pub h_flip: bool,
    pub vram_bank: u8,
    pub bgp: u8,
}

impl From<u8> for TileAttribute {
    fn from(value: u8) -> Self {
        Self {
            bg_to_oam: BgOamPrio::from((value & 0x80) >> 7),
            v_flip: ((value & (0x40)) >> 6) != 0,
            h_flip: ((value & (0x20)) >> 5) != 0,
            vram_bank: (value & 0x08) >> 3,
            bgp: value & 0x07,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BgOamPrio {
    OAMPrio,
    BGPrio,
}

impl From<u8> for BgOamPrio {
    fn from(value: u8) -> Self {
        match value {
            0 => BgOamPrio::OAMPrio,
            1 => BgOamPrio::BGPrio,
            _ => unreachable!(),
        }
    }
}

```

`src/ui/control_panel.rs`:

```rs
use eframe::{
    egui::{Context, Grid, Key, Separator, TextEdit, Ui},
    CreationContext,
};
use egui::{Button, Frame};
use gilrs::{Button as CButton, Gilrs};
use hashlink::LinkedHashMap;

pub struct ControlPanel {
    pub open: bool,

    // LinkedHashMap keeps insertion order, which we want
    // since we generate UI elements from this map.
    pub direction_keys: LinkedHashMap<String, (Key, CButton)>,
    pub action_keys: LinkedHashMap<String, (Key, CButton)>,

    pub gilrs: Gilrs,

    button_width: f32,
}

impl Default for ControlPanel {
    fn default() -> Self {
        Self {
            open: Default::default(),
            direction_keys: LinkedHashMap::from_iter([
                ("Right".into(), (Key::D, CButton::DPadRight)),
                ("Left".into(), (Key::A, CButton::DPadLeft)),
                ("Up".into(), (Key::W, CButton::DPadUp)),
                ("Down".into(), (Key::S, CButton::DPadDown)),
            ]),
            action_keys: LinkedHashMap::from_iter([
                ("A".into(), (Key::P, CButton::South)),
                ("B".into(), (Key::O, CButton::East)),
                ("Select".into(), (Key::Q, CButton::Select)),
                ("Start".into(), (Key::Enter, CButton::Start)),
            ]),
            gilrs: Gilrs::new().unwrap(),
            button_width: 0.0,
        }
    }
}

impl ControlPanel {
    pub fn new(cc: &CreationContext) -> Self {
        if let Some(storage) = cc.storage {
            if let (Some(dir_controls), Some(action_controls)) = (
                eframe::get_value::<LinkedHashMap<String, (Key, CButton)>>(storage, "dir_controls"),
                eframe::get_value::<LinkedHashMap<String, (Key, CButton)>>(
                    storage,
                    "action_controls",
                ),
            ) {
                Self {
                    open: Default::default(),
                    direction_keys: dir_controls,
                    action_keys: action_controls,
                    gilrs: Gilrs::new().unwrap(),
                    button_width: 0.0,
                }
            } else {
                ControlPanel::default()
            }
        } else {
            ControlPanel::default()
        }
    }

    pub fn show(&mut self, ctx: &Context, ui: &mut Ui, frame: &mut eframe::Frame) {
        ui.horizontal(|ui| {
            ui.add_space(ui.available_width() / 7.0);

            Frame::none().show(ui, |ui| {
                ui.vertical(|ui| {
                    ui.heading("Direction");
                    Grid::new("direction").num_columns(2).show(ui, |ui| {
                        for (name, (key, _)) in &mut self.direction_keys {
                            ui.label(format!("{name}: "));
                            let response = ui.add(
                                TextEdit::singleline(&mut (*key).name().to_string())
                                    .desired_width(50.0)
                                    .lock_focus(true)
                                    .hint_text((*key).name()),
                            );

                            if response.has_focus() || response.lost_focus() {
                                let buttons = ctx.input(|i| i.keys_down.clone());
                                if !buttons.is_empty() {
                                    *key = *buttons.iter().next().unwrap();
                                }
                            }

                            ui.end_row();
                        }
                    });
                });
            });

            ui.add(Separator::default().vertical());

            Frame::none().show(ui, |ui| {
                ui.vertical(|ui| {
                    ui.heading("Action");
                    Grid::new("action").num_columns(2).show(ui, |ui| {
                        for (name, (key, _)) in &mut self.action_keys {
                            ui.label(format!("{name}: "));
                            let response = ui.add(
                                TextEdit::singleline(&mut (*key).name().to_string())
                                    .desired_width(50.0)
                                    .lock_focus(true)
                                    .hint_text((*key).name()),
                            );

                            if response.has_focus() || response.lost_focus() {
                                let buttons = ctx.input(|i| i.keys_down.clone());
                                if !buttons.is_empty() {
                                    *key = *buttons.iter().next().unwrap();
                                }
                            }

                            ui.end_row();
                        }
                    });
                });
            });

            ui.add_space(ui.available_width() / 7.0);
        });

        ui.add_space(5.0);
        ui.separator();
        ui.vertical_centered(|ui| {
            ui.set_max_width(self.button_width);

            self.button_width = ui
                .horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply new controls and save them to a file")
                        .clicked()
                    {
                        if let Some(storage) = frame.storage_mut() {
                            eframe::set_value(storage, "dir_controls", &self.direction_keys);
                            eframe::set_value(storage, "action_controls", &self.action_keys);
                            storage.flush();
                        }

                        self.open = false;
                    }
                    if ui
                        .add_enabled(false, Button::new("Reset"))
                        .on_disabled_hover_text("Reset changes to controls")
                        .clicked()
                    {
                        // TODO
                    }
                })
                .response
                .rect
                .width();
        });
    }
}

```

`src/ui/frame_history.rs`:

```rs
use eframe::{
    egui::{util::History, Context},
    Frame,
};

pub struct FrameHistory {
    frame_times: History<f32>,
}

impl Default for FrameHistory {
    fn default() -> Self {
        Self {
            frame_times: History::new(2..100, 1.0),
        }
    }
}

impl FrameHistory {
    pub fn update(&mut self, ctx: &Context, frame: &mut Frame) {
        let prev_time = frame.info().cpu_usage.unwrap_or_default();
        self.frame_times.add(ctx.input(|i| i.time), prev_time);
    }

    pub fn fps(&self) -> f32 {
        1.0 / self.frame_times.mean_time_interval().unwrap_or_default()
    }
}

```

`src/ui/memory_viewer.rs`:

```rs
use eframe::{
    egui::{Grid, RichText, ScrollArea, Separator, TextStyle, Ui},
    epaint::Color32,
};

pub struct MemoryViewer {
    pub open: bool,
    memory: Vec<u8>,
    show_ascii: bool,
}

impl MemoryViewer {
    pub fn new() -> Self {
        Self {
            open: false,
            memory: Vec::new(),
            show_ascii: false,
        }
    }

    pub fn new_with_memory(memory: &[u8], show_ascii: bool) -> Self {
        Self {
            open: false,
            memory: memory.to_vec(),
            show_ascii,
        }
    }

    pub fn show(&mut self, ui: &mut Ui) {
        let mem_chunks: Vec<_> = self.memory.chunks(16).collect();

        ui.checkbox(&mut self.show_ascii, "Show ASCII");
        ui.separator();

        ScrollArea::new([false, true]).show_rows(
            ui,
            ui.text_style_height(&TextStyle::Monospace),
            self.memory.len() / 16,
            |ui, range| {
                Grid::new("memory viewer").striped(true).show(ui, |ui| {
                    for line in range {
                        let chunk = mem_chunks[line];

                        ui.label(
                            RichText::new(format!("{:#06X}:", line * 16)).color(Color32::GOLD),
                        );

                        ui.label(
                            RichText::new(
                                chunk
                                    .iter()
                                    .map(|b| format!("{b:02X?} "))
                                    .collect::<String>(),
                            )
                            .monospace(),
                        );

                        if self.show_ascii {
                            ui.horizontal(|ui| {
                                ui.add(Separator::default().vertical().spacing(3.0));

                                ui.label(
                                    RichText::new(
                                        chunk
                                            .iter()
                                            .map(|c| {
                                                if (32..=127).contains(c) {
                                                    *c as char
                                                } else {
                                                    '.'
                                                }
                                            })
                                            .collect::<String>(),
                                    )
                                    .monospace(),
                                );
                            });
                        }

                        ui.end_row();
                    }
                });
            },
        );
    }
}

```

`src/ui/palette_picker.rs`:

```rs
use crate::ppu::color_palette::{Chocolate, Green, Monochrome};
use eframe::{
    egui::{Grid, Ui},
    epaint::Color32,
    CreationContext,
};
use hashlink::LinkedHashMap;

#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Palette {
    Monochrome(Monochrome),
    Green(Green),
    Chocolate(Chocolate),
    Custom,
}

/// UI for customizing the color palette
pub struct PalettePicker {
    pub open: bool,
    pub current_palette: Palette,

    pub colors: LinkedHashMap<String, Color32>,
    prev_colors: LinkedHashMap<String, Color32>,

    button_width: f32,
}

impl Default for PalettePicker {
    fn default() -> Self {
        Self {
            open: Default::default(),
            current_palette: Palette::Green(Green),
            colors: LinkedHashMap::from_iter([
                ("Black".into(), Green::BLACK),
                ("Gray".into(), Green::GRAY),
                ("Light Gray".into(), Green::LIGHT_GRAY),
                ("White".into(), Green::WHITE),
            ]),
            prev_colors: LinkedHashMap::from_iter([
                ("Black".into(), Green::BLACK),
                ("Gray".into(), Green::GRAY),
                ("Light Gray".into(), Green::LIGHT_GRAY),
                ("White".into(), Green::WHITE),
            ]),
            button_width: 0.0,
        }
    }
}

impl PalettePicker {
    pub fn new(cc: &CreationContext) -> Self {
        if let Some(storage) = cc.storage {
            if let Some(colors) = eframe::get_value::<LinkedHashMap<_, _>>(storage, "colors") {
                let prev_colors = colors.clone();
                Self {
                    open: Default::default(),
                    current_palette: Palette::Custom,
                    colors,
                    prev_colors,
                    button_width: 0.0,
                }
            } else {
                PalettePicker::default()
            }
        } else {
            PalettePicker::default()
        }
    }

    pub fn change_colors(
        &mut self,
        black: &Color32,
        gray: &Color32,
        light_gray: &Color32,
        white: &Color32,
    ) {
        self.colors["Black"] = *black;
        self.colors["Gray"] = *gray;
        self.colors["Light Gray"] = *light_gray;
        self.colors["White"] = *white;
    }

    pub fn show(&mut self, ui: &mut Ui, frame: &mut eframe::Frame) {
        ui.vertical_centered(|ui| {
            ui.heading("Choose custom colors");
            ui.add_space(5.0);

            ui.horizontal(|ui| {
                ui.add_space(ui.available_width() / 3.0);
                Grid::new("colors").show(ui, |ui| {
                    for (k, v) in &mut self.colors {
                        ui.label(format!("{k}: "));
                        ui.color_edit_button_srgba(v);
                        ui.end_row();
                    }
                });
                ui.add_space(ui.available_width() / 3.0);
            });

            ui.add_space(5.0);
            ui.separator();
            ui.vertical_centered(|ui| {
                ui.set_max_width(self.button_width);
                self.button_width = ui
                    .horizontal(|ui| {
                        // "Apply" saves the chosen colors to an external file (egui storage)
                        if ui
                            .button("Apply")
                            .on_hover_text("Saves the palette to a file")
                            .clicked()
                        {
                            if let Some(storage) = frame.storage_mut() {
                                eframe::set_value(storage, "colors", &self.colors);
                                storage.flush();
                            }

                            self.prev_colors = self.colors.clone();
                            self.open = false;
                        }

                        // "Reset" resets the color changes to whichever palette was active before "Apply" was clicked
                        if ui
                            .button("Reset")
                            .on_hover_text("Reset to currently saved palette")
                            .clicked()
                        {
                            self.colors = self.prev_colors.clone();
                        }
                    })
                    .response
                    .rect
                    .width();
            });
        });
    }
}

```

`src/ui/sound_settings.rs`:

```rs
use eframe::CreationContext;
use egui::{RichText, Slider, Ui};

use crate::apu::APU;

pub struct SoundSettings {
    pub open: bool,
    pub volume: f32,
}

impl SoundSettings {
    pub fn new(cc: &CreationContext) -> Self {
        let volume = if let Some(storage) = cc.storage {
            if let Some(saved_volume) = eframe::get_value::<f32>(storage, "volume") {
                saved_volume
            } else {
                50.0
            }
        } else {
            50.0
        };

        Self {
            open: false,
            volume,
        }
    }

    pub fn show(&mut self, ui: &mut Ui, frame: &mut eframe::Frame, apu: &mut APU) {
        ui.vertical_centered(|ui| {
            ui.heading("Change sound settings");
            ui.add_space(5.0);

            ui.horizontal(|ui| {
                ui.add_space(ui.available_width() / 4.0);
                ui.label("Volume:");
                ui.add(Slider::new(&mut self.volume, 0.0..=100.0));
                ui.add_space(ui.available_width() / 4.0);
            });

            ui.add_space(5.0);
            ui.separator();

            ui.label(RichText::new("Enable separate channels:").size(15.0));
            ui.add_space(5.0);

            ui.horizontal(|ui| {
                ui.add_space(ui.available_width() / 4.0);
                ui.checkbox(&mut apu.ch_enable.0, "Channel 1");
                ui.checkbox(&mut apu.ch_enable.1, "Channel 2");
                ui.add_space(ui.available_width() / 4.0);
            });
            ui.horizontal(|ui| {
                ui.add_space(ui.available_width() / 4.0);
                ui.checkbox(&mut apu.ch_enable.2, "Channel 3");
                ui.checkbox(&mut apu.ch_enable.3, "Channel 4");
                ui.add_space(ui.available_width() / 4.0);
            });

            ui.add_space(5.0);
            ui.separator();

            if ui
                .button("Apply")
                .on_hover_text("Saves the volume to a file")
                .clicked()
            {
                if let Some(storage) = frame.storage_mut() {
                    eframe::set_value(storage, "volume", &self.volume);
                    storage.flush();

                    self.open = false;
                }
            }
        });
    }
}

```

`src/ui/ui.rs`:

```rs
use std::{
    fs::{self, File},
    io::Write,
    path::PathBuf,
    sync::atomic::Ordering,
};

use eframe::{
    egui::{
        menu, Button, CentralPanel, CollapsingHeader, Context, Key, KeyboardShortcut, Modifiers,
        RichText, TextureOptions, TopBottomPanel, Window,
    },
    epaint::{Color32, ColorImage},
    App, CreationContext, Frame, Storage,
};
use egui::{Grid, Rgba, ScrollArea, SelectableLabel, SidePanel, TextureHandle, Vec2};
use egui_extras::RetainedImage;
use hashlink::LinkedHashSet;

use crate::{
    cpu::registers::Flag,
    emulator::Emulator,
    ppu::{
        color_palette::{Chocolate, Green, Monochrome, ScreenColor, COLOR_CORRECTION},
        LCD_HEIGHT, LCD_WIDTH,
    },
};

use self::{
    control_panel::ControlPanel,
    frame_history::FrameHistory,
    memory_viewer::MemoryViewer,
    palette_picker::{Palette, PalettePicker},
    sound_settings::SoundSettings,
};

pub mod control_panel;
pub mod frame_history;
pub mod memory_viewer;
pub mod palette_picker;
pub mod sound_settings;

/// Shortcut for adding phosphor icons infront of text.
macro_rules! icon_text {
    ($icon:ident, $text:expr) => {
        format!("{} {}", egui_phosphor::regular::$icon, $text)
    };
}

/// Overarching struct that handles the emulator
/// and keeps track of UI elements since we are using
/// an immediate mode GUI.
pub struct Kevboy {
    emulator: Emulator,
    history: FrameHistory,

    texture: Option<TextureHandle>,
    frame_buffer: Vec<Color32>,

    mem_viewer: MemoryViewer,
    control_panel: ControlPanel,
    palette_picker: PalettePicker,
    sound_settings: SoundSettings,
    github_img: RetainedImage,

    recent_roms: LinkedHashSet<PathBuf>,
    is_vram_window_open: bool,

    playback_button_width: f32,
    pause: bool,
    right: bool,
    fast_forward: bool,

    integer_scaling: (bool, u8),
    blend: bool,
    color_correction: bool,
}

/// Exposes two functions to create the overarching emulator object
impl Kevboy {
    /// Create overarching emulator object with no ROM loaded
    ///
    /// `CreationContext` is needed for its `storage`, so that we can
    /// store some local settings like controls, colors, etc.
    pub fn new(cc: &CreationContext) -> Self {
        Self {
            emulator: Emulator::new(),
            history: FrameHistory::default(),

            texture: None,
            frame_buffer: [Green::WHITE].repeat(LCD_WIDTH * LCD_HEIGHT),

            mem_viewer: MemoryViewer::new(),
            control_panel: ControlPanel::new(cc),
            palette_picker: PalettePicker::new(cc),
            sound_settings: SoundSettings::new(cc),
            github_img: RetainedImage::from_svg_bytes(
                "gh",
                include_bytes!("../../icon/github-mark-white.svg"),
            )
            .unwrap(),

            recent_roms: eframe::get_value(cc.storage.unwrap(), "recent_roms").unwrap_or_default(),
            is_vram_window_open: false,

            playback_button_width: 0.0,
            pause: false,
            right: false,
            fast_forward: false,

            integer_scaling: (false, 0),
            blend: false,
            color_correction: false,
        }
    }

    /// For starting the emulator from the command line
    pub fn with_rom(rom: &[u8], cc: &CreationContext) -> Self {
        let mut emulator = Emulator::new();
        let mut kevboy = Self::new(cc);

        emulator.load_rom(rom);
        kevboy.emulator = emulator;

        kevboy
    }
}

impl App for Kevboy {
    /// Called on shutdown and regular intervals, uses local filesystem or local storage (web)
    ///
    /// We save colors, controls and recently opened ROMs.
    fn save(&mut self, _storage: &mut dyn Storage) {
        eframe::set_value(_storage, "colors", &self.palette_picker.colors);
        eframe::set_value(_storage, "dir_controls", &self.control_panel.direction_keys);
        eframe::set_value(_storage, "action_controls", &self.control_panel.action_keys);
        eframe::set_value(_storage, "recent_roms", &self.recent_roms);
    }

    /// UI declarations and functionality, called every frame and also runs the emulator
    fn update(&mut self, ctx: &Context, frame: &mut Frame) {
        self.history.update(ctx, frame);

        if let Some(tex) = &mut self.texture {
            tex.set(
                ColorImage {
                    size: [LCD_WIDTH, LCD_HEIGHT],
                    pixels: self.frame_buffer.clone(),
                },
                TextureOptions::NEAREST,
            );
        } else {
            self.texture = Some(ctx.load_texture(
                "fb",
                ColorImage::new([LCD_WIDTH, LCD_HEIGHT], Green::WHITE),
                TextureOptions::NEAREST,
            ));
        }

        // Load rom file when dropped on top of the GUI
        ctx.input(|c| {
            let dropped_files = &c.raw.dropped_files;
            let first_rom = dropped_files
                .iter()
                .find(|file| {
                    file.path.as_ref().is_some_and(|p| {
                        let extension = p.extension().unwrap();
                        extension == "gb" || extension == "gbc"
                    })
                })
                .cloned();

            if let Some(file) = first_rom {
                let rom = fs::read(file.path.as_ref().unwrap()).unwrap();

                frame.set_window_title(&format!(
                    "Kevboy - {:#?}",
                    file.path.unwrap().file_name().unwrap().to_str().unwrap()
                ));
                self.emulator.load_rom(&rom);
                self.mem_viewer = MemoryViewer::new_with_memory(&rom, true);
            }
        });

        // ----------------------------------
        //      Start of UI declarations
        // ----------------------------------

        TopBottomPanel::top("menu").show(ctx, |root| {
            menu::bar(root, |ui| {
                ui.menu_button("File", |ui| {
                    // Opens File Dialog filtered for the most common extensions.
                    // Inserts path into `recent_roms` and saves it into local storage.
                    // Then, loads the rom into the emulator and inits the memory viewer.
                    if ui.button(icon_text!(FILE_CODE, "Open ROM")).clicked() {
                        let file = rfd::FileDialog::new()
                            .add_filter("Game Boy ROM", &["gb", "bin", "gbc"])
                            .pick_file();

                        if let Some(path) = file {
                            let rom = fs::read(path.clone()).expect("ROM wasn't loaded correctly!");
                            // Limit recent roms list to 10 (gets too cluttered otherwise)
                            if self.recent_roms.insert(path.clone()) && self.recent_roms.len() >= 10  {
                                self.recent_roms.pop_front();
                            }

                            if let Some(storage) = frame.storage_mut() {
                                eframe::set_value(storage, "recent_roms", &self.recent_roms);
                                storage.flush();
                            }

                            frame.set_window_title(&format!("Kevboy - {:#?}", path.file_name().unwrap().to_str().unwrap()));
                            self.emulator.load_rom(&rom);
                            self.mem_viewer = MemoryViewer::new_with_memory(&rom, true);
                        }

                        ui.close_menu();
                    }

                    // Iterates through a copy of `recent_roms` and generates menu buttons from it
                    // so that all the most recently loaded roms are there. Only displays the file name, not the full path.
                    // Loads the emulator and memory viewer upon clicking a rom.
                    ui.menu_button(icon_text!(FILES, "Open recent ROMs"), |ui| {
                        for rom_path in self.recent_roms.clone().iter().rev() {
                            if ui.button(rom_path.file_name().unwrap().to_str().unwrap()).clicked() {
                                let rom = fs::read(rom_path).expect("ROM wasn't loaded correctly!");
                                self.recent_roms.to_back(rom_path);

                                frame.set_window_title(&format!("Kevboy - {:#?}", rom_path.file_name().unwrap().to_str().unwrap()));
                                self.emulator.load_rom(&rom);
                                self.mem_viewer = MemoryViewer::new_with_memory(&rom, true);

                                ui.close_menu();
                            }
                        }
                    });

                    ui.separator();

                    // Load save file and restarts the game,
                    // this is only enabled when a game is already loaded,
                    // so that we can determine what game the save file belongs to.
                    if ui
                        .add_enabled(
                            !self.emulator.rom.is_empty(),
                            Button::new(icon_text!(UPLOAD_SIMPLE, "Load Save")).shortcut_text(
                                ctx.format_shortcut(&KeyboardShortcut::new(
                                    Modifiers::CTRL,
                                    Key::L,
                                )),
                            ),
                        )
                        .clicked()
                    {
                        let file = rfd::FileDialog::new()
                            .add_filter("Save file", &["sav"])
                            .pick_file();

                        if let Some(path) = file {
                            let save_file = fs::read(path).expect("Save file wasn't loaded correctly!");

                            // restart ROM so that the save can be applied before it's too late
                            self.emulator.load_rom(&self.emulator.rom.clone());
                            self.emulator.bus.cartridge.load_sram(&save_file);
                        }
                    }

                    // Store save file, only enabled when game is already loaded.
                    if ui
                        .add_enabled(
                            !self.emulator.rom.is_empty(),
                            Button::new(icon_text!(DOWNLOAD_SIMPLE, "Store Save")).shortcut_text(
                                ctx.format_shortcut(&KeyboardShortcut::new(
                                    Modifiers::CTRL,
                                    Key::S,
                                )),
                            ),
                        )
                        .clicked()
                    {
                        let file = rfd::FileDialog::new().add_filter("Save file", &["sav"]).save_file();
                        let sram = self.emulator.bus.cartridge.dump_sram();

                        if let Some(f) = file {
                            let save_file = File::create(f);
                            if let Ok(mut sf) = save_file {
                                if let Some(sram) = sram {
                                    sf.write_all(&sram).unwrap();
                                } else {
                                    rfd::MessageDialog::new().set_title("No saving was done!")
                                        .set_description("Nothing was saved as this cartridge does not support external RAM.").show();
                                }
                            }
                        }
                    }
                });

                // Options for changing controls and color palettes.
                // Both may open a new window and will save to local storage.
                ui.menu_button("Options", |ui| {
                    ui.menu_button(icon_text!(PALETTE, "Change palette"), |ui| {
                        if ui.radio_value(&mut self.palette_picker.current_palette, Palette::Monochrome(Monochrome), "Monochrome").clicked() {
                            self.palette_picker.change_colors(&Monochrome::BLACK, &Monochrome::GRAY, &Monochrome::LIGHT_GRAY, &Monochrome::WHITE);
                        }
                        if ui.radio_value(&mut self.palette_picker.current_palette, Palette::Green(Green), "LCD Green").clicked() {
                            self.palette_picker.change_colors(&Green::BLACK, &Green::GRAY, &Green::LIGHT_GRAY, &Green::WHITE);
                        }
                        if ui.radio_value(&mut self.palette_picker.current_palette, Palette::Chocolate(Chocolate), "Chocolate").clicked() {
                            self.palette_picker.change_colors(&Chocolate::BLACK, &Chocolate::GRAY, &Chocolate::LIGHT_GRAY, &Chocolate::WHITE);
                        }
                        if ui.radio_value(&mut self.palette_picker.current_palette, Palette::Custom, "Custom").clicked() {
                            self.palette_picker.open = !self.palette_picker.open;
                        }
                    });

                    ui.menu_button(icon_text!(MAGNIFYING_GLASS_PLUS, "Scaling"), |ui| {
                        let (force, scale) = &mut self.integer_scaling;

                        ui.checkbox(force, "Force integer scaling");
                        ui.separator();
                        ui.add_enabled_ui(*force, |ui| {
                            ui.radio_value(scale, 0, "Automatic");
                            ui.radio_value(scale, 1, "1x");
                            ui.radio_value(scale, 2, "2x");
                            ui.radio_value(scale, 3, "3x");
                            ui.radio_value(scale, 4, "4x");
                            ui.radio_value(scale, 5, "5x");
                        });
                    });

                    ui.separator();
                    ui.toggle_value(&mut self.blend, icon_text!(CARDS, "Frame blending")).on_hover_text("Slow on the web version!");
                    if ui.toggle_value(&mut self.color_correction, icon_text!(PAINT_BRUSH_HOUSEHOLD, "Color correction")).clicked() {
                        COLOR_CORRECTION.store(self.color_correction, Ordering::SeqCst);
                    }
                    ui.separator();

                    if ui.button(icon_text!(GAME_CONTROLLER, "Controls . . .")).clicked() {
                        self.control_panel.open = !self.control_panel.open;
                    };

                    if ui.button(icon_text!(SPEAKER_HIGH, "Sound . . .")).clicked() {
                        self.sound_settings.open = !self.sound_settings.open;
                    }
                });

                ui.menu_button("Debug", |ui| {
                    if ui.button(icon_text!(FLOPPY_DISK, "Show memory (hex)")).clicked() {
                        self.mem_viewer.open = !self.mem_viewer.open;
                    }
                    if ui.button(icon_text!(FRAME_CORNERS, "Open VRAM viewer")).clicked() {
                        self.is_vram_window_open = !self.is_vram_window_open;
                    }
                });
            });
        });

        // Optional information about register state, cartridge type and an "About" section
        // Can be expanded via the "R" button
        SidePanel::right("rp").resizable(false).show_animated(ctx, self.right, |ui| {
            ScrollArea::new([false, true]).show(ui, |ui| {
                ui.vertical(|ui| {
                    ui.add_space(10.0);
                    ui.label(format!("FPS: {:.2}", self.history.fps()));
                    ui.add_space(10.0);

                    // Registers
                    CollapsingHeader::new("Registers")
                        .default_open(true)
                        .show(ui, |ui| {
                            ui.horizontal(|ui| {
                                ui.label(
                                    RichText::new("AF:\nBC:\nDE:\nHL:\n\nSP:\nPC:")
                                        .strong()
                                        .monospace()
                                        .color(Color32::GRAY),
                                );

                                ui.label(
                                    RichText::new(format!(
                                        "{:#06X}\n{:#06X}\n{:#06X}\n{:#06X}\n\n{:#06X}\n{:#06X}",
                                        self.emulator.cpu.registers.get_af(),
                                        self.emulator.cpu.registers.get_bc(),
                                        self.emulator.cpu.registers.get_de(),
                                        self.emulator.cpu.registers.get_hl(),
                                        self.emulator.cpu.registers.SP,
                                        self.emulator.cpu.registers.PC
                                    ))
                                    .strong()
                                    .monospace()
                                    .color(Color32::GOLD),
                                );
                            });

                            ui.label("\nFlags:\n");
                            ui.label(
                                RichText::new("Z\t\tN\t\tH\t\tC\n")
                                    .strong()
                                    .monospace()
                                    .color(Color32::GRAY),
                            );

                            ui.label(
                                RichText::new(format!(
                                    "{}\t\t{}\t\t{}\t\t{}",
                                    self.emulator.cpu.registers.get_flag(Flag::Zero) as u8,
                                    self.emulator.cpu.registers.get_flag(Flag::Substraction) as u8,
                                    self.emulator.cpu.registers.get_flag(Flag::HalfCarry) as u8,
                                    self.emulator.cpu.registers.get_flag(Flag::Carry) as u8
                                ))
                                .strong()
                                .monospace()
                                .color(Color32::GOLD),
                            );
                        });

                    ui.add_space(10.0);

                    // Cartridge Info
                    CollapsingHeader::new("Cartridge Information")
                        .default_open(true)
                        .show(ui, |ui| {
                            Grid::new("cartridge").striped(true).show(ui, |ui| {
                                ui.label("Title: ");
                                ui.label(&self.emulator.bus.cartridge.title);
                                ui.end_row();

                                ui.label("MBC: ");
                                ui.label(self.emulator.get_full_mbc_title().unwrap_or_default());
                                ui.end_row();

                                ui.label("Destination: ");
                                ui.label(self.emulator.get_destination_code().unwrap_or_default());
                                ui.end_row();

                                ui.label("ROM size: ");
                                ui.label(format!(
                                    "{} KiB",
                                    self.emulator.get_rom_size().unwrap_or_default()
                                ));
                                ui.end_row();

                                ui.label("RAM size: ");
                                ui.label(format!(
                                    "{} KiB",
                                    self.emulator.get_ram_size().unwrap_or_default()
                                ));
                                ui.end_row();
                            });
                        });

                    ui.add_space(10.0);

                    CollapsingHeader::new("About").default_open(true).show(ui, |ui| {
                        ui.label("This is a Color Game Boy emulator. \
                        It was made both as a learning exercise and because of the desire to create something emulation-related. \
                        It is not the most accurate emulator out there but it fares relatively well thanks to sub-instruction timing \
                        for example.");

                        ui.horizontal(|ui| {
                            ui.label(RichText::new("Supported MBCs:").strong());
                            ui.label(RichText::new("MBC0, MBC1, MBC2, MBC3, MBC5").monospace());
                        });

                        ui.horizontal(|ui| {
                            ui.image(self.github_img.texture_id(ctx), Vec2::splat(20.0));
                            ui.hyperlink("https://github.com/xkevio/kevboy");
                        });

                        ui.add_space(5.0);
                    });
                });
            });
        });

        // This panel holds both the game screen and the button group for resuming, pausing or stopping emulation
        CentralPanel::default().show(ctx, |ui| {
            ui.vertical(|ui| {
                ui.add_space(20.0);
                ui.vertical_centered(|ui| {
                    ui.set_max_width(self.playback_button_width);
                    self.playback_button_width = ui
                        .group(|ui| {
                            ui.horizontal(|ui| {
                                if ui.add_sized([25.0, 25.0], Button::new(RichText::new("⏹").size(15.0)))
                                    .on_hover_text("Stop the emulation and reset the emulator state")
                                    .clicked()
                                {
                                    self.emulator.reset();
                                    self.frame_buffer.fill(Green::WHITE);
                                }

                                if ui.add_sized([25.0, 25.0], Button::new(if !self.pause { RichText::new("⏸").size(15.0) } else { RichText::new("▶").size(15.0) }))
                                    .on_hover_text("Pause / Resume the emulation")
                                    .clicked()
                                {
                                    self.pause = !self.pause;
                                }

                                if ui.add_sized([25.0, 25.0], SelectableLabel::new(self.fast_forward, RichText::new("⏩").size(15.0)))
                                    .on_hover_text("Fast forward (5x)")
                                    .clicked()
                                {
                                    self.fast_forward = !self.fast_forward;
                                    self.emulator.bus.apu.speed = self.fast_forward;
                                }

                                ui.separator();

                                if ui.add_sized([25.0, 25.0], SelectableLabel::new(self.right, RichText::new("R").size(15.0)))
                                    .on_hover_text("Show right sidebar displaying extra information about registers,\nthe cartridge and an about section")
                                    .clicked()
                                {
                                    self.right = !self.right;
                                }
                            });
                        })
                        .response
                        .rect
                        .width();
                });

                ui.centered_and_justified(|ui| {
                    if let Some(tex) = &self.texture {
                        let raw_scale =
                            (ui.available_width().min(ui.available_height())) / LCD_WIDTH as f32;

                        let scale = match self.integer_scaling {
                            (false, _) => raw_scale,
                            (true, 0) => raw_scale.trunc(),
                            (true, sc) => sc as f32,
                        };

                        ui.image(tex.id(), tex.size_vec2() * scale);
                    }
                });
            });
        });

        // ------------------------------------
        //    Handle open state of windows
        // ------------------------------------

        // Change and customize controls in this window
        if self.control_panel.open {
            let mut control_panel_open = self.control_panel.open;
            Window::new("⌨ Controls")
                .open(&mut control_panel_open)
                .resizable(false)
                .show(ctx, |ui| {
                    self.control_panel.show(ctx, ui, frame);
                });
            self.control_panel.open &= control_panel_open;
        }

        // Change and customize sound settings in this window
        if self.sound_settings.open {
            let mut sound_settings = self.sound_settings.open;
            Window::new("🔊 Volume")
                .open(&mut sound_settings)
                .resizable(false)
                .show(ctx, |ui| {
                    self.sound_settings
                        .show(ui, frame, &mut self.emulator.bus.apu);
                });
            self.sound_settings.open &= sound_settings;
        }

        // Change and customize the color palette of the Game Boy
        if self.palette_picker.open {
            let mut palette_window_open = self.palette_picker.open;
            Window::new("🎨 Palettes")
                .open(&mut palette_window_open)
                .resizable(false)
                .show(ctx, |ui| {
                    self.palette_picker.show(ui, frame);
                });
            self.palette_picker.open &= palette_window_open;
        }

        if self.mem_viewer.open {
            let mut mem_viewer_open = self.mem_viewer.open;
            Window::new("💾 Memory")
                .open(&mut mem_viewer_open)
                .show(ctx, |ui| {
                    self.mem_viewer.show(ui);
                });
            self.mem_viewer.open = mem_viewer_open;
        }

        if self.is_vram_window_open {
            Window::new("🖼 BG Map")
                .open(&mut self.is_vram_window_open)
                .show(ctx, |ui| {
                    self.emulator.bus.ppu.dump_bg_map(&self.emulator.bus.vram);

                    let pixels: Vec<Color32> = self
                        .emulator
                        .bus
                        .ppu
                        .raw_frame
                        .iter()
                        .map(|c| match *c {
                            ScreenColor::White(_) => self.palette_picker.colors["White"],
                            ScreenColor::LightGray(_) => self.palette_picker.colors["Light Gray"],
                            ScreenColor::Gray(_) => self.palette_picker.colors["Gray"],
                            ScreenColor::Black(_) => self.palette_picker.colors["Black"],
                            ScreenColor::FullColor(c, _) => c,
                        })
                        .collect();

                    let image = RetainedImage::from_color_image(
                        "vram",
                        ColorImage {
                            size: [256, 256],
                            pixels,
                        },
                    )
                    .with_options(TextureOptions::NEAREST);

                    image.show_size(ui, ui.available_size());
                });

            Window::new("💾 VRAM:0")
                .open(&mut self.is_vram_window_open)
                .show(ctx, |ui| {
                    let mut mem = MemoryViewer::new_with_memory(&self.emulator.bus.vram[0], false);
                    mem.show(ui);
                });

            Window::new("💾 VRAM:1")
                .open(&mut self.is_vram_window_open)
                .show(ctx, |ui| {
                    let mut mem = MemoryViewer::new_with_memory(&self.emulator.bus.vram[1], false);
                    mem.show(ui);
                });
        }

        // ----------------------------------
        //      End of UI declarations
        // ----------------------------------

        if !self.emulator.rom.is_empty() && !self.pause {
            self.run(ctx);
            ctx.request_repaint();
        }
    }
}

/// Second impl block for the run function
impl Kevboy {
    fn run(&mut self, ctx: &Context) {
        let double_factor = if self.emulator.bus.double_speed { 2 } else { 1 };

        // Poll keyboard and gamepad input once per frame.
        self.emulator.bus.joypad.tick(
            ctx,
            &mut self.emulator.bus.interrupt_handler,
            &self.control_panel.action_keys,
            &self.control_panel.direction_keys,
            &mut self.control_panel.gilrs,
        );

        while self.emulator.cycle_count < 17_556 * double_factor {
            for _ in 0..(4 * self.fast_forward as u8) {
                self.emulator.step();
            }

            self.emulator.cycle_count += self.emulator.step() as u16;
        }

        self.emulator
            .bus
            .apu
            .sink
            .set_volume(self.sound_settings.volume / 100.0);

        // Normal frame buffer for frontend, gets swapped for double buffering
        let frame_buffer = self
            .emulator
            .bus
            .ppu
            .ui_frame_buffer
            .iter()
            .map(|c| match *c {
                ScreenColor::White(_) => self.palette_picker.colors["White"],
                ScreenColor::LightGray(_) => self.palette_picker.colors["Light Gray"],
                ScreenColor::Gray(_) => self.palette_picker.colors["Gray"],
                ScreenColor::Black(_) => self.palette_picker.colors["Black"],
                ScreenColor::FullColor(c, _) => c,
            })
            .collect::<Vec<_>>();

        if self.blend {
            let old_frame = self.frame_buffer.clone();
            let new_frame = frame_buffer;
            self.frame_buffer = self.frame_blend(&old_frame, &new_frame);
        } else {
            self.frame_buffer = frame_buffer;
        }

        self.emulator.cycle_count = 0;
        self.emulator.bus.joypad.reset_pressed_keys();
    }

    // TODO: rewrite as shader, slow on web
    fn frame_blend(&self, old: &[Color32], new: &[Color32]) -> Vec<Color32> {
        new.iter()
            .zip(old)
            .map(|(n, o)| {
                let nc = Rgba::from_srgba_premultiplied(n.r(), n.g(), n.b(), n.a());
                let no = Rgba::from_srgba_premultiplied(o.r(), o.g(), o.b(), o.a());

                let c = nc + (no.multiply(0.5));
                let cc = c.to_srgba_unmultiplied();
                Color32::from_rgba_premultiplied(cc[0], cc[1], cc[2], cc[3])
            })
            .collect()
    }
}

```