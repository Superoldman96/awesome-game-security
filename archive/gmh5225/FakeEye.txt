Project Path: arc_gmh5225_FakeEye_lzhshf0g

Source Tree:

```txt
arc_gmh5225_FakeEye_lzhshf0g
├── FakeEye
│   ├── FakeEye.vcxproj
│   ├── FakeEye.vcxproj.filters
│   ├── FakeEye.vcxproj.user
│   ├── be_service.hpp
│   ├── config_reader.hpp
│   ├── game_launcher.hpp
│   ├── installer.hpp
│   └── main.cpp
├── FakeEye.sln
└── README.md

```

`FakeEye.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FakeEye", "FakeEye\FakeEye.vcxproj", "{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Debug|x64.ActiveCfg = Debug|x64
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Debug|x64.Build.0 = Debug|x64
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Debug|x86.ActiveCfg = Debug|Win32
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Debug|x86.Build.0 = Debug|Win32
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Release|x64.ActiveCfg = Release|x64
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Release|x64.Build.0 = Release|x64
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Release|x86.ActiveCfg = Release|Win32
		{88CB7FBF-A275-46D9-9EE5-93672CAFC87D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D5BA2BAA-9734-4F74-865C-0DB4C1BC8E41}
	EndGlobalSection
EndGlobal

```

`FakeEye/FakeEye.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="be_service.hpp" />
    <ClInclude Include="config_reader.hpp" />
    <ClInclude Include="game_launcher.hpp" />
    <ClInclude Include="installer.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{88cb7fbf-a275-46d9-9ee5-93672cafc87d}</ProjectGuid>
    <RootNamespace>FakeEye</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>
    </TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FakeEye/FakeEye.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="installer.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="be_service.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="game_launcher.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="config_reader.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="FakeEye.md">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`FakeEye/FakeEye.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`FakeEye/be_service.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <iostream>
#include <vector>
#include "config_reader.hpp"
#include "installer.hpp"

/**
 * @brief Responsible for the communication between the launcher and BEService
 */
class BEService
{
public:

	/**
	 * @enum PACKET_ID
	 * @brief Packet-Ids discovered in the BattlEye launcher
	 */
	enum class PACKET_ID : std::uint8_t
	{
		/**
		 * Used to transfer the BattlEye configuration
		 */
		INIT_SERVICE = 0,
		/**
		 * Used to notify the BattlEye service about the started game
		 */
		NOTIFY_GAME_PROCESS = 3
	};

	/**
	 * Constructor
	 *
	 */
	BEService()
	{
		hFile = INVALID_HANDLE_VALUE;
	}

	/**
	 * Deconstructor
	 *
	 */
	~BEService()
	{
		if (hFile)
			CloseHandle(hFile);
	}

	/**
	 * Opens the pipe of BEService
	 *
	 * @return result of CreateService
	 */
	auto Open()->boolean
	{
		hFile = CreateFileA(
			"\\\\.\\pipe\\BattlEye",
			GENERIC_READ | GENERIC_WRITE,
			0,
			0,
			OPEN_ALWAYS,
			0,
			0);
		return hFile != INVALID_HANDLE_VALUE;
	}

	/**
	 * Closes the opened pipe of BEService
	 *
	 */
	auto Close()->void
	{
		CloseHandle(hFile);
		hFile = 0;
		return;
	}

	/**
	 * Read any message from the pipe
	 *
	 * @param Out The buffer 
	 * @param Size The size of the buffer
	 * 
	 * @returns The number of bytes read
	 */
	auto Read(void* Out, std::uint32_t Size)->int const
	{
		DWORD dwReaded = 0;
		if (!ReadFile(this->hFile, Out, Size, &dwReaded, 0) && GetLastError() == ERROR_BROKEN_PIPE)
			return -1;
		return dwReaded;
	}

	/**
	 * Checks if the pipe is opened
	 *
	 * @returns whether the pipe is open or not
	 */
	auto IsOpened()->boolean const
	{
		return hFile != INVALID_HANDLE_VALUE;
	}

	/**
	 * Writes a packet to the pipe
	 *
	 * @param Id The specified BE packet id
	 * @param Size An additional argument, for example, the process-id of the game
	 *
	 * @returns The number of bytes read
	 */
	auto Write(PACKET_ID Id, void* Argument)->boolean
	{
		boolean Result = false;
		std::uint8_t* Buffer = nullptr, *StartBuffer = nullptr;
		config_reader::be_config* config = nullptr;
		DWORD dwWritten = 0;
		switch (Id)
		{
		case PACKET_ID::INIT_SERVICE:

			config = config_reader::ReadConfig();
			if (!config)
				break;

			Buffer = (std::uint8_t*)VirtualAlloc(0, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (!Buffer)
				break;

			StartBuffer = Buffer;

			// Build packet buffer
			{
				*(std::uint8_t*)(Buffer) = (std::uint8_t)PACKET_ID::INIT_SERVICE;
				Buffer++;
				auto GameIdLen = wcslen(config->GameID);;
				*(std::uint8_t*)(Buffer) = wcslen(config->GameID);
				Buffer++;
				wmemcpy((wchar_t*)Buffer, config->GameID, GameIdLen);
				Buffer += GameIdLen * 2;
				*(std::uint16_t*)(Buffer) = config->BasePort;
				Buffer += sizeof(std::uint16_t);
				*(std::uint32_t*)(Buffer) = GetCurrentProcessId();
				Buffer += sizeof(std::uint32_t);
				auto Exe = wcslen(config->Exe32) ? config->Exe32 : config->Exe64;
				Buffer++;
				auto ExeLen = wcslen(Exe);
				*(std::uint8_t*)(Buffer) = ExeLen;
				Buffer++;
				wmemcpy((wchar_t*)Buffer, Exe, ExeLen);
				Buffer += ExeLen * sizeof(wchar_t);
				wmemcpy((wchar_t*)Buffer, installer::GetInstallationPath().c_str(), installer::GetInstallationPath().length());
				Buffer += installer::GetInstallationPath().length() * 2;
			}
			// send buffer
			{
				auto PacketSize = (Buffer - StartBuffer);
				Result = WriteFile(hFile, StartBuffer, PacketSize, &dwWritten, 0);
			}
			break;
		case PACKET_ID::NOTIFY_GAME_PROCESS:
			Buffer = (std::uint8_t*)VirtualAlloc(0, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

			if (!Buffer)
				break;

			// construct and send packet
			{
				Buffer = Buffer;
				*(std::uint8_t*)(Buffer) = (std::uint8_t)PACKET_ID::NOTIFY_GAME_PROCESS;
				Buffer++;
				*(std::uint32_t*)(Buffer) = (std::uint32_t)Argument;
				Result = WriteFile(hFile, Buffer, 5, &dwWritten, 0);
			}
			break;
		}

		if(Buffer)
			VirtualFree(Buffer, 0, MEM_RELEASE);
		if (config)
			delete config;

		return Result;
	}

private:
	/**
	 * Pipe-Handle used to read and write data
	 *
	 */
	HANDLE hFile = 0;
};
```

`FakeEye/config_reader.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <iostream>
#include <filesystem>

/**
 * @namespace config_reader
 * @brief Responsible for reading the configuration of BattlEye
*/
namespace config_reader
{
	/**
	 * @brief Holds the attributes found in the BattlEye configuration
	 */
	struct be_config
	{
		/**
		 * Used to identify the game
		 */
		wchar_t GameID[512];
		/**
		 * Used to start the 32 bit game
		 */
		wchar_t Exe32[512];
		/**
		 * Used to start the 64 bit game
		 */
		wchar_t Exe64[512];
		/**
		 * Used as process argument
		 */
		wchar_t BEArg[512];

		/**
		 * Used for communication
		 */
		int BasePort;
	};

	/**
	 * Reads the configuration found in the game folder
	 *
	 * @returns The read config struct
	 */
	auto ReadConfig()->be_config*
	{

		be_config* config = nullptr;

		wchar_t Path[512];
		std::memset(Path, 0, 512);
		wchar_t ExePath[512];
		std::memset(ExePath, 0, 512);


		if (!GetModuleFileNameW(0, ExePath, 512))
			return nullptr;

		config = new be_config();
		if (!config)
			return nullptr;
		std::memset(config->GameID, 0, 512);
		std::memset(config->Exe32, 0, 512);
		std::memset(config->Exe64, 0, 512);
		std::memset(config->BEArg, 0, 512);

		swprintf_s(Path, L"%s/%s", std::filesystem::path(ExePath).parent_path().generic_wstring().c_str(), L"BattlEye/BELauncher.ini");

		config->BasePort = GetPrivateProfileIntW(L"Launcher", L"BasePort", 0, Path);
		GetPrivateProfileStringW(L"Launcher", L"GameID", 0, config->GameID, 512, Path);
		GetPrivateProfileStringW(L"Launcher", L"32BitExe", 0, config->Exe32, 512, Path);
		GetPrivateProfileStringW(L"Launcher", L"64BitExe", 0, config->Exe64, 512, Path);
		GetPrivateProfileStringW(L"Launcher", L"BEArg", 0, config->BEArg, 512, Path);

		return config;
	};
}
```

`FakeEye/game_launcher.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <iostream>

/*! \cond PRIVATE */
struct _OBJECT_HANDLE_FLAG_INFORMATION
{
	BOOLEAN Inherit;
	BOOLEAN ProtectFromClose;
};

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} LSA_UNICODE_STRING, * PLSA_UNICODE_STRING, UNICODE_STRING, * PUNICODE_STRING;

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	WORD Flags;
	WORD Length;
	ULONG TimeStamp;
	UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	PVOID Handle;
} CURDIR, * PCURDIR;

typedef struct _SECTION_IMAGE_INFORMATION
{
	PVOID TransferAddress;
	ULONG ZeroBits;
	ULONG MaximumStackSize;
	ULONG CommittedStackSize;
	ULONG SubSystemType;
	union
	{
		struct
		{
			WORD SubSystemMinorVersion;
			WORD SubSystemMajorVersion;
		};
		ULONG SubSystemVersion;
	};
	ULONG GpValue;
	WORD ImageCharacteristics;
	WORD DllCharacteristics;
	WORD Machine;
	UCHAR ImageContainsCode;
	UCHAR ImageFlags;
	ULONG ComPlusNativeReady : 1;
	ULONG ComPlusILOnly : 1;
	ULONG ImageDynamicallyRelocated : 1;
	ULONG Reserved : 5;
	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, * PSECTION_IMAGE_INFORMATION;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE           Reserved1[16];
	PVOID          Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _RTL_USER_PROCESS_INFORMATION
{
	ULONG Length;
	HANDLE ProcessHandle;
	HANDLE ThreadHandle;
	CLIENT_ID ClientId;
	SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, * PRTL_USER_PROCESS_INFORMATION;

typedef struct _RTL_RELATIVE_NAME_U {
	UNICODE_STRING RelativeName;
	HANDLE ContainingDirectory;
	PVOID CurDirRef;
} RTL_RELATIVE_NAME_U, * PRTL_RELATIVE_NAME_U;
/*! \endcond */

/**
 * @namespace game_handler
 * @brief Responsible for emulating the game-start process
*/
namespace game_handler
{
	/**
	 * Starts the protected game in the launcher 
	 *
	 * @param Arg The process argument
	 * @param Cmd The path to the BE protected game
	 * @param ProcessHandle A pointer to be written with the full access process handle
	 * @param ThreadHandle A pointer to be written with the full access thread handle
	 * @param Suspended Decides whether the process should remain suspended or not
	 *
	 * @returns A boolean which decides whether the function was successful or not.
	 */
	auto StartGame(wchar_t* Arg, wchar_t* Cmd, OUT PHANDLE ProcessHandle, OUT PHANDLE ThreadHandle, BOOL Suspended)->boolean
	{
		using p_NtSetInformationObject = NTSTATUS(NTAPI*)(HANDLE ObjectHandle, int ObjectInformationClass, PVOID ObjectInformation, ULONG Length);
		static p_NtSetInformationObject NtSetInformationObject = (p_NtSetInformationObject)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetInformationObject"));

		using p_RtlDosPathNameToNtPathName_U = NTSTATUS(NTAPI*)(PCWSTR DosName, PUNICODE_STRING NtName, PCWSTR* PartName, PRTL_RELATIVE_NAME_U RelativeName);
		static p_RtlDosPathNameToNtPathName_U RtlDosPathNameToNtPathName_U = (p_RtlDosPathNameToNtPathName_U)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlDosPathNameToNtPathName_U"));

		using p_RtlInitUnicodeString = NTSTATUS(NTAPI*)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
		static p_RtlInitUnicodeString RtlInitUnicodeString = (p_RtlInitUnicodeString)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlInitUnicodeString"));

		using p_RtlCreateProcessParameters = NTSTATUS(NTAPI*)(PRTL_USER_PROCESS_PARAMETERS* pProcessParameters, PUNICODE_STRING ImagePathName, PUNICODE_STRING DllPath, PUNICODE_STRING CurrentDirectory, PUNICODE_STRING CommandLine, PVOID Environment, PUNICODE_STRING WindowTitle, PUNICODE_STRING DesktopInfo, PUNICODE_STRING ShellInfo, PUNICODE_STRING RuntimeData);
		static p_RtlCreateProcessParameters RtlCreateProcessParameters = (p_RtlCreateProcessParameters)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlCreateProcessParameters"));

		using p_RtlFreeUnicodeString = NTSTATUS(NTAPI*)(PUNICODE_STRING UnicodeString);
		static p_RtlFreeUnicodeString RtlFreeUnicodeString = (p_RtlFreeUnicodeString)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlFreeUnicodeString"));

		using p_RtlCreateUserProcess =  NTSTATUS(NTAPI*)(PUNICODE_STRING ImagePath, ULONG ObjectAttributes, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, PSECURITY_DESCRIPTOR ProcessSecurityDescriptor, PSECURITY_DESCRIPTOR ThreadSecurityDescriptor, HANDLE ParentProcess, BOOLEAN InheritHandles, HANDLE DebugPort, HANDLE ExceptionPort, PRTL_USER_PROCESS_INFORMATION ProcessInformation);
		static p_RtlCreateUserProcess RtlCreateUserProcess =(p_RtlCreateUserProcess)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlCreateUserProcess"));

		using p_RtlDestroyProcessParameters = NTSTATUS(NTAPI*)(PRTL_USER_PROCESS_PARAMETERS ProcessParameters);
		static p_RtlDestroyProcessParameters RtlDestroyProcessParameters = (p_RtlDestroyProcessParameters)(GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlDestroyProcessParameters"));


		wchar_t Path[512], CmdLine[512], NewPath[512];
		STARTUPINFOW si;
		PROCESS_INFORMATION pi;
		PRTL_USER_PROCESS_PARAMETERS UserProcessParam = 0, GameParam = 0;
		HANDLE hProcess = 0, OwnProcess = INVALID_HANDLE_VALUE;
		UNICODE_STRING FileName, CommandLine, FileNameGame;
		RTL_USER_PROCESS_INFORMATION ProcessInfo;
		NTSTATUS Status = 0;
		_OBJECT_HANDLE_FLAG_INFORMATION ObjectHandleAttributeInformation;
		std::uint32_t pId = 0;

		ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
		ZeroMemory(&ObjectHandleAttributeInformation, sizeof(ObjectHandleAttributeInformation));
		ZeroMemory(&si, sizeof(STARTUPINFOW));
		ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
		ZeroMemory(&UserProcessParam, sizeof(UserProcessParam));
		ZeroMemory(&GameParam, sizeof(GameParam));
		ZeroMemory(&FileName, sizeof(FileName));
		ZeroMemory(&CommandLine, sizeof(CommandLine));
		ZeroMemory(&FileNameGame, sizeof(FileNameGame));
		ZeroMemory(Path, 512);
		ZeroMemory(NewPath, 512);
		ZeroMemory(CmdLine, 512);

		if (!NtSetInformationObject || !RtlDosPathNameToNtPathName_U || !RtlInitUnicodeString || !RtlCreateProcessParameters || !RtlFreeUnicodeString || !RtlCreateUserProcess || !RtlDestroyProcessParameters)
			return false;

		OwnProcess = OpenProcess(PROCESS_CREATE_PROCESS, false, GetCurrentProcessId());
		if (OwnProcess == INVALID_HANDLE_VALUE)
			return false;

		if (!GetModuleFileNameW(0, Path, 512))
		{
			CloseHandle(OwnProcess);
			return false;
		}

		if (Arg)
		{
			swprintf_s(CmdLine, L"\"%ws\" %ws", Cmd, Arg);
			RtlInitUnicodeString(&CommandLine, CmdLine);
		}


		if (!RtlDosPathNameToNtPathName_U(Path, &FileName, NULL, NULL) ||
			!RtlDosPathNameToNtPathName_U(Cmd, &FileNameGame, NULL, NULL))
		{
			CloseHandle(OwnProcess);
			return false;
		}


		if (RtlCreateProcessParameters(&UserProcessParam, &FileName, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL))
		{
			RtlFreeUnicodeString(&FileNameGame);
			RtlFreeUnicodeString(&FileName);
			CloseHandle(OwnProcess);
			return false;
		}

		if (RtlCreateProcessParameters(&GameParam, &FileNameGame, NULL, NULL, Arg ? &CommandLine : 0, NULL, NULL, NULL, NULL, NULL))
		{
			RtlFreeUnicodeString(&FileNameGame);
			RtlFreeUnicodeString(&FileName);
			RtlDestroyProcessParameters(UserProcessParam);
			CloseHandle(OwnProcess);
			return false;
		}

		Status = RtlCreateUserProcess(&FileName, 0x00000040, UserProcessParam, NULL, NULL, OwnProcess, TRUE, NULL, NULL, &ProcessInfo);
		if (Status)
		{
			RtlFreeUnicodeString(&FileNameGame);
			RtlFreeUnicodeString(&FileName);
			RtlDestroyProcessParameters(UserProcessParam);
			CloseHandle(OwnProcess);
			return false;
		}

		hProcess = ProcessInfo.ProcessHandle;
		if (!CloseHandle(ProcessInfo.ThreadHandle))
		{
			RtlFreeUnicodeString(&FileNameGame);
			RtlFreeUnicodeString(&FileName);
			RtlDestroyProcessParameters(UserProcessParam);
			CloseHandle(OwnProcess);
			CloseHandle(ProcessInfo.ProcessHandle);
			return false;
		}

		Status = RtlCreateUserProcess(&FileNameGame, 0x00000040, GameParam, NULL, NULL, ProcessInfo.ProcessHandle, TRUE, NULL, NULL, &ProcessInfo);
		if (Status)
		{
			RtlFreeUnicodeString(&FileNameGame);
			RtlFreeUnicodeString(&FileName);
			RtlDestroyProcessParameters(UserProcessParam);
			CloseHandle(OwnProcess);
			CloseHandle(ProcessInfo.ProcessHandle);
			CloseHandle(ProcessInfo.ThreadHandle);
			return false;
		}

		TerminateProcess(hProcess, (NTSTATUS)(ProcessInfo.ClientId.UniqueProcess));
		CloseHandle(hProcess);

		if (Suspended == FALSE)
			ResumeThread(ProcessInfo.ThreadHandle);
		pId = (std::uint32_t)(ProcessInfo.ClientId.UniqueProcess);
		if (ThreadHandle)
			*ThreadHandle = ProcessInfo.ThreadHandle;
		if (ProcessHandle)
			*ProcessHandle = ProcessInfo.ProcessHandle;
		if (UserProcessParam)
			RtlDestroyProcessParameters(UserProcessParam);
		if (GameParam)
			RtlDestroyProcessParameters(GameParam);
		if (ProcessInfo.ThreadHandle && !ThreadHandle)
			CloseHandle(ProcessInfo.ThreadHandle);
		if (ProcessInfo.ProcessHandle && !ProcessHandle)
			CloseHandle(ProcessInfo.ProcessHandle);
		if (FileName.Buffer)
			RtlFreeUnicodeString(&FileName);
		if (FileNameGame.Buffer)
			RtlFreeUnicodeString(&FileNameGame);
		if (OwnProcess)
			CloseHandle(OwnProcess);
		Status = true;
		return Status;
	}
};

```

`FakeEye/installer.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <iostream>
#include <Shlobj.h>
#include <shlwapi.h>
#pragma comment(lib,"shlwapi")

/**
 * @namespace installer
 * @brief Responsible for managing the service
*/
namespace installer
{
	/**
	 * Stores the path of the installed service
	 * 
	 */
	static inline std::wstring service_path;

	/**
	 * Installs the service of BattlEye
	 *
	 * @returns The result as boolean
	 */
	auto Install()->boolean 
	{
		wchar_t FilePath[1024], CommonPath[MAX_PATH], ComPath[MAX_PATH];
		SYSTEM_INFO si;
		DWORD dwAttributes = 0, bytesNeeded = 0;
		SC_HANDLE hService = 0, hSCM = 0;
		SERVICE_STATUS_PROCESS ss = { 0,0,0,0,0,0,0,0,0 };
		HANDLE hFile = INVALID_HANDLE_VALUE;


		std::memset(FilePath, 0, 1024);
		std::memset(CommonPath, 0, MAX_PATH);
		std::memset(ComPath, 0, MAX_PATH);

		// check if the service is already installed
		{
			std::memset(&si, 0, sizeof(si));
			hSCM = OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS);
			if (hSCM == 0)
				return false;

			hService = OpenServiceA(hSCM, "BEService", SERVICE_ALL_ACCESS);
			if (hService != 0)
			{
				if (QueryServiceStatusEx(hService, (SC_STATUS_TYPE)0, (LPBYTE)&ss, sizeof(ss), &bytesNeeded))
				{
					if (ss.dwCurrentState == SERVICE_RUNNING)
					{
						CloseServiceHandle(hService);
						return true;
					}
					if (StartServiceA(hService, 0, 0) == FALSE)
					{
						CloseServiceHandle(hService);
						return false;
					}

					while (ss.dwCurrentState != SERVICE_RUNNING)
					{
						if (!QueryServiceStatusEx(hService, (SC_STATUS_TYPE)0, (LPBYTE)&ss, sizeof(ss), &bytesNeeded))
						{
							CloseServiceHandle(hService);
							return false;
						}
					}
					CloseServiceHandle(hService);
					return true;
				}
				CloseServiceHandle(hService);
			}
		}

		// get service path
		{
			GetNativeSystemInfo(&si);
			auto is_64_pc = (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64);

			if (!GetModuleFileNameW(0, FilePath, 1024))
			{
				CloseServiceHandle(hSCM);
				return false;
			}

			if (!SHGetSpecialFolderPathW(0, CommonPath, is_64_pc ? CSIDL_PROGRAM_FILESX86 : CSIDL_PROGRAM_FILES, FALSE))
			{
				CloseServiceHandle(hSCM);
				return false;
			}

			if (!PathRemoveFileSpecW(FilePath))
			{
				CloseServiceHandle(hSCM);
				return false;
			}

			swprintf_s(FilePath, is_64_pc ? L"%s\\BattlEye\\BEService_x64.exe" : L"%s\\BattlEye\\BEService.exe", FilePath);
			if (!SHGetSpecialFolderPathW(0, CommonPath, is_64_pc ? CSIDL_PROGRAM_FILESX86 : CSIDL_PROGRAM_FILES, FALSE))
			{
				CloseServiceHandle(hSCM);
				return false;
			}
		}

		// copy service
		{

			swprintf_s(ComPath, L"%s\\Common Files\\BattlEye", CommonPath);
			dwAttributes = GetFileAttributesW(ComPath);
			if (!(dwAttributes != INVALID_FILE_ATTRIBUTES && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)))
			{
				if (!CreateDirectoryW(ComPath, 0))
				{
					CloseServiceHandle(hSCM);
					return false;
				}
			}

			swprintf_s(ComPath, L"%s\\Common Files\\BattlEye\\BEService.exe", CommonPath);
			hFile = CreateFileW(ComPath, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				CloseHandle(hFile);
				if (!DeleteFileW(ComPath))
				{
					CloseHandle(hFile);
					CloseServiceHandle(hSCM);
					return false;
				}
			}

			if (service_path.length() == 0)
			{
				wchar_t ServicePath[1024];
				std::memset(ServicePath, 0, 1024);
				wmemcpy(ServicePath, FilePath, wcslen(FilePath));
				service_path = std::wstring(ServicePath);
			}

			
			if (!CopyFileW(FilePath, ComPath, false))
			{
				CloseServiceHandle(hSCM);
				return false;
			}
		}
		// start service
		{
			hService = 0;
			hService = CreateServiceW(hSCM,
				L"BEService",
				L"BattlEye Service",
				SERVICE_ALL_ACCESS,
				SERVICE_WIN32_OWN_PROCESS,
				SERVICE_DEMAND_START,
				SERVICE_ERROR_NORMAL,
				ComPath,
				0,
				0,
				0,
				0,
				0);
			if (hService == 0)
			{
				CloseServiceHandle(hSCM);
				return false;
			}


			if (StartServiceA(hService, 0, 0) == FALSE)
			{
				CloseServiceHandle(hService);
				CloseServiceHandle(hSCM);
				return false;
			}

			while (ss.dwCurrentState != SERVICE_RUNNING)
			{
				if (!QueryServiceStatusEx(hService, (SC_STATUS_TYPE)0, (LPBYTE)&ss, sizeof(ss), &bytesNeeded))
				{
					CloseServiceHandle(hService);
					CloseServiceHandle(hSCM);
					return false;
				}
			}
			if (hFile)
				CloseHandle(hFile);
			if (hService != 0 && hService != INVALID_HANDLE_VALUE)
				CloseServiceHandle(hService);
			if (hSCM != 0)
				CloseServiceHandle(hSCM);
		}
		return true;
	};


	/**
	 * Removes the service of BattlEye
	 *
	 * @returns The result as boolean
	 */
	auto Uninstall()->boolean
	{
		BOOL Status = false;
		SC_HANDLE hService = 0, hSCM = 0;
		DWORD cbNeeded = 0;
		SERVICE_STATUS_PROCESS ss = { 0,0,0,0,0,0,0,0,0 };
		SERVICE_STATUS ssc = { 0,0,0,0,0,0,0 };

		hSCM = OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS);
		if (hSCM == 0)
			return false;

		hService = OpenServiceA(hSCM, "BEService", SERVICE_ALL_ACCESS);

		if (hService != 0 &&
			QueryServiceStatusEx(hService, (SC_STATUS_TYPE)0, (LPBYTE)&ss, sizeof(ss), &cbNeeded))
		{
			// stop driver
			{
				if (ss.dwCurrentState == SERVICE_RUNNING)
				{
					if (ControlService(hService, SERVICE_CONTROL_STOP, &ssc) == FALSE)
					{
						CloseServiceHandle(hSCM);
						CloseServiceHandle(hService);
						return false;
					}
					while (ss.dwCurrentState != SERVICE_STOPPED)
					{
						if (!QueryServiceStatusEx(hService, (SC_STATUS_TYPE)0, (LPBYTE)&ss, sizeof(ss), &cbNeeded))
						{
							CloseServiceHandle(hSCM);
							CloseServiceHandle(hService);
							return false;
						}
					}
				}
			}

			if (DeleteService(hService) == FALSE)
			{
				CloseServiceHandle(hSCM);
				CloseServiceHandle(hService);
				return false;
			}
			// wait for driver exit
			{
				CloseServiceHandle(hService);
				hService = 0;
				while (hService != 0)
				{
					Sleep(120);
					hService = OpenServiceA(hSCM, "BEService", SERVICE_ALL_ACCESS);
					CloseServiceHandle(hService);
				}
			}
		}
		return true;
	};

	/**
	 * Gets the path where BEService is installed
	 *
	 */
	auto GetInstallationPath()->std::wstring { return service_path; };
}
```

`FakeEye/main.cpp`:

```cpp
#include "be_service.hpp"
#include "game_launcher.hpp"
#include "installer.hpp"
#include <TlHelp32.h>

int main()
{

	// install BEService
	{
		std::cout << "Starting BattlEye Service..." << std::endl;
		if (!installer::Uninstall() ||
			!installer::Install())
		{
			std::cout << "Failed to start BattlEye Service " << std::endl;
			std::cout << "Installing BattlEye Service..." << std::endl;
			if (!installer::Uninstall() ||
				!installer::Install())
			{
				std::cout << "Failed to start BattlEye Service (" << GetLastError() << ")" << std::endl;
				std::cin.get();
			}
		}
		std::cout << "Successfully installed BattlEye Service." << std::endl;
	}

	auto BEPipe = new BEService();
	// init pipe
	{
		if (!BEPipe)
		{
			std::cout << "Failed to communicate to BattlEye Service " << std::endl;
			std::cin.get();
		}

		auto EndTime = time(NULL) + 10;
		while (time(NULL) < EndTime)
		{
			Sleep(100);
			if (BEPipe->Open())
				break;
		}

		if (time(NULL) > EndTime ||
			!BEPipe->Write(BEService::PACKET_ID::INIT_SERVICE, 0))
		{
			std::cout << "Failed to communicate to BattlEye Service (" << GetLastError() << ")" << std::endl;
			std::cin.get();
		}

		std::uint8_t PipeBuffer[1024];
		std::memset(PipeBuffer, 0, 1024);

		EndTime = time(NULL) + 10;

		/* Waiting for BEs message so we can start the game */
		while (time(NULL) < EndTime)
		{
			auto BytesRead = BEPipe->Read(PipeBuffer, 1024);
			if (BytesRead != 0 && BytesRead != -1)
				break;

			Sleep(100);
		}

		if (time(NULL) > EndTime)
		{
			std::cout << "BattlEye Service timeout (" << GetLastError() << ")" << std::endl;
			std::cin.get();
		}
	}

	HANDLE hProc = INVALID_HANDLE_VALUE;
	HANDLE hThread = INVALID_HANDLE_VALUE;
	auto Pid = 0;

	// parse arguments and start game
	{
		std::wstring WCommandLine = L"";
		wchar_t ExePath[1024];
		std::memset(ExePath, 0, 1024);

		auto be_config = config_reader::ReadConfig();

		if (!be_config)
		{
			std::cout << "Config is zero" << std::endl;
			std::cin.get();
		}

		std::cout << "Launching game..." << std::endl;

		auto Exe = wcslen(be_config->Exe32) ? be_config->Exe32 : be_config->Exe64;

		/* Get the arguments from the cmdline or from the initialization file*/
		auto argc_ = 0;
		auto argv_ = CommandLineToArgvW(GetCommandLineW(), &argc_);

		// Parse process arguments
		if (argc_ > 1)
		{
			for (int i = 1; i < argc_; i++)
			{
				if (i == 1)
					WCommandLine += argv_[1];
				else
				{
					WCommandLine += L" ";
					WCommandLine += argv_[i];
				}
			}
		}

		GetModuleFileNameW(0, ExePath, 1024);
			

		swprintf_s(ExePath, L"%s/%s", std::filesystem::path(ExePath).parent_path().generic_wstring().c_str(), Exe);
		Exe = ExePath;

		if (argc_ > 1)
		{
			if (!game_handler::StartGame(const_cast<wchar_t*>(WCommandLine.c_str()), Exe, &hProc, &hThread, FALSE))
			{
				std::cout << "Failed to launch the game (" << GetLastError() << ")" << std::endl;
				delete be_config;
				std::cin.get();
			}
		}
		else
		{
			if (!game_handler::StartGame(be_config->BEArg, Exe, &hProc, &hThread, FALSE))
			{
				std::cout << "Failed to launch the game (" << GetLastError() << ")" << std::endl;
				delete be_config;
				std::cin.get();
			}
		}


		Pid = GetProcessId(hProc);
		if (!BEPipe->Write(BEService::PACKET_ID::NOTIFY_GAME_PROCESS, (void*)Pid))
		{
			TerminateProcess(hProc, 1);
			CloseHandle(hProc);
			CloseHandle(hThread);
			std::cout << "Failed to communicate to BattlEye Service (" << GetLastError() << ")" << std::endl;
			delete be_config;
			std::cin.get();
			return 0;
		}
		delete be_config;

	}



	// TODO:

	// do something with full process access:
	// ....
	
	BEPipe->Close();
	delete BEPipe;
	CloseHandle(hThread);
	CloseHandle(hProc);
	hProc = OpenProcess(SYNCHRONIZE, false, Pid);
	WaitForSingleObject(hProc,INFINITE);
	CloseHandle(hProc);
	return true;
}
```

`README.md`:

```md
# FakeEye
 A lightweight BattlEye emulator of the launcher

```