Project Path: arc_gmh5225_hardware-breakpoint_op87jwsh

Source Tree:

```txt
arc_gmh5225_hardware-breakpoint_op87jwsh
├── LICENSE
├── Makefile
├── README.md
├── doc
│   └── 硬件断点驱动解析.md
├── hw_breakpoint.c
├── include
│   ├── hw_breakpoint.h
│   ├── hw_breakpointApi.h
│   ├── hw_breakpointManage.h
│   └── hw_proc.h
├── make.sh
└── src
    ├── hw_breakpointApi.c
    ├── hw_breakpointManage.c
    └── hw_proc.c

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`Makefile`:

```
CROSS:= aarch64-linux-gnu-
KERNEL_DIR:= /home/zwf/x3_src/kernel
CURRENT_PATH:= $(shell pwd)
MODULE_NAME= hw_break

src_dir?= $(shell pwd)
export src_dir


includedir:= -I$(src_dir)/include
EXTRA_CFLAGS+= $(includedir) -g


obj-m:= $(MODULE_NAME).o
$(MODULE_NAME)-objs+= 	hw_breakpoint.o \
						src/hw_breakpointApi.o \
    					src/hw_proc.o \
    					src/hw_breakpointManage.o \
    

all: ko
# 编译驱动
ko:
	make -C $(KERNEL_DIR) M=$(CURRENT_PATH) EXTRA_CFLAGS="$(EXTRA_CFLAGS)" CROSS_COMPILE=${CROSS} ARCH=arm64 modules


clean:
	make -C $(KERNEL_DIR) M=$(CURRENT_PATH) clean
```

`README.md`:

```md
## 已实现功能
- [x] proc通过IO物理地址查询所有ioremap的虚拟地址   
- [x] proc通过符号查询符号里的内容，常用于指针变量
- [x] proc通过符号查询符号地址
- [x] proc列出所有已经插入的断点 
- [x] 通过导出的函数使用符号或地址添加删除断点
- [x] proc通过符号和地址添加删除断点


## 使用方法

这里只介绍proc接口的使用方法，代码里使用直接调对应的函数即可，接口均已导出。具体实现见[原理解析](./doc/硬件断点驱动解析.md)。

### 添加断点

```
echo add <type> <len> <symbol>/<addr> > /proc/breakpoint, add a breakpoint
	[type]:
		[wp1]: HW_BREAKPOINT_R
		[wp2]: HW_BREAKPOINT_W
		[wp3]: HW_BREAKPOINT_R|HW_BREAKPOINT_W
		 [bp]:  HW_BREAKPOINT_X
	[len]:[0,8] (2^3,2^31]
```

使用add指令可添加一个断点，长度可以是1~2^31的任意值，驱动会自动解析入参，设置一个大于期望监控地址范围的断点。触发时会根据期望监控的地址范围，选择是否打印堆栈。重复插入相同地址的断点会失败

### 删除断点

`echo del <symbol>/<addr> > /proc/breakpoint, del a breakpoint `

删除一个断点。

### 查询符号地址或数据

`echo get ptr/val <symbol> > /proc/breakpoint, search &symbol/*(&symbol)`

有些时候想监控的地址是一个指针变量的地址的话，直接输入该符号名字，就无法监控了。所以提供了一个可以查询符号里内容的操作，可以查询指针变量里的指针。然后使用`echo add <type> <len> <addr> > /proc/breakpoint`打断点。也可以查询函数地址，然后在函数地址+N的地方设置执行断点。

### 列出所有已设置的断点

`echo show > /proc/breakpoint`

该命令用于查询所有已设置的断点，信息示例如下所示：

```
--------------------------------------------------
breakpoint[6]:														/*观察断点是6~9，执行断点是0~5*/
        type:   HW_BREAKPOINT_RW									/*断点类型*/
        name:   zwf_test_value0+0x0/0xffffffffffffda78 [hw_break]	/*断点的符号名称*/
        monit:  0xffffff8000843588--->0xffffff800084358b			/*断点期望监控的地址范围*/
        len:    4													/*断点期望监控的长度*/
        mask:   0x0													/*断点的mask掩码*/
        range:  0xffffff8000843588--->0xffffff800084358c			/*断点实际监控的地址范围*/
        size:   4													/*断点实际监控的大小*/
--------------------------------------------------
breakpoint[7]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value1+0x0/0xffffffffffffd9f8 [hw_break]
        monit:  0xffffff8000843608--->0xffffff8000843610
        len:    9
        mask:   0x5
        range:  0xffffff8000843600--->0xffffff800084361f
        size:   31
--------------------------------------------------
breakpoint[8]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value2+0x0/0xffffffffffffd978 [hw_break]
        monit:  0xffffff8000843688--->0xffffff80008436d4
        len:    77
        mask:   0x7
        range:  0xffffff8000843680--->0xffffff80008436ff
        size:   127
--------------------------------------------------
breakpoint[9]:
        type:   HW_BREAKPOINT_RW
        name:   zwf_test_value3+0x0/0xffffffffffffdb00 [hw_break]
        monit:  0xffffff8000843500--->0xffffff800084357f
        len:    128
        mask:   0x8
        range:  0xffffff8000843500--->0xffffff80008435ff
        size:   255

```

### 根据IO地址查询所有映射的虚拟地址

`echo iophy <ioaddr> > /proc/breakpoint`
该功能用于监测IO地址的更改，因为同一个IO地址可能被多个地方ioremap过，所以要监测IO地址的话就先找到该IO地址对应的所有虚拟地址。
示例：
```
/home # echo iophy 0x11030000 > /proc/breakpoint
--------------------------------------------------
VM STRUCT:
     phy addr:       0x11030000              /*该vm_struct映射的物理起始地址*/
     virt addr:      0xffffff800a135000      /*物理地址对应的虚拟地址起始地址*/
     size:           0x2000                  /*vm_struct映射的内存大小*/
0x11030000 to virt: 0xffffff800a135000          /*要查询的IO地址对应的虚拟地址*/

--------------------------------------------------
VM STRUCT:
        phy addr:       0x11020000
        virt addr:      0xffffff800c780000
        size:           0x11000
0x11030000 to virt: 0xffffff800c790000

--------------------------------------------------
VM STRUCT:
        phy addr:       0x10280000
        virt addr:      0xffffff8010000000
        size:           0x79d1000
0x11030000 to virt: 0xffffff8010db0000

```


```

`doc/硬件断点驱动解析.md`:

```md

# 硬件断点是什么

硬件断点是cpu自带的用于调试程序的断点，分为执行断点和内存断点。比如armv8架构，它有4个内存断点和6个执行断点。执行断点是最常见的断点类型，就是在某个程序地址处加断点，CPU运行到这里时就会触发，触发长度是4字节。而内存断点是，监控某一个内存区间，当CPU试图访问或者是操作这块内存时就会触发，触发长度可以是[1,8]字节，或是(8,2G]字节，其中8~2G的区间内只能是2的幂。

# 硬件断点的实现机制

cpu的架构不同，硬件断点的机制也不同。通常都是配置好对应的断点寄存器后，CPU触发断点，触发调试异常，进入中断执行相应操作后退出。大概流程如下图所示：

```mermaid
flowchart TB
    CONFIG_BKREG([配置断点寄存器])
    CPU_RUN([CPU正常运行])
    CPU_TRIGER([CPU访问断点内的地址])
    INTO_ESR([CPU发生异常])
    DECODE_ESRISS([解码ISS得到异常类型为ESR_ELx_EC_BREAKPT_CUR])
    GET_ESR_ENTRY([从异常向量表中找到ESR_ELx_EC_BREAKPT_CUR对应的服务函数])
    DEBUG_HANDLE([执行服务函数])

    CONFIG_BKREG-->CPU_RUN
    CPU_RUN-->CPU_TRIGER
    CPU_TRIGER-->INTO_ESR
    INTO_ESR-->DECODE_ESRISS
    DECODE_ESRISS-->GET_ESR_ENTRY
    GET_ESR_ENTRY-->DEBUG_HANDLE

    DEBUG_HANDLE-->CPU_RUN
```

## 断点寄存器解析

以armv8为例，比如cotex-a55核心，每个断点都有2个用于控制硬件断点的寄存器。如下所示：()下面表格中的N代表第几个断点，X代表异常等级，比如el0, el1, el2)

| name          | explain                |
| ------------- | ---------------------- |
| `dbgbvrN_elX` | 执行断点地址设置寄存器 |
| `dbgbcrN_elX` | 执行断点控制寄存器     |
| `dbgwvrN_elX` | 观察断点地址设置寄存器 |
| `dbgwcrN_elX` | 观察断点控制寄存器     |

### `dbgbvrN_elX`

设置执行断点的地址，linux里直接填入对应函数的虚拟地址即可。

### `dbgbcrN_elX`

执行断点的控制寄存器，共有31BIT。用于控制断点的各种属性。具体如下所示：

| 31~24 | 23~20 | 19~16 | 15~14 |  13  | 12~9 | 8~5  | 4~3  | 2~1  |  0   |
| :---: | :---: | :---: | :---: | :--: | :--: | :--: | :--: | :--: | :--: |
| RES2  |  BT   |  LBN  |  SSC  | HMC  | RES1 | BAS  | RES0 | PMC  |  E   |

其中比较常用的是E, PMC, BT。

* E是断点使能位，高位使能。
* PMC用于记录上次控制时的异常等级，配合HMC和SSC一起使用
* BT是控制断点触发的条件，默认是0b0000，对应的触发条件是当地址匹配时触发。

### `dbgwvrN_elX`

设置观察断点的地址，linux里直接填入想观察的内存区域的起始地址即可。

### `dbgwcrN_elX`

观察断点的控制寄存器，共有31bit，用于控制观察断点的各种属性。具体如下所示：

| 31~29 | 28~24 | 23~21 |  20  | 19~16 | 15~14 |  13  | 12~5 | 4~3  | 2~1  |  0   |
| ----- | :---: | :---: | :--: | :---: | :---: | :--: | :--: | :--: | :--: | :--: |
| RES1  | MASK  | RES0  |  WT  |  LBN  |  SSC  | HMC  | BAS  | LSC  | PAC  |  E   |

其中比较常用的是E, PAC, BAS, MASK。

* E是断点使能位，高位使能。
* PAC用于记录上次控制时的异常等级，配合HMC和SSC一起使用
* BAS一共8bit，代表要监控的内存大小，每1bit代表1byte，最大可检测8bytes。
* MASK代表使用掩码的模式监控地址，共有5bit，代表可以掩掉dbgwvrN_elX中的0~31位低地址。

#### MASK举例

比如想监控的地址是 `0xffffffc0622a5c10, MASK=0b00111`

则监控的范围是：`0xffffffc0622a5c00~0xffffffc0622a5c7f`，实际的 `dbgwcrN_elX=0xffffffc0622a5c00`

假如 `MASK=0b01100`

则监控的范围是：`0xffffffc0622a5000~0xffffffc0622a5fff`，实际的 `dbgwcrN_elX=0xffffffc0622a5000`

# 实现硬件断点驱动

在linux内核里其实有硬件断点功能，但是这个硬件断点不太好用，它依赖太多的配置选项。开了这些配置选项除了内核需要重编之外，由于头文件变更过大，所以所有的驱动也要重编。而且内核的硬件断点只能监控8字节，也不支持设置断点触发事件，自定义属性太少。

## 硬件断点需要实现的部分

实现硬件断点驱动，主要是需要实现以下几部分：

1. 注册自己的断点异常服务函数。
2. 根据设定的地址和长度自动解析需配置的硬件断点寄存器值。
3. 设置硬件断点寄存器。

## 硬件断点实现需要的内核接口

上述部分的实现依赖一些内核接口，这些接口内核是没有导出符号的，不过只要开启了 `CONFIG_KALLSYMS=y`，函数都是可以查询的到的。

涉及的接口如下：

```c
typedef struct HW_kernelApi
{
    struct
    {
        unsigned long (*kallsyms_lookup_name)(const char *name); /*根据符号查询地址函数*/
        void (*register_step_hook)(struct step_hook *hook);      /*注册step调试异常hook的函数*/
        void (*unregister_step_hook)(struct step_hook *hook);    /*取消注册step调试异常hook的函数*/
        void (*enable_debug_monitors)(enum dbg_active_el el);    /*使能debug异常*/
        void (*disable_debug_monitors)(enum dbg_active_el el);   /*失能debug异常*/
        int (*kernel_active_single_step)(void);                  /*单步调试是否激活*/
        void (*kernel_enable_single_step)(struct pt_regs *regs); /*使能单步调试异常*/
        void (*kernel_disable_single_step)(void);                /*失能单步调试异常*/
        u64 (*read_sanitised_ftr_reg)(u32 id);                   /*读ftr寄存器*/
        void (*show_regs)(struct pt_regs *);                     /*显示堆栈*/
        void (*do_bad)(unsigned long addr, unsigned int esr, struct pt_regs *regs); /*调试异常的默认中断处理函数*/
    } __aligned(128) fun;
    struct
    {
#ifdef CONFIG_CPU_PM
        u64 *hw_breakpoint_restore;         /*cpu从调试暂停恢复运行时执行的函数*/
        u64  default_hw_breakpoint_restore; /*接管之前的函数地址*/
#endif
        struct fault_info *debug_fault_info;      /*接管硬件断点调试异常中断，替换回调函数*/
        struct fault_info  default_fault_info[2]; /*接管之前的数据信息*/
    } __aligned(128) val;
} HW_kernelApi;
```

我记得在linux 5.7.0之后的内核版本，kallsyms_lookup_name这个根据符号查询地址的函数，是不再导出了。所以驱动中需要先找到这个符号的地址，再用这个地址去查询其余需要的内核接口即可。寻找kallsyms_lookup_name的代码如下：

```c
/*根据名字找函数地址*/
unsigned long kaddr_lookup_name(const char *fname_raw)
{
    int           i;
    unsigned long kaddr;
    char         *fname_lookup, *fname;

    fname_lookup = kzalloc(NAME_MAX, GFP_KERNEL);
    if (!fname_lookup)
        return 0;

    fname = kzalloc(strlen(fname_raw) + 4, GFP_KERNEL);
    if (!fname)
        return 0;

    /*第一个0x0代表是该符号的起始地址*/
    strcpy(fname, fname_raw);
    strcat(fname, "+0x0");

    /*获取内核代码段基地址*/
    kaddr  = (unsigned long)&sprint_symbol;
    kaddr &= 0xffffffffff000000;

    /*内核符号不会超过0x100000*16的大小，所以按4字节偏移，挨个找*/
    for (i = 0x0; i < 0x400000; i++)
    {
        /*寻找地址对应的符号名称*/
        sprint_symbol(fname_lookup, kaddr);
        /*对比寻找的符号名字*/
        if (strncmp(fname_lookup, fname, strlen(fname)) == 0)
        {
            /*找到了就返回地址*/
            kfree(fname_lookup);
            kfree(fname);
            return kaddr;
        }
        /*偏移4字节*/
        kaddr += 0x04;
    }
    /*没找到地址就返回0*/
    kfree(fname_lookup);
    kfree(fname);
    return 0;
}
```

## 解析要设置断点信息

对于使用者来说，是不需要关注每个断点寄存器应该配什么值，只需要知道以下几点就行了：

1. 断点类型：执行断点或是读/写断点。
2. 断点地址
3. 断点监控的长度

所以这部分需要解析对应调用者传入的参数，自动解析出寄存器需要配置的值。流程如下：

```mermaid
flowchart LR
	%% 设置曲线样式
	%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
    TYPE([BK TYPE])
    ADDR([BK ADDR])
    LEN([BK LEN])

    subgraph BP
    	direction LR
        dbgbvr([dbgbvr=addr])
        dbgbcr([dbgbcr.EN=1,\n.BT=0\n.bas=0b1111])

    end
    TYPE-->BP
    ADDR-->dbgbvr
    LEN-->|len=4|dbgbcr

    subgraph WP
    	direction TB
        len[[len>8?]]
        BASWl([dbgwcr.bas=0blen*1])
        dbgwvr([dbgwvr=addr])
    
        getBaseMask(["mask=log2(len)"])
        ifMask[["2^mask*bit=1 > addr+len?"]]
        maskAdd(["mask=mask+1"])
        MASK(["dbgwcr.mask=mask"])
    
    
    
    
        len-->|否|BASWl
        len-->|是|getBaseMask
        getBaseMask-->ifMask
        ifMask-->|是|MASK
        ifMask-->|否|maskAdd
        maskAdd-->ifMask
    end
  
    LEN-->len
    ADDR-->dbgwvr
    TYPE-->WP

```

## 实现断点异常服务函数

以观察断点服务函数为例，当一个观察断点触发时需要如下几步。

1. 先关闭所有观察断点，防止其一直触发。
2. 遍历所有已设置的观察断点，求出触发的地址与设置的地址正向距离最近的那个断点。
3. 取出断点数据结构，筛选该地址是否在期望监控的地址范围内。
4. 执行用户函数。
5. 在当前regs开启single step
6. 进入single step异常服务函数
7. 重新开启断点。

至此整个流程完毕，执行断点流程类似。代码如下所示：

```c
/*watchpoint回调函数*/
static int HW_watchpointHandler(unsigned long addr, unsigned int esr, struct pt_regs *regs)
{
    int                       i, *kernel_step, access, closest_match = -1;
    u64                       min_dist = -1, dist;
    u32                       ctrl_reg;
    u64                       val, startAddr, endAddr;
    struct HW_breakpointInfo *wp, **slots;
    // struct debug_info *debug_info;
    HW_breakpointVC     *info = NULL;
    HW_breakpointCtrlReg ctrl;

    slots = this_cpu_ptr(wp_on_reg);
    // debug_info = &current->thread.debug;

    /*
	 * Find all watchpoints that match the reported address. If no exact
	 * match is found. Attribute the hit to the closest watchpoint.
	 */
    rcu_read_lock();
    for (i = 0; i < core_num_wrps; ++i)
    {
        wp = slots[i];
        if (wp == NULL)
            continue;

        /*
		 * Check that the access type matches.
		 * 0 => load, otherwise => store
		 */
        access = (esr & AARCH64_ESR_ACCESS_MASK) ? HW_BREAKPOINT_W : HW_BREAKPOINT_R;
        if (!(access /*& hw_breakpoint_type(wp)待实现，将wp与attr->type关联*/))
            continue;

        /* Check if the watchpoint value and byte select match. */
        val      = HW_readBreakpointReg(AARCH64_DBG_REG_WVR, i);
        ctrl_reg = HW_readBreakpointReg(AARCH64_DBG_REG_WCR, i);
        HW_decodeCtrlReg(ctrl_reg, &ctrl);
        dist = HW_getDistanceFromWatchpoint(addr, wp->attr.addr, &ctrl);
        if (dist < min_dist)
        {
            min_dist      = dist;
            closest_match = i;
        }
        /* Is this an exact match? */
        if (dist != 0)
            continue;
        info          = HW_counterArchbp(wp);
        info->trigger = addr;
        closest_match = i;
    }
    if (min_dist > 0 && min_dist != -1)
    {
        /* No exact match found. */
        wp            = slots[closest_match];
        info          = HW_counterArchbp(wp);
        info->trigger = addr;
    }
    rcu_read_unlock();

    /*关闭所有断点*/
    HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL0, 0);
    HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 0);
    kernel_step = this_cpu_ptr(&stepping_kernel_bp);

    // printk("watchpoint is trigger,addr=0x%lx, close = %d, dist = %d, mindist = %d, info = %lx\n",
    //        addr, closest_match, dist, min_dist);
    if (info)
    {
        wp = container_of(info, struct HW_breakpointInfo, info);
        if (addr >= wp->attr.addr && addr < wp->attr.addr + wp->attr.len)
        {
            /*在期望检测的地址范围之内，才打印堆栈信息*/
            printk("wp is triger = 0x%llx, addr = 0x%llx, len = %d\n", addr, wp->attr.addr, wp->attr.len);
            kernelApi.fun.show_regs(regs);
        }
        info->trigger = 0;
    }

    if (*kernel_step != ARM_KERNEL_STEP_NONE)
        return 0;

    if (kernelApi.fun.kernel_active_single_step())
    {
        *kernel_step = ARM_KERNEL_STEP_SUSPEND;
    }
    else
    {
        *kernel_step = ARM_KERNEL_STEP_ACTIVE;
        /*在当前regs触发step异常*/
        kernelApi.fun.kernel_enable_single_step(regs);
    }
    // }

    return 0;
}
```

## 注册调试异常服务函数

当断点触发时，是会进入到内核的调试异常服务函数，这个函数里会解析异常类型，去运行对应的断点调试异常函数。内核默认的断点调试异常函数是 `do_bad`，这是一个空函数。需要将这个函数替换为我们自己对应的服务函数。

```c
    /* 注册调试异常回调函数 */
    /*执行断点*/
    /*保存原先的变量*/
    kernelApi.val.default_fault_info[0].fn   = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn;
    kernelApi.val.default_fault_info[0].sig  = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig;
    kernelApi.val.default_fault_info[0].code = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code;
    kernelApi.val.default_fault_info[0].name = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name;
    /*注册新的内容*/
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn   = HW_breakpointHandler;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig  = SIGTRAP;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code = TRAP_HWBKPT;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name = "hw-breakpoint handler";
    /*内存断点*/
    /*保存原先的变量*/
    kernelApi.val.default_fault_info[1].fn   = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn;
    kernelApi.val.default_fault_info[1].sig  = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig;
    kernelApi.val.default_fault_info[1].code = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code;
    kernelApi.val.default_fault_info[1].name = kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name;
    /*注册新的内容*/
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn   = HW_watchpointHandler;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig  = SIGTRAP;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code = TRAP_HWBKPT;
    kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name = "hw-watchpoint handler";
    kernelApi.fun.register_step_hook(&gHwStepHook);

#ifdef CONFIG_CPU_PM
    /*注册cpu暂停后恢复断点的回调函数*/
    /*保存原先的变量*/
    kernelApi.val.default_hw_breakpoint_restore = *kernelApi.val.hw_breakpoint_restore;
    *kernelApi.val.hw_breakpoint_restore        = (u64)HW_breakpointReset;
#endif
```

# 已实现的硬件断点驱动

目前的话，该驱动已经实现。详情可参考[硬件断点仓库](https://gitee.com/SmartSmallBoy/hardware-breakpoint)。

目前只依赖两个内核选项：

1. `CONFIG_KALLSYMS=y`
2. `CONFIG_KALLSYMS_ALL=y`

linux 4.19~6.0内核均已测试，可以直接使用。

该驱动共分为3部分，分为底层实现，多核CPU的断点同步管理，API接口开放。

## 底层实现

底层实现包括设置对应的硬件断点寄存器，监控设置的地址，注册调试异常 `hook`等，注册单步异常 `hook`。

## 多核心CPU的断点同步管理

上述的底层实现只是实现单核 `CPU`断点的设置。假如在一个多核心的 `CPU`上要监视某个内存地址的读写行为，那肯定是要监控所有 `CPU`对该地址的读写行为，只监控当前 `CPU`的访问肯定是不够的。所以该部分是对上述底层的封装，对所有运行的核心进行遍历，通过多核同步机制(`smp_call_function_single`)，给所有核心打上/删除相同的断点。

## API接口开放

该部分集中管理所有通过API接口设置的断点，对外开放设置断点的接口，可选择和 `KGDB`联动，实现断点触发后的源码级调试。分为如下几个部分：

1. 直接通过地址设置断点。
2. 通过符号名字设置断点。
3. 在启用 `kgdb`联动功能后，可以通过 `kgdb`的设置断点功能设置硬件断点。
4. 在 `shell`下通过 `proc`调试文件来设置断点。
5. 查询符号地址。
6. 查询符号地址里的内容（针对指针变量使用）。

断点监测的虚拟地址范围最大为2Gb。当断点被触发时，会打印出当时操作这块内存的堆栈信息，便于问题定位，或是代码的深度理解。若是启用了 `KGDB`的联动功能，则会在打出堆栈信息后，进入 `KGDB`状态，等待远程主机连接调试。`KGDB`的原来及使用可以参考我的前一篇文章[KGDB原理分析及远程挂载调试ARM64内核](https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2Fqq_38384263%2Farticle%2Fdetails%2F132290737%3Fspm%3D1001.2014.3001.5502)。


```

`hw_breakpoint.c`:

```c
#include "hw_breakpoint.h"
#include <linux/module.h>
#include "asm/uaccess.h"
#include <asm-generic/kprobes.h>
#include "hw_breakpointApi.h"
#include "hw_proc.h"
#include "hw_breakpointManage.h"
#include "linux/kallsyms.h"
#include "linux/slab.h"

enum hw_breakpoint_ops {
	HW_BREAKPOINT_INSTALL,
	HW_BREAKPOINT_UNINSTALL,
	HW_BREAKPOINT_RESTORE
};

/* Breakpoint currently in use for each BRP. */
static DEFINE_PER_CPU(struct HW_breakpointInfo *, bp_on_reg[ARM_MAX_BRP]);

/* Watchpoint currently in use for each WRP. */
static DEFINE_PER_CPU(struct HW_breakpointInfo *, wp_on_reg[ARM_MAX_WRP]);

/* Currently stepping a per-CPU kernel breakpoint. */
static DEFINE_PER_CPU(int, stepping_kernel_bp);

/* Number of BRP/WRP registers on this CPU. */
static int core_num_brps;
static int core_num_wrps;

HW_kernelApi kernelApi;

/*获取断点数量*/
int HW_getBreakpointNum(int type)
{
	/*
     * We can be called early, so don't rely on
     * our static variables being initialised.
     */
	switch (type) {
	case TYPE_INST:
		return HW_getNumBrps();
	case TYPE_DATA:
		return HW_getNumWrps();
	default:
		printk("unknown slot type: %d\n", type);
		return 0;
	}
}

#define READ_WB_REG_CASE(OFF, N, REG, VAL)     \
	case (OFF + N):                        \
		AARCH64_DBG_READ(N, REG, VAL); \
		break

#define WRITE_WB_REG_CASE(OFF, N, REG, VAL)     \
	case (OFF + N):                         \
		AARCH64_DBG_WRITE(N, REG, VAL); \
		break

#define GEN_READ_WB_REG_CASES(OFF, REG, VAL) \
	READ_WB_REG_CASE(OFF, 0, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 1, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 2, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 3, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 4, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 5, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 6, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 7, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 8, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 9, REG, VAL);  \
	READ_WB_REG_CASE(OFF, 10, REG, VAL); \
	READ_WB_REG_CASE(OFF, 11, REG, VAL); \
	READ_WB_REG_CASE(OFF, 12, REG, VAL); \
	READ_WB_REG_CASE(OFF, 13, REG, VAL); \
	READ_WB_REG_CASE(OFF, 14, REG, VAL); \
	READ_WB_REG_CASE(OFF, 15, REG, VAL)

#define GEN_WRITE_WB_REG_CASES(OFF, REG, VAL) \
	WRITE_WB_REG_CASE(OFF, 0, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 1, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 2, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 3, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 4, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 5, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 6, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 7, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 8, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 9, REG, VAL);  \
	WRITE_WB_REG_CASE(OFF, 10, REG, VAL); \
	WRITE_WB_REG_CASE(OFF, 11, REG, VAL); \
	WRITE_WB_REG_CASE(OFF, 12, REG, VAL); \
	WRITE_WB_REG_CASE(OFF, 13, REG, VAL); \
	WRITE_WB_REG_CASE(OFF, 14, REG, VAL); \
	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)

/*读寄存器*/
static u64 HW_readBreakpointReg(int reg, int n)
{
	u64 val = 0;

	switch (reg + n) {
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BVR,
				      AARCH64_DBG_REG_NAME_BVR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BCR,
				      AARCH64_DBG_REG_NAME_BCR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WVR,
				      AARCH64_DBG_REG_NAME_WVR, val);
		GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WCR,
				      AARCH64_DBG_REG_NAME_WCR, val);
	default:
		printk("attempt to read from unknown breakpoint register %d\n",
		       n);
	}

	return val;
}
NOKPROBE_SYMBOL(HW_readBreakpointReg);

/*写寄存器*/
static void HW_writeBreakpointReg(int reg, int n, u64 val)
{
	switch (reg + n) {
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BVR,
				       AARCH64_DBG_REG_NAME_BVR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BCR,
				       AARCH64_DBG_REG_NAME_BCR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WVR,
				       AARCH64_DBG_REG_NAME_WVR, val);
		GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WCR,
				       AARCH64_DBG_REG_NAME_WCR, val);
	default:
		printk("attempt to write to unknown breakpoint register %d\n",
		       n);
	}
	/*清空流水线，确保在执行新的指令前，之前的指令都已经完成*/
	isb();
}
NOKPROBE_SYMBOL(HW_writeBreakpointReg);

/*获取异常等级*/
static enum dbg_active_el HW_getDebugExceptionLevel(int privilege)
{
	switch (privilege) {
	case AARCH64_BREAKPOINT_EL0:
		return DBG_ACTIVE_EL0;
	case AARCH64_BREAKPOINT_EL1:
		return DBG_ACTIVE_EL1;
	default:
		printk("invalid breakpoint privilege level %d\n", privilege);
		return -EINVAL;
	}
}
NOKPROBE_SYMBOL(HW_getDebugExceptionLevel);

/*
判断该断点是否是兼容断点？？
内核态调用register_wide_hw_breakpoint创建断点时,task参数传递的是NULL，故此直接返回false
*/
static int HW_isCompatBp(struct HW_breakpointInfo *bp)
{
	//待实现
	return 0;
}

/**
 * HW_breakpointSlotSetup - 在断点的全局变量数组中插入/删除一个断点
 *
 * @slots: 指向全局变量数组的指针
 * @max_slots: 支持的最大断点数量
 * @bp: 要操作的断点
 * @ops: 断点的操作类型：插入/删除
 *
 * Return:
 *    成功返回操作的第几个断点
 *    -ENOSPC 没有可插入的空闲断点或要删除的断点在全局变量中搜索不到
 *    -EINVAL 错误的操作类型
 */
static int HW_breakpointSlotSetup(struct HW_breakpointInfo **slots,
				  int max_slots, struct HW_breakpointInfo *bp,
				  enum hw_breakpoint_ops ops)
{
	int i;
	struct HW_breakpointInfo **slot;

	for (i = 0; i < max_slots; ++i) {
		slot = &slots[i];
		switch (ops) {
		case HW_BREAKPOINT_INSTALL:
			if (!*slot) {
				*slot = bp;
				return i;
			}
			break;
		case HW_BREAKPOINT_UNINSTALL:
			if (*slot == bp) {
				*slot = NULL;
				return i;
			}
			break;
		case HW_BREAKPOINT_RESTORE:
			if (*slot == bp)
				return i;
			break;
		default:
			printk("Unhandled hw breakpoint ops %d\n", ops);
			return -EINVAL;
		}
	}
	return -ENOSPC;
}

/*断点的install/uninstall*/
static int HW_breakpointControl(struct HW_breakpointInfo *bp,
				enum hw_breakpoint_ops ops)
{
	HW_breakpointVC *info = HW_counterArchbp(bp);
	struct HW_breakpointInfo **slots;
	int i, max_slots, ctrl_reg, val_reg;
	enum dbg_active_el dbg_el =
		HW_getDebugExceptionLevel(info->ctrl.privilege);
	u32 ctrl;

	printk("the real CPU = %d\n", raw_smp_processor_id());

	if (info->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
		/* Breakpoint */
		ctrl_reg = AARCH64_DBG_REG_BCR;
		val_reg = AARCH64_DBG_REG_BVR;
		slots = this_cpu_ptr(bp_on_reg);
		max_slots = core_num_brps;
	} else {
		/* Watchpoint */
		ctrl_reg = AARCH64_DBG_REG_WCR;
		val_reg = AARCH64_DBG_REG_WVR;
		slots = this_cpu_ptr(wp_on_reg);
		max_slots = core_num_wrps;
	}

	i = HW_breakpointSlotSetup(slots, max_slots, bp, ops);

	if (WARN_ONCE(i < 0, "Can't find any breakpoint slot"))
		return i;

	switch (ops) {
	case HW_BREAKPOINT_INSTALL:
		/*
     * Ensure debug monitors are enabled at the correct exception
     * level.
     */
		kernelApi.fun.enable_debug_monitors(dbg_el);
		/* Fall through */
	case HW_BREAKPOINT_RESTORE:
		/* Setup the address register. */
		HW_writeBreakpointReg(val_reg, i, info->address);

		/* Setup the control register. */
		ctrl = HW_encodeCtrlReg(info->ctrl);
		printk("CTRL REG = %x\n", ctrl);
		HW_writeBreakpointReg(ctrl_reg, i, ctrl);
		break;
	case HW_BREAKPOINT_UNINSTALL:
		/* Reset the control register. */
		HW_writeBreakpointReg(ctrl_reg, i, 0);

		/*
     * Release the debug monitors for the correct exception
     * level.
     */
		kernelApi.fun.disable_debug_monitors(dbg_el);
		break;
	}

	return 0;
}

/*
 * Install a perf counter breakpoint.
 */
int HW_breakpointInstall(struct HW_breakpointInfo *bp)
{
	return HW_breakpointControl(bp, HW_BREAKPOINT_INSTALL);
}

int HW_breakpointUninstall(struct HW_breakpointInfo *bp)
{
	return HW_breakpointControl(bp, HW_BREAKPOINT_UNINSTALL);
}

static int HW_getHbpLen(u8 hbp_len)
{
	unsigned int len_in_bytes = 0;

	switch (hbp_len) {
	case ARM_BREAKPOINT_LEN_1:
		len_in_bytes = 1;
		break;
	case ARM_BREAKPOINT_LEN_2:
		len_in_bytes = 2;
		break;
	case ARM_BREAKPOINT_LEN_3:
		len_in_bytes = 3;
		break;
	case ARM_BREAKPOINT_LEN_4:
		len_in_bytes = 4;
		break;
	case ARM_BREAKPOINT_LEN_5:
		len_in_bytes = 5;
		break;
	case ARM_BREAKPOINT_LEN_6:
		len_in_bytes = 6;
		break;
	case ARM_BREAKPOINT_LEN_7:
		len_in_bytes = 7;
		break;
	case ARM_BREAKPOINT_LEN_8:
		len_in_bytes = 8;
		break;
	}

	return len_in_bytes;
}

/*
 * Check whether bp virtual address is in kernel space.
 */
int HW_archCheckBpInKernelspace(HW_breakpointVC *hw)
{
	unsigned int len;
	unsigned long va;

	va = hw->address;
	len = HW_getHbpLen(hw->ctrl.len);

	return (va >= TASK_SIZE) && ((va + len - 1) >= TASK_SIZE);
}

/*
 * Extract generic type and length encodings from an arch_hw_breakpoint_ctrl.
 * Hopefully this will disappear when ptrace can bypass the conversion
 * to generic breakpoint descriptions.
 */
int HW_archGetBpGenericFields(HW_breakpointCtrlReg ctrl, int *gen_len,
			      int *gen_type, int *offset)
{
	/* Type */
	switch (ctrl.type) {
	case ARM_BREAKPOINT_EXECUTE:
		*gen_type = HW_BREAKPOINT_X;
		break;
	case ARM_BREAKPOINT_LOAD:
		*gen_type = HW_BREAKPOINT_R;
		break;
	case ARM_BREAKPOINT_STORE:
		*gen_type = HW_BREAKPOINT_W;
		break;
	case ARM_BREAKPOINT_LOAD | ARM_BREAKPOINT_STORE:
		*gen_type = HW_BREAKPOINT_RW;
		break;
	default:
		return -EINVAL;
	}

	if (!ctrl.len)
		return -EINVAL;
	*offset = __ffs(ctrl.len);

	/* Len */
	switch (ctrl.len >> *offset) {
	case ARM_BREAKPOINT_LEN_1:
		*gen_len = HW_BREAKPOINT_LEN_1;
		break;
	case ARM_BREAKPOINT_LEN_2:
		*gen_len = HW_BREAKPOINT_LEN_2;
		break;
	case ARM_BREAKPOINT_LEN_3:
		*gen_len = HW_BREAKPOINT_LEN_3;
		break;
	case ARM_BREAKPOINT_LEN_4:
		*gen_len = HW_BREAKPOINT_LEN_4;
		break;
	case ARM_BREAKPOINT_LEN_5:
		*gen_len = HW_BREAKPOINT_LEN_5;
		break;
	case ARM_BREAKPOINT_LEN_6:
		*gen_len = HW_BREAKPOINT_LEN_6;
		break;
	case ARM_BREAKPOINT_LEN_7:
		*gen_len = HW_BREAKPOINT_LEN_7;
		break;
	case ARM_BREAKPOINT_LEN_8:
		*gen_len = HW_BREAKPOINT_LEN_8;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

/*
 * Construct an arch_hw_breakpoint from a perf_event.
 */
static int HW_archBuildBpInfo(struct HW_breakpointInfo *bp,
			      const HW_breakpointAttr *attr,
			      HW_breakpointVC *hw)
{
	/* Type */
	switch (attr->type) {
	case HW_BREAKPOINT_X:
		hw->ctrl.type = ARM_BREAKPOINT_EXECUTE;
		break;
	case HW_BREAKPOINT_R:
		hw->ctrl.type = ARM_BREAKPOINT_LOAD;
		break;
	case HW_BREAKPOINT_W:
		hw->ctrl.type = ARM_BREAKPOINT_STORE;
		break;
	case HW_BREAKPOINT_RW:
		hw->ctrl.type = ARM_BREAKPOINT_LOAD | ARM_BREAKPOINT_STORE;
		break;
	default:
		return -EINVAL;
	}

	/* Len */
	switch (attr->realLen) {
	case HW_BREAKPOINT_LEN_1:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_1;
		break;
	case HW_BREAKPOINT_LEN_2:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_2;
		break;
	case HW_BREAKPOINT_LEN_3:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_3;
		break;
	case HW_BREAKPOINT_LEN_4:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_4;
		break;
	case HW_BREAKPOINT_LEN_5:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_5;
		break;
	case HW_BREAKPOINT_LEN_6:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_6;
		break;
	case HW_BREAKPOINT_LEN_7:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_7;
		break;
	case HW_BREAKPOINT_LEN_8:
		hw->ctrl.len = ARM_BREAKPOINT_LEN_8;
		break;
	default:
		return -EINVAL;
	}

	/*
     * On AArch64, we only permit breakpoints of length 4, whereas
     * AArch32 also requires breakpoints of length 2 for Thumb.
     * Watchpoints can be of length 1, 2, 4 or 8 bytes.
     */
	if (hw->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
		/*
     * FIXME: Some tools (I'm looking at you perf) assume
     *      that breakpoints should be sizeof(long). This
     *      is nonsense. For now, we fix up the parameter
     *      but we should probably return -EINVAL instead.
     */
		hw->ctrl.len = ARM_BREAKPOINT_LEN_4;
	}
	/*地址掩码*/
	hw->ctrl.mask = attr->mask;
	/* Address */
	hw->address = attr->startAddr;

	/*
     * Privilege
     * Note that we disallow combined EL0/EL1 breakpoints because
     * that would complicate the stepping code.
     */
	if (HW_archCheckBpInKernelspace(hw))
		hw->ctrl.privilege = AARCH64_BREAKPOINT_EL1;
	else
		hw->ctrl.privilege = AARCH64_BREAKPOINT_EL0;

	/* Enabled? */
	hw->ctrl.enabled = !attr->disabled;

	return 0;
}

/*
 * 解析并配置断点信息
 */
int HW_breakpointArchParse(struct HW_breakpointInfo *bp,
			   const HW_breakpointAttr *attr, HW_breakpointVC *hw)
{
	int ret;

	/* Build the arch_hw_breakpoint. */
	ret = HW_archBuildBpInfo(bp, attr, hw);
	if (ret)
		return ret;

	printk("ctrl.len=%x,mask=%d,enabled=%d,address=%llx\n", hw->ctrl.len,
	       hw->ctrl.mask, hw->ctrl.enabled, hw->address);

	/*
     * Disallow per-task kernel breakpoints since these would
     * complicate the stepping code.
     */
	if (hw->ctrl.privilege == AARCH64_BREAKPOINT_EL1 && NULL)
		return -EINVAL;

	return 0;
}

/*
enable/disable一个断点
 */
static void HW_toggleBpRegisters(int reg, enum dbg_active_el el, int enable)
{
	int i, max_slots, privilege;
	u32 ctrl;
	struct HW_breakpointInfo **slots;

	switch (reg) {
	case AARCH64_DBG_REG_BCR:
		slots = this_cpu_ptr(bp_on_reg);
		max_slots = core_num_brps;
		break;
	case AARCH64_DBG_REG_WCR:
		slots = this_cpu_ptr(wp_on_reg);
		max_slots = core_num_wrps;
		break;
	default:
		return;
	}

	for (i = 0; i < max_slots; ++i) {
		if (!slots[i])
			continue;

		privilege = HW_counterArchbp(slots[i])->ctrl.privilege;
		if (HW_getDebugExceptionLevel(privilege) != el)
			continue;

		ctrl = HW_readBreakpointReg(reg, i);
		if (enable)
			ctrl |= 0x1;
		else
			ctrl &= ~0x1;
		HW_writeBreakpointReg(reg, i, ctrl);
	}
}
NOKPROBE_SYMBOL(HW_toggleBpRegisters);

/*breakpoint回调函数*/
static int HW_breakpointHandler(unsigned long unused, unsigned int esr,
				struct pt_regs *regs)
{
	int i, *kernel_step;
	u32 ctrl_reg;
	u64 addr, val;
	struct HW_breakpointInfo *bp, **slots;
	// struct debug_info *debug_info;
	HW_breakpointCtrlReg ctrl;

	slots = this_cpu_ptr(bp_on_reg);
	addr = instruction_pointer(regs);
	// debug_info = &current->thread.debug;

	for (i = 0; i < core_num_brps; ++i) {
		rcu_read_lock();

		bp = slots[i];

		if (bp == NULL)
			goto unlock;

		/* Check if the breakpoint value matches. */
		val = HW_readBreakpointReg(AARCH64_DBG_REG_BVR, i);
		if (val != (addr & ~0x3))
			goto unlock;

		/* Possible match, check the byte address select to confirm. */
		ctrl_reg = HW_readBreakpointReg(AARCH64_DBG_REG_BCR, i);
		HW_decodeCtrlReg(ctrl_reg, &ctrl);
		if (!((1 << (addr & 0x3)) & ctrl.len))
			goto unlock;

		HW_counterArchbp(bp)->trigger = addr;

unlock:
		rcu_read_unlock();
	}

	HW_toggleBpRegisters(AARCH64_DBG_REG_BCR, DBG_ACTIVE_EL1, 0);
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (*kernel_step != ARM_KERNEL_STEP_NONE)
		return 0;

	if (kernelApi.fun.kernel_active_single_step()) {
		*kernel_step = ARM_KERNEL_STEP_SUSPEND;
	} else {
		*kernel_step = ARM_KERNEL_STEP_ACTIVE;
		kernelApi.fun.kernel_enable_single_step(regs);
	}
	// }

	return 0;
}
NOKPROBE_SYMBOL(HW_breakpointHandler);

/*
 * Arm64 hardware does not always report a watchpoint hit address that matches
 * one of the watchpoints set. It can also report an address "near" the
 * watchpoint if a single instruction access both watched and unwatched
 * addresses. There is no straight-forward way, short of disassembling the
 * offending instruction, to map that address back to the watchpoint. This
 * function computes the distance of the memory access from the watchpoint as a
 * heuristic for the likelyhood that a given access triggered the watchpoint.
 *
 * See Section D2.10.5 "Determining the memory location that caused a Watchpoint
 * exception" of ARMv8 Architecture Reference Manual for details.
 *
 * The function returns the distance of the address from the bytes watched by
 * the watchpoint. In case of an exact match, it returns 0.
 */
static u64 HW_getDistanceFromWatchpoint(unsigned long addr, u64 val,
					HW_breakpointCtrlReg *ctrl)
{
	addr = untagged_addr(addr);
	val = untagged_addr(val);
	return addr - val;
}

/*watchpoint回调函数*/
static int HW_watchpointHandler(unsigned long addr, unsigned int esr,
				struct pt_regs *regs)
{
	int i, *kernel_step, access, closest_match = -1;
	u64 min_dist = -1, dist;
	u32 ctrl_reg;
	u64 val, startAddr, endAddr;
	struct HW_breakpointInfo *wp, **slots;
	HW_breakpointVC *info = NULL;
	HW_breakpointCtrlReg ctrl;

	slots = this_cpu_ptr(wp_on_reg);
	// debug_info = &current->thread.debug;

	/*寻找最近的触发地址*/
	rcu_read_lock();
	for (i = 0; i < core_num_wrps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;

		/*检测触发的断点类型*/
		access = (esr & AARCH64_ESR_ACCESS_MASK) ? HW_BREAKPOINT_W :
							   HW_BREAKPOINT_R;
		if (!(access /*& hw_breakpoint_type(wp)待实现，将wp与attr->type关联*/))
			continue;

		/* Check if the watchpoint value and byte select match. */
		val = HW_readBreakpointReg(AARCH64_DBG_REG_WVR, i);
		ctrl_reg = HW_readBreakpointReg(AARCH64_DBG_REG_WCR, i);
		HW_decodeCtrlReg(ctrl_reg, &ctrl);
		dist = HW_getDistanceFromWatchpoint(addr, wp->attr.addr, &ctrl);
		if (dist < min_dist) {
			min_dist = dist;
			closest_match = i;
		}
		/* Is this an exact match? */
		if (dist != 0)
			continue;
		info = HW_counterArchbp(wp);
		info->trigger = addr;
		closest_match = i;
	}
	if (min_dist > 0 && min_dist != -1) {
		/* No exact match found. */
		wp = slots[closest_match];
		info = HW_counterArchbp(wp);
		info->trigger = addr;
	}
	rcu_read_unlock();

	/*
     * We always disable EL0 watchpoints because the kernel can
     * cause these to fire via an unprivileged access.
     */
	HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 0);
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	// printk("watchpoint is trigger,addr=0x%lx, close = %d, dist = %d, mindist = %d, info = %lx\n",
	//        addr, closest_match, dist, min_dist);

	if (*kernel_step != ARM_KERNEL_STEP_NONE)
		return 0;

	if (kernelApi.fun.kernel_active_single_step()) {
		*kernel_step = ARM_KERNEL_STEP_SUSPEND;
	} else {
		*kernel_step = ARM_KERNEL_STEP_ACTIVE;
		/*在当前regs触发step异常*/
		kernelApi.fun.kernel_enable_single_step(regs);
	}
	// }

	return 0;
}
NOKPROBE_SYMBOL(HW_watchpointHandler);

/*
 * 单步异常回调函数中调用，重新开启已经关闭的断点
 */
int HW_breakpointReinstall(struct pt_regs *regs)
{
	// struct debug_info *debug_info = &current->thread.debug;
	int handled_exception = 0, *kernel_step;

	/*获取当前CPU有没有使能signle step*/
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (*kernel_step != ARM_KERNEL_STEP_NONE) {
		HW_toggleBpRegisters(AARCH64_DBG_REG_BCR, DBG_ACTIVE_EL1, 1);
		HW_toggleBpRegisters(AARCH64_DBG_REG_WCR, DBG_ACTIVE_EL1, 1);

		if (*kernel_step != ARM_KERNEL_STEP_SUSPEND) {
			kernelApi.fun.kernel_disable_single_step();
			handled_exception = 1;
		} else {
			handled_exception = 0;
		}

		*kernel_step = ARM_KERNEL_STEP_NONE;
	}

	return !handled_exception;
}
NOKPROBE_SYMBOL(HW_breakpointReinstall);

/*
 * 断点复位函数
 */
static int HW_breakpointReset(unsigned int cpu)
{
	int i;
	struct HW_breakpointInfo **slots;
	/*
     * When a CPU goes through cold-boot, it does not have any installed
     * slot, so it is safe to share the same function for restoring and
     * resetting breakpoints; when a CPU is hotplugged in, it goes
     * through the slots, which are all empty, hence it just resets control
     * and value for debug registers.
     * When this function is triggered on warm-boot through a CPU PM
     * notifier some slots might be initialized; if so they are
     * reprogrammed according to the debug slots content.
     */
	for (slots = this_cpu_ptr(bp_on_reg), i = 0; i < core_num_brps; ++i) {
		if (slots[i]) {
			HW_breakpointControl(slots[i], HW_BREAKPOINT_RESTORE);
		} else {
			HW_writeBreakpointReg(AARCH64_DBG_REG_BCR, i, 0UL);
			HW_writeBreakpointReg(AARCH64_DBG_REG_BVR, i, 0UL);
		}
	}

	for (slots = this_cpu_ptr(wp_on_reg), i = 0; i < core_num_wrps; ++i) {
		if (slots[i]) {
			HW_breakpointControl(slots[i], HW_BREAKPOINT_RESTORE);
		} else {
			HW_writeBreakpointReg(AARCH64_DBG_REG_WCR, i, 0UL);
			HW_writeBreakpointReg(AARCH64_DBG_REG_WVR, i, 0UL);
		}
	}

	return 0;
}

static void HW_showRegs(struct pt_regs *regs)
{
	int i = 0;
	struct HW_breakpointInfo *wp, **slots;

	rcu_read_lock();
	slots = this_cpu_ptr(bp_on_reg);
	for (i = 0; i < core_num_brps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;
		if (wp->info.trigger) {
			/*只要触发了就打印信息*/
			printk("bp is triger = 0x%llx, addr = 0x%llx, len = %d\n",
			       wp->info.trigger, wp->attr.addr, wp->attr.len);
			kernelApi.fun.show_regs(regs);
			wp->info.trigger = 0;
		}
	}
	slots = this_cpu_ptr(wp_on_reg);
	for (i = 0; i < core_num_wrps; ++i) {
		wp = slots[i];
		if (wp == NULL)
			continue;
		if (!wp->info.trigger) {
			/*未触发跳过*/
			continue;
		}
		if (wp->info.trigger >= wp->attr.addr &&
		    wp->info.trigger < wp->attr.addr + wp->attr.len) {
			/*在期望检测的地址范围之内，才打印堆栈信息*/
			printk("wp is triger = 0x%llx, addr = 0x%llx, len = %d\n",
			       wp->info.trigger, wp->attr.addr, wp->attr.len);
			kernelApi.fun.show_regs(regs);
		}
		wp->info.trigger = 0;
	}
	rcu_read_unlock();
}

/*单步异常回调函数，该函数将重新开启被关闭的断点*/
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
static int HW_stepBrkFn(struct pt_regs *regs, unsigned long esr)
#else
static int HW_stepBrkFn(struct pt_regs *regs, unsigned int esr)
#endif
{
	int *kernel_step;

	/*取step状态*/
	kernel_step = this_cpu_ptr(&stepping_kernel_bp);

	if (user_mode(regs) || !(*kernel_step))
		return DBG_HOOK_ERROR;

	HW_showRegs(regs);

	if (HW_breakpointReinstall(regs)) {
		return DBG_HOOK_ERROR;
	}
#ifdef KGDB_ENABLE
	kgdb_handle_exception(0, SIGTRAP, 0, regs);
#endif

	return DBG_HOOK_HANDLED;
}
NOKPROBE_SYMBOL(HW_stepBrkFn);

static struct step_hook gHwStepHook = { .fn = HW_stepBrkFn };

/*根据名字找函数地址*/
unsigned long kaddr_lookup_name(const char *fname_raw)
{
	int i;
	unsigned long kaddr;
	char *fname_lookup, *fname;

	fname_lookup = kzalloc(NAME_MAX, GFP_KERNEL);
	if (!fname_lookup)
		return 0;

	fname = kzalloc(strlen(fname_raw) + 4, GFP_KERNEL);
	if (!fname)
		return 0;

	/*
   * We have to add "+0x0" to the end of our function name
   * because that's the format that sprint_symbol() returns
   * to us. If we don't do this, then our search can stop
   * prematurely and give us the wrong function address!
   */
	strcpy(fname, fname_raw);
	strcat(fname, "+0x0");

	/*获取内核代码段基地址*/
	kaddr = (unsigned long)&sprint_symbol;
	kaddr &= 0xffffffffff000000;

	/*内核符号不会超过0x100000*16的大小，所以按4字节偏移，挨个找*/
	for (i = 0x0; i < 0x400000; i++) {
		/*寻找地址对应的符号名称*/
		sprint_symbol(fname_lookup, kaddr);
		/*对比寻找的符号名字*/
		if (strncmp(fname_lookup, fname, strlen(fname)) == 0) {
			/*找到了就返回地址*/
			kfree(fname_lookup);
			kfree(fname);
			return kaddr;
		}
		/*偏移4字节*/
		kaddr += 0x04;
	}
	/*没找到地址就返回0*/
	kfree(fname_lookup);
	kfree(fname);
	return 0;
}

/*获取驱动必须的内核接口*/
static int HW_getKallsymsLookupName(void)
{
	kernelApi.fun.kallsyms_lookup_name =
		(void *)kaddr_lookup_name("kallsyms_lookup_name");
	if (!kernelApi.fun.kallsyms_lookup_name) {
		printk("get kallsyms_lookup_name fail \n");
		return -1;
	}
	return 0;
}

/*获取驱动必须的内核接口*/
static int HW_getKernelApi(void)
{
	memset(&kernelApi, 0, sizeof(kernelApi));
	if (HW_getKallsymsLookupName()) {
		return -1;
	}
	kernelApi.val.debug_fault_info =
		(void *)kernelApi.fun.kallsyms_lookup_name("debug_fault_info");
	if (!kernelApi.val.debug_fault_info) {
		printk("get debug_fault_info fail\n");
		return -1;
	}
	// printk("debug_fault_info = %llx,name = %s\n", &kernelApi.val.debug_fault_info[0],
	//        kernelApi.val.debug_fault_info[0].name);
	// printk("debug_fault_info = %llx,name = %s\n", &kernelApi.val.debug_fault_info[2],
	//        kernelApi.val.debug_fault_info[2].name);
#ifdef CONFIG_CPU_PM
	kernelApi.val.hw_breakpoint_restore =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"hw_breakpoint_restore");
	if (!kernelApi.val.hw_breakpoint_restore) {
		printk("get hw_breakpoint_restore fail\n");
		return -1;
	}
	// printk("hw_breakpoint_restore = %llx,%llx\n", kernelApi.val.hw_breakpoint_restore,
	//        *kernelApi.val.hw_breakpoint_restore);
#endif
	kernelApi.fun.kernel_active_single_step =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"kernel_active_single_step");
	if (!kernelApi.fun.kernel_active_single_step) {
		printk("get kernel_active_single_step fail\n");
		return -1;
	}
	kernelApi.fun.kernel_disable_single_step =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"kernel_disable_single_step");
	if (!kernelApi.fun.kernel_disable_single_step) {
		printk("get kernel_disable_single_step fail\n");
		return -1;
	}
	kernelApi.fun.kernel_enable_single_step =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"kernel_enable_single_step");
	if (!kernelApi.fun.kernel_enable_single_step) {
		printk("get kernel_enable_single_step fail\n");
		return -1;
	}
	kernelApi.fun.disable_debug_monitors =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"disable_debug_monitors");
	if (!kernelApi.fun.disable_debug_monitors) {
		printk("get disable_debug_monitors fail\n");
		return -1;
	}
	kernelApi.fun.do_bad =
		(void *)kernelApi.fun.kallsyms_lookup_name("do_bad");
	if (!kernelApi.fun.do_bad) {
		printk("get do_bad fail\n");
		return -1;
	}
	kernelApi.fun.enable_debug_monitors =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"enable_debug_monitors");
	if (!kernelApi.fun.enable_debug_monitors) {
		printk("get enable_debug_monitors fail\n");
		return -1;
	}
	kernelApi.fun.read_sanitised_ftr_reg =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"read_sanitised_ftr_reg");
	if (!kernelApi.fun.read_sanitised_ftr_reg) {
		printk("get read_sanitised_ftr_reg fail\n");
		return -1;
	}
	kernelApi.fun.show_regs =
		(void *)kernelApi.fun.kallsyms_lookup_name("show_regs");
	if (!kernelApi.fun.show_regs) {
		printk("get show_regs fail\n");
		return -1;
	}
	kernelApi.fun.dump_backtrace =
		(void *)kernelApi.fun.kallsyms_lookup_name("dump_backtrace");
	if (!kernelApi.fun.dump_backtrace) {
		printk("get dump_backtrace fail\n");
		return -1;
	}
	/*5.0以下内核用的是register_step_hook*/
	kernelApi.fun.register_step_hook =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"register_step_hook");
	if (!kernelApi.fun.register_step_hook) {
		/*5.0以上内核用的是register_kernel_step_hook*/
		kernelApi.fun.register_step_hook =
			(void *)kernelApi.fun.kallsyms_lookup_name(
				"register_kernel_step_hook");
		if (!kernelApi.fun.register_step_hook) {
			printk("get register_step_hook fail\n");
			return -1;
		}
	}
	kernelApi.fun.unregister_step_hook =
		(void *)kernelApi.fun.kallsyms_lookup_name(
			"unregister_step_hook");
	if (!kernelApi.fun.unregister_step_hook) {
		kernelApi.fun.unregister_step_hook =
			(void *)kernelApi.fun.kallsyms_lookup_name(
				"unregister_kernel_step_hook");
		if (!kernelApi.fun.unregister_step_hook) {
			printk("get unregister_step_hook fail\n");
			return -1;
		}
	}

	/*以下不影响驱动使用，只影响根据io地址查询虚拟地址功能*/
	kernelApi.val.vmap_area_lock =
		(void *)kernelApi.fun.kallsyms_lookup_name("vmap_area_lock");
	kernelApi.val.vmap_area_list =
		(void *)kernelApi.fun.kallsyms_lookup_name("vmap_area_list");

	return 0;
}

/*驱动初始化*/
static int __init HW_breakpointInit(void)
{
	int ret = 0;

	if (HW_getKernelApi()) {
		return -1;
	}
	/*计算断点数量*/

	core_num_brps = HW_getNumBrps();
	core_num_wrps = HW_getNumWrps();

	printk("found %d breakpoint and %d watchpoint registers.\n",
	       core_num_brps, core_num_wrps);

	/* 注册调试异常回调函数 */
	/*执行断点*/
	/*保存原先的变量*/
	kernelApi.val.default_fault_info[0].fn =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn;
	kernelApi.val.default_fault_info[0].sig =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig;
	kernelApi.val.default_fault_info[0].code =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code;
	kernelApi.val.default_fault_info[0].name =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name;
	/*注册新的内容*/
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn =
		HW_breakpointHandler;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig = SIGTRAP;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code = TRAP_HWBKPT;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name =
		"hw-breakpoint handler";
	/*内存断点*/
	/*保存原先的变量*/
	kernelApi.val.default_fault_info[1].fn =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn;
	kernelApi.val.default_fault_info[1].sig =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig;
	kernelApi.val.default_fault_info[1].code =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code;
	kernelApi.val.default_fault_info[1].name =
		kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name;
	/*注册新的内容*/
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn =
		HW_watchpointHandler;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig = SIGTRAP;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code = TRAP_HWBKPT;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name =
		"hw-watchpoint handler";
	kernelApi.fun.register_step_hook(&gHwStepHook);
#ifdef CONFIG_CPU_PM
	/*注册cpu暂停后恢复断点的回调函数*/
	/*保存原先的变量*/
	kernelApi.val.default_hw_breakpoint_restore =
		*kernelApi.val.hw_breakpoint_restore;
	*kernelApi.val.hw_breakpoint_restore = (u64)HW_breakpointReset;
#endif
	HW_bpManageInit();
	hw_proc_init();

	printk("HW_breakpointInit\n");
	return 0;
}

static void __exit HW_breakpointExit(void)
{
	hw_proc_exit();
	HW_bpManageDeInit();
#ifdef CONFIG_CPU_PM
	*kernelApi.val.hw_breakpoint_restore =
		kernelApi.val.default_hw_breakpoint_restore;
#endif
	kernelApi.fun.unregister_step_hook(&gHwStepHook);
	/*内存断点*/
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].fn =
		kernelApi.val.default_fault_info[1].fn;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].sig =
		kernelApi.val.default_fault_info[1].sig;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].code =
		kernelApi.val.default_fault_info[1].code;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWWP].name =
		kernelApi.val.default_fault_info[1].name;
	/*执行断点*/
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].fn =
		kernelApi.val.default_fault_info[0].fn;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].sig =
		kernelApi.val.default_fault_info[0].sig;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].code =
		kernelApi.val.default_fault_info[0].code;
	kernelApi.val.debug_fault_info[DBG_ESR_EVT_HWBP].name =
		kernelApi.val.default_fault_info[0].name;
	printk(" HW_breakpointExit\n");
}

module_init(HW_breakpointInit);
module_exit(HW_breakpointExit);

MODULE_AUTHOR("zwf");
MODULE_DESCRIPTION("hw break point test");
MODULE_LICENSE("Dual BSD/GPL");

```

`include/hw_breakpoint.h`:

```h
#ifndef __ASM_HW_BREAKPOINT_H
#define __ASM_HW_BREAKPOINT_H

#include "asm-generic/int-ll64.h"
#include "asm/virt.h"
#include <asm/debug-monitors.h>
#include "linux/spinlock_types.h"
#include <linux/version.h>

/* Privilege Levels */
#define AARCH64_BREAKPOINT_EL1 1
#define AARCH64_BREAKPOINT_EL0 2

#define DBG_HMC_HYP (1 << 13)

/* Breakpoint */
#define ARM_BREAKPOINT_EXECUTE 0

/* Watchpoints */
#define ARM_BREAKPOINT_LOAD 1
#define ARM_BREAKPOINT_STORE 2
#define AARCH64_ESR_ACCESS_MASK (1 << 6)

/* Lengths */
#define ARM_BREAKPOINT_LEN_1 0x1
#define ARM_BREAKPOINT_LEN_2 0x3
#define ARM_BREAKPOINT_LEN_3 0x7
#define ARM_BREAKPOINT_LEN_4 0xf
#define ARM_BREAKPOINT_LEN_5 0x1f
#define ARM_BREAKPOINT_LEN_6 0x3f
#define ARM_BREAKPOINT_LEN_7 0x7f
#define ARM_BREAKPOINT_LEN_8 0xff

/* Kernel stepping */
#define ARM_KERNEL_STEP_NONE 0
#define ARM_KERNEL_STEP_ACTIVE 1
#define ARM_KERNEL_STEP_SUSPEND 2

/*
 * Limits.
 * Changing these will require modifications to the register accessors.
 */
#define ARM_MAX_BRP 16
#define ARM_MAX_WRP 16

/* Virtual debug register bases. */
#define AARCH64_DBG_REG_BVR 0
#define AARCH64_DBG_REG_BCR (AARCH64_DBG_REG_BVR + ARM_MAX_BRP)
#define AARCH64_DBG_REG_WVR (AARCH64_DBG_REG_BCR + ARM_MAX_BRP)
#define AARCH64_DBG_REG_WCR (AARCH64_DBG_REG_WVR + ARM_MAX_WRP)

/* Debug register names. */
#define AARCH64_DBG_REG_NAME_BVR bvr
#define AARCH64_DBG_REG_NAME_BCR bcr
#define AARCH64_DBG_REG_NAME_WVR wvr
#define AARCH64_DBG_REG_NAME_WCR wcr

/* Accessor macros for the debug registers. */
#define AARCH64_DBG_READ(N, REG, VAL)                 \
	do {                                          \
		VAL = read_sysreg(dbg##REG##N##_el1); \
	} while (0)

#define AARCH64_DBG_WRITE(N, REG, VAL)                \
	do {                                          \
		write_sysreg(VAL, dbg##REG##N##_el1); \
	} while (0)

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = HW_BREAKPOINT_R | HW_BREAKPOINT_W,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = HW_BREAKPOINT_RW | HW_BREAKPOINT_X,
};

enum bp_type_idx { TYPE_INST = 0, TYPE_DATA = 1, TYPE_MAX };

typedef struct HW_breakpointAttr {
	u32 type; /*断点类型*/
	u64 addr; /*断点期望监控的地址*/
	u64 startAddr; /*断点实际监控的起始地址*/
	u64 endAddr; /*断点实际监控的结束*/
	u64 len; /*断点期望监控的长度*/
	u64 realLen; /*实际写入断点寄存器的len*/
	u32 mask; /*断点的mask码，区别于len，可以监控更大的地址范围*/
	u64 disabled : 1, //63bit
		reserved : 63; //0~62bit
} HW_breakpointAttr;

typedef struct HW_breakpointCtrlReg {
	u32 reserved2 : 3, //29~31bit, 保留位
		mask : 5, //24~28bit, 地址掩码，mask=0b11111时(屏蔽2^0b11111位低地址),最大支持2G的地址监控, 最小8字节
		reserved1 : 3, //21~23bit, 保留位
		wt : 1, //20bit, watchpointtype, Unlinked(0)/linked(1) data address match.
		lbn : 4, //16~19bit, wt设置时才需要设置，跟链接断点有关
		ssc : 2, //14,15bit, 安全状态控制，控制什么状态才会监听断点事件
		hmc : 1, //13bit, 结合上述字段使用
		len : 8, //5~12bit, 控制watchpoint监控的字节数量, 每一位代表1字节，最大8字节
		type : 2, //3~4bit， 断点类型: breakpoint/watchpoint
		privilege : 2, //1~2bit, 上次断点设置时的el等级，配合ssc, hmc使用
		enabled : 1; //0bit, watchpoint使能
} HW_breakpointCtrlReg;

typedef struct HW_breakpointVC {
	u64 address;
	u64 trigger;
	HW_breakpointCtrlReg ctrl;
} HW_breakpointVC;

/*以下接口皆是从Kernel中导出*/
struct fault_info {
	int (*fn)(unsigned long addr, unsigned int esr, struct pt_regs *regs);
	int sig;
	int code;
	const char *name;
};
typedef struct HW_kernelApi {
	struct {
		unsigned long (*kallsyms_lookup_name)(
			const char *name); /*根据符号查询地址函数*/
		void (*register_step_hook)(
			struct step_hook *hook); /*注册step调试异常hook的函数*/
		void (*unregister_step_hook)(
			struct step_hook
				*hook); /*取消注册step调试异常hook的函数*/
		void (*enable_debug_monitors)(
			enum dbg_active_el el); /*使能debug异常*/
		void (*disable_debug_monitors)(
			enum dbg_active_el el); /*失能debug异常*/
		int (*kernel_active_single_step)(void); /*单步调试是否激活*/
		void (*kernel_enable_single_step)(
			struct pt_regs *regs); /*使能单步调试异常*/
		void (*kernel_disable_single_step)(void); /*失能单步调试异常*/
		u64 (*read_sanitised_ftr_reg)(u32 id); /*读ftr寄存器*/
		void (*show_regs)(struct pt_regs *); /*显示堆栈*/
		void (*dump_backtrace)(struct pt_regs *regs,
				       struct task_struct *tsk); /**/
		void (*do_bad)(
			unsigned long addr, unsigned int esr,
			struct pt_regs *regs); /*调试异常的默认中断处理函数*/
	} __aligned(128) fun;
	struct {
#ifdef CONFIG_CPU_PM
		u64 *hw_breakpoint_restore; /*cpu从调试暂停恢复运行时执行的函数*/
		u64 default_hw_breakpoint_restore; /*接管之前的函数地址*/
#endif
		struct fault_info *
			debug_fault_info; /*接管硬件断点调试异常中断，替换回调函数*/
		struct fault_info default_fault_info[2]; /*接管之前的数据信息*/
		spinlock_t *vmap_area_lock; /*内核vm spinlock*/
		struct list_head *
			vmap_area_list /*内核vm链表，所有虚拟内存都在这个链表里*/
	} __aligned(128) val;

} HW_kernelApi;

extern HW_kernelApi kernelApi;

/*组装reg*/
static inline u32 HW_encodeCtrlReg(HW_breakpointCtrlReg ctrl)
{
	u32 val = (ctrl.mask << 24) | (ctrl.len << 5) | (ctrl.type << 3) |
		  (ctrl.privilege << 1) | ctrl.enabled;

	if (is_kernel_in_hyp_mode() && ctrl.privilege == AARCH64_BREAKPOINT_EL1)
		val |= DBG_HMC_HYP;

	return val;
}

static inline void HW_decodeCtrlReg(u32 reg, HW_breakpointCtrlReg *ctrl)
{
	ctrl->enabled = reg & 0x1;
	reg >>= 1;
	ctrl->privilege = reg & 0x3;
	reg >>= 2;
	ctrl->type = reg & 0x3;
	reg >>= 2;
	ctrl->len = reg & 0xff;
	reg >>= 19;
	ctrl->mask = reg & 0x1f;
}

/* Determine number of BRP registers available. */
static inline int HW_getNumBrps(void)
{
	u64 dfr0 = kernelApi.fun.read_sanitised_ftr_reg(SYS_ID_AA64DFR0_EL1);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	return 1 + cpuid_feature_extract_unsigned_field(
			   dfr0, ID_AA64DFR0_EL1_BRPs_SHIFT);
#else
	return 1 + cpuid_feature_extract_unsigned_field(dfr0,
							ID_AA64DFR0_BRPS_SHIFT);
#endif
}

/* Determine number of WRP registers available. */
static inline int HW_getNumWrps(void)
{
	u64 dfr0 = kernelApi.fun.read_sanitised_ftr_reg(SYS_ID_AA64DFR0_EL1);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	return 1 + cpuid_feature_extract_unsigned_field(
			   dfr0, ID_AA64DFR0_EL1_BRPs_SHIFT);
#else
	return 1 + cpuid_feature_extract_unsigned_field(dfr0,
							ID_AA64DFR0_WRPS_SHIFT);
#endif
}

#endif
```

`include/hw_breakpointApi.h`:

```h
#ifndef _MY_HW_BREAKPOINT_H
#define _MY_HW_BREAKPOINT_H

#include "hw_breakpoint.h"

struct HW_breakpointInfo {
	int cpu;
	HW_breakpointAttr attr;
	HW_breakpointVC info;
};

static inline HW_breakpointVC *HW_counterArchbp(struct HW_breakpointInfo *bp)
{
	return &bp->info;
}

int HW_getBreakpointNum(int type);
int HW_breakpointArchParse(struct HW_breakpointInfo *bp,
			   const HW_breakpointAttr *attr, HW_breakpointVC *hw);
int HW_breakpointInstall(struct HW_breakpointInfo *bp);
int HW_breakpointUninstall(struct HW_breakpointInfo *bp);
int HW_breakpointReinstall(struct pt_regs *regs);
int HW_archCheckBpInKernelspace(HW_breakpointVC *hw);
int HW_breakpointRegister(struct HW_breakpointInfo *__percpu *cpu_events,
			  HW_breakpointAttr *attr, int *state);
void HW_breakpointUnregister(struct HW_breakpointInfo *__percpu *bp, int state);

#endif

```

`include/hw_breakpointManage.h`:

```h
#ifndef _HW_BREAKPOINT_MANAGE_H
#define _HW_BREAKPOINT_MANAGE_H

// #define KGDB_ENABLE

#include "hw_breakpointApi.h"

int HW_bpManageInit(void);
void HW_bpManageDeInit(void);
void HW_breakpointShowAll(void);
int HW_breakpointInstallFromAddr(u64 addr, int len, int type);
void HW_breakpointUnInstallFromAddr(u64 addr);
int HW_breakpointInstallFromSymbol(char *name, int len, int type);
void HW_breakpointUnInstallFromSymbol(char *name);

#endif

```

`include/hw_proc.h`:

```h
/*
 * @Author: zwf 240970521@qq.com
 * @Date: 2023-08-23 18:59:47
 * @LastEditors: zwf 240970521@qq.com
 * @LastEditTime: 2023-08-23 21:36:57
 * @FilePath: /hardware-breakpoint/include/hw_proc.h
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE;/
 */
#ifndef _hw_proc_H
#define _hw_proc_H

extern int hw_proc_init(void);
extern void hw_proc_exit(void);

#endif
```

`make.sh`:

```sh
#!/bin/sh
###
 # @Author: zwf 240970521@qq.com
 # @Date: 2023-08-25 21:21:01
 # @LastEditors: zwf 240970521@qq.com
 # @LastEditTime: 2023-08-25 21:27:58
 # @FilePath: /hardware-breakpoint/make.sh
 # @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
### 
KERNEL_DIR=/home/zwf/x3_src/kernel
hotbot_key=$KERNEL_DIR/certs/hobot_fixed_signing_key.pem
sign_key=$KERNEL_DIR/certs/signing_key.x509
sign_tools=$KERNEL_DIR/scripts/sign-file

rm -rf .vscode/compile_commands.json
make clean
bear make
mv compile_commands.json .vscode/compile_commands.json

#给驱动加签名
$sign_tools sha512 $hotbot_key $sign_key ./hw_break.ko

#copy到nfs目录
cp ./hw_break.ko ~/x3sdb/nfs/

```

`src/hw_breakpointApi.c`:

```c
#include "hw_breakpointApi.h"
#include <linux/slab.h>
#include "hw_breakpoint.h"
#include "linux/capability.h"
#include "linux/cpu.h"

typedef int (*HW_remoteFunctionF)(void *);

struct HW_remoteFunctionCall {
	struct HW_breakpointInfo *p;
	HW_remoteFunctionF func;
	void *info;
	int ret;
};

static void HW_remoteFunction(void *data)
{
	struct HW_remoteFunctionCall *tfc = data;

	/*回调函数*/
	tfc->ret = tfc->func(tfc->info);
}

static int HW_cpuFunctionCall(int cpu, HW_remoteFunctionF func, void *info)
{
	struct HW_remoteFunctionCall data = {
		.p = NULL,
		.func = func,
		.info = info,
		.ret = -ENXIO, /* No such CPU */
	};

	smp_call_function_single(cpu, HW_remoteFunction, &data, 1);

	return data.ret;
}

static int HW_breakpointParse(struct HW_breakpointInfo *bp,
			      const HW_breakpointAttr *attr,
			      HW_breakpointVC *hw)
{
	int err;

	err = HW_breakpointArchParse(bp, attr, hw);
	if (err)
		return err;

	if (HW_archCheckBpInKernelspace(hw)) {
		/*
     * Don't let unprivileged users set a breakpoint in the trap
     * path to avoid trap recursion attacks.
     */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
	}

	return 0;
}

static int HW_breakpointInfoDel(void *p)
{
	struct HW_breakpointInfo *bp = (struct HW_breakpointInfo *)p;
	return HW_breakpointUninstall(bp);
}

static int HW_breakpointInfoAdd(void *p)
{
	struct HW_breakpointInfo *bp = (struct HW_breakpointInfo *)p;
	return HW_breakpointInstall(bp);
}

static int HW_breakpointInfoInit(struct HW_breakpointInfo *bp)
{
	int err;
	HW_breakpointVC hw = {};

	err = HW_breakpointParse(bp, &bp->attr, &hw);
	if (err)
		return err;

	bp->info = hw;

	return 0;
}

static struct HW_breakpointInfo *
HW_breakpointInfoAlloc(const HW_breakpointAttr *attr, int cpu)
{
	struct HW_breakpointInfo *bp = NULL;
	int err;

	/*为bp分配内存*/
	bp = kzalloc(sizeof(*bp), GFP_KERNEL);
	if (!bp) {
		printk("bp alloc fail\n");
		return ERR_PTR(-ENOMEM);
	}

	bp->cpu = cpu;
	bp->attr = *attr;

	/*初始化bp*/
	err = HW_breakpointInfoInit(bp);
	if (err) {
		printk("HW_breakpointInfo_init fail\n");
		return ERR_PTR(err);
	}
	/*这个CPU同步函数不能在KGDB状态下调用*/
	err = HW_cpuFunctionCall(cpu, HW_breakpointInfoAdd, bp);
	if (err) {
		printk("HW_breakpointInfo_add fail\n");
		return ERR_PTR(err);
	}

	return bp;
}

static void HW_breakpointInfoFree(struct HW_breakpointInfo *bp, int cpu)
{
	HW_cpuFunctionCall(cpu, HW_breakpointInfoDel, bp);
	kfree(bp);
}

void HW_breakpointUnregister(struct HW_breakpointInfo *__percpu *bp, int state)
{
	int cpu;

	if (bp == NULL) {
		return;
	}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_possible_cpu(cpu) {
		if (state & 1 << cpu) {
			HW_breakpointInfoFree(per_cpu(*bp, cpu), cpu);
		}
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif
}

int HW_breakpointRegister(struct HW_breakpointInfo *__percpu *cpu_events,
			  HW_breakpointAttr *attr, int *state)
{
	struct HW_breakpointInfo *bp;
	int cpu;

	if (cpu_events == NULL || attr == NULL || state == NULL) {
		printk("HW_breakpointRegister para is NULL\n");
		return -1;
	}

	*state = 0;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_lock();
#else
	get_online_cpus();
#endif
	for_each_online_cpu(cpu) {
		bp = HW_breakpointInfoAlloc(attr, cpu);
		if (IS_ERR(bp)) {
			printk("HW_breakpointInfo_alloc error at CPU[%d]\n",
			       cpu);
		}
		/*代表第几个CPU设置断点成功*/
		*state |= 1 << cpu;
		/*为每个CPU保存设置的断点*/
		per_cpu(*cpu_events, cpu) = bp;
	}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
	cpus_read_unlock();
#else
	put_online_cpus();
#endif

	return 0;
}

```

`src/hw_breakpointManage.c`:

```c
#include "hw_breakpointManage.h"
#include "hw_breakpoint.h"
#include "linux/kallsyms.h"
#include <linux/kgdb.h>
#include <linux/module.h>

struct HW_bpManageInfo {
	struct HW_breakpointInfo **info; /*存储申请到的percpu变量*/
	HW_breakpointAttr attr; /*断点属性*/
	int mask; /*断点应用成功的CPU掩码*/
	char symbolName[KSYM_SYMBOL_LEN]; /*符号名字*/
};
struct HW_bpManage {
	struct HW_bpManageInfo wp[ARM_MAX_WRP]; /*存储观察断点*/
	struct HW_bpManageInfo bp[ARM_MAX_BRP]; /*存储执行断点*/
	int maxWpNum; /*芯片支持的最大观察断点数量*/
	int maxBpNum; /*芯片支持的最大执行断点数量*/
	int cpuMask; /*cpu掩码，代表有几个CPU可用*/
};

static struct HW_bpManage gHwManage;
extern u32 zwf_test_value;
extern u32 zwf_test_value1;

/*显示一个断点的信息*/
static void HW_breakpointShowOne(struct HW_bpManageInfo *bpInfo, int index)
{
	char type[4][30] = { "HW_BREAKPOINT_R", "HW_BREAKPOINT_W",
			     "HW_BREAKPOINT_RW", "HW_BREAKPOINT_X" };

	printk("--------------------------------------------------\n");
	/*打印第几个断点*/
	switch (bpInfo->attr.type) {
	case HW_BREAKPOINT_R:
	case HW_BREAKPOINT_W:
	case HW_BREAKPOINT_RW:
	case HW_BREAKPOINT_X: {
		printk("breakpoint[%d]:\n", index);
		break;
	}
	default: {
		printk("breakpoint[%d] type is error!\n", index);
		return;
	}
	}

	/*打印断点类型*/
	printk("\ttype: \t%s\n", type[bpInfo->attr.type - 1]);
	/*打印监控的符号名称*/
	printk("\tname: \t%s\n", bpInfo->symbolName);
	/*打印想监控的地址范围*/
	printk("\tmonit: \t0x%llx--->0x%llx\n", bpInfo->attr.addr,
	       bpInfo->attr.addr + bpInfo->attr.len - 1);
	/*打印监控的字节长度*/
	printk("\tlen: \t%d\n", bpInfo->attr.len);
	/*打印监控的地址掩码*/
	printk("\tmask: \t0x%x\n", bpInfo->attr.mask);
	/*打印实际监控的地址范围*/
	printk("\trange: \t0x%llx--->0x%llx\n", bpInfo->attr.startAddr,
	       bpInfo->attr.endAddr);
	printk("\tsize: \t%d\n", bpInfo->attr.endAddr - bpInfo->attr.startAddr);
}

/*显示所有断点*/
void HW_breakpointShowAll(void)
{
	struct HW_bpManageInfo *bpInfo = NULL;
	int i = 0;

	for (i = 0; i < gHwManage.maxBpNum; i++) {
		bpInfo = &gHwManage.bp[i];
		if (bpInfo->mask & gHwManage.cpuMask) {
			HW_breakpointShowOne(bpInfo, i);
		}
	}

	for (i = 0; i < gHwManage.maxWpNum; i++) {
		bpInfo = &gHwManage.wp[i];
		if (bpInfo->mask & gHwManage.cpuMask) {
			HW_breakpointShowOne(bpInfo, i + gHwManage.maxBpNum);
		}
	}
}

#ifdef KGDB_ENABLE
/*kgdb的操作函数*/
static int HW_breakpointInstallFromKgdb(unsigned long addr, int len,
					enum kgdb_bptype type)
{
	int bpLen = len, bpType = 0, res;

	printk("111111111111111\n");

	bpLen = max(bpLen, HW_BREAKPOINT_LEN_8);
	bpLen = min(bpLen, HW_BREAKPOINT_LEN_1);

	switch (type) {
	case BP_HARDWARE_BREAKPOINT: {
		bpType = HW_BREAKPOINT_X;
		break;
	}
	case BP_WRITE_WATCHPOINT: {
		bpType = HW_BREAKPOINT_W;
		break;
	}
	case BP_READ_WATCHPOINT: {
		bpType = HW_BREAKPOINT_R;
		break;
	}
	case BP_ACCESS_WATCHPOINT: {
		bpType = HW_BREAKPOINT_W | HW_BREAKPOINT_R;
		break;
	}
	default: {
		return -1;
	}
	}

	res = HW_breakpointInstallFromAddr(addr, bpLen, bpType);

	return res;
}

static int HW_breakpointUnInstallFromKgdb(unsigned long addr, int len,
					  enum kgdb_bptype type)
{
	HW_breakpointUnInstallFromAddr(addr);
	return 0;
}
#endif

static void HW_breakpointUninstallAll(void)
{
	struct HW_bpManageInfo *bpInfo = NULL;
	int i = 0;

	for (i = 0; i < gHwManage.maxBpNum; i++) {
		bpInfo = &gHwManage.bp[i];
		if (bpInfo->mask & gHwManage.cpuMask) {
			HW_breakpointUnregister(bpInfo->info, bpInfo->mask);
			/*清空该断点信息*/
			memset(bpInfo->symbolName, 0,
			       sizeof(bpInfo->symbolName));
			memset(&bpInfo->attr, 0, sizeof(bpInfo->attr));
			bpInfo->mask = 0;
		}
	}

	for (i = 0; i < gHwManage.maxWpNum; i++) {
		bpInfo = &gHwManage.wp[i];
		if (bpInfo->mask & gHwManage.cpuMask) {
			HW_breakpointUnregister(bpInfo->info, bpInfo->mask);
			/*清空该断点信息*/
			memset(bpInfo->symbolName, 0,
			       sizeof(bpInfo->symbolName));
			memset(&bpInfo->attr, 0, sizeof(bpInfo->attr));
			bpInfo->mask = 0;
		}
	}
}

#ifdef KGDB_ENABLE
static void HW_bpKgdbOpsRegister(void)
{
	arch_kgdb_ops.flags = 0;
	arch_kgdb_ops.set_hw_breakpoint = NULL;
	arch_kgdb_ops.remove_hw_breakpoint = NULL;
	arch_kgdb_ops.remove_all_hw_break = NULL;
}

static void HW_bpKgdbOpsUnRegister(void)
{
	arch_kgdb_ops.flags = 0;
	arch_kgdb_ops.set_hw_breakpoint = NULL;
	arch_kgdb_ops.remove_hw_breakpoint = NULL;
	arch_kgdb_ops.remove_all_hw_break = NULL;
}
#endif

static int HW_getAddrMask(u64 addr, int len)
{
	/*期望检测地址的结束地址*/
	u64 addrTmp = addr + len;
	u64 alignment_mask = 0;
	int mask, i = 0;

	/*获取基础mask*/
	mask = (int)__ilog2_u64(len);
	if ((1 << mask) < len) {
		mask = mask + 1;
	}
	for (i = 0; i < mask; i++) {
		alignment_mask |= (1 << i);
	}

	while (1) {
		if ((addr | alignment_mask) >= addrTmp) {
			break;
		}
		mask = mask + 1;
		alignment_mask |= (1 << i);
		i++;
	}

	if (mask > 31) {
		/*arm64的mask最大为0b11111*/
		mask = 31;
	}
	return mask;
}

/*从地址设置一个断点*/
int HW_breakpointInstallFromAddr(u64 addr, int len, int type)
{
	int state, i, maxNum, ret, mask = 0;
	struct HW_bpManageInfo *bpInfo;
	u64 startAddr, endAddr;
	u64 alignment_mask = 0, realLen = len, offset;

	if ((0 == addr) || (addr < TASK_SIZE)) {
		printk("HW_breakpointInstallFromAddr para is error\n");
		return -1;
	}

	switch (type) {
	case HW_BREAKPOINT_R:
	case HW_BREAKPOINT_W:
	case HW_BREAKPOINT_RW: {
		/*内存断点*/
		bpInfo = gHwManage.wp;
		maxNum = gHwManage.maxWpNum;
		if (len > 8) {
			/*要监控的字节大于8个时就要使用掩码来控制了*/
			mask = HW_getAddrMask(addr, len);
			realLen = 4;
		}
		if (mask != 0) {
			/*掩码模式监控*/
			for (i = 0; i < mask; i++) {
				alignment_mask |= (1 << i);
			}
			startAddr = addr & ~(alignment_mask);
			endAddr = addr | alignment_mask;
		} else {
			/*按长度监控*/
			alignment_mask = 0x7;
			offset = addr & alignment_mask;
			realLen = len << offset;
			if (realLen > 8) {
				realLen = 8;
			}
			startAddr = addr & ~(alignment_mask);
			endAddr = startAddr + realLen;
		}
		break;
	}
	case HW_BREAKPOINT_X: {
		/*执行断点*/
		realLen = 4;
		bpInfo = gHwManage.bp;
		maxNum = gHwManage.maxBpNum;
		alignment_mask = 0x3;
		offset = addr & alignment_mask;
		realLen = len << offset;
		if (realLen > 8) {
			realLen = 8;
		}
		startAddr = addr & ~(alignment_mask);
		endAddr = startAddr + realLen;
		break;
	}
	default: {
		/*断点类型错误*/
		printk("breakpoint type error\n");
		return -1;
	}
	}

	for (i = 0; i < maxNum; i++) {
		if ((bpInfo[i].mask & gHwManage.cpuMask) != 0) {
			/*代表断点已经设置*/
			if (bpInfo[i].attr.addr == addr) {
				printk("[install] The addr [%lx] is already set at index %d\n",
				       addr, i);
				return -1;
			}
		}
	}

	for (i = 0; i < maxNum; i++) {
		if ((bpInfo[i].mask & gHwManage.cpuMask) != 0) {
			continue;
		}
		bpInfo[i].attr.len = len;
		bpInfo[i].attr.realLen = realLen;
		bpInfo[i].attr.mask = mask;
		bpInfo[i].attr.type = type;
		bpInfo[i].attr.addr = addr;
		bpInfo[i].attr.startAddr = startAddr;
		bpInfo[i].attr.endAddr = endAddr;
		break;
	}
	if (i == maxNum) {
		printk("[install] breakpoint is full type = %x\n", type);
		return -1;
	}

	// printk("gHwManage.wp[%d].info = %lx\n", i, gHwManage.wp[i].info);
	// printk("info = %lx,attr=%lx,state=%lx\n", bpInfo[i].info, &bpInfo[i].attr,
	//        &state);
	ret = HW_breakpointRegister(bpInfo[i].info, &bpInfo[i].attr, &state);
	if (ret) {
		goto clear;
	}
	/*代表有多少CPU注册成了该断点*/
	bpInfo[i].mask = state;
	memset(bpInfo[i].symbolName, 0, sizeof(bpInfo[i].symbolName));
	sprint_symbol(bpInfo[i].symbolName, addr);
	HW_breakpointShowOne(&bpInfo[i], i);
	return 0;
clear:
	printk("HW_breakpointInstallFromAddr [%lx] error\n", addr);
	/*清除attr信息*/
	memset(&bpInfo[i].attr, 0, sizeof(bpInfo[i].attr));
	memset(bpInfo[i].symbolName, 0, sizeof(bpInfo[i].symbolName));
	bpInfo[i].mask = 0;
	return -1;
}
EXPORT_SYMBOL(HW_breakpointInstallFromAddr);

/*从符号设置一个断点*/
int HW_breakpointInstallFromSymbol(char *name, int len, int type)
{
	int ret = 0;
	u64 addr = 0;

	if ((NULL == name) || (HW_BREAKPOINT_INVALID == type)) {
		printk("HW_breakpointInstallFromSymbol para is error\n");
		return -1;
	}

	addr = kernelApi.fun.kallsyms_lookup_name(name);
	if (0 == addr) {
		/*无法找到该符号的地址*/
		printk("Can not find the symbol, name: %s\n", name);
		return -1;
	}

	ret = HW_breakpointInstallFromAddr(addr, len, type);
	if (ret) {
		printk("HW_breakpointInstallFromSymbol error [%s]\n", name);
		return -1;
	}

	return 0;
}
EXPORT_SYMBOL(HW_breakpointInstallFromSymbol);

void HW_breakpointUnInstallFromAddr(u64 addr)
{
	int i = 0;
	struct HW_bpManageInfo *bpInfo = NULL;

	/*遍历查找和addr相同的断点地址*/
	/*查找breakpoint*/
	for (i = 0; i < gHwManage.maxBpNum; i++) {
		if (gHwManage.bp[i].mask & gHwManage.cpuMask) {
			if (gHwManage.bp[i].attr.addr == addr) {
				bpInfo = &gHwManage.bp[i];
				printk("[uninstall] find addr: bp[%d]\n", i);
				break;
			}
		}
	}
	/*查找watchpoint*/
	for (i = 0; (i < gHwManage.maxWpNum) && (bpInfo == NULL); i++) {
		if (gHwManage.wp[i].mask & gHwManage.cpuMask) {
			if (gHwManage.wp[i].attr.addr == addr) {
				bpInfo = &gHwManage.wp[i];
				printk("[uninstall] find addr: wp[%d]\n", i);
				break;
			}
		}
	}
	if (NULL == bpInfo) {
		printk("HW_breakpointUnInstallFromAddr fail,can not find addr:0x%lx\n",
		       addr);
		return;
	}
	HW_breakpointUnregister(bpInfo->info, bpInfo->mask);
	/*清空该断点信息*/
	memset(bpInfo->symbolName, 0, sizeof(bpInfo->symbolName));
	memset(&bpInfo->attr, 0, sizeof(bpInfo->attr));
	bpInfo->mask = 0;
}
EXPORT_SYMBOL(HW_breakpointUnInstallFromAddr);

void HW_breakpointUnInstallFromSymbol(char *name)
{
	u64 addr = 0;

	if (NULL == name) {
		printk("HW_breakpointUnInstallFromSymbol para is error\n");
		return;
	}

	addr = kernelApi.fun.kallsyms_lookup_name(name);
	if (0 == addr) {
		/*无法找到该符号的地址*/
		printk("[uninstall] Can not find the symbol, name: %s\n", name);
		return;
	}
	HW_breakpointUnInstallFromAddr(addr);
}
EXPORT_SYMBOL(HW_breakpointUnInstallFromSymbol);

/*断点管理去初始化*/
void HW_bpManageDeInit(void)
{
	int i = 0;

	HW_breakpointUninstallAll();

#ifdef KGDB_ENABLE
	HW_bpKgdbOpsUnRegister();
#endif
	for (i = 0; i < gHwManage.maxWpNum; i++) {
		free_percpu(gHwManage.wp[i].info);
	}

	for (i = 0; i < gHwManage.maxBpNum; i++) {
		free_percpu(gHwManage.bp[i].info);
	}
}

/*断点管理初始化*/
int HW_bpManageInit(void)
{
	int cpu = -1, i = 0;
	struct HW_breakpointInfo *__percpu *bp = NULL;

	/*获取断点的数量*/
	gHwManage.maxBpNum = HW_getBreakpointNum(TYPE_INST);
	gHwManage.maxWpNum = HW_getBreakpointNum(TYPE_DATA);

	/*获取CPU数量*/
	for_each_online_cpu(cpu) {
		gHwManage.cpuMask |= 1 << cpu;
	}
	printk("CPU MASK =  %x\n", gHwManage.cpuMask);

	/*为每个断点申请percpu内存*/
	for (i = 0; i < gHwManage.maxWpNum; i++) {
		bp = alloc_percpu(typeof(*bp));
		if (!bp) {
			printk("wp alloc_percpu fail\n");
			goto free;
		}
		gHwManage.wp[i].info = bp;
		bp = NULL;
	}
	for (i = 0; i < gHwManage.maxBpNum; i++) {
		bp = alloc_percpu(typeof(*bp));
		if (!bp) {
			printk("wp alloc_percpu fail\n");
			goto free;
		}
		gHwManage.bp[i].info = bp;
		bp = NULL;
	}

#ifdef KGDB_ENABLE
	HW_bpKgdbOpsRegister();
#endif

	return 0;

free:
	HW_bpManageDeInit();
	return -1;
}

```

`src/hw_proc.c`:

```c
#include "hw_breakpointApi.h"
#include <linux/version.h>
#include <linux/errno.h>
#include <linux/delay.h>
#include <linux/mii.h>
#include <linux/mdio.h>
#include <linux/proc_fs.h>
#include <linux/spinlock.h>
#include "asm/string.h"
#include "linux/printk.h"
#include "linux/slab.h"
#include "linux/stddef.h"
#include "hw_breakpoint.h"
#include <linux/random.h>
#include "hw_breakpointManage.h"

#define PROC_FILE_DEBUG "breakpoint"
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 72)
#define VM_LAZY_FREE 0x02
#define VM_VM_AREA 0x04
#endif

static struct proc_dir_entry *proc_file = NULL;

//帮助
char *test_proc_write_usag = {
	"Usage:\n"
	"\thw_break support cmd type: \n"
	"\t\t1: echo add <type> <len> <symbol>/<addr> > /proc/breakpoint, add a breakpoint\n"
	"\t\t\t[type]:\n"
	"\t\t\t\t[wp1]: HW_BREAKPOINT_R\n"
	"\t\t\t\t[wp2]: HW_BREAKPOINT_W\n"
	"\t\t\t\t[wp3]: HW_BREAKPOINT_R|HW_BREAKPOINT_W\n"
	"\t\t\t\t[bp]:  HW_BREAKPOINT_X\n"
	"\t\t\t[len]:[0,8] (2^3,2^31]\n"
	"\t\t2: echo del <symbol> > /proc/breakpoint, del a breakpoint\n"
	"\t\t3: echo get ptr/val <symbol> > /proc/breakpoint, search &symbol/*(&symbol)\n"
	"\t\t4: echo iophy <ioaddr> > /proc/breakpoint, search all of ioaddr map virt\n"
};
char *test_proc_write_example = {
	"Example:\n"
	"\tThe first step:\n"
	"\t\techo add wp3 4 zwf_test_value0 > /proc/breakpoint, add a watchpoint at "
	"&zwf_test_value0\n"
	"\tThe second step:\n"
	"\t\techo write 0 0 > /proc/breakpoint, write zwf_test_value0\n"
	"\tThe third step:\n"
	"\t\techo read 0 0 > /proc/breakpoint, read zwf_test_value0\n"
	"\tThe forth step:\n"
	"\t\techo del zwf_test_value0 > /proc/breakpoint, del wawtchpoint at "
	"&zwf_test_value0\n"
};
/*******************************************************************************
* 函数名  : print_cmd_params
* 描  述  : 打印cmd的一些参数信息
* 输  入  : - argc  :
*         : - argv[]:
* 输  出  : 无
* 返回值  : OSA_SOK  : 成功
*           OSA_EFAIL: 失败
*******************************************************************************/
void print_cmd_params(int argc, char *argv[])
{
	int loop = 0;

	for (loop = 0; loop < argc; loop++) {
		printk("loop:%d, %s\n", loop, argv[loop]);
	}
}

/*******************************************************************************
* 函数名  : processCmdString
* 描  述  : 处理cmd的字符串信息
* 输  入  : - pBuf   :
*         : - pArgc  :
*         : - pArgv[]:
* 输  出  : 无
* 返回值  : OSA_SOK  : 成功
*           OSA_EFAIL: 失败
*******************************************************************************/
void processCmdString(char *pBuf, int *pArgc, char *pArgv[])
{
	int iArgc;
	char *pTmp = pBuf;

	pArgv[0] = pBuf;
	iArgc = 1;

	while (*pTmp) {
		if (' ' == *pTmp) {
			*pTmp = '\0';
			pArgv[iArgc++] = pTmp + 1;
		}

		pTmp++;
	}
	*pArgc = iArgc;
	// print_cmd_params(*pArgc, pArgv);
}

static ssize_t hw_proc_read(struct file *file, char __user *pBuf, size_t count,
			    loff_t *pPos)
{
	printk("hw_proc_read\n");

	return 0;
}

u32 zwf_test_value3[32] = { 0 };
u32 zwf_test_value2[32] = { 0 };
u32 zwf_test_value1[32] = { 0 };
u32 zwf_test_value0[32] = { 0 };

/*显示一块vm struct，以及物理地址对应的虚拟地址*/
static void HW_testShowVm(struct vm_struct *area, u64 phyAddr)
{
	printk("--------------------------------------------------\n");
	if (area->phys_addr) {
		printk("\tphy addr:\t0x%llx\n", area->phys_addr);
	}
	if (area->addr) {
		printk("\tvirt addr:\t0x%llx\n", area->addr);
	}
	if (area->size) {
		printk("\tsize:\t\t0x%llx\n", area->size);
	}
	if (area->addr && area->phys_addr) {
		printk("0x%llx to virt: 0x%llx\n", phyAddr,
		       area->addr + phyAddr - area->phys_addr);
	}
	printk("\n");
}

/*proc 通过IO地址查询所有映射过的虚拟地址*/
static void HW_testIOPhyToVirt(char *addrB)
{
	u64 ioAddr = 0;

	if (!kernelApi.val.vmap_area_list || !kernelApi.val.vmap_area_lock) {
		printk("vmap_area_list or vmap_area_lock is NULL, can not get virt");
		return;
	}

	/*buf转IO地址*/
	ioAddr = simple_strtol(addrB, NULL, 0);

	/*查询所有虚拟地址*/
	struct vmap_area *va = NULL;
	spin_lock(kernelApi.val.vmap_area_lock);
	list_for_each_entry(va, kernelApi.val.vmap_area_list, list) {
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 72)
		if (!(va->flags & VM_VM_AREA)) {
			continue;
		}
#endif
		struct vm_struct *area = va->vm;
		if (!area) {
			continue;
		}
		if (!(area->flags & VM_IOREMAP) ||
		    area->flags & VM_UNINITIALIZED) {
			continue;
		}
		/*在invalid queue的数据被刷完之后再执行屏障后的读操作*/
		smp_rmb();
		/*找到了IO地址，检查要查询的IO地址是否在该IO地址范围内*/
		struct vm_struct *next = area;
		while (next) {
			if (next->phys_addr && next->size) {
				/*要查询的IO地址在其范围内*/
				if (ioAddr >= next->phys_addr &&
				    ioAddr < next->phys_addr + next->size) {
					HW_testShowVm(next, ioAddr);
				}
			}
			next = next->next;
			if (next == area) {
				break;
			}
		}
	}
	spin_unlock(kernelApi.val.vmap_area_lock);
}

/*proc get查询*/
static int HW_testGet(char *typeB, char *nameB)
{
	u64 addr = 0;

	/*查询符号地址*/
	addr = kernelApi.fun.kallsyms_lookup_name(nameB);
	if (!addr || addr < TASK_SIZE) {
		printk("can not find symbol %s\n", nameB);
		return -1;
	}
	if (strcmp("ptr", typeB) == 0) {
		printk("&%s = 0x%llx\n", nameB, addr);
	} else if (strcmp("val", typeB) == 0) {
		printk("*(%s) = 0x%llx\n", nameB, *((u64 *)addr));
	} else {
		return -1;
	}
	return 0;
}

/*proc删除断点*/
static void HW_testDel(char *nameB)
{
	u64 uninstallAddr = 0;

	if (nameB[0] == '0' && nameB[1] == 'x') {
		uninstallAddr = simple_strtol(nameB, 0, 0);
	}
	if (uninstallAddr) {
		printk("will uninstall at 0x%llx\n", uninstallAddr);
		HW_breakpointUnInstallFromAddr(uninstallAddr);
	} else {
		printk("will uninstall at &%s\n", nameB);
		HW_breakpointUnInstallFromSymbol(nameB);
	}
}

/*proc添加断点*/
static int HW_testAdd(char *tybeB, char *lenB, char *nameB)
{
	char *name = NULL;
	int len = HW_BREAKPOINT_LEN_4, type = 0;
	u64 installAddr = 0;

	/*判断断点类型*/
	switch (strlen(tybeB)) {
	/*长度是2代表执行断点*/
	case 2: {
		type = HW_BREAKPOINT_X;
		name = nameB;
		break;
	}
	/*长度是3代表内存断点，第三个字符是断点类型*/
	case 3: {
		type = tybeB[2] - '0';
		len = (int)simple_strtoul(lenB, NULL, 0);
		name = nameB;
		break;
	}
	default: {
		return -1;
	}
	}
	/*检查断点类型是否合法*/
	if (type < 1 || type > 4) {
		return -1;
	}

	if (nameB[0] == '0' && nameB[1] == 'x') {
		installAddr = simple_strtol(nameB, 0, 0);
	}
	if (installAddr) {
		printk("will install at 0x%llx\n", installAddr);
		HW_breakpointInstallFromAddr(installAddr, len, type);
	} else {
		printk("will install at &%s\n", name);
		HW_breakpointInstallFromSymbol(name, len, type);
	}
	return 0;
}

/*测试写入*/
static void HW_testReadWrite(char *cmd, char *testIndexB, char *indexB)
{
	int index = simple_strtol(testIndexB, NULL, 0);
	int index1 = simple_strtol(indexB, NULL, 0);
	u32 *tmpbuf;
	switch (index) {
	case 0: {
		tmpbuf = zwf_test_value0;
		break;
	}
	case 1: {
		tmpbuf = zwf_test_value1;
		break;
	}
	case 2: {
		tmpbuf = zwf_test_value2;
		break;
	}
	case 3:
	default: {
		tmpbuf = zwf_test_value3;
		break;
	}
	}
	if (strcmp("write", cmd) == 0) {
		printk("will write zwf_test_value%d[%d], addr = %lx\n", index,
		       index1, &tmpbuf[index1]);
		tmpbuf[index1] = get_random_u32();
	} else if (strcmp("read", cmd) == 0) {
		printk("will read zwf_test_value%d[%d], addr = %lx\n", index,
		       index1, &tmpbuf[index1]);
		printk("zwf_test_value%d[%d] = %d\n", index, index1,
		       tmpbuf[index1]);
	}
}

static ssize_t hw_proc_write(struct file *file, const char __user *pBuf,
			     size_t count, loff_t *pPos)
{
	size_t ret;
	char cmdBuf[128] = { 0 };
	int argc = 0;
	char *argv[10] = { NULL };

	// printk("hw_proc_write\n");

	if ((count > sizeof(cmdBuf)) || (count == 0)) {
		printk("test proc write, count is error!\n");
		return count;
	}

	memset(cmdBuf, 0, sizeof(cmdBuf));
	ret = copy_from_user(cmdBuf, pBuf, count);
	if (0 != ret) {
		printk("fail to copy data from user!\n");
		return count;
	}

	//将数据的最后一个换行符改为0
	cmdBuf[count - 1] = '\0';
	memset(argv, 0, sizeof(argv));
	processCmdString(cmdBuf, &argc, argv);

	// printk("CPU = %d\n", raw_smp_processor_id());

	if (strcmp("write", argv[0]) == 0 || strcmp("read", argv[0]) == 0) {
		if (argc != 3) {
			goto cmdErr;
		}
		HW_testReadWrite(argv[0], argv[1], argv[2]);
		return count;
	} else if (strcmp("show", argv[0]) == 0) {
		HW_breakpointShowAll();
		return count;
	} else if (strcmp("help", argv[0]) == 0) {
		printk(test_proc_write_usag);
		printk(test_proc_write_example);
		return count;
	}

	if (strcmp("add", argv[0]) == 0) {
		if (argc != 4) {
			// printk("argc = %d\n",argc);
			goto cmdErr;
		}
		if (HW_testAdd(argv[1], argv[2], argv[3])) {
			goto cmdErr;
		}
	} else if (strcmp("del", argv[0]) == 0) {
		if (argc != 2) {
			// printk("argc = %d\n",argc);
			goto cmdErr;
		}
		HW_testDel(argv[1]);
	} else if (strcmp("get", argv[0]) == 0) {
		if (argc != 3) {
			// printk("argc = %d\n",argc);
			goto cmdErr;
		}
		if (HW_testGet(argv[1], argv[2])) {
			goto cmdErr;
		}
	} else if (strcmp("iophy", argv[0]) == 0) {
		if (argc != 2) {
			// printk("argc = %d\n",argc);
			goto cmdErr;
		}
		HW_testIOPhyToVirt(argv[1]);
	} else {
		goto cmdErr;
	}

	return count;
cmdErr:
	printk("cmd error, echo help > /proc/breakpoint\n");
	return count;
}

#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 1, 10)
static const struct proc_ops hw_proc_fops = {
	.proc_read = hw_proc_read,
	.proc_write = hw_proc_write,
};
#else
static const struct file_operations hw_proc_fops = {
	.open = NULL,
	.read = hw_proc_read,
	.write = hw_proc_write,
};
#endif

int hw_proc_init(void)
{
	proc_file = proc_create(PROC_FILE_DEBUG, S_IRUGO | S_IWUGO, NULL,
				&hw_proc_fops);
	if (NULL == proc_file) {
		printk("hw proc init, Create %s proc file failed!\n",
		       PROC_FILE_DEBUG);
		return -ENOMEM;
	}
	printk(test_proc_write_usag);
	printk(test_proc_write_example);
	return 0;
}

void hw_proc_exit(void)
{
	if (NULL != proc_file) {
		remove_proc_entry(PROC_FILE_DEBUG, NULL);
	}
}
```