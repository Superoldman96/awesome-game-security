Project Path: arc_gmh5225_DLAC_eyjlo0c2

Source Tree:

```txt
arc_gmh5225_DLAC_eyjlo0c2
├── DLAC
│   ├── __init__.py
│   ├── anticheat.py
│   ├── data
│   │   └── data.csv
│   ├── go.mod
│   ├── go.sum
│   ├── models
│   │   ├── best.pt
│   │   ├── bigger.onnx
│   │   └── small.onnx
│   ├── new_parser
│   │   └── main.go
│   ├── parser.go
│   ├── parser.so
│   ├── scaler.gz
│   └── utils
│       ├── filter.pyx
│       ├── filter_players.py
│       └── webdatasetmaker.py
├── README.md
├── images
│   ├── Gruception.png
│   ├── Transformer.png
│   └── current.png
├── setup.py
├── test.py
└── training
    ├── Multi-kill-gru.py
    └── Simple-gru.py

```

`DLAC/__init__.py`:

```py
from .anticheat import Model
```

`DLAC/anticheat.py`:

```py
import csv
import time
import sklearn
import joblib
import pandas as pd
import math
import numpy as np
import onnxruntime
import os
from ctypes import *
from ctypes import cdll


# Send paths to Golang
class go_string(Structure):
    _fields_ = [
        ("p", c_char_p),
        ("n", c_int)]


class Model:

    def __init__(self, dem_folder, model_type='small'):
        self.model_type = model_type
        dirname = os.path.dirname(__file__)
        self._parser(dem_folder, dirname)
        # Parser outputs 1x1728 row
        self.scaler = joblib.load(os.path.join(dirname, 'scaler.gz'))
        self.X = pd.read_csv(os.path.join(dirname, 'data/data.csv'), header=None).to_numpy().reshape(-1, 192, 9)
        # Remove file after reading
        os.remove(os.path.join(dirname, 'data/data.csv'))
        # ONNX

        if model_type == 'small':
            self.ort_session = onnxruntime.InferenceSession(os.path.join(dirname, 'models/small.onnx'))
        elif model_type == 'big':
            self.ort_session = onnxruntime.InferenceSession(os.path.join(dirname, 'models/bigger.onnx'))
        else:
            raise FileNotFoundError('Unknown model_type, use "small" or "big"')


    # Calls Go parser
    def _parser(self, dem_folder, dirname):
        lib = cdll.LoadLibrary(os.path.join(dirname, 'parser.so'))
        lib.startparsing.restype = c_char_p
        lib.startparsing(c_char_p(dirname.encode()), c_char_p(dem_folder.encode()))

    def _predict(self, batch_size):
        # Parser outputs other information that isn't used in the prediction and is combined after prediction
        self.file = self.X[:, 0, 0]
        self.name = self.X[:, 0, 1]
        self.id = self.X[:, 0, 2]
        self.tick = self.X[:, 0, 3]

        self.X = np.float32(self.X[:, :, 4:])  # Data that is input into the model.
        # Only the bigger model uses scaling
        if self.model_type == 'big':
            self.X = self.scaler.transform(self.X.reshape(-1, 5)).reshape(-1, 192, 5)
        else:
            # smaller model uses 128 tick and bigger uses 192
            self.X = self.X[:, 192-128:, :]

        total_batches = math.ceil(self.X.shape[0] / batch_size)
        confidence = []
        for batch in range(total_batches):
            # Slice current batch
            data_this_batch = self.X[batch_size * batch: batch_size * batch + batch_size, :, :]
            # ONNX inputs
            ort_inputs = {self.ort_session.get_inputs()[0].name: data_this_batch}
            # Predict
            ort_outs = np.array(self.ort_session.run(None, ort_inputs))
            # index the cheating conf
            cheating_confidence = list(ort_outs[0][:, 1])
            # Add batch to output
            confidence.extend(cheating_confidence)
        self.confidence = np.array(confidence)

    def predict_to_terminal(self, threshold=0.95, batch_size=1000):
        self._predict(batch_size)     # Does the actual prediction
        # Loop trough each shot in the game
        print("Name", "Confidence", "ID", "File")
        for shot in range(len(self.confidence)):
            if self.confidence[shot] > threshold:
                print(self.name[shot], self.confidence[shot], self.id[shot], self.file[shot])

    def predict_to_csv(self, out_file, threshold=0.95, batch_size=1000):
        self._predict(batch_size)     # Does the actual prediction
        # Create headers for csv
        with open(out_file, 'w', newline='\n')as f:
            thewriter = csv.writer(f)
            thewriter.writerow(["name", "confidence", "id", "file"])
        # Loop trough each shot in the game
        for shot in range(len(self.confidence)):
            if self.confidence[shot] > threshold:
                with open(out_file,'a',newline='\n')as f:
                    thewriter = csv.writer(f)
                    thewriter.writerow([self.name[shot], self.confidence[shot], self.id[shot], self.file[shot]])

    def predict_to_list(self, threshold=0.95, batch_size=1000):
        # Returns a list for each shot, so the output is a list of lists
        outputs = []
        self._predict(batch_size)     # Does the actual prediction
        # Loop trough each shot in the game
        for shot in range(len(self.confidence)):
            if self.confidence[shot] > threshold:
                outputs.append([self.name[shot], self.confidence[shot], self.id[shot], self.file[shot]])
        return outputs

    def predict_total_detections_to_dict(self, batch_size=1000):
        output_dict = {}
        self._predict(batch_size)  # Does the actual prediction
        # Loop trough each shot in the game
        for shot in range(len(self.confidence)):
            if self.name[shot] not in output_dict:
                output_dict[self.name[shot]] = 1
            else:
                output_dict[self.name[shot]] += 1
        out = {k: v for k, v in sorted(output_dict.items(),reverse=True, key=lambda item: item[1])}
        return out

    def predict_averages_to_dict(self, batch_size=1000):
        output_dict = {}
        self._predict(batch_size)  # Does the actual prediction
        # Loop trough each shot in the game
        for shot in range(len(self.confidence)):
            if self.name[shot] not in output_dict:
                output_dict[self.name[shot]] = [self.confidence[shot]]
            else:
                output_dict[self.name[shot]].append(self.confidence[shot])
        out = {k: sum(v) / len(v) for k, v in sorted(output_dict.items(), key=lambda item: item[1])}
        out = {k: v for k, v in sorted(out.items(),reverse=True ,key=lambda item: item[1])}
        return out
```

`DLAC/go.mod`:

```mod
module github.com/LaihoE/DLAC

go 1.15

require (
	github.com/golang/geo v0.0.0-20210211234256-740aa86cb551
	github.com/markus-wa/demoinfocs-golang/v2 v2.12.0
)

```

`DLAC/go.sum`:

```sum
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dustin/go-heatmap v0.0.0-20180603032536-b89dbd73785a/go.mod h1:VBmwC4U3p2SMEKr+/m5j0eby7rmUtSoA5TGLwe6P+3A=
github.com/go-gl/gl v0.0.0-20180407155706-68e253793080/go.mod h1:482civXOzJJCPzJ4ZOX/pwvXBWSnzD4OKMdH4ClKGbk=
github.com/go-gl/glfw v0.0.0-20180426074136-46a8d530c326/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=
github.com/golang/geo v0.0.0-20180826223333-635502111454/go.mod h1:vgWZ7cu0fq0KY3PpEHsocXOWJpRtkcbKemU4IUw0M60=
github.com/golang/geo v0.0.0-20210211234256-740aa86cb551 h1:gtexQ/VGyN+VVFRXSFiguSNcXmS6rkKT+X7FdIrTtfo=
github.com/golang/geo v0.0.0-20210211234256-740aa86cb551/go.mod h1:QZ0nwyI2jOfgRAoBvP+ab5aRr7c9x7lhGEJrKvBwjWI=
github.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/llgcode/draw2d v0.0.0-20200930101115-bfaf5d914d1e/go.mod h1:mVa0dA29Db2S4LVqDYLlsePDzRJLDfdhVZiI15uY0FA=
github.com/llgcode/ps v0.0.0-20150911083025-f1443b32eedb/go.mod h1:1l8ky+Ew27CMX29uG+a2hNOKpeNYEQjjtiALiBlFQbY=
github.com/markus-wa/demoinfocs-golang v1.11.0 h1:0VSWmeZ8kOeQIpit1+Kisf2KLtcCosNTjzPxhQkDdO8=
github.com/markus-wa/demoinfocs-golang/v2 v2.12.0 h1:XdUZ/SUgZdPNarerbErDuM1n7BlCzQs6DgbX5+9OR2w=
github.com/markus-wa/demoinfocs-golang/v2 v2.12.0/go.mod h1:BPIElNIVtyVzzc2AD3w/yMbiHiaq91o6L873PdZJobo=
github.com/markus-wa/go-unassert v0.1.2 h1:uXWlMDa8JVtc4RgNq4XJIjyRejv9MOVuy/E0VECPxxo=
github.com/markus-wa/go-unassert v0.1.2/go.mod h1:XEvrxR+trvZeMDfXcZPvzqGo6eumEtdk5VjNRuvvzxQ=
github.com/markus-wa/gobitread v0.2.3 h1:COx7dtYQ7Q+77hgUmD+O4MvOcqG7y17RP3Z7BbjRvPs=
github.com/markus-wa/gobitread v0.2.3/go.mod h1:PcWXMH4gx7o2CKslbkFkLyJB/aHW7JVRG3MRZe3PINg=
github.com/markus-wa/godispatch v1.4.1 h1:Cdff5x33ShuX3sDmUbYWejk7tOuoHErFYMhUc2h7sLc=
github.com/markus-wa/godispatch v1.4.1/go.mod h1:tk8L0yzLO4oAcFwM2sABMge0HRDJMdE8E7xm4gK/+xM=
github.com/markus-wa/quickhull-go/v2 v2.1.0 h1:DA2pzEzH0k5CEnlUsouRqNdD+jzNFb4DBhrX4Hpa5So=
github.com/markus-wa/quickhull-go/v2 v2.1.0/go.mod h1:bOlBUpIzGSMMhHX0f9N8CQs0VZD4nnPeta0OocH7m4o=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

```

`DLAC/new_parser/main.go`:

```go
package main

import (
	"math"
	"os"
	"C"
	"fmt"
	"encoding/csv"
	"io/ioutil"
	"log"


	"github.com/golang/geo/r3"
	dem "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs"
	common "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/common"
	events "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/events"
)

// MAJOIRTY OF CODE IS WRITTEN BY 87andrewh, found at: https://github.com/87andrewh/DeepAimDetector/blob/master/parser/to_csv.go
// MAJOIRTY OF CODE IS WRITTEN BY 87andrewh, found at: https://github.com/87andrewh/DeepAimDetector/blob/master/parser/to_csv.go





// USEAGE go run main.go "path_to_demos" -> outputs data to /data






// Defines amount of frames to collect around attacks
const samplesPerSecond = 32
const secondsBeforeAttack = 5
const secondsAfterAttack = 1
const secondsPerAttack = secondsBeforeAttack + secondsAfterAttack
const samplesPerAttack = int(samplesPerSecond * secondsPerAttack)

// PlayerData stores all data of a player in a single frame.
type PlayerData struct {
    ViewDirectionY float32
    ViewDirectionX float32
    ammoleft  int
    nSpotted  int
    score     int
    Ping      int
    IsScoped  bool
	flashleft float32
	id 		  uint64
	name      string
    xv        float64
    yv        float64
    zv        float64
	weapon    int
	position  r3.Vector
	yaw       float32
	pitch     float32
	crouching bool
	firing    bool
	health    int
}

// AttackTime marks when an attacker shot a victim
type AttackTime struct {
	attacker    int
	victim      int
	startFrame  int
	attackFrame int
	endFrame    int
	a_spotted_v  bool
	v_spotted_a  bool
}

// FireFrameKey is a key to a dictionary that marks
// if a shooter shoot at a given frame
type FireFrameKey struct {
	shooter int
	frame   int
}

// AttackData stores the features of a single sample fed into the model.
type AttackData struct {
	// Whether the attacker used an aimbot during the attack
	attackerAimbot bool

	// One-hot encoding of attacking gun
	weaponAK47 bool
	weaponM4A4 bool
	weaponAWP  bool

	// Viewangle deltas
	attackerDeltaYaw   [samplesPerAttack]float32
	attackerDeltaPitch [samplesPerAttack]float32
    victimDeltaYaw   [samplesPerAttack]float32
	victimDeltaPitch [samplesPerAttack]float32

	// Angles between the attacker's crosshair and the victim
	crosshairToVictimYaw   [samplesPerAttack]float32
	crosshairToVictimPitch [samplesPerAttack]float32

    crosshairToAttackerYaw   [samplesPerAttack]float32
	crosshairToAttackerPitch [samplesPerAttack]float32

	victimDistance    [samplesPerAttack]float32
	attackerCrouching [samplesPerAttack]bool
	victimCrouching   [samplesPerAttack]bool
	attackerFiring    [samplesPerAttack]bool
    victimFiring    [samplesPerAttack]bool

	attackerHealth [samplesPerAttack]int
	victimHealth   [samplesPerAttack]int

	attackerViewVector     [samplesPerAttack]r3.Vector
	attackerToVictimVector [samplesPerAttack]r3.Vector

	attackerX [samplesPerAttack]float32
	attackerY [samplesPerAttack]float32
	attackerZ [samplesPerAttack]float32

	victimX [samplesPerAttack]float32
	victimY [samplesPerAttack]float32
	victimZ [samplesPerAttack]float32

	flashleft [samplesPerAttack]float32
	id [samplesPerAttack]uint64

	attackerxv      [samplesPerAttack]float64
	attackeryv      [samplesPerAttack]float64
	attackerzv      [samplesPerAttack]float64

	victimxv      [samplesPerAttack]float64
	victimyv      [samplesPerAttack]float64
	victimzv      [samplesPerAttack]float64

    a_spotted_v  [samplesPerAttack]bool
	v_spotted_a  [samplesPerAttack]bool

	name      [samplesPerAttack]string
	visible   [samplesPerAttack]bool
	frame [samplesPerAttack]int
	IsScoped [samplesPerAttack]bool
    Ping [samplesPerAttack]int

    weapon [samplesPerAttack]int
    nSpotted [samplesPerAttack]int
	filename string
	AmmoLeft [samplesPerAttack]int
	ViewDirectionY [samplesPerAttack]float32
    ViewDirectionX [samplesPerAttack]float32
    enemyPing [samplesPerAttack]int
}

// Marks guns that the model will be trained on
// TODO: Test model on different sets of guns.
var validGuns = map[string]bool{
	"AK-47":  true,
	"M4A4":   true,
	"AWP":    true,
	"M4A1":   true,
	"AUG":    true,
	"SG 553": true,
}

// Stores data to be fed into model
var modelData = []AttackData{}


//export startparsing
func startparsing(){
    source_go := os.Args[1]
    fmt.Println(source_go)
	files, err := ioutil.ReadDir(source_go)

	if err != nil {
		log.Fatal(err)
	}
	for _, f := range files {
		parseDemo(source_go, f.Name())
	}
	csvExport()
}

func main(){
    startparsing()
}


func parseDemo(source string, name string) {
    var suspect = uint64(42)
	// Times when a player is attacked by a valid gun
	var attackTimes = []AttackTime{}
	// Marks if a player is firing at a given frame.
	var fireFrames = map[FireFrameKey]bool{}
	// Marks frames surrounding attacks that should be gathered
	// for easier processing into model inputs
	var isMarked = map[int]bool{}
	// Stores the PlayerData for each player for each marked framed
	var markedFrameData = map[int]map[int]PlayerData{}
	//var markedFrameData = make([]int, 0)
	// Marks if the demo was generated with an aimbot

	f, err := os.Open(source + name)
	defer f.Close()
	checkError(err)
	p := dem.NewParser(f)

	h, err := p.ParseHeader()
	FrameRate := h.FrameRate()

	// Calculate the demo framerate with some hacks
	tick := -1
	for !(2900 < tick && tick < 3000) {
		_, err = p.ParseNextFrame()
		tick = p.GameState().IngameTick()
	}
	checkError(err)
	iters := 10
	for i := 0; i < iters; i++ {
		_, err = p.ParseNextFrame()
		checkError(err)
	}
	nextTick := p.GameState().IngameTick()

	TicksPerFrame := float64(nextTick-tick) / float64(iters)
	FrameRate2 := p.TickRate() / TicksPerFrame

	if FrameRate == 0 {
		FrameRate = FrameRate2
	}

	var framesBeforeAttack int
	var framesAfterAttack int
	if (math.Abs(FrameRate-32.0) < 1) && (FrameRate2 == 32) {
		framesBeforeAttack = secondsBeforeAttack * 32
		framesAfterAttack = secondsAfterAttack * 32
	} else if (math.Abs(FrameRate-64.0) < 4) && (FrameRate2 == 64) {
		framesBeforeAttack = secondsBeforeAttack * 64
		framesAfterAttack = secondsAfterAttack * 64
	} else if (math.Abs(FrameRate-128) < 4) && (FrameRate2 == 128) {
		framesBeforeAttack = secondsBeforeAttack * 128
		framesAfterAttack = secondsAfterAttack * 128
	} else {
		println("Invalid frame rate: ", FrameRate, FrameRate2)
		return
	}

	framesPerAttack := framesBeforeAttack + framesAfterAttack
	framesPerSample := int(framesPerAttack / samplesPerAttack)
	//println("Frames per sample ", framesPerSample)

	// First pass.

	// Get frame times of attacks with valid guns,
	// and mark surrounding frames for retrieval.
	var attackCount int = 0
	var start int = 0
	var end int = 0
	var frame int = 0
	var attackFrame int

	p.RegisterEventHandler(func(e events.PlayerHurt) {
		 if e.Attacker.SteamID64 != suspect{
		    if suspect != uint64(42){
			    return
		    }
		}
		attackCount++
		attackFrame = p.CurrentFrame()
		start = attackFrame - framesBeforeAttack
		end = attackFrame + framesAfterAttack
		for frame = start; frame < end; frame++ {
			isMarked[frame] = true
		}
		isMarked[start-framesPerSample] = true // For first sample delta angles
        a_spotted_v := e.Attacker.HasSpotted(e.Player)
        v_spotted_a := e.Player.HasSpotted(e.Attacker)

		new := AttackTime{e.Attacker.UserID, e.Player.UserID, start, attackFrame, end, a_spotted_v, v_spotted_a}
		attackTimes = append(attackTimes, new)
	})

	// Track frames where a player fires a weapon
	var i int = 0
	p.RegisterEventHandler(func(e events.WeaponFire) {
		frame = p.CurrentFrame()
		// Include previous frames so that shot is not lost after sampling
		for i = 0; i < framesPerSample; i++ {
			fireFrames[FireFrameKey{e.Shooter.UserID, frame - i}] = true
		}
	})
	err = p.ParseToEnd()
    //fmt.Printf("Valid attacks: %d\n", attackCount)

	// Second pass.

	// Extract player data from marked frames
	f, err = os.Open(source + name)
	p = dem.NewParser(f)
    var ok bool

	for ok = true; ok; ok, err = p.ParseNextFrame() {
		checkError(err)
		frame = p.CurrentFrame()
		if !isMarked[frame] {
			continue
		}

		var players = map[int]PlayerData{}
		gs := p.GameState()

		for _, player := range gs.Participants().Playing() {
		    hasSpotted := gs.Participants().SpottedBy(player)
			players[player.UserID] = extractPlayerData(hasSpotted,frame, player, fireFrames)
		}
		markedFrameData[frame] = players
	}

	// Extract each attack's AttackData, and add it to modelData
	for _, attack := range attackTimes {
		//weapon := markedFrameData[attack.attackFrame][attack.attacker].weapon
		attackData := AttackData{}

		prevFrame := attack.startFrame - framesPerSample
		prevAttackerYaw := markedFrameData[prevFrame][attack.attacker].yaw
		prevAttackerPitch := markedFrameData[prevFrame][attack.attacker].pitch
		prevVictimYaw := markedFrameData[prevFrame][attack.victim].yaw
		prevVictimPitch := markedFrameData[prevFrame][attack.victim].pitch

        var attackerToVictim r3.Vector
        var attackerToVictimYaw float32
        var attackerToVictimPitch float32
        var sample int
        var attackerYaw float32
        var attackerPitch float32
        var victimToAttacker r3.Vector
        var victimToAttackerYaw float32
        var victimToAttackerPitch float32
        var victimYaw float32
        var victimPitch float32

		for sample = 0; sample < samplesPerAttack; sample++ {
			frame = framesPerSample*sample + attack.startFrame
			attacker := markedFrameData[frame][attack.attacker]
			victim := markedFrameData[frame][attack.victim]

            victimYaw = victim.yaw
            victimPitch = victim.pitch
			attackerYaw = attacker.yaw
			attackerPitch = attacker.pitch

			attackData.victimDeltaYaw[sample] = normalizeAngle(victimYaw - prevVictimYaw)
			attackData.victimDeltaPitch[sample] = victimPitch - prevVictimPitch
			attackData.attackerDeltaYaw[sample] = normalizeAngle(attackerYaw - prevAttackerYaw)
			attackData.attackerDeltaPitch[sample] = attackerPitch - prevAttackerPitch

			prevAttackerYaw = attackerYaw
			prevAttackerPitch = attackerPitch
			prevVictimYaw = victimYaw
			prevVictimPitch = victimPitch

			attackerToVictim = victim.position.Sub(attacker.position)
			attackData.attackerToVictimVector[sample] = attackerToVictim.Normalize()
            victimToAttacker = attacker.position.Sub(victim.position)
			attackData.attackerToVictimVector[sample] = victimToAttacker.Normalize()

			dXa := attackerToVictim.X
			dYa := attackerToVictim.Y
			dZa := attackerToVictim.Z

			dXv := victimToAttacker.X
			dYv := victimToAttacker.Y
			dZv := victimToAttacker.Z

			attackerToVictimYaw = 180 / math.Pi * float32(math.Atan2(dYa, dXa))
			attackerToVictimPitch = 180 / math.Pi * float32(math.Atan2(math.Sqrt(dXa*dXa+dYa*dYa),dZa))

			victimToAttackerYaw = 180 / math.Pi * float32(math.Atan2(dYv, dXv))
			victimToAttackerPitch = 180 / math.Pi * float32(math.Atan2(math.Sqrt(dXv*dXv+dYv*dYv),dZv))

			// Smallest angle between attackerToVictimYaw and attackerYaw
			attackData.crosshairToVictimYaw[sample] = normalizeAngle(attackerToVictimYaw - attackerYaw)
			attackData.crosshairToVictimPitch[sample] =	attackerToVictimPitch - attackerPitch

            attackData.crosshairToAttackerYaw[sample] = normalizeAngle(victimToAttackerYaw - victimYaw)
			attackData.crosshairToAttackerPitch[sample] =	victimToAttackerPitch - victimPitch

			attackData.victimDistance[sample] = float32(attackerToVictim.Norm())

			attackData.attackerCrouching[sample] = attacker.crouching
			attackData.victimCrouching[sample] = victim.crouching
			attackData.attackerFiring[sample] = attacker.firing
            attackData.victimFiring[sample] = victim.firing

			attackData.attackerHealth[sample] = attacker.health
			attackData.victimHealth[sample] = victim.health

			attackerYaw64 := float64(math.Pi / 180 * attackerYaw)
			attackerPitch64 := float64(math.Pi / 180 * attackerPitch)
			attackData.attackerViewVector[sample] = r3.Vector{
				math.Cos(attackerYaw64) * math.Sin(attackerPitch64),
				math.Sin(attackerYaw64) * math.Sin(attackerPitch64),
				math.Cos(attackerPitch64)}

			attackData.attackerX[sample] = float32(attacker.position.X)
			attackData.attackerY[sample] = float32(attacker.position.Y)
			attackData.attackerZ[sample] = float32(attacker.position.Z)

			attackData.victimX[sample] = float32(victim.position.X)
			attackData.victimY[sample] = float32(victim.position.Y)
			attackData.victimZ[sample] = float32(victim.position.Z)

            attackData.attackerxv[sample] = attacker.xv
            attackData.attackeryv[sample] = attacker.yv
            attackData.attackerzv[sample] = attacker.zv

            attackData.victimxv[sample] = victim.xv
            attackData.victimyv[sample] = victim.yv
            attackData.victimzv[sample] = victim.zv

            attackData.v_spotted_a[sample] = attack.v_spotted_a
            attackData.a_spotted_v[sample] = attack.a_spotted_v

            attackData.weapon[sample] = attacker.weapon
			attackData.flashleft[sample]  = attacker.flashleft

			attackData.name[sample]  = attacker.name
			attackData.id[sample] = attacker.id
			attackData.frame[sample] = frame
			attackData.IsScoped[sample] = attacker.IsScoped
            attackData.Ping[sample] = attacker.Ping
            attackData.nSpotted[sample] = victim.nSpotted
            attackData.AmmoLeft[sample] = attacker.weapon
            attackData.enemyPing[sample] = victim.Ping
		}
		// A player teleported. Throw away the data.
		modelData = append(modelData, attackData)
	}
	f.Close()
}

func extractPlayerData(
    spotted []*common.Player,
	frame int,
	player *common.Player,
	fireFrames map[FireFrameKey]bool) PlayerData{
	fixedPitch := float32(math.Mod(float64(player.ViewDirectionY())+90,180))
    ogViewDirectionX := player.ViewDirectionX()
    ogViewDirectionY := player.ViewDirectionY()

    var vel r3.Vector
    var xv float64
    var yv float64
    var zv float64

    vel = player.Velocity()
    xv = vel.X
    yv = vel.Y
    zv = vel.Z

    activeweapon := player.ActiveWeapon()
    var ammoleft int = -2
    var weapon int = -2
    // ActiveWeapon might return nil
    if activeweapon == nil{
        ammoleft = -2
        weapon = -2
    }else{
        ammoleft = activeweapon.AmmoInMagazine()
        weapon = int(activeweapon.Type)
    }

	return PlayerData{
	    ogViewDirectionX,
	    ogViewDirectionY,
	    ammoleft,
	    len(spotted),
	    player.Score(),
	    player.Ping(),
	    player.IsScoped(),
		player.FlashDuration,
		player.SteamID64,
		player.Name,
		xv,
		yv,
		zv,
		weapon,
		player.LastAlivePosition,
		player.ViewDirectionX(),
		fixedPitch,
		player.IsDucking(),
		fireFrames[FireFrameKey{player.UserID, frame}],
		player.Health()}
}



func csvExport() error {
    dataDest := "./data/data.csv"
	file, err := os.OpenFile(dataDest, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}

	writer := csv.NewWriter(file)

	for _, attackData := range modelData {
		err := writer.Write(attackToString(attackData))
		if err != nil {
			return err
		}
	}
	writer.Flush()
	file.Close()
	return nil
}


func attackToString(data AttackData) []string {
	var out []string

	for i := 0; i < samplesPerAttack; i++ {
		out = append(out, fmt.Sprintf(data.name[i]))

	    out = append(out, fmt.Sprintf("%.4f", data.ViewDirectionX[i]))
	    out = append(out, fmt.Sprintf("%.4f", data.ViewDirectionY[i]))

	    out = append(out, fmt.Sprintf("%d", data.AmmoLeft[i]))
	    out = append(out, fmt.Sprintf("%d", data.nSpotted[i]))
	    out = append(out, fmt.Sprintf("%d", data.Ping[i]))
	    out = append(out, fmt.Sprintf("%d", data.enemyPing[i]))
	    out = append(out, fmt.Sprintf("%.4f", data.flashleft[i]))
	    out = append(out, fmt.Sprintf("%d", data.weapon[i]))

        out = append(out, fmt.Sprintf("%.4f", data.attackerxv[i])) // v stands for velocity
        out = append(out, fmt.Sprintf("%.4f", data.attackeryv[i]))
        out = append(out, fmt.Sprintf("%.4f", data.attackerzv[i]))

        out = append(out, fmt.Sprintf("%.4f", data.victimxv[i]))
        out = append(out, fmt.Sprintf("%.4f", data.victimyv[i]))
        out = append(out, fmt.Sprintf("%.4f", data.victimzv[i]))

	    out = append(out, fmt.Sprintf("%.4f", data.victimDistance[i]))
        out = append(out, fmt.Sprintf("%d", int64(data.id[i])))
        out = append(out, fmt.Sprintf("%d", data.frame[i]))

		out = append(out, fmt.Sprintf("%.4f", data.attackerDeltaYaw[i]))
		out = append(out, fmt.Sprintf("%.4f", data.attackerDeltaPitch[i]))
		out = append(out, fmt.Sprintf("%.4f", data.crosshairToVictimYaw[i]))
		out = append(out, fmt.Sprintf("%.4f", data.crosshairToVictimPitch[i]))

        out = append(out, fmt.Sprintf("%.4f", data.victimDeltaYaw[i]))
		out = append(out, fmt.Sprintf("%.4f", data.victimDeltaPitch[i]))
		out = append(out, fmt.Sprintf("%.4f", data.crosshairToAttackerYaw[i]))
		out = append(out, fmt.Sprintf("%.4f", data.crosshairToAttackerPitch[i]))

        if data.IsScoped[i] {
                out = append(out,  fmt.Sprintf("%d", 1))
            } else {
                out = append(out, fmt.Sprintf("%d", 0))
            }

        if data.v_spotted_a[i] {
                out = append(out,  fmt.Sprintf("%d", 1))
            } else {
                out = append(out, fmt.Sprintf("%d", 0))
            }

        if data.a_spotted_v[i] {
                out = append(out,  fmt.Sprintf("%d", 1))
            } else {
                out = append(out, fmt.Sprintf("%d", 0))
            }

        if data.attackerFiring[i] {
                out = append(out,  fmt.Sprintf("%d", 1))
            } else {
                out = append(out, fmt.Sprintf("%d", 0))
            }
        if data.victimFiring[i] {
                out = append(out,  fmt.Sprintf("%d", 1))
            } else {
                out = append(out, fmt.Sprintf("%d", 0))
            }
        }

	return out
}

// Returns a mod b, keeping the sign of b
func divisorSignMod(a float64, b float64) float64 {
	return math.Mod(math.Mod(a, b)+b, b)
}

// Normalize an angle to be between -180 and 180
func normalizeAngle(a float32) float32 {
	return float32(-180 + divisorSignMod(float64(a)+180, 360))
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

```

`DLAC/parser.go`:

```go
package main

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"
	"sync"
	"C"

	strings "strings"

	"github.com/golang/geo/r3"
	dem "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs"
	common "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/common"
	events "github.com/markus-wa/demoinfocs-golang/v2/pkg/demoinfocs/events"
)

// MAJOIRTY OF CODE IS WRITTEN BY 87andrewh, found at: https://github.com/87andrewh/DeepAimDetector/blob/master/parser/to_csv.go
// MAJOIRTY OF CODE IS WRITTEN BY 87andrewh, found at: https://github.com/87andrewh/DeepAimDetector/blob/master/parser/to_csv.go


// File paths
//var dest = "data/data.csv"


// Defines amount of frames to collect around attacks
const samplesPerSecond = 32
const secondsBeforeAttack = 5
const secondsAfterAttack = 1
const secondsPerAttack = secondsBeforeAttack + secondsAfterAttack
const samplesPerAttack = int(samplesPerSecond * secondsPerAttack)

// PlayerData stores all data of a player in a single frame.
type PlayerData struct {
	flashleft float32
	id 		  uint64
	velo      r3.Vector
	name      string
	weapon    string
	position  r3.Vector
	yaw       float32
	pitch     float32
	crouching bool
	firing    bool
	health    int
}

// AttackTime marks when an attacker shot a victim
type AttackTime struct {
	attacker    int
	victim      int
	startFrame  int
	attackFrame int
	endFrame    int
}

// FireFrameKey is a key to a dictionary that marks
// if a shooter shoot at a given frame
type FireFrameKey struct {
	shooter int
	frame   int
}

// AttackData stores the features of a single sample fed into the model.
type AttackData struct {
	// Whether the attacker used an aimbot during the attack
	attackerAimbot bool

	// One-hot encoding of attacking gun
	weaponAK47 bool
	weaponM4A4 bool
	weaponAWP  bool

	// Viewangle deltas
	attackerDeltaYaw   [samplesPerAttack]float32
	attackerDeltaPitch [samplesPerAttack]float32

	// Angles between the attacker's crosshair and the victim
	crosshairToVictimYaw   [samplesPerAttack]float32
	crosshairToVictimPitch [samplesPerAttack]float32

	victimDistance    [samplesPerAttack]float32
	attackerCrouching [samplesPerAttack]bool
	victimCrouching   [samplesPerAttack]bool
	attackerFiring    [samplesPerAttack]bool

	attackerHealth [samplesPerAttack]int
	victimHealth   [samplesPerAttack]int

	attackerViewVector     [samplesPerAttack]r3.Vector
	attackerToVictimVector [samplesPerAttack]r3.Vector

	attackerX [samplesPerAttack]float32
	attackerY [samplesPerAttack]float32
	attackerZ [samplesPerAttack]float32

	victimX [samplesPerAttack]float32
	victimY [samplesPerAttack]float32
	victimZ [samplesPerAttack]float32

	flashleft [samplesPerAttack]float32
	id [samplesPerAttack]uint64
	velo      [samplesPerAttack]r3.Vector
	name      [samplesPerAttack]string
	visible   [samplesPerAttack]bool
	frame [samplesPerAttack]int
	filename string

}

// Marks guns that the model will be trained on
// TODO: Test model on different sets of guns.
var validGuns = map[string]bool{
	"AK-47":  true,
	"M4A4":   true,
	"AWP":    true,
	"M4A1":   true,
	"AUG":    true,
	"SG 553": true,
}

// Stores data to be fed into model
var modelData = []AttackData{}
var wg sync.WaitGroup


//export startparsing
func startparsing(directory *C.char, source *C.char){
    dest := C.GoString(directory)


    source_go := C.GoString(source)
    fmt.Println(source_go)
	files, err := ioutil.ReadDir(source_go)
	if err != nil {
		log.Fatal(err)
	}
	for _, f := range files {
		//fmt.Println(f.Name())
		wg.Add(1)
		go parseDemo(source_go, f.Name())
	}
	wg.Wait()
	csvExport(dest)
}

func main() {
}

func readCsvFile(filePath string) [][]string {
	f, err := os.Open(filePath)
	if err != nil {
		log.Fatal("Unable to read input file "+filePath, err)
	}
	defer f.Close()

	csvReader := csv.NewReader(f)
	records, err := csvReader.ReadAll()
	if err != nil {
		log.Fatal("Unable to parse file as CSV for "+filePath, err)
	}

	return records
}

func parseDemo(source string, name string) {
    defer wg.Done()
	// Times when a player is attacked by a valid gun
	var attackTimes = []AttackTime{}
	// Marks if a player is firing at a given frame.
	var fireFrames = map[FireFrameKey]bool{}
	// Marks frames surrounding attacks that should be gathered
	// for easier processing into model inputs
	var isMarked = map[int]bool{}
	// Stores the PlayerData for each player for each marked framed
	var markedFrameData = map[int]map[int]PlayerData{}
	// Marks if the demo was generated with an aimbot
	aimbot := strings.Contains(name, "_aimbot_")

	f, err := os.Open(source + name)
	defer f.Close()
	checkError(err)
	p := dem.NewParser(f)

	h, err := p.ParseHeader()
	FrameRate := h.FrameRate()

	// Calculate the demo framerate with some hacks
	tick := -1
	for !(2900 < tick && tick < 3000) {
		_, err = p.ParseNextFrame()
		tick = p.GameState().IngameTick()
	}
	checkError(err)
	iters := 10
	for i := 0; i < iters; i++ {
		_, err = p.ParseNextFrame()
		checkError(err)
	}
	nextTick := p.GameState().IngameTick()

	TicksPerFrame := float64(nextTick-tick) / float64(iters)
	FrameRate2 := p.TickRate() / TicksPerFrame

	if FrameRate == 0 {
		FrameRate = FrameRate2
	}

	var framesBeforeAttack int
	var framesAfterAttack int
	if (math.Abs(FrameRate-32.0) < 1) && (FrameRate2 == 32) {
		framesBeforeAttack = secondsBeforeAttack * 32
		framesAfterAttack = secondsAfterAttack * 32
	} else if (math.Abs(FrameRate-64.0) < 4) && (FrameRate2 == 64) {
		framesBeforeAttack = secondsBeforeAttack * 64
		framesAfterAttack = secondsAfterAttack * 64
	} else if (math.Abs(FrameRate-128) < 4) && (FrameRate2 == 128) {
		framesBeforeAttack = secondsBeforeAttack * 128
		framesAfterAttack = secondsAfterAttack * 128
	} else {
		println("Invalid frame rate: ", FrameRate, FrameRate2)
		return
	}

	framesPerAttack := framesBeforeAttack + framesAfterAttack
	framesPerSample := int(framesPerAttack / samplesPerAttack)
	//println("Frames per sample ", framesPerSample)

	// First pass.

	// Get frame times of attacks with valid guns,
	// and mark surrounding frames for retrieval.
	attackCount := 0


	p.RegisterEventHandler(func(e events.PlayerHurt) {
		if !validGuns[e.Weapon.String()] {
			return
		}

		attackCount++
		attackFrame := p.CurrentFrame()
		start := attackFrame - framesBeforeAttack
		end := attackFrame + framesAfterAttack
		for frame := start; frame < end; frame++ {
			isMarked[frame] = true
		}
		isMarked[start-framesPerSample] = true // For first sample delta angles
		new := AttackTime{
			e.Attacker.UserID, e.Player.UserID, start, attackFrame, end}
		attackTimes = append(attackTimes, new)
	})

	// Track frames where a player fires a weapon
	p.RegisterEventHandler(func(e events.WeaponFire) {
		frame := p.CurrentFrame()
		// Include previous frames so that shot is not lost after sampling
		for i := 0; i < framesPerSample; i++ {
			fireFrames[FireFrameKey{e.Shooter.UserID, frame - i}] = true
		}
	})
	err = p.ParseToEnd()
	fmt.Printf("Valid attacks: %d\n", attackCount)

	// Second pass.

	// Extract player data from marked frames
	f, err = os.Open(source + name)
	p = dem.NewParser(f)

	for ok := true; ok; ok, err = p.ParseNextFrame() {
		checkError(err)
		frame := p.CurrentFrame()

		if !isMarked[frame] {
			continue
		}

		var players = map[int]PlayerData{}
		gs := p.GameState()
		for _, player := range gs.Participants().Playing() {
			players[player.UserID] = extractPlayerData(frame, player, fireFrames)
		}
		markedFrameData[frame] = players
	}

	// Extract each attack's AttackData, and add it to modelData
	for _, attack := range attackTimes {
		weapon := markedFrameData[attack.attackFrame][attack.attacker].weapon
		attackData := AttackData{
			attackerAimbot: aimbot,
			weaponAK47:     weapon == "AK-47",
			weaponM4A4:     weapon == "M4A4",
			weaponAWP:      weapon == "AWP",
		}

		prevFrame := attack.startFrame - framesPerSample
		prevAttackerYaw := markedFrameData[prevFrame][attack.attacker].yaw
		prevAttackerPitch := markedFrameData[prevFrame][attack.attacker].pitch
        attackData.filename = name


		for sample := 0; sample < samplesPerAttack; sample++ {
			frame := framesPerSample*sample + attack.startFrame
			attacker := markedFrameData[frame][attack.attacker]
			victim := markedFrameData[frame][attack.victim]

			attackerYaw := attacker.yaw
			attackerPitch := attacker.pitch
			attackData.attackerDeltaYaw[sample] = normalizeAngle(
				attackerYaw - prevAttackerYaw)
			attackData.attackerDeltaPitch[sample] = attackerPitch - prevAttackerPitch
			prevAttackerYaw = attackerYaw
			prevAttackerPitch = attackerPitch

			attackerToVictim := victim.position.Sub(attacker.position)
			attackData.attackerToVictimVector[sample] = attackerToVictim.Normalize()

			dX := attackerToVictim.X
			dY := attackerToVictim.Y
			dZ := attackerToVictim.Z
			attackerToVictimYaw := 180 / math.Pi * float32(math.Atan2(dY, dX))
			attackerToVictimPitch := 180 / math.Pi * float32(math.Atan2(
				math.Sqrt(dX*dX+dY*dY),
				dZ))

			// Smallest angle between attackerToVictimYaw and attackerYaw
			attackData.crosshairToVictimYaw[sample] =
				normalizeAngle(attackerToVictimYaw - attackerYaw)
			attackData.crosshairToVictimPitch[sample] =
				attackerToVictimPitch - attackerPitch

			attackData.victimDistance[sample] = float32(attackerToVictim.Norm())

			attackData.attackerCrouching[sample] = attacker.crouching
			attackData.victimCrouching[sample] = victim.crouching
			attackData.attackerFiring[sample] = attacker.firing

			attackData.attackerHealth[sample] = attacker.health
			attackData.victimHealth[sample] = victim.health

			attackerYaw64 := float64(math.Pi / 180 * attackerYaw)
			attackerPitch64 := float64(math.Pi / 180 * attackerPitch)
			attackData.attackerViewVector[sample] = r3.Vector{
				math.Cos(attackerYaw64) * math.Sin(attackerPitch64),
				math.Sin(attackerYaw64) * math.Sin(attackerPitch64),
				math.Cos(attackerPitch64)}

			attackData.attackerX[sample] = float32(attacker.position.X)
			attackData.attackerY[sample] = float32(attacker.position.Y)
			attackData.attackerZ[sample] = float32(attacker.position.Z)

			attackData.victimX[sample] = float32(victim.position.X)
			attackData.victimY[sample] = float32(victim.position.Y)
			attackData.victimZ[sample] = float32(victim.position.Z)

			attackData.velo[sample] = attacker.velo
			attackData.name[sample]  = attacker.name
			attackData.id[sample] = attacker.id
			//attackData.tick[sample] = attacker.tick
			attackData.frame[sample] = frame
			//attackData.visible[sample] = attacker.player.HasSpotted(victim)
			//attackData.visible[sample] = attacker.player.HasSpotted(victim)


		}
		// A player teleported. Throw away the data.
		modelData = append(modelData, attackData)
	}
	f.Close()
}

func extractPlayerData(
	frame int,
	player *common.Player,
	fireFrames map[FireFrameKey]bool) PlayerData {

	fixedPitch := float32(math.Mod(
		float64(player.ViewDirectionY())+90,
		180))

	weapon := ""
	if player.ActiveWeapon() != nil {
		weapon = player.ActiveWeapon().String()
	}

	return PlayerData{
		player.FlashDuration,
		player.SteamID64,
		player.Velocity(),
		player.Name,
		weapon,
		player.LastAlivePosition,
		player.ViewDirectionX(),
		fixedPitch,
		player.IsDucking(),
		fireFrames[FireFrameKey{player.UserID, frame}],
		player.Health()}
}

func csvExport(dest string) error {
    dataDest := dest+"/data/data.csv"
	file, err := os.OpenFile(dataDest, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}

	writer := csv.NewWriter(file)

	for _, attackData := range modelData {
		err := writer.Write(attackToString(attackData))
		if err != nil {
			return err
		}
	}

	writer.Flush()
	file.Close()
	return nil
}

func attackToString(data AttackData) []string {
	var out []string

	for i := 0; i < samplesPerAttack; i++ {
	    //out = append(out, attackData.name[i])
	    out = append(out, data.filename)
        out = append(out, data.name[i])
        out = append(out, fmt.Sprintf("%d", data.id[i]))
        out = append(out, fmt.Sprintf("%d", data.frame[i]))
		out = append(out, fmt.Sprintf("%.3f", data.attackerDeltaYaw[i]))
		out = append(out, fmt.Sprintf("%.3f", data.attackerDeltaPitch[i]))
		out = append(out, fmt.Sprintf("%.3f", data.crosshairToVictimYaw[i]))
		out = append(out, fmt.Sprintf("%.3f", data.crosshairToVictimPitch[i]))
	if data.attackerFiring[i] {
			out = append(out, fmt.Sprintf("%d", 1))
		} else {
			out = append(out, fmt.Sprintf("%d", 0))
		}

	}

	return out
}

// Returns a mod b, keeping the sign of b
func divisorSignMod(a float64, b float64) float64 {
	return math.Mod(math.Mod(a, b)+b, b)
}

// Normalize an angle to be between -180 and 180
func normalizeAngle(a float32) float32 {
	return float32(-180 + divisorSignMod(float64(a)+180, 360))
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

```

`DLAC/utils/filter.pyx`:

```pyx
import pickle
import numpy as np


def speed(a):
    cdef int i
    cdef double player
    cdef int totalrange
    with open('xd.pickle', 'rb') as handle:
        d = pickle.load(handle)

    print(len(d))
    cdef ashape = a.shape[0]-1
    total = {}
    l = []

    for i in range(ashape):
        player = int(a[i][0][0])
        if player != 0:
            if player not in total:
                total[player] = 1
                l.append(i)
            else:
                if total[player] <= 1000:
                    total[player] += 1
                    l.append(i)
    with open('xd.pickle', 'wb') as handle:
        pickle.dump(d, handle)
    return a[l]

```

`DLAC/utils/filter_players.py`:

```py
import filter
import os
from multiprocessing import Process, Value, Array, Lock,Process, Manager, Queue
import time
import numpy as np
import pickle

# Filters wanted amount of players and ignores cheaters

def f(lock, inx, d,q):
    folder = 'F:/csgo/npz_clean1/'
    files = os.listdir(folder)
    while True:
        inx = q.get()
        sub_files = files[inx * 250:inx * 250 + 250]
        a = np.concatenate([np.load(f"{folder}{file}")['arr_0'] for file in sub_files])
        with lock:
            a = filter.speed(a)
        a = np.float32(a[:, :, 1:])
        np.save(f'D:/happy/{inx}', a)


if __name__ == '__main__':
    d = {}
    q = Queue()
    a = np.load("cheatersids.npy")
    for i in a:
        d[i] = 5000

    for i in range(5000):
        q.put(i)
    with open('xd.pickle', 'wb') as handle:
        pickle.dump(d, handle)
    with Manager() as manager:
        d = manager.dict()
        lock = Lock()
        ps = []
        for i in range(22):
            p = Process(target=f, args=(lock,i,d,q))
            ps.append(p)
        for p in ps:
            p.start()
```

`DLAC/utils/webdatasetmaker.py`:

```py
import webdataset as wds
import time
from hashlib import sha1
import numpy as np
import multiprocessing
import multiprocessing as mp
import shutil
import os

# Creates a webdataset from numpy arrays


def wdswriter(clean, dirty,x,counter):
    os.mkdir(f"shards/{x}")
    # writes clean and dirty
    with wds.ShardWriter(f'shards/{x}/shard-%07d.tar', maxcount=100000) as sink:
        while True:
            if clean.qsize() > 1000 and dirty.qsize() > 1000:
                clean_data = clean.get()
                with counter.get_lock():
                    inx = counter.value
                    counter.value += 1
                sink.write({
                    "__key__": "samplex%07d" % inx,
                    "y.pyd": 0,
                    "X.pyd": clean_data,
                })
                dirty_data = dirty.get()
                with counter.get_lock():
                    inx = counter.value
                    counter.value += 1
                sink.write({
                    "__key__": "samplex%07d" % inx,
                    "y.pyd": 1,
                    "X.pyd": dirty_data,
                })


def clean_putter(dirtyq,cleanq,clean, dirty, x, counter):
    # Reads "clean" numpy arrays and puts into queue
    while not cleanq.empty():
        print("CleanQ Size:",cleanq.qsize())
        while clean.qsize() > 300000:
            time.sleep(0.1)
        file = cleanq.get()
        a = np.load(file)
        a = np.float32(a)
        for i in range(a.shape[0]):
            clean.put(a[i])


def dirty_putter(dirtyq,cleanq,clean, dirty, x, counter):
    # Reads "dirty" numpy arrays and puts into queue
    while not dirtyq.empty():
        while dirty.qsize() > 1000000:
            time.sleep(0.01)
        print("DirtyQ Size:",dirtyq.qsize())
        file = dirtyq.get()
        a = np.load(file)["arr_0"]
        a = a[:, :, 1:]
        a = np.float32(a)
        for i in range(a.shape[0]):
            dirty.put(a[i])


if __name__ == '__main__':
    counter = multiprocessing.Value("l", 0)
    filenames = []
    clean = mp.Queue()
    dirty = mp.Queue()
    cleanq = mp.Queue()
    dirtyq = mp.Queue()
    for i in range(104):
        dirty_folder = "F:/hd5f/dirty_train/"
        files = os.listdir(dirty_folder)
        for i in files:
            dirtyq.put(f"{dirty_folder}{i}")

    clean_folder = "D:/happy/"
    files = os.listdir(clean_folder)
    for i in files:
        cleanq.put(f"{clean_folder}{i}")
    # Puts clean samples in cleanQ
    processes = [mp.Process(target=clean_putter, args=(dirtyq,cleanq,clean,dirty,x, counter)) for x in range(2)]
    for p in processes:
        p.start()
    # Puts dirty samples in dirtyQ
    processes = [mp.Process(target=dirty_putter, args=(dirtyq,cleanq,clean, dirty, x, counter)) for x in range(2)]
    for p in processes:
        p.start()

    time.sleep(3)
    processes = [mp.Process(target=wdswriter, args=(clean, dirty, x, counter)) for x in range(1,20)]
    for p in processes:
        p.start()
    for p in processes:
        print(p, "joined")
        p.join()
        p.terminate()


    # Joins shards together
    for i in range(1, 48):
        files = os.listdir(f"F:/bigdata/shards/{i}")
        for f in files:
            my_file_name = f"F:/bigdata/shards/{i}/{f}".encode()
            hash_filename = sha1(my_file_name).hexdigest()
            os.rename(f"F:/bigdata/shards/{i}/{f}", f"F:/bigdata/shards/{i}/{hash_filename}.tar")
            shutil.move(f"F:/bigdata/shards/{i}/{hash_filename}.tar", f"F:/bigdata/shards/a/{hash_filename}.tar")
    folder = "F:/bigdata/shards/a/"
    files = os.listdir(folder)
    for cnt, i in enumerate(files):
        cnt = format(cnt, "07")
        os.rename(f"{folder}{i}", f"{folder}shard{cnt}.tar")
```

`README.md`:

```md
# Deep Learning Anti-Cheat For CSGO



Input the directory with your .dem files and the model outputs predictions for every shot during the game.

```python
from DLAC import Model

model = Model("./path_to_demos/")
model.predict_to_terminal(threshold=0.95)   # You can manually specify threshold, 0.95 by default
```
## Installation
Windows should be as easy as:
```python
pip install DLAC
```
Linux users will need to build the .so file. This requres GO.
```
git clone https://github.com/LaihoE/DLAC  
cd DLAC
python3 setup.py install
cd DLAC
go build -o parser.so -buildmode=c-shared
```

## You can choose between a bigger and a smaller model
```python
from DLAC import Model

model = Model("./path_to_demos/", model_type='big')
model.predict_to_terminal(threshold=0.99)   # 0.99 is recommended with the bigger model
```
The bigger model is slower with slightly better accuracy  


Other ways to output predictions  
model.predict_to_csv()  
model.predict_to_list()

## Example output from one shot  
```CSV
Name, Confidence of cheating, SteamId, File
PeskyCheater22, 0.9601634, 123456789, exampledemo.dem
```


## Special thank you to
Demoinfocs-golang is the underlying parser used for parsing the demos, found at:  
https://github.com/markus-wa/demoinfocs-golang.  

87andrewh has written the majority of the specific parser used, found at: https://github.com/87andrewh/DeepAimDetector/blob/master/parser/to_csv.go

```

`setup.py`:

```py
from setuptools import setup, find_packages

setup(name='DLAC',
    version='1.0',
    description='Deep learning anti-cheat for CSGO',
    author='LaihoE',
    packages=find_packages(),

    install_requires=[
    "numpy==1.21.5",
    "onnxruntime==1.10.0",
    "pandas==1.3.5",
    "scikit-learn==1.0.1"
    ],
     )
```

`test.py`:

```py
from DLAC import Model

model = Model("./path_to_demos/")
model.predict_to_terminal()     # Prints outputs
```

`training/Multi-kill-gru.py`:

```py
import joblib
from torch.utils.data import Dataset, DataLoader
import numpy as np
import torch
import torch.nn as nn
from einops import rearrange, repeat
from sklearn.metrics import f1_score,precision_score,recall_score
import webdataset as wds


class TestDataset(Dataset):
    def __init__(self):
        scaler = joblib.load('scaler.gz')
        print(f"Scaler fitted on {scaler.n_samples_seen_} samples",)
        self.x = np.float32(np.load("F:/csgo/transformer_data/test/X.npy"))
        self.x = self.x.reshape(-1, 5)
        self.x = scaler.transform(self.x)
        self.x = self.x.reshape(-1, 128, 5)

        self.y = np.load("F:/csgo/transformer_data/test/y.npy")
        self.y = np.int64(self.y)
        self.n_samples = len(self.y)
        print(np.where(self.y == 0))
        print(np.where(self.y == 1))

    def __getitem__(self, index):
        return self.x[index], self.y[index]

    def __len__(self):
        return self.n_samples


def check_accuracy(loader, model):
    num_correct, num_samples = 0, 0
    model.eval()
    with torch.no_grad():
        for x, y in loader:
            x = x.to(device=device)
            y = y.to(device=device)
            x = x.float()
            y = y.long()
            scores = model(x)
            _, predictions = scores.max(1)
            num_correct += (predictions == y).sum()
            num_samples += predictions.size(0)
    model.train()
    return float(num_correct) / float(num_samples) * 100


def check_other_metrics(loader, model, threshold):
    model.eval()
    F1 = []
    pres = []
    recall = []
    with torch.no_grad():
        for x, y in loader:
            x = x.to(device=device)
            y = y.to(device=device)
            x = x.float()
            y = y.long()
            scores = model(x)
            _, predictions = scores.max(1)
            probs = torch.softmax(scores, 1)
            y = y.cpu()
            probs = probs.detach().cpu()
            probs = probs[:,1] > threshold
            F1.append(f1_score(y,probs))
            pres.append(precision_score(y,probs))
            recall.append(recall_score(y,probs))
    model.train()
    return sum(F1) / len(F1), sum(pres) / len(pres), sum(recall) / len(recall)


class GruCeption(nn.Module):
    def __init__(self, input_dim, first_hidden_dim, second_hidden_dim, layer_dim, output_dim, dropout_prob, number_of_kills):
        super(GruCeption, self).__init__()
        self.number_of_kills = number_of_kills
        self.layer_dim = layer_dim
        self.hidden_dim = first_hidden_dim
        self.gru = nn.GRU(input_dim, first_hidden_dim, layer_dim, batch_first=True, dropout=dropout_prob)
        self.fc = nn.Linear(second_hidden_dim, output_dim)
        self.gru2 = nn.GRU(number_of_kills, second_hidden_dim, layer_dim, batch_first=True, dropout=dropout_prob)

    def forward(self, X):
        print(X.shape)
        # first kill like this for easy torch.cat
        x = X[:,0,:,:]
        h0 = torch.zeros(self.layer_dim, x.size(0), self.hidden_dim).requires_grad_().to(device)
        out, _ = self.gru(x, h0.detach())
        out1 = out[:, -1, :]
        o = out1.reshape((-1, 1, self.hidden_dim))
        # Loop over kills 1->n kills
        for i in range(1, self.number_of_kills):
            x = X[:, i, :, :]
            h0 = torch.zeros(self.layer_dim, x.size(0), self.hidden_dim).requires_grad_().to(device)
            out, _ = self.gru(x, h0.detach())
            out2 = out[:, -1, :]
            out2 = out2.reshape((-1, 1, self.hidden_dim))
            o = torch.cat((o, out2), dim=1)

        # Batch nkills hsize -> Batch hsize nkills
        o = rearrange(o,'b n h -> b h n')
        h0 = torch.zeros(self.layer_dim, x.size(0), self.hidden_dim).requires_grad_().to(device)
        out, _ = self.gru2(o, h0.detach())
        out = out[:, -1, :]
        return self.fc(out)


if __name__ == "__main__":
    is_cuda = torch.cuda.is_available()
    if is_cuda:
        device = torch.device("cuda")
    else:
        device = torch.device("cpu")
    print(device)

    learning_rate = 0.002
    input_size = 5
    embedding_dim = 5
    first_hidden_size = 256
    second_hidden_size = 256
    num_layers = 1
    num_classes = 2
    dropout = 0.1
    batch_size = 256

    model = GruCeption(input_size, first_hidden_size, second_hidden_size, num_layers, num_classes, 0.2, number_of_kills=25).to(device)
    #model = GruCeption(input_size, first_hidden_size, second_hidden_size, num_layers, num_classes, 0.2, number_of_kills=25).to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)


    # Finally found the only good OOM-dataset
    dataset_train = (
        wds.WebDataset("shards/a/shard{0000000..000227}.tar")
        .shuffle(1000)
        .decode()
        .to_tuple("x.pyd", "y.cls")
    )
    dataset_testing = TestDataset()

    train_loader = torch.utils.data.DataLoader(dataset_train, num_workers=12, batch_size=batch_size)
    test_loader = torch.utils.data.DataLoader(dataset=dataset_testing,
                                              batch_size=batch_size,
                                              shuffle=True)
    scaler = torch.cuda.amp.GradScaler()
    for epoch in range(100):
        losses = []
        for i, (data, labels) in enumerate(train_loader):
            data = data.to(device)
            labels = labels.to(device)
            with torch.cuda.amp.autocast():
                outputs = model(data)
                loss = criterion(outputs, labels)

            losses.append(loss.item())
            scaler.scale(loss).backward()
            scaler.step(optimizer)
            scaler.update()

            # mid epoch check
            if i % 1000 == 0:
                acc = check_accuracy(test_loader, model)
                f1, pres, recall = check_other_metrics(test_loader, model, threshold=0.9)
                print(f"Cost at epoch {i*batch_size} is {sum(losses) / len(losses)},Train acc:, Validation acc:{acc}, pres:{pres}, recall:{recall}, F1: {f1}")
                torch.save(model, f'models/model{i*batch_size}.pt')
        # Normal check
        acc = check_accuracy(test_loader, model)
        f1,pres,recall = check_other_metrics(test_loader, model, threshold=0.9)
        print(f"Cost at epoch {epoch} is {sum(losses) / len(losses)},Train acc:, Validation acc:{acc}, pres:{pres}, recall:{recall}, F1: {f1}")
        torch.save(model, f'models/model{epoch}.pt')

```

`training/Simple-gru.py`:

```py
import joblib
from torch.utils.data import Dataset, DataLoader
import numpy as np
import torch
import torch.nn as nn
from einops import rearrange, repeat
from sklearn.metrics import f1_score,precision_score,recall_score
import webdataset as wds

class TestDataset(Dataset):
    def __init__(self):
        scaler = joblib.load('scaler.gz')
        print(f"Scaler fitted on {scaler.n_samples_seen_} samples",)
        self.x = np.float32(np.load("F:/csgo/transformer_data/test/X.npy"))
        self.x = self.x.reshape(-1, 5)
        self.x = scaler.transform(self.x)
        self.x = self.x.reshape(-1, 128, 5)

        self.y = np.load("F:/csgo/transformer_data/test/y.npy")
        self.y = np.int64(self.y)
        self.n_samples = len(self.y)
        print(np.where(self.y == 0))
        print(np.where(self.y == 1))

    def __getitem__(self, index):
        return self.x[index], self.y[index]

    def __len__(self):
        return self.n_samples


def check_accuracy(loader, model):
    num_correct, num_samples = 0, 0
    model.eval()
    with torch.no_grad():
        for x, y in loader:
            x = x.to(device=device)
            y = y.to(device=device)
            x = x.float()
            y = y.long()
            scores = model(x)
            _, predictions = scores.max(1)
            num_correct += (predictions == y).sum()
            num_samples += predictions.size(0)
    model.train()
    return float(num_correct) / float(num_samples) * 100


def check_other_metrics(loader, model, threshold):
    model.eval()
    F1 = []
    pres = []
    recall = []
    with torch.no_grad():
        for x, y in loader:
            x = x.to(device=device)
            y = y.to(device=device)
            x = x.float()
            y = y.long()
            scores = model(x)
            _, predictions = scores.max(1)
            probs = torch.softmax(scores, 1)
            y = y.cpu()
            probs = probs.detach().cpu()
            probs = probs[:,1] > threshold
            F1.append(f1_score(y,probs))
            pres.append(precision_score(y,probs))
            recall.append(recall_score(y,probs))
    model.train()
    return sum(F1) / len(F1), sum(pres) / len(pres), sum(recall) / len(recall)


class GRUModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, layer_dim, output_dim, dropout_prob):
        super(GRUModel, self).__init__()
        self.layer_dim = layer_dim
        self.hidden_dim = hidden_dim
        self.gru = nn.GRU(input_dim, hidden_dim, layer_dim, batch_first=True, dropout=dropout_prob)
        self.fc = nn.Linear(hidden_dim, output_dim)

    def forward(self, x):
        h0 = torch.zeros(self.layer_dim, x.size(0), self.hidden_dim).requires_grad_().to(device)
        out, _ = self.gru(x, h0.detach())
        out = out[:, -1, :]
        out = self.fc(out)
        return out


if __name__ == "__main__":
    is_cuda = torch.cuda.is_available()
    if is_cuda:
        device = torch.device("cuda")
    else:
        device = torch.device("cpu")
    print(device)

    learning_rate = 0.002
    input_size = 5
    embedding_dim = 5
    hidden_size = 256
    num_layers = 2
    num_classes = 2
    dropout = 0.1
    batch_size = 512

    model = GRUModel(input_size, hidden_size, num_layers, num_classes, 0.2).to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)

    # Finally found the only good OOM-dataset
    dataset_train = (
        wds.WebDataset("shards/a/shard{0000000..000226}.tar")
        .shuffle(1000)
        .decode()
        .to_tuple("x.pyd", "y.cls")
    )
    dataset_testing = TestDataset()

    train_loader = torch.utils.data.DataLoader(dataset_train, num_workers=12, batch_size=batch_size)
    test_loader = torch.utils.data.DataLoader(dataset=dataset_testing,
                                              batch_size=batch_size,
                                              shuffle=True)

    scaler = torch.cuda.amp.GradScaler()
    for epoch in range(100):
        losses = []
        for i, (data, labels) in enumerate(train_loader):
            data = data.to(device)
            labels = labels.to(device)
            with torch.cuda.amp.autocast():
                outputs = model(data)
                loss = criterion(outputs, labels)

            losses.append(loss.item())
            scaler.scale(loss).backward()
            scaler.step(optimizer)
            scaler.update()
            # mid epoch check
            if i % 1000 == 0:
                acc = check_accuracy(test_loader, model)
                f1, pres, recall = check_other_metrics(test_loader, model, threshold=0.9)
                print(f"Cost at epoch {i*batch_size} is {sum(losses) / len(losses)},Train acc:, Validation acc:{acc}, pres:{pres}, recall:{recall}, F1: {f1}")
                torch.save(model, f'models/model{i*batch_size}.pt')
        # Normal check
        acc = check_accuracy(test_loader, model)
        f1, pres, recall = check_other_metrics(test_loader, model, threshold=0.9)
        print(f"Cost at epoch {epoch} is {sum(losses) / len(losses)},Train acc:, Validation acc:{acc}, pres:{pres}, recall:{recall}, F1: {f1}")
        torch.save(model, f'models/model{epoch}.pt')

```