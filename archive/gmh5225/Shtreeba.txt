Project Path: arc_gmh5225_Shtreeba_t9aht_wt

Source Tree:

```txt
arc_gmh5225_Shtreeba_t9aht_wt
├── COPYING.LESSER
├── Library
│   ├── File.cpp
│   ├── File.h
│   ├── Library.def
│   ├── Library.rc
│   ├── Library.vcxproj
│   ├── Library.vcxproj.filters
│   ├── MMap.cpp
│   ├── MMap.h
│   ├── ProcessInfo.h
│   ├── Shtreeba.h
│   ├── Start.cpp
│   └── resource.h
├── README.md
├── Shtreeba.sln
└── UI
    ├── FindProcessId.cpp
    ├── FindProcessId.h
    ├── Shtreeba.ini
    ├── UI.cpp
    ├── UI.rc
    ├── UI.vcxproj
    ├── UI.vcxproj.filters
    └── resource.h

```

`COPYING.LESSER`:

```LESSER
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`Library/File.cpp`:

```cpp
#include "File.h"
#include <fstream>
#include <vector>
#include <stdexcept>
#include <sstream>
#include <Windows.h>

static std::string errMsg() {
    char* e = strerror(errno);
    return e ? e : "";
}

File::File(const std::filesystem::path& filepath) {
    if (!std::filesystem::exists(filepath))
    {
        auto ex{ (std::ostringstream{} << "I/O error: File doesn't exist (" << filepath.string() << ")").str() };
        std::throw_with_nested(std::runtime_error(ex));
    }

    std::basic_ifstream<std::byte> file(filepath, std::ios::binary);
    if (!file)
        std::throw_with_nested(std::runtime_error("I/O error: " + errMsg()));

    file.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    if (std::filesystem::file_size(filepath) < 0x1000)
    {
        auto ex{ (std::ostringstream{} << "I/O error: Invalid filesize (" << filepath.string() << ")").str() };
        std::throw_with_nested(std::runtime_error(ex));
    }

    binaryData = { std::istreambuf_iterator<std::byte>(file), std::istreambuf_iterator<std::byte>() };
    file.close();

    if (reinterpret_cast<IMAGE_DOS_HEADER*>(binaryData.data())->e_magic != 0x5A4D) //"MZ"
    {
        auto ex{ (std::ostringstream{} << "I/O error: Invalid binary file (" << filepath.string() << ")").str() };
        std::throw_with_nested(std::runtime_error(ex));
    }
};
```

`Library/File.h`:

```h
#pragma once

#include <vector>
#include <filesystem>

class File
{
    std::vector<std::byte> binaryData;

public:
    explicit File(const std::filesystem::path& filepath);

    constexpr auto& read()
    {
        return binaryData;
    };
};


```

`Library/Library.def`:

```def
EXPORTS
	Start=?Start@@YA_NUProcessInfo@@ABVpath@filesystem@std@@@Z
```

`Library/Library.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
FILEVERSION 2, 0, 0, 1
PRODUCTVERSION 2, 0, 0, 1
FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
FILEFLAGS 0x1L
#else
FILEFLAGS 0x0L
#endif
FILEOS 0x40004L
FILETYPE 0x2L
FILESUBTYPE 0x0L
BEGIN
BLOCK "StringFileInfo"
BEGIN
BLOCK "040004b0"
BEGIN
VALUE "CompanyName", "Jweega Capital Limited Incorporated"
VALUE "FileDescription", "SHTREEBA library"
VALUE "FileVersion", "2.0.0.1"
VALUE "InternalName", "Shtreeba.dll"
VALUE "LegalCopyright", "Copyright (C) 2019"
VALUE "OriginalFilename", "Shtreeba.dll"
VALUE "ProductName", "SHTREEBA: Dynamic library assistant"
VALUE "ProductVersion", "2.0.0.1"
END
END
BLOCK "VarFileInfo"
BEGIN
VALUE "Translation", 0x400, 1200
END
END

#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Ukrainian (Ukraine) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_UKR)
LANGUAGE LANG_UKRAINIAN, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
"resource.h\0"
END

2 TEXTINCLUDE
BEGIN
"#include ""winres.h""\r\n"
"\0"
END

3 TEXTINCLUDE
BEGIN
"\r\n"
"\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Ukrainian (Ukraine) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Library/Library.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Library</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;WINVER=0x0601;_WIN32_WINNT=0x0601;WIN32;_DEBUG;LIBRARY_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>Library.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;LIBRARY_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;WINVER=0x0601;_WIN32_WINNT=0x0601;WIN32;NDEBUG;LIBRARY_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <StringPooling>true</StringPooling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <EnforceTypeConversionRules>true</EnforceTypeConversionRules>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <AdditionalOptions>/Ob3 /Gw %(AdditionalOptions)</AdditionalOptions>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ImageHasSafeExceptionHandlers>
      </ImageHasSafeExceptionHandlers>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies />
      <ModuleDefinitionFile>Library.def</ModuleDefinitionFile>
      <MapExports>false</MapExports>
      <GenerateMapFile>false</GenerateMapFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;LIBRARY_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="File.h" />
    <ClInclude Include="MMap.h" />
    <ClInclude Include="ProcessInfo.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Shtreeba.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="File.cpp" />
    <ClCompile Include="Start.cpp" />
    <ClCompile Include="MMap.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Library.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Library.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Library/Library.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="File.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MMap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Shtreeba.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="File.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MMap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Start.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Library.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Library.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Library/MMap.cpp`:

```cpp
#include "MMap.h"
#include <array>
#include <Windows.h>

static const inline bool isCorrectTargetArchitecture(HANDLE process)
{
    BOOL target = FALSE;
    if (!IsWow64Process(process, &target))
    {
        std::throw_with_nested(std::runtime_error("Error: Wrong platform: " + GetLastError()));
    }

    BOOL host = FALSE;
    IsWow64Process(GetCurrentProcess(), &host);
    return (target == host);
}

MMap::MMap(ProcessInfo processInfo, std::vector<std::byte> _file) :
    process{ OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, processInfo.pid) },
    thread{ OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, FALSE, processInfo.tid) },
    file{ _file }, srcData{ file.data() }
{
    if (!process)
    {
        std::throw_with_nested(std::runtime_error("Error: Failed to open process: " + GetLastError()));
    }

    if (!thread)
    {
        std::throw_with_nested(std::runtime_error("Error: Failed to open thread: " + GetLastError()));
    }

    if (!isCorrectTargetArchitecture(process))
    {
        std::throw_with_nested(std::runtime_error("Error: Target process architecture doesn't match!"));
    }

    const auto oldNtHeader{ reinterpret_cast<IMAGE_NT_HEADERS*>(srcData + reinterpret_cast<IMAGE_DOS_HEADER*>(srcData)->e_lfanew) };
    const auto oldOptHeader{ &oldNtHeader->OptionalHeader };
    const auto oldFileHeader{ &oldNtHeader->FileHeader };

    if (oldFileHeader->Machine != IMAGE_FILE_MACHINE_I386)
    {
        std::throw_with_nested(std::runtime_error("Invalid architecture: Not a 32bit DLL!"));
    }

    targetBase = reinterpret_cast<std::byte*>(VirtualAllocEx(process, reinterpret_cast<void*>(oldOptHeader->ImageBase), oldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
    if (!targetBase)
    {
        targetBase = reinterpret_cast<std::byte*>(VirtualAllocEx(process, nullptr, oldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
        if (!targetBase)
        {
            std::throw_with_nested(std::runtime_error("Error: Failed to allocate memory for DLL: " + GetLastError()));
        }
    }

    loader = VirtualAllocEx(process, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!loader)
    {
        VirtualFreeEx(process, targetBase, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: Failed to allocate memory for Loader: " + GetLastError()));
    }

    codeCave = VirtualAllocEx(process, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!codeCave)
    {
        VirtualFreeEx(process, loader, 0, MEM_RELEASE);
        VirtualFreeEx(process, targetBase, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: Failed to allocate memory for CodeCave: " + GetLastError()));
    }
};

template<typename... Ts>
constexpr std::array<std::byte, sizeof...(Ts)> make_bytes(Ts&&... args) {
    return{ std::byte(std::forward<Ts>(args))... };
}

static auto shellcode = make_bytes
(
    0x00, 0x00, 0x00, 0x00,						// - 0x04 (pCodecave)	-> returned value							;buffer to store returned value (eax)

    0x83, 0xEC, 0x04,							// + 0x00				-> sub esp, 0x04							;prepare stack for ret
    0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00,	// + 0x03 (+ 0x06)		-> mov [esp], OldEip						;store old eip as return address

    0x50, 0x51, 0x52,							// + 0x0A				-> psuh e(a/c/d)							;save e(a/c/d)x
    0x9C,										// + 0x0D				-> pushfd									;save flags register

    0xB9, 0x00, 0x00, 0x00, 0x00,				// + 0x0E (+ 0x0F)		-> mov ecx, pArg							;load pArg into ecx
    0xB8, 0x00, 0x00, 0x00, 0x00,				// + 0x13 (+ 0x14)		-> mov eax, pRoutine

    0x51,										// + 0x18				-> push ecx									;push pArg
    0xFF, 0xD0,									// + 0x19				-> call eax									;call target function

    0xA3, 0x00, 0x00, 0x00, 0x00,				// + 0x1B (+ 0x1C)		-> mov unsigned long file[pCodecave], eax			;store returned value

    0x9D,										// + 0x20				-> popfd									;restore flags register
    0x5A, 0x59, 0x58,							// + 0x21				-> pop e(d/c/a)								;restore e(d/c/a)x

    0xC6, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,	// + 0x24 (+ 0x26)		-> mov byte file[pCodecave + 0x06], 0x00		;set checkbyte to 0

    0xC3										// + 0x2B				-> ret										;return to OldEip
); // SIZE = 0x2C (+ 0x04)

template<typename T>
constexpr auto RELOC_FLAG(T RelInfo) { return ((RelInfo >> 0x0C) == IMAGE_REL_BASED_HIGHLOW); }

static constexpr void __stdcall mapper(MANUAL_MAPPING_DATA* data)
{
    if (!data)
        return;

    const auto base{ reinterpret_cast<std::byte*>(data) };
    const auto opt{ &reinterpret_cast<IMAGE_NT_HEADERS*>(base + reinterpret_cast<IMAGE_DOS_HEADER*>(data)->e_lfanew)->OptionalHeader };

    const auto _LoadLibraryA{ data->LoadLibraryA };
    if (!_LoadLibraryA) {
        return;
    }

    const auto _GetProcAddress{ data->GetProcAddress };
    if (!_GetProcAddress) {
        return;
    }

    const auto _dllMain{ reinterpret_cast<_DLL_ENTRY_POINT>(base + opt->AddressOfEntryPoint) };

    const auto locationDelta{ base - opt->ImageBase };
    if (locationDelta)
    {
        if (!opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
            return;

        auto relocData{ reinterpret_cast<IMAGE_BASE_RELOCATION*>(base + opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) };

        while (relocData->VirtualAddress)
        {
            auto amountOfEntries{ (relocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(unsigned short) };
            auto relativeInfo{ reinterpret_cast<unsigned short*>(relocData + 1) };

            for (unsigned int i = 0; i != amountOfEntries; ++i, ++relativeInfo)
            {
                if (RELOC_FLAG(*relativeInfo))
                {
                    auto patch{ reinterpret_cast<uintptr_t*>(base + relocData->VirtualAddress + ((*relativeInfo) & 0xFFF)) };
                    *patch += reinterpret_cast<uintptr_t>(locationDelta);
                }
            }
            relocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<std::byte*>(relocData) + relocData->SizeOfBlock);
        }
    }

    if (opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
    {
        auto importDescr{ reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(base + opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) };
        while (importDescr->Characteristics)
        {
            const char* module{ reinterpret_cast<char*>(base + importDescr->Name) };
            const auto dll{ _LoadLibraryA(module) };

            auto thunkRef{ reinterpret_cast<uintptr_t*>(base + importDescr->OriginalFirstThunk) };
            auto funcRef{ reinterpret_cast<FARPROC*>(base + importDescr->FirstThunk) };

            if (!thunkRef)
                thunkRef = reinterpret_cast<uintptr_t*>(funcRef);

            while (*thunkRef)
            {
                if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
                {
                    *funcRef = _GetProcAddress(dll, reinterpret_cast<char*>(*thunkRef & 0xFFFF));
                }
                else
                {
                    const auto import{ reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(base + (*thunkRef)) };
                    *funcRef = _GetProcAddress(dll, import->Name);
                }
                ++thunkRef;
                ++funcRef;
            }
            ++importDescr;
        }
    }

    if (opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
    {
        const auto tls{ reinterpret_cast<IMAGE_TLS_DIRECTORY*>(base + opt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress) };
        auto callback{ reinterpret_cast<PIMAGE_TLS_CALLBACK*>(tls->AddressOfCallBacks) };
        while (callback && *callback)
            (*callback++)(base, DLL_PROCESS_ATTACH, nullptr);
    }
    _dllMain(base, DLL_PROCESS_ATTACH, nullptr);

    for (unsigned int i = 0; i != 0x1000; i += sizeof(unsigned long))
        *reinterpret_cast<unsigned long*>(base + i) = 0;
}


bool MMap::threadHijack()
{
    CONTEXT ctx = { CONTEXT_FULL };

    if (!thread)
    {
        std::throw_with_nested(std::runtime_error("Error: Wrong thread handle: " + GetLastError()));
    }


    SuspendThread(thread);
    GetThreadContext(thread, &ctx);


    constexpr unsigned long funcOffset = 0x04;
    constexpr unsigned long checkByteOffset = 0x02 + funcOffset;

    *reinterpret_cast<unsigned long*>(shellcode.data() + 0x06 + funcOffset) = ctx.Eip;

    *reinterpret_cast<void**>(shellcode.data() + 0x0F + funcOffset) = targetBase;
    *reinterpret_cast<void**>(shellcode.data() + 0x14 + funcOffset) = loader;

    *reinterpret_cast<void**>(shellcode.data() + 0x1C + funcOffset) = codeCave;
    *reinterpret_cast<std::byte**>(shellcode.data() + 0x26 + funcOffset) = reinterpret_cast<std::byte*>(codeCave) + checkByteOffset;

    ctx.Eip = reinterpret_cast<unsigned long>(codeCave) + funcOffset;

    if (!WriteProcessMemory(process, codeCave, shellcode.data(), shellcode.size(), nullptr)) // + 0x4 because a unsigned long is 0x4 big
    {
        ResumeThread(thread);
        CloseHandle(thread);
        VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: shellcode injection failed: " + GetLastError()));
    }

    if (!SetThreadContext(thread, &ctx))
    {
        ResumeThread(thread);
        CloseHandle(thread);
        VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: Hijacking failed: " + GetLastError()));
    }

    if (ResumeThread(thread) == (unsigned long)-1)
    {
        CloseHandle(thread);
        VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: Failed to resume thread: " + GetLastError()));
    }

    CloseHandle(thread);

    const auto timer{ GetTickCount64() };
    unsigned char checkByte{ 1 };

    do
    {
        ReadProcessMemory(process, reinterpret_cast<std::byte*>(codeCave) + checkByteOffset, &checkByte, 1, nullptr);

        if (GetTickCount64() - timer > 5000)
        {
            VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
            std::throw_with_nested(std::runtime_error("Error: Hijacking timeout: " + GetLastError()));
        }

        Sleep(10);
    } while (checkByte);

    ReadProcessMemory(process, codeCave, &checkByte, sizeof(checkByte), nullptr);
    VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
    return true;
}

bool MMap::run()
{
    const auto oldNtHeader{ reinterpret_cast<IMAGE_NT_HEADERS*>(srcData + reinterpret_cast<IMAGE_DOS_HEADER*>(srcData)->e_lfanew) };
    const auto oldOptHeader{ &oldNtHeader->OptionalHeader };
    const auto oldFileHeader{ &oldNtHeader->FileHeader };

    auto sectionHeader = IMAGE_FIRST_SECTION(oldNtHeader);
    for (unsigned short i = 0; i != oldFileHeader->NumberOfSections; ++i, ++sectionHeader)
    {
        if (sectionHeader->SizeOfRawData)
        {
            if (!WriteProcessMemory(process, targetBase + sectionHeader->VirtualAddress, srcData + sectionHeader->PointerToRawData, sectionHeader->SizeOfRawData, nullptr))
            {
                VirtualFreeEx(process, targetBase, 0, MEM_RELEASE);
                std::throw_with_nested(std::runtime_error("Error: MMAP failed: " + GetLastError()));
            }
        }
    }

    WriteProcessMemory(process, targetBase, srcData, 0x1000, nullptr);
    WriteProcessMemory(process, targetBase, &data, sizeof(data), nullptr);
    WriteProcessMemory(process, loader, mapper, 0x1000, nullptr);

    uintptr_t dllOut = 0;

    if (!threadHijack())
    {
        VirtualFreeEx(process, targetBase, 0, MEM_RELEASE);
        VirtualFreeEx(process, loader, 0, MEM_RELEASE);
        std::throw_with_nested(std::runtime_error("Error: Thread hijacking was not success: " + GetLastError()));
    }

    VirtualFreeEx(process, loader, 0, MEM_RELEASE);

    return true;
}

```

`Library/MMap.h`:

```h
#pragma once

#include "ProcessInfo.h"
#include <Windows.h>
#include <vector>
#include <string>
#include <stdexcept>

using _LoadLibraryA = HMODULE(__stdcall*)(const char*);
using _GetProcAddress = FARPROC(__stdcall*)(HMODULE, const char*);
using _DLL_ENTRY_POINT = BOOL(__stdcall*)(void* dll, unsigned long reason, void* reserved);

struct MANUAL_MAPPING_DATA
{
    _LoadLibraryA		LoadLibraryA;
    _GetProcAddress	GetProcAddress;
};

class MMap
{
    MANUAL_MAPPING_DATA data{ LoadLibraryA, GetProcAddress };
    HANDLE process{ nullptr };
    HANDLE thread{ nullptr };

    std::vector<std::byte> file;
    std::byte* srcData{ nullptr };
    std::byte* targetBase{ nullptr };
    void* loader{ nullptr };
    void* codeCave{ nullptr };

    bool threadHijack();

public:
    explicit MMap(ProcessInfo processInfo, std::vector<std::byte> _file);

    bool run();

    ~MMap()
    {
        if (thread)
            CloseHandle(thread);
        if (codeCave)
            VirtualFreeEx(process, codeCave, 0, MEM_RELEASE);
        if (loader)
            VirtualFreeEx(process, loader, 0, MEM_RELEASE);
        if (process)
            CloseHandle(process);
    }
};
```

`Library/ProcessInfo.h`:

```h
#pragma once
#include <string>

struct ProcessInfo {
    const std::wstring processName;
    const unsigned long pid;
    const unsigned long tid;
};

```

`Library/Shtreeba.h`:

```h
#pragma once

#include "ProcessInfo.h"
#include "File.h"
#include "MMap.h"

class Shtreeba
{
    ProcessInfo processInfo;
    File file;
    MMap mmap;

public:
    explicit Shtreeba(const ProcessInfo& _processInfo, const std::filesystem::path& _file) : processInfo{ _processInfo }, file{ _file }, mmap(_processInfo, file.read()) { };

    bool inject() { return mmap.run(); };

    constexpr auto& getProcessInfo() { return processInfo; }
};
```

`Library/Start.cpp`:

```cpp
#include <filesystem>
#include "ProcessInfo.h"
#include "Shtreeba.h"

bool Start(ProcessInfo processInfo, const std::filesystem::path& filePath)
{
    Shtreeba shtreeba(processInfo, filePath);
    shtreeba.inject();
    return EXIT_SUCCESS;
}



```

`Library/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Library.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# Shtreeba [![C++](https://img.shields.io/badge/language-C%2B%2B-%23f34b7d.svg?style=plastic)](https://en.wikipedia.org/wiki/C%2B%2B) [![Windows](https://img.shields.io/badge/platform-Windows-0078d7.svg)](https://en.wikipedia.org/wiki/Microsoft_Windows) [![x86](https://img.shields.io/badge/arch-x86-red.svg)](https://en.wikipedia.org/wiki/X86) [![License](https://img.shields.io/github/license/mdilai/Shtreeba.svg)](COPYING.LESSER) ![Windows](https://github.com/mdilai/Shtreeba/workflows/Windows/badge.svg?branch=master&event=push)

VAC-proof 32bit DLL injector written in C++, using memory mapping and thread hijacking techniques

## Features:
* **Library** - full-featured VAC-proof and VirusTotal-proof library for injecting third-party DLL's into 32-bit applications.
* **UI** - Simple interface for accessing Library as injector.

## Getting started

### Prerequisites

Written using **Microsoft Visual Studio 2019**, work with older versions not guaranteed.

### Prebuilt release
Download [latest release](https://github.com/mdilai/Shtreeba/releases) and unpack to any desired location.

### Compiling from source

Open **Shtreeba.sln** in Microsoft Visual Studio 2019. 
Make sure build configuration is set to `Release | x86` and build the solution. 

If everything went right you will find `Shtreeba.exe` and `Shtreeba.dll` files in Release folder.
Copy both files to some location and run `Shtreeba.exe` to generate default config

### Usage.
* Put your **DLL** to inject together with `Shtreeba.exe` and `Shtreeba.dll`
* Edit `Shtreeba.ini` to set **path** and **process name**
* Run `Shtreeba.exe` as **Administrator**

### Configuration
Configuration file Shtreeba.ini will be automatically created after first run. Here is default sample config:
```
[Library]
DLL=Jweega.bin
ProcessName=csgo.exe
[UI]
Silent=0
CloseDelay=3000
```
* **DLL** - Absolute or relative path to DLL for injection. By default is `Jweega.bin` at current work directory
* **ProcessName** - Name of process for injection into. By default is `csgo.exe`
* **Silent** - Disable non-critical notifications. By default is `0`.
* **CloseDelay** - Interval in milliseconds for automatical closing of UI Messagebox after injecting (when `Silent=0`)

## License

> Copyright (c) 2019-2021 Maksym Dilai

This project is licensed under the [LGPL-3.0 License](https://opensource.org/licenses/LGPL-3.0) - see the [COPYING.LESSER](COPYING.LESSER) file for details.

## See also
- [JweegaCSGO](https://github.com/mdilai/JweegaCSGO) - free and open source cheat for CS:GO based on [Osiris](https://github.com/danielkrupinski/Osiris)

```

`Shtreeba.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Library", "Library\Library.vcxproj", "{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UI", "UI\UI.vcxproj", "{D6D6A886-BF13-48CA-9294-3316321CC099}"
	ProjectSection(ProjectDependencies) = postProject
		{C73A8C25-4224-472C-A68B-DA5AC5F32A6C} = {C73A8C25-4224-472C-A68B-DA5AC5F32A6C}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}.Debug|x86.ActiveCfg = Debug|Win32
		{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}.Debug|x86.Build.0 = Debug|Win32
		{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}.Release|x86.ActiveCfg = Release|Win32
		{C73A8C25-4224-472C-A68B-DA5AC5F32A6C}.Release|x86.Build.0 = Release|Win32
		{D6D6A886-BF13-48CA-9294-3316321CC099}.Debug|x86.ActiveCfg = Debug|Win32
		{D6D6A886-BF13-48CA-9294-3316321CC099}.Debug|x86.Build.0 = Debug|Win32
		{D6D6A886-BF13-48CA-9294-3316321CC099}.Release|x86.ActiveCfg = Release|Win32
		{D6D6A886-BF13-48CA-9294-3316321CC099}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F64AFFBD-92A4-4C0E-A02D-DA6E8C990132}
	EndGlobalSection
EndGlobal

```

`UI/FindProcessId.cpp`:

```cpp
#include "FindProcessId.h"
#include <memory>
#include <stdexcept>
#include <string>

static std::string errMsg() {
    char* e = strerror(errno);
    return e ? e : "";
}

FindProcessId::FindProcessId() {
    const auto hNTDLL{ LoadLibraryW(L"ntdll") };
    if (!hNTDLL)
        std::throw_with_nested(std::runtime_error("Unable to get handle of ntdll.dll library: " + errMsg()));

    const auto ntQSI{ reinterpret_cast<f_NTQuerySystemInformation>(GetProcAddress(hNTDLL, "NtQuerySystemInformation")) };
    if (!ntQSI)
        std::throw_with_nested(std::runtime_error("Unable to load NTQuerySystemInformation function: " + errMsg()));

    if (SIZE_T buffersize; !NT_SUCCESS(ntQSI(SystemProcessInformation, nullptr, 0, &buffersize))) {
        auto buffer{ std::make_unique<std::byte[]>(buffersize) };
        auto spi{ reinterpret_cast<SYSTEM_PROCESSES*>(buffer.get()) };
        if (NTSTATUS status; !NT_SUCCESS(status = ntQSI(SystemProcessInformation, spi, buffersize, nullptr)))
            std::throw_with_nested(std::runtime_error("Error: Unable to query list of running processes: " + status));

        while (spi->NextEntryDelta)
        {
            spi = reinterpret_cast<SYSTEM_PROCESSES*>((LPBYTE)spi + spi->NextEntryDelta);
            const auto processName{ spi->ProcessName.Buffer };
            const auto pid{ spi->ProcessId };
            const auto tid{ reinterpret_cast<ULONG>(spi->Threads->ClientId.UniqueThread) };
            processList.emplace_back(ProcessInfo{ processName, pid, tid });
        }
    }
}

ProcessInfo FindProcessId::getProcess(std::wstring_view processName)
{
    for (const auto& process : processList)
        if (processName == process.processName)
            return process;

    std::throw_with_nested(std::runtime_error("Error: Failed to find target process!"));
}

ProcessInfo FindProcessId::getProcess(int pid)
{
    for (const auto& process : processList)
        if (pid == process.pid)
            return process;

    std::throw_with_nested(std::runtime_error("Error: Failed to find target process!"));
}
```

`UI/FindProcessId.h`:

```h
#pragma once

#include <vector>
#include <Windows.h>
#include <winternl.h>
#include "ProcessInfo.h"

class FindProcessId {

    struct SYSTEM_THREADS {
        LARGE_INTEGER  KernelTime;
        LARGE_INTEGER  UserTime;
        LARGE_INTEGER  CreateTime;
        ULONG          WaitTime;
        PVOID          StartAddress;
        CLIENT_ID      ClientId;
        KPRIORITY      Priority;
        KPRIORITY      BasePriority;
        ULONG          ContextSwitchCount;
        LONG           State;
        LONG           WaitReason;
    };

    struct VM_COUNTERS {
        SIZE_T             PeakVirtualSize;
        SIZE_T             VirtualSize;
        ULONG              PageFaultCount;
        SIZE_T             PeakWorkingSetSize;
        SIZE_T             WorkingSetSize;
        SIZE_T             QuotaPeakPagedPoolUsage;
        SIZE_T             QuotaPagedPoolUsage;
        SIZE_T             QuotaPeakNonPagedPoolUsage;
        SIZE_T             QuotaNonPagedPoolUsage;
        SIZE_T             PagefileUsage;
        SIZE_T             PeakPagefileUsage;
    };

    struct SYSTEM_PROCESSES {
        ULONG              NextEntryDelta;
        ULONG              ThreadCount;
        ULONG              Reserved1[6];
        LARGE_INTEGER      CreateTime;
        LARGE_INTEGER      UserTime;
        LARGE_INTEGER      KernelTime;
        UNICODE_STRING     ProcessName;
        KPRIORITY          BasePriority;
        ULONG              ProcessId;
        ULONG              InheritedFromProcessId;
        ULONG              HandleCount;
        ULONG              Reserved2[2];
        VM_COUNTERS        VmCounters;
        IO_COUNTERS        IoCounters;
        SYSTEM_THREADS     Threads[1];
    };
    using f_NTQuerySystemInformation = NTSTATUS(WINAPI*)(ULONG, PVOID, ULONG, PULONG);


    std::vector<ProcessInfo> processList;

public:
    FindProcessId();
    ProcessInfo getProcess(std::wstring_view process);
    ProcessInfo getProcess(int pid);
    constexpr auto& getList() { return processList; }
};
```

`UI/Shtreeba.ini`:

```ini
[Library]
DLL=Jweega.bin
ProcessName=csgo.exe
[UI]
Silent=0

```

`UI/UI.cpp`:

```cpp
#include "FindProcessId.h"

#include <iostream>
#include <filesystem>
#include <sstream>

#include <Windows.h>

using _Start = bool(*)(ProcessInfo, const std::filesystem::path&);

static const inline int MessageBoxTimeoutW(HWND hWnd, const WCHAR* sText, const WCHAR* sCaption, UINT uType, DWORD dwMilliseconds)
{
    using _MessageBoxTimeoutW = int(WINAPI*)(HWND, LPCWSTR, LPCWSTR, UINT, WORD, DWORD);
    int iResult;
    HMODULE hUser32 = LoadLibraryW(L"user32.dll");
    if (hUser32)
    {
        const auto MessageBoxTimeoutW{ reinterpret_cast<_MessageBoxTimeoutW>(GetProcAddress(hUser32, "MessageBoxTimeoutW")) };
        iResult = MessageBoxTimeoutW(hWnd, sText, sCaption, uType, 0, dwMilliseconds);
        FreeLibrary(hUser32);
    }
    else
        iResult = MessageBox(hWnd, sText, sCaption, uType);

    return iResult;
}

static const inline void adjustPrivileges()
{
    HANDLE token;
    TOKEN_PRIVILEGES tp;
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    tp.Privileges[0].Luid.LowPart = 20; // 20 = SeDebugPrivilege
    tp.Privileges[0].Luid.HighPart = 0;

    if (OpenProcessToken((HANDLE)-1, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token))
    {
        AdjustTokenPrivileges(token, FALSE, &tp, 0, NULL, 0);
        CloseHandle(token);
    }
}

static const inline auto getConfig(LPCWSTR section, LPCWSTR key, LPCWSTR def, LPCWSTR filename)
{
    wchar_t temp[MAX_PATH];
    int result = GetPrivateProfileStringW(section, key, def, temp, sizeof(temp) / sizeof(temp[0]), filename);
    return std::wstring(temp, result);
}

static const inline auto getConfig(LPCWSTR section, LPCWSTR key, int def, LPCWSTR filename)
{
    return GetPrivateProfileIntW(section, key, def, filename);
}

static const inline auto setConfig(LPCWSTR section, LPCWSTR key, LPCWSTR data, LPCWSTR filename)
{
    if (!WritePrivateProfileStringW(section, key, data, filename))
        std::wcout << "Error: Unable to save config file: " << GetLastError() << "\n";
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    constexpr auto libraryName{ L"Shtreeba" };
    const auto configPath{ std::filesystem::absolute(std::filesystem::path(L"Shtreeba.ini")) };

    const auto fileName{ getConfig(L"Library", L"DLL", L"Jweega.bin", configPath.c_str()) };
    const auto processName{ getConfig(L"Library", L"ProcessName", L"csgo.exe", configPath.c_str()) };
    const auto isSilent{ getConfig(L"UI", L"Silent", 0, configPath.c_str()) };
    const auto closeDelay{ getConfig(L"UI", L"CloseDelay", 3000, configPath.c_str()) };
    if (!std::filesystem::exists(configPath)) {
        setConfig(L"Library", L"DLL", fileName.data(), configPath.c_str());
        setConfig(L"Library", L"ProcessName", processName.data(), configPath.c_str());
        setConfig(L"UI", L"Silent", std::to_wstring(isSilent).data(), configPath.c_str());
        setConfig(L"UI", L"CloseDelay", std::to_wstring(closeDelay).data(), configPath.c_str());
    }

    const auto hInst = LoadLibraryW(std::filesystem::absolute(std::filesystem::path(libraryName)).c_str());
    if (!hInst) {
        std::wcout << "Shtreeba.dll loading failed\n";
        MessageBoxW(NULL, L"Shtreeba.dll loading failed", L"Error", MB_OK | MB_ICONERROR);
        return EXIT_FAILURE;
    }


    const auto Shtreeba = reinterpret_cast<_Start>(GetProcAddress(hInst, "Start"));
    if (!Shtreeba) {
        FreeLibrary(hInst);
        std::wcout << "Failed to load function from library\n";
        MessageBoxW(NULL, L"Failed to load function from library", L"Error", MB_OK | MB_ICONERROR);
        return EXIT_FAILURE;
    }

    try {
        adjustPrivileges();
        FindProcessId processList;
        const auto processInfo{ processList.getProcess(processName) };
        const auto filePath{ std::filesystem::absolute(std::filesystem::path(fileName)) };
        Shtreeba(processInfo, filePath);
        if (!isSilent) {
            std::wcout << "Process name: " << processInfo.processName << "\nPID: " << processInfo.pid << "\nTID: " << processInfo.tid << "\n";
            std::wcout << "Done!" << "\n";
            auto buf{ (std::wstringstream{ } << "Process name: " << processInfo.processName << "\nPID: " << processInfo.pid << "\nTID: " << processInfo.tid << "\n").str() };
            MessageBoxTimeoutW(NULL, buf.data(), L"Success", MB_OK | MB_ICONINFORMATION, closeDelay);
        }
    }
    catch (const std::exception& e) {
        FreeLibrary(hInst);
        std::cerr << e.what() << '\n';
        MessageBoxA(NULL, e.what(), "Error", MB_OK | MB_ICONERROR);
        return EXIT_FAILURE;
    }

    FreeLibrary(hInst);
    return EXIT_SUCCESS;
}
```

`UI/UI.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
FILEVERSION 2, 0, 0, 1
PRODUCTVERSION 2, 0, 0, 1
FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
FILEFLAGS 0x1L
#else
FILEFLAGS 0x0L
#endif
FILEOS 0x40004L
FILETYPE 0x1L
FILESUBTYPE 0x0L
BEGIN
BLOCK "StringFileInfo"
BEGIN
BLOCK "040004b0"
BEGIN
VALUE "CompanyName", "Jweega Capital Limited Incorporated"
VALUE "FileDescription", "SHTREEBA executable"
VALUE "FileVersion", "2.0.0.1"
VALUE "InternalName", "Shtreeba.exe"
VALUE "LegalCopyright", "Copyright (C) 2019"
VALUE "OriginalFilename", "Shtreeba.exe"
VALUE "ProductName", "SHTREEBA: Dynamic library assistant"
VALUE "ProductVersion", "2.0.0.1"
END
END
BLOCK "VarFileInfo"
BEGIN
VALUE "Translation", 0x400, 1200
END
END

#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Ukrainian (Ukraine) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_UKR)
LANGUAGE LANG_UKRAINIAN, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
"resource.h\0"
END

2 TEXTINCLUDE
BEGIN
"#include ""winres.h""\r\n"
"\0"
END

3 TEXTINCLUDE
BEGIN
"\r\n"
"\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Ukrainian (Ukraine) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`UI/UI.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{D6D6A886-BF13-48CA-9294-3316321CC099}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>UI</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <GenerateManifest>true</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;WINVER=0x0601;_WIN32_WINNT=0x0601;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>../Library;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32_LEAN_AND_MEAN;WINVER=0x0601;_WIN32_WINNT=0x0601;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <StringPooling>true</StringPooling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <EnforceTypeConversionRules>true</EnforceTypeConversionRules>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <AdditionalIncludeDirectories>../Library;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <AdditionalOptions>/Gw /Ob3 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>advapi32.lib;user32.lib</AdditionalDependencies>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <ForceSymbolReferences>
      </ForceSymbolReferences>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FindProcessId.cpp" />
    <ClCompile Include="UI.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FindProcessId.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="UI.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UI/UI.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FindProcessId.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FindProcessId.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="UI.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`UI/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by UI.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```