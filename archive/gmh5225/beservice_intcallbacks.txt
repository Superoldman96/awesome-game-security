Project Path: arc_gmh5225_beservice_intcallbacks_t4kwfekc

Source Tree:

```txt
arc_gmh5225_beservice_intcallbacks_t4kwfekc
├── README.md
├── beservice_intcallbacks
│   ├── beservice_intcallbacks.vcxproj
│   ├── beservice_intcallbacks.vcxproj.filters
│   ├── beservice_intcallbacks.vcxproj.user
│   ├── bridge.asm
│   ├── common.h
│   ├── dllmain.cpp
│   ├── framework.h
│   ├── instrumentation.cpp
│   ├── instrumentation.h
│   ├── pch.cpp
│   ├── pch.h
│   ├── symbols.cpp
│   └── symbols.h
└── beservice_intcallbacks.sln

```

`README.md`:

```md
# beservice_intcallbacks
battleye bypass that could have worked. abusing old secret.club vulnerability in a different way.

credits:
- me (banging rocks together)
- ekknod (support)
- deputation (https://github.com/Deputation/instrumentation_callbacks)

```

`beservice_intcallbacks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32901.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "beservice_intcallbacks", "beservice_intcallbacks\beservice_intcallbacks.vcxproj", "{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Debug|x64.ActiveCfg = Debug|x64
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Debug|x64.Build.0 = Debug|x64
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Debug|x86.ActiveCfg = Debug|Win32
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Debug|x86.Build.0 = Debug|Win32
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Release|x64.ActiveCfg = Release|x64
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Release|x64.Build.0 = Release|x64
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Release|x86.ActiveCfg = Release|Win32
		{F9EF7C09-C4B8-4038-AFF5-539BD57BDECC}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4AFBDB1C-8975-4A6D-AA14-1F54707F159B}
	EndGlobalSection
EndGlobal

```

`beservice_intcallbacks/beservice_intcallbacks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f9ef7c09-c4b8-4038-aff5-539bd57bdecc}</ProjectGuid>
    <RootNamespace>beserviceintcallbacks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>profapi</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>C:\Program Files (x86)\Common Files\BattlEye</OutDir>
    <TargetName>profapi</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;BESERVICEINTCALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;BESERVICEINTCALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;BESERVICEINTCALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>imagehlp.lib;ntdll.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;BESERVICEINTCALLBACKS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>imagehlp.lib;ntdll.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="instrumentation.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="symbols.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="instrumentation.h" />
    <ClInclude Include="symbols.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="bridge.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`beservice_intcallbacks/beservice_intcallbacks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="instrumentation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="symbols.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="instrumentation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="symbols.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="bridge.asm">
      <Filter>Header Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`beservice_intcallbacks/beservice_intcallbacks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`beservice_intcallbacks/bridge.asm`:

```asm
EXTERN callback:NEAR
EXTERNDEF __imp_RtlCaptureContext:QWORD

.code

bridge PROC	
    ; credits to https://gist.github.com/esoterix/df38008568c50d4f83123e3a90b62ebb
    mov gs:[2e0h], rsp ; Win10 TEB InstrumentationCallbackPreviousSp
    mov gs:[2d8h], r10 ; Win10 TEB InstrumentationCallbackPreviousPc
	
	mov r10, rcx ; save rcx
	sub rsp, 4d0h ; CONTEXT structure size
	and rsp, -10h ; align rsp
	mov rcx, rsp ; parameters are fun
	call __imp_RtlCaptureContext ; capture the thread's context
	
	sub rsp, 20h ; shadow stack space
	call callback ; call our callback which will restore context and go back to where we want
	
	int 3 ; we should not be here.
bridge ENDP

END
```

`beservice_intcallbacks/common.h`:

```h
#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <chrono>

#include <Windows.h>
#include <DbgHelp.h>

#include <fstream>

#include "instrumentation.h"
#include "symbols.h"

static bool g_shouldRun = 0;
static std::ofstream output;
```

`beservice_intcallbacks/dllmain.cpp`:

```cpp
#include "common.h"

int main(void) {

    //OutputDebugStringA("[SuperBE]\n");
    //output.close();

    syms::initialize();

    if (!instrumentation::initialize()) {
        //OutputDebugStringA("[+] Couldn't initialize instrumentation callbacks.\n");
    }

    while (true) {
        Sleep(1);
    }

    return 0;
}


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(0, 0, (LPTHREAD_START_ROUTINE)main, 0, 0, 0);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`beservice_intcallbacks/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`beservice_intcallbacks/instrumentation.cpp`:

```cpp
#include "common.h"
#pragma warning(disable:4996)

void DebugOut(const wchar_t* fmt, ...)
{
    va_list argp;
    va_start(argp, fmt);
    wchar_t dbg_out[4096];
    vswprintf_s(dbg_out, fmt, argp);
    va_end(argp);
    OutputDebugString(dbg_out);
}

DWORD instrumentation::tls_index;
int repeat = 0;

bool g_shouldshould = true;

void callback(CONTEXT* ctx) {

    auto teb = reinterpret_cast<uint64_t>(NtCurrentTeb());
    ctx->Rip = *reinterpret_cast<uint64_t*>(teb + 0x2d8);
    ctx->Rsp = *reinterpret_cast<uint64_t*>(teb + 0x2e0);
    ctx->Rcx = ctx->R10;

    if(repeat == 4) {
        RtlRestoreContext(ctx, nullptr);
        return;
    }

    if (instrumentation::is_thread_handling_syscall()) {
        RtlRestoreContext(ctx, nullptr);
    }

    if (!instrumentation::set_thread_handling_syscall(true)) {
        RtlRestoreContext(ctx, nullptr);
    }

    auto return_address = reinterpret_cast<void*>(ctx->Rip);
    auto return_value = reinterpret_cast<void*>(ctx->Rax);

    uint64_t offset_into_function;
    auto function_name = syms::g_parser->get_function_sym_by_address(
        return_address, &offset_into_function);

    if (strcmp(function_name.c_str(), "ZwCreateFile") == 0)
    {
        HANDLE hOrig = *(HANDLE*)(ctx->Rsp + 0x80);
        if (hOrig != INVALID_HANDLE_VALUE && hOrig > (HANDLE)0x10 && hOrig < (HANDLE)0x1000)
        {
            size_t size = sizeof(FILE_NAME_INFO) + sizeof(WCHAR) * MAX_PATH;
            FILE_NAME_INFO* cInfo = (FILE_NAME_INFO*)(malloc(size));
            if (cInfo)
            {
                BOOL status = GetFileInformationByHandleEx(hOrig, FileNameInfo, cInfo, size);
                if (status)
                {
                    if (wcsstr(cInfo->FileName, L"SPINF.dll") != 0)
                    {
                        repeat++;
                        //Who wouldve thought? SPINF.dll is ksuser.dll all of a sudden. Weird... ;)
                        HANDLE hksuser = CreateFileA("C:\\Users\\emlin\\desktop\\ksuser.dll", GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                        *(HANDLE*)(ctx->Rsp + 0x80) = hksuser;

                        //dont close the handle since battleye does that for us.
                    }
                }
            }
        }
    }

    instrumentation::set_thread_handling_syscall(false);
    RtlRestoreContext(ctx, nullptr);
}

bool* instrumentation::get_thread_data_pointer() {
    void* thread_data = nullptr;
    bool* data_pointer = nullptr;

    thread_data = TlsGetValue(instrumentation::tls_index);

    if (thread_data == nullptr) {
        thread_data = reinterpret_cast<void*>(LocalAlloc(LPTR, 256));

        if (thread_data == nullptr) {
            return nullptr;
        }

        RtlZeroMemory(thread_data, 256);


        if (!TlsSetValue(instrumentation::tls_index, thread_data)) {
            return nullptr;
        }
    }

    data_pointer = reinterpret_cast<bool*>(thread_data);

    return data_pointer;
}

bool instrumentation::set_thread_handling_syscall(bool value) {
    if (auto data_pointer = get_thread_data_pointer()) {
        *data_pointer = value;
        return true;
    }

    return false;
}

bool instrumentation::is_thread_handling_syscall() {
    if (auto data_pointer = get_thread_data_pointer()) {
        return *data_pointer;
    }

    return false;
}

bool instrumentation::initialize() {

    auto nt_dll = LoadLibrary(L"ntdll.dll");
    if (!nt_dll)
        return false;

    auto nt_set_information_process = reinterpret_cast<instrumentation::nt_set_information_process_t>(GetProcAddress(nt_dll, "NtSetInformationProcess"));

    if (!nt_set_information_process)
        return false;

    instrumentation::tls_index = TlsAlloc();

    if (instrumentation::tls_index == TLS_OUT_OF_INDEXES)
        return false;

    process_instrumentation_callback_info_t info;
    info.version = 0;  // x64 mode
    info.reserved = 0;
    info.callback = bridge;

    nt_set_information_process(GetCurrentProcess(),static_cast<PROCESS_INFORMATION_CLASS>(0x28),&info, sizeof(info));

    return true;
}
```

`beservice_intcallbacks/instrumentation.h`:

```h
#pragma once

namespace instrumentation {
    /// <summary>
    /// Structure describing the syscall NtSetInformationProcess, its return value
    /// and its arguments.
    /// </summary>
    using nt_set_information_process_t = NTSTATUS(NTAPI*)(HANDLE,
        PROCESS_INFORMATION_CLASS,
        PVOID, ULONG);
    /// <summary>
    /// Structure describing the callback the system will call.
    /// </summary>
    using bridge_function_t = void (*)();

    /// <summary>
    /// System structure used to describe an instrumentation callback, will be sent
    /// to the NtSetInformationProcess syscall.
    /// </summary>
    struct process_instrumentation_callback_info_t {
        uint32_t version;
        uint32_t reserved;
        bridge_function_t callback;
    };

    /// <summary>
    /// TLS index used to store thread specific information.
    /// </summary>
    extern DWORD tls_index;

    /// <summary>
    /// Get a pointer to the thread specific information we allocated (a boolean
    /// telling us whether the current thread is handling a syscall or not.
    /// </summary>
    /// <returns>A pointer to the boolean describing whether or not the current
    /// thread is handling a syscall.</returns>
    bool* get_thread_data_pointer();

    /// <summary>
    /// Gets a pointer to the thread specific data describing whether or not the
    /// current thread is handling a syscall, and sets it to the value defined in parameters.
    /// </summary>
    /// <param name="value">Value to set the syscall "lock" to.</param>
    /// <returns>True if the operation was successful, false if not.</returns>
    bool set_thread_handling_syscall(bool value);

    /// <summary>
    /// Gets a pointer to the thread specific data describing whether or not the
    /// curreent thread is handling a syscall, dereferences it and returns its
    /// value.
    /// </summary>
    /// <returns>Ture if the variable was set to true, false if it wasn't or there
    /// was an error.</returns>
    bool is_thread_handling_syscall();

    /// <summary>
    /// Initializes the TLS index and places the instrumentation callback.
    /// </summary>
    /// <returns>True if initialization was successful, false if not.</returns>
    bool initialize();
}  // namespace instrumentation

/// <summary>
/// "Bridge" function used to call the instrumentationc allback and setting up
/// the stack properly.
/// </summary>
extern "C" void bridge();

/// <summary>
/// Actual instrumentation callback which will receive syscall. Extern'd so that
/// it may be called directly from the .asm file.
/// </summary>
/// <param name="ctx">syscall context.</param>
extern "C" void callback(CONTEXT * ctx);


extern bool g_shouldshould;
```

`beservice_intcallbacks/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`beservice_intcallbacks/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H

```

`beservice_intcallbacks/symbols.cpp`:

```cpp
#include "common.h"

std::shared_ptr<syms::parser_t> syms::g_parser;

std::string syms::parser_t::get_function_sym_by_address(
    void* address, uint64_t* offset_into_function_output) {
    auto buffer = std::malloc(sizeof(SYMBOL_INFO) + MAX_SYM_NAME);

    if (!buffer) {
        return "Couldn't retrieve function name.";
    }

    RtlZeroMemory(buffer, sizeof(buffer));

    auto symbol_information = reinterpret_cast<PSYMBOL_INFO>(buffer);
    symbol_information->SizeOfStruct = sizeof(SYMBOL_INFO);
    symbol_information->MaxNameLen = MAX_SYM_NAME;

    DWORD64 offset_into_function = 0;

    auto result = SymFromAddr(reinterpret_cast<HANDLE>(-1),
        reinterpret_cast<DWORD64>(address),
        &offset_into_function, symbol_information);

    if (!result) {
        std::free(buffer);
        return "Couldn't retrieve function name.";
    }

    if (offset_into_function_output) {
        *offset_into_function_output = offset_into_function;
    }

    auto built_string = std::string(symbol_information->Name);

    std::free(buffer);

    return built_string;
}

syms::parser_t::parser_t() {
    SymSetOptions(SYMOPT_UNDNAME);
    SymInitialize(reinterpret_cast<HANDLE>(-1), nullptr, true);
}

void syms::initialize() { g_parser = std::make_shared<parser_t>(); }
```

`beservice_intcallbacks/symbols.h`:

```h
#pragma once

namespace syms {
    /// <summary>
    /// Parser clased used to interface with the DbgHelp interface.
    /// </summary>
    class parser_t {
    public:
        /// <summary>
        /// Gets a function's name given its address.
        /// </summary>
        /// <param name="address">Function address (can be any number of bytes into
        /// the function.)</param> <param name="offset_into_function_output">Pointer
        /// to a variable which will receive the amount of bytes the address is into
        /// the function.</param>
        /// <returns>The function's name if successful., otherwise an error
        /// message.</returns>
        std::string get_function_sym_by_address(
            void* address, uint64_t* offset_into_function_output = nullptr);

        /// <summary>
        /// Initializes the symbol parsing interface.
        /// </summary>
        parser_t();
    };

    /// <summary>
    /// Singleton used to let the program interface elegantly with the symbol
    /// parsing interface.
    /// </summary>
    extern std::shared_ptr<parser_t> g_parser;

    /// <summary>
    /// Initializes the symbol parsing interface.
    /// </summary>
    void initialize();
}  // namespace syms
```