Project Path: arc_gmh5225_pe-bear_f65ustt3

Source Tree:

```txt
arc_gmh5225_pe-bear_f65ustt3
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ SIG.txt
â”œâ”€â”€ bearparser
â”œâ”€â”€ build.sh
â”œâ”€â”€ build_qt4.sh
â”œâ”€â”€ build_qt5.sh
â”œâ”€â”€ capstone
â”œâ”€â”€ disasm
â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ Disasm.cpp
â”‚   â”œâ”€â”€ Disasm.h
â”‚   â”œâ”€â”€ MnemType.h
â”‚   â”œâ”€â”€ PeDisasm.cpp
â”‚   â”œâ”€â”€ PeDisasm.h
â”‚   â”œâ”€â”€ bear_disasm.h
â”‚   â”œâ”€â”€ cdis
â”‚   â”‚   â”œâ”€â”€ CDisasm.cpp
â”‚   â”‚   â””â”€â”€ CDisasm.h
â”‚   â””â”€â”€ udis
â”‚       â”œâ”€â”€ UDisasm.cpp
â”‚       â””â”€â”€ UDisasm.h
â”œâ”€â”€ logo
â”‚   â””â”€â”€ main_ico.png
â”œâ”€â”€ macos_wrap.sh
â”œâ”€â”€ pe-bear
â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ DateDisplay.cpp
â”‚   â”œâ”€â”€ DateDisplay.h
â”‚   â”œâ”€â”€ DisasmView.cpp
â”‚   â”œâ”€â”€ DisasmView.h
â”‚   â”œâ”€â”€ ExeDependentAction.cpp
â”‚   â”œâ”€â”€ ExeDependentAction.h
â”‚   â”œâ”€â”€ HexCompareView.cpp
â”‚   â”œâ”€â”€ HexCompareView.h
â”‚   â”œâ”€â”€ HexDumpModel.cpp
â”‚   â”œâ”€â”€ HexDumpModel.h
â”‚   â”œâ”€â”€ HexView.cpp
â”‚   â”œâ”€â”€ HexView.h
â”‚   â”œâ”€â”€ OffsetHeader.cpp
â”‚   â”œâ”€â”€ OffsetHeader.h
â”‚   â”œâ”€â”€ PEDockedWidget.cpp
â”‚   â”œâ”€â”€ PEDockedWidget.h
â”‚   â”œâ”€â”€ PEFileTreeModel.cpp
â”‚   â”œâ”€â”€ PEFileTreeModel.h
â”‚   â”œâ”€â”€ REbear.h
â”‚   â”œâ”€â”€ SectionsDiagram.cpp
â”‚   â”œâ”€â”€ SectionsDiagram.h
â”‚   â”œâ”€â”€ TempBuffer.h
â”‚   â”œâ”€â”€ ViewSettings.cpp
â”‚   â”œâ”€â”€ ViewSettings.h
â”‚   â”œâ”€â”€ application.qrc
â”‚   â”œâ”€â”€ base
â”‚   â”‚   â”œâ”€â”€ BearVers.cpp
â”‚   â”‚   â”œâ”€â”€ BearVers.h
â”‚   â”‚   â”œâ”€â”€ CommentHandler.cpp
â”‚   â”‚   â”œâ”€â”€ CommentHandler.h
â”‚   â”‚   â”œâ”€â”€ MainSettings.cpp
â”‚   â”‚   â”œâ”€â”€ MainSettings.h
â”‚   â”‚   â”œâ”€â”€ Modification.cpp
â”‚   â”‚   â”œâ”€â”€ Modification.h
â”‚   â”‚   â”œâ”€â”€ PeHandler.cpp
â”‚   â”‚   â”œâ”€â”€ PeHandler.h
â”‚   â”‚   â”œâ”€â”€ PeHandlerFactory.cpp
â”‚   â”‚   â”œâ”€â”€ PeHandlerFactory.h
â”‚   â”‚   â”œâ”€â”€ PeHandlersManager.cpp
â”‚   â”‚   â”œâ”€â”€ PeHandlersManager.h
â”‚   â”‚   â”œâ”€â”€ RegKeyManager.cpp
â”‚   â”‚   â”œâ”€â”€ RegKeyManager.h
â”‚   â”‚   â””â”€â”€ Releasable.h
â”‚   â”œâ”€â”€ gui
â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚   â”œâ”€â”€ CommentView.cpp
â”‚   â”‚   â”œâ”€â”€ CommentView.h
â”‚   â”‚   â”œâ”€â”€ ContentPreview.cpp
â”‚   â”‚   â”œâ”€â”€ ContentPreview.h
â”‚   â”‚   â”œâ”€â”€ DarkStyle.h
â”‚   â”‚   â”œâ”€â”€ DataDirWrapperSplitter.cpp
â”‚   â”‚   â”œâ”€â”€ DataDirWrapperSplitter.h
â”‚   â”‚   â”œâ”€â”€ DetailsTab.cpp
â”‚   â”‚   â”œâ”€â”€ DetailsTab.h
â”‚   â”‚   â”œâ”€â”€ DosHdrTableModel.cpp
â”‚   â”‚   â”œâ”€â”€ DosHdrTableModel.h
â”‚   â”‚   â”œâ”€â”€ GeneralPanel.cpp
â”‚   â”‚   â”œâ”€â”€ GeneralPanel.h
â”‚   â”‚   â”œâ”€â”€ HexDiffModel.cpp
â”‚   â”‚   â”œâ”€â”€ HexDiffModel.h
â”‚   â”‚   â”œâ”€â”€ PackersTableModel.cpp
â”‚   â”‚   â”œâ”€â”€ PackersTableModel.h
â”‚   â”‚   â”œâ”€â”€ PeTreeModel.cpp
â”‚   â”‚   â”œâ”€â”€ PeTreeModel.h
â”‚   â”‚   â”œâ”€â”€ PeWrapperModel.cpp
â”‚   â”‚   â”œâ”€â”€ PeWrapperModel.h
â”‚   â”‚   â”œâ”€â”€ ResourceDirSplitter.cpp
â”‚   â”‚   â”œâ”€â”€ ResourceDirSplitter.h
â”‚   â”‚   â”œâ”€â”€ TreeModel.cpp
â”‚   â”‚   â”œâ”€â”€ TreeModel.h
â”‚   â”‚   â”œâ”€â”€ WrapperSplitter.cpp
â”‚   â”‚   â”œâ”€â”€ WrapperSplitter.h
â”‚   â”‚   â”œâ”€â”€ WrapperTreeView.cpp
â”‚   â”‚   â”œâ”€â”€ WrapperTreeView.h
â”‚   â”‚   â”œâ”€â”€ pe_models
â”‚   â”‚   â”‚   â”œâ”€â”€ BoundImpTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ BoundImpTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ ClrHdrTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ ClrHdrTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ DebugTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ DebugTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ DelayImpTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ DelayImpTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ ExceptionTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ ExceptionTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportsTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportsTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ FileHdrTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ FileHdrTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ ImportsTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ ImportsTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ LdConfigTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ LdConfigTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ OptionalHdrTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ OptionalHdrTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ RelocsTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ RelocsTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ ResourcesTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ ResourcesTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ RichHdrTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ RichHdrTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ SecHdrsTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ SecHdrsTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ SecurityTreeModel.cpp
â”‚   â”‚   â”‚   â”œâ”€â”€ SecurityTreeModel.h
â”‚   â”‚   â”‚   â”œâ”€â”€ TLSTreeModel.cpp
â”‚   â”‚   â”‚   â””â”€â”€ TLSTreeModel.h
â”‚   â”‚   â”œâ”€â”€ pe_models.h
â”‚   â”‚   â””â”€â”€ windows
â”‚   â”‚       â”œâ”€â”€ DiffWindow.cpp
â”‚   â”‚       â”œâ”€â”€ DiffWindow.h
â”‚   â”‚       â”œâ”€â”€ MainWindow.cpp
â”‚   â”‚       â”œâ”€â”€ MainWindow.h
â”‚   â”‚       â”œâ”€â”€ OffsetsBrowseWindow.cpp
â”‚   â”‚       â”œâ”€â”€ OffsetsBrowseWindow.h
â”‚   â”‚       â”œâ”€â”€ SectionAddWindow.cpp
â”‚   â”‚       â”œâ”€â”€ SectionAddWindow.h
â”‚   â”‚       â”œâ”€â”€ SignaturesBrowseWindow.cpp
â”‚   â”‚       â”œâ”€â”€ SignaturesBrowseWindow.h
â”‚   â”‚       â”œâ”€â”€ UserConfigWindow.cpp
â”‚   â”‚       â””â”€â”€ UserConfigWindow.h
â”‚   â”œâ”€â”€ gui_base
â”‚   â”‚   â”œâ”€â”€ AddressInputDialog.cpp
â”‚   â”‚   â”œâ”€â”€ AddressInputDialog.h
â”‚   â”‚   â”œâ”€â”€ ClipboardUtil.cpp
â”‚   â”‚   â”œâ”€â”€ ClipboardUtil.h
â”‚   â”‚   â”œâ”€â”€ ExtTableView.cpp
â”‚   â”‚   â”œâ”€â”€ ExtTableView.h
â”‚   â”‚   â”œâ”€â”€ FollowablePeTreeView.cpp
â”‚   â”‚   â”œâ”€â”€ FollowablePeTreeView.h
â”‚   â”‚   â”œâ”€â”€ HexInputDialog.cpp
â”‚   â”‚   â”œâ”€â”€ HexInputDialog.h
â”‚   â”‚   â”œâ”€â”€ HexMimeSource.cpp
â”‚   â”‚   â”œâ”€â”€ HexMimeSource.h
â”‚   â”‚   â”œâ”€â”€ HexSpinBox.cpp
â”‚   â”‚   â”œâ”€â”€ HexSpinBox.h
â”‚   â”‚   â”œâ”€â”€ OffsetDependentAction.cpp
â”‚   â”‚   â”œâ”€â”€ OffsetDependentAction.h
â”‚   â”‚   â”œâ”€â”€ PEViewsManager.cpp
â”‚   â”‚   â”œâ”€â”€ PEViewsManager.h
â”‚   â”‚   â”œâ”€â”€ PeGuiItem.cpp
â”‚   â”‚   â”œâ”€â”€ PeGuiItem.h
â”‚   â”‚   â”œâ”€â”€ PeTableModel.cpp
â”‚   â”‚   â”œâ”€â”€ PeTableModel.h
â”‚   â”‚   â”œâ”€â”€ PeTreeView.cpp
â”‚   â”‚   â”œâ”€â”€ PeTreeView.h
â”‚   â”‚   â”œâ”€â”€ TreeCpView.cpp
â”‚   â”‚   â”œâ”€â”€ TreeCpView.h
â”‚   â”‚   â”œâ”€â”€ WrapperInterface.cpp
â”‚   â”‚   â”œâ”€â”€ WrapperInterface.h
â”‚   â”‚   â”œâ”€â”€ WrapperTableModel.cpp
â”‚   â”‚   â””â”€â”€ WrapperTableModel.h
â”‚   â”œâ”€â”€ icons
â”‚   â”‚   â”œâ”€â”€ Add.ico
â”‚   â”‚   â”œâ”€â”€ Delete.ico
â”‚   â”‚   â”œâ”€â”€ DeleteAll.ico
â”‚   â”‚   â”œâ”€â”€ EP.ico
â”‚   â”‚   â”œâ”€â”€ List.ico
â”‚   â”‚   â”œâ”€â”€ Locked.ico
â”‚   â”‚   â”œâ”€â”€ Preview.ico
â”‚   â”‚   â”œâ”€â”€ Save.ico
â”‚   â”‚   â”œâ”€â”€ add_entry.ico
â”‚   â”‚   â”œâ”€â”€ add_subentry.ico
â”‚   â”‚   â”œâ”€â”€ app32.ico
â”‚   â”‚   â”œâ”€â”€ app32_w.ico
â”‚   â”‚   â”œâ”€â”€ app64.ico
â”‚   â”‚   â”œâ”€â”€ app64_w.ico
â”‚   â”‚   â”œâ”€â”€ arr_down.ico
â”‚   â”‚   â”œâ”€â”€ arr_up.ico
â”‚   â”‚   â”œâ”€â”€ arrow-right.ico
â”‚   â”‚   â”œâ”€â”€ data_dir_color.ico
â”‚   â”‚   â”œâ”€â”€ data_dir_gray.ico
â”‚   â”‚   â”œâ”€â”€ dos.ico
â”‚   â”‚   â”œâ”€â”€ down.ico
â”‚   â”‚   â”œâ”€â”€ dump.ico
â”‚   â”‚   â”œâ”€â”€ enlarge.ico
â”‚   â”‚   â”œâ”€â”€ eraser.ico
â”‚   â”‚   â”œâ”€â”€ go_to_raw.ico
â”‚   â”‚   â”œâ”€â”€ go_to_rva.ico
â”‚   â”‚   â”œâ”€â”€ hdr.ico
â”‚   â”‚   â”œâ”€â”€ information.ico
â”‚   â”‚   â”œâ”€â”€ move.ico
â”‚   â”‚   â”œâ”€â”€ red_pin.ico
â”‚   â”‚   â”œâ”€â”€ reload.ico
â”‚   â”‚   â”œâ”€â”€ resize.ico
â”‚   â”‚   â”œâ”€â”€ save_black.ico
â”‚   â”‚   â”œâ”€â”€ section.ico
â”‚   â”‚   â”œâ”€â”€ shrink.ico
â”‚   â”‚   â”œâ”€â”€ space.ico
â”‚   â”‚   â”œâ”€â”€ space_down.ico
â”‚   â”‚   â”œâ”€â”€ space_this.ico
â”‚   â”‚   â”œâ”€â”€ space_up.ico
â”‚   â”‚   â”œâ”€â”€ star.ico
â”‚   â”‚   â”œâ”€â”€ undo.ico
â”‚   â”‚   â”œâ”€â”€ unmodify.ico
â”‚   â”‚   â”œâ”€â”€ up.ico
â”‚   â”‚   â””â”€â”€ wrong_way.ico
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ main_ico.ico
â”‚   â”œâ”€â”€ resources.h
â”‚   â””â”€â”€ resources.rc
â””â”€â”€ sig_finder
    â”œâ”€â”€ CMakeLists.txt
    â”œâ”€â”€ sig_finder
    â”‚   â”œâ”€â”€ PckrSign.cpp
    â”‚   â”œâ”€â”€ PckrSign.h
    â”‚   â”œâ”€â”€ SigFinder.cpp
    â”‚   â”œâ”€â”€ SigFinder.h
    â”‚   â”œâ”€â”€ SigNode.cpp
    â”‚   â”œâ”€â”€ SigNode.h
    â”‚   â”œâ”€â”€ SigTree.cpp
    â”‚   â””â”€â”€ SigTree.h
    â”œâ”€â”€ sig_finder.h
    â””â”€â”€ win_types.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)
project (PE-bear_full)

# modules:
set ( M_SIGFIND "sig_finder" )
set ( M_BEARPARSER "bearparser/parser" )
set ( M_DISASM "disasm" )
set ( M_CAPSTONE "capstone" )

option(USE_QT4 "Use Qt4 (Qt5 if OFF)" OFF )
option(SHOW_CONSOLE "Show debug console" OFF )

# libraries should be searched in a local directory of the binary
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")

	if(RELATIVE_LIBS)
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-rpath='$ORIGIN'")
	endif()

endif()

# modules paths:
set (PARSER_DIR "${CMAKE_SOURCE_DIR}/${M_BEARPARSER}" CACHE PATH "BearParser main path")
set (PARSER_INC "${PARSER_DIR}/include" CACHE PATH "BearParser include path")

set( SIGFIND_DIR "${CMAKE_SOURCE_DIR}/${M_SIGFIND}" CACHE PATH "SigMa main path")
set( DISASM_DIR "${CMAKE_SOURCE_DIR}/${M_DISASM}" CACHE PATH "Disasm main path")

set (CAPSTONE_DIR "${CMAKE_SOURCE_DIR}/${M_CAPSTONE}" CACHE PATH "Capstone main path")
set (CAPSTONE_INC "${CAPSTONE_DIR}/include" CACHE PATH "Capstone include path")

#capstone settings:
option(CAPSTONE_INSTALL "Install Capstone" OFF)
option(CAPSTONE_BUILD_STATIC_RUNTIME "Embed static runtime" OFF)
option(CAPSTONE_BUILD_STATIC "Build static library" ON)
option(CAPSTONE_BUILD_SHARED "Build shared library" OFF)
option(CAPSTONE_BUILD_DIET "Build diet library" OFF)
option(CAPSTONE_BUILD_TESTS "Build tests" OFF)
option(CAPSTONE_USE_DEFAULT_ALLOC "Use default memory allocation functions" ON)
option(CAPSTONE_ARM_SUPPORT "ARM support" OFF)
option(CAPSTONE_ARM64_SUPPORT "ARM64 support" OFF)
option(CAPSTONE_MIPS_SUPPORT "MIPS support" OFF)
option(CAPSTONE_PPC_SUPPORT "PowerPC support" OFF)
option(CAPSTONE_SPARC_SUPPORT "Sparc support" OFF)
option(CAPSTONE_SYSZ_SUPPORT "SystemZ support" OFF)
option(CAPSTONE_XCORE_SUPPORT "XCore support" OFF)

option(CAPSTONE_M68K_SUPPORT "M68K support" OFF)
option(CAPSTONE_MOS65XX_SUPPORT "MOS65XX support" OFF)
option(CAPSTONE_M680X_SUPPORT "M680X support" OFF)
option(CAPSTONE_TMS320C64X_SUPPORT "TMS320C64X support" OFF)
option(CAPSTONE_EVM_SUPPORT "EVM support" OFF)
option(CAPSTONE_WASM_SUPPORT "WASM support" OFF)
option(CAPSTONE_BPF_SUPPORT "BPF support" OFF)
option(CAPSTONE_RISCV_SUPPORT "RISCV support" OFF)
 
option(CAPSTONE_X86_SUPPORT "x86 support" ON)
option(CAPSTONE_X86_REDUCE "x86 with reduce instruction sets to minimize library" OFF)
option(CAPSTONE_X86_ATT_DISABLE "Disable x86 AT&T syntax" ON)

# Add sub-directories
#
# libs

add_subdirectory(${M_CAPSTONE})
set(CAPSTONE_LIB $<TARGET_FILE:capstone-static> CACHE PATH "Capstone library path")

add_subdirectory(${M_BEARPARSER})
set(PARSER_LIB $<TARGET_FILE:bearparser> CACHE PATH "BearParser library path")

add_subdirectory(${M_DISASM})
set(DISASM_LIB $<TARGET_FILE:libdisasm> CACHE PATH "Disasm library path")

add_subdirectory(${M_SIGFIND})
set(SIGFIND_LIB $<TARGET_FILE:sig_finder> CACHE PATH "SigFinder library path")

# executables
add_subdirectory(pe-bear)

add_dependencies(libdisasm bearparser capstone-static)
add_dependencies(PE-bear bearparser sig_finder libdisasm capstone-static)


```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`README.md`:

```md
PE-bear
-

<img src="./logo/main_ico.png" alt="PE-bear logo">

[![Build status](https://ci.appveyor.com/api/projects/status/q2smuy32pqqo0oyn?svg=true)](https://ci.appveyor.com/project/hasherezade/pe-bear)
[![Codacy Badge](https://app.codacy.com/project/badge/Grade/14648384b52b4d979bc1f2246edbd496)](https://www.codacy.com/gh/hasherezade/pe-bear/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=hasherezade/pe-bear&amp;utm_campaign=Badge_Grade)
[![License: GPL v2](https://img.shields.io/badge/License-GPL_v2-blue.svg)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)

[![GitHub release](https://img.shields.io/github/release/hasherezade/pe-bear.svg)](https://github.com/hasherezade/pe-bear/releases) 
[![Github All Releases](https://img.shields.io/github/downloads/hasherezade/pe-bear-releases/total.svg)](https://github.com/hasherezade/pe-bear-releases/releases) 
[![Github Latest Release](https://img.shields.io/github/downloads/hasherezade/pe-bear/latest/total.svg)](https://github.com/hasherezade/pe-bear/releases) 

PE-bear is a multiplatform reversing tool for PE files. Its objective is to deliver fast and flexible â€œfirst viewâ€ for malware analysts, stable and capable to handle malformed PE files.

Signatures for PE-bear:
+ [SIG.txt](SIG.txt) (updated: 22.01.2014) - *contains signatures from [PEid's UserDB](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml) - converted by a script provided by [crashish](http://crashish.blogspot.com/2013/09/peid-signature-conversion-for-pe-bear.html)*

## Builds

ðŸ“¦ âš™ï¸ Download the latest [release](https://github.com/hasherezade/pe-bear/releases).

![](https://community.chocolatey.org/favicon.ico) Available also via [Chocolatey](https://community.chocolatey.org/packages/pebear)

ðŸ§ª Fresh **test builds** (ahead of the official release) can be downloaded from the [AppVeyor build server](https://ci.appveyor.com/project/hasherezade/pe-bear). They are created on each commit to the `main` branch. You can download them by clicking on the build version, then choosing the tab `Artifacts`. WARNING: those builds may be unstable.

> An archive of **old releases** is available here: https://github.com/hasherezade/pe-bear-releases

## How to build

### Requires:

+   [git](https://git-scm.com/downloads)
+   [cmake](http://www.cmake.org)
+   [Qt5](https://www.qt.io/download) (optionally Qt4)
+   bearparser (submodule of the current repository)
+   capstone (submodule of the current repository)

### Clone

Use **recursive clone** to get the repo together with submodules:

```console
git clone --recursive https://github.com/hasherezade/pe-bear.git
```

### Building on Windows

Use [CMake](http://www.cmake.org) to generate a Visual Studio project. Open in Visual Studio and build.


### Building on Linux and MacOS

To build it on Linux or MacOS you can use the given scripts:
+   [build.sh](./build.sh) - default, builds with Qt5
+   [build_qt5.sh](./build_qt5.sh) - builds with Qt5
+   [build_qt4.sh](./build_qt4.sh) - builds with Qt4

To generate the `.app` bundle on MacOS you can use:
+   [macos_wrap.sh](./macos_wrap.sh)


---

If you like PE-bear, you can support it:

[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/donate/?hosted_button_id=FQX9B9VHCRBF4)


```

`SIG.txt`:

```txt
ASPack 1.00b
64
60 E8 ?? ?? ?? ?? 5D 81 ED 92 1A 44 00 B8 8C 1A
44 00 03 C5 2B 85 CD 1D 44 00 89 85 D9 1D 44 00
80 BD C4 1D 44 00 00 75 15 FE 85 C4 1D 44 00 E8
1D 00 00 00 E8 D5 01 00 00 E8 6A 02 00 00 8B 85

ASPack 1.01b
64
60 E8 ?? ?? ?? ?? 5D 81 ED D2 2A 44 00 B8 CC 2A
44 00 03 C5 2B 85 A5 2E 44 00 89 85 B1 2E 44 00
80 BD 9C 2E 44 00 00 75 15 FE 85 9C 2E 44 00 E8
1D 00 00 00 E8 E4 01 00 00 E8 7A 02 00 00 8B 85

ASPack 1.02a
64
60 E8 ?? ?? ?? ?? 5D 81 ED 3E D9 43 00 B8 38 D9
43 00 03 C5 2B 85 0B DE 43 00 89 85 17 DE 43 00
80 BD 01 DE 43 00 00 75 15 FE 85 01 DE 43 00 E8
1D 00 00 00 E8 79 02 00 00 E8 12 03 00 00 8B 85

ASPack 1.02b
64
60 E8 ?? ?? ?? ?? 5D 81 ED 96 78 43 00 B8 90 78
43 00 03 C5 2B 85 7D 7C 43 00 89 85 89 7C 43 00
80 BD 74 7C 43 00 00 75 15 FE 85 74 7C 43 00 E8
1D 00 00 00 E8 F7 01 00 00 E8 8E 02 00 00 8B 85

ASPack 1.03b
64
60 E8 ?? ?? ?? ?? 5D 81 ED CE 3A 44 00 B8 C8 3A
44 00 03 C5 2B 85 B5 3E 44 00 89 85 C1 3E 44 00
80 BD AC 3E 44 00 00 75 15 FE 85 AC 3E 44 00 E8
1D 00 00 00 E8 F7 01 00 00 E8 8E 02 00 00 8B 85

ASPack 1.04b
64
60 E8 ?? ?? ?? ?? 5D 81 ED AE 98 43 00 B8 A8 98
43 00 03 C5 2B 85 12 9D 43 00 89 85 1E 9D 43 00
80 BD 08 9D 43 00 00 75 15 FE 85 08 9D 43 00 E8
1D 00 00 00 E8 73 02 00 00 E8 0A 03 00 00 8B 85

ASPack 1.05b
64
60 E8 ?? ?? ?? ?? 5D 81 ED AE 98 43 00 B8 A8 98
43 00 03 C5 2B 85 18 9D 43 00 89 85 24 9D 43 00
80 BD 0E 9D 43 00 00 75 15 FE 85 0E 9D 43 00 E8
1D 00 00 00 E8 73 02 00 00 E8 0A 03 00 00 8B 85

ASPack 1.06x
64
60 E8 ?? ?? ?? ?? 5D 81 ED EA A8 43 00 B8 E4 A8
43 00 03 C5 2B 85 78 AD 43 00 89 85 84 AD 43 00
80 BD 6E AD 43 00 00 75 15 FE 85 6E AD 43 00 E8
1D 00 00 00 E8 73 02 00 00 E8 0A 03 00 00 8B 85

ASPack 1.07b
64
60 E8 ?? ?? ?? ?? 5D 81 ED 3E D9 43 00 B8 38 D9
43 00 03 C5 2B 85 0B DE 43 00 89 85 17 DE 43 00
80 BD 01 DE 43 00 00 75 15 FE 85 01 DE 43 00 E8
1D 00 00 00 E8 79 02 00 00 E8 12 03 00 00 8B 85

ASPack 1.08.00
64
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ED 23 EA 44 00 BB 10 EA 44 00 03 DD
2B 9D 72 EF 44 00 8D 8D DE F0 44 00 51 FF 95 C4
F1 44 00 8D 8D 04 F1 44 00 51 50 FF 95 C0 F1 44

ASPack 1.08.01
64
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ED 23 6A 44 00 BB 10 6A 44 00 03 DD
2B 9D 72 6F 44 00 8D 8D DE 70 44 00 51 FF 95 C4
71 44 00 8D 8D 04 71 44 00 51 50 FF 95 C0 71 44

ASPack 1.08.02
64
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ED 23 6A 44 00 BB 10 6A 44 00 03 DD
2B 9D 46 6F 44 00 8D 8D EA 6F 44 00 51 FF 95 D0
70 44 00 8D 8D 10 70 44 00 51 50 FF 95 CC 70 44

ASPack 1.08.03 (packed ldr)
64
60 E8 ?? ?? ?? ?? 5D 81 ED 0A 4A 44 00 BB 04 4A
44 00 03 DD 2B 9D B1 50 44 00 83 BD AC 50 44 00
00 89 9D BB 4E 44 00 0F 85 17 05 00 00 8D 85 D1
50 44 00 50 FF 95 94 51 44 00 89 85 CD 50 44 00

ASPack 1.08.04 (packed ldr)
8
60 E8 41 06 00 00 EB 41

ASPack 2.000
8
60 E8 70 05 00 00 EB 4C

ASPack 2.001
8
60 E8 72 05 00 00 EB 4C

ASPack  2.1
8
60 E8 72 05 00 00 EB 33

ASPack  2.11 (poly)
6
60 E9 3D 04 00 00

ASPack  2.11c (poly)
22
60 E8 02 00 00 00 EB 09 5D 55 81 ED 39 39 44 00
C3 E9 59 04 00 00

ASPack 2.12
64
?? E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB ?? ?? ??
?? 83 BD 22 04 00 00 00 89 9D 22 04 00 00 0F 85
65 03 00 00 8D 85 2E 04 00 00 50 FF 95 4D 0F 00

ASPack 2.12b
64
90 60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01
00 00 00 EB 5D BB EC FF FF FF 03 DD 81 EB ?? ??
?? ?? 83 BD 22 04 00 00 00 89 9D 22 04 00 00 0F
85 65 03 00 00 8D 85 2E 04 00 00 50 FF 95 4C 0F

ASPack 2.12
64
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB ?? ?? ??
?? 83 BD 7D 04 00 00 00 89 9D 7D 04 00 00 0F 85
C0 03 00 00 8D 85 89 04 00 00 50 FF 95 09 0F 00

ASPack 2.24 / 2.29
64
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB ?? ?? ??
?? 83 BD 88 04 00 00 00 89 9D 88 04 00 00 0F 85
CB 03 00 00 8D 85 94 04 00 00 50 FF 95 A9 0F 00

ASPack (in data sec)
7
75 00 E9 ?? ?? ?? 00

FSG 1.0
244
BB D0 01 40 00 BF 00 10 40 00 BE 00 00 00 00 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 FC
B2 80 A4 6A 02 5B FF 14 24 73 F7 33 C9 FF 14 24
73 18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14
24 12 C0 73 F9 75 3F AA EB DC E8 43 00 00 00 2B
CB 75 10 E8 38 00 00 00 EB 28 AC D1 E8 74 41 13
C9 EB 1C 91 48 C1 E0 08 AC E8 22 00 00 00 3D 00
7D 00 00 73 0A 80 FC 05 73 06 83 F8 7F 77 02 41
41 95 8B C5 B3 01 56 8B F7 2B F0 F3 A4 5E EB 96
33 C9 41 FF 54 24 04 13 C9 FF 54 24 04 72 F4 C3
5F 5B 0F B7 3B 4F 74 08 4F 74 13 C1 E7 0C EB 07
8B 7B 02 57 83 C3 04 43 43 E9 51 FF FF FF 5F BB
00 00 00 00 47 8B 37 AF 57 FF 13 95 33 C0 AE 75
FD FE 0F 74 EF FE 0F 75 06 47 FF 37 AF EB 09 FE
0F 0F 84 00 00 00 00 57 55 FF 53 04 09 06 AD 75
DB 8B EC C3

FSG 1.3
243
BB D0 01 40 00 BF 00 10 40 00 BE 00 00 00 00 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 B2
80 A4 6A 02 5B FF 14 24 73 F7 33 C9 FF 14 24 73
18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14 24
12 C0 73 F9 75 3F AA EB DC E8 43 00 00 00 2B CB
75 10 E8 38 00 00 00 EB 28 AC D1 E8 74 41 13 C9
EB 1C 91 48 C1 E0 08 AC E8 22 00 00 00 3D 00 7D
00 00 73 0A 80 FC 05 73 06 83 F8 7F 77 02 41 41
95 8B C5 B3 01 56 8B F7 2B F0 F3 A4 5E EB 96 33
C9 41 FF 54 24 04 13 C9 FF 54 24 04 72 F4 C3 5F
5B 0F B7 3B 4F 74 08 4F 74 13 C1 E7 0C EB 07 8B
7B 02 57 83 C3 04 43 43 E9 52 FF FF FF 5F BB 00
00 00 00 47 8B 37 AF 57 FF 13 95 33 C0 AE 75 FD
FE 0F 74 EF FE 0F 75 06 47 FF 37 AF EB 09 FE 0F
0F 84 00 00 00 00 57 55 FF 53 04 09 06 AD 75 DB
8B EC C3

FSG 1.31
239
BB D0 01 40 00 BF 00 10 40 00 BE 00 00 00 00 53
BB 00 00 00 00 B2 80 A4 B6 80 FF D3 73 F9 33 C9
FF D3 73 16 33 C0 FF D3 73 23 B6 80 41 B0 10 FF
D3 12 C0 73 FA 75 42 AA EB E0 E8 46 00 00 00 02
F6 83 D9 01 75 10 E8 38 00 00 00 EB 28 AC D1 E8
74 48 13 C9 EB 1C 91 48 C1 E0 08 AC E8 22 00 00
00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83 F8 7F
77 02 41 41 95 8B C5 B6 00 56 8B F7 2B F0 F3 A4
5E EB 97 33 C9 41 FF D3 13 C9 FF D3 72 F8 C3 02
D2 75 05 8A 16 46 12 D2 C3 5B 5B 0F B7 3B 4F 74
08 4F 74 13 C1 E7 0C EB 07 8B 7B 02 57 83 C3 04
43 43 E9 58 FF FF FF 5F BB 00 00 00 00 47 8B 37
AF 57 FF 13 95 33 C0 AE 75 FD FE 0F 74 EF FE 0F
75 06 47 FF 37 AF EB 09 FE 0F 0F 84 00 00 00 00
57 55 FF 53 04 89 06 AD 85 C0 75 D9 8B EC C3

FSG 1.33
197
BE A4 01 40 00 AD 93 AD 97 AD 56 96 B2 80 A4 B6
80 FF 13 73 F9 33 C9 FF 13 73 16 33 C0 FF 13 73
1F B6 80 41 B0 10 FF 13 12 C0 73 FA 75 3C AA EB
E0 FF 53 08 02 F6 83 D9 01 75 0E FF 53 04 EB 26
AC D1 E8 74 2F 13 C9 EB 1A 91 48 C1 E0 08 AC FF
53 04 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83 F8
7F 77 02 41 41 95 8B C5 B6 00 56 8B F7 2B F0 F3
A4 5E EB 9D 8B D6 5E AD 48 74 0A 79 02 AD 50 56
8B F2 97 EB 87 AD 93 5E 46 AD 97 56 FF 13 95 AC
84 C0 75 FB FE 0E 74 F0 79 05 46 AD 50 EB 09 FE
0E 0F 84 ?? ?? ?? ?? 56 55 FF 53 04 AB EB E0 33
C9 41 FF 13 13 C9 FF 13 72 F8 C3 02 D2 75 05 8A
16 46 12 D2 C3

FSG 2.0
170
87 25 ?? ?? ?? ??
61 94 55 A4 B6 80 FF 13 73 F9 33 C9 FF 13 73 16
33 C0 FF 13 73 1F B6 80 41 B0 10 FF 13 12 C0 73
FA 75 3A AA EB E0 FF 53 08 02 F6 83 D9 01 75 0E
FF 53 04 EB 24 AC D1 E8 74 2D 13 C9 EB 18 91 48
C1 E0 08 AC FF 53 04 3B 43 F8 73 0A 80 FC 05 73
06 83 F8 7F 77 02 41 41 95 8B C5 B6 00 56 8B F7
2B F0 F3 A4 5E EB 9F 5E AD 97 AD 50 FF 53 10 95
8B 07 40 78 F3 75 03 FF 63 0C 50 55 FF 53 14 AB
EB EE 33 C9 41 FF 13 13 C9 FF 13 72 F8 C3 02 D2
75 05 8A 16 46 12 D2 C3 4B 45 52 4E 45 4C 33 32
2E 64 6C 6C

WWPack32 v1.0
110
53 55 ?? ?? ?? ?? db eb 60 ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? e8 00 00 00 00

WWPack32 v1.03
111
53 55 ?? ?? ?? db eb 60 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? e8 00 00 00 00

WWPack32 v1.12/1.20
117
53 55 ?? ?? ?? db eb 60 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? e8 00 00 00 00 ?? ?? ??
?? ?? ?? ?? 60

WWPack32 v1.12/1.20(xor)
116
53 55 ?? ?? ?? db eb 60 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? e8 00 00 00 00 ?? ?? ??
?? ?? ?? 0F 

WWPack32(packed ldr)
120
53 55 ?? ?? ?? db eb 60 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? e8 00 00 00 00 ?? ?? ??
?? ?? ?? ?? ?? ?? 60 FD

!EP (ExE Pack) V1.0 -> Elite Coding Group
13
60 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? FF 10

!EPack 1.4 lite (final) - by 6aHguT
15
33 C0 8B C0 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8

$pirit v1.5
13
?? ?? ?? 5B 24 55 50 44 FB 32 2E 31 5D

$PIRIT v1.5
15
B4 4D CD 21 E8 ?? ?? FD E8 ?? ?? B4 51 CD 21

* PseudoSigner 0.1 --> Anorganix
26
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90

* PseudoSigner 0.1 [32Lite 0.03] --> Anorganix
23
60 06 FC 1E 07 BE 90 90 90 90 6A 04 68 90 10 90
90 68 ?? ?? ?? ?? E9

* PseudoSigner 0.1 [ACProtect 1.09] --> Anorganix
85
60 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 EB 02 00 00 90 90 90 04
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [Armadillo 3.00] --> Anorganix
49
60 E8 2A 00 00 00 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58 50 51 EB 85
E9

* PseudoSigner 0.1 [ASPack 2.xx Heuristic] --> Anorganix
63
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 A8 03 00 00 61 75
08 B8 01 00 00 00 C2 0C 00 68 00 00 00 00 C3 8B
85 26 04 00 00 8D 8D 3B 04 00 00 51 50 FF 95

* PseudoSigner 0.1 [ASProtect] --> Anorganix
22
60 90 90 90 90 90 90 5D 90 90 90 90 90 90 90 90
90 90 90 03 DD E9

* PseudoSigner 0.1 [Borland Delphi 3.0] --> Anorganix
85
55 8B EC 83 C4 90 90 90 90 68 ?? ?? ?? ?? 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [Borland Delphi 5.0 KOL/MCK] --> Anorganix
85
55 8B EC 90 90 90 90 68 ?? ?? ?? ?? 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 00 FF 90 90 90 90 90 90
90 90 00 01 90 90 90 90 90 90 90 90 90 EB 04 00
00 00 01 90 90 90 90 90 90 90 00 01 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [Borland Delphi 6.0 - 7.0] --> Anorganix
73
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 53 8B D8 33 C0 A3
09 09 09 00 6A 00 E8 09 09 00 FF A3 09 09 09 00
A1 09 09 09 00 A3 09 09 09 00 33 C0 A3 09 09 09
00 33 C0 A3 09 09 09 00 E8

* PseudoSigner 0.1 [CD-Cops II] --> Anorganix
21
53 60 BD 90 90 90 90 8D 45 90 8D 5D 90 E8 00 00
00 00 8D 01 E9

* PseudoSigner 0.1 [Code-Lock] --> Anorganix
30
43 4F 44 45 2D 4C 4F 43 4B 2E 4F 43 58 00 01 28
01 50 4B 47 05 4C 3F B4 04 4D 4C 47 4B E9

* PseudoSigner 0.1 [CodeSafe 2.0] --> Anorganix
36
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 EB 0B 83 EC 10 53 56 57 E8 C4
01 00 85 E9

* PseudoSigner 0.1 [Crunch/PE Heuristic] --> Anorganix
27
55 E8 0E 00 00 00 5D 83 ED 06 8B C5 55 60 89 AD
?? ?? ?? ?? 2B 85 00 00 00 00 E9

* PseudoSigner 0.1 [DEF 1.0] --> Anorganix
37
BE 00 01 40 00 6A 05 59 80 7E 07 00 74 11 8B 46
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 83 C1 01 E9

* PseudoSigner 0.1 [DxPack 1.0] --> Anorganix
41
60 E8 00 00 00 00 5D 8B FD 81 ED 90 90 90 90 2B
B9 00 00 00 00 81 EF 90 90 90 90 83 BD 90 90 90
90 90 0F 84 00 00 00 00 E9

* PseudoSigner 0.1 [ExeSmasher] --> Anorganix
41
9C FE 03 90 60 BE 90 90 41 90 8D BE 90 10 FF FF
57 83 CD FF EB 10 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 FE 0B E9

* PseudoSigner 0.1 [FSG 1.0] --> Anorganix
65
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 BB D0 01 40 00 BF
00 10 40 00 BE 90 90 90 90 53 E8 0A 00 00 00 02
D2 75 05 8A 16 46 12 D2 C3 FC B2 80 A4 6A 02 5B
E9

* PseudoSigner 0.1 [FSG 1.31] --> Anorganix
24
BE 90 90 90 00 BF 90 90 90 00 BB 90 90 90 00 53
BB 90 90 90 00 B2 80 E9

* PseudoSigner 0.1 [Gleam 1.00] --> Anorganix
36
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 EB 0B 83 EC 0C 53 56 57 E8 24
02 00 FF E9

* PseudoSigner 0.1 [JDPack 1.x / JDProtect 0.9] --> Anorganix
41
60 E8 22 00 00 00 5D 8B D5 81 ED 90 90 90 90 2B
95 90 90 90 90 81 EA 06 90 90 90 89 95 90 90 90
90 83 BD 45 00 01 00 01 E9

* PseudoSigner 0.1 [LCC Win32 1.x] --> Anorganix
23
64 A1 01 00 00 00 55 89 E5 6A FF 68 ?? ?? ?? ??
68 9A 10 40 90 50 E9

* PseudoSigner 0.1 [LCC Win32 DLL] --> Anorganix
32
55 89 E5 53 56 57 83 7D 0C 01 75 05 E8 17 90 90
90 FF 75 10 FF 75 0C FF 75 08 A1 ?? ?? ?? ?? E9

* PseudoSigner 0.1 [Lockless Intro Pack] --> Anorganix
31
2C E8 EB 1A 90 90 5D 8B C5 81 ED F6 73 90 90 2B
85 90 90 90 90 83 E8 06 89 85 FF 01 EC AD E9

* PseudoSigner 0.1 [LTC 1.3] --> Anorganix
25
54 E8 00 00 00 00 5D 8B C5 81 ED F6 73 40 00 2B
85 87 75 40 00 83 E8 06 E9

* PseudoSigner 0.1 [Macromedia Flash Projector 6.0] --> Anorganix
73
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 83 EC 44 56 FF 15
24 81 49 00 8B F0 8A 06 3C 22 75 1C 8A 46 01 46
3C 22 74 0C 84 C0 74 08 8A 46 01 46 3C 22 75 F4
80 3E 22 75 0F 46 EB 0C E9

* PseudoSigner 0.1 [MEW 11 SE 1.0] --> Anorganix
15
E9 09 00 00 00 00 00 00 02 00 00 00 0C 90 E9

* PseudoSigner 0.1 [Microsoft Visual Basic 5.0 - 6.0] --> Anorganix
21
68 ?? ?? ?? ?? E8 0A 00 00 00 00 00 00 00 00 00
30 00 00 00 E9

* PseudoSigner 0.1 [Microsoft Visual Basic 6.0 DLL] --> Anorganix
42
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 5A 68 90 90 90 90
68 90 90 90 90 52 E9 90 90 FF

* PseudoSigner 0.1 [Microsoft Visual C++ 5.0+ (MFC)] --> Anorganix
23
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 E9

* PseudoSigner 0.1 [Microsoft Visual C++ 6.0 (Debug Version)] --> Anorganix
85
55 8B EC 51 90 90 90 01 01 90 90 90 90 68 ?? ??
?? ?? 90 90 90 90 90 90 90 90 90 90 90 90 00 01
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 00 01
90 90 90 90 90

* PseudoSigner 0.1 [Microsoft Visual C++ 6.20] --> Anorganix
48
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 55 8B EC 83 EC 50
53 56 57 BE 90 90 90 90 8D 7D F4 A5 A5 66 A5 8B

* PseudoSigner 0.1 [Microsoft Visual C++ 7.0 DLL] --> Anorganix
33
55 8D 6C 01 00 81 EC 00 00 00 00 8B 45 90 83 F8
01 56 0F 84 00 00 00 00 85 C0 0F 84 ?? ?? ?? ??
E9

* PseudoSigner 0.1 [MinGW GCC 2.x] --> Anorganix
16
55 89 E5 E8 02 00 00 00 C9 C3 90 90 45 58 45 E9

* PseudoSigner 0.1 [Morphine 1.2] --> Anorganix
85
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
EB 06 00 90 90 90 90 90 90 90 90 EB 08 E8 90 00
00 00 66 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
51 66 90 90 90 59 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [Neolite 2.0] --> Anorganix
85
E9 A6 00 00 00 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [NorthStar PE Shrinker 1.3] --> Anorganix
27
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5 00 00 00 00 E9

* PseudoSigner 0.1 [Pack Master 1.0 (PEX Clone)] --> Anorganix
85
60 E8 01 01 00 00 E8 83 C4 04 E8 01 90 90 90 E9
5D 81 ED D3 22 40 90 E8 04 02 90 90 E8 EB 08 EB
02 CD 20 FF 24 24 9A 66 BE 47 46 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90

* PseudoSigner 0.1 [PE Intro 1.0] --> Anorganix
31
8B 04 24 9C 60 E8 14 00 00 00 5D 81 ED 0A 45 40
90 80 BD 67 44 40 90 90 0F 85 48 FF ED 0A E9

* PseudoSigner 0.1 [PE Pack 0.99] --> Anorganix
24
60 E8 11 00 00 00 5D 83 ED 06 80 BD E0 04 90 90
01 0F 84 F2 FF CC 0A E9

* PseudoSigner 0.1 [PE Protect 0.9] --> Anorganix
26
52 51 55 57 64 67 A1 30 00 85 C0 78 0D E8 07 00
00 00 58 83 C0 07 C6 90 C3 E9

* PseudoSigner 0.1 [PECompact 1.4+] --> Anorganix
55
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 EB 06 68 90 90 90
90 C3 9C 60 E8 02 90 90 90 33 C0 8B C4 83 C0 04
93 8B E3 8B 5B FC 81

* PseudoSigner 0.1 [PENightMare 2 Beta] --> Anorganix
23
60 E9 10 00 00 00 EF 40 03 A7 07 8F 07 1C 37 5D
43 A7 04 B9 2C 3A E9

* PseudoSigner 0.1 [PENinja 1.31] --> Anorganix
37
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 E9

* PseudoSigner 0.1 [PESHiELD 0.25] --> Anorganix
50
60 E8 2B 00 00 00 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 CC
CC E9

* PseudoSigner 0.1 [PEtite 2.x (level 0)] --> Anorganix
61
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 B8 00 90 90 00 6A
00 68 90 90 90 00 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 66 9C 60 50 8B D8 03 00 68

* PseudoSigner 0.1 [PEX 0.99] --> Anorganix
24
60 E8 01 00 00 00 55 83 C4 04 E8 01 00 00 00 90
5D 81 FF FF FF 00 01 E9

* PseudoSigner 0.1 [REALBasic] --> Anorganix
22
55 89 E5 90 90 90 90 90 90 90 90 90 90 50 90 90
90 90 90 00 01 E9

* PseudoSigner 0.1 [Ste@lth PE 1.01] --> Anorganix
68
0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0
BA ?? ?? ?? ?? FF E2 BA E0 10 40 00 B8 68 24 1A
40 89 02 83 C2 03 B8 40 00 E8 EE 89 02 83 C2 FD
FF E2 2D 3D 5B 20 48 69 64 65 50 45 20 5D 3D 2D
90 00 00 00

* PseudoSigner 0.1 [UPX 0.6] --> Anorganix
25
60 E8 00 00 00 00 58 83 E8 3D 50 8D B8 00 00 00
FF 57 8D B0 E8 00 00 00 E9

* PseudoSigner 0.1 [VBOX 4.3 MTE] --> Anorganix
17
0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0
E9

* PseudoSigner 0.1 [Video-Lan-Client] --> Anorganix
53
55 89 E5 83 EC 08 90 90 90 90 90 90 90 90 90 90
90 90 90 90 01 FF FF 01 01 01 00 01 90 90 90 90
90 90 90 90 90 90 90 90 90 90 00 01 00 01 00 01
90 90 00 01 E9

* PseudoSigner 0.1 [VOB ProtectCD 5] --> Anorganix
12
36 3E 26 8A C0 60 E8 00 00 00 00 E9

* PseudoSigner 0.1 [WATCOM C/C++ EXE] --> Anorganix
12
E9 00 00 00 00 90 90 90 90 57 41 E9

* PseudoSigner 0.1 [XCR 0.11] --> Anorganix
12
60 8B F0 33 DB 83 C3 01 83 C0 01 E9

* PseudoSigner 0.1 [Yoda's Protector 1.02] --> Anorganix
10
E8 03 00 00 00 EB 01 90 90 E9

* PseudoSigner 0.2 [.BJFNT 1.1b] --> Anorganix
21
EB 01 EA 9C EB 01 EA 53 EB 01 EA 51 EB 01 EA 52
EB 01 EA 56 90

* PseudoSigner 0.2 [.BJFNT 1.2] --> Anorganix
21
EB 02 69 B1 83 EC 04 EB 03 CD 20 EB EB 01 EB 9C
EB 01 EB EB 00

* PseudoSigner 0.2 [32Lite 0.03] --> Anorganix
18
60 06 FC 1E 07 BE 90 90 90 90 6A 04 68 90 10 90
90 68

* PseudoSigner 0.2 [Armadillo 3.00] --> Anorganix
48
60 E8 2A 00 00 00 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58 50 51 EB 85

* PseudoSigner 0.2 [ASProtect] --> Anorganix
21
60 90 90 90 90 90 90 5D 90 90 90 90 90 90 90 90
90 90 90 03 DD

* PseudoSigner 0.2 [Borland C++ 1999] --> Anorganix
24
EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90 E9 90 90
90 90 A1 ?? ?? ?? ?? A3

* PseudoSigner 0.2 [Borland C++ DLL (Method 2)] --> Anorganix
18
EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90 E9 90 90
90 90

* PseudoSigner 0.2 [Borland Delphi DLL] --> Anorganix
24
55 8B EC 83 C4 B4 B8 90 90 90 90 E8 00 00 00 00
E8 00 00 00 00 8D 40 00

* PseudoSigner 0.2 [Borland Delphi Setup Module] --> Anorganix
25
55 8B EC 83 C4 90 53 56 57 33 C0 89 45 F0 89 45
D4 89 45 D0 E8 00 00 00 00

* PseudoSigner 0.2 [CD-Cops II] --> Anorganix
20
53 60 BD 90 90 90 90 8D 45 90 8D 5D 90 E8 00 00
00 00 8D 01

* PseudoSigner 0.2 [Code-Lock] --> Anorganix
29
43 4F 44 45 2D 4C 4F 43 4B 2E 4F 43 58 00 01 28
01 50 4B 47 05 4C 3F B4 04 4D 4C 47 4B

* PseudoSigner 0.2 [CodeSafe 2.0] --> Anorganix
35
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 EB 0B 83 EC 10 53 56 57 E8 C4
01 00 85

* PseudoSigner 0.2 [Crunch/PE Heuristic] --> Anorganix
26
55 E8 0E 00 00 00 5D 83 ED 06 8B C5 55 60 89 AD
?? ?? ?? ?? 2B 85 00 00 00 00

* PseudoSigner 0.2 [DEF 1.0] --> Anorganix
36
BE 00 01 40 00 6A 05 59 80 7E 07 00 74 11 8B 46
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 83 C1 01

* PseudoSigner 0.2 [DxPack 1.0] --> Anorganix
40
60 E8 00 00 00 00 5D 8B FD 81 ED 90 90 90 90 2B
B9 00 00 00 00 81 EF 90 90 90 90 83 BD 90 90 90
90 90 0F 84 00 00 00 00

* PseudoSigner 0.2 [ExeSmasher] --> Anorganix
40
9C FE 03 90 60 BE 90 90 41 90 8D BE 90 10 FF FF
57 83 CD FF EB 10 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 FE 0B

* PseudoSigner 0.2 [FSG 1.0] --> Anorganix
64
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 BB D0 01 40 00 BF
00 10 40 00 BE 90 90 90 90 53 E8 0A 00 00 00 02
D2 75 05 8A 16 46 12 D2 C3 FC B2 80 A4 6A 02 5B

* PseudoSigner 0.2 [FSG 1.31] --> Anorganix
23
BE 90 90 90 00 BF 90 90 90 00 BB 90 90 90 00 53
BB 90 90 90 00 B2 80

* PseudoSigner 0.2 [Gleam 1.00] --> Anorganix
35
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 EB 0B 83 EC 0C 53 56 57 E8 24
02 00 FF

* PseudoSigner 0.2 [JDPack 1.x / JDProtect 0.9] --> Anorganix
40
60 E8 22 00 00 00 5D 8B D5 81 ED 90 90 90 90 2B
95 90 90 90 90 81 EA 06 90 90 90 89 95 90 90 90
90 83 BD 45 00 01 00 01

* PseudoSigner 0.2 [LCC Win32 1.x] --> Anorganix
22
64 A1 01 00 00 00 55 89 E5 6A FF 68 ?? ?? ?? ??
68 9A 10 40 90 50

* PseudoSigner 0.2 [LCC Win32 DLL] --> Anorganix
27
55 89 E5 53 56 57 83 7D 0C 01 75 05 E8 17 90 90
90 FF 75 10 FF 75 0C FF 75 08 A1

* PseudoSigner 0.2 [Lockless Intro Pack] --> Anorganix
30
2C E8 EB 1A 90 90 5D 8B C5 81 ED F6 73 90 90 2B
85 90 90 90 90 83 E8 06 89 85 FF 01 EC AD

* PseudoSigner 0.2 [Macromedia Flash Projector 6.0] --> Anorganix
72
90 90 90 90 68 ?? ?? ?? ?? 67 64 FF 36 00 00 67
64 89 26 00 00 F1 90 90 90 90 83 EC 44 56 FF 15
24 81 49 00 8B F0 8A 06 3C 22 75 1C 8A 46 01 46
3C 22 74 0C 84 C0 74 08 8A 46 01 46 3C 22 75 F4
80 3E 22 75 0F 46 EB 0C

* PseudoSigner 0.2 [MEW 11 SE 1.0] --> Anorganix
14
E9 09 00 00 00 00 00 00 02 00 00 00 0C 90

* PseudoSigner 0.2 [Microsoft Visual Basic 5.0 - 6.0] --> Anorganix
20
68 ?? ?? ?? ?? E8 0A 00 00 00 00 00 00 00 00 00
30 00 00 00

* PseudoSigner 0.2 [Microsoft Visual C++ 7.0 DLL] --> Anorganix
28
55 8D 6C 01 00 81 EC 00 00 00 00 8B 45 90 83 F8
01 56 0F 84 00 00 00 00 85 C0 0F 84

* PseudoSigner 0.2 [MinGW GCC 2.x] --> Anorganix
15
55 89 E5 E8 02 00 00 00 C9 C3 90 90 45 58 45

* PseudoSigner 0.2 [NorthStar PE Shrinker 1.3] --> Anorganix
26
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5 00 00 00 00

* PseudoSigner 0.2 [PE Intro 1.0] --> Anorganix
30
8B 04 24 9C 60 E8 14 00 00 00 5D 81 ED 0A 45 40
90 80 BD 67 44 40 90 90 0F 85 48 FF ED 0A

* PseudoSigner 0.2 [PE Pack 0.99] --> Anorganix
23
60 E8 11 00 00 00 5D 83 ED 06 80 BD E0 04 90 90
01 0F 84 F2 FF CC 0A

* PseudoSigner 0.2 [PE Protect 0.9] --> Anorganix
25
52 51 55 57 64 67 A1 30 00 85 C0 78 0D E8 07 00
00 00 58 83 C0 07 C6 90 C3

* PseudoSigner 0.2 [PENightMare 2 Beta] --> Anorganix
22
60 E9 10 00 00 00 EF 40 03 A7 07 8F 07 1C 37 5D
43 A7 04 B9 2C 3A

* PseudoSigner 0.2 [PESHiELD 0.25] --> Anorganix
49
60 E8 2B 00 00 00 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 CC
CC

* PseudoSigner 0.2 [PEX 0.99] --> Anorganix
23
60 E8 01 00 00 00 55 83 C4 04 E8 01 00 00 00 90
5D 81 FF FF FF 00 01

* PseudoSigner 0.2 [REALBasic] --> Anorganix
21
55 89 E5 90 90 90 90 90 90 90 90 90 90 50 90 90
90 90 90 00 01

* PseudoSigner 0.2 [UPX 0.6] --> Anorganix
24
60 E8 00 00 00 00 58 83 E8 3D 50 8D B8 00 00 00
FF 57 8D B0 E8 00 00 00

* PseudoSigner 0.2 [VBOX 4.3 MTE] --> Anorganix
16
0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0 0B C0

* PseudoSigner 0.2 [Video-Lan-Client] --> Anorganix
52
55 89 E5 83 EC 08 90 90 90 90 90 90 90 90 90 90
90 90 90 90 01 FF FF 01 01 01 00 01 90 90 90 90
90 90 90 90 90 90 90 90 90 90 00 01 00 01 00 01
90 90 00 01

* PseudoSigner 0.2 [VOB ProtectCD 5] --> Anorganix
11
36 3E 26 8A C0 60 E8 00 00 00 00

* PseudoSigner 0.2 [Watcom C/C++ DLL] --> Anorganix
26
53 56 57 55 8B 74 24 14 8B 7C 24 18 8B 6C 24 1C
83 FF 03 0F 87 01 00 00 00 F1

* PseudoSigner 0.2 [WATCOM C/C++ EXE] --> Anorganix
11
E9 00 00 00 00 90 90 90 90 57 41

* PseudoSigner 0.2 [XCR 0.11] --> Anorganix
11
60 8B F0 33 DB 83 C3 01 83 C0 01

* PseudoSigner 0.2 [Yoda's Protector 1.02] --> Anorganix
9
E8 03 00 00 00 EB 01 90 90

* PseudoSigner 0.2 [ZCode 1.01] --> Anorganix
35
E9 12 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 E9 FB FF FF FF C3 68 00 00 00 00 64 FF 35 00
00 00 00

* [MSLRH] v0.1 -> emadicius
85
60 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8

* [MSLRH] V0.31 -> emadicius
15
60 D1 CB 0F CA C1 CA E0 D1 CA 0F C8 EB 01 F1

* [MSLRH] v0.31a
85
60 D1 CB 0F CA C1 CA E0 D1 CA 0F C8 EB 01 F1 0F
C0 C9 D2 D1 0F C1 C0 D3 DA C0 D6 A8 EB 01 DE D0
EC 0F C1 CB D0 CF 0F C1 D1 D2 DB 0F C8 EB 01 BC
C0 E9 C6 C1 D0 91 0F CB EB 01 73 0F CA 87 D9 87
D2 D0 CF 87 D9 0F C8 EB 01 C1 EB 01 A2 86 CA D0
E1 0F C0 CB 0F

* [MSLRH] v0.32a -> emadicius
85
E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83
C4 08 74 04 75 02 EB 02 EB 01 81 74 04 75 02 EB
02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
2B 04 24 74 04 75 02 EB 02 EB 01 81 83 C4 04 E8
0A 00 00 00 E8

* [MSLRH] v0.32a -> emadicius
85
EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
74 04 75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29
5A 58 6B C0 03

*** Protector v1.1.11 (DDeM->PE Engine v0.9, DDeM->CI v0.9.2)
36
53 51 56 E8 00 00 00 00 5B 81 EB 08 10 00 00 8D
B3 34 10 00 00 B9 F3 03 00 00 BA 63 17 2A EE 31
16 83 C6 04

.BJFnt v1.1b
20
EB 01 EA 9C EB 01 EA 53 EB 01 EA 51 EB 01 EA 52
EB 01 EA 56

.BJFnt v1.2 RC
20
EB 02 69 B1 83 EC 04 EB 03 CD 20 EB EB 01 EB 9C
EB 01 EB EB

.BJFnt v1.3
21
EB ?? 3A ?? ?? 1E EB ?? CD 20 9C EB ?? CD 20 EB
?? CD 20 60 EB

.NET DLL -> Microsoft
38
00 00 00 00 00 00 00 00 5F 43 6F 72 44 6C 6C 4D
61 69 6E 00 6D 73 63 6F 72 65 65 2E 64 6C 6C 00
00 ?? 00 00 FF 25

.NET executable -> Microsoft
38
00 00 00 00 00 00 00 00 5F 43 6F 72 45 78 65 4D
61 69 6E 00 6D 73 63 6F 72 65 65 2E 64 6C 6C 00
00 00 00 00 FF 25

32Lite v0.03a
18
60 06 FC 1E 07 BE ?? ?? ?? ?? 6A 04 68 ?? 10 ??
?? 68

624 (Six to Four) v1.0
22
50 55 4C 50 83 ?? ?? FC BF ?? ?? BE ?? ?? B5 ??
57 F3 A5 C3 33 ED

Aase Crypter - by santasdad
210
55 8B EC 83 C4 F0 53 B8 A0 3E 00 10 E8 93 DE FF
FF 68 F8 42 00 10 E8 79 DF FF FF 68 00 43 00 10
68 0C 43 00 10 E8 42 DF FF FF 50 E8 44 DF FF FF
A3 98 66 00 10 83 3D 98 66 00 10 00 75 13 6A 00
68 18 43 00 10 68 1C 43 00 10 6A 00 E8 4B DF FF
FF 68 2C 43 00 10 68 0C 43 ?? ?? ?? ?? DF FF FF
50 E8 0E DF FF FF A3 94 66 00 10 83 3D 94 66 00
10 00 75 13 6A 00 68 18 43 00 10 68 38 43 00 10
6A 00 E8 15 DF FF FF 68 48 43 00 10 68 0C 43 00
10 E8 D6 DE FF FF 50 E8 D8 DE FF FF A3 A0 66 00
10 83 3D A0 66 00 10 00 75 13 6A 00 68 18 43 00
10 68 58 43 00 10 6A 00 E8 DF DE FF FF 68 6C 43
00 10 68 0C 43 00 10 E8 A0 DE FF FF 50 E8 A2 DE
FF FF

ABC Cryptor 1.0 - by ZloY
123
68 FF 64 24 F0 68 58 58 58 58 90 FF D4 50 8B 40
F2 05 B0 95 F6 95 0F 85 01 81 BB FF 68 ?? ?? ??
?? BF 00 ?? ?? ?? B9 00 ?? ?? ?? 80 37 ?? 47 39
CF 75 F8 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? BF 00 ?? ?? ?? B9 00
?? ?? ?? 80 37 ?? 47 39 CF 75 F8

AcidCrypt
30
60 B9 ?? ?? ?? 00 BA ?? ?? ?? 00 BE ?? ?? ?? 00
02 38 40 4E 75 FA 8B C2 8A 18 32 DF C0 CB

AcidCrypt
19
BE ?? ?? ?? ?? 02 38 40 4E 75 FA 8B C2 8A 18 32
DF C0 CB

ACProtect 1.09g -> Risco software Inc.
64
60 F9 50 E8 01 00 00 00 7C 58 58 49 50 E8 01 00
00 00 7E 58 58 79 04 66 B9 B8 72 E8 01 00 00 00
7A 83 C4 04 85 C8 EB 01 EB C1 F8 BE 72 03 73 01
74 0F 81 01 00 00 00 F9 EB 01 75 F9 E8 01 00 00

ACProtect 1.4x -> RISCO soft
85
47 65 74 50 72 6F 63 41 64 64 72 65 73 73 00 00
00 47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65
41 00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41
00 00 00 45 78 69 74 50 72 6F 63 65 73 73 00 00
00 4D 65 73 73 61 67 65 42 6F 78 41 00 90 4D 69
6E 65 49 6D 70

ACProtect v1.35 -> risco software Inc. & Anticrack Software
85
4B 45 52 4E 45 4C 33 32 2E 44 4C 4C 00 ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? 55 53 45 52 33 32 2E 44 4C 4C 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 47 65
74 50 72 6F 63

ACProtect V1.3X -> risco
9
60 50 E8 01 00 00 00 75 83

ACProtect v1.41
64
60 76 03 77 01 7B 74 03 75 01 78 47 87 EE E8 01
00 00 00 76 83 C4 04 85 EE EB 01 7F 85 F2 EB 01
79 0F 86 01 00 00 00 FC EB 01 78 79 02 87 F2 61
51 8F 05 19 38 01 01 60 EB 01 E9 E9 01 00 00 00

ACProtect V1.4X -> risco
12
60 E8 01 00 00 00 7C 83 04 24 06 C3

ACProtect v1.90g -> Risco software Inc.
20
60 0F 87 02 00 00 00 1B F8 E8 01 00 00 00 73 83
04 24 06 C3

ACProtect V2.0 -> risco
12
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? C3 C3

ACProtect/UltraProtect 1.0X-2.0X -> RiSco
229
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4B 45 52 4E 45 4C 33 32
2E 44 4C 4C 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 00 00 00 00 55 53 45 52 33 32 2E
44 4C 4C 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 47 65 74 50 72 6F 63 41 64 64
72 65 73 73 00 00 00 47 65 74 4D 6F 64 75 6C 65
48 61 6E 64 6C 65 41 00 00 00 4C 6F 61 64 4C 69
62 72 61 72 79 41 00 00 00 45 78 69 74 50 72 6F
63 65 73 73 00 00 00 4D 65 73 73 61 67 65 42 6F
78 41 00 90 4D 69 6E 65 49 6D 70 6F 72 74 5F 45
6E 64 73 73 00

ActiveMARK 5.x -> Trymedia Systems,Inc.
85
20 2D 2D 4D 50 52 4D 4D 47 56 41 2D 2D 00 75 73
65 72 33 32 2E 64 6C 6C 00 4D 65 73 73 61 67 65
42 6F 78 41 00 54 68 69 73 20 61 70 70 6C 69 63
61 74 69 6F 6E 20 63 61 6E 6E 6F 74 20 72 75 6E
20 77 69 74 68 20 61 6E 20 61 63 74 69 76 65 20
64 65 62 75 67

ActiveMARK[TM] R5.31.1140 -> Trymedia
16
79 11 7F AB 9A 4A 83 B5 C9 6B 1A 48 F9 27 B4 25

AdFlt2
18
68 00 01 9C 0F A0 0F A8 60 FD 6A 00 0F A1 BE ??
?? AD

Ady's Glue 1.10
15
2E ?? ?? ?? ?? 0E 1F BF ?? ?? 33 DB 33 C0 AC

Ady`s Glue v0.10
27
2E 8C 06 ?? ?? 0E 07 33 C0 8E D8 BE ?? ?? BF ??
?? FC B9 ?? ?? 56 F3 A5 1E 07 5F

AHPack 0.1 -> FEUERRADER
28
60 68 54 ?? ?? 00 B8 48 ?? ?? 00 FF 10 68 B3 ??
?? 00 50 B8 44 ?? ?? 00 FF 10 68 00

AHpack 0.1 -> FEUERRADER
85
60 68 54 ?? ?? ?? B8 48 ?? ?? ?? FF 10 68 B3 ??
?? ?? 50 B8 44 ?? ?? ?? FF 10 68 00 ?? ?? ?? 6A
40 FF D0 89 05 CA ?? ?? ?? 89 C7 BE 00 10 ?? ??
60 FC B2 80 31 DB A4 B3 02 E8 6D 00 00 00 73 F6
31 C9 E8 64 00 00 00 73 1C 31 C0 E8 5B 00 00 00
73 23 B3 02 41

AHTeam EP Protector 0.3 (fake ASPack 2.12) -> FEUERRADER
79
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8
01 00 00 00 EB 5D BB ED FF FF FF 03 DD 81 EB

AHTeam EP Protector 0.3 (fake ASProtect 1.0) -> FEUERRADER
73
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 60 E8 01 00 00 00 90 5D 81 ED 00 00 00 00
BB 00 00 00 00 03 DD 2B 9D

AHTeam EP Protector 0.3 (fake Borland Delphi 6.0-7.0) -> FEUERRADER
97
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 53 8B D8 33 C0 A3 00 00 00 00 6A 00 E8 00
00 00 FF A3 00 00 00 00 A1 00 00 00 00 A3 00 00
00 00 33 C0 A3 00 00 00 00 33 C0 A3 00 00 00 00
E8

AHTeam EP Protector 0.3 (fake k.kryptor 9/kryptor a) -> FEUERRADER
81
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 60 E8 ?? ?? ?? ?? 5E B9 00 00 00 00 2B C0
02 04 0E D3 C0 49 79 F8 41 8D 7E 2C 33 46 ?? 66
B9

AHTeam EP Protector 0.3 (fake Microsoft Visual C++ 7.0) -> FEUERRADER
101
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 6A 00 68 ?? ?? ?? ?? E8 ?? ?? ?? ?? BF ??
?? ?? ?? 8B C7 E8 ?? ?? ?? ?? 89 65 00 8B F4 89
3E 56 FF 15 ?? ?? ?? ?? 8B 4E ?? 89 0D ?? ?? ??
00 8B 46 00 A3

AHTeam EP Protector 0.3 (fake PCGuard 4.03-4.15) -> FEUERRADER
78
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 FC 55 50 E8 00 00 00 00 5D EB 01 E3 60 E8
03 00 00 00 D2 EB 0B 58 EB 01 48 40 EB 01

AHTeam EP Protector 0.3 (fake PE Lock NT 2.04) -> FEUERRADER
78
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 EB 03 CD 20 C7 1E EB 03 CD 20 EA 9C EB 02
EB 01 EB 01 EB 60 EB 03 CD 20 EB EB 01 EB

AHTeam EP Protector 0.3 (fake PE-Crypt 1.02) -> FEUERRADER
64
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 E8 00 00 00 00 5B 83 EB 05 EB 04 52 4E 44

AHTeam EP Protector 0.3 (fake PESHiELD 2.x) -> FEUERRADER
70
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 60 E8 00 00 00 00 41 4E 41 4B 49 4E 5D 83
ED 06 EB 02 EA 04

AHTeam EP Protector 0.3 (fake PEtite 2.2) -> FEUERRADER
78
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 B8 00 00 00 00 68 00 00 00 00 64 FF 35 00
00 00 00 64 89 25 00 00 00 00 66 9C 60 50

AHTeam EP Protector 0.3 (fake Spalsher 1.x-3.x) -> FEUERRADER
78
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 9C 60 8B 44 24 24 E8 00 00 00 00 5D 81 ED
00 00 00 00 50 E8 ED 02 00 00 8C C0 0F 84

AHTeam EP Protector 0.3 (fake Stone's PE Encryptor 2.0) -> FEUERRADER
94
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 53 51 52 56 57 55 E8 00 00 00 00 5D 81 ED
42 30 40 00 FF 95 32 35 40 00 B8 37 30 40 00 03
C5 2B 85 1B 34 40 00 89 85 27 34 40 00 83

AHTeam EP Protector 0.3 (fake SVKP 1.3x) -> FEUERRADER
119
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 60 E8 00 00 00 00 5D 81 ED 06 00 00 00 EB
05 B8 00 00 00 00 64 A0 23 00 00 00 EB 03 C7 84
E8 84 C0 EB 03 C7 84 E9 75 67 B9 49 00 00 00 8D
B5 C5 02 00 00 56 80 06 44 46 E2 FA 8B 8D C1 02
00 00 5E 55 51 6A 00

AHTeam EP Protector 0.3 (fake tElock 0.61) -> FEUERRADER
98
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 E9 00 00 00 00 60 E8 00 00 00 00 58 83 C0
08 F3 EB FF E0 83 C0 28 50 E8 00 00 00 00 5E B3
33 8D 46 0E 8D 76 31 28 18 F8 73 00 C3 8B FE B9
3C 02

AHTeam EP Protector 0.3 (fake VIRUS/I-Worm Hybris) -> FEUERRADER
82
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 EB 16 A8 54 00 00 47 41 42 4C 4B 43 47 43
00 00 00 00 00 00 52 49 53 00 FC 68 4C 70 40 00
FF 15

AHTeam EP Protector 0.3 (fake VOB ProtectCD) -> FEUERRADER
88
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 5F 81 EF 00 00 00 00 BE 00 00 40 00 8B 87
00 00 00 00 03 C6 57 56 8C A7 00 00 00 00 FF 10
89 87 00 00 00 00 5E 5F

AHTeam EP Protector 0.3 (fake Xtreme-Protector 1.05) -> FEUERRADER
75
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 E8 00 00 00 00 5D 81 00 00 00 00 00 6A 45
E8 A3 00 00 00 68 00 00 00 00 E8

AHTeam EP Protector 0.3 (fake ZCode 1.01) -> FEUERRADER
81
90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 90
FF E0 E9 12 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 E9 FB FF FF FF C3 68 00 00 00 00 64 FF
35

AI1 Creator 1 Beta 2 - by MZ
91
E8 FE FD FF FF 6A 00 E8 0D 00 00 00 CC FF 25 78
10 40 00 FF 25 7C 10 40 00 FF 25 80 10 40 00 FF
25 84 10 40 00 FF 25 88 10 40 00 FF 25 8C 10 40
00 FF 25 90 10 40 00 FF 25 94 10 40 00 FF 25 98
10 40 00 FF 25 9C 10 40 00 FF 25 A0 10 40 00 FF
25 A4 10 40 00 FF 25 AC 10 40 00

AINEXE v2.1
36
A1 ?? ?? 2D ?? ?? 8E D0 BC ?? ?? 8C D8 36 A3 ??
?? 05 ?? ?? 36 A3 ?? ?? 2E A1 ?? ?? 8A D4 B1 04
D2 EA FE C9

AINEXE v2.30
26
0E 07 B9 ?? ?? BE ?? ?? 33 FF FC F3 A4 A1 ?? ??
2D ?? ?? 8E D0 BC ?? ?? 8C D8

Alex Protector 1.0 beta 2 by Alex
85
60 E8 00 00 00 00 5D 81 ED 06 10 40 00 E8 24 00
00 00 EB 01 E9 8B 44 24 0C EB 03 EB 03 C7 EB FB
E8 01 00 00 00 A8 83 C4 04 83 80 B8 00 00 00 02
33 C0 EB 01 E9 C3 58 83 C4 04 EB 03 EB 03 C7 EB
FB E8 01 00 00 00 A8 83 C4 04 50 64 FF 35 00 00
00 00 64 89 25

Alex Protector v0.4 beta 1 by Alex
85
60 E8 01 00 00 00 C7 83 C4 04 33 C9 E8 01 00 00
00 68 83 C4 04 E8 01 00 00 00 68 83 C4 04 B9 ??
00 00 00 E8 01 00 00 00 68 83 C4 04 E8 00 00 00
00 E8 01 00 00 00 C7 83 C4 04 8B 2C 24 83 C4 04
E8 01 00 00 00 A9 83 C4 04 81 ED 3C 13 40 00 E8
01 00 00 00 68

Alex Protector v1.0 -> Alex
22
60 E8 00 00 00 00 5D 81 ED 06 10 40 00 E8 24 00
00 00 EB 01 E9 8B

Alloy 4.x -> PGWare LLC
85
9C 60 E8 02 00 00 00 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB 07 30 40 00 87 DD 6A 04 68 00
10 00 00 68 00 02 00 00 6A 00 FF 95 A8 33 40 00
0B C0 0F 84 F6 01 00 00 89 85 2E 33 40 00 83 BD
E8 32 40 00 01 74 0D 83 BD E4 32 40 00 01 74 2A
8B F8 EB 3E 68

Alloy v1.x.2000
49
9C 60 E8 02 ?? ?? ?? 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB 07 20 40 ?? 87 DD 6A 04 68 ??
10 ?? ?? 68 ?? 02 ?? ?? 6A ?? FF 95 46 23 40 ??
0B

Aluwain v8.09
8
8B EC 1E E8 ?? ?? 9D 5E

ANDpakk2 0.06 -> Dmitry Andreev
164
60 FC BE D4 00 40 00 BF 00 10 00 01 57 83 CD FF
33 C9 F9 EB 05 A4 02 DB 75 05 8A 1E 46 12 DB 72
F4 33 C0 40 02 DB 75 05 8A 1E 46 12 DB 13 C0 02
DB 75 05 8A 1E 46 12 DB 72 0E 48 02 DB 75 05 8A
1E 46 12 DB 13 C0 EB DC 83 E8 03 72 0F C1 E0 08
AC 83 F0 FF 74 4D D1 F8 8B E8 EB 09 02 DB 75 05
8A 1E 46 12 DB 13 C9 02 DB 75 05 8A 1E 46 12 DB
13 C9 75 1A 41 02 DB 75 05 8A 1E 46 12 DB 13 C9
02 DB 75 05 8A 1E 46 12 DB 73 EA 83 C1 02 81 FD
00 FB FF FF 83 D1 01 56 8D 34 2F F3 A4 5E E9 73
FF FF FF C3

ANDpakk2 0.18 - by Dmitry "AND" Andreev
163
FC BE D4 00 40 00 BF 00 ?? ?? 00 57 83 CD FF 33
C9 F9 EB 05 A4 02 DB 75 05 8A 1E 46 12 DB 72 F4
33 C0 40 02 DB 75 05 8A 1E 46 12 DB 13 C0 02 DB
75 05 8A 1E 46 12 DB 72 0E 48 02 DB 75 05 8A 1E
46 12 DB 13 C0 EB DC 83 E8 03 72 0F C1 E0 08 AC
83 F0 FF 74 4D D1 F8 8B E8 EB 09 02 DB 75 05 8A
1E 46 12 DB 13 C9 02 DB 75 05 8A 1E 46 12 DB 13
C9 75 1A 41 02 DB 75 05 8A 1E 46 12 DB 13 C9 02
DB 75 05 8A 1E 46 12 DB 73 EA 83 C1 02 81 FD 00
FB FF FF 83 D1 01 56 8D 34 2F F3 A4 5E E9 73 FF
FF FF C3

Anskya Binder v1.1 -> Anskya
19
BE ?? ?? ?? 00 BB F8 11 40 00 33 ED 83 EE 04 39
2E 74 11

Anskya NTPacker Generator -> Anskya
101
55 8B EC 83 C4 F0 53 B8 88 1D 00 10 E8 C7 FA FF
FF 6A 0A 68 20 1E 00 10 A1 14 31 00 10 50 E8 71
FB FF FF 8B D8 85 DB 74 2F 53 A1 14 31 00 10 50
E8 97 FB FF FF 85 C0 74 1F 53 A1 14 31 00 10 50
E8 5F FB FF FF 85 C0 74 0F 50 E8 5D FB FF FF 85
C0 74 05 E8 70 FC FF FF 5B E8 F2 F6 FF FF 00 00
48 45 41 52 54

Anslym Crypter
118
55 8B EC 83 C4 F0 53 56 B8 38 17 05 10 E8 5A 45
FB FF 33 C0 55 68 21 1C 05 10 64 FF 30 64 89 20
EB 08 FC FC FC FC FC FC 27 54 E8 85 4C FB FF 6A
00 E8 0E 47 FB FF 6A 0A E8 27 49 FB FF E8 EA 47
FB FF 6A 0A 68 30 1C 05 10 A1 60 56 05 10 50 E8
68 47 FB FF 8B D8 85 DB 0F 84 B6 02 00 00 53 A1
60 56 05 10 50 E8 F2 48 FB FF 8B F0 85 F6 0F 84
A0 02 00 00 E8 F3

Anslym FUD Crypter
68
55 8B EC 83 C4 F0 53 56 B8 38 17 05 10 E8 5A 45
FB FF 33 C0 55 68 21 1C 05 10 64 FF 30 64 89 20
EB 08 FC FC FC FC FC FC 27 54 E8 85 4C FB FF 6A
00 E8 0E 47 FB FF 6A 0A E8 27 49 FB FF E8 EA 47
FB FF 6A 0A

Anti007 V2.6 -> LiuXingPing
156
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 00 56 69 72 74 75 61 6C 50 72 6F 74 65 63
74 00 00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63
00 00 00 56 69 72 74 75 61 6C 46 72 65 65 00 00
00 47 65 74 53 79 73 74 65 6D 44 69 72 65 63 74
6F 72 79 41 00 00 00 43 72 65 61 74 65 46 69 6C
65 41 00 00 00 57 72 69 74 65 46 69 6C 65 00 00
00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 00 00 45
78 69 74 50 72 6F 63 65 73 73 00 00

Anticrack Software Protector v1.09 (ACProtect)
40
60 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? E8 01 00 00 00 ?? 83 04 24
06 C3 ?? ?? ?? ?? ?? 00

AntiDote 1.0 Beta -> SIS-Team
168
E8 BB FF FF FF 84 C0 74 2F 68 04 01 00 00 68 C0
23 60 00 6A 00 FF 15 08 10 60 00 E8 40 FF FF FF
50 68 78 11 60 00 68 68 11 60 00 68 C0 23 60 00
E8 AB FD FF FF 83 C4 10 33 C0 C2 10 00 90 90 90
8B 4C 24 08 56 8B 74 24 08 33 D2 8B C6 F7 F1 8B
C6 85 D2 74 08 33 D2 F7 F1 40 0F AF C1 5E C3 90
8B 44 24 04 53 55 56 8B 48 3C 57 03 C8 33 D2 8B
79 54 8B 71 38 8B C7 F7 F6 85 D2 74 0C 8B C7 33
D2 F7 F6 8B F8 47 0F AF FE 33 C0 33 DB 66 8B 41
14 8D 54 08 18 33 C0 66 8B 41 06 89 54 24 14 8D
68 FF 85 ED 7C 37 33 C0

AntiDote 1.0 Demo / 1.2 -> SIS-Team
228
00 00 00 00 09 01 47 65 74 43 6F 6D 6D 61 6E 64
4C 69 6E 65 41 00 DB 01 47 65 74 56 65 72 73 69
6F 6E 45 78 41 00 73 01 47 65 74 4D 6F 64 75 6C
65 46 69 6C 65 4E 61 6D 65 41 00 00 7A 03 57 61
69 74 46 6F 72 53 69 6E 67 6C 65 4F 62 6A 65 63
74 00 BF 02 52 65 73 75 6D 65 54 68 72 65 61 64
00 00 29 03 53 65 74 54 68 72 65 61 64 43 6F 6E
74 65 78 74 00 00 94 03 57 72 69 74 65 50 72 6F
63 65 73 73 4D 65 6D 6F 72 79 00 00 6B 03 56 69
72 74 75 61 6C 41 6C 6C 6F 63 45 78 00 00 A6 02
52 65 61 64 50 72 6F 63 65 73 73 4D 65 6D 6F 72
79 00 CA 01 47 65 74 54 68 72 65 61 64 43 6F 6E
74 65 78 74 00 00 62 00 43 72 65 61 74 65 50 72
6F 63 65 73 73 41 00 00 4B 45 52 4E 45 4C 33 32
2E 64 6C 6C

AntiDote 1.2 Beta (Demo) -> SIS-Team
183
68 69 D6 00 00 E8 C6 FD FF FF 68 69 D6 00 00 E8
BC FD FF FF 83 C4 08 E8 A4 FF FF FF 84 C0 74 2F
68 04 01 00 00 68 B0 21 60 00 6A 00 FF 15 08 10
60 00 E8 29 FF FF FF 50 68 88 10 60 00 68 78 10
60 00 68 B0 21 60 00 E8 A4 FD FF FF 83 C4 10 33
C0 C2 10 00 90 90 90 90 90 90 90 90 90 90 90 90
8B 4C 24 08 56 8B 74 24 08 33 D2 8B C6 F7 F1 8B
C6 85 D2 74 08 33 D2 F7 F1 40 0F AF C1 5E C3 90
8B 44 24 04 53 55 56 8B 48 3C 57 03 C8 33 D2 8B
79 54 8B 71 38 8B C7 F7 F6 85 D2 74 0C 8B C7 33
D2 F7 F6 8B F8 47 0F AF FE 33 C0 33 DB 66 8B 41
14 8D 54 08 18 33 C0

AntiDote 1.2.Demo -> SIS-Team
97
E8 F7 FE FF FF 05 CB 22 00 00 FF E0 E8 EB FE FF
FF 05 BB 19 00 00 FF E0 E8 BD 00 00 00 08 B2 62
00 01 52 17 0C 0F 2C 2B 20 7F 52 79 01 30 07 17
29 4F 01 3C 30 2B 5A 3D C7 26 11 26 06 59 0E 78
2E 10 14 0B 13 1A 1A 3F 64 1D 71 33 57 21 09 24
8B 1B 09 37 08 61 0F 1D 1D 2A 01 87 35 4C 07 39
0B

AntiDote 1.2.DLL.Demo -> SIS-Team
242
EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90 E9 08 32
90 90 90 90 90 90 90 90 90 90 80 7C 24 08 01 0F
85 ?? ?? ?? ?? 60 BE ?? ?? ?? ?? 8D BE ?? ?? ??
?? 57 83 CD FF EB 0B 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
EF 75 09 8B 1E 83 EE FC 11 DB 73 E4 31 C9 83 E8
03 72 0D C1 E0 08 8A 06 46 83 F0 FF 74 74 89 C5
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C9 01 DB 75
07 8B 1E 83 EE FC 11 DB 11 C9 75 20 41 01 DB 75
07 8B 1E 83 EE FC 11 DB 11 C9 01 DB 73 EF 75 09
8B 1E 83 EE FC 11 DB 73 E4 83 C1 02 81 FD 00 F3
FF FF 83 D1 01 8D 14 2F 83 FD FC 76 0F 8A 02 42
88 07 47 49 75 F7 E9 63 FF FF FF 90 8B 02 83 C2
04 89 07 83 C7 04 83 E9 04 77 F1 01 CF E9 4C FF
FF FF

AntiDote 1.2/1.4 SE DLL -> SIS-Team
106
EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90 E9 08 32
90 90 90 90 90 90 90 90 90 90 80 7C 24 08 01 0F
85 ?? ?? ?? ?? 60 BE ?? ?? ?? ?? 8D BE ?? ?? ??
?? 57 83 CD FF EB 0B 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
?? 75 ?? 8B 1E 83 EE FC 11 DB

AntiDote 1.4 SE -> SIS-Team
191
68 90 03 00 00 E8 C6 FD FF FF 68 90 03 00 00 E8
BC FD FF FF 68 90 03 00 00 E8 B2 FD FF FF 50 E8
AC FD FF FF 50 E8 A6 FD FF FF 68 69 D6 00 00 E8
9C FD FF FF 50 E8 96 FD FF FF 50 E8 90 FD FF FF
83 C4 20 E8 78 FF FF FF 84 C0 74 4F 68 04 01 00
00 68 10 22 60 00 6A 00 FF 15 08 10 60 00 68 90
03 00 00 E8 68 FD FF FF 68 69 D6 00 00 E8 5E FD
FF FF 50 E8 58 FD FF FF 50 E8 52 FD FF FF E8 DD
FE FF FF 50 68 A4 10 60 00 68 94 10 60 00 68 10
22 60 00 E8 58 FD FF FF 83 C4 20 33 C0 C2 10 00
8B 4C 24 08 56 8B 74 24 08 33 D2 8B C6 F7 F1 8B
C6 85 D2 74 08 33 D2 F7 F1 40 0F AF C1 5E C3

AntiVirus Vaccine v.1.03
18
FA 33 DB B9 ?? ?? 0E 1F 33 F6 FC AD 35 ?? ?? 03
D8 E2

aPack v0.62
19
1E 06 8C C8 8E D8 ?? ?? ?? 8E C0 50 BE ?? ?? 33
FF FC B6

aPack v0.82
24
1E 06 8C CB BA ?? ?? 03 DA 8D ?? ?? ?? FC 33 F6
33 FF 48 4B 8E C0 8E DB

aPack v0.98 -m
33
1E 06 8C C8 8E D8 05 ?? ?? 8E C0 50 BE ?? ?? 33
FF FC B2 ?? BD ?? ?? 33 C9 50 A4 BB ?? ?? 3B F3
76

aPack v0.98b (DS&ES not saved)
28
8C CB BA ?? ?? 03 DA FC 33 F6 33 FF 4B 8E DB 8D
?? ?? ?? 8E C0 B9 ?? ?? F3 A5 4A 75

aPack v0.98b -> Jibz
12
93 07 1F 05 ?? ?? 8E D0 BC ?? ?? EA

APatch GUI v1.1
8
52 31 C0 E8 FF FF FF FF

Apex 3.0 alpha -> 500mhz
34
5F B9 14 00 00 00 51 BE 00 10 40 00 B9 00 ?? ??
00 8A 07 30 06 46 E2 FB 47 59 E2 EA 68 ?? ?? ??
00 C3

APEX_C (BLT Apex 4.0) -> 500mhz
34
68 ?? ?? ?? ?? B9 FF FF FF 00 01 D0 F7 E2 72 01
48 E2 F7 B9 FF 00 00 00 8B 34 24 80 36 FD 46 E2
FA C3

Apex_c beta -> 500mhz
85
68 ?? ?? ?? ?? B9 FF FF FF 00 01 D0 F7 E2 72 01
48 E2 F7 B9 FF 00 00 00 8B 34 24 80 36 FD 46 E2
FA C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

App Encryptor -> Silent Team
27
60 E8 00 00 00 00 5D 81 ED 1F 1F 40 00 B9 7B 09
00 00 8D BD 67 1F 40 00 8B F7 AC

App Protector -> Silent Team
85
E9 97 00 00 00 0D 0A 53 69 6C 65 6E 74 20 54 65
61 6D 20 41 70 70 20 50 72 6F 74 65 63 74 6F 72
0D 0A 43 72 65 61 74 65 64 20 62 79 20 53 69 6C
65 6E 74 20 53 6F 66 74 77 61 72 65 0D 0A 54 68
65 6E 6B 7A 20 74 6F 20 44 6F 63 68 74 6F 72 20
58 0D 0A 0D 0A

ARC-SFX Archive
39
8C C8 8C DB 8E D8 8E C0 89 ?? ?? ?? 2B C3 A3 ??
?? 89 ?? ?? ?? BE ?? ?? B9 ?? ?? BF ?? ?? BA ??
?? FC AC 32 C2 8A D8

ARM Protector 0.1 - by SMoKE
171
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D EB 01 00 81 ED
5E 1F 40 00 EB 02 83 09 8D B5 EF 1F 40 00 EB 02
83 09 BA A3 11 00 00 EB 01 00 8D 8D 92 31 40 00
8B 09 E8 14 00 00 00 83 EB 01 00 8B FE E8 00 00
00 00 58 83 C0 07 50 C3 00 EB 04 58 40 50 C3 8A
06 46 EB 01 00 D0 C8 E8 14 00 00 00 83 EB 01 00
2A C2 E8 00 00 00 00 5B 83 C3 07 53 C3 00 EB 04
5B 43 53 C3 EB 01 00 32 C2 E8 0B 00 00 00 00 32
C1 EB 01 00 C0 C0 02 EB 09 2A C2 5B EB 01 00 43
53 C3 88 07 EB 01 00 47 4A 75 B4

ARM Protector 0.3 - by SMoKE
171
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D EB 01 00 81 ED
13 24 40 00 EB 02 83 09 8D B5 A4 24 40 00 EB 02
83 09 BA 4B 15 00 00 EB 01 00 8D 8D EF 39 40 00
8B 09 E8 14 00 00 00 83 EB 01 00 8B FE E8 00 00
00 00 58 83 C0 07 50 C3 00 EB 04 58 40 50 C3 8A
06 46 EB 01 00 D0 C8 E8 14 00 00 00 83 EB 01 00
2A C2 E8 00 00 00 00 5B 83 C3 07 53 C3 00 EB 04
5B 43 53 C3 EB 01 00 32 C2 E8 0B 00 00 00 00 32
C1 EB 01 00 C0 C0 02 EB 09 2A C2 5B EB 01 00 43
53 C3 88 07 EB 01 00 47 4A 75 B4

ARM Protector v0.1 by SMoKE
85
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D EB 01 00 81 ED
5E 1F 40 00 EB 02 83 09 8D B5 EF 1F 40 00 EB 02
83 09 BA A3 11 00 00 EB 01 00 8D 8D 92 31 40 00
8B 09 E8 14 00 00 00 83 EB 01 00 8B FE E8 00 00
00 00 58 83 C0

ARM Protector v0.2-> SMoKE
64
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D EB 01 00 81 ED
09 20 40 00 EB 02 83 09 8D B5 9A 20 40 00 EB 02
83 09 BA 0B 12 00 00 EB 01 00 8D 8D A5 32 40 00

Armadillo 3.00a -> Silicon Realms Toolworks
85
60 E8 00 00 00 00 5D 50 51 EB 0F ?? EB 0F ?? EB
07 ?? EB 0F ?? EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC ?? 59 58 50 51 EB 0F
?? EB 0F ?? EB 07 ?? EB 0F ?? EB 08 FD EB 0B F2
EB F5 EB F6 F2 EB 08 FD EB E9 F3 EB E4 FC ?? 59
58 50 51 EB 0F

Armadillo 3.X-5.X -> Silicon Realms Toolworks
175
60 E8 00 00 00 00 5D 50 51 0F CA F7 D2 9C F7 D2
0F CA EB 0F B9 EB 0F B8 EB 07 B9 EB 0F 90 EB 08
FD EB 0B F2 EB F5 EB F6 F2 EB 08 FD EB E9 F3 EB
E4 FC E9 9D 0F C9 8B CA F7 D1 59 58 50 51 0F CA
F7 D2 9C F7 D2 0F CA EB 0F B9 EB 0F B8 EB 07 B9
EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2 EB 08
FD EB E9 F3 EB E4 FC E9 9D 0F C9 8B CA F7 D1 59
58 50 51 0F CA F7 D2 9C F7 D2 0F CA EB 0F B9 EB
0F B8 EB 07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5
EB F6 F2 EB 08 FD EB E9 F3 EB E4 FC E9 9D 0F C9
8B CA F7 D1 59 58 60 33 C9 75 02 EB 15 EB 33

Armadillo 4.30a -> Silicon Realms Toolworks
85
44 64 65 44 61 74 61 20 69 6E 69 74 69 61 6C 69
7A 65 64 20 28 41 4E 53 49 29 2C 20 61 70 70 20
73 74 72 69 6E 67 73 20 61 72 65 20 27 25 73 27
20 61 6E 64 20 27 25 73 27 00 00 00 44 64 65 44
61 74 61 20 69 6E 69 74 69 61 6C 69 7A 65 64 20
28 55 4E 49 43

Armadillo 4.40 -> Silicon Realms Toolworks
85
31 2E 31 2E 34 00 00 00 C2 E0 94 BE 93 FC DE C6
B6 24 83 F7 D2 A4 92 77 40 27 CF EB D8 6F 50 B4
B5 29 24 FA 45 08 04 52 D5 1B D2 8C 8A 1E 6E FF
8C 5F 42 89 F1 83 B1 27 C5 69 57 FC 55 0A DD 44
BE 2A 02 97 6B 65 15 AA 31 E9 28 7D 49 1B DF B5
5D 08 A8 BA A8

Armadillo 5.0 Dll -> Silicon Realms Toolworks
294
83 7C 24 08 01 75 05 E8 DE 4B 00 00 FF 74 24 04
8B 4C 24 10 8B 54 24 0C E8 ED FE FF FF 59 C2 0C
00 6A 0C 68 ?? ?? ?? ?? E8 E5 24 00 00 8B 4D 08
33 FF 3B CF 76 2E 6A E0 58 33 D2 F7 F1 3B 45 0C
1B C0 40 75 1F E8 8F 15 00 00 C7 00 0C 00 00 00
57 57 57 57 57 E8 20 15 00 00 83 C4 14 33 C0 E9
D5 00 00 00 0F AF 4D 0C 8B F1 89 75 08 3B F7 75
03 33 F6 46 33 DB 89 5D E4 83 FE E0 77 69 83 3D
?? ?? ?? ?? 03 75 4B 83 C6 0F 83 E6 F0 89 75 0C
8B 45 08 3B 05 ?? ?? ?? ?? 77 37 6A 04 E8 D7 23
00 00 59 89 7D FC FF 75 08 E8 EC 53 00 00 59 89
45 E4 C7 45 FC FE FF FF FF E8 5F 00 00 00 8B 5D
E4 3B DF 74 11 FF 75 08 57 53 E8 2B C5 FF FF 83
C4 0C 3B DF 75 61 56 6A 08 FF 35 ?? ?? ?? ?? FF
15 ?? ?? ?? ?? 8B D8 3B DF 75 4C 39 3D ?? ?? ??
?? 74 33 56 E8 19 ED FF FF 59 85 C0 0F 85 72 FF
FF FF 8B 45 10 3B C7 0F 84 50 FF FF FF C7 00 0C
00 00 00 E9 45 FF FF FF 33 FF 8B 75 0C 6A 04 E8
7D 22 00 00 59 C3

Armadillo 5.00 -> Silicon Realms Toolworks
271
E8 E3 40 00 00 E9 16 FE FF FF 6A 0C 68 ?? ?? ??
?? E8 44 15 00 00 8B 4D 08 33 FF 3B CF 76 2E 6A
E0 58 33 D2 F7 F1 3B 45 0C 1B C0 40 75 1F E8 36
13 00 00 C7 00 0C 00 00 00 57 57 57 57 57 E8 C7
12 00 00 83 C4 14 33 C0 E9 D5 00 00 00 0F AF 4D
0C 8B F1 89 75 08 3B F7 75 03 33 F6 46 33 DB 89
5D E4 83 FE E0 77 69 83 3D ?? ?? ?? ?? 03 75 4B
83 C6 0F 83 E6 F0 89 75 0C 8B 45 08 3B 05 ?? ??
?? ?? 77 37 6A 04 E8 48 11 00 00 59 89 7D FC FF
75 08 E8 01 49 00 00 59 89 45 E4 C7 45 FC FE FF
FF FF E8 5F 00 00 00 8B 5D E4 3B DF 74 11 FF 75
08 57 53 E8 66 D3 FF FF 83 C4 0C 3B DF 75 61 56
6A 08 FF 35 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 8B D8
3B DF 75 4C 39 3D ?? ?? ?? ?? 74 33 56 E8 AF F9
FF FF 59 85 C0 0F 85 72 FF FF FF 8B 45 10 3B C7
0F 84 50 FF FF FF C7 00 0C 00 00 00 E9 45 FF FF
FF 33 FF 8B 75 0C 6A 04 E8 EE 0F 00 00 59 C3

Armadillo v1.60a
32
55 8B EC 6A FF 68 98 71 40 00 68 48 2D 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.72 - v1.73
32
55 8B EC 6A FF 68 E8 C1 ?? ?? 68 F4 86 ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58

Armadillo v1.77
32
55 8B EC 6A FF 68 B0 71 40 00 68 6C 37 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.80
32
55 8B EC 6A FF 68 E8 C1 00 00 68 F4 86 00 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.82
32
55 8B EC 6A FF 68 E0 C1 40 00 68 74 81 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.83
32
55 8B EC 6A FF 68 E0 C1 40 00 68 64 84 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.84
32
55 8B EC 6A FF 68 E8 C1 40 00 68 F4 86 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90
32
55 8B EC 6A FF 68 10 F2 40 00 68 64 9A 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90a
32
55 8B EC 64 FF 68 10 F2 40 00 68 14 9B 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90b1
32
55 8B EC 6A FF 68 E0 C1 40 00 68 04 89 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90b2
32
55 8B EC 6A FF 68 F0 C1 40 00 68 A4 89 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90b3
32
55 8B EC 6A FF 68 08 E2 40 00 68 94 95 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90b4
32
55 8B EC 6A FF 68 08 E2 40 00 68 B4 96 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.90c
32
55 8B EC 6A FF 68 10 F2 40 00 68 74 9D 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v1.9x
40
55 8B EC 6A FF 68 98 ?? ?? ?? 68 10 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15

Armadillo v2.00
32
55 8B EC 6A FF 68 00 02 41 00 68 C4 A0 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.00b2-2.00b3
32
55 8B EC 6A FF 68 00 F2 40 00 68 C4 A0 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.01
32
55 8B EC 6A FF 68 08 02 41 00 68 04 9A 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.10b2
32
55 8B EC 6A FF 68 18 12 41 00 68 24 A0 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.20
32
55 8B EC 6A FF 68 10 12 41 00 68 F4 A0 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.20b1
32
55 8B EC 6A FF 68 30 12 41 00 68 A4 A5 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58

Armadillo v2.50
51
55 8B EC 6A FF 68 B8 ?? ?? ?? 68 F8 ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 20 ?? ?? ?? 33 D2 8A D4
89 15 D0

Armadillo v2.50b3
51
55 8B EC 6A FF 68 B8 ?? ?? ?? 68 F8 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 20 ?? ?? ?? 33 D2 8A D4
89 15 D0

Armadillo v2.51
41
55 8B EC 6A FF 68 B8 ?? ?? ?? 68 D0 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 20

Armadillo v2.52
46
55 8B EC 6A FF 68 ?? ?? ?? ?? E0 ?? ?? ?? ?? 68
D4 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83
EC 58 53 56 57 89 65 E8 FF ?? ?? ?? 15 38

Armadillo v2.52
41
55 8B EC 6A FF 68 E0 ?? ?? ?? 68 D4 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 38

Armadillo v2.52 beta2
46
55 8B EC 6A FF 68 ?? ?? ?? ?? B0 ?? ?? ?? ?? 68
60 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83
EC 58 53 56 57 89 65 E8 FF ?? ?? ?? 15 24

Armadillo v2.52b2
41
55 8B EC 6A FF 68 B0 ?? ?? ?? 68 60 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 24

Armadillo v2.53
51
55 8B EC 6A FF 68 40 ?? ?? ?? 68 54 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 58 ?? ?? ?? 33 D2 8A D4
89 15 EC

Armadillo v2.53
51
55 8B EC 6A FF 68 ?? ?? ?? ?? 40 ?? ?? ?? ?? 68
54 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83
EC 58 53 56 57 89 65 E8 FF ?? ?? ?? 15 58 33 D2
8A D4 89

Armadillo v2.53b3
40
55 8B EC 6A FF 68 D8 ?? ?? ?? 68 14 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15

Armadillo v2.5x - v2.6x
51
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 58 ?? ?? ?? 33 D2 8A D4
89 15 EC

Armadillo v2.60
51
55 8B EC 6A FF 68 D0 ?? ?? ?? 68 34 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 68 ?? ?? ?? 33 D2 8A D4
89 15 84

Armadillo v2.60a
51
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 94 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 6C ?? ?? ?? 33 D2 8A D4
89 15 B4

Armadillo v2.60b1
51
55 8B EC 6A FF 68 50 ?? ?? ?? 68 74 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 58 ?? ?? ?? 33 D2 8A D4
89 15 FC

Armadillo v2.60b2
51
55 8B EC 6A FF 68 90 ?? ?? ?? 68 24 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 60 ?? ?? ?? 33 D2 8A D4
89 15 3C

Armadillo v2.60c
51
55 8B EC 6A FF 68 40 ?? ?? ?? 68 F4 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 6C ?? ?? ?? 33 D2 8A D4
89 15 F4

Armadillo v2.61
51
55 8B EC 6A FF 68 28 ?? ?? ?? 68 E4 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 6C ?? ?? ?? 33 D2 8A D4
89 15 0C

Armadillo v2.65b1
51
55 8B EC 6A FF 68 38 ?? ?? ?? 68 40 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 28 ?? ?? ?? 33 D2 8A D4
89 15 F4

Armadillo v2.75a
51
55 8B EC 6A FF 68 68 ?? ?? ?? 68 D0 ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 28 ?? ?? ?? 33 D2 8A D4
89 15 24

Armadillo v2.85
51
55 8B EC 6A FF 68 68 ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 28 ?? ?? ?? 33 D2 8A D4
89 15 24

Armadillo v2.xx (CopyMem II)
60
6A ?? 8B B5 ?? ?? ?? ?? C1 E6 04 8B 85 ?? ?? ??
?? 25 07 ?? ?? 80 79 05 48 83 C8 F8 40 33 C9 8A
88 ?? ?? ?? ?? 8B 95 ?? ?? ?? ?? 81 E2 07 ?? ??
80 79 05 4A 83 CA F8 42 33 C0 8A 82

Armadillo v3.00
47
60 E8 ?? ?? ?? ?? 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58 60 33 C9

Armadillo v3.00a
47
60 E8 ?? ?? ?? ?? 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58 50 51 EB

Armadillo v3.01, v3.05
85
60 E8 00 00 00 00 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58 50 51 EB 0F
B9 EB 0F B8 EB 07 B9 EB 0F 90 EB 08 FD EB 0B F2
EB F5 EB F6 F2 EB 08 FD EB E9 F3 EB E4 FC E9 59
58 50 51 EB 0F

Armadillo v3.10
85
55 8B EC 6A FF 68 E0 97 44 00 68 20 C0 42 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 4C 41 44 00 33 D2 8A D4
89 15 90 A1 44 00 8B C8 81 E1 FF 00 00 00 89 0D
8C A1 44 00 C1 E1 08 03 CA 89 0D 88 A1 44 00 C1
E8 10 A3 84 A1

Armadillo v3.xx
44
60 E8 ?? ?? ?? ?? 5D 50 51 EB 0F B9 EB 0F B8 EB
07 B9 EB 0F 90 EB 08 FD EB 0B F2 EB F5 EB F6 F2
EB 08 FD EB E9 F3 EB E4 FC E9 59 58

Armadillo v4.00.0053 -> Silicon Realms Toolworks
85
55 8B EC 6A FF 68 20 8B 4B 00 68 80 E4 48 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 88 31 4B 00 33 D2 8A D4
89 15 A4 A1 4B 00 8B C8 81 E1 FF 00 00 00 89 0D
A0 A1 4B 00 C1 E1 08 03 CA 89 0D 9C A1 4B 00 C1
E8 10 A3 98 A1

Armadillo v4.10 -> Silicon Realms Toolworks
85
55 8B EC 6A FF 68 F8 8E 4C 00 68 D0 EA 49 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 88 31 4C 00 33 D2 8A D4
89 15 7C A5 4C 00 8B C8 81 E1 FF 00 00 00 89 0D
78 A5 4C 00 C1 E1 08 03 CA 89 0D 74 A5 4C 00 C1
E8 10 A3 70 A5

Armadillo v4.20 -> Silicon Realms Toolworks
85
55 8B EC 6A FF 68 F8 8E 4C 00 68 F0 EA 49 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 88 31 4C 00 33 D2 8A D4
89 15 84 A5 4C 00 8B C8 81 E1 FF 00 00 00 89 0D
80 A5 4C 00 C1 E1 08 03 CA 89 0D 7C A5 4C 00 C1
E8 10 A3 78 A5

Armadillo v4.30 - v4.40 -> Silicon Realms Toolworks
84
55 8B EC 6A FF 68 40 ?? ?? 00 68 80 ?? ?? 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 88 ?? ?? 00 33 D2 8A D4
89 15 30 ?? ?? 00 8B C8 81 E1 FF 00 00 00 89 0D
2C ?? ?? 00 C1 E1 08 03 CA 89 0D 28 ?? ?? 00 C1
E8 10 A3 24

Armadillo v4.30 - v4.40 -> Silicon Realms Toolworks
85
60 E8 00 00 00 00 5D 50 51 0F CA F7 D2 9C F7 D2
0F CA EB 0F B9 EB 0F B8 EB 07 B9 EB 0F 90 EB 08
FD EB 0B F2 EB F5 EB F6 F2 EB 08 FD EB E9 F3 EB
E4 FC E9 9D 0F C9 8B CA F7 D1 59 58 50 51 0F CA
F7 D2 9C F7 D2 0F CA EB 0F B9 EB 0F B8 EB 07 B9
EB 0F 90 EB 08

AsCrypt v0.1 -> SToRM - #1
21
81 ?? ?? ?? ?? ?? ?? 83 ?? ?? ?? ?? ?? ?? ?? 83
?? ?? E2 ?? EB

AsCrypt v0.1 -> SToRM - #2
16
80 ?? ?? ?? 83 ?? ?? ?? ?? 90 90 90 83 ?? ?? E2

AsCrypt v0.1 -> SToRM - #3
24
80 ?? ?? ?? 83 ?? ?? ?? ?? 90 90 90 51 ?? ?? ??
01 00 00 00 83 ?? ?? E2

AsCrypt v0.1 -> SToRM - #4
13
80 ?? ?? ?? 83 ?? ?? ?? ?? 90 90 90 E2

AsCrypt v0.1 -> SToRM - #5
9
83 ?? ?? E2 ?? ?? E2 ?? FF

ASDPack 2.0 -> asd
88
00 00 00 00 ?? ?? ?? ?? 00 00 00 00 00 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C 6C
00 8D 49 00 1F 01 47 65 74 4D 6F 64 75 6C 65 48
61 6E 64 6C 65 41 00 90

ASDPack 2.0 -> asd
16
5B 43 83 7B 74 00 0F 84 08 00 00 00 89 43 14 E9

ASDPack 2.0 -> asd
30
8B 44 24 04 56 57 53 E8 CD 01 00 00 C3 00 00 00
00 00 00 00 00 00 00 00 00 00 10 00 00 00

ASDPack v1.0 -> asd
500
55 8B EC 56 53 E8 5C 01 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 10 00 00 ?? ?? ?? 00 00 00
00 00 00 00 40 00 00 ?? ?? 00 00 00 00 00 00 00
00 00 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00
00 00 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 ??
?? 00 00 10 00 00 00 ?? 00 00 00 ?? ?? 00 00 ??
?? 00 00 ?? ?? 00 00 ?? 00 00 00 ?? ?? 00 00 ??
00 00 00 ?? ?? 00 00 ?? 00 00 00 ?? ?? 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 5B 81 EB E6 1D 40 00 83 7D 0C
01 75 11 55 E8 4F 01 00 00 E8 6A 01 00 00 5D E8
2C 00 00 00 8B B3 1A 1E 40 00 03 B3 FA 1D 40 00
8B 76 0C AD 0B C0 74 0D FF 75 10 FF 75 0C FF 75
08 FF D0 EB EE B8 01 00 00 00 5B 5E C9 C2 0C 00
55 6A 00 FF 93 20 21 40 00 89 83 FA 1D 40 00 6A
40 68 00 10 00 00 FF B3 02 1E 40 00 6A 00 FF 93
2C 21 40 00 89 83 06 1E 40 00 8B 83 F2 1D 40 00
03 83 FA 1D 40 00 50 FF B3 06 1E 40 00 50 E8 6D
01 00 00 5F

ASPack v1.00b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED 92 1A 44 ?? B8 8C 1A
44 ?? 03 C5 2B 85 CD 1D 44 ?? 89 85 D9 1D 44 ??
80 BD C4 1D 44

ASPack v1.01b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED D2 2A 44 ?? B8 CC 2A
44 ?? 03 C5 2B 85 A5 2E 44 ?? 89 85 B1 2E 44 ??
80 BD 9C 2E 44

ASPack v1.02a -> Alexey Solodovnikov
80
60 E8 ?? ?? ?? ?? 5D 81 ED 3E D9 43 ?? B8 38 ??
?? ?? 03 C5 2B 85 0B DE 43 ?? 89 85 17 DE 43 ??
80 BD 01 DE 43 ?? ?? 75 15 FE 85 01 DE 43 ?? E8
1D ?? ?? ?? E8 79 02 ?? ?? E8 12 03 ?? ?? 8B 85
03 DE 43 ?? 03 85 17 DE 43 ?? 89 44 24 1C 61 FF

ASPack v1.02b -> Alexey Solodovnikov
20
60 E8 00 00 00 00 5D 81 ED 96 78 43 00 B8 90 78
43 00 03 C5

ASPack v1.02b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED 96 78 43 ?? B8 90 78
43 ?? 03 C5 2B 85 7D 7C 43 ?? 89 85 89 7C 43 ??
80 BD 74 7C 43

ASPack v1.03b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED AE 98 43 ?? B8 A8 98
43 ?? 03 C5 2B 85 18 9D 43 ?? 89 85 24 9D 43 ??
80 BD 0E 9D 43

ASPack v1.04b -> Alexey Solodovnikov
36
60 E8 ?? ?? ?? ?? 5D 81 ED ?? ?? ?? ?? B8 ?? ??
?? ?? 03 C5 2B 85 ?? 12 9D ?? 89 85 1E 9D ?? ??
80 BD 08 9D

ASPack v1.05b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED CE 3A 44 ?? B8 C8 3A
44 ?? 03 C5 2B 85 B5 3E 44 ?? 89 85 C1 3E 44 ??
80 BD AC 3E 44

ASPack v1.061b -> Alexey Solodovnikov
37
60 E8 ?? ?? ?? ?? 5D 81 ED EA A8 43 ?? B8 E4 A8
43 ?? 03 C5 2B 85 78 AD 43 ?? 89 85 84 AD 43 ??
80 BD 6E AD 43

ASPack v1.07b (DLL) -> Alexey Solodovnikov
20
60 E8 00 00 00 00 5D ?? ?? ?? ?? ?? ?? B8 ?? ??
?? ?? 03 C5

ASPack v1.07b -> Alexey Solodovnikov
36
60 E8 ?? ?? ?? ?? 5D 81 ED ?? ?? ?? ?? B8 ?? ??
?? ?? 03 C5 2B 85 ?? 0B DE ?? 89 85 17 DE ?? ??
80 BD 01 DE

ASPack v1.08.01 -> Alexey Solodovnikov
34
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ?? ?? ?? 44 00 BB 10 ?? 44 00 03 DD
2B 9D

ASPack v1.08.01 -> Alexey Solodovnikov
34
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ?? ?? ?? 44 ?? BB 10 ?? 44 ?? 03 DD
2B 9D

ASPack v1.08.01 -> Alexey Solodovnikov
13
60 EB ?? 5D EB ?? FF ?? ?? ?? ?? ?? E9

ASPack v1.08.02 -> Alexey Solodovnikov
35
60 EB 0A 5D EB 02 FF 25 45 FF E5 E8 E9 E8 F1 FF
FF FF E9 81 ED 23 6A 44 00 BB 10 ?? 44 00 03 DD
2B 9D 72

ASPack v1.08.03 -> Alexey Solodovnikov
20
60 E8 00 00 00 00 5D 81 ED 0A 4A 44 00 BB 04 4A
44 00 03 DD

ASPack v1.08.03 -> Alexey Solodovnikov
37
60 E8 00 00 00 00 5D 81 ED 0A 4A 44 00 BB 04 4A
44 00 03 DD 2B 9D B1 50 44 00 83 BD AC 50 44 00
00 89 9D BB 4E

ASPack v1.08.03 -> Alexey Solodovnikov
20
60 E8 00 00 00 00 5D ?? ?? ?? ?? ?? ?? BB ?? ??
?? ?? 03 DD

ASPack v1.08.03 -> Alexey Solodovnikov
37
60 E8 00 00 00 00 5D ?? ?? ?? ?? ?? ?? BB ?? ??
?? ?? 03 DD 2B 9D B1 50 44 00 83 BD AC 50 44 00
00 89 9D BB 4E

ASPack v1.08.04 -> Alexey Solodovnikov
8
60 E8 41 06 00 00 EB 41

ASPack v1.08.x -> Alexey Solodovnikov
27
60 EB 03 5D FF E5 E8 F8 FF FF FF 81 ED 1B 6A 44
00 BB 10 6A 44 00 03 DD 2B 9D 2A

ASPack v2.000 -> Alexey Solodovnikov
8
60 E8 70 05 00 00 EB 4C

ASPack v2.001 -> Alexey Solodovnikov
8
60 E8 72 05 00 00 EB 4C

ASPack v2.1 -> Alexey Solodovnikov
12
60 E8 72 05 00 00 EB 33 87 DB 90 00

ASPack v2.11b -> Alexey Solodovnikov
22
60 E8 02 00 00 00 EB 09 5D 55 81 ED 39 39 44 00
C3 E9 3D 04 00 00

ASPack v2.11c -> Alexey Solodovnikov
22
60 E8 02 00 00 00 EB 09 5D 55 81 ED 39 39 44 00
C3 E9 59 04 00 00

ASPack v2.11d -> Alexey Solodovnikov
10
60 E8 02 00 00 00 EB 09 5D 55

ASPack v2.12 -> Alexey Solodovnikov
15
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01

ASPack v2.12 -> Alexey Solodovnikov
29
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB

ASPack v2.xx -> Alexey Solodovnikov
37
A8 03 00 00 61 75 08 B8 01 00 00 00 C2 0C 00 68
00 00 00 00 C3 8B 85 26 04 00 00 8D 8D 3B 04 00
00 51 50 FF 95

ASPack v2.xx -> Alexey Solodovnikov
37
A8 03 ?? ?? 61 75 08 B8 01 ?? ?? ?? C2 0C ?? 68
?? ?? ?? ?? C3 8B 85 26 04 ?? ?? 8D 8D 3B 04 ??
?? 51 50 FF 95

ASPR Stripper v2.x unpacked
31
BB ?? ?? ?? ?? E9 ?? ?? ?? ?? 60 9C FC BF ?? ??
?? ?? B9 ?? ?? ?? ?? F3 AA 9D 61 C3 55 8B EC

ASProtect 1.33 - 2.1 Registered -> Alexey Solodovnikov
12
68 01 ?? ?? ?? E8 01 00 00 00 C3 C3

ASProtect SKE 2.1x (dll) -> Alexey Solodovnikov
85
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB 00 ?? ??
?? 80 7D 4D 01 75 0C 8B 74 24 28 83 FE 01 89 5D
4E 75 31 8D 45 53 50 53 FF B5 ED 09 00 00 8D 45
35 50 E9 82 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

ASProtect SKE 2.1x (exe) -> Alexey Solodovnikov
85
90 60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01
00 00 00 EB 5D BB ED FF FF FF 03 DD 81 EB 00 ??
?? ?? 80 7D 4D 01 75 0C 8B 74 24 28 83 FE 01 89
5D 4E 75 31 8D 45 53 50 53 FF B5 ED 09 00 00 8D
45 35 50 E9 82 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

ASProtect v1.0
23
60 E8 01 ?? ?? ?? 90 5D 81 ED ?? ?? ?? ?? BB ??
?? ?? ?? 03 DD 2B 9D

ASProtect v1.1
15
60 E9 ?? 04 ?? ?? E9 ?? ?? ?? ?? ?? ?? ?? EE

ASProtect v1.1 MTE
12
60 E9 ?? ?? ?? ?? 91 78 79 79 79 E9

ASProtect v1.1 MTEc
9
90 60 E8 1B ?? ?? ?? E9 FC

ASProtect v1.2 -> Alexey Solodovnikov (h1)
43
90 60 E8 1B 00 00 00 E9 FC 8D B5 0F 06 00 00 8B
FE B9 97 00 00 00 AD 35 78 56 34 12 AB 49 75 F6
EB 04 5D 45 55 C3 E9 ?? ?? ?? 00

ASProtect v1.23 RC1
12
68 01 ?? ?? 00 E8 01 00 00 00 C3 C3

ASProtect v1.23 RC4 build 08.07 (dll) -> Alexey Solodovnikov
85
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB 00 ?? ??
?? 80 7D 4D 01 75 0C 8B 74 24 28 83 FE 01 89 5D
4E 75 31 8D 45 53 50 53 FF B5 D5 09 00 00 8D 45
35 50 E9 82 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

ASProtect v1.23 RC4 build 08.07 (exe) -> Alexey Solodovnikov
85
90 60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01
00 00 00 EB 5D BB ED FF FF FF 03 DD 81 EB ?? ??
?? ?? 80 7D 4D 01 75 0C 8B 74 24 28 83 FE 01 89
5D 4E 75 31 8D 45 53 50 53 FF B5 D5 09 00 00 8D
45 35 50 E9 82 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

ASProtect v1.2x
9
00 00 68 01 ?? ?? ?? C3 AA

ASProtect v1.2x (New Strain)
12
68 01 ?? ?? ?? E8 01 ?? ?? ?? C3 C3

ASProtect v2.0
12
68 01 ?? 40 00 E8 01 00 00 00 C3 C3

ASProtect V2.X DLL -> Alexey Solodovnikov
27
60 E8 03 00 00 00 E9 ?? ?? 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ?? ?? ?? ?? 03 DD

ASProtect v?.? -> If you know this version, post on PEiD board (h2)
85
90 60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01
00 00 00 EB 5D BB ED FF FF FF 03 DD 81 EB 00 ??
?? 00 80 7D 4D 01 75 0C 8B 74 24 28 83 FE 01 89
5D 4E 75 31 8D 45 53 50 53 FF B5 DD 09 00 00 8D
45 35 50 E9 82 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

ASProtect vx.x
21
60 ?? ?? ?? ?? ?? 90 5D ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 03 DD

ass - crypter -> by santasdad
268
55 8B EC 83 C4 EC 53 ?? ?? ?? ?? 89 45 EC B8 98
40 00 10 E8 AC EA FF FF 33 C0 55 68 78 51 00 10
64 ?? ?? ?? ?? 20 6A 0A 68 88 51 00 10 A1 E0 97
00 10 50 E8 D8 EA FF FF 8B D8 53 A1 E0 97 00 10
50 E8 12 EB FF FF 8B F8 53 A1 E0 97 00 10 50 E8
DC EA FF FF 8B D8 53 E8 DC EA FF FF 8B F0 85 F6
74 26 8B D7 4A B8 F0 97 00 10 E8 C9 E7 FF FF B8
F0 97 00 10 E8 B7 E7 FF FF 8B CF 8B D6 E8 EE EA
FF FF 53 E8 98 EA FF FF 8D 4D EC BA 9C 51 00 10
A1 F0 97 00 10 E8 22 EB FF FF 8B 55 EC B8 F0 97
00 10 E8 89 E6 FF FF B8 F0 97 00 10 E8 7F E7 FF
FF E8 6E EC FF FF 33 C0 5A 59 59 64 89 10 68 7F
51 00 10 8D 45 EC E8 11 E6 FF FF C3 E9 FF DF FF
FF EB F0 5F 5E 5B E8 0D E5 FF FF 00 53 45 54 54
49 4E 47 53 00 00 00 00 FF FF FF FF 1C 00 00 00
45 4E 54 45 52 20 59 4F 55 52 20 4F 57 4E 20 50
41 53 53 57 4F 52 44 20 48 45 52 45

AverCryptor 1.0 -> os1r1s
178
60 E8 00 00 00 00 5D 81 ED 75 17 40 00 8B BD 9C
18 40 00 8B 8D A4 18 40 00 B8 BC 18 40 00 03 C5
80 30 05 83 F9 00 74 71 81 7F 1C AB 00 00 00 75
62 8B 57 0C 03 95 A0 18 40 00 33 C0 51 33 C9 66
B9 FA 00 66 83 F9 00 74 49 8B 57 0C 03 95 A0 18
40 00 8B 85 A8 18 40 00 83 F8 02 75 06 81 C2 00
02 00 00 51 8B 4F 10 83 F8 02 75 06 81 E9 00 02
00 00 57 BF C8 00 00 00 8B F1 E8 27 00 00 00 8B
C8 5F B8 BC 18 40 00 03 C5 E8 24 00 00 00 59 49
EB B1 59 83 C7 28 49 EB 8A 8B 85 98 18 40 00 89
44 24 1C 61 FF E0 56 57 4F F7 D7 23 F7 8B C6 5F
5E C3

AverCryptor 1.02 beta -> os1r1s
178
60 E8 00 00 00 00 5D 81 ED 0C 17 40 00 8B BD 33
18 40 00 8B 8D 3B 18 40 00 B8 51 18 40 00 03 C5
80 30 05 83 F9 00 74 71 81 7F 1C AB 00 00 00 75
62 8B 57 0C 03 95 37 18 40 00 33 C0 51 33 C9 66
B9 F7 00 66 83 F9 00 74 49 8B 57 0C 03 95 37 18
40 00 8B 85 3F 18 40 00 83 F8 02 75 06 81 C2 00
02 00 00 51 8B 4F 10 83 F8 02 75 06 81 E9 00 02
00 00 57 BF C8 00 00 00 8B F1 E8 27 00 00 00 8B
C8 5F B8 51 18 40 00 03 C5 E8 24 00 00 00 59 49
EB B1 59 83 C7 28 49 EB 8A 8B 85 2F 18 40 00 89
44 24 1C 61 FF E0 56 57 4F F7 D7 23 F7 8B C6 5F
5E C3

AVPACK v1.20
22
50 1E 0E 1F 16 07 33 F6 8B FE B9 ?? ?? FC F3 A5
06 BB ?? ?? 53 CB

AZProtect 0001 - by AlexZ aka AZCRC
268
EB 70 FC 60 8C 80 4D 11 00 70 25 81 00 40 0D 91
BB 60 8C 80 4D 11 00 70 21 81 1D 61 0D 81 00 40
CE 60 8C 80 4D 11 00 70 25 81 25 81 25 81 25 81
29 61 41 81 31 61 1D 61 00 40 B7 30 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 60 BE 00 ?? ?? 00 BF 00 00 40 00 EB 17 4B
45 52 4E 45 4C 33 32 2E 44 4C 4C 00 00 00 00 00
FF 25 ?? ?? ?? 00 8B C6 03 C7 8B F8 57 55 8B EC
05 7F 00 00 00 50 E8 E5 FF FF FF BA 8C ?? ?? 00
89 02 E9 1A 01 00 00 ?? 00 00 00 47 65 74 4D 6F
64 75 6C 65 46 69 6C 65 4E 61 6D 65 41 00 47 65
74 56 6F 6C 75 6D 65 49 6E 66 6F 72 6D 61 74 69
6F 6E 41 00 4D 65 73 73 61 67 65 42 6F 78 41 00
45 78 69 74 50 72 6F 63 65 73 73 00 47 65 74 4D
6F 64 75 6C 65 48 61 6E 64 6C 65 41

AZProtect 0001 - by AlexZ aka AZCRC
115
FC 33 C9 49 8B D1 33 C0 33 DB AC 32 C1 8A CD 8A
EA 8A D6 B6 08 66 D1 EB 66 D1 D8 73 09 66 35 20
83 66 81 F3 B8 ED FE CE 75 EB 33 C8 33 D3 4F 75
D5 F7 D2 F7 D1 8B C2 C1 C0 10 66 8B C1 C3 F0 DA
55 8B EC 53 56 33 C9 33 DB 8B 4D 0C 8B 55 10 8B
75 08 4E 4A 83 FB 08 72 05 33 DB 43 EB 01 43 33
C0 8A 04 31 8A 24 13 2A C4 88 04 31 E2 E6 5E 5B
C9 C2 0C

bambam 0.01 -> bedrock
111
6A 14 E8 9A 05 00 00 8B D8 53 68 ?? ?? ?? ?? E8
6C FD FF FF B9 05 00 00 00 8B F3 BF ?? ?? ?? ??
53 F3 A5 E8 8D 05 00 00 8B 3D ?? ?? ?? ?? A1 ??
?? ?? ?? 66 8B 15 ?? ?? ?? ?? B9 ?? ?? ?? ?? 2B
CF 89 45 E8 89 0D ?? ?? ?? ?? 66 89 55 EC 8B 41
3C 33 D2 03 C1 83 C4 10 66 8B 48 06 66 8B 50 14
81 E1 FF FF 00 00 8D 5C 02 18 8D 41 FF 85 C0

bambam 0.04 -> bedrock
112
BF ?? ?? ?? ?? 83 C9 FF 33 C0 68 ?? ?? ?? ?? F2
AE F7 D1 49 51 68 ?? ?? ?? ?? E8 11 0A 00 00 83
C4 0C 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 8B F0 BF
?? ?? ?? ?? 83 C9 FF 33 C0 F2 AE F7 D1 49 BF ??
?? ?? ?? 8B D1 68 ?? ?? ?? ?? C1 E9 02 F3 AB 8B
CA 83 E1 03 F3 AA BF ?? ?? ?? ?? 83 C9 FF 33 C0
F2 AE F7 D1 49 51 68 ?? ?? ?? ?? E8 C0 09 00 00

BamBam v0.01 -> Bedrock
85
6A 14 E8 9A 05 00 00 8B D8 53 68 FB ?? ?? 00 E8
6C FD FF FF B9 05 00 00 00 8B F3 BF FB ?? ?? 00
53 F3 A5 E8 8D 05 00 00 8B 3D 03 ?? ?? 00 A1 2B
?? ?? 00 66 8B 15 2F ?? ?? 00 B9 80 ?? ?? 00 2B
CF 89 45 E8 89 0D 6B ?? ?? 00 66 89 55 EC 8B 41
3C 33 D2 03 C1

beria v0.07 public WIP --> symbiont
85
83 EC 18 53 8B 1D 00 30 ?? ?? 55 56 57 68 30 07
00 00 33 ED 55 FF D3 8B F0 3B F5 74 0D 89 AE 20
07 00 00 E8 88 0F 00 00 EB 02 33 F6 6A 10 55 89
35 30 40 ?? ?? FF D3 8B F0 3B F5 74 09 89 2E E8
3C FE FF FF EB 02 33 F6 6A 18 55 89 35 D8 43 ??
?? FF D3 8B F0

BeRo Tiny Pascal -> BeRo
81
E9 ?? ?? ?? ?? 20 43 6F 6D 70 69 6C 65 64 20 62
79 3A 20 42 65 52 6F 54 69 6E 79 50 61 73 63 61
6C 20 2D 20 28 43 29 20 43 6F 70 79 72 69 67 68
74 20 32 30 30 36 2C 20 42 65 6E 6A 61 6D 69 6E
20 27 42 65 52 6F 27 20 52 6F 73 73 65 61 75 78
20

BeRoEXEPacker V1.00 -> BeRo
99
BA ?? ?? ?? ?? 8D B2 ?? ?? ?? ?? 8B 46 ?? 85 C0
74 51 03 C2 8B 7E ?? 8B 1E 85 DB 75 02 8B DF 03
DA 03 FA 52 57 50 FF 15 ?? ?? ?? ?? 5F 5A 85 C0
74 2F 8B C8 8B 03 85 C0 74 22 0F BA F0 1F 72 04
8D 44 ?? ?? 51 52 57 50 51 FF 15 ?? ?? ?? ?? 5F
5A 59 85 C0 74 0B AB 83 C3 04 EB D8 83 C6 14 EB
AA 61 C3

BeRoEXEPacker v1.00 DLL [LZBRR] -> BeRo / Farbrausch
60
83 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 BE ?? ?? ??
?? BF ?? ?? ?? ?? FC B2 80 33 DB A4 B3 02 E8 ??
?? ?? ?? 73 F6 33 C9 E8 ?? ?? ?? ?? 73 1C 33 C0
E8 ?? ?? ?? ?? 73 23 B3 02 41 B0 10

BeRoEXEPacker v1.00 DLL [LZBRS] -> BeRo / Farbrausch
75
83 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 BE ?? ?? ??
?? BF ?? ?? ?? ?? FC AD 8D 1C 07 B0 80 3B FB 73
3B E8 ?? ?? ?? ?? 72 03 A4 EB F2 E8 ?? ?? ?? ??
8D 51 FF E8 ?? ?? ?? ?? 56 8B F7 2B F2 F3 A4 5E
EB DB 02 C0 75 03 AC 12 C0 C3 33

BeRoEXEPacker v1.00 DLL [LZMA] -> BeRo / Farbrausch
68
83 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 68 ?? ?? ??
?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8 ?? ?? ?? ??
BE ?? ?? ?? ?? B9 ?? ?? ?? ?? 8B F9 81 FE ?? ??
?? ?? 7F 10 AC 47 04 18 2C 02 73 F0 29 3E 03 F1
03 F9 EB E8

BeRoEXEPacker v1.00 [LZBRR] -> BeRo / Farbrausch
49
60 BE ?? ?? ?? ?? BF ?? ?? ?? ?? FC B2 80 33 DB
A4 B3 02 E8 ?? ?? ?? ?? 73 F6 33 C9 E8 ?? ?? ??
?? 73 1C 33 C0 E8 ?? ?? ?? ?? 73 23 B3 02 41 B0
10

BeRoEXEPacker v1.00 [LZBRS] -> BeRo / Farbrausch
64
60 BE ?? ?? ?? ?? BF ?? ?? ?? ?? FC AD 8D 1C 07
B0 80 3B FB 73 3B E8 ?? ?? ?? ?? 72 03 A4 EB F2
E8 ?? ?? ?? ?? 8D 51 FF E8 ?? ?? ?? ?? 56 8B F7
2B F2 F3 A4 5E EB DB 02 C0 75 03 AC 12 C0 C3 33

BeRoEXEPacker v1.00 [LZMA] -> BeRo / Farbrausch
57
60 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ??
E8 ?? ?? ?? ?? BE ?? ?? ?? ?? B9 04 00 00 00 8B
F9 81 FE ?? ?? ?? ?? 7F 10 AC 47 04 18 2C 02 73
F0 29 3E 03 F1 03 F9 EB E8

BlackEnergy DDoS Bot Crypter
44
55 ?? ?? 81 EC 1C 01 00 00 53 56 57 6A 04 BE 00
30 00 00 56 FF 35 00 20 11 13 6A 00 E8 ?? 03 00
00 ?? ?? 83 C4 10 ?? FF 89 7D F4 0F

Blade Joiner v1.5
19
55 8B EC 81 C4 E4 FE FF FF 53 56 57 33 C0 89 45
F0 89 85

BlindSpot 1.0 -> s134k
227
55 8B EC 81 EC 50 02 00 00 8D 85 B0 FE FF FF 53
56 A3 90 12 40 00 57 8D 85 B0 FD FF FF 68 00 01
00 00 33 F6 50 56 FF 15 24 10 40 00 56 68 80 00
00 00 6A 03 56 56 8D 85 B0 FD FF FF 68 00 00 00
80 50 FF 15 20 10 40 00 56 56 68 00 08 00 00 50
89 45 FC FF 15 1C 10 40 00 8D 45 F8 8B 1D 18 10
40 00 56 50 6A 34 FF 35 90 12 40 00 FF 75 FC FF
D3 85 C0 0F 84 7F 01 00 00 39 75 F8 0F 84 76 01
00 00 A1 90 12 40 00 66 8B 40 30 66 3D 01 00 75
14 8D 85 E4 FE FF FF 68 04 01 00 00 50 FF 15 14
10 40 00 EB 2C 66 3D 02 00 75 14 8D 85 E4 FE FF
FF 50 68 04 01 00 00 FF 15 10 10 40 00 EB 12 8D
85 E4 FE FF FF 68 04 01 00 00 50 FF 15 0C 10 40
00 8B 3D 08 10 40 00 8D 85 E4 FE FF FF 68 54 10
40 00 50

BobPack v1.00 --> BoB / BobSoft
64
60 E8 00 00 00 00 8B 0C 24 89 CD 83 E9 06 81 ED
?? ?? ?? ?? E8 3D 00 00 00 89 85 ?? ?? ?? ?? 89
C2 B8 5D 0A 00 00 8D 04 08 E8 E4 00 00 00 8B 70
04 01 D6 E8 76 00 00 00 E8 51 01 00 00 E8 01 01

BobSoft Mini Delphi -> BoB / BobSoft
33
55 8B EC 83 C4 F0 53 56 B8 ?? ?? ?? ?? E8 ?? ??
?? ?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20
B8

BobSoft Mini Delphi -> BoB / BobSoft
37
55 8B EC 83 C4 F0 53 B8 ?? ?? ?? ?? E8 ?? ?? ??
?? 33 C0 55 68 ?? ?? ?? ?? 64 FF 30 64 89 20 B8
?? ?? ?? ?? E8

BobSoft Mini Delphi -> BoB / BobSoft
12
55 8B EC 83 C4 F0 B8 ?? ?? ?? ?? E8

BopCrypt v1.0
11
60 BD ?? ?? ?? ?? E8 ?? ?? 00 00

CD-Cops II
19
53 60 BD ?? ?? ?? ?? 8D 45 ?? 8D 5D ?? E8 ?? ??
?? ?? 8D

CDS SS 1.0 beta1 -> CyberDoom
154
60 E8 00 00 00 00 5D 81 ED CA 47 40 00 FF 74 24
20 E8 D3 03 00 00 0B C0 0F 84 13 03 00 00 89 85
B8 4E 40 00 66 8C D8 A8 04 74 0C C7 85 8C 4E 40
00 01 00 00 00 EB 12 64 A1 30 00 00 00 0F B6 40
02 0A C0 0F 85 E8 02 00 00 8D 85 F6 4C 40 00 50
FF B5 B8 4E 40 00 E8 FC 03 00 00 0B C0 0F 84 CE
02 00 00 E8 1E 03 00 00 89 85 90 4E 40 00 8D 85
03 4D 40 00 50 FF B5 B8 4E 40 00 E8 D7 03 00 00
0B C0 0F 84 A9 02 00 00 E8 F9 02 00 00 89 85 94
4E 40 00 8D 85 12 4D 40 00 50

CDS SS v1.0 Beta 1 -> CyberDoom / Team-X
120
60 E8 00 00 00 00 5D 81 ED CA 47 40 00 FF 74 24
20 E8 D3 03 00 00 0B C0 0F 84 13 03 00 00 89 85
B8 4E 40 00 66 8C D8 A8 04 74 0C C7 85 8C 4E 40
00 01 00 00 00 EB 12 64 A1 30 00 00 00 0F B6 40
02 0A C0 0F 85 E8 02 00 00 8D 85 F6 4C 40 00 50
FF B5 B8 4E 40 00 E8 FC 03 00 00 0B C0 0F 84 CE
02 00 00 E8 1E 03 00 00 89 85 90 4E 40 00 8D 85
03 4D 40 00 50 FF B5 B8

Celsius Crypt 2.1 -> Z3r0
368
55 89 E5 83 EC 08 C7 04 24 01 00 00 00 FF 15 84
92 44 00 E8 C8 FE FF FF 90 8D B4 26 00 00 00 00
55 89 E5 83 EC 08 C7 04 24 02 00 00 00 FF 15 84
92 44 00 E8 A8 FE FF FF 90 8D B4 26 00 00 00 00
55 8B 0D C4 92 44 00 89 E5 5D FF E1 8D 74 26 00
55 8B 0D AC 92 44 00 89 E5 5D FF E1 90 90 90 90
55 89 E5 5D E9 77 C2 00 00 90 90 90 90 90 90 90
55 89 E5 83 EC 28 8B 45 10 89 04 24 E8 3F 14 01
00 48 89 45 FC 8B 45 0C 48 89 45 F4 8D 45 F4 89
44 24 04 8D 45 FC 89 04 24 E8 12 A3 03 00 8B 00
89 45 F8 8B 45 FC 89 45 F0 C6 45 EF 01 C7 45 E8
00 00 00 00 8B 45 E8 3B 45 F8 73 39 80 7D EF 00
74 33 8B 45 F0 89 44 24 04 8B 45 10 89 04 24 E8
1C 1A 01 00 89 C1 8B 45 08 8B 55 E8 01 C2 0F B6
01 3A 02 0F 94 C0 88 45 EF 8D 45 F0 FF 08 8D 45
E8 FF 00 EB BF 83 7D F0 00 74 34 80 7D EF 00 74
2E 8B 45 F0 89 44 24 04 8B 45 10 89 04 24 E8 DD
19 01 00 89 C1 8B 45 08 8B 55 F8 01 C2 0F B6 01
3A 02 0F 94 C0 88 45 EF 8D 45 F0 FF 08 EB C6 C7
44 24 04 00 00 00 00 8B 45 10 89 04 24 E8 AE 19
01 00 89 C1 8B 45 08 8B 55 F8 01 C2 0F B6 01 3A
02 7F 0C 0F B6 45 EF 83 E0 01 88 45 E7 EB 04 C6
45 E7 00 0F B6 45 E7 88 45 EF 0F B6 45 EF C9 C3

Celsius Crypt 2.1 -> Z3r0
256
55 89 E5 83 EC 28 8B 45 10 89 04 24 E8 3F 14 01
00 48 89 45 FC 8B 45 0C 48 89 45 F4 8D 45 F4 89
44 24 04 8D 45 FC 89 04 24 E8 12 A3 03 00 8B 00
89 45 F8 8B 45 FC 89 45 F0 C6 45 EF 01 C7 45 E8
00 00 00 00 8B 45 E8 3B 45 F8 73 39 80 7D EF 00
74 33 8B 45 F0 89 44 24 04 8B 45 10 89 04 24 E8
1C 1A 01 00 89 C1 8B 45 08 8B 55 E8 01 C2 0F B6
01 3A 02 0F 94 C0 88 45 EF 8D 45 F0 FF 08 8D 45
E8 FF 00 EB BF 83 7D F0 00 74 34 80 7D EF 00 74
2E 8B 45 F0 89 44 24 04 8B 45 10 89 04 24 E8 DD
19 01 00 89 C1 8B 45 08 8B 55 F8 01 C2 0F B6 01
3A 02 0F 94 C0 88 45 EF 8D 45 F0 FF 08 EB C6 C7
44 24 04 00 00 00 00 8B 45 10 89 04 24 E8 AE 19
01 00 89 C1 8B 45 08 8B 55 F8 01 C2 0F B6 01 3A
02 7F 0C 0F B6 45 EF 83 E0 01 88 45 E7 EB 04 C6
45 E7 00 0F B6 45 E7 88 45 EF 0F B6 45 EF C9 C3

CERBERUS v2.0
30
9C 2B ED 8C ?? ?? 8C ?? ?? FA E4 ?? 88 ?? ?? 16
07 BF ?? ?? 8E DD 9B F5 B9 ?? ?? FC F3 A5

CExe v1.0a
49
55 8B EC 81 EC 0C 02 ?? ?? 56 BE 04 01 ?? ?? 8D
85 F8 FE FF FF 56 50 6A ?? FF 15 54 10 40 ?? 8A
8D F8 FE FF FF 33 D2 84 C9 8D 85 F8 FE FF FF 74
16

CHECKPRG (c) 1992
19
33 C0 BE ?? ?? 8B D8 B9 ?? ?? BF ?? ?? BA ?? ??
47 4A 74

ChinaProtect -> dummy
124
C3 E8 ?? ?? ?? ?? B9 ?? ?? ?? ?? E8 ?? ?? ?? ??
FF 30 C3 B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? FF 30 C3
B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? FF 30 C3 B9 ?? ??
?? ?? E8 ?? ?? ?? ?? FF 30 C3 56 8B ?? ?? ?? 6A
40 68 00 10 00 00 8D ?? ?? 50 6A 00 E8 ?? ?? ??
?? 89 30 83 C0 04 5E C3 8B 44 ?? ?? 56 8D ?? ??
68 00 40 00 00 FF 36 56 E8 ?? ?? ?? ?? 68 00 80
00 00 6A 00 56 E8 ?? ?? ?? ?? 5E C3

ChSfx (small) v1.1
28
BA ?? ?? E8 ?? ?? 8B EC 83 EC ?? 8C C8 BB ?? ??
B1 ?? D3 EB 03 C3 8E D8 05 ?? ?? 89

CICompress v1.0
85
6A 04 68 00 10 00 00 FF 35 9C 14 40 00 6A 00 FF
15 38 10 40 00 A3 FC 10 40 00 97 BE 00 20 40 00
E8 71 00 00 00 3B 05 9C 14 40 00 75 61 6A 00 6A
20 6A 02 6A 00 6A 03 68 00 00 00 C0 68 94 10 40
00 FF 15 2C 10 40 00 A3 F8 10 40 00 6A 00 68 F4
10 40 00 FF 35

CipherWall Self-Extrator/Decryptor (Console) v1.5
85
90 61 BE 00 10 42 00 8D BE 00 00 FE FF C7 87 C0
20 02 00 0B 6E 5B 9B 57 83 CD FF EB 0E 90 90 90
90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC
11 DB 72 ED B8 01 00 00 00 01 DB 75 07 8B 1E 83
EE FC 11 DB 11 C0 01 DB 73 EF 75 09 8B 1E 83 EE
FC 11 DB 73 E4

CipherWall Self-Extrator/Decryptor (GUI) v1.5
85
90 61 BE 00 10 42 00 8D BE 00 00 FE FF C7 87 C0
20 02 00 F9 89 C7 6A 57 83 CD FF EB 0E 90 90 90
90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC
11 DB 72 ED B8 01 00 00 00 01 DB 75 07 8B 1E 83
EE FC 11 DB 11 C0 01 DB 73 EF 75 09 8B 1E 83 EE
FC 11 DB 73 E4

Code Virtualizer 1.3.1.0 -> Oreans Technologies
99
60 9C FC E8 00 00 00 00 5F 81 EF ?? ?? ?? ?? 8B
C7 81 C7 ?? ?? ?? ?? 3B 47 2C 75 02 EB 2E 89 47
2C B9 A7 00 00 00 EB 05 01 44 8F ?? 49 0B C9 75
F7 83 7F 40 00 74 15 8B 77 40 03 F0 EB 09 8B 1E
03 D8 01 03 83 C6 04 83 3E 00 75 F2 8B 74 24 24
8B DE 03 F0 B9 01 00 00 00 33 C0 F0 0F B1 4F 30
75 F7 AC

Code-Lock vx.x
14
43 4F 44 45 2D 4C 4F 43 4B 2E 4F 43 58 00

CodeCrypt v0.14b
20
E9 C5 02 00 00 EB 02 83 3D 58 EB 02 FF 1D 5B EB
02 0F C7 5F

CodeCrypt v0.15b
20
E9 31 03 00 00 EB 02 83 3D 58 EB 02 FF 1D 5B EB
02 0F C7 5F

CodeCrypt v0.164
25
E9 2E 03 00 00 EB 02 83 3D 58 EB 02 FF 1D 5B EB
02 0F C7 5F EB 03 FF 1D 34

CodeCrypt v0.16b - v0.163b
20
E9 2E 03 00 00 EB 02 83 3D 58 EB 02 FF 1D 5B EB
02 0F C7 5F

codeCrypter 0.31
32
50 58 53 5B 90 BB ?? ?? 40 00 FF E3 90 CC CC CC
55 8B EC 5D C3 CC CC CC CC CC CC CC CC CC CC CC

codeCrypter 0.31 -> Tibbar
32
50 58 53 5B 90 BB ?? ?? ?? 00 FF E3 90 CC CC CC
55 8B EC 5D C3 CC CC CC CC CC CC CC CC CC CC CC

COP v1.0 (c) 1988
24
BF ?? ?? BE ?? ?? B9 ?? ?? AC 32 ?? ?? ?? AA E2
?? 8B ?? ?? ?? EB ?? 90

Copy Protector v2.0
20
2E A2 ?? ?? 53 51 52 1E 06 B4 ?? 1E 0E 1F BA ??
?? CD 21 1F

CopyControl v3.03
23
CC 90 90 EB 0B 01 50 51 52 53 54 61 33 61 2D 35
CA D1 07 52 D1 A1 3C

CopyMinder -> Microcosm.Ltd
124
83 25 ?? ?? ?? ?? EF 6A 00 E8 ?? ?? ?? ?? E8 ??
?? ?? ?? CC FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ??
FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25 ?? ??
?? ?? FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25
?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ??
FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25 ?? ??
?? ?? FF 25 ?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25
?? ?? ?? ?? FF 25 ?? ?? ?? ?? FF 25

CPAV
12
E8 ?? ?? 4D 5A B1 01 93 01 00 00 02

CrackStop v1.01 (c) Stefan Esser 1997
14
B4 48 BB FF FF B9 EB 27 8B EC CD 21 FA FC

CreateInstall Stub vx.x
85
55 8B EC 81 EC 20 02 00 00 53 56 57 6A 00 FF 15
18 61 40 00 68 00 70 40 00 89 45 08 FF 15 14 61
40 00 85 C0 74 27 6A 00 A1 00 20 40 00 50 FF 15
3C 61 40 00 8B F0 6A 06 56 FF 15 38 61 40 00 6A
03 56 FF 15 38 61 40 00 E9 36 03 00 00 68 02 7F
00 00 33 F6 56

CreateInstall v2003.3.5
85
81 EC 0C 04 00 00 53 56 57 55 68 60 50 40 00 6A
01 6A 00 FF 15 D8 80 40 00 8B F0 FF 15 D4 80 40
00 3D B7 00 00 00 75 0F 56 FF 15 B8 80 40 00 6A
02 FF 15 A4 80 40 00 33 DB E8 F2 FE FF FF 68 02
7F 00 00 89 1D 94 74 40 00 53 89 1D 98 74 40 00
FF 15 E4 80 40

Crinkler V0.1-V0.2 -> Rune L.H.Stubbe and Aske Simon Christensen
32
B9 ?? ?? ?? ?? 01 C0 68 ?? ?? ?? ?? 6A 00 58 50
6A 00 5F 48 5D BB 03 00 00 00 BE ?? ?? ?? ?? E9

Crinkler V0.3-V0.4 -> Rune L.H.Stubbe and Aske Simon Christensen
10
B8 00 00 42 00 31 DB 43 EB 58

Crunch 5 Fusion 4
25
EB 15 03 ?? ?? ?? 06 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 68 ?? ?? ?? ?? 55 E8

Crunch v4.0
85
EB 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 55 E8 00 00 00 00 5D 81 ED 18 00 00 00 8B
C5 55 60 9C 2B 85 E9 06 00 00 89 85 E1 06 00 00
FF 74 24 2C E8 BB 01 00 00 0F 82 92 05 00 00 E8
F1 03 00 00 49 0F 88 86 05 00 00 68 6C D9 B2 96
33 C0 50 E8 24

Crunch v5 -> Bit-Arts
85
EB 15 03 00 00 00 06 00 00 00 00 00 00 00 00 00
00 00 68 00 00 00 00 55 E8 00 00 00 00 5D 81 ED
1D 00 00 00 8B C5 55 60 9C 2B 85 FC 07 00 00 89
85 E8 07 00 00 FF 74 24 2C E8 20 02 00 00 0F 82
94 06 00 00 E8 F3 04 00 00 49 0F 88 88 06 00 00
8B B5 E8 07 00

Crunch/PE
22
55 E8 ?? ?? ?? ?? 5D 83 ED 06 8B C5 55 60 89 AD
?? ?? ?? ?? 2B 85

Crunch/PE v1.0.x.x
43
55 E8 ?? ?? ?? ?? 5D 83 ED 06 8B C5 55 60 89 AD
?? ?? ?? ?? 2B 85 ?? ?? ?? ?? 89 85 ?? ?? ?? ??
80 BD ?? ?? ?? ?? ?? 75 09 C6 85

Crunch/PE v2.0.x.x
51
55 E8 ?? ?? ?? ?? 5D 83 ED 06 8B C5 55 60 89 AD
?? ?? ?? ?? 2B 85 ?? ?? ?? ?? 89 85 ?? ?? ?? ??
55 BB ?? ?? ?? ?? 03 DD 53 64 67 FF 36 ?? ?? 64
67 89 26

Crunch/PE v3.0.x.x
50
EB 10 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 55 E8 ?? ?? ?? ?? 5D 81 ED 18 ?? ?? ?? 8B
C5 55 60 9C 2B 85 ?? ?? ?? ?? 89 85 ?? ?? ?? ??
FF 74

Crunch/PE v4.0
85
EB 10 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 55 E8 ?? ?? ?? ?? 5D 81 ED 18 ?? ?? ?? 8B
C5 55 60 9C 2B 85 E9 06 ?? ?? 89 85 E1 06 ?? ??
FF 74 24 2C E8 BB 01 00 00 0F 82 92 05 00 00 E8
F1 03 00 00 49 0F 88 86 05 00 00 68 6C D9 B2 96
33 C0 50 E8 24

Cruncher v1.0
35
2E ?? ?? ?? ?? 2E ?? ?? ?? B4 30 CD 21 3C 03 73
?? BB ?? ?? 8E DB 8D ?? ?? ?? B4 09 CD 21 06 33
C0 50 CB

CrypKey v5 - v6
37
E8 ?? ?? ?? ?? 58 83 E8 05 50 5F 57 8B F7 81 EF
?? ?? ?? ?? 83 C6 39 BA ?? ?? ?? ?? 8B DF B9 0B
?? ?? ?? 8B 06

CrypKey V5.6.X -> Kenonic Controls Ltd.
18
E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 F8 00 75 07 6A
00 E8

CrypKey V5.6.X DLL -> Kenonic Controls Ltd.
17
8B 1D ?? ?? ?? ?? 83 FB 00 75 0A E8 ?? ?? ?? ??
E8

CrypKey V6.1X DLL -> CrypKey (Canada) Inc.
15
83 3D ?? ?? ?? ?? 00 75 34 68 ?? ?? ?? ?? E8

CRYPT Version 1.7 (c) Dismember
10
0E 17 9C 58 F6 ?? ?? 74 ?? E9

Crypter 3.1 -> SLESH
28
68 FF 64 24 F0 68 58 58 58 58 FF D4 50 8B 40 F2
05 B0 95 F6 95 0F 85 01 81 BB FF 68

Cryptic 2.0 -> Tughack
38
B8 00 00 40 00 BB ?? ?? ?? 00 B9 00 10 00 00 BA
?? ?? ?? 00 03 D8 03 C8 03 D1 3B CA 74 06 80 31
?? 41 EB F6 FF E3

Crypto-Lock v2.02 (Eng) -> Ryan Thian
30
60 BE 15 90 40 00 8D BE EB 7F FF FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47

Crypto-Lock v2.02 (Eng) -> Ryan Thian
85
60 BE 15 90 40 00 8D BE EB 7F FF FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
EF 75 09 8B 1E 83 EE FC 11 DB 73 E4 31 C9 83 E8
03 72 0D C1 E0

Crypto-Lock v2.02 (Eng) -> Ryan Thian
85
60 BE ?? 90 40 00 8D BE ?? ?? FF FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
EF 75 09 8B 1E 83 EE FC 11 DB 73 E4 31 C9 83 E8
03 72 0D C1 E0

CRYPToCRACk's PE Protector V0.9.2 -> Lukas Fleischer
38
E8 01 00 00 00 E8 58 5B 81 E3 00 FF FF FF 66 81
3B 4D 5A 75 37 84 DB 75 33 8B F3 03 ?? ?? 81 3E
50 45 00 00 75 26

CRYPToCRACk's PE Protector V0.9.3 -> Lukas Fleischer
54
5B 81 E3 00 FF FF FF 66 81 3B 4D 5A 75 33 8B F3
03 73 3C 81 3E 50 45 00 00 75 26 0F B7 46 18 8B
C8 69 C0 AD 0B 00 00 F7 E0 2D AB 5D 41 4B 69 C9
DE C0 00 00 03 C1

CrypWrap vx.x
35
E8 B8 ?? ?? ?? E8 90 02 ?? ?? 83 F8 ?? 75 07 6A
?? E8 ?? ?? ?? ?? FF 15 49 8F 40 ?? A9 ?? ?? ??
80 74 0E

Cygwin32
8
55 89 E5 83 EC 04 83 3D

D1NS1G -> D1N
180
18 37 00 00 00 00 00 00 01 00 0A 00 00 00 18 00
00 80 00 00 00 00 ?? ?? 18 37 00 00 00 00 02 00
00 00 88 00 00 80 38 00 00 80 96 00 00 80 50 00
00 80 00 00 00 00 ?? ?? 18 37 00 00 00 00 00 00
01 00 00 00 00 00 68 00 00 00 00 00 00 00 ?? ??
18 37 00 00 00 00 00 00 01 00 00 00 00 00 78 00
00 00 B0 F0 00 00 10 00 00 00 00 00 00 00 00 00
00 00 C0 F0 00 00 60 00 00 00 00 00 00 00 00 00
00 00 06 00 44 00 56 00 43 00 4C 00 41 00 4C 00
0B 00 50 00 41 00 43 00 4B 00 41 00 47 00 45 00
49 00 4E 00 46 00 4F 00 00 00 00 00 00 00 00 00
00 00 00 00

D1S1G v1.1 Beta ++ Scrambled EXE -> D1N
120
E8 07 00 00 00 E8 1E 00 00 00 C3 90 58 89 C2 89
C2 25 00 F0 FF FF 50 83 C0 55 8D 00 FF 30 8D 40
04 FF 30 52 C3 8D 40 00 55 8B EC 83 C4 E8 53 56
57 8B 4D 10 8B 45 08 89 45 F8 8B 45 0C 89 45 F4
8D 41 61 8B 38 8D 41 65 8B 00 03 C7 89 45 FC 8D
41 69 8B 00 03 C7 8D 51 6D 8B 12 03 D7 83 C1 71
8B 09 03 CF 2B CA 72 0A 41 87 D1 80 31 FF 41 4A
75 F9 89 45 F0 EB 71 8B

D1S1G v1.1 beta --> D1N
176
00 00 00 00 ?? ?? ?? ?? 00 00 00 00 00 00 01 00
0A 00 00 00 18 00 00 80 00 00 00 00 ?? ?? ?? ??
00 00 00 00 02 00 00 00 88 00 00 80 38 00 00 80
96 00 00 80 50 00 00 80 00 00 00 00 ?? ?? ?? ??
00 00 00 00 00 00 01 00 00 00 00 00 68 00 00 00
00 00 00 00 ?? ?? ?? ?? 00 00 00 00 00 00 01 00
00 00 00 00 78 00 00 00 B0 ?? ?? 00 10 00 00 00
00 00 00 00 00 00 00 00 C0 ?? ?? ?? ?? 00 00 00
00 00 00 00 00 00 00 00 06 00 44 00 56 00 43 00
4C 00 41 00 4C 00 0B 00 50 00 41 00 43 00 4B 00
41 00 47 00 45 00 49 00 4E 00 46 00 4F 00 00 00

DAEMON Protect v0.6.7
23
60 60 9C 8C C9 32 C9 E3 0C 52 0F 01 4C 24 FE 5A
83 C2 0C 8B 1A 9D 61

DalKrypt 1.0 - by DalKiT
39
68 00 10 40 00 58 68 ?? ?? ?? 00 5F 33 DB EB 0D
8A 14 03 80 EA 07 80 F2 04 88 14 03 43 81 FB ??
?? ?? 00 72 EB FF E7

DBPE v1.53
43
9C 55 57 56 52 51 53 9C FA E8 ?? ?? ?? ?? 5D 81
ED 5B 53 40 ?? B0 ?? E8 ?? ?? ?? ?? 5E 83 C6 11
B9 27 ?? ?? ?? 30 06 46 49 75 FA

DBPE v2.10
61
9C 6A 10 73 0B EB 02 C1 51 E8 06 ?? ?? ?? C4 11
73 F7 5B CD 83 C4 04 EB 02 99 EB FF 0C 24 71 01
E8 79 E0 7A 01 75 83 C4 04 9D EB 01 75 68 5F 20
40 ?? E8 B0 EF FF FF 72 03 73 01 75 BE

DBPE v2.10 -> Ding Boy
85
EB 20 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 9C 55 57 56 52 51 53 9C E8 ?? ?? ?? ?? 5D
81 ED ?? ?? ?? ?? EB 58 75 73 65 72 33 32 2E 64
6C 6C ?? 4D 65 73 73 61 67 65 42 6F 78 41 ?? 6B
65 72 6E 65 6C

DBPE v2.33 -> Ding Boy
85
EB 20 ?? ?? 40 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 9C 55 57 56 52 51 53 9C E8 ?? ?? ?? ?? 5D
81 ED ?? ?? ?? ?? 9C 6A 10 73 0B EB 02 C1 51 E8
06 ?? ?? ?? C4 11 73 F7 5B CD 83 C4 04 EB 02 99
EB FF 0C 24 71

DBPE vx.xx -> Ding Boy
50
EB 20 ?? ?? 40 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 9C 55 57 56 52 51 53 9C E8 ?? ?? ?? ?? 5D
81 ED

DCrypt Private 0.9b -> drmist
28
B9 ?? ?? ?? 00 E8 00 00 00 00 58 68 ?? ?? ?? 00
83 E8 0B 0F 18 00 D0 00 48 E2 FB C3

DEF 1.0 -> bart/xt
85
BE ?? ?? 40 00 6A ?? 59 80 7E 07 00 74 11 8B 46
0C 05 00 00 40 00 8B 56 10 30 10 40 4A 75 FA 83
C6 28 E2 E4 68 ?? ?? 40 00 C3 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

DEF v1.0
16
BE ?? 01 40 00 6A 05 59 80 7E 07 00 74 11 8B 46

DEF v1.0
42
BE ?? 01 40 00 6A ?? 59 80 7E 07 00 74 11 8B 46
0C 05 00 00 40 00 8B 56 10 30 10 40 4A 75 FA 83
C6 28 E2 E4 68 ?? 10 40 00 C3

DEF v1.00 (Eng) -> bart/xt
85
BE ?? 01 40 00 6A ?? 59 80 7E 07 00 74 11 8B 46
0C 05 00 00 40 00 8B 56 10 30 10 40 4A 75 FA 83
C6 28 E2 E4 68 ?? ?? 40 00 C3 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

dePACK -> deNULL
19
EB 01 DD 60 68 00 ?? ?? ?? 68 ?? ?? 00 00 E8 ??
00 00 00

dePACK -> deNULL
148
EB 01 DD 60 68 00 ?? ?? ?? 68 ?? ?? ?? 00 E8 ??
00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? D2

Dev-C++ 4.9.9.2 -> Bloodshed Software
83
55 89 E5 83 EC 08 C7 04 24 01 00 00 00 FF 15 ??
?? ?? 00 E8 C8 FE FF FF 90 8D B4 26 00 00 00 00
55 89 E5 83 EC 08 C7 04 24 02 00 00 00 FF 15 ??
?? ?? 00 E8 A8 FE FF FF 90 8D B4 26 00 00 00 00
55 8B 0D ?? ?? ?? 00 89 E5 5D FF E1 8D 74 26 00
55 8B 0D

Dev-C++ v4
23
55 89 E5 83 EC 08 83 C4 F4 6A ?? A1 ?? ?? ?? 00
FF D0 E8 ?? FF FF FF

Dev-C++ v5
32
55 89 E5 83 EC 14 6A ?? FF 15 ?? ?? ?? 00 ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00

DIET v1.00, v1.00d
21
BF ?? ?? 3B FC 72 ?? B4 4C CD 21 BE ?? ?? B9 ??
?? FD F3 A5 FC

DIET v1.00d
32
FC 06 1E 0E 8C C8 01 ?? ?? ?? BA ?? ?? 03 ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00

DIET v1.02b, v1.10a, v1.20
21
BE ?? ?? BF ?? ?? B9 ?? ?? 3B FC 72 ?? B4 4C CD
21 FD F3 A5 FC

DIET v1.44, v1.45f
20
F8 9C 06 1E 57 56 52 51 53 50 0E FC 8C C8 BA ??
?? 03 D0 52

Ding Boy's PE-lock Phantasm v0.8
20
55 57 56 52 51 53 E8 00 00 00 00 5D 8B D5 81 ED
0D 39 40 00

Ding Boy's PE-lock Phantasm v1.0 / v1.1
20
55 57 56 52 51 53 66 81 C3 EB 02 EB FC 66 81 C3
EB 02 EB FC

Ding Boy's PE-lock Phantasm v1.5b3
22
9C 55 57 56 52 51 53 9C FA E8 00 00 00 00 5D 81
ED 5B 53 40 00 B0

Ding Boy's PE-lock v0.07
20
55 57 56 52 51 53 E8 00 00 00 00 5D 8B D5 81 ED
23 35 40 00

diPacker V1.X -> diProtector Software
52
0F 00 2D E9 01 00 A0 E3 68 01 00 EB 8C 00 00 EB
2B 00 00 EB 00 00 20 E0 1C 10 8F E2 8E 20 8F E2
00 30 A0 E3 67 01 00 EB 0F 00 BD E8 00 C0 8F E2
00 F0 9C E5

diProtector V1.X -> diProtector Software
80
01 00 A0 E3 14 00 00 EB 00 00 20 E0 44 10 9F E5
03 2A A0 E3 40 30 A0 E3 AE 00 00 EB 30 00 8F E5
00 20 A0 E1 3A 0E 8F E2 00 00 80 E2 1C 10 9F E5
20 30 8F E2 0E 00 00 EB 14 00 9F E5 14 10 9F E5
7F 20 A0 E3 C5 00 00 EB 04 C0 8F E2 00 F0 9C E5

DJoin v0.7 public (RC4 encryption) -> drmist
34
C6 05 ?? ?? 40 00 00 C6 05 ?? ?? 40 00 00 ?? ??
?? ?? ?? ?? ?? ?? 00 ?? ?? ?? ?? 00 ?? ?? ?? ??
?? 00

DJoin v0.7 public (xor encryption) -> drmist
27
C6 05 ?? ?? 40 00 00 ?? ?? ?? ?? ?? ?? ?? ?? 00
?? ?? ?? ?? 00 ?? ?? ?? ?? ?? 00

DotFix Nice Protect 2.1 -> GPcH Soft
234
E9 FF 00 00 00 60 8B 74 24 24 8B 7C 24 28 FC B2
80 33 DB A4 B3 02 E8 6D 00 00 00 73 F6 33 C9 E8
64 00 00 00 73 1C 33 C0 E8 5B 00 00 00 73 23 B3
02 41 B0 10 E8 4F 00 00 00 12 C0 73 F7 75 3F AA
EB D4 E8 4D 00 00 00 2B CB 75 10 E8 42 00 00 00
EB 28 AC D1 E8 74 4D 13 C9 EB 1C 91 48 C1 E0 08
AC E8 2C 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05
73 06 83 F8 7F 77 02 41 41 95 8B C5 B3 01 56 8B
F7 2B F0 F3 A4 5E EB 8E 02 D2 75 05 8A 16 46 12
D2 C3 33 C9 41 E8 EE FF FF FF 13 C9 E8 E7 FF FF
FF 72 F2 C3 2B 7C 24 28 89 7C 24 1C 61 C3 60 B8
?? ?? ?? ?? 03 C5 50 B8 ?? ?? ?? ?? 03 C5 FF 10
BB ?? ?? ?? ?? 03 DD 83 C3 0C 53 50 B8 ?? ?? ??
?? 03 C5 FF 10 6A 40 68 00 10 00 00 FF 74 24 2C
6A 00 FF D0 89 44 24 1C 61 C3

DotFix NiceProtect vna
69
60 E8 55 00 00 00 8D BD 00 10 40 00 68 ?? ?? ??
00 03 3C 24 8B F7 90 68 31 10 40 00 9B DB E3 55
DB 04 24 8B C7 DB 44 24 04 DE C1 DB 1C 24 8B 1C
24 66 AD 51 DB 04 24 90 90 DA 8D 77 10 40 00 DB
1C 24 D1 E1 29

Dr.Web Virus-Finding Engine -> InSoft EDV-Systeme
20
B8 01 00 00 00 C2 0C 00 8D 80 00 00 00 00 8B D2
8B ?? 24 04

DragonArmor -> Orient
170
BF 4C ?? ?? 00 83 C9 FF 33 C0 68 34 ?? ?? 00 F2
AE F7 D1 49 51 68 4C ?? ?? 00 E8 11 0A 00 00 83
C4 0C 68 4C ?? ?? 00 FF 15 00 ?? ?? 00 8B F0 BF
4C ?? ?? 00 83 C9 FF 33 C0 F2 AE F7 D1 49 BF 4C
?? ?? 00 8B D1 68 34 ?? ?? 00 C1 E9 02 F3 AB 8B
CA 83 E1 03 F3 AA BF 5C ?? ?? 00 83 C9 FF 33 C0
F2 AE F7 D1 49 51 68 5C ?? ?? 00 E8 C0 09 00 00
8B 1D 04 ?? ?? 00 83 C4 0C 68 5C ?? ?? 00 56 FF
D3 A3 D4 ?? ?? 00 BF 5C ?? ?? 00 83 C9 FF 33 C0
F2 AE F7 D1 49 BF 5C ?? ?? 00 8B D1 68 34 ?? ??
00 C1 E9 02 F3 AB 8B CA 83 E1

Dropper Creator V0.1 -> Conflict
41
60 E8 00 00 00 00 5D 8D 05 ?? ?? ?? ?? 29 C5 8D
85 ?? ?? ?? ?? 31 C0 64 03 40 30 78 0C 8B 40 0C
8B 70 1C AD 8B 40 08 EB 09

DSHIELD
19
06 E8 ?? ?? 5E 83 EE ?? 16 17 9C 58 B9 ?? ?? 25
?? ?? 2E

Dual's eXe 1.0
85
55 8B EC 81 EC 00 05 00 00 E8 00 00 00 00 5D 81
ED 0E 00 00 00 8D 85 08 03 00 00 89 28 33 FF 8D
85 7D 02 00 00 8D 8D 08 03 00 00 2B C8 8B 9D 58
03 00 00 E8 1C 02 00 00 8D 9D 61 02 00 00 8D B5
7C 02 00 00 46 80 3E 00 74 24 56 FF 95 0A 04 00
00 46 80 3E 00

Dual's eXe Encryptor 1.0b -> Dual
139
55 8B EC 81 EC 00 05 00 00 E8 00 00 00 00 5D 81
ED 0E 00 00 00 8D 85 3A 04 00 00 89 28 33 FF 8D
85 80 03 00 00 8D 8D 3A 04 00 00 2B C8 8B 9D 8A
04 00 00 E8 24 02 00 00 8D 9D 58 03 00 00 8D B5
7F 03 00 00 46 80 3E 00 74 24 56 FF 95 58 05 00
00 46 80 3E 00 75 FA 46 80 3E 00 74 E7 50 56 50
FF 95 5C 05 00 00 89 03 58 83 C3 04 EB E3 8D 85
69 02 00 00 FF D0 8D 85 56 04 00 00 50 68 1F 00
02 00 6A 00 8D 85 7A 04 00 00 50

dUP 2.x Patcher --> www.diablo2oo2.cjb.net
25
8B CB 85 C9 74 ?? 80 3A 01 74 08 AC AE 75 0A 42
49 EB EF 47 46 42 49 EB E9

dUP2 -> diablo2oo2
98
E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B F0 6A 00 68 ??
?? ?? ?? 56 E8 ?? ?? ?? ?? A2 ?? ?? ?? ?? 6A 00
68 ?? ?? ?? ?? 56 E8 ?? ?? ?? ?? A2 ?? ?? ?? ??
6A 00 68 ?? ?? ?? ?? 56 E8 ?? ?? ?? ?? A2 ?? ??
?? ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 56 E8 ?? ??
?? ?? 3C 01 75 19 BE ?? ?? ?? ?? 68 00 02 00 00
56 68

DxPack 1.0
36
60 E8 ?? ?? ?? ?? 5D 8B FD 81 ED ?? ?? ?? ?? 2B
B9 ?? ?? ?? ?? 81 EF ?? ?? ?? ?? 83 BD ?? ?? ??
?? ?? 0F 84

DxPack V0.86 -> Dxd
40
60 E8 00 00 00 00 5D 8B FD 81 ED 06 10 40 00 2B
BD 94 12 40 00 81 EF 06 00 00 00 83 BD 14 13 40
00 01 0F 84 2F 01 00 00

DzA Patcher v1.3 Loader
85
BF 00 40 40 00 99 68 48 20 40 00 68 00 20 40 00
52 52 52 52 52 52 52 57 E8 15 01 00 00 85 C0 75
1C 99 52 52 57 52 E8 CB 00 00 00 FF 35 4C 20 40
00 E8 D2 00 00 00 6A 00 E8 BF 00 00 00 99 68 58
20 40 00 52 52 68 63 10 40 00 52 52 E8 DB 00 00
00 6A FF FF 35

E language
20
E8 06 00 00 00 50 E8 ?? 01 00 00 55 8B EC 81 C4
F0 FE FF FF

E.You.Di.Dai-> YueHeiFengGao
62
55 8B EC B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 53 56 57
0F 31 8B D8 0F 31 8B D0 2B D3 C1 EA 10 B8 ?? ??
?? ?? 0F 6E C0 B8 ?? ?? ?? ?? 0F 6E C8 0F F5 C1
0F 7E C0 0F 77 03 C2 ?? ?? ?? ?? ?? FF E0

E2C by DoP
14
BE ?? ?? BF ?? ?? B9 ?? ?? FC 57 F3 A5 C3

EEXE Version 1.12
22
B4 30 CD 21 3C 03 73 ?? BA 1F 00 0E 1F B4 09 CD
21 B8 FF 4C CD 21

Elicense System V4.0.0.0 -> ViaTech Inc
24
00 00 00 00 63 79 62 00 65 6C 69 63 65 6E 34 30
2E 64 6C 6C 00 00 00 00

Embed PE v1.13 -> cyclotron
20
83 EC 50 60 68 5D B9 52 5A E8 2F 99 00 00 DC 99
F3 57 05 68

EmbedPE 1.13 -> cyclotron
85
83 EC 50 60 68 5D B9 52 5A E8 2F 99 00 00 DC 99
F3 57 05 68 B8 5E 2D C6 DA FD 48 63 05 3C 71 B8
5E 97 7C 36 7E 32 7C 08 4F 06 51 64 10 A3 F1 4E
CF 25 CB 80 D2 99 54 46 ED E1 D3 46 86 2D 10 68
93 83 5C 46 4D 43 9B 8C D6 7C BB 99 69 97 71 2A
2F A3 38 6B 33

EmbedPE V1.00-V1.24 -> cyclotron
149
00 00 00 00 ?? ?? ?? ?? 00 00 00 00 00 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 4B 45 52 4E
45 4C 33 32 2E 64 6C 6C 00 00 00 00 47 65 74 50
72 6F 63 41 64 64 72 65 73 73 00 00 00 47 65 74
4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00 00
4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00 00 00
00 00 00 00 00

EmbedPE v1.24 -> cyclotron
14
83 EC 50 60 68 ?? ?? ?? ?? E8 CB FF 00 00

EmbedPE V1.X -> cyclotron
14
83 EC 50 60 68 ?? ?? ?? ?? E8 ?? ?? 00 00

EncryptPE 1.2003.3.18-1.2003.5.18 -> WFS
257
60 9C 64 FF 35 00 00 00 00 E8 79 01 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
53 79 73 74 65 6D 44 69 72 65 63 74 6F 72 79 41
00 00 00 43 72 65 61 74 65 46 69 6C 65 41 00 00
00 43 72 65 61 74 65 46 69 6C 65 4D 61 70 70 69
6E 67 41 00 00 00 4D 61 70 56 69 65 77 4F 66 46
69 6C 65 00 00 00 55 6E 6D 61 70 56 69 65 77 4F
66 46 69 6C 65 00 00 00 43 6C 6F 73 65 48 61 6E
64 6C 65 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64 72
65 73 73 00 00 00 45 78 69 74 50 72 6F 63 65 73
73

EncryptPE 1.2003.5.18 -> WFS
11
60 9C 64 FF 35 00 00 00 00 E8 79

EncryptPE 2.2004.6.16-2.2006.6.30 -> WFS
257
60 9C 64 FF 35 00 00 00 00 E8 7A 01 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
53 79 73 74 65 6D 44 69 72 65 63 74 6F 72 79 41
00 00 00 43 72 65 61 74 65 46 69 6C 65 41 00 00
00 43 72 65 61 74 65 46 69 6C 65 4D 61 70 70 69
6E 67 41 00 00 00 4D 61 70 56 69 65 77 4F 66 46
69 6C 65 00 00 00 55 6E 6D 61 70 56 69 65 77 4F
66 46 69 6C 65 00 00 00 43 6C 6F 73 65 48 61 6E
64 6C 65 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64 72
65 73 73 00 00 00 45 78 69 74 50 72 6F 63 65 73
73

EncryptPE 2.2004.8.10 - 2.2005.3.14 -> WFS
11
60 9C 64 FF 35 00 00 00 00 E8 7A

EncryptPE 2.2006.7.10-2.2006.10.25 -> WFS
250
60 9C 64 FF 35 00 00 00 00 E8 73 01 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
54 65 6D 70 50 61 74 68 41 00 00 00 43 72 65 61
74 65 46 69 6C 65 41 00 00 00 43 72 65 61 74 65
46 69 6C 65 4D 61 70 70 69 6E 67 41 00 00 00 4D
61 70 56 69 65 77 4F 66 46 69 6C 65 00 00 00 55
6E 6D 61 70 56 69 65 77 4F 66 46 69 6C 65 00 00
00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 00 00 4C
6F 61 64 4C 69 62 72 61 72 79 41 00 00 00 47 65
74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00 45
78 69 74 50 72 6F 63 65 73 73

EncryptPE V2.2006.1.15 -> WFS
27
45 50 45 3A 20 45 6E 63 72 79 70 74 50 45 20 56
32 2E 32 30 30 36 2E 31 2E 31 35

EncryptPE V2.2006.7.10 -> WFS
14
60 9C 64 FF 35 00 00 00 00 E8 73 01 00 00

EncryptPE V2.2006.7.10 -> WFS
254
60 9C 64 FF 35 00 00 00 00 E8 73 01 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
54 65 6D 70 50 61 74 68 41 00 00 00 43 72 65 61
74 65 46 69 6C 65 41 00 00 00 43 72 65 61 74 65
46 69 6C 65 4D 61 70 70 69 6E 67 41 00 00 00 4D
61 70 56 69 65 77 4F 66 46 69 6C 65 00 00 00 55
6E 6D 61 70 56 69 65 77 4F 66 46 69 6C 65 00 00
00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 00 00 4C
6F 61 64 4C 69 62 72 61 72 79 41 00 00 00 47 65
74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00 45
78 69 74 50 72 6F 63 65 73 73 00 00 00 00

EncryptPE V2.2007.04.11 -> WFS
250
60 9C 64 FF 35 00 00 00 00 E8 1B 02 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
54 65 6D 70 50 61 74 68 41 00 00 00 43 72 65 61
74 65 46 69 6C 65 41 00 00 00 43 72 65 61 74 65
46 69 6C 65 4D 61 70 70 69 6E 67 41 00 00 00 4D
61 70 56 69 65 77 4F 66 46 69 6C 65 00 00 00 55
6E 6D 61 70 56 69 65 77 4F 66 46 69 6C 65 00 00
00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 00 00 4C
6F 61 64 4C 69 62 72 61 72 79 41 00 00 00 47 65
74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00 45
78 69 74 50 72 6F 63 65 73 73

EncryptPE V2.2007.4.11 -> WFS
256
60 9C 64 FF 35 00 00 00 00 E8 1B 02 00 00 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
54 65 6D 70 50 61 74 68 41 00 00 00 43 72 65 61
74 65 46 69 6C 65 41 00 00 00 43 72 65 61 74 65
46 69 6C 65 4D 61 70 70 69 6E 67 41 00 00 00 4D
61 70 56 69 65 77 4F 66 46 69 6C 65 00 00 00 55
6E 6D 61 70 56 69 65 77 4F 66 46 69 6C 65 00 00
00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 00 00 4C
6F 61 64 4C 69 62 72 61 72 79 41 00 00 00 47 65
74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00 45
78 69 74 50 72 6F 63 65 73 73 00 00 00 00 00 00

ENIGMA Protector -> Sukhov Vladimir
19
45 6E 69 67 6D 61 20 70 72 6F 74 65 63 74 6F 72
20 76 31

Enigma Protector 1.0X -> Sukhov Vladimir
145
60 E8 00 00 00 00 5D 83 ?? ?? 81 ED ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 ?? 83 C4 04 EB 02 ?? ?? 60 E8 24 00
00 00 00 00 ?? EB 02 ?? ?? 8B 44 24 0C 83 80 B8
00 00 00 03 31 C0 C3 83 C0 08 EB 02 ?? ?? 89 C4
61 EB 2E ?? ?? ?? ?? ?? ?? ?? EB 01 ?? 31 C0 EB
01 ?? 64 FF 30 EB 01 ?? 64 89 20 EB 02 ?? ?? 89
00 9A 64 8F 05 00 00 00 00 EB 02 C1 ?? 58 61 EB
01

Enigma protector 1.10 (unregistered)
85
60 72 80 72 88 72 8C 72 90 72 94 72 98 72 9C 72
A0 72 A4 59 A8 B0 5C E8 39 D5 39 E4 39 F1 31 F9
5C 3D 58 CA 5F 56 B1 2D 20 7A 2E 30 16 32 72 2B
72 36 1C A5 33 A9 9C AD 9C B1 9C B5 9C B9 9C BD
9C C1 9C C5 9C C9 9C CD 9C D1 9C D5 9C D9 9C DD
9C E1 9C E5 89

Enigma protector 1.10 (unregistered)
128
60 72 80 72 88 72 8C 72 90 72 94 72 98 72 9C 72
A0 72 A4 59 A8 B0 5C E8 39 D5 39 E4 39 F1 31 F9
5C 3D 58 CA 5F 56 B1 2D 20 7A 2E 30 16 32 72 2B
72 36 1C A5 33 A9 9C AD 9C B1 9C B5 9C B9 9C BD
9C C1 9C C5 9C C9 9C CD 9C D1 9C D5 9C D9 9C DD
9C E1 9C E5 89 E9 51 0B C4 80 BC 7E 35 09 37 E7
C9 3D C9 45 C9 4D 74 92 BA E4 E9 24 6B DF 3E 0E
38 0C 49 10 27 80 51 A1 8E 3A A3 C8 AE 3B 1C 35

Enigma protector 1.10/1.11 -> Vladimir Sukhov
85
60 E8 00 00 00 00 5D 83 ED 06 81 ED ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 9A 83 C4 04 EB 02 FF 35 60 E8 24 00
00 00 00 00 FF EB 02 CD 20 8B 44 24 0C 83 80 B8
00 00 00 03 31

Enigma protector 1.10/1.11 -> Vladimir Sukhov
287
60 E8 00 00 00 00 5D 83 ED 06 81 ED ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 9A 83 C4 04 EB 02 FF 35 60 E8 24 00
00 00 00 00 FF EB 02 CD 20 8B 44 24 0C 83 80 B8
00 00 00 03 31 C0 C3 83 C0 08 EB 02 FF 15 89 C4
61 EB 2E EA EB 2B 83 04 24 03 EB 01 00 31 C0 EB
01 85 64 FF 30 EB 01 83 64 89 20 EB 02 CD 20 89
00 9A 64 8F 05 00 00 00 00 EB 02 C1 90 58 61 EB
01 3E EB ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8 01 00 00
00 9A 83 C4 04 01 E8 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? E8 01 00 00 00 9A 83 C4 04 05
F6 01 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? E8 01 00 00 00 9A 83 C4 04 B9 3D 1A

Enigma protector 1.12 -> Vladimir Sukhov
287
60 E8 00 00 00 00 5D 83 ED 06 81 ED ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 9A 83 C4 04 EB 02 FF 35 60 E8 24 00
00 00 00 00 FF EB 02 CD 20 8B 44 24 0C 83 80 B8
00 00 00 03 31 C0 C3 83 C0 08 EB 02 FF 15 89 C4
61 EB 2E EA EB 2B 83 04 24 03 EB 01 00 31 C0 EB
01 85 64 FF 30 EB 01 83 64 89 20 EB 02 CD 20 89
00 9A 64 8F 05 00 00 00 00 EB 02 C1 90 58 61 EB
01 3E EB 04 ?? ?? ?? ?? B8 ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8 01 00 00
00 9A 83 C4 04 01 E8 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? E8 01 00 00 00 9A 83 C4 04 05
F6 01 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? E8 01 00 00 00 9A 83 C4 04 B9 44 1A

Enigma Protector 1.1X-1.3X -> Sukhov Vladimir & Serge N. Markin
24
55 8B EC 83 C4 F0 B8 00 10 40 00 E8 01 00 00 00
9A 83 C4 10 8B E5 5D E9

Enigma Protector 1.31 Build 20070615 Dll -> Sukhov Vladimir & Serge N. Markin
167
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 81 ED ??
?? ?? ?? E9 49 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 8A 84 24 28 00 00 00 80 F8 01 0F 84 07 00 00
00 B8 ?? ?? ?? ?? FF E0 E9 04 00 00 00 ?? ?? ??
?? B8 ?? ?? ?? ?? 03 C5 81 C0 ?? ?? ?? ?? B9 ??
?? ?? ?? BA ?? ?? ?? ?? 30 10 40 49 0F 85 F6 FF
FF FF E9 04 00 00 00

Enigma Protector 1.X -> Sukhov Vladimir & Serge N. Markin
170
00 00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00
00 00 56 69 72 74 75 61 6C 46 72 65 65 00 00 00
47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41
00 00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73
73 00 00 00 45 78 69 74 50 72 6F 63 65 73 73 00
00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
00 4D 65 73 73 61 67 65 42 6F 78 41 00 00 00 52
65 67 43 6C 6F 73 65 4B 65 79 00 00 00 53 79 73
46 72 65 65 53 74 72 69 6E 67 00 00 00 43 72 65
61 74 65 46 6F 6E 74 41 00 00 00 53 68 65 6C 6C
45 78 65 63 75 74 65 41 00 00

ENIGMA Protector V1.1-> Sukhov Vladimir
11
60 E8 00 00 00 00 5D 83 ?? ?? 81

ENIGMA Protector V1.1-V1.2-> Sukhov Vladimir
11
60 E8 00 00 00 00 5D 83 ED 06 81

Enigma Protector v1.12 LITE
85
60 E8 00 00 00 00 5D 83 ED 06 81 ED ?? ?? ?? 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 9A 83 C4 04 EB 02 FF 35 60 E8 24 00
00 00 00 00 FF EB 02 CD 20 8B 44 24 0C 83 80 B8
00 00 00 03 31

ENIGMA Protector V1.12-> Sukhov Vladimir
85
60 E8 00 00 00 00 5D 83 C5 FA 81 ED ?? ?? ?? 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8
01 00 00 00 9A 83 C4 04 EB 02 FF 35 60 E8 24 00
00 00 00 00 FF EB 02 CD 20 8B 44 24 0C 83 80 B8
00 00 00 03 31

EP v1.0
85
50 83 C0 17 8B F0 97 33 C0 33 C9 B1 24 AC 86 C4
AC AA 86 C4 AA E2 F6 00 B8 40 00 03 00 3C 40 D2
33 8B 66 14 50 70 8B 8D 34 02 44 8B 18 10 48 70
03 BA 0C ?? ?? ?? ?? C0 33 FE 8B 30 AC 30 D0 C1
F0 10 C2 D0 30 F0 30 C2 C1 AA 10 42 42 CA C1 E2
04 5F E9 5E B1

EPW v1.2
29
06 57 1E 56 55 52 51 53 50 2E ?? ?? ?? ?? 8C C0
05 ?? ?? 2E ?? ?? ?? 8E D8 A1 ?? ?? 2E

EPW v1.30
20
06 57 1E 56 55 52 51 53 50 2E 8C 06 08 00 8C C0
83 C0 10 2E

Escargot 0.1 (final) -> ++Meat
150
EB 04 40 30 2E 31 60 68 61 ?? ?? ?? 64 FF 35 00
00 00 00 64 89 25 00 00 00 00 B8 92 ?? ?? ?? 8B
00 FF D0 50 B8 CD ?? ?? ?? 81 38 DE C0 37 13 75
2D 68 C9 ?? ?? ?? 6A 40 68 00 ?? 00 00 68 00 00
?? ?? B8 96 ?? ?? ?? 8B 00 FF D0 8B 44 24 F0 8B
4C 24 F4 EB 05 49 C6 04 01 40 0B C9 75 F7 BE 00
10 ?? ?? B9 00 ?? ?? 00 EB 05 49 80 34 31 40 0B
C9 75 F7 58 0B C0 74 08 33 C0 C7 00 DE C0 AD 0B
BE ?? ?? ?? ?? E9 AC 00 00 00 8B 46 0C BB 00 00
?? ?? 03 C3 50 50

Escargot 0.1 - by ueMeat
163
EB 08 28 65 73 63 30 2E 31 29 60 68 2B ?? ?? ??
64 FF 35 00 00 00 00 64 89 25 00 00 00 00 B8 5C
?? ?? ?? 8B 00 FF D0 50 BE 00 10 ?? ?? B9 00 ??
?? 00 EB 05 49 80 34 31 40 0B C9 75 F7 58 0B C0
74 08 33 C0 C7 00 DE C0 AD 0B BE ?? ?? ?? ?? E9
AC 00 00 00 8B 46 0C BB 00 00 ?? ?? 03 C3 50 50
B8 54 ?? ?? ?? 8B 00 FF D0 5F 80 3F 00 74 06 C6
07 00 47 EB F5 33 FF 8B 16 0B D2 75 03 8B 56 10
03 D3 03 D7 8B 0A C7 02 00 00 00 00 0B C9 74 4B
F7 C1 00 00 00 80 74 14 81 E1 FF FF 00 00 50 51
50 B8 50

Escargot V0.1 -> ++Meat
9
EB 04 40 30 2E 31 60 68 61

Excalibur 1.03 -> forgot
18
E9 00 00 00 00 60 E8 14 00 00 00 5D 81 ED 00 00
00 00

Excalibur V1.03 -> forgot
35
E9 00 00 00 00 60 E8 14 00 00 00 5D 81 ED 00 00
00 00 6A 45 E8 A3 00 00 00 68 00 00 00 00 E8 58
61 EB 39

eXcalibur v1.03 -> forgot/us
85
E9 00 00 00 00 60 E8 14 00 00 00 5D 81 ED 00 00
00 00 6A 45 E8 A3 00 00 00 68 00 00 00 00 E8 58
61 EB 39 20 45 78 63 61 6C 69 62 75 72 20 28 63
29 20 62 79 20 66 6F 72 67 6F 74 2F 75 53 2F 44
46 43 47 20 20 20 20 20 20 20 20 20 20 20 20 20
20 20 20 20 20

Exe Guarder v1.8 -> Exeicon.com
85
55 8B EC 83 C4 D0 53 56 57 8D 75 FC 8B 44 24 30
25 00 00 FF FF 81 38 4D 5A 90 00 74 07 2D 00 10
00 00 EB F1 89 45 FC E8 C8 FF FF FF 2D B2 04 00
00 89 45 F4 8B 06 8B 40 3C 03 06 8B 40 78 03 06
8B C8 8B 51 20 03 16 8B 59 24 03 1E 89 5D F0 8B
59 1C 03 1E 89

EXE joiner -> Amok
12
A1 14 A1 40 00 C1 E0 02 A3 18 A1 40

Exe Locker 1.0 -> IonIce
16
E8 00 00 00 00 60 8B 6C 24 20 81 ED 05 00 00 00

Exe Locker v1.0 --> IonIce
64
E8 00 00 00 00 60 8B 6C 24 20 81 ED 05 00 00 00
3E 8F 85 6C 00 00 00 3E 8F 85 68 00 00 00 3E 8F
85 64 00 00 00 3E 8F 85 60 00 00 00 3E 8F 85 5C
00 00 00 3E 8F 85 58 00 00 00 3E 8F 85 54 00 00

EXE Manager Version 3.0 1994 (c) Solar Designer
23
B4 30 1E 06 CD 21 2E ?? ?? ?? BF ?? ?? B9 ?? ??
33 C0 2E ?? ?? 47 E2

EXE Packer v7.0 by TurboPower Software
24
1E 06 8C C3 83 ?? ?? 2E ?? ?? ?? ?? B9 ?? ?? 8C
C8 8E D8 8B F1 4E 8B FE

EXE Shield v0.1b - v0.3b, v0.3 -> SMoKE
12
E8 04 00 00 00 83 60 EB 0C 5D EB 05

EXE Shield V0.5 -> Smoke
85
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D 81 ED BC 1A 40
00 EB 01 00 8D B5 46 1B 40 00 BA B3 0A 00 00 EB
01 00 8D 8D F9 25 40 00 8B 09 E8 14 00 00 00 83
EB 01 00 8B FE E8 00 00 00 00 58 83 C0 07 50 C3
00 EB 04 58 40

EXE Shield V0.5 -> Smoke
164
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D 81 ED BC 1A 40
00 EB 01 00 8D B5 46 1B 40 00 BA B3 0A 00 00 EB
01 00 8D 8D F9 25 40 00 8B 09 E8 14 00 00 00 83
EB 01 00 8B FE E8 00 00 00 00 58 83 C0 07 50 C3
00 EB 04 58 40 50 C3 8A 06 46 EB 01 00 D0 C8 E8
14 00 00 00 83 EB 01 00 2A C2 E8 00 00 00 00 5B
83 C3 07 53 C3 00 EB 04 5B 43 53 C3 EB 01 00 32
C2 E8 0B 00 00 00 00 32 C1 EB 01 00 C0 C0 02 EB
09 2A C2 5B EB 01 00 43 53 C3 88 07 EB 01 00 47
4A 75 B4 90

EXE Shield V0.6 -> SMoKE
85
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D 81 ED D4 1A 40
00 EB 01 00 8D B5 5E 1B 40 00 BA A1 0B 00 00 EB
01 00 8D 8D FF 26 40 00 8B 09 E8 14 00 00 00 83
EB 01 00 8B FE E8 00 00 00 00 58 83 C0 07 50 C3
00 EB 04 58 40

EXE Shield V0.6 -> SMoKE
164
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D 81 ED D4 1A 40
00 EB 01 00 8D B5 5E 1B 40 00 BA A1 0B 00 00 EB
01 00 8D 8D FF 26 40 00 8B 09 E8 14 00 00 00 83
EB 01 00 8B FE E8 00 00 00 00 58 83 C0 07 50 C3
00 EB 04 58 40 50 C3 8A 06 46 EB 01 00 D0 C8 E8
14 00 00 00 83 EB 01 00 2A C2 E8 00 00 00 00 5B
83 C3 07 53 C3 00 EB 04 5B 43 53 C3 EB 01 00 32
C2 E8 0B 00 00 00 00 32 C1 EB 01 00 C0 C0 02 EB
09 2A C2 5B EB 01 00 43 53 C3 88 07 EB 01 00 47
4A 75 B4 90

Exe Shield v1.7
32
EB 06 68 90 1F 06 00 C3 9C 60 E8 02 00 00 00 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90

Exe Shield v2.7
14
EB 06 68 F4 86 06 00 C3 9C 60 E8 02 00 00

Exe Shield v2.7b
85
EB 06 68 40 85 06 00 C3 9C 60 E8 02 00 00 00 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90
40 00 87 DD 8B 85 E6 90 40 00 01 85 33 90 40 00
66 C7 85 30 90 40 00 90 90 01 85 DA 90 40 00 01
85 DE 90 40 00 01 85 E2 90 40 00 BB 7B 11 00 00
03 9D EA 90 40

Exe Shield v2.9
31
60 E8 00 00 00 00 5D 81 ED 0B 20 40 00 B9 EB 08
00 00 8D BD 53 20 40 00 8B F7 AC ?? ?? ?? F8

Exe Shield vx.x
13
65 78 65 73 68 6C 2E 64 6C 6C C0 5D 00

Exe Stealth 2.75a -> WebtoolMaster
85
EB 58 53 68 61 72 65 77 61 72 65 2D 56 65 72 73
69 6F 6E 20 45 78 65 53 74 65 61 6C 74 68 2C 20
63 6F 6E 74 61 63 74 20 73 75 70 70 6F 72 74 40
77 65 62 74 6F 6F 6C 6D 61 73 74 65 72 2E 63 6F
6D 20 2D 20 77 77 77 2E 77 65 62 74 6F 6F 6C 6D
61 73 74 65 72

EXE Stealth v1.1
21
60 E8 00 00 00 00 5D 81 ED FB 1D 40 00 B9 7B 09
00 00 8B F7 AC

EXE Stealth v2.5
64
60 90 EB 22 45 78 65 53 74 65 61 6C 74 68 20 2D
20 77 77 77 2E 77 65 62 74 6F 6F 6C 6D 61 73 74
65 72 2E 63 6F 6D E8 00 00 00 00 5D 81 ED 40 1E
40 00 B9 99 09 00 00 8D BD 88 1E 40 00 8B F7 AC

EXE Stealth v2.7
16
EB 00 60 EB 00 E8 00 00 00 00 5D 81 ED D3 26 40

EXE Stealth v2.71
16
EB 00 60 EB 00 E8 00 00 00 00 5D 81 ED B0 27 40

EXE Stealth v2.72
16
EB 00 EB 2F 53 68 61 72 65 77 61 72 65 20 2D 20

EXE Stealth v2.73
85
EB 00 EB 2F 53 68 61 72 65 77 61 72 65 20 2D 20
45 78 65 53 74 65 61 6C 74 68 00 EB 16 77 77 77
2E 77 65 62 74 6F 6F 6C 6D 61 73 74 65 72 2E 63
6F 6D 00 60 90 E8 00 00 00 00 5D 81 ED F0 27 40
00 B9 15 00 00 00 83 C1 05 EB 05 EB FE 83 C7 56
EB 00 83 E9 02

EXE Stealth v2.74
85
EB 00 EB 17 53 68 61 72 65 77 61 72 65 20 2D 20
45 78 65 53 74 65 61 6C 74 68 00 60 90 E8 00 00
00 00 5D 81 ED C4 27 40 00 B9 15 00 00 00 83 C1
04 83 C1 01 EB 05 EB FE 83 C7 56 EB 00 83 E9 02
81 C1 78 43 27 65 EB 00 81 C1 10 25 94 00 81 E9
63 85 00 00 B9

EXE Stealth v2.74 -> WebToolMaster
35
EB 00 EB 17 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 60 90 E8 00 00
00 00 5D

EXE Stealth v2.76 -> WebToolMaster
64
EB 65 45 78 65 53 74 65 61 6C 74 68 20 56 32 20
2D 20 77 77 77 2E 77 65 62 74 6F 6F 6C 6D 61 73
74 65 72 2E 63 6F 6D 20 59 4F 55 52 20 41 44 20
48 45 52 45 21 50 69 52 41 43 59 20 69 53 20 41

EXE32Pack v1.36
45
3B C0 74 02 81 83 55 3B C0 74 02 81 83 53 3B C9
74 01 BC ?? ?? ?? ?? 02 81 ?? ?? ?? ?? ?? ?? ??
3B DB 74 01 BE 5D 8B D5 81 ED CC 8D 40

EXE32Pack v1.37
45
3B C0 74 02 81 83 55 3B C0 74 02 81 83 53 3B C9
74 01 BC ?? ?? ?? ?? 02 81 ?? ?? ?? ?? ?? ?? ??
3B DB 74 01 BE 5D 8B D5 81 ED 4C 8E 40

EXE32Pack v1.38
45
3B C0 74 02 81 83 55 3B C0 74 02 81 83 53 3B C9
74 01 BC ?? ?? ?? ?? 02 81 ?? ?? ?? ?? ?? ?? ??
3B DB 74 01 BE 5D 8B D5 81 ED DC 8D 40

EXE32Pack v1.39
45
3B C0 74 02 81 83 55 3B C0 74 02 81 83 53 3B C9
74 01 BC ?? ?? ?? ?? 02 81 ?? ?? ?? ?? ?? ?? ??
3B DB 74 01 BE 5D 8B D5 81 ED EC 8D 40

EXE32Pack v1.3x
41
3B ?? 74 02 81 83 55 3B ?? 74 02 81 ?? 53 3B ??
74 01 ?? ?? ?? ?? ?? 02 81 ?? ?? E8 ?? ?? ?? ??
3B 74 01 ?? 5D 8B D5 81 ED

ExeBundle v3.0 (small loader)
62
00 00 00 00 60 BE 00 F0 40 00 8D BE 00 20 FF FF
57 83 CD FF EB 10 90 90 90 90 90 90 8A 06 46 88
07 47 01 DB 75 07 8B 1E 83 EE FC 11 DB 72 ED B8
01 00 00 00 01 DB 75 07 8B 1E 83 EE FC 11

ExeBundle v3.0 (standard loader)
62
00 00 00 00 60 BE 00 B0 42 00 8D BE 00 60 FD FF
C7 87 B0 E4 02 00 31 3C 4B DF 57 83 CD FF EB 0E
90 90 90 90 8A 06 46 88 07 47 01 DB 75 07 8B 1E
83 EE FC 11 DB 72 ED B8 01 00 00 00 01 DB

EXECrypt 1.0 -> ReBirth
75
90 90 60 E8 00 00 00 00 5D 81 ED D1 27 40 00 B9
15 00 00 00 83 C1 04 83 C1 01 EB 05 EB FE 83 C7
56 EB 00 EB 00 83 E9 02 81 C1 78 43 27 65 EB 00
81 C1 10 25 94 00 81 E9 63 85 00 00 B9 96 0C 00
00 90 8D BD 4E 28 40 00 8B F7 AC

EXECryptor 2.0/2.1 (protected IAT)
209
A4 ?? ?? ?? 00 00 00 00 FF FF FF FF 3C ?? ?? ??
94 ?? ?? ?? D8 ?? ?? ?? 00 00 00 00 FF FF FF FF
B8 ?? ?? ?? D4 ?? ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 6B 65 72 6E
65 6C 33 32 2E 64 6C 6C 00 00 00 00 00 00 47 65
74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00
00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 00 00 00 00 45 78 69 74 50 72 6F 63 65 73
73 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? 00 60 ?? ?? ?? 70 ?? ?? ??
84 ?? ?? ?? 00 00 00 00 75 73 65 72 33 32 2E 64
6C 6C 00 00 00 00 4D 65 73 73 61 67 65 42 6F 78
41

EXECryptor 2.1.17 -> Strongbit/SoftComplete Development
85
BE ?? ?? ?? ?? B8 00 00 ?? ?? 89 45 FC 89 C2 8B
46 0C 09 C0 0F 84 ?? 00 00 00 01 D0 89 C3 50 FF
15 94 ?? ?? ?? 09 C0 0F 85 0F 00 00 00 53 FF 15
98 ?? ?? ?? 09 C0 0F 84 ?? 00 00 00 89 45 F8 6A
00 8F 45 F4 8B 06 09 C0 8B 55 FC 0F 85 03 00 00
00 8B 46 10 01

EXECryptor 2.2.4 -> Strongbit/SoftComplete Development (h1)
35
E8 F7 FE FF FF 05 ?? ?? 00 00 FF E0 E8 EB FE FF
FF 05 ?? ?? 00 00 FF E0 E8 04 00 00 00 FF FF FF
FF 5E C3

EXECryptor 2.2.4 -> Strongbit/SoftComplete Development (h2)
29
E8 F7 FE FF FF 05 ?? ?? 00 00 FF E0 E8 EB FE FF
FF 05 ?? ?? 00 00 FF E0 E8 ?? 00 00 00

EXECryptor 2.2.4 -> Strongbit/SoftComplete Development (h3)
85
6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00
00 00 47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C
65 41 00 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 00 47 65 74 50 72 6F 63 41 64 64
72 65 73 73 00 00 00 00 00 00 45 78 69 74 50 72
6F 63 65 73 73

EXECryptor 2.2.6 (minimum protection)
338
50 68 ?? ?? ?? ?? 58 81 E0 ?? ?? ?? ?? E9 ?? ??
?? 00 87 0C 24 59 E8 ?? ?? ?? 00 89 45 F8 E9 ??
?? ?? ?? 0F 83 ?? ?? ?? 00 E9 ?? ?? ?? ?? 87 14
24 5A 57 68 ?? ?? ?? ?? E9 ?? ?? ?? ?? 58 81 C0
?? ?? ?? ?? 2B 05 ?? ?? ?? ?? 81 C8 ?? ?? ?? ??
81 E0 ?? ?? ?? ?? E9 ?? ?? ?? 00 C3 E9 ?? ?? ??
?? C3 BF ?? ?? ?? ?? 81 CB ?? ?? ?? ?? BA ?? ??
?? ?? 52 E9 ?? ?? ?? 00 E8 ?? ?? ?? 00 E9 ?? ??
?? 00 E9 ?? ?? ?? ?? 87 34 24 5E 66 8B 00 66 25
?? ?? E9 ?? ?? ?? ?? 8B CD 87 0C 24 8B EC 51 89
EC 5D 8B 05 ?? ?? ?? ?? 09 C0 E9 ?? ?? ?? ?? 59
81 C1 ?? ?? ?? ?? C1 C1 ?? 23 0D ?? ?? ?? ?? 81
F9 ?? ?? ?? ?? E9 ?? ?? ?? ?? C3 E9 ?? ?? ?? 00
13 D0 0B F9 E9 ?? ?? ?? ?? 51 E8 ?? ?? ?? ?? 8B
64 24 08 31 C0 64 8F 05 00 00 00 00 5A E9 ?? ??
?? ?? 3C A4 0F 85 ?? ?? ?? 00 8B 45 FC 66 81 38
?? ?? 0F 84 05 00 00 00 E9 ?? ?? ?? ?? 0F 84 ??
?? ?? ?? E9 ?? ?? ?? ?? 87 3C 24 5F 31 DB 31 C9
31 D2 68 ?? ?? ?? ?? E9 ?? ?? ?? ?? 89 45 FC 33
C0 89 45 F4 83 7D FC 00 E9 ?? ?? ?? ?? 53 52 8B
D1 87 14 24 81 C0 ?? ?? ?? ?? 0F 88 ?? ?? ?? ??
3B CB

EXECryptor 2.2.6 DLL (minimum protection)
192
50 8B C6 87 04 24 68 ?? ?? ?? ?? 5E E9 ?? ?? ??
?? 85 C8 E9 ?? ?? ?? ?? 81 C3 ?? ?? ?? ?? 0F 81
?? ?? ?? 00 81 FA ?? ?? ?? ?? 33 D0 E9 ?? ?? ??
00 0F 8D ?? ?? ?? 00 81 D5 ?? ?? ?? ?? F7 D1 0B
15 ?? ?? ?? ?? C1 C2 ?? 81 C2 ?? ?? ?? ?? 9D E9
?? ?? ?? ?? C1 E2 ?? C1 E8 ?? 81 EA ?? ?? ?? ??
13 DA 81 E9 ?? ?? ?? ?? 87 04 24 8B C8 E9 ?? ??
?? ?? 55 8B EC 83 C4 F8 89 45 FC 8B 45 FC 89 45
F8 8B 45 08 E9 ?? ?? ?? ?? 8B 45 E0 C6 00 00 FF
45 E4 E9 ?? ?? ?? ?? FF 45 E4 E9 ?? ?? ?? 00 F7
D3 0F 81 ?? ?? ?? ?? E9 ?? ?? ?? ?? 87 34 24 5E
8B 45 F4 E8 ?? ?? ?? 00 8B 45 F4 8B E5 5D C3 E9

EXECryptor 2.2/2.3 (compressed code) -> www.strongbit.com
85
E8 00 00 00 00 58 ?? ?? ?? ?? ?? 8B 1C 24 81 EB
?? ?? ?? ?? B8 ?? ?? ?? ?? 50 6A 04 68 00 10 00
00 50 6A 00 B8 C4 ?? ?? ?? 8B 04 18 FF D0 59 BA
?? ?? ?? ?? 01 DA 52 53 50 89 C7 89 D6 FC F3 A4
B9 ?? ?? ?? ?? 01 D9 FF D1 58 8B 1C 24 68 00 80
00 00 6A 00 50

EXECryptor 2.2/2.3 (compressed code) -> www.strongbit.com
192
E8 00 00 00 00 58 ?? ?? ?? ?? ?? 8B 1C 24 81 EB
?? ?? ?? ?? B8 ?? ?? ?? ?? 50 6A 04 68 00 10 00
00 50 6A 00 B8 C4 ?? ?? ?? 8B 04 18 FF D0 59 BA
?? ?? ?? ?? 01 DA 52 53 50 89 C7 89 D6 FC F3 A4
B9 ?? ?? ?? ?? 01 D9 FF D1 58 8B 1C 24 68 00 80
00 00 6A 00 50 B8 C8 ?? ?? ?? 8B 04 18 FF D0 59
58 5B 83 EB 05 C6 03 B8 43 89 03 83 C3 04 C6 03
C3 09 C9 74 46 89 C3 E8 A0 00 00 00 FC AD 83 F8
FF 74 38 53 89 CB 01 C3 01 0B 83 C3 04 AC 3C FE
73 07 25 FF 00 00 00 EB ED 81 C3 FE 00 00 00 09
C0 7A 09 66 AD 25 FF FF 00 00 EB DA AD 4E 25 FF
FF FF 00 3D FF FF FF 00 75 CC ?? ?? ?? ?? ?? C3

EXECryptor 2.2/2.3 (protected IAT)
256
CC ?? ?? ?? 00 00 00 00 FF FF FF FF 3C ?? ?? ??
B4 ?? ?? ?? 08 ?? ?? ?? 00 00 00 00 FF FF FF FF
E8 ?? ?? ?? 04 ?? ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 6B 65 72 6E
65 6C 33 32 2E 64 6C 6C 00 00 00 00 00 00 47 65
74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00
00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 00 00 00 00 45 78 69 74 50 72 6F 63 65 73
73 00 00 00 00 00 56 69 72 74 75 61 6C 41 6C 6C
6F 63 00 00 00 00 56 69 72 74 75 61 6C 46 72 65
65 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 4C ?? ?? ??
60 ?? ?? ?? 70 ?? ?? ?? 84 ?? ?? ?? 94 ?? ?? ??
A4 ?? ?? ?? 00 00 00 00 75 73 65 72 33 32 2E 64
6C 6C 00 00 00 00 4D 65 73 73 61 67 65 42 6F 78

EXECryptor 2.3.9 (compressed resources)
288
51 68 ?? ?? ?? ?? 59 81 F1 12 3C CB 98 E9 53 2C
00 00 F7 D7 E9 EB 60 00 00 83 45 F8 02 E9 E3 36
00 00 F6 45 F8 20 0F 84 1E 21 00 00 55 E9 80 62
00 00 87 0C 24 8B E9 ?? ?? ?? ?? 00 00 23 C1 81
E9 ?? ?? ?? ?? 57 E9 ED 00 00 00 0F 88 ?? ?? ??
?? E9 2C 0D 00 00 81 ED BB 43 CB 79 C1 E0 1C E9
9E 14 00 00 0B 15 ?? ?? ?? ?? 81 E2 2A 70 7F 49
81 C2 9D 83 12 3B E8 0C 50 00 00 E9 A0 16 00 00
59 5B C3 64 FF 35 00 00 00 00 64 89 25 00 00 00
00 E8 41 42 00 00 E9 93 33 00 00 31 DB 89 D8 59
5B C3 A1 ?? ?? ?? ?? 8A 00 2C 99 E9 82 30 00 00
0F 8A ?? ?? ?? ?? B8 01 00 00 00 31 D2 0F A2 25
FF 0F 00 00 E9 72 21 00 00 0F 86 57 0B 00 00 E9
?? ?? ?? ?? C1 C0 03 E8 F0 36 00 00 E9 41 0A 00
00 81 F7 B3 6E 85 EA 81 C7 ?? ?? ?? ?? 87 3C 24
E9 74 52 00 00 0F 8E ?? ?? ?? ?? E8 5E 37 00 00
68 B1 74 96 13 5A E9 A1 04 00 00 81 D1 49 C0 12
27 E9 50 4E 00 00 C1 C8 1B 1B C3 81 E1 96 36 E5

EXECryptor 2.3.9 (minimum protection)
256
68 ?? ?? ?? ?? E9 ?? ?? ?? FF 50 C1 C8 18 89 05
?? ?? ?? ?? C3 C1 C0 18 51 E9 ?? ?? ?? FF 84 C0
0F 84 6A F9 FF FF E9 ?? ?? ?? FF C3 E9 ?? ?? ??
FF E8 CF E9 FF FF B8 01 00 00 00 E9 ?? ?? ?? FF
2B D0 68 A0 36 80 D4 59 81 C9 64 98 FF 99 E9 ??
?? ?? FF 84 C0 0F 84 8E EC FF FF E9 ?? ?? ?? FF
C3 87 3C 24 5F 8B 00 03 45 FC 83 C0 18 E9 ?? ??
?? FF 87 0C 24 59 B8 01 00 00 00 D3 E0 23 D0 E9
02 18 00 00 0F 8D DB 00 00 00 C1 E8 14 E9 CA 00
00 00 9D 87 0C 24 59 87 1C 24 68 AE 73 B9 96 E9
C5 10 00 00 0F 8A ?? ?? ?? ?? E9 ?? ?? ?? FF 81
FD F5 FF 8F 07 E9 4F 10 00 00 C3 E9 5E 12 00 00
87 3C 24 E9 ?? ?? ?? FF E8 ?? ?? ?? FF 83 3D ??
?? ?? ?? 00 0F 85 ?? ?? ?? ?? 8D 55 EC B8 ?? ??
?? ?? E9 ?? ?? ?? FF E8 A7 1A 00 00 E8 2A CB FF
FF E9 ?? ?? ?? FF C3 E9 ?? ?? ?? FF 59 89 45 E0

EXECryptor 2.3.9 DLL (compressed resources)
206
50 68 ?? ?? ?? ?? 58 C1 C0 0F E9 ?? ?? ?? 00 87
04 24 58 89 45 FC E9 ?? ?? ?? FF FF 05 ?? ?? ??
?? E9 ?? ?? ?? 00 C1 C3 18 E9 ?? ?? ?? ?? 8B 55
08 09 42 F8 E9 ?? ?? ?? FF 83 7D F0 01 0F 85 ??
?? ?? ?? E9 ?? ?? ?? 00 87 34 24 5E 8B 45 FC 33
D2 56 8B F2 E9 ?? ?? ?? 00 BA ?? ?? ?? ?? E8 ??
?? ?? 00 A3 ?? ?? ?? ?? C3 E9 ?? ?? ?? 00 C3 83
C4 04 C3 E9 ?? ?? ?? FF 64 FF 35 00 00 00 00 64
89 25 00 00 00 00 E8 ?? ?? ?? 00 E9 ?? ?? ?? FF
C1 C2 03 81 CA ?? ?? ?? ?? 81 C2 ?? ?? ?? ?? 03
C2 5A E9 ?? ?? ?? FF 81 E7 ?? ?? ?? ?? 81 EF ??
?? ?? ?? 81 C7 ?? ?? ?? ?? 89 07 E9 ?? ?? ?? ??
0F 89 ?? ?? ?? ?? 87 14 24 5A 50 C1 C8 10

EXECryptor 2.3.9 DLL (minimum protection)
224
51 68 ?? ?? ?? ?? 87 2C 24 8B CD 5D 81 E1 ?? ??
?? ?? E9 ?? ?? ?? 00 89 45 F8 51 68 ?? ?? ?? ??
59 81 F1 ?? ?? ?? ?? 0B 0D ?? ?? ?? ?? 81 E9 ??
?? ?? ?? E9 ?? ?? ?? 00 81 C2 ?? ?? ?? ?? E8 ??
?? ?? 00 87 0C 24 59 51 64 8B 05 30 00 00 00 8B
40 0C 8B 40 0C E9 ?? ?? ?? 00 F7 D6 2B D5 E9 ??
?? ?? 00 87 3C 24 8B CF 5F 87 14 24 1B CA E9 ??
?? ?? 00 83 C4 08 68 ?? ?? ?? ?? E9 ?? ?? ?? 00
C3 E9 ?? ?? ?? 00 E9 ?? ?? ?? 00 50 8B C5 87 04
24 8B EC 51 0F 88 ?? ?? ?? 00 FF 05 ?? ?? ?? ??
E9 ?? ?? ?? 00 87 0C 24 59 99 03 04 24 E9 ?? ??
?? 00 C3 81 D5 ?? ?? ?? ?? 9C E9 ?? ?? ?? 00 81
FA ?? ?? ?? ?? E9 ?? ?? ?? 00 C1 C3 15 81 CB ??
?? ?? ?? 81 F3 ?? ?? ?? ?? 81 C3 ?? ?? ?? ?? 87

EXECryptor 2.x -> SoftComplete Developement
32
A4 ?? ?? 00 00 00 00 00 FF FF FF FF 3C ?? ?? 00
94 ?? ?? 00 D8 ?? ?? 00 00 00 00 00 FF FF FF FF

EXECryptor 2.xx (compressed resources)
114
56 57 53 31 DB 89 C6 89 D7 0F B6 06 89 C2 83 E0
1F C1 EA 05 74 2D 4A 74 15 8D 5C 13 02 46 C1 E0
08 89 FA 0F B6 0E 46 29 CA 4A 29 C2 EB 32 C1 E3
05 8D 5C 03 04 46 89 FA 0F B7 0E 29 CA 4A 83 C6
02 EB 1D C1 E3 04 46 89 C1 83 E1 0F 01 CB C1 E8
05 73 07 43 89 F2 01 DE EB 06 85 DB 74 0E EB A9
56 89 D6 89 D9 F3 A4 31 DB 5E EB 9D 89 F0 5B 5F
5E C3

EXECryptor 2.xx (max. compressed resources)
192
55 8B EC 83 C4 EC FC 53 57 56 89 45 FC 89 55 F8
89 C6 89 D7 66 81 3E 4A 43 0F 85 23 01 00 00 83
C6 0A C7 45 F4 08 00 00 00 31 DB BA 00 00 00 80
43 31 C0 E8 11 01 00 00 73 0E 8B 4D F0 E8 1F 01
00 00 02 45 EF AA EB E9 E8 FC 00 00 00 0F 82 97
00 00 00 E8 F1 00 00 00 73 5B B9 04 00 00 00 E8
FD 00 00 00 48 74 DE 0F 89 C7 00 00 00 E8 D7 00
00 00 73 1B 55 BD 00 01 00 00 E8 D7 00 00 00 88
07 47 4D 75 F5 E8 BF 00 00 00 72 E9 5D EB A2 B9
01 00 00 00 E8 C8 00 00 00 83 C0 07 89 45 F0 C6
45 EF 00 83 F8 08 74 89 E8 A9 00 00 00 88 45 EF
E9 7C FF FF FF B9 07 00 00 00 E8 A2 00 00 00 50

EXECryptor v1.3.0.45
34
E8 24 00 00 00 8B 4C 24 0C C7 01 17 00 01 00 C7
81 ?? ?? ?? ?? ?? ?? ?? 31 C0 89 41 14 89 41 18
80 A1

EXECryptor v1.3.0.45
34
E8 24 ?? ?? ?? 8B 4C 24 0C C7 01 17 ?? 01 ?? C7
81 ?? ?? ?? ?? ?? ?? ?? 31 C0 89 41 14 89 41 18
80 A1

EXECryptor v1.4.0.1
34
E8 24 00 00 00 8B 4C 24 0C C7 01 17 00 01 00 C7
81 B8 00 00 00 00 ?? ?? 00 31 C0 89 41 14 89 41
18 80

EXECryptor v1.5.1.x
51
E8 24 ?? ?? ?? 8B 4C 24 0C C7 01 17 ?? 01 ?? C7
81 B8 ?? ?? ?? ?? ?? ?? ?? 31 C0 89 41 14 89 41
18 80 A1 C1 ?? ?? ?? FE C3 31 C0 64 FF 30 64 89
20 CC C3

EXECryptor v1.5.3
51
E8 24 00 00 00 8B 4C 24 0C C7 01 17 00 01 00 C7
81 B8 00 00 00 00 ?? ?? 00 31 C0 89 41 14 89 41
18 80 A1 C1 00 00 00 FE C3 31 C0 64 FF 30 64 89
20 CC C3

EXECryptor V2.1X -> softcomplete.com
11
83 C6 14 8B 55 FC E9 ?? FF FF FF

EXECryptor V2.1X -> softcomplete.com
25
E9 ?? ?? ?? ?? 66 9C 60 50 8D 88 ?? ?? ?? ?? 8D
90 04 16 ?? ?? 8B DC 8B E1

EXECryptor V2.2X -> softcomplete.com
14
FF E0 E8 04 00 00 00 FF FF FF FF 5E C3 00

EXECryptor vx.x.x.x
29
E8 24 ?? ?? ?? 8B 4C 24 0C C7 01 17 ?? 01 ?? C7
81 B8 ?? ?? ?? ?? ?? ?? ?? 31 C0 89 41

ExeJoiner 1.0 -> Yoda
164
68 00 10 40 00 68 04 01 00 00 E8 39 03 00 00 05
00 10 40 00 C6 00 5C 68 04 01 00 00 68 04 11 40
00 6A 00 E8 1A 03 00 00 6A 00 68 80 00 00 00 6A
03 6A 00 6A 01 68 00 00 00 80 68 04 11 40 00 E8
EC 02 00 00 83 F8 FF 0F 84 83 02 00 00 A3 08 12
40 00 6A 00 50 E8 E2 02 00 00 83 F8 FF 0F 84 6D
02 00 00 A3 0C 12 40 00 8B D8 83 EB 04 6A 00 6A
00 53 FF 35 08 12 40 00 E8 E3 02 00 00 6A 00 68
3C 12 40 00 6A 04 68 1E 12 40 00 FF 35 08 12 40
00 E8 C4 02 00 00 83 EB 04 6A 00 6A 00 53 FF 35
08 12 40 00

ExeJoiner 1.0 -> Yoda f2f
85
68 00 10 40 00 68 04 01 00 00 E8 39 03 00 00 05
00 10 40 00 C6 00 5C 68 04 01 00 00 68 04 11 40
00 6A 00 E8 1A 03 00 00 6A 00 68 80 00 00 00 6A
03 6A 00 6A 01 68 00 00 00 80 68 04 11 40 00 E8
EC 02 00 00 83 F8 FF 0F 84 83 02 00 00 A3 08 12
40 00 6A 00 50

EXEJoiner v1.0
35
68 00 10 40 00 68 04 01 00 00 E8 39 03 00 00 05
00 10 40 C6 00 5C 68 ?? ?? ?? ?? 68 ?? ?? ?? ??
6A 00 E8

ExeJoiner V1.0 -> Yoda f2f
28
68 00 10 40 00 68 04 01 00 00 E8 39 03 00 00 05
00 10 40 00 C6 00 5C 68 04 01 00 00

EXELOCK 666 1.5
31
BA ?? ?? BF ?? ?? EB ?? EA ?? ?? ?? ?? 79 ?? 7F
?? 7E ?? 1C ?? 48 78 ?? E3 ?? 45 14 ?? 5A E9

ExeLock v1.00
29
06 8C C8 8E C0 BE ?? ?? 26 ?? ?? 34 ?? 26 ?? ??
46 81 ?? ?? ?? 75 ?? 40 B3 ?? B3 ?? F3

EXEPACK (LINK) v3.60, v3.64, v3.65 or 5.01.21
34
8C C0 05 ?? ?? 0E 1F A3 ?? ?? 03 ?? ?? ?? 8E C0
8B ?? ?? ?? 8B ?? 4F 8B F7 FD F3 A4 50 B8 ?? ??
50 CB

EXEPACK v4.05, v4.06
28
8C C0 05 ?? ?? 0E 1F A3 ?? ?? 03 06 ?? ?? 8E C0
8B 0E ?? ?? 8B F9 4F 8B F7 FD F3 A4

EXERefactor V0.1 -> random
25
55 8B EC 81 EC 90 0B 00 00 53 56 57 E9 58 8C 01
00 55 53 43 41 54 49 4F 4E

ExeSafeguard v1.0 -> simonzh
85
C0 5D EB 4E EB 47 DF 69 4E 58 DF 59 74 F3 EB 01
DF 75 EE 9A 59 9C 81 C1 E2 FF FF FF EB 01 DF 9D
FF E1 E8 51 E8 EB FF FF FF DF 22 3F 9A C0 81 ED
19 18 40 00 EB 48 EB 47 DF 69 4E 58 DF 59 79 EE
EB 01 DF 78 E9 DF 59 9C 81 C1 E5 FF FF FF 9D FF
E1 EB 51 E8 EE

ExeShield 3.6 -> www.exeshield.com
85
B8 ?? ?? ?? 00 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 6F 6D 70 61 63
74 32 00 CE 1E 42 AF F8 D6 CC E9 FB C8 4F 1B 22
7C B4 C8 0D BD 71 A9 C8 1F 5F B1 29 8F 11 73 8F
00 D1 88 87 A9 3F 4D 00 6C 3C BF C0 80 F7 AD 35
23 EB 84 82 6F

ExeShield Cryptor 1.3RC -> Tom Commander
51
55 8B EC 53 56 57 60 E8 00 00 00 00 5D 81 ED 8C
21 40 00 B9 51 2D 40 00 81 E9 E6 21 40 00 8B D5
81 C2 E6 21 40 00 8D 3A 8B F7 33 C0 EB 04 90 EB
01 C2 AC

ExeShield Protector V3.6 -> www.exeshield.com
42
B8 ?? ?? ?? 00 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 6F 6D 70 61 63
74 32 00 CE 1E 42 AF F8 D6 CC

ExeSmasher vx.x
22
9C FE 03 ?? 60 BE ?? ?? 41 ?? 8D BE ?? 10 FF FF
57 83 CD FF EB 10

ExeSplitter 1.2 -> Bill Prisoner / TPOC
129
E9 95 02 00 00 64 A1 00 00 00 00 83 38 FF 74 04
8B 00 EB F7 8B 40 04 C3 55 8B EC B8 00 00 00 00
8B 75 08 81 E6 00 00 FF FF B9 06 00 00 00 56 56
E8 B0 00 00 00 5E 83 F8 01 75 06 8B C6 C9 C2 04
00 81 EE 00 00 01 00 E2 E5 C9 C2 04 00 55 8B EC
8B 75 0C 8B DE 03 76 3C 8D 76 18 8D 76 60 8B 36
03 F3 56 8B 76 20 03 F3 33 D2 8B C6 8B 36 03 F3
8B 7D 08 B9 0E 00 00 00 FC F3 A6 0B C9 75 02 EB
08

ExeSplitter 1.3 (Split Method) -> Bill Prisoner / TPOC
202
E8 00 00 00 00 5D 81 ED 08 12 40 00 E8 66 FE FF
FF 55 50 8D 9D 81 11 40 00 53 8D 9D 21 11 40 00
53 6A 08 E8 76 FF FF FF 6A 40 68 00 30 00 00 68
00 01 00 00 6A 00 FF 95 89 11 40 00 89 85 61 10
40 00 50 68 00 01 00 00 FF 95 85 11 40 00 8D 85
65 10 40 00 50 FF B5 61 10 40 00 FF 95 8D 11 40
00 6A 00 68 80 00 00 00 6A 02 6A 00 ?? ?? ?? ??
01 1F 00 FF B5 61 10 40 00 FF 95 91 11 40 00 89
85 72 10 40 00 6A 00 8D ?? ?? ?? ?? 00 50 FF B5
09 10 40 00 8D 85 F5 12 40 00 50 FF B5 72 10 40
00 FF 95 95 11 40 00 FF B5 72 10 40 00 FF 95 99
11 40 00 8D 85 0D 10 40 00 50 8D 85 1D 10 40 00
50 B9 07 00 00 00 6A 00 E2 FC

ExeSplitter 1.3 (Split Method) -> Bill Prisoner / TPOC
171
E9 FE 01 00 00 ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 73 76 63 45 72 30 31 31 2E 74 6D
70 00 00 00 00 00 00 00 00 00 64 A1 30 00 00 00
8B 40 0C 8B 40 0C 8B 00 85 C0 0F 84 5F 02 00 00
8B 48 30 80 39 6B 74 07 80 39 4B 74 02 EB E7 80
79 0C 33 74 02 EB DF 8B 40 18 C3

ExeSplitter 1.3 (Split+Crypt Method) -> Bill Prisoner / TPOC
148
15 10 05 23 14 56 57 57 48 12 0B 16 66 66 66 66
66 66 66 66 66 02 C7 56 66 66 66 ED 26 6A ED 26
6A ED 66 E3 A6 69 E2 39 64 66 66 ED 2E 56 E6 5F
0D 12 61 E6 5F 2D 12 64 8D 81 E6 1F 6A 55 12 64
8D B9 ED 26 7E A5 33 ED 8A 8D 69 21 03 12 36 14
09 05 27 02 02 14 03 15 15 27 ED 2B 6A ED 13 6E
ED B8 65 10 5A EB 10 7E EB 10 06 ED 50 65 95 30
ED 10 46 65 95 55 B4 ED A0 ED 50 65 95 37 ED 2B
6A EB DF AB 76 26 66 3F DF 68 66 66 66 9A 95 C0
6D AF 13 64

ExeSplitter 1.3 (Split+Crypt Method) -> Bill Prisoner / TPOC
42
E8 00 00 00 00 5D 81 ED 05 10 40 00 B9 ?? ?? ??
?? 8D 85 1D 10 40 00 80 30 66 40 E2 FA 8F 98 67
66 66 ?? ?? ?? ?? ?? ?? ?? 66

EXEStealth 2.75 -> WebtoolMaster
20
90 60 90 E8 00 00 00 00 5D 81 ED D1 27 40 00 B9
15 00 00 00

EXEStealth 2.76 Unregistered -> WebtoolMaster
26
EB ?? 45 78 65 53 74 65 61 6C 74 68 20 56 32 20
53 68 61 72 65 77 61 72 65 20

ExeTools COM2EXE
27
E8 ?? ?? 5D 83 ED ?? 8C DA 2E 89 96 ?? ?? 83 C2
?? 8E DA 8E C2 2E 01 96 ?? ?? 60

ExeTools v2.1 Encruptor by DISMEMBER
26
E8 ?? ?? 5D 83 ?? ?? 1E 8C DA 83 ?? ?? 8E DA 8E
C2 BB ?? ?? BA ?? ?? 85 D2 74

eXPressor 1.1 -> CGSoftLabs
35
E9 ?? ?? 00 00 E9 ?? ?? 00 00 E9 ?? 12 00 00 E9
?? 0C 00 00 E9 ?? ?? 00 00 E9 ?? ?? 00 00 E9 ??
?? 00 00

eXPressor 1.2 -> CGSoftLabs
26
55 8B EC 81 EC D4 01 00 00 53 56 57 EB 0C 45 78
50 72 2D 76 2E 31 2E 32 2E 2E

eXPressor 1.2.0 Beta PE Packer
26
55 8B EC 81 EC ?? ?? ?? ?? 53 56 57 EB ?? 45 78
50 72 2D 76 2E 31 2E 32 2E 2E

eXPressor V1.0 -> CGSoftLabs
40
E9 35 14 00 00 E9 31 13 00 00 E9 98 12 00 00 E9
EF 0C 00 00 E9 42 13 00 00 E9 E9 02 00 00 E9 EF
0B 00 00 E9 1B 0D 00 00

eXpressor v1.1 -> CGSoftLabs
35
E9 15 13 00 00 E9 F0 12 00 00 E9 58 12 00 00 E9
AF 0C 00 00 E9 AE 02 00 00 E9 B4 0B 00 00 E9 E0
0C 00 00

eXPressor v1.2 -> CGSoftLabs
11
45 78 50 72 2D 76 2E 31 2E 32 2E

eXpressor v1.2 -> CGSoftLabs
20
55 8B EC 81 EC D4 01 00 00 53 56 57 EB 0C 45 78
50 72 2D 76

eXPressor v1.2 -> CGSoftLabs
85
55 8B EC 81 EC D4 01 00 00 53 56 57 EB 0C 45 78
50 72 2D 76 2E 31 2E 32 2E 2E B8 ?? ?? ?? ?? 2B
05 84 ?? ?? ?? A3 ?? ?? ?? ?? 83 3D ?? ?? ?? ??
00 74 16 A1 ?? ?? ?? ?? 03 05 80 ?? ?? ?? 89 85
54 FE FF FF E9 ?? 07 00 00 C7 05 ?? ?? ?? ?? 01
00 00 00 68 04

eXPressor v1.2 -> CGSoftLabs
99
55 8B EC 81 EC D4 01 00 00 53 56 57 EB 0C 45 78
50 72 2D 76 2E 31 2E 32 2E 2E B8 ?? ?? ?? ?? 2B
05 84 ?? ?? ?? A3 ?? ?? ?? ?? 83 3D ?? ?? ?? ??
00 74 16 A1 ?? ?? ?? ?? 03 05 80 ?? ?? ?? 89 85
54 FE FF FF E9 ?? 07 00 00 C7 05 ?? ?? ?? ?? 01
00 00 00 68 04 01 00 00 8D 85 F0 FE FF FF 50 6A
00 FF 15

eXPressor v1.2.0b
85
55 8B EC 81 EC D4 01 00 00 53 56 57 EB 0C 45 78
50 72 2D 76 2E 31 2E 32 2E 2E B8 ?? ?? ?? 00 2B
05 84 ?? ?? 00 A3 ?? ?? ?? 00 83 3D ?? ?? ?? 00
00 74 16 A1 ?? ?? ?? 00 03 05 80 ?? ?? 00 89 85
54 FE FF FF E9 ?? 07 00 00 C7 05 ?? ?? ?? 00 01
00 00 00 68 04

eXPressor v1.3 -> CGSoftLabs
11
45 78 50 72 2D 76 2E 31 2E 33 2E

eXPressor V1.3 -> CGSoftLabs
12
55 8B EC 83 EC ?? 53 56 57 EB 0C 45

eXPressor v1.3 -> CGSoftLabs
69
55 8B EC 83 EC ?? 53 56 57 EB 0C 45 78 50 72 2D
76 2E 31 2E 33 2E 2E B8 ?? ?? ?? ?? 2B 05 ?? ??
?? ?? A3 ?? ?? ?? ?? 83 3D ?? ?? ?? ?? 00 74 13
A1 ?? ?? ?? ?? 03 05 ?? ?? ?? ?? 89 ?? ?? E9 ??
?? 00 00 C7 05

eXPressor v1.4 -> CGSoftLabs
24
55 8B EC 83 EC ?? 53 56 57 EB 0C 45 78 50 72 2D
76 2E 31 2E 34 2E 2E B8

eXPressor v1.4 -> CGSoftLabs
11
65 58 50 72 2D 76 2E 31 2E 34 2E

eXpressor v1.4.5 -> CGSoftLabs
16
55 8B EC 83 EC 58 53 56 57 83 65 DC 00 F3 EB 0C

eXPressor V1.4.5.1 -> CGSoftLabs
64
55 8B EC 83 EC 58 53 56 57 83 65 DC 00 F3 EB 0C
65 58 50 72 2D 76 2E 31 2E 34 2E 00 A1 00 ?? ??
00 05 00 ?? ?? 00 A3 08 ?? ?? 00 A1 08 ?? ?? 00
B9 81 ?? ?? 00 2B 48 18 89 0D 0C ?? ?? 00 83 3D

eXPressor v1.4.5.1 -> CGSoftLabs
85
55 8B EC 83 EC 58 53 56 57 83 65 DC 00 F3 EB 0C
65 58 50 72 2D 76 2E 31 2E 34 2E 00 A1 00 ?? ??
?? 05 00 ?? ?? ?? A3 08 ?? ?? ?? A1 08 ?? ?? ??
B9 81 ?? ?? ?? 2B 48 18 89 0D 0C ?? ?? ?? 83 3D
10 ?? ?? ?? 00 74 16 A1 08 ?? ?? ?? 8B 0D 0C ??
?? ?? 03 48 14

eXPressor v1.4.5.1 -> CGSoftLabs
88
55 8B EC 83 EC 58 53 56 57 83 65 DC 00 F3 EB 0C
65 58 50 72 2D 76 2E 31 2E 34 2E 00 A1 00 ?? ??
?? 05 00 ?? ?? ?? A3 08 ?? ?? ?? A1 08 ?? ?? ??
B9 81 ?? ?? ?? 2B 48 18 89 0D 0C ?? ?? ?? 83 3D
10 ?? ?? ?? 00 74 16 A1 08 ?? ?? ?? 8B 0D 0C ??
?? ?? 03 48 14 89 4D CC

eXPressor.PacK 1.5.0.X -> CGSoftLabs
75
55 8B EC 81 EC ?? ?? ?? ?? 53 56 57 83 A5 ?? ??
?? ?? ?? F3 EB 0C 65 58 50 72 2D 76 2E 31 2E 35
2E 00 83 7D 0C ?? 75 23 8B 45 08 A3 ?? ?? ?? ??
6A 04 68 00 10 00 00 68 20 03 00 00 6A 00 FF 15
?? ?? ?? ?? A3 ?? ?? ?? ?? EB 04

eXPressor.Protection 1.5.0.X -> CGSoftLabs
150
EB 01 68 EB 01 ?? ?? ?? ?? 83 EC 0C 53 56 57 EB
01 ?? 83 3D ?? ?? ?? ?? 00 74 08 EB 01 E9 E9 56
01 00 00 EB 02 E8 E9 C7 05 ?? ?? ?? ?? 01 00 00
00 EB 01 C2 E8 E2 05 00 00 EB 02 DA 9F 68 ?? ??
?? ?? 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? FF D0 59 59
EB 01 C8 EB 02 66 F0 68 ?? ?? ?? ?? E8 0E 05 00
00 59 EB 01 DD 83 65 F4 00 EB 07 8B 45 F4 40 89
45 F4 83 7D F4 61 73 1F EB 02 DA 1A 8B 45 F4 0F
?? ?? ?? ?? ?? ?? 33 45 F4 8B 4D F4 88 ?? ?? ??
?? ?? EB 01 EB EB

EZIP v1.0
32
E9 19 32 00 00 E9 7C 2A 00 00 E9 19 24 00 00 E9
FF 23 00 00 E9 1E 2E 00 00 E9 88 2E 00 00 E9 2C

FACRYPT v1.0
23
B9 ?? ?? B3 ?? 33 D2 BE ?? ?? 8B FE AC 32 C3 AA
49 43 32 E4 03 D0 E3

FakeNinja v2.8 (Anti-Debug) -> Spirit
173
64 A1 18 00 00 00 EB 02 C3 11 8B 40 30 EB 01 0F
0F B6 40 02 83 F8 01 74 FE EB 01 E8 90 C0 FF FF
EB 03 BD F4 B5 64 A1 30 00 00 00 0F B6 40 02 74
01 BA 74 E0 50 00 64 A1 30 00 00 00 83 C0 68 8B
00 EB 00 83 F8 70 74 CF EB 02 EB FE 90 90 90 0F
31 33 C9 03 C8 0F 31 2B C1 3D FF 0F 00 00 73 EA
E8 08 00 00 00 C1 3D FF 0F 00 00 74 AA EB 07 E8
8B 40 30 EB 08 EA 64 A1 18 00 00 00 EB F2 90 90
90 BA ?? ?? ?? ?? FF E2 64 11 40 00 FF 35 84 11
40 00 E8 40 11 00 00 6A 00 6A 00 FF 35 70 11 40
00 FF 35 84 11 40 00 E8 25 11 00 00 FF

FakeNinja v2.8 -> Spirit
19
BA ?? ?? ?? ?? FF E2 64 11 40 00 FF 35 84 11 40
00 E8 40

Feokt
85
89 25 A8 11 40 00 BF ?? ?? ?? 00 31 C0 B9 ?? ??
?? 00 29 F9 FC F3 AA ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? E8

FileShield
9
50 1E EB ?? 90 00 00 8B D8

Fish PE Shield 1.01 -> HellFish
130
55 8B EC 83 C4 D0 53 56 57 8B 45 10 83 C0 0C 8B
00 89 45 DC 83 7D DC 00 75 08 E8 AD FF FF FF 89
45 DC E8 C1 FE FF FF 8B 10 03 55 DC 89 55 E4 83
C0 04 8B 10 89 55 FC 83 C0 04 8B 10 89 55 F4 83
C0 04 8B 10 89 55 F8 83 C0 04 8B 10 89 55 F0 83
C0 04 8B 10 89 55 EC 83 C0 04 8B 00 89 45 E8 8B
45 E4 8B 58 04 03 5D E4 8B FB 8B 45 E4 8B 30 4E
85 F6 72 2B 46 C7 45 E0 00 00 00 00 83 7B 04 00
74 14

Fish PE Shield 1.01 -> HellFish
137
60 E8 12 FE FF FF C3 90 09 00 00 00 2C 00 00 00
?? ?? ?? ?? C4 03 00 00 BC A0 00 00 00 40 01 00
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 99 00 00 00 00 8A 00 00 00 10 00 00
28 88 00 00 40 ?? 4B 00 00 00 02 00 00 00 A0 00
00 18 01 00 00 40 ?? 4C 00 00 00 0C 00 00 00 B0
00 00 38 0A 00 00 40 ?? 4E 00 00 00 00 00 00 00
C0 00 00 40 39 00 00 40 ?? 4E 00 00 00 08 00 00
00 00 01 00 C8 06 00 00 40

Fish PE Shield 1.12/1.16 -> HellFish
165
55 8B EC 83 C4 D0 53 56 57 8B 45 10 83 C0 0C 8B
00 89 45 DC 83 7D DC 00 75 08 E8 BD FE FF FF 89
45 DC E8 E1 FD FF FF 8B 00 03 45 DC 89 45 E4 E8
DC FE FF FF 8B D8 BA 8E 4E 0E EC 8B C3 E8 2E FF
FF FF 89 45 F4 BA 04 49 32 D3 8B C3 E8 1F FF FF
FF 89 45 F8 BA 54 CA AF 91 8B C3 E8 10 FF FF FF
89 45 F0 BA AC 33 06 03 8B C3 E8 01 FF FF FF 89
45 EC BA 1B C6 46 79 8B C3 E8 F2 FE FF FF 89 45
E8 BA AA FC 0D 7C 8B C3 E8 E3 FE FF FF 89 45 FC
8B 45 E4 8B 58 04 03 5D E4 8B FB 8B 45 E4 8B 30
4E 85 F6 72 2B

Fish PE Shield 1.12/1.16 -> HellFish
107
60 E8 EA FD FF FF FF D0 C3 8D 40 00 ?? 00 00 00
2C 00 00 00 ?? ?? ?? 00 ?? ?? 00 00 ?? ?? ?? 00
00 ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? 00 00 00
00 ?? ?? 00 ?? ?? 00 00 ?? 00 00 00 00 ?? ?? 00
00 10 00 00 ?? ?? ?? 00 40 ?? ?? ?? 00 00 ?? ??
00 00 ?? ?? 00 ?? ?? ?? 00 40 ?? ?? ?? 00 00 ??
00 00 00 ?? ?? 00 ?? ?? 00 00 40

FishPE V1.0X -> hellfish
136
60 E8 ?? ?? ?? ?? C3 90 09 00 00 00 2C 00 00 00
?? ?? ?? ?? C4 03 00 00 BC A0 00 00 00 40 01 00
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 99 00 00 00 00 8A 00 00 00 10 00 00
?? ?? 00 00 ?? ?? ?? ?? 00 00 02 00 00 00 A0 00
00 18 01 00 00 ?? ?? ?? ?? 00 00 0C 00 00 00 B0
00 00 38 0A 00 00 ?? ?? ?? ?? 00 00 00 00 00 00
C0 00 00 40 39 00 00 ?? ?? ?? ?? 00 00 08 00 00
00 00 01 00 C8 06 00 00

FixupPak v1.20
85
55 E8 00 00 00 00 5D 81 ED ?? ?? 00 00 BE 00 ??
00 00 03 F5 BA 00 00 ?? ?? 2B D5 8B DD 33 C0 AC
3C 00 74 3D 3C 01 74 0E 3C 02 74 0E 3C 03 74 0D
03 D8 29 13 EB E7 66 AD EB F6 AD EB F3 AC 0F B6
C8 3C 00 74 06 3C 01 74 09 EB 0A 66 AD 0F B7 C8
EB 03 AD 8B C8

Fly-Crypter 1.0 -> ut1lz
219
53 56 57 55 BB 2C ?? ?? 44 BE 00 30 44 44 BF 20
?? ?? 44 80 7B 28 00 75 16 83 3F 00 74 11 8B 17
89 D0 33 D2 89 17 8B E8 FF D5 83 3F 00 75 EF 83
3D 04 30 44 44 00 74 06 FF 15 58 30 44 44 80 7B
28 02 75 0A 83 3E 00 75 05 33 C0 89 43 0C FF 15
20 30 44 44 80 7B 28 01 76 05 83 3E 00 74 22 8B
43 10 85 C0 74 1B FF 15 18 30 44 44 8B 53 10 8B
42 10 3B 42 04 74 0A 85 C0 74 06 50 E8 2F FA FF
FF FF 15 24 30 44 44 80 7B 28 01 75 03 FF 53 24
80 7B 28 00 74 05 E8 35 FF FF FF 83 3B 00 75 17
83 3D 10 ?? ?? 44 00 74 06 FF 15 10 ?? ?? 44 8B
06 50 E8 51 FA FF FF 8B 03 56 8B F0 8B FB B9 0B
00 00 00 F3 A5 5E E9 73 FF FF FF 5D 5F 5E 5B C3
A3 00 30 44 44 E8 26 FF FF FF C3

Fly-Crypter 1.0 -> ut1lz
140
55 8B EC 83 C4 F0 53 B8 18 22 44 44 E8 7F F7 FF
FF E8 0A F1 FF FF B8 09 00 00 00 E8 5C F1 FF FF
8B D8 85 DB 75 05 E8 85 FD FF FF 83 FB 01 75 05
E8 7B FD FF FF 83 FB 02 75 05 E8 D1 FD FF FF 83
FB 03 75 05 E8 87 FE FF FF 83 FB 04 75 05 E8 5D
FD FF FF 83 FB 05 75 05 E8 B3 FD FF FF 83 FB 06
75 05 E8 69 FE FF FF 83 FB 07 75 05 E8 5F FE FF
FF 83 FB 08 75 05 E8 95 FD FF FF 83 FB 09 75 05
E8 4B FE FF FF 5B E8 9D F2 FF FF 90

FreeBASIC 0.16b
128
55 89 E5 83 EC 08 C7 04 24 01 00 00 00 FF 15 ??
?? ?? 00 E8 88 FF FF FF 89 EC 31 C0 5D C3 89 F6
55 89 E5 83 EC 08 C7 04 24 02 00 00 00 FF 15 ??
?? ?? 00 E8 68 FF FF FF 89 EC 31 C0 5D C3 89 F6
55 89 E5 83 EC 08 8B 45 08 89 04 24 FF 15 ?? ??
?? 00 89 EC 5D C3 8D 76 00 8D BC 27 00 00 00 00
55 89 E5 83 EC 08 8B 45 08 89 04 24 FF 15 ?? ??
?? 00 89 EC 5D C3 90 90 90 90 90 90 90 90 90 90

FreeCryptor 0.1 (build 001)-> GlOFF
55
8B 04 24 40 90 83 C0 07 80 38 90 90 74 02 EB FF
68 26 ?? ?? 00 64 FF 35 00 00 00 00 64 89 25 00
00 00 00 FF E4 90 8B 04 24 64 A3 00 00 00 00 8B
64 24 08 90 83 C4 08

FreeCryptor 0.1 (build 002) -> GlOFF
56
8B 04 24 40 90 83 C0 07 80 38 90 90 74 02 EB FF
90 68 27 ?? ?? 00 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 FF E4 90 8B 04 24 64 A3 00 00 00 00
8B 64 24 08 90 83 C4 08

FreeCryptor 0.2 (build 002) -> GlOFF
89
33 D2 90 1E 68 1B ?? ?? ?? 0F A0 1F 8B 02 90 50
54 8F 02 90 90 8E 64 24 08 FF E2 58 50 33 D2 52
83 F8 01 9B 40 8A 10 89 14 24 90 D9 04 24 90 D9
FA D9 5C 24 FC 8B 5C 24 FC 81 F3 C2 FC 1D 1C 75
E3 74 01 62 FF D0 90 5A 33 C0 8B 54 24 08 90 64
8F 00 90 83 C2 08 52 5C 5A

FreeJoiner 1.5.1 -> GlOFF
117
90 87 FF 90 90 B9 2B 00 00 00 BA 07 10 40 00 83
C2 03 90 87 FF 90 90 B9 04 00 00 00 90 87 FF 90
33 C9 C7 05 09 30 40 00 00 00 00 00 68 00 01 00
00 68 21 30 40 00 6A 00 E8 B7 02 00 00 6A 00 68
80 00 00 00 6A 03 6A 00 6A 00 68 00 00 00 80 68
21 30 40 00 E8 8F 02 00 00 A3 19 30 40 00 90 87
FF 90 8B 15 09 30 40 00 81 C2 04 01 00 00 F7 DA
6A 02 6A 00 52

FreeJoiner 1.5.2 (Stub engine 1.6) -> GlOFF
71
E8 46 FD FF FF 50 E8 0C 00 00 00 FF 25 08 20 40
00 FF 25 0C 20 40 00 FF 25 10 20 40 00 FF 25 14
20 40 00 FF 25 18 20 40 00 FF 25 1C 20 40 00 FF
25 20 20 40 00 FF 25 24 20 40 00 FF 25 28 20 40
00 FF 25 00 20 40 00

FreeJoiner 1.5.3 (Stub engine 1.7) -> GlOFF
72
E8 33 FD FF FF 50 E8 0D 00 00 00 CC FF 25 08 20
40 00 FF 25 0C 20 40 00 FF 25 10 20 40 00 FF 25
14 20 40 00 FF 25 18 20 40 00 FF 25 1C 20 40 00
FF 25 20 20 40 00 FF 25 24 20 40 00 FF 25 28 20
40 00 FF 25 00 20 40 00

FreeJoiner 1.5.3 (Stub engine 1.7.1) -> GlOFF
73
E8 02 FD FF FF 6A 00 E8 0D 00 00 00 CC FF 25 80
10 40 00 FF 25 84 10 40 00 FF 25 88 10 40 00 FF
25 8C 10 40 00 FF 25 90 10 40 00 FF 25 94 10 40
00 FF 25 98 10 40 00 FF 25 9C 10 40 00 FF 25 A0
10 40 00 FF 25 A8 10 40 00

FreeJoiner Small (build 014-021/024-027) -> GlOFF
91
E8 ?? ?? FF FF 6A 00 E8 0D 00 00 00 CC FF 25 78
10 40 00 FF 25 7C 10 40 00 FF 25 80 10 40 00 FF
25 84 10 40 00 FF 25 88 10 40 00 FF 25 8C 10 40
00 FF 25 90 10 40 00 FF 25 94 10 40 00 FF 25 98
10 40 00 FF 25 9C 10 40 00 FF 25 A0 10 40 00 FF
25 A4 10 40 00 FF 25 AC 10 40 00

FreeJoiner Small (build 023) -> GlOFF
90
E8 E1 FD FF FF 6A 00 E8 0C 00 00 00 FF 25 78 10
40 00 FF 25 7C 10 40 00 FF 25 80 10 40 00 FF 25
84 10 40 00 FF 25 88 10 40 00 FF 25 8C 10 40 00
FF 25 90 10 40 00 FF 25 94 10 40 00 FF 25 98 10
40 00 FF 25 9C 10 40 00 FF 25 A0 10 40 00 FF 25
A4 10 40 00 FF 25 AC 10 40 00

FreeJoiner Small (build 029) -> GlOFF
97
50 32 C4 8A C3 58 E8 DE FD FF FF 6A 00 E8 0D 00
00 00 CC FF 25 78 10 40 00 FF 25 7C 10 40 00 FF
25 80 10 40 00 FF 25 84 10 40 00 FF 25 88 10 40
00 FF 25 8C 10 40 00 FF 25 90 10 40 00 FF 25 94
10 40 00 FF 25 98 10 40 00 FF 25 9C 10 40 00 FF
25 A0 10 40 00 FF 25 A4 10 40 00 FF 25 AC 10 40
00

FreeJoiner Small (build 031/032) -> GlOFF
98
50 32 ?? 66 8B C3 58 E8 ?? FD FF FF 6A 00 E8 0D
00 00 00 CC FF 25 78 10 40 00 FF 25 7C 10 40 00
FF 25 80 10 40 00 FF 25 84 10 40 00 FF 25 88 10
40 00 FF 25 8C 10 40 00 FF 25 90 10 40 00 FF 25
94 10 40 00 FF 25 98 10 40 00 FF 25 9C 10 40 00
FF 25 A0 10 40 00 FF 25 A4 10 40 00 FF 25 AC 10
40 00

FreeJoiner Small (build 033) -> GlOFF
99
50 66 33 C3 66 8B C1 58 E8 AC FD FF FF 6A 00 E8
0D 00 00 00 CC FF 25 78 10 40 00 FF 25 7C 10 40
00 FF 25 80 10 40 00 FF 25 84 10 40 00 FF 25 88
10 40 00 FF 25 8C 10 40 00 FF 25 90 10 40 00 FF
25 94 10 40 00 FF 25 98 10 40 00 FF 25 9C 10 40
00 FF 25 A0 10 40 00 FF 25 A4 10 40 00 FF 25 AC
10 40 00

FreeJoiner Small (build 035) -> GlOFF
99
51 33 CB 86 C9 59 E8 9E FD FF FF 66 87 DB 6A 00
E8 0C 00 00 00 FF 25 78 10 40 00 FF 25 7C 10 40
00 FF 25 80 10 40 00 FF 25 84 10 40 00 FF 25 88
10 40 00 FF 25 8C 10 40 00 FF 25 90 10 40 00 FF
25 94 10 40 00 FF 25 98 10 40 00 FF 25 9C 10 40
00 FF 25 A0 10 40 00 FF 25 A4 10 40 00 FF 25 AC
10 40 00

Freshbind v2.0 -> gFresh
16
64 A1 00 00 00 00 55 89 E5 6A FF 68 1C A0 41 00

Frusion -> biff
16
83 EC 0C 53 55 56 57 68 04 01 00 00 C7 44 24 14

FSG 1.31 -> dulek/xt
23
BE ?? ?? ?? 00 BF ?? ?? ?? 00 BB ?? ?? ?? 00 53
BB ?? ?? ?? 00 B2 80

FSG v1.0
38
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? ?? 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 FC
B2 80 A4 6A 02 5B

FSG v1.00 (Eng) -> dulek/xt
85
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? 00 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 FC
B2 80 A4 6A 02 5B FF 14 24 73 F7 33 C9 FF 14 24
73 18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14
24 12 C0 73 F9 75 3F AA EB DC E8 43 00 00 00 2B
CB 75 10 E8 38

FSG v1.1
30
BB D0 01 40 ?? BF ?? 10 40 ?? BE ?? ?? ?? ?? FC
B2 80 8A 06 46 88 07 47 02 D2 75 05 8A 16

FSG v1.10 (Eng) -> bart/xt
85
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? 00 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 B2
80 A4 6A 02 5B FF 14 24 73 F7 33 C9 FF 14 24 73
18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14 24
12 C0 73 F9 75 3F AA EB DC E8 43 00 00 00 2B CB
75 10 E8 38 00

FSG v1.10 (Eng) -> bart/xt -> (Watcom C/C++ EXE)
23
EB 02 CD 20 03 ?? 8D ?? 80 ?? ?? 00 ?? ?? ?? ??
?? ?? ?? ?? ?? EB 02

FSG v1.10 (Eng) -> bart/xt -> WinRAR-SFX
30
80 E9 A1 C1 C1 13 68 E4 16 75 46 C1 C1 05 5E EB
01 9D 68 64 86 37 46 EB 02 8C E0 5F F7 D0

FSG v1.10 (Eng) -> bart/xt -> WinRAR-SFX
30
EB 01 02 EB 02 CD 20 B8 80 ?? 42 00 EB 01 55 BE
F4 00 00 00 13 DF 13 D8 0F B6 38 D1 F3 F7

FSG v1.10 (Eng) -> dulek/xt
11
BB D0 01 40 ?? BF ?? 10 40 ?? BE

FSG v1.10 (Eng) -> dulek/xt
12
E8 01 00 00 00 ?? ?? E8 ?? 00 00 00

FSG v1.10 (Eng) -> dulek/xt
12
EB 01 ?? EB 02 ?? ?? ?? 80 ?? ?? 00

FSG v1.10 (Eng) -> dulek/xt -> (Borland C++ 1999)
30
EB 02 CD 20 2B C8 68 80 ?? ?? 00 EB 02 1E BB 5E
EB 02 CD 20 68 B1 2B 6E 37 40 5B 0F B6 C9

FSG v1.10 (Eng) -> dulek/xt -> (Borland C++)
30
23 CA EB 02 5A 0D E8 02 00 00 00 6A 35 58 C1 C9
10 BE 80 ?? ?? 00 0F B6 C9 EB 02 CD 20 BB

FSG v1.10 (Eng) -> dulek/xt -> (Borland C++)
85
23 CA EB 02 5A 0D E8 02 00 00 00 6A 35 58 C1 C9
10 BE 80 ?? ?? 00 0F B6 C9 EB 02 CD 20 BB F4 00
00 00 EB 02 04 FA EB 01 FA EB 01 5F EB 02 CD 20
8A 16 EB 02 11 31 80 E9 31 EB 02 30 11 C1 E9 11
80 EA 04 EB 02 F0 EA 33 CB 81 EA AB AB 19 08 04
D5 03 C2 80 EA

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Borland C++)
30
2B C2 E8 02 00 00 00 95 4A 59 8D 3D 52 F1 2A E8
C1 C8 1C BE 2E ?? ?? 18 EB 02 AB A0 03 F7

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Borland C++)
85
2B C2 E8 02 00 00 00 95 4A 59 8D 3D 52 F1 2A E8
C1 C8 1C BE 2E ?? ?? 18 EB 02 AB A0 03 F7 EB 02
CD 20 68 F4 00 00 00 0B C7 5B 03 CB 8A 06 8A 16
E8 02 00 00 00 8D 46 59 EB 01 A4 02 D3 EB 02 CD
20 02 D3 E8 02 00 00 00 57 AB 58 81 C2 AA 87 AC
B9 0F BE C9 80

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Borland C++)
30
EB 01 2E EB 02 A5 55 BB 80 ?? ?? 00 87 FE 8D 05
AA CE E0 63 EB 01 75 BA 5E CE E0 63 EB 02

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Microsoft Visual C++ / ASM)
30
EB 02 CD 20 EB 02 CD 20 EB 02 CD 20 C1 E6 18 BB
80 ?? ?? 00 EB 02 82 B8 EB 01 10 8D 05 F4

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Microsoft Visual C++)
85
1B DB E8 02 00 00 00 1A 0D 5B 68 80 ?? ?? 00 E8
01 00 00 00 EA 5A 58 EB 02 CD 20 68 F4 00 00 00
EB 02 CD 20 5E 0F B6 D0 80 CA 5C 8B 38 EB 01 35
EB 02 DC 97 81 EF F7 65 17 43 E8 02 00 00 00 97
CB 5B 81 C7 B2 8B A1 0C 8B D1 83 EF 17 EB 02 0C
65 83 EF 43 13

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Microsoft Visual C++)
30
C1 C8 10 EB 01 0F BF 03 74 66 77 C1 E9 1D 68 83
?? ?? 77 EB 02 CD 20 5E EB 02 CD 20 2B F7

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi / Microsoft Visual C++)x
30
1B DB E8 02 00 00 00 1A 0D 5B 68 80 ?? ?? 00 E8
01 00 00 00 EA 5A 58 EB 02 CD 20 68 F4 00

FSG v1.10 (Eng) -> dulek/xt -> (Borland Delphi 2.0)
30
EB 01 56 E8 02 00 00 00 B2 D9 59 68 80 ?? 41 00
E8 02 00 00 00 65 32 59 5E EB 02 CD 20 BB

FSG v1.10 (Eng) -> dulek/xt -> (MASM32 / TASM32 / Microsoft Visual Basic)
30
F7 D8 0F BE C2 BE 80 ?? ?? 00 0F BE C9 BF 08 3B
65 07 EB 02 D8 29 BB EC C5 9A F8 EB 01 94

FSG v1.10 (Eng) -> dulek/xt -> (MASM32 / TASM32)
30
03 F7 23 FE 33 FB EB 02 CD 20 BB 80 ?? 40 00 EB
01 86 EB 01 90 B8 F4 00 00 00 83 EE 05 2B

FSG v1.10 (Eng) -> dulek/xt -> (MASM32 / TASM32)
85
03 F7 23 FE 33 FB EB 02 CD 20 BB 80 ?? 40 00 EB
01 86 EB 01 90 B8 F4 00 00 00 83 EE 05 2B F2 81
F6 EE 00 00 00 EB 02 CD 20 8A 0B E8 02 00 00 00
A9 54 5E C1 EE 07 F7 D7 EB 01 DE 81 E9 B7 96 A0
C4 EB 01 6B EB 02 CD 20 80 E9 4B C1 CF 08 EB 01
71 80 E9 1C EB

FSG v1.10 (Eng) -> dulek/xt -> (MASM32)
30
EB 01 DB E8 02 00 00 00 86 43 5E 8D 1D D0 75 CF
83 C1 EE 1D 68 50 ?? 8F 83 EB 02 3D 0F 5A

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual Basic / MASM32)
30
EB 02 09 94 0F B7 FF 68 80 ?? ?? 00 81 F6 8E 00
00 00 5B EB 02 11 C2 8D 05 F4 00 00 00 47

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual Basic 5.0 / 6.0)
30
C1 CB 10 EB 01 0F B9 03 74 F6 EE 0F B6 D3 8D 05
83 ?? ?? EF 80 F3 F6 2B C1 EB 01 DE 68 77

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 4.x / LCC Win32 1.x)
30
2C 71 1B CA EB 01 2A EB 01 65 8D 35 80 ?? ?? 00
80 C9 84 80 C9 68 BB F4 00 00 00 EB 01 EB

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 5.0 / 6.0)
30
33 D2 0F BE D2 EB 01 C7 EB 01 D8 8D 05 80 ?? ??
?? EB 02 CD 20 EB 01 F8 BE F4 00 00 00 EB

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0 / ASM)
30
E8 01 00 00 00 5A 5E E8 02 00 00 00 BA DD 5E 03
F2 EB 01 64 BB 80 ?? ?? 00 8B FA EB 01 A8

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
85
0B D0 8B DA E8 02 00 00 00 40 A0 5A EB 01 9D B8
80 ?? ?? 00 EB 02 CD 20 03 D3 8D 35 F4 00 00 00
EB 01 35 EB 01 88 80 CA 7C 80 F3 74 8B 38 EB 02
AC BA 03 DB E8 01 00 00 00 A5 5B C1 C2 0B 81 C7
DA 10 0A 4E EB 01 08 2B D1 83 EF 14 EB 02 CD 20
33 D3 83 EF 27

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
30
0B D0 8B DA E8 02 00 00 00 40 A0 5A EB 01 9D B8
80 ?? ?? ?? EB 02 CD 20 03 D3 8D 35 F4 00

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
30
87 FE E8 02 00 00 00 98 CC 5F BB 80 ?? ?? 00 EB
02 CD 20 68 F4 00 00 00 E8 01 00 00 00 E3

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
30
F7 D8 40 49 EB 02 E0 0A 8D 35 80 ?? ?? ?? 0F B6
C2 EB 01 9C 8D 1D F4 00 00 00 EB 01 3C 80

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
30
F7 DB 80 EA BF B9 2F 40 67 BA EB 01 01 68 AF ??
A7 BA 80 EA 9D 58 C1 C2 09 2B C1 8B D7 68

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / ASM)
30
F7 D0 EB 02 CD 20 BE BB 74 1C FB EB 02 CD 20 BF
3B ?? ?? FB C1 C1 03 33 F7 EB 02 CD 20 68

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
03 DE EB 01 F8 B8 80 ?? 42 00 EB 02 CD 20 68 17
A0 B3 AB EB 01 E8 59 0F B6 DB 68 0B A1 B3

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
85
03 DE EB 01 F8 B8 80 ?? 42 00 EB 02 CD 20 68 17
A0 B3 AB EB 01 E8 59 0F B6 DB 68 0B A1 B3 AB EB
02 CD 20 5E 80 CB AA 2B F1 EB 02 CD 20 43 0F BE
38 13 D6 80 C3 47 2B FE EB 01 F4 03 FE EB 02 4F
4E 81 EF 93 53 7C 3C 80 C3 29 81 F7 8A 8F 67 8B
80 C3 C7 2B FE

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
91 EB 02 CD 20 BF 50 BC 04 6F 91 BE D0 ?? ?? 6F
EB 02 CD 20 2B F7 EB 02 F0 46 8D 1D F4 00

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
C1 CE 10 C1 F6 0F 68 00 ?? ?? 00 2B FA 5B 23 F9
8D 15 80 ?? ?? 00 E8 01 00 00 00 B6 5E 0B

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
D1 E9 03 C0 68 80 ?? ?? 00 EB 02 CD 20 5E 40 BB
F4 00 00 00 33 CA 2B C7 0F B6 16 EB 01 3E

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
E8 01 00 00 00 0E 59 E8 01 00 00 00 58 58 BE 80
?? ?? 00 EB 02 61 E9 68 F4 00 00 00 C1 C8

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
EB 01 4D 83 F6 4C 68 80 ?? ?? 00 EB 02 CD 20 5B
EB 01 23 68 48 1C 2B 3A E8 02 00 00 00 38

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
EB 02 AB 35 EB 02 B5 C6 8D 05 80 ?? ?? 00 C1 C2
11 BE F4 00 00 00 F7 DB F7 DB 0F BE 38 E8

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
21
EB 02 CD 20 ?? CF ?? ?? 80 ?? ?? 00 ?? ?? ?? ??
?? ?? ?? ?? 00

FSG v1.10 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
30
F7 DB 80 EA BF B9 2F 40 67 BA EB 01 01 68 AF ??
?? BA 80 EA 9D 58 C1 C2 09 2B C1 8B D7 68

FSG v1.2
49
4B 45 52 4E 45 4C 33 32 2E 64 6C 6C 00 00 4C 6F
61 64 4C 69 62 72 61 72 79 41 00 00 47 65 74 50
72 6F 63 41 64 64 72 65 73 73 00 ?? 00 00 00 00
00

FSG v1.20 (Eng) -> dulek/xt -> (Borland C++)
85
C1 F0 07 EB 02 CD 20 BE 80 ?? ?? 00 1B C6 8D 1D
F4 00 00 00 0F B6 06 EB 02 CD 20 8A 16 0F B6 C3
E8 01 00 00 00 DC 59 80 EA 37 EB 02 CD 20 2A D3
EB 02 CD 20 80 EA 73 1B CF 32 D3 C1 C8 0E 80 EA
23 0F B6 C9 02 D3 EB 01 B5 02 D3 EB 02 DB 5B 81
C2 F6 56 7B F6

FSG v1.20 (Eng) -> dulek/xt -> (Borland Delphi / Borland C++)
85
0F BE C1 EB 01 0E 8D 35 C3 BE B6 22 F7 D1 68 43
?? ?? 22 EB 02 B5 15 5F C1 F1 15 33 F7 80 E9 F9
BB F4 00 00 00 EB 02 8F D0 EB 02 08 AD 8A 16 2B
C7 1B C7 80 C2 7A 41 80 EA 10 EB 01 3C 81 EA CF
AE F1 AA EB 01 EC 81 EA BB C6 AB EE 2C E3 32 D3
0B CB 81 EA AB

FSG v1.20 (Eng) -> dulek/xt -> (Borland Delphi / Microsoft Visual C++)
85
0F B6 D0 E8 01 00 00 00 0C 5A B8 80 ?? ?? 00 EB
02 00 DE 8D 35 F4 00 00 00 F7 D2 EB 02 0E EA 8B
38 EB 01 A0 C1 F3 11 81 EF 84 88 F4 4C EB 02 CD
20 83 F7 22 87 D3 33 FE C1 C3 19 83 F7 26 E8 02
00 00 00 BC DE 5A 81 EF F7 EF 6F 18 EB 02 CD 20
83 EF 7F EB 01

FSG v1.20 (Eng) -> dulek/xt -> (MASM32 / TASM32)
85
33 C2 2C FB 8D 3D 7E 45 B4 80 E8 02 00 00 00 8A
45 58 68 02 ?? 8C 7F EB 02 CD 20 5E 80 C9 16 03
F7 EB 02 40 B0 68 F4 00 00 00 80 F1 2C 5B C1 E9
05 0F B6 C9 8A 16 0F B6 C9 0F BF C7 2A D3 E8 02
00 00 00 99 4C 58 80 EA 53 C1 C9 16 2A D3 E8 02
00 00 00 9D CE

FSG v1.20 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0 / 7.0)
85
EB 02 CD 20 EB 01 91 8D 35 80 ?? ?? 00 33 C2 68
83 93 7E 7D 0C A4 5B 23 C3 68 77 93 7E 7D EB 01
FA 5F E8 02 00 00 00 F7 FB 58 33 DF EB 01 3F E8
02 00 00 00 11 88 58 0F B6 16 EB 02 CD 20 EB 02
86 2F 2A D3 EB 02 CD 20 80 EA 2F EB 01 52 32 D3
80 E9 CD 80 EA

FSG v1.20 (Eng) -> dulek/xt -> (Microsoft Visual C++ 6.0)
85
C1 E0 06 EB 02 CD 20 EB 01 27 EB 01 24 BE 80 ??
42 00 49 EB 01 99 8D 1D F4 00 00 00 EB 01 5C F7
D8 1B CA EB 01 31 8A 16 80 E9 41 EB 01 C2 C1 E0
0A EB 01 A1 81 EA A8 8C 18 A1 34 46 E8 01 00 00
00 62 59 32 D3 C1 C9 02 EB 01 68 80 F2 1A 0F BE
C9 F7 D1 2A D3

FSG v1.3
85
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? ?? 53
E8 0A 00 00 00 02 D2 75 05 8A 16 46 12 D2 C3 B2
80 A4 6A 02 5B FF 14 24 73 F7 33 C9 FF 14 24 73
18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14 24
12 C0 73 F9 75 3F AA EB DC E8 43 00 00 00 2B CB
75 10 E8 38 00

FSG v1.31
32
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? ?? 53
BB ?? ?? ?? ?? B2 80 A4 B6 80 FF D3 73 F9 33 C9

FSG v1.31 (Eng) -> dulek/xt
85
BB D0 01 40 00 BF 00 10 40 00 BE ?? ?? ?? 00 53
BB ?? ?? ?? 00 B2 80 A4 B6 80 FF D3 73 F9 33 C9
FF D3 73 16 33 C0 FF D3 73 23 B6 80 41 B0 10 FF
D3 12 C0 73 FA 75 42 AA EB E0 E8 46 00 00 00 02
F6 83 D9 01 75 10 E8 38 00 00 00 EB 28 AC D1 E8
74 48 13 C9 EB

FSG v1.33
20
BE A4 01 40 00 AD 93 AD 97 AD 56 96 B2 80 A4 B6
80 FF 13 73

FSG v1.33 (Eng) -> dulek/xt
30
BE A4 01 40 00 AD 93 AD 97 AD 56 96 B2 80 A4 B6
80 FF 13 73 F9 33 C9 FF 13 73 16 33 C0 FF

FSG v1.33 (Eng) -> dulek/xt
85
BE A4 01 40 00 AD 93 AD 97 AD 56 96 B2 80 A4 B6
80 FF 13 73 F9 33 C9 FF 13 73 16 33 C0 FF 13 73
1F B6 80 41 B0 10 FF 13 12 C0 73 FA 75 3C AA EB
E0 FF 53 08 02 F6 83 D9 01 75 0E FF 53 04 EB 26
AC D1 E8 74 2F 13 C9 EB 1A 91 48 C1 E0 08 AC FF
53 04 3D 00 7D

FSG v2.0
40
87 25 ?? ?? ?? ?? 61 94 55 A4 B6 80 FF 13 73 F9
33 C9 FF 13 73 16 33 C0 FF 13 73 1F B6 80 41 B0
10 FF 13 12 C0 73 FA 75

FSG v2.0 -> bart/xt
14
87 25 ?? ?? ?? 00 61 94 55 A4 B6 80 FF 13

Fuck'n'Joy v1.0c -> UsAr
85
60 E8 00 00 00 00 5D 81 ED D8 05 40 00 FF 74 24
20 E8 8C 02 00 00 0B C0 0F 84 2C 01 00 00 89 85
6C 08 40 00 8D 85 2F 08 40 00 50 FF B5 6C 08 40
00 E8 EF 02 00 00 0B C0 0F 84 0C 01 00 00 89 85
3B 08 40 00 8D 85 3F 08 40 00 50 FF B5 6C 08 40
00 E8 CF 02 00

Fuck'n'Joy v1.0c -> UsAr
255
60 E8 00 00 00 00 5D 81 ED D8 05 40 00 FF 74 24
20 E8 8C 02 00 00 0B C0 0F 84 2C 01 00 00 89 85
6C 08 40 00 8D 85 2F 08 40 00 50 FF B5 6C 08 40
00 E8 EF 02 00 00 0B C0 0F 84 0C 01 00 00 89 85
3B 08 40 00 8D 85 3F 08 40 00 50 FF B5 6C 08 40
00 E8 CF 02 00 00 0B C0 0F 84 EC 00 00 00 89 85
4D 08 40 00 8D 85 51 08 40 00 50 FF B5 6C 08 40
00 E8 AF 02 00 00 0B C0 0F 84 CC 00 00 00 89 85
5C 08 40 00 8D 85 67 07 40 00 E8 7B 02 00 00 8D
B5 C4 07 40 00 56 6A 64 FF 95 74 07 40 00 46 80
3E 00 75 FA C7 06 74 6D 70 2E 83 C6 04 C7 06 65
78 65 00 8D 85 36 07 40 00 E8 4C 02 00 00 33 DB
53 53 6A 02 53 53 68 00 00 00 40 8D 85 C4 07 40
00 50 FF 95 74 07 40 00 89 85 78 07 40 00 8D 85
51 07 40 00 E8 21 02 00 00 6A 00 8D 85 7C 07 40
00 50 68 00 ?? ?? 00 8D 85 F2 09 40 00 50 FF

Fusion 1.0 -> jaNooNi
25
68 04 30 40 00 68 04 30 40 00 E8 09 03 00 00 68
04 30 40 00 E8 C7 02 00 00

GameGuard - nProtect
172
31 FF 74 06 61 E9 4A 4D 50 30 5A BA 7D 00 00 00
80 7C 24 08 01 E9 00 00 00 00 60 BE ?? ?? ?? ??
31 FF 74 06 61 E9 4A 4D 50 30 8D BE ?? ?? ?? ??
31 C9 74 06 61 E9 4A 4D 50 30 B8 7D 00 00 00 39
C2 B8 4C 00 00 00 F7 D0 75 3F 64 A1 30 00 00 00
85 C0 78 23 8B 40 0C 8B 40 0C C7 40 20 00 10 00
00 64 A1 18 00 00 00 8B 40 30 0F B6 40 02 85 C0
75 16 E9 12 00 00 00 31 C0 64 A0 20 00 00 00 85
C0 75 05 E9 01 00 00 00 61 57 83 CD FF EB 0B 90
8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC 11
DB 72 ED B8 01 00 00 00 01 DB 75 07

GameGuard v2006.5.x.x (*.dll) -> sign by hot_UNP
29
31 FF 74 06 61 E9 4A 4D 50 30 BA 4C 00 00 00 80
7C 24 08 01 0F 85 ?? 01 00 00 60 BE 00

GameGuard v2006.5.x.x (*.exe) -> sign by hot_UNP
29
31 FF 74 06 61 E9 4A 4D 50 30 5A BA 7D 00 00 00
80 7C 24 08 01 E9 00 00 00 00 60 BE 00

Gamehouse Media Protector Version Unknown
27
68 ?? ?? ?? ?? 6A 00 FF 15 ?? ?? ?? ?? 50 FF 15
?? ?? ?? 00 00 00 00 00 00 00 00

Gardian Angel 1.0
12
06 8C C8 8E D8 8E C0 FC BF ?? ?? EB

GHF Protector (pack only) --> GPcH
420
60 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? FF 10 68 ?? ??
?? ?? 50 B8 ?? ?? ?? ?? FF 10 68 00 00 00 00 6A
40 FF D0 89 05 ?? ?? ?? ?? 89 C7 BE ?? ?? ?? ??
60 FC B2 80 31 DB A4 B3 02 E8 6D 00 00 00 73 F6
31 C9 E8 64 00 00 00 73 1C 31 C0 E8 5B 00 00 00
73 23 B3 02 41 B0 10 E8 4F 00 00 00 10 C0 73 F7
75 3F AA EB D4 E8 4D 00 00 00 29 D9 75 10 E8 42
00 00 00 EB 28 AC D1 E8 74 4D 11 C9 EB 1C 91 48
C1 E0 08 AC E8 2C 00 00 00 3D 00 7D 00 00 73 0A
80 FC 05 73 06 83 F8 7F 77 02 41 41 95 89 E8 B3
01 56 89 FE 29 C6 F3 A4 5E EB 8E 00 D2 75 05 8A
16 46 10 D2 C3 31 C9 41 E8 EE FF FF FF 11 C9 E8
E7 FF FF FF 72 F2 C3 61 B9 FC FF FF FF 8B 1C 08
89 99 ?? ?? ?? ?? E2 F5 90 90 BA ?? ?? ?? ?? BE
?? ?? ?? ?? 01 D6 8B 46 0C 85 C0 0F 84 87 00 00
00 01 D0 89 C3 50 B8 ?? ?? ?? ?? FF 10 85 C0 75
08 53 B8 ?? ?? ?? ?? FF 10 89 05 ?? ?? ?? ?? C7
05 ?? ?? ?? ?? 00 00 00 00 BA ?? ?? ?? ?? 8B 06
85 C0 75 03 8B 46 10 01 D0 03 05 ?? ?? ?? ?? 8B
18 8B 7E 10 01 D7 03 3D ?? ?? ?? ?? 85 DB 74 2B
F7 C3 00 00 00 80 75 04 01 D3 43 43 81 E3 FF FF
FF 0F 53 FF 35 ?? ?? ?? ?? B8 ?? ?? ?? ?? FF 10
89 07 83 05 ?? ?? ?? ?? 04 EB AE 83 C6 14 BA ??
?? ?? ?? E9 6E FF FF FF 68 ?? ?? ?? ?? B8 ?? ??
?? ?? FF 10 68 ?? ?? ?? ?? 50 B8 ?? ?? ?? ?? FF
10 8B 15 ?? ?? ?? ?? 52 FF D0 61 BA ?? ?? ?? ??
FF E2 90 C3

GHF Protector (pack only) -> GPcH
85
60 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? FF 10 68 ?? ??
?? ?? 50 B8 ?? ?? ?? ?? FF 10 68 00 00 00 00 6A
40 FF D0 89 05 ?? ?? ?? ?? 89 C7 BE ?? ?? ?? ??
60 FC B2 80 31 DB A4 B3 02 E8 6D 00 00 00 73 F6
31 C9 E8 64 00 00 00 73 1C 31 C0 E8 5B 00 00 00
73 23 B3 02 41

Goats Mutilator V1.6 -> Goat/_e0f
31
E8 EA 0B 00 00 ?? ?? ?? 8B 1C 79 F6 63 D8 8D 22
B0 BF F6 49 08 C3 02 BD 3B 6C 29 46 13 28 5D

GP-Install v5.0.3.32
55
55 8B EC 33 C9 51 51 51 51 51 51 51 53 56 57 B8
C4 1C 41 00 E8 6B 3E FF FF 33 C0 55 68 76 20 41
00 64 FF 30 64 89 20 BA A0 47 41 00 33 C0 E8 31
0A FF FF 33 D2 A1 A0

HACKSTOP v1.00
16
FA BD ?? ?? FF E5 6A 49 48 0C ?? E4 ?? 3F 98 3F

HACKSTOP v1.10, v1.11
27
B4 30 CD 21 86 E0 3D ?? ?? 73 ?? B4 2F CD 21 B0
?? B4 4C CD 21 50 B8 ?? ?? 58 EB

HACKSTOP v1.10p1
35
B4 30 CD 21 86 E0 3D 00 03 73 ?? B4 2F CD 21 B4
2A CD 21 B4 2C CD 21 B0 FF B4 4C CD 21 50 B8 ??
?? 58 EB

HACKSTOP v1.11c
27
B4 30 CD 21 86 E0 3D ?? ?? 73 ?? B4 ?? CD 21 B0
?? B4 4C CD 21 53 BB ?? ?? 5B EB

HACKSTOP v1.13
26
52 B8 ?? ?? 1E CD 21 86 E0 3D ?? ?? 73 ?? CD 20
0E 1F B4 09 E8 ?? ?? 24 ?? EA

HACKSTOP v1.18
32
52 BA ?? ?? 5A EB ?? 9A ?? ?? ?? ?? 30 CD 21 ??
?? ?? FD 02 ?? ?? CD 20 0E 1F 52 BA ?? ?? 5A EB

HACKSTOP v1.19
32
52 BA ?? ?? 5A EB ?? 9A ?? ?? ?? ?? 30 CD 21 ??
?? ?? D6 02 ?? ?? CD 20 0E 1F 52 BA ?? ?? 5A EB

Hardlock dongle (Alladin)
32
5C 5C 2E 5C 48 41 52 44 4C 4F 43 4B 2E 56 58 44
00 00 00 00 5C 5C 2E 5C 46 45 6E 74 65 44 65 76

Hasp dongle (Alladin)
38
50 53 51 52 57 56 8B 75 1C 8B 3E ?? ?? ?? ?? ??
8B 5D 08 8A FB ?? ?? 03 5D 10 8B 45 0C 8B 4D 14
8B 55 18 80 FF 32

HASP HL Protection V1.X -> Aladdin
83
55 8B EC 53 56 57 60 8B C4 A3 ?? ?? ?? ?? B8 ??
?? ?? ?? 2B 05 ?? ?? ?? ?? A3 ?? ?? ?? ?? 83 3D
?? ?? ?? ?? 00 74 15 8B 0D ?? ?? ?? ?? 51 FF 15
?? ?? ?? ?? 83 C4 04 E9 A5 00 00 00 68 ?? ?? ??
?? FF 15 ?? ?? ?? ?? A3 ?? ?? ?? ?? 68 ?? ?? ??
?? FF 15

HASP HL Protection V1.X -> Aladdin
94
55 8B EC 53 56 57 60 8B C4 A3 ?? ?? ?? ?? B8 ??
?? ?? ?? 2B 05 ?? ?? ?? ?? A3 ?? ?? ?? ?? 83 3D
?? ?? ?? ?? 00 74 15 8B 0D ?? ?? ?? ?? 51 FF 15
?? ?? ?? ?? 83 C4 04 E9 A5 00 00 00 68 ?? ?? ??
?? FF 15 ?? ?? ?? ?? A3 ?? ?? ?? ?? 68 ?? ?? ??
?? FF 15 ?? ?? ?? ?? A3 ?? ?? ?? ?? 8B 15

HEALTH v.5.1 by Muslim M.Polyak
34
1E E8 ?? ?? 2E 8C 06 ?? ?? 2E 89 3E ?? ?? 8B D7
B8 ?? ?? CD 21 8B D8 0E 1F E8 ?? ?? 06 57 A1 ??
?? 26

Hide PE 1.01 -> BGCorp
64
?? BA ?? ?? ?? 00 B8 ?? ?? ?? ?? 89 02 83 C2 04
B8 ?? ?? ?? ?? 89 02 83 C2 04 B8 ?? ?? ?? ?? 89
02 83 C2 F8 FF E2 0D 0A 2D 3D 5B 20 48 69 64 65
50 45 20 62 79 20 42 47 43 6F 72 70 20 5D 3D 2D

hmimys Protect v1.0
250
E8 BA 00 00 00 ?? 00 00 00 00 ?? ?? 00 00 10 40
00 ?? ?? ?? 00 ?? ?? ?? 00 00 ?? ?? 00 ?? ?? ??
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ??
00 ?? 00 00 00 00 00 00 00 ?? ?? ?? 00 00 00 00
00 00 00 00 00 ?? ?? ?? 00 ?? ?? ?? 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ??
00 00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C
6C 00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41
00 00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73
73 00 00 00 56 69 72 74 75 61 6C 46 72 65 65 00
00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 5E
83 C6 64 AD 50 AD 50 83 EE 6C AD 50 AD 50 AD 50
AD 50 AD 50 E8 E7 07 00 00 AD 8B DE 8B F0 83 C3
44 AD 85 C0 74 32 8B F8 56 FF 13 8B E8 AC 84 C0
75 FB AC 84 C0 74 EA 4E AD A9

hmimys Protect v1.0
253
E8 BA 00 00 00 ?? 00 00 00 00 ?? ?? 00 00 10 40
00 ?? ?? ?? 00 ?? ?? ?? 00 00 ?? ?? 00 ?? ?? ??
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ??
00 ?? 00 00 00 00 00 00 00 ?? ?? ?? 00 00 00 00
00 00 00 00 00 ?? ?? ?? 00 ?? ?? ?? 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ??
00 00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C
6C 00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41
00 00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73
73 00 00 00 56 69 72 74 75 61 6C 46 72 65 65 00
00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 5E
83 C6 64 AD 50 AD 50 83 EE 6C AD 50 AD 50 AD 50
AD 50 AD 50 E8 E7 07 00 00 AD 8B DE 8B F0 83 C3
44 AD 85 C0 74 32 8B F8 56 FF 13 8B E8 AC 84 C0
75 FB AC 84 C0 74 EA 4E AD A9 00 00 00

hmimys's PE-Pack 0.1 -> hmimys
243
E8 00 00 00 00 5D 83 ED 05 6A 00 FF 95 E1 0E 00
00 89 85 85 0E 00 00 8B 58 3C 03 D8 81 C3 F8 00
00 00 80 AD 89 0E 00 00 01 89 9D 63 0F 00 00 8B
4B 0C 03 8D 85 0E 00 00 8B 53 08 80 BD 89 0E 00
00 00 75 0C 03 8D 91 0E 00 00 2B 95 91 0E 00 00
89 8D 57 0F 00 00 89 95 5B 0F 00 00 8B 5B 10 89
9D 5F 0F 00 00 8B 9D 5F 0F 00 00 8B 85 57 0F 00
00 53 50 E8 B7 0B 00 00 89 85 73 0F 00 00 6A 04
68 00 10 00 00 50 6A 00 FF 95 E9 0E 00 00 89 85
6B 0F 00 00 6A 04 68 00 10 00 00 68 D8 7C 00 00
6A 00 FF 95 E9 0E 00 00 89 85 6F 0F 00 00 8D 85
67 0F 00 00 8B 9D 73 0F 00 00 8B 8D 6B 0F 00 00
8B 95 5B 0F 00 00 83 EA 0E 8B B5 57 0F 00 00 83
C6 0E 8B BD 6F 0F 00 00 50 53 51 52 56 68 D8 7C
00 00 57 E8 01 01 00 00 8B 9D 57 0F 00 00 8B 03
3C 01 75

hmimys-Packer 1.0 -> hmimys
24
5E 83 C6 64 AD 50 AD 50 83 EE 6C AD 50 AD 50 AD
50 AD 50 AD 50 E8 E7 07

hmimys-Packer V1.2 -> hmimys
279
E8 95 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 5E AD 50 AD 50 97
AD 50 AD 50 AD 50 E8 C0 01 00 00 AD 50 AD 93 87
DE B9 ?? ?? ?? ?? E3 1D 8A 07 47 04 ?? 3C ?? 73
F7 8B 07 3C ?? 75 F3 B0 00 0F C8 05 ?? ?? ?? ??
2B C7 AB E2 E3 AD 85 C0 74 2B 97 56 FF 13 8B E8
AC 84 C0 75 FB 66 AD 66 85 C0 74 E9 AC 83 EE 03
84 C0 74 08 56 55 FF 53 04 AB EB E4 AD 50 55 FF
53 04 AB EB E0 C3 8B 0A 3B 4A 04 75 0A C7 42 10
01 00 00 00 0C FF C3

HPA
21
E8 ?? ?? 5E 8B D6 83 ?? ?? 83 ?? ?? 06 0E 1E 0E
1F 33 FF 8C D3

Hying's PE-Armor 0.75.exe -> Hying [CCG]
85
00 00 00 00 00 00 00 00 ?? ?? 00 00 00 00 00 00
?? ?? 01 00 00 00 00 00 00 00 00 00 56 69 72 74
75 61 6C 41 6C 6C 6F 63 00 00 00 00 00 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 00 00 00 00 00 00 00 00 00 74 ?? ?? ??
00 00 00 00 00

hying's PEArmor V0.76 -> hying
25
E9 00 00 00 00 60 E8 14 00 00 00 5D 81 ED 00 00
00 00 6A ?? E8 A3 00 00 00

ICrypt 1.0 - by BuGGz
244
55 8B EC 83 C4 EC 53 56 57 33 C0 89 45 EC B8 70
3B 00 10 E8 3C FA FF FF 33 C0 55 68 6C 3C 00 10
64 FF 30 64 89 20 6A 0A 68 7C 3C 00 10 A1 50 56
00 10 50 E8 D8 FA FF FF 8B D8 53 A1 50 56 00 10
50 E8 0A FB FF FF 8B F8 53 A1 50 56 00 10 50 E8
D4 FA FF FF 8B D8 53 E8 D4 FA FF FF 8B F0 85 F6
74 26 8B D7 4A B8 64 56 00 10 E8 25 F6 FF FF B8
64 56 00 10 E8 13 F6 FF FF 8B CF 8B D6 E8 E6 FA
FF FF 53 E8 90 FA FF FF 8D 4D EC BA 8C 3C 00 10
A1 64 56 00 10 E8 16 FB FF FF 8B 55 EC B8 64 56
00 10 E8 C5 F4 FF FF B8 64 56 00 10 E8 DB F5 FF
FF E8 56 FC FF FF 33 C0 5A 59 59 64 89 10 68 73
3C 00 10 8D 45 EC E8 4D F4 FF FF C3 E9 E3 EE FF
FF EB F0 5F 5E 5B E8 4D F3 FF FF 00 53 45 54 ??
?? ?? ?? 00 FF FF FF FF 08 00 00 00 76 6F 74 72
65 63 6C 65

ID Application Protector 1.2 -> ID Security Suite
81
60 E8 00 00 00 00 5D 81 ED F2 0B 47 00 B9 19 22
47 00 81 E9 EA 0E 47 00 89 EA 81 C2 EA 0E 47 00
8D 3A 89 FE 31 C0 E9 D3 02 00 00 CC CC CC CC E9
CA 02 00 00 43 3A 5C 57 69 6E 64 6F 77 73 5C 53
6F 66 74 57 61 72 65 50 72 6F 74 65 63 74 6F 72
5C

ILUCRYPT v4.015 [exe]
18
8B EC FA C7 46 F7 ?? ?? 42 81 FA ?? ?? 75 F9 FF
66 F7

iLUCRYPT v4.018 [exe]
25
8B EC FA C7 ?? ?? ?? ?? 4C 4C C3 FB BF ?? ?? B8
?? ?? 2E ?? ?? D1 C8 4F 81

IMP-Packer 1.0 -> Mahdi Hezavehi [IMPOSTER]
85
28 ?? ?? ?? 00 00 00 00 00 00 00 00 40 ?? ?? ??
34 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4C ?? ?? ?? 5C ?? ?? ??
00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
4B 45 52 4E 45 4C 33 32 2E 64 6C 6C 00 00 47 65
74 50 72 6F 63

Imploder v1.04 --> BoB / BobSoft
64
60 E8 A0 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 36 ?? ?? ?? 2E ?? ?? ?? 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00
00 80 00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 44

IMPostor Pack 1.0 -> Mahdi Hezavehi
40
BE ?? ?? ?? 00 83 C6 01 FF E6 00 00 00 00 ?? ??
00 00 00 00 00 00 00 00 00 ?? ?? ?? 00 ?? 02 ??
?? 00 10 00 00 00 02 00

Inbuild v1.0 [hard]
14
B9 ?? ?? BB ?? ?? 2E ?? ?? 2E ?? ?? 43 E2

INCrypter 0.3 (INinY) - by z3e_NiFe
208
60 64 A1 30 00 00 00 8B 40 0C 8B 40 0C 8D 58 20
C7 03 00 00 00 00 E8 00 00 00 00 5D 81 ED 4D 16
40 00 8B 9D 0E 17 40 00 64 A1 18 00 00 00 8B 40
30 0F B6 40 02 83 F8 01 75 05 03 DB C1 CB 10 8B
8D 12 17 40 00 8B B5 06 17 40 00 51 81 3E 2E 72
73 72 74 65 8B 85 16 17 40 00 E8 23 00 00 00 8B
85 1A 17 40 00 E8 18 00 00 00 8B 85 1E 17 40 00
E8 0D 00 00 00 8B 85 22 17 40 00 E8 02 00 00 00
EB 18 8B D6 3B 46 0C 72 0A 83 F9 01 74 0B 3B 46
34 72 06 BA 00 00 00 00 C3 58 83 FA 00 75 1A 8B
4E 10 8B 7E 0C 03 BD 02 17 40 00 83 F9 00 74 09
F6 17 31 0F 31 1F 47 E2 F7 59 83 C6 28 49 83 F9
00 75 88 8B 85 0A 17 40 00 89 44 24 1C 61 50 C3

Inno Setup Module
26
49 6E 6E 6F 53 65 74 75 70 4C 64 72 57 69 6E 64
6F 77 00 00 53 54 41 54 49 43

Inno Setup Module
45
55 8B EC 83 C4 ?? 53 56 57 33 C0 89 45 F0 89 45
?? 89 45 ?? E8 ?? ?? FF FF E8 ?? ?? FF FF E8 ??
?? FF FF E8 ?? ?? FF FF E8 ?? ?? FF FF

Inno Setup Module v1.09a
37
55 8B EC 83 C4 C0 53 56 57 33 C0 89 45 F0 89 45
C4 89 45 C0 E8 A7 7F FF FF E8 FA 92 FF FF E8 F1
B3 FF FF 33 C0

Inno Setup Module v1.2.9
37
55 8B EC 83 C4 C0 53 56 57 33 C0 89 45 F0 89 45
EC 89 45 C0 E8 5B 73 FF FF E8 D6 87 FF FF E8 C5
A9 FF FF E8 E0

Inno Setup Module v2.0.18
37
55 8B EC 83 C4 B8 53 56 57 33 C0 89 45 F0 89 45
BC 89 45 B8 E8 73 71 FF FF E8 DA 85 FF FF E8 81
A7 FF FF E8 C8

Inno Setup Module v3.0.4-beta/v3.0.6/v3.0.7
37
55 8B EC 83 C4 B8 53 56 57 33 C0 89 45 F0 89 45
BC 89 45 B8 E8 B3 70 FF FF E8 1A 85 FF FF E8 25
A7 FF FF E8 6C

Install Stub 32-bit
35
55 8B EC 81 EC 14 ?? 00 00 53 56 57 6A 00 FF 15
?? ?? ?? ?? 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 85
C0 74 29

InstallAnywhere 6.1 -> Zero G Software Inc
85
60 BE 00 A0 42 00 8D BE 00 70 FD FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
EF 75 09 8B 1E 83 EE FC 11 DB 73 E4 31 C9 83 E8
03 72 0D C1 E0

InstallAnywhere 6.1 ->Zero G Software Inc
52
60 BE 00 A0 42 00 8D BE 00 70 FD FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07

InstallShield 2000
35
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 C4 ??
53 56 57

InstallShield Custom
64
55 8B EC 83 EC 44 56 FF 15 ?? ?? 41 00 8B F0 85
F6 75 08 6A FF FF 15 ?? ?? 41 00 8A 06 57 8B 3D
?? ?? 41 00 3C 22 75 1B 56 FF D7 8B F0 8A 06 3C
22 74 04 84 C0 75 F1 80 3E 22 75 15 56 FF D7 8B

Ionic Wind Software
16
9B DB E3 9B DB E2 D9 2D 00 ?? ?? 00 55 89 E5 E8

iPB Protect 0.1.3 - 0.1.7 -> forgot
21
55 8B EC 6A FF 68 4B 43 55 46 68 54 49 48 53 64
A1 00 00 00 00

iPBProtect v0.1.3
85
55 8B EC 6A FF 68 4B 43 55 46 68 54 49 48 53 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68
53 56 57 89 65 FA 33 DB 89 5D F8 6A 02 EB 01 F8
58 5F 5E 5B 64 8B 25 00 00 00 00 64 8F 05 00 00
00 00 58 58 58 5D 68 9F 6F 56 B6 50 E8 5D 00 00
00 EB FF 71 78

IProtect 1.0 (Fxlib.dll mode) - by FuXdas
464
EB 33 2E 46 55 58 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 46 78 4C 69 62 2E 64 6C 6C 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 60 E8 00 00 00 00 5D 81 ED 71 10
40 00 FF 74 24 20 E8 40 00 00 00 0B C0 74 2F 89
85 63 10 40 00 8D 85 3C 10 40 00 50 FF B5 63 10
40 00 E8 92 00 00 00 0B C0 74 13 89 85 5F 10 40
00 8D 85 49 10 40 00 50 FF 95 5F 10 40 00 8B 85
67 10 40 00 89 44 24 1C 61 FF E0 8B 7C 24 04 8D
85 00 10 40 00 50 64 FF 35 00 00 00 00 8D 85 53
10 40 00 89 20 89 68 04 8D 9D 0A 11 40 00 89 58
08 64 89 25 00 00 00 00 81 E7 00 00 FF FF 66 81
3F 4D 5A 75 0F 8B F7 03 76 3C 81 3E 50 45 00 00
75 02 EB 17 81 EF 00 00 01 00 81 FF 00 00 00 70
73 07 BF 00 00 F7 BF EB 02 EB D3 97 64 8F 05 00
00 00 00 83 C4 04 C2 04 00 8D 85 00 10 40 00 50
64 FF 35 00 00 00 00 8D 85 53 10 40 00 89 20 89
68 04 8D 9D 0A 11 40 00 89 58 08 64 89 25 00 00
00 00 8B 74 24 0C 66 81 3E 4D 5A 74 05 E9 8A 00
00 00 03 76 3C 81 3E 50 45 00 00 74 02 EB 7D 8B
7C 24 10 B9 96 00 00 00 32 C0 F2 AE 8B CF 2B 4C
24 10 8B 56 78 03 54 24 0C 8B 5A 20 03 5C 24 0C
33 C0 8B 3B 03 7C 24 0C 8B 74 24 10 51 F3 A6 75
05 83 C4 04 EB 0A 59 83 C3 04 40 3B 42 18 75 E2
3B 42 18 75 02 EB 35 8B 72 24 03 74 24 0C 52 BB
02 00 00 00 33 D2 F7 E3 5A 03 C6 33 C9 66 8B 08
8B 7A 1C 33 D2 BB 04 00 00 00 8B C1 F7 E3 03 44
24 0C 03 C7 8B 00 03 44 24 0C EB 02 33 C0 64 8F
05 00 00 00 00 83 C4 04 C2 08 00 E8 FA FD FF FF

IProtect 1.0 (FxSub.dll mode) - by FuXdas
464
EB 33 2E 46 55 58 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 46 78 53 75 62 2E 64 6C 6C 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 60 E8 00 00 00 00 5D 81 ED B6 13
40 00 FF 74 24 20 E8 40 00 00 00 0B C0 74 2F 89
85 A8 13 40 00 8D 85 81 13 40 00 50 FF B5 A8 13
40 00 E8 92 00 00 00 0B C0 74 13 89 85 A4 13 40
00 8D 85 8E 13 40 00 50 FF 95 A4 13 40 00 8B 85
AC 13 40 00 89 44 24 1C 61 FF E0 8B 7C 24 04 8D
85 00 10 40 00 50 64 FF 35 00 00 00 00 8D 85 98
13 40 00 89 20 89 68 04 8D 9D 4F 14 40 00 89 58
08 64 89 25 00 00 00 00 81 E7 00 00 FF FF 66 81
3F 4D 5A 75 0F 8B F7 03 76 3C 81 3E 50 45 00 00
75 02 EB 17 81 EF 00 00 01 00 81 FF 00 00 00 70
73 07 BF 00 00 F7 BF EB 02 EB D3 97 64 8F 05 00
00 00 00 83 C4 04 C2 04 00 8D 85 00 10 40 00 50
64 FF 35 00 00 00 00 8D 85 98 13 40 00 89 20 89
68 04 8D 9D 4F 14 40 00 89 58 08 64 89 25 00 00
00 00 8B 74 24 0C 66 81 3E 4D 5A 74 05 E9 8A 00
00 00 03 76 3C 81 3E 50 45 00 00 74 02 EB 7D 8B
7C 24 10 B9 96 00 00 00 32 C0 F2 AE 8B CF 2B 4C
24 10 8B 56 78 03 54 24 0C 8B 5A 20 03 5C 24 0C
33 C0 8B 3B 03 7C 24 0C 8B 74 24 10 51 F3 A6 75
05 83 C4 04 EB 0A 59 83 C3 04 40 3B 42 18 75 E2
3B 42 18 75 02 EB 35 8B 72 24 03 74 24 0C 52 BB
02 00 00 00 33 D2 F7 E3 5A 03 C6 33 C9 66 8B 08
8B 7A 1C 33 D2 BB 04 00 00 00 8B C1 F7 E3 03 44
24 0C 03 C7 8B 00 03 44 24 0C EB 02 33 C0 64 8F
05 00 00 00 00 83 C4 04 C2 08 00 E8 B5 FA FF FF

JAM v2.11
24
50 06 16 07 BE ?? ?? 8B FE B9 ?? ?? FD FA F3 2E
A5 FB 06 BD ?? ?? 55 CB

JDPack
36
60 E8 ?? ?? ?? ?? 5D 8B D5 81 ED ?? ?? ?? ?? 2B
95 ?? ?? ?? ?? 81 EA 06 ?? ?? ?? 89 95 ?? ?? ??
?? 83 BD 45

JDPack 2.x -> JDPack
21
55 8B EC 6A FF 68 68 51 40 00 68 04 25 40 00 64
A1 00 00 00 00

JDPack V2.00 -> JDPack
69
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 ?? ?? ??
E8 01 00 00 00 ?? ?? ?? ?? ?? ?? 05 00 00 00 00
83 C4 0C 5D 60 E8 00 00 00 00 5D 8B D5 64 FF 35
00 00 00 00 EB

JExeCompressor 1.0 - by Arash Veyskarami
113
8D 2D D3 4A E5 14 0F BB F7 0F BA E5 73 0F AF D5
8D 0D 0C 9F E6 11 C0 F8 EF F6 DE 80 DC 5B F6 DA
0F A5 C1 0F C1 F1 1C F3 4A 81 E1 8C 1F 66 91 0F
BE C6 11 EE 0F C0 E7 33 D9 64 F2 C0 DC 73 0F C0
D5 55 8B EC BA C0 1F 41 00 8B C2 B9 97 00 00 00
80 32 79 50 B8 02 00 00 00 50 03 14 24 58 58 51
2B C9 B9 01 00 00 00 83 EA 01 E2 FB 59 E2 E1 FF
E0

Joiner (sign from pinch 25.03.2007 20:10)
63
81 EC 04 01 00 00 8B F4 68 04 01 00 00 56 6A 00
E8 7C 01 00 00 33 C0 6A 00 68 80 00 00 00 6A 03
6A 00 6A 00 68 00 00 00 80 56 E8 50 01 00 00 8B
D8 6A 00 6A 00 6A 00 6A 02 6A 00 53 E8 44 01

KBys Packer 0.28 Beta -> Shoooo
81
60 E8 00 00 00 00 5E 83 EE 0A 8B 06 03 C2 8B 08
89 4E F3 83 EE 0F 56 52 8B F0 AD AD 03 C2 8B D8
6A 04 BF 00 10 00 00 57 57 6A 00 FF 53 08 5A 59
BD 00 80 00 00 55 6A 00 50 51 52 50 89 06 AD AD
03 C2 50 AD 03 C2 FF D0 6A 04 57 AD 50 6A 00 FF
53

KByS V0.22 -> shoooo
23
68 ?? ?? ?? ?? E8 01 00 00 00 C3 C3 11 55 07 8B
EC B8 ?? ?? ?? ?? E8

KByS V0.28 -> shoooo
27
68 ?? ?? ?? ?? E8 01 00 00 00 C3 C3 60 8B 74 24
24 8B 7C 24 28 FC B2 80 33 DB A4

KByS V0.28 DLL -> shoooo
24
B8 ?? ?? ?? ?? BA ?? ?? ?? ?? 03 C2 FF E0 ?? ??
?? ?? 60 E8 00 00 00 00

KGB SFX
64
60 BE 00 A0 46 00 8D BE 00 70 F9 FF 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73

KGCrypt vx.x
31
E8 ?? ?? ?? ?? 5D 81 ED ?? ?? ?? ?? 64 A1 30 ??
?? ?? 84 C0 74 ?? 64 A1 20 ?? ?? ?? 0B C0 74

kkrunchy -> Ryd
85
BD 08 ?? ?? 00 C7 45 00 ?? ?? ?? 00 FF 4D 08 C6
45 0C 05 8D 7D 14 31 C0 B4 04 89 C1 F3 AB BF ??
?? ?? 00 57 BE ?? ?? ?? 00 31 C9 41 FF 4D 0C 8D
9C 8D A0 00 00 00 FF D6 10 C9 73 F3 FF 45 0C 91
AA 83 C9 FF 8D 5C 8D 18 FF D6 74 DD E3 17 8D 5D
1C FF D6 74 10

kkrunchy 0.23 alpha -> Ryd
225
BD 08 ?? ?? 00 C7 45 00 ?? ?? ?? 00 FF 4D 08 C6
45 0C 05 8D 7D 14 31 C0 B4 04 89 C1 F3 AB BF ??
?? ?? 00 57 BE ?? ?? ?? 00 31 C9 41 FF 4D 0C 8D
9C 8D A0 00 00 00 FF D6 10 C9 73 F3 FF 45 0C 91
AA 83 C9 FF 8D 5C 8D 18 FF D6 74 DD E3 17 8D 5D
1C FF D6 74 10 8D 9D A0 08 00 00 E8 ?? 00 00 00
8B 45 10 EB 42 8D 9D A0 04 00 00 E8 ?? 00 00 00
49 49 78 40 8D 5D 20 74 03 83 C3 40 31 D2 42 E8
?? 00 00 00 8D 0C 48 F6 C2 10 74 F3 41 91 8D 9D
A0 08 00 00 E8 ?? 00 00 00 3D 00 08 00 00 83 D9
FF 83 F8 60 83 D9 FF 89 45 10 56 89 FE 29 C6 F3
A4 5E EB 90 BE ?? ?? ?? 00 BB ?? ?? ?? 00 55 46
AD 85 C0 74 ?? 97 56 FF 13 85 C0 74 16 95 AC 84
C0 75 FB 38 06 74 E8 78 ?? 56 55 FF 53 04 AB 85
C0

kkrunchy 0.23 alpha 2 -> Ryd
62
BD ?? ?? ?? ?? C7 45 00 ?? ?? ?? 00 B8 ?? ?? ??
00 89 45 04 89 45 54 50 C7 45 10 ?? ?? ?? 00 FF
4D 0C FF 45 14 FF 45 58 C6 45 1C 08 B8 00 08 00
00 8D 7D 30 AB AB AB AB BB 00 00 D8 00 BF

kkrunchy 0.23 alpha 2 -> Ryd
94
BD ?? ?? ?? ?? C7 45 00 ?? ?? ?? 00 B8 ?? ?? ??
00 89 45 04 89 45 54 50 C7 45 10 ?? ?? ?? 00 FF
4D 0C FF 45 14 FF 45 58 C6 45 1C 08 B8 00 08 00
00 8D 7D 30 AB AB AB AB BB 00 00 D8 00 BF ?? ??
?? 01 31 C9 41 8D 74 09 01 B8 CA 8E 2A 2E 99 F7
F6 01 C3 89 D8 C1 E8 15 AB FE C1 75 E8 BE

kkrunchy v0.17 -> F. Giesen
10
FC FF 4D 08 31 D2 8D 7D 30 BE

kkrunchy V0.2X -> Ryd
56
BD ?? ?? ?? ?? C7 45 ?? ?? ?? ?? ?? FF 4D 08 C6
45 0C 05 8D 7D 14 31 C0 B4 04 89 C1 F3 AB BF ??
?? ?? ?? 57 BE ?? ?? ?? ?? 31 C9 41 FF 4D 0C 8D
9C 8D A0 00 00 00 FF D6

Krypton v0.2
16
8B 0C 24 E9 0A 7C 01 ?? AD 42 40 BD BE 9D 7A 04

Krypton v0.3
21
8B 0C 24 E9 C0 8D 01 ?? C1 3A 6E CA 5D 7E 79 6D
B3 64 5A 71 EA

Krypton v0.4
24
54 E8 ?? ?? ?? ?? 5D 8B C5 81 ED 61 34 ?? ?? 2B
85 60 37 ?? ?? 83 E8 06

Krypton v0.5
24
54 E8 ?? ?? ?? ?? 5D 8B C5 81 ED 71 44 ?? ?? 2B
85 64 60 ?? ?? EB 43 DF

kryptor 5
12
E8 03 ?? ?? ?? E9 EB 6C 58 40 FF E0

kryptor 6
19
E8 03 ?? ?? ?? E9 EB 68 58 33 D2 74 02 E9 E9 40
42 75 02

kryptor 9
31
60 E8 ?? ?? ?? ?? 5E B9 ?? ?? ?? ?? 2B C0 02 04
0E D3 C0 49 79 F8 41 8D 7E 2C 33 46 ?? 66 B9

LameCrypt -> LaZaRus
31
60 66 9C BB 00 ?? ?? 00 80 B3 00 10 40 00 90 4B
83 FB FF 75 F3 66 9D 61 B8 ?? ?? 40 00 FF E0

LameCrypt v1.0
24
60 66 9C BB ?? ?? ?? ?? 80 B3 00 10 40 00 90 4B
83 FB FF 75 F3 66 9D 61

LamerStop v1.0c (c) Stefan Esser
32
E8 ?? ?? 05 ?? ?? CD 21 33 C0 8E C0 26 ?? ?? ??
2E ?? ?? ?? 26 ?? ?? ?? 2E ?? ?? ?? BA ?? ?? FA

LaunchAnywhere v4.0.0.1
85
55 89 E5 53 83 EC 48 55 B8 FF FF FF FF 50 50 68
E0 3E 42 00 64 FF 35 00 00 00 00 64 89 25 00 00
00 00 68 C0 69 44 00 E8 E4 80 FF FF 59 E8 4E 29
00 00 E8 C9 0D 00 00 85 C0 75 08 6A FF E8 6E 2B
00 00 59 E8 A8 2C 00 00 E8 23 2E 00 00 FF 15 4C
C2 44 00 89 C3

Launcher Generator v1.03
85
68 00 20 40 00 68 10 20 40 00 6A 00 6A 00 6A 20
6A 00 6A 00 6A 00 68 F0 22 40 00 6A 00 E8 93 00
00 00 85 C0 0F 84 7E 00 00 00 B8 00 00 00 00 3B
05 68 20 40 00 74 13 6A ?? 68 60 23 40 00 68 20
23 40 00 6A 00 E8 83 00 00 00 A1 58 20 40 00 3B
05 6C 20 40 00

LOCK98 V1.00.28 -> keenvim
22
55 E8 00 00 00 00 5D 81 ?? ?? ?? ?? ?? EB 05 E9
?? ?? ?? ?? EB 08

Lockless Intro Pack
26
2C E8 ?? ?? ?? ?? 5D 8B C5 81 ED F6 73 ?? ?? 2B
85 ?? ?? ?? ?? 83 E8 06 89 85

LTC v1.3
24
54 E8 00 00 00 00 5D 8B C5 81 ED F6 73 40 00 2B
85 87 75 40 00 83 E8 06

LY_WGKX -> www.szleyu.com
8
4D 79 46 75 6E 00 62 73

Macromedia Windows Flash Projector/Player v3.0
46
55 8B EC 83 EC 44 56 FF 15 94 13 42 00 8B F0 B1
22 8A 06 3A C1 75 13 8A 46 01 46 3A C1 74 04 84
C0 75 F4 38 0E 75 0D 46 EB 0A 3C 20 7E 06

Macromedia Windows Flash Projector/Player v4.0
46
83 EC 44 56 FF 15 24 41 43 00 8B F0 8A 06 3C 22
75 1C 8A 46 01 46 3C 22 74 0C 84 C0 74 08 8A 46
01 46 3C 22 75 F4 80 3E 22 75 0F 46 EB 0C

Macromedia Windows Flash Projector/Player v5.0
85
83 EC 44 56 FF 15 70 61 44 00 8B F0 8A 06 3C 22
75 1C 8A 46 01 46 3C 22 74 0C 84 C0 74 08 8A 46
01 46 3C 22 75 F4 80 3E 22 75 0F 46 EB 0C 3C 20
7E 08 8A 46 01 46 3C 20 7F F8 8A 06 84 C0 74 0C
3C 20 7F 08 8A 46 01 46 84 C0 75 F4 8D 44 24 04
C7 44 24 30 00

Macromedia Windows Flash Projector/Player v6.0
46
83 EC 44 56 FF 15 24 81 49 00 8B F0 8A 06 3C 22
75 1C 8A 46 01 46 3C 22 74 0C 84 C0 74 08 8A 46
01 46 3C 22 75 F4 80 3E 22 75 0F 46 EB 0C

MarjinZ EXE-Scrambler SE - by MarjinZ
166
E8 A3 02 00 00 E9 35 FD FF FF FF 25 C8 20 00 10
6A 14 68 C0 21 00 10 E8 E4 01 00 00 FF 35 7C 33
00 10 8B 35 8C 20 00 10 FF D6 59 89 45 E4 83 F8
FF 75 0C FF 75 08 FF 15 88 20 00 10 59 EB 61 6A
08 E8 02 03 00 00 59 83 65 FC 00 FF 35 7C 33 00
10 FF D6 89 45 E4 FF 35 78 33 00 10 FF D6 89 45
E0 8D 45 E0 50 8D 45 E4 50 FF 75 08 E8 D1 02 00
00 89 45 DC FF 75 E4 8B 35 74 20 00 10 FF D6 A3
7C 33 00 10 FF 75 E0 FF D6 83 C4 1C A3 78 33 00
10 C7 45 FC FE FF FF FF E8 09 00 00 00 8B 45 DC
E8 A0 01 00 00 C3

MaskPE 1.6 -> yzkzero
10
36 81 2C 24 ?? ?? ?? 00 C3 60

MaskPE V2.0 -> yzkzero
28
B8 18 00 00 00 64 8B 18 83 C3 30 C3 40 3E 0F B6
00 C1 E0 ?? 83 C0 ?? 36 01 04 24 C3

MASM32
30
6A ?? 68 00 30 40 00 68 ?? 30 40 00 6A 00 E8 07
00 00 00 6A 00 E8 06 00 00 00 FF 25 08 20

Matrix Dongle -> TDi GmbH
192
00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64 72
65 73 73 00 4B 45 52 4E 45 4C 33 32 2E 44 4C 4C
00 E8 B6 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? E8 00 00 00 00 5B 2B D9 8B F8 8B 4C 24 2C
33 C0 2B CF F2 AA 8B 3C 24 8B 0A 2B CF 89 5C 24
20 80 37 A2 47 49 75 F9 8D 64 24 04 FF 64 24 FC
60 C7 42 08 ?? ?? ?? ?? E8 C5 FF FF FF C3 C2 F7
29 4E 29 5A 29 E6 86 8A 89 63 5C A2 65 E2 A3 A2

Matrix Dongle -> TDi GmbH
21
E8 00 00 00 00 E8 00 00 00 00 59 5A 2B CA 2B D1
E8 1A FF FF FF

MEGALITE v1.20a
24
B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 2D 73 ?? 72 ?? B4
09 BA ?? ?? CD 21 CD 90

MESS v1.20
18
?? ?? ?? ?? FA B9 ?? ?? F3 ?? ?? E3 ?? EB ?? EB
?? B6

Metrowerks CodeWarrior (DLL) v2.0
84
55 89 E5 53 56 57 8B 75 0C 8B 5D 10 83 FE 01 74
05 83 FE 02 75 12 53 56 FF 75 08 E8 6E FF FF FF
09 C0 75 04 31 C0 EB 21 53 56 FF 75 08 E8 ?? ??
?? ?? 89 C7 09 F6 74 05 83 FE 03 75 0A 53 56 FF
75 08 E8 47 FF FF FF 89 F8 8D 65 F4 5F 5E 5B 5D
C2 0C 00 C9

Metrowerks CodeWarrior v2.0 (Console)
59
55 89 E5 55 B8 FF FF FF FF 50 50 68 ?? ?? ?? ??
64 FF 35 00 00 00 00 64 89 25 00 00 00 00 68 ??
?? ?? ?? E8 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
E8 ?? ?? 00 00 E8 ?? ?? 00 00 E8

Metrowerks CodeWarrior v2.0 (GUI)
59
55 89 E5 53 56 83 EC 44 55 B8 FF FF FF FF 50 50
68 ?? ?? 40 00 64 FF 35 00 00 00 00 64 89 25 00
00 00 00 68 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
E8 ?? ?? 00 00 E8 ?? ?? 00 00 E8

MEW 10 by Northfox
12
33 C0 E9 ?? ?? FF FF ?? 1C ?? ?? 40

Mew 10 exe-coder 1.0  -> Northfox [HCC]
14
33 C0 E9 ?? ?? FF FF 6A ?? ?? ?? ?? ?? 70

MEW 11 SE v1.1
17
E9 ?? ?? ?? FF 0C ?? 00 00 00 00 00 00 00 00 00
00

MEW 11 SE v1.2
85
E9 ?? ?? ?? FF 0C ?? 00 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 0C ?? 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

Mew 11 SE v1.2 (Eng) -> Northfox
22
E9 ?? ?? ?? FF 0C ?? ?? 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 0C

MEW 11 SE v1.2 -> Northfox[HCC]
25
E9 ?? ?? ?? FF 0C ?? ?? 00 00 00 00 00 00 00 00
00 ?? ?? ?? 00 0C ?? ?? 00

MEW 5 1.0 -> Northfox
17
BE 5B 00 40 00 AD 91 AD 93 53 AD 96 56 5F AC C0
C0

Mew 5.0.1 -> NorthFox / HCC
120
BE 5B 00 40 00 AD 91 AD 93 53 AD 96 56 5F AC C0
C0 ?? 04 ?? C0 C8 ?? AA E2 F4 C3 00 ?? ?? 00 ??
?? ?? 00 00 10 40 00 4D 45 57 20 30 2E 31 20 62
79 20 4E 6F 72 74 68 66 6F 78 00 4D 45 57 20 30
2E 31 20 62 79 20 4E 6F 72 74 68 66 6F 78 00 4D
45 57 20 30 2E 31 20 62 79 20 4E 6F 72 74 68 66
6F 78 00 4D 45 57 20 30 2E 31 20 62 79 20 4E 6F
72 74 68 66 6F 78 00 4D

MicroJoiner 1.1 -> coban2k
19
BE 0C 70 40 00 BB F8 11 40 00 33 ED 83 EE 04 39
2E 74 11

MicroJoiner 1.5 -> coban2k
20
BF 05 10 40 00 83 EC 30 8B EC E8 C8 FF FF FF E8
C3 FF FF FF

MicroJoiner 1.6 -> coban2k
19
33 C0 64 8B 38 48 8B C8 F2 AF AF 8B 1F 66 33 DB
66 81 3B

MicroJoiner 1.7 -> coban2k
21
BF 00 10 40 00 8D 5F 21 6A 0A 58 6A 04 59 60 57
E8 8E 00 00 00

Microsoft Visual C++ V8.0
76
6A 14 68 ?? ?? ?? ?? E8 ?? ?? ?? ?? BB 94 00 00
00 53 6A 00 8B ?? ?? ?? ?? ?? FF D7 50 FF ?? ??
?? ?? ?? 8B F0 85 F6 75 0A 6A 12 E8 ?? ?? ?? ??
59 EB 18 89 1E 56 FF ?? ?? ?? ?? ?? 56 85 C0 75
14 50 FF D7 50 FF ?? ?? ?? ?? ?? B8

Microsoft Visual C++ V8.0 (Debug)
101
E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9
?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ??
?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ??
?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ??
?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ??
E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9 ?? ?? ?? ?? E9
?? ?? ?? ?? E9

MinGW GCC 3.x
33
55 89 E5 83 EC 08 C7 04 24 ?? 00 00 00 FF 15 ??
?? ?? ?? E8 ?? ?? FF FF ?? ?? ?? ?? ?? ?? ?? ??
55

Minke 1.0.1 - by Codius
208
55 8B EC 83 C4 F0 53 ?? ?? ?? ?? ?? 10 E8 7A F6
FF FF BE 68 66 00 10 33 C0 55 68 DB 40 00 10 64
FF 30 64 89 20 E8 FA F8 FF FF BA EC 40 00 10 8B
C6 E8 F2 FA FF FF 8B D8 B8 6C 66 00 10 8B 16 E8
88 F2 FF FF B8 6C 66 00 10 E8 76 F2 FF FF 8B D0
8B C3 8B 0E E8 E3 E4 FF FF E8 2A F9 FF FF E8 C1
F8 FF FF B8 6C 66 00 10 8B 16 E8 6D FA FF FF E8
14 F9 FF FF E8 AB F8 FF FF 8B 06 E8 B8 E3 FF FF
8B D8 B8 6C 66 00 10 E8 38 F2 FF FF 8B D3 8B 0E
E8 A7 E4 FF ?? ?? ?? ?? C4 FB FF FF E8 E7 F8 FF
FF 8B C3 E8 B0 E3 FF FF E8 DB F8 FF FF 33 C0 5A
59 59 64 89 10 68 E2 40 00 10 C3 E9 50 EB FF FF
EB F8 5E 5B E8 BB EF FF FF 00 00 00 43 41 31 38

Minke V1.0.1 -> Codius
84
26 3D 4F 38 C2 82 37 B8 F3 24 42 03 17 9B 3A 83
01 00 00 CC 00 00 00 00 06 00 00 00 01 64 53 74
75 62 00 10 55 54 79 70 65 73 00 00 C7 53 79 73
74 65 6D 00 00 81 53 79 73 49 6E 69 74 00 0C 4B
57 69 6E 64 6F 77 73 00 00 8A 75 46 75 6E 63 74
69 6F 6E 73

mkfpack -> llydd
66
E8 00 00 00 00 5B 81 EB 05 00 00 00 8B 93 9F 08
00 00 53 6A 40 68 00 10 00 00 52 6A 00 FF 93 32
08 00 00 5B 8B F0 8B BB 9B 08 00 00 03 FB 56 57
E8 86 08 00 00 83 C4 08 8D 93 BB 08 00 00 52 53
FF E6

modified HACKSTOP v1.11f
21
52 B4 30 CD 21 52 FA ?? FB 3D ?? ?? EB ?? CD 20
0E 1F B4 09 E8

MoleBox v2.0
8
E8 ?? ?? ?? ?? 60 E8 4F

MoleBox v2.3.0 -> Teggo
80
42 04 E8 ?? ?? 00 00 A3 ?? ?? ?? 00 8B 4D F0 8B
11 89 15 ?? ?? ?? 00 ?? 45 FC A3 ?? ?? ?? 00 5F
5E 8B E5 5D C3 CC CC CC CC CC CC CC CC CC CC CC
E8 EB FB FF FF 58 E8 ?? 07 00 00 58 89 44 24 20
61 58 FF D0 E8 ?? ?? 00 00 CC CC CC CC CC CC CC

MoleBox V2.3X -> MoleStudio.com
11
E8 00 00 00 00 60 E8 4F 00 00 00

MoleBox v2.5.4 -> Teggo
80
?? ?? ?? 00 8B 4D F0 8B 11 89 15 ?? ?? ?? 00 8B
45 FC A3 ?? ?? ?? 00 5F 5E 8B E5 5D C3 CC CC CC
E8 EB FB FF FF 58 E8 ?? 07 00 00 58 89 44 24 24
61 58 58 FF D0 E8 ?? ?? 00 00 6A 00 FF 15 ?? ??
?? 00 CC CC CC CC CC CC CC CC CC CC CC CC CC CC

Morphine v2.7 --> Holy_Father & Ratter/29A
85
00 00 00 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

Morphine v2.7 --> Holy_Father & Ratter/29A
85
?? ?? ?? ?? 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 47 65
74 50 72 6F 63

Morphine V2.7 -> Holy_Father & Ratter/29A
85
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 4B 65 52 6E
45 6C 33 32 2E 64 4C 6C 00 00 47 65 74 50 72 6F
63 41 64 64 72

Morphine v3.3 -> Silent Software & Silent Shield (c)2005
85
28 ?? ?? ?? 00 00 00 00 00 00 00 00 40 ?? ?? ??
34 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4C ?? ?? ?? 5C ?? ?? ??
00 00 00 00 4C ?? ?? ?? 5C ?? ?? ?? 00 00 00 00
4B 65 52 6E 45 6C 33 32 2E 64 4C 6C 00 00 47 65
74 50 72 6F 63

Morphine v3.3 -> Silent Software & Silent Shield (c)2005
106
28 ?? ?? ?? 00 00 00 00 00 00 00 00 40 ?? ?? ??
34 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4C ?? ?? ?? 5C ?? ?? ??
00 00 00 00 4C ?? ?? ?? 5C ?? ?? ?? 00 00 00 00
4B 65 52 6E 45 6C 33 32 2E 64 4C 6C 00 00 47 65
74 50 72 6F 63 41 64 64 72 65 73 73 00 00 4C 6F
61 64 4C 69 62 72 61 72 79 41

mPack 0.0.3 -> DeltaAziz
181
55 8B EC 83 C4 F0 33 C0 89 45 F0 B8 A8 76 00 10
E8 67 C4 FF FF 33 C0 55 68 C2 78 00 10 64 FF 30
64 89 20 8D 55 F0 33 C0 E8 93 C8 FF FF 8B 45 F0
E8 87 CB FF FF A3 08 A5 00 10 33 C0 55 68 A5 78
00 10 64 FF 30 64 89 20 A1 08 A5 00 10 E8 FA C9
FF FF 83 F8 FF 75 0A E8 88 B2 FF FF E9 1B 01 00
00 C7 05 14 A5 00 10 32 00 00 00 A1 08 A5 00 10
8B 15 14 A5 00 10 E8 C9 C9 FF FF BA 14 A5 00 10
A1 08 A5 00 10 B9 04 00 00 00 E8 C5 C9 FF FF 83
3D 14 A5 00 10 32 77 0A E8 47 B2 FF FF E9 DA 00
00 00 A1 08 A5 00 10 8B 15 14 A5 00 10 E8 92 C9
FF FF BA 18 A5

MS Visual C++ v.8 DLL (h-small sig1)
27
8B FF 55 8B EC 83 7D 0C 01 75 05 E8 ?? ?? ?? FF
5D E9 D6 FE FF FF CC CC CC CC CC

MS Visual C++ v.8 DLL (h-small sig2)
28
8B FF 55 8B EC 53 8B 5D 08 56 8B 75 0C 85 F6 57
8B 7D 10 0F 84 ?? ?? 00 00 83 FE 01

mucki's protector I -> mucki
20
BE ?? ?? ?? ?? B9 ?? ?? ?? ?? 8A 06 F6 D0 88 06
46 E2 F7 E9

mucki's protector II -> mucki
87
E8 24 00 00 00 8B 4C 24 0C C7 01 17 00 01 00 C7
81 B8 00 00 00 00 00 00 00 31 C0 89 41 14 89 41
18 80 6A 00 E8 85 C0 74 12 64 8B 3D 18 00 00 00
8B 7F 30 0F B6 47 02 85 C0 74 01 C3 C7 04 24 ??
?? ?? ?? BE ?? ?? ?? ?? B9 ?? ?? ?? ?? 8A 06 F6
D0 88 06 46 E2 F7 C3

MZ0oPE 1.0.6b --> TaskFall
43
EB CA 89 03 83 C3 04 87 FE 32 C0 AE 75 FD 87 FE
80 3E FF 75 E2 46 5B 83 C3 04 53 8B 1B 80 3F FF
75 C9 8B E5 61 68 ?? ?? ?? ?? C3

MZ0oPE 1.0.6b -> TaskFall
193
EB CA 89 03 83 C3 04 87 FE 32 C0 AE 75 FD 87 FE
80 3E FF 75 E2 46 5B 83 C3 04 53 8B 1B 80 3F FF
75 C9 8B E5 61 68 ?? ?? ?? ?? C3 FC B2 80 33 DB
A4 B3 02 E8 6D 00 00 00 73 F6 33 C9 E8 64 00 00
00 73 1C 33 C0 E8 5B 00 00 00 73 23 B3 02 41 B0
10 E8 4F 00 00 00 12 C0 73 F7 75 3F AA EB D4 E8
4D 00 00 00 2B CB 75 10 E8 42 00 00 00 EB 28 AC
D1 E8 74 4C 13 C9 EB 1C 91 48 C1 E0 08 AC E8 2C
00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83
F8 7F 77 02 41 41 95 8B C5 B3 01 56 8B F7 2B F0
F3 A4 5E EB 8E 02 D2 75 05 8A 16 46 12 D2 C3 33
C9 41 E8 EE FF FF FF 13 C9 E8 E7 FF FF FF 72 F2
C3

MZ_Crypt 1.0 - by BrainSt0rm
84
60 E8 00 00 00 00 5D 81 ED 25 14 40 00 8B BD 77
14 40 00 8B 8D 7F 14 40 00 EB 28 83 7F 1C 07 75
1E 8B 77 0C 03 B5 7B 14 40 00 33 C0 EB 0C 50 8A
A5 83 14 40 00 30 26 58 40 46 3B 47 10 76 EF 83
C7 28 49 0B C9 75 D4 8B 85 73 14 40 00 89 44 24
1C 61 FF E0

N-Joiner 0.1 (Asm Version) -> NEX
117
6A 00 68 00 14 40 00 68 00 10 40 00 6A 00 E8 14
00 00 00 6A 00 E8 13 00 00 00 CC FF 25 AC 12 40
00 FF 25 B0 12 40 00 FF 25 B4 12 40 00 FF 25 B8
12 40 00 FF 25 BC 12 40 00 FF 25 C0 12 40 00 FF
25 C4 12 40 00 FF 25 C8 12 40 00 FF 25 CC 12 40
00 FF 25 D0 12 40 00 FF 25 D4 12 40 00 FF 25 D8
12 40 00 FF 25 DC 12 40 00 FF 25 E4 12 40 00 FF
25 EC 12 40 00

N-Joy 1.0 -> NEX
40
55 8B EC 83 C4 F0 B8 9C 3B 40 00 E8 8C FC FF FF
6A 00 68 E4 39 40 00 6A 0A 6A 00 E8 40 FD FF FF
E8 EF F5 FF FF 8D 40 00

N-Joy 1.1 -> NEX
40
55 8B EC 83 C4 F0 B8 0C 3C 40 00 E8 24 FC FF FF
6A 00 68 28 3A 40 00 6A 0A 6A 00 E8 D8 FC FF FF
E8 7F F5 FF FF 8D 40 00

N-Joy 1.2 -> NEX
40
55 8B EC 83 C4 F0 B8 A4 32 40 00 E8 E8 F1 FF FF
6A 00 68 54 2A 40 00 6A 0A 6A 00 E8 A8 F2 FF FF
E8 C7 EA FF FF 8D 40 00

N-Joy 1.3 -> NEX
40
55 8B EC 83 C4 F0 B8 48 36 40 00 E8 54 EE FF FF
6A 00 68 D8 2B 40 00 6A 0A 6A 00 E8 2C EF FF FF
E8 23 E7 FF FF 8D 40 00

Nakedbind 1.0 -> nakedcrew
25
64 8B 38 48 8B C8 F2 AF AF 8B 1F 66 33 DB 66 81
3B 4D 5A 74 08 81 EB 00 00

NakedPacker 1.0 - by BigBoote
143
60 FC 0F B6 05 34 ?? ?? ?? 85 C0 75 31 B8 50 ??
?? ?? 2B 05 04 ?? ?? ?? A3 30 ?? ?? ?? A1 00 ??
?? ?? 03 05 30 ?? ?? ?? A3 38 ?? ?? ?? E8 9A 00
00 00 A3 50 ?? ?? ?? C6 05 34 ?? ?? ?? 01 83 3D
50 ?? ?? ?? 00 75 07 61 FF 25 38 ?? ?? ?? 61 FF
74 24 04 6A 00 FF 15 44 ?? ?? ?? 50 FF 15 40 ??
?? ?? C3 FF 74 24 04 6A 00 FF 15 44 ?? ?? ?? 50
FF 15 48 ?? ?? ?? C3 8B 4C 24 04 56 8B 74 24 10
57 85 F6 8B F9 74 0D 8B 54 24 10 8A 02 88 01

Native UD Packer 1.1 (Modded Poison Ivy Shellcode) -> okkixot
200
31 C0 31 DB 31 C9 EB 0E 6A 00 6A 00 6A 00 6A 00
FF 15 28 41 40 00 FF 15 94 40 40 00 89 C7 68 88
13 00 00 FF 15 98 40 40 00 FF 15 94 40 40 00 81
C7 88 13 00 00 39 F8 73 05 E9 84 00 00 00 6A 40
68 00 10 00 00 FF 35 04 30 40 00 6A 00 FF 15 A4
40 40 00 89 C7 FF 35 04 30 40 00 68 CA 10 40 00
50 FF 15 A8 40 40 00 6A 40 68 00 10 00 00 FF 35
08 30 40 00 6A 00 FF 15 A4 40 40 00 89 C6 68 00
30 40 00 FF 35 04 30 40 00 57 FF 35 08 30 40 00
50 6A 02 FF 15 4E 41 40 00 6A 00 6A 00 6A 00 56
6A 00 6A 00 FF 15 9C 40 40 00 50 6A 00 6A 00 6A
11 50 FF 15 4A 41 40 00 58 6A FF 50 FF 15 AC 40
40 00 6A 00 FF 15 A0 40

nBinder v3.6.1
40
6E 35 36 34 35 36 35 33 32 33 34 35 34 33 5F 6E
62 33 5C 00 5C 6E 35 36 34 35 36 35 33 32 33 34
35 34 33 5F 6E 62 33 5C

nBinder v4.0
76
5C 6E 62 34 5F 74 6D 70 5F 30 31 33 32 34 35 34
33 35 30 5C 00 00 00 00 00 00 00 00 00 E9 55 43
4C FF 01 1A 00 00 00 00 96 30 07 77 2C 61 0E EE
BA 51 09 99 19 C4 6D 07 8F F4 6A 70 35 A5 63 E9
A3 95 64 9E 32 88 DB 0E A4 B8 DC 79

nbuild v1.0 [soft]
14
B9 ?? ?? BB ?? ?? C0 ?? ?? 80 ?? ?? 43 E2

NeoLite v1.0
28
8B 44 24 04 8D 54 24 FC 23 05 ?? ?? ?? ?? E8 ??
?? ?? ?? FF 35 ?? ?? ?? ?? 50 FF 25

NeoLite v2.0
36
E9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 4E 65 6F
4C 69 74 65

NeoLite v2.00
28
8B 44 24 04 23 05 ?? ?? ?? ?? 50 E8 ?? ?? ?? ??
83 C4 04 FE 05 ?? ?? ?? ?? 0B C0 74

NFO v1.0
18
8D 50 12 2B C9 B1 1E 8A 02 34 77 88 02 42 E2 F7
C8 8C

Ningishzida 1.0 -> CyberDoom
80
9C 60 96 E8 00 00 00 00 5D 81 ED 03 25 40 00 B9
04 1B 00 00 8D BD 4B 25 40 00 8B F7 AC ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? AA E2 CC

nMacro recorder 1.0
52
5C 6E 6D 72 5F 74 65 6D 70 2E 6E 6D 72 00 00 00
72 62 00 00 58 C7 41 00 10 F8 41 00 11 01 00 00
00 00 00 00 46 E1 00 00 46 E1 00 00 35 00 00 00
F6 88 41 00

NME 1.1 Public - by redlime
264
55 8B EC 83 C4 F0 53 56 B8 30 35 14 13 E8 9A E6
FF FF 33 C0 55 68 6C 36 14 13 64 FF 30 64 89 20
B8 08 5C 14 13 BA 84 36 14 13 E8 7D E2 FF FF E8
C0 EA FF FF 8B 15 CC 45 14 13 A1 C8 45 14 13 E8
04 F8 FF FF 8B 15 D0 45 14 13 A1 C8 45 14 13 E8
F4 F7 FF FF 8B 15 CC 45 14 13 A1 C8 45 14 13 E8
2C F9 FF FF A3 F8 5A 14 13 8B 15 D0 45 14 13 A1
C8 45 14 13 E8 17 F9 FF FF A3 FC 5A 14 13 B8 04
5C 14 13 E8 20 FB FF FF 8B D8 85 DB 74 48 B8 00
5B 14 13 8B 15 C4 45 14 13 E8 1E E7 FF FF A1 04
5C 14 13 E8 A8 DA FF FF ?? ?? ?? ?? 5C 14 13 50
8B CE 8B D3 B8 00 5B 14 13 ?? ?? ?? ?? FF 8B C6
E8 DF FB FF FF 8B C6 E8 9C DA FF FF B8 00 5B 14
13 E8 72 E7 FF FF 33 C0 5A 59 59 64 89 10 68 73
36 14 13 C3 E9 0F DF FF FF EB F8 5E 5B E8 7E E0
FF FF 00 00 FF FF FF FF 0C 00 00 00 4E 4D 45 20
31 2E 31 20 53 74 75 62

NoodleCrypt v2.0
26
EB 01 9A E8 3D 00 00 00 EB 01 9A E8 EB 01 00 00
EB 01 9A E8 2C 04 00 00 EB 01

NoodleCrypt v2.0
26
EB 01 9A E8 ?? 00 00 00 EB 01 9A E8 ?? ?? 00 00
EB 01 9A E8 ?? ?? 00 00 EB 01

NoodleCrypt v2.00 (Eng) -> NoodleSpa
85
EB 01 9A E8 76 00 00 00 EB 01 9A E8 65 00 00 00
EB 01 9A E8 7D 00 00 00 EB 01 9A E8 55 00 00 00
EB 01 9A E8 43 04 00 00 EB 01 9A E8 E1 00 00 00
EB 01 9A E8 3D 00 00 00 EB 01 9A E8 EB 01 00 00
EB 01 9A E8 2C 04 00 00 EB 01 9A E8 25 00 00 00
EB 01 9A E8 02

Noodlecrypt2 -> r!sc
8
EB 01 9A E8 76 00 00 00

North Star PE Shrinker 1.3 -> Liuxingping
22
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5

North Star PE Shrinker v1.3 by Liuxingping
85
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5 73 ?? FF FF 8B 06 83 F8 00 74
11 8D B5 7F ?? FF FF 8B 06 83 F8 01 0F 84 F1 01
00 00 C7 06 01 00 00 00 8B D5 8B 85 4F ?? FF FF
2B D0 89 95 4F ?? FF FF 01 95 67 ?? FF FF 8D B5
83 ?? FF FF 01

nPack 1.1.150.2006.Beta -> NEOx
135
83 3D ?? ?? ?? ?? ?? 75 05 E9 01 00 00 00 C3 E8
41 00 00 00 B8 ?? ?? ?? ?? 2B 05 ?? ?? ?? ?? A3
?? ?? ?? ?? E8 5E 00 00 00 E8 E0 01 00 00 E8 EC
06 00 00 E8 F7 05 00 00 A1 ?? ?? ?? ?? C7 05 ??
?? ?? ?? ?? ?? ?? ?? 01 05 ?? ?? ?? ?? FF 35 ??
?? ?? ?? C3 C3 56 57 68 ?? ?? ?? ?? FF 15 ?? ??
?? ?? 8B 35 ?? ?? ?? ?? 8B F8 68 ?? ?? ?? ?? 57
FF D6 68 ?? ?? ?? ?? 57 A3 ?? ?? ?? ?? FF D6 5F
A3 ?? ?? ?? ?? 5E C3

nPack 1.1.300.2006 Beta -> NEOx
140
83 3D ?? ?? ?? ?? ?? 75 05 E9 01 00 00 00 C3 E8
46 00 00 00 E8 73 00 00 00 B8 ?? ?? ?? ?? 2B 05
?? ?? ?? ?? A3 ?? ?? ?? ?? E8 9C 00 00 00 E8 2D
02 00 00 E8 DD 06 00 00 E8 2C 06 00 00 A1 ?? ??
?? ?? C7 05 ?? ?? ?? ?? ?? ?? ?? ?? 01 05 ?? ??
?? ?? FF 35 ?? ?? ?? ?? C3 C3 56 57 68 ?? ?? ??
?? FF 15 ?? ?? ?? ?? 8B 35 ?? ?? ?? ?? 8B F8 68
?? ?? ?? ?? 57 FF D6 68 ?? ?? ?? ?? 57 A3 ?? ??
?? ?? FF D6 5F A3 ?? ?? ?? ?? 5E C3

nPack v1.1 150-200 Beta -> NEOx
56
83 3D 40 ?? ?? ?? 00 75 05 E9 01 00 00 00 C3 E8
41 00 00 00 B8 80 ?? ?? ?? 2B 05 08 ?? ?? ?? A3
3C ?? ?? 00 E8 5E 00 00 00 E8 E0 01 00 00 E8 EC
06 00 00 E8 F7 05 00 00

nPack v1.1 250 Beta -> NEOx
85
83 3D 04 ?? ?? ?? 00 75 05 E9 01 00 00 00 C3 E8
46 00 00 00 E8 73 00 00 00 B8 2E ?? ?? ?? 2B 05
08 ?? ?? ?? A3 00 ?? ?? ?? E8 9C 00 00 00 E8 04
02 00 00 E8 FB 06 00 00 E8 1B 06 00 00 A1 00 ??
?? ?? C7 05 04 ?? ?? ?? 01 00 00 00 01 05 00 ??
?? ?? FF 35 00

nPack V1.1.150.2006.Beta -> NEOx/[uinC]
85
83 3D 40 ?? ?? ?? 00 75 05 E9 01 00 00 00 C3 E8
41 00 00 00 B8 80 ?? ?? ?? 2B 05 08 ?? ?? ?? A3
3C ?? ?? ?? E8 5E 00 00 00 E8 E0 01 00 00 E8 EC
06 00 00 E8 F7 05 00 00 A1 3C ?? ?? ?? C7 05 40
?? ?? ?? 01 00 00 00 01 05 00 ?? ?? ?? FF 35 00
?? ?? ?? C3 C3

nPack V1.1.200.2006.Beta -> NEOx/[uinC]
85
83 3D 40 ?? ?? ?? 00 75 05 E9 01 00 00 00 C3 E8
41 00 00 00 B8 80 ?? ?? ?? 2B 05 08 ?? ?? ?? A3
3C ?? ?? ?? E8 5E 00 00 00 E8 EC 01 00 00 E8 F8
06 00 00 E8 03 06 00 00 A1 3C ?? ?? ?? C7 05 40
?? ?? ?? 01 00 00 00 01 05 00 ?? ?? ?? FF 35 00
?? ?? ?? C3 C3

NSIS Installer --> NullSoft
60
83 EC 20 53 55 56 33 DB 57 89 5C 24 18 C7 44 24
10 ?? ?? ?? ?? C6 44 24 14 20 FF 15 30 70 40 00
53 FF 15 80 72 40 00 68 ?? ?? ?? ?? 68 ?? ?? ??
?? A3 ?? ?? ?? ?? E8 ?? ?? ?? ?? BE

NsPacK .Net -> LiuXingPing
71
56 69 72 74 75 61 6C 50 72 6F 74 65 63 74 00 00
BB 01 47 65 74 53 79 73 74 65 6D 49 6E 66 6F 00
4B 45 52 4E 45 4C 33 32 2E 64 6C 6C 00 00 5E 00
5F 43 6F 72 ?? ?? ?? 4D 61 69 6E 00 6D 73 63 6F
72 65 65 2E 64 6C 6C

NsPack 1.4 -> Liuxingping
18
9C 60 E8 00 00 00 00 5D B8 ?? ?? 40 00 2D ?? ??
40 00

NsPack 1.4 by North Star (Liu Xing Ping)
43
8B DF 83 3F 00 75 0A 83 C7 04 B9 00 00 00 00 EB
16 B9 01 00 00 00 03 3B 83 C3 04 83 3B 00 74 2D
01 13 8B 33 03 7B 04 57 51 52 53

NsPack 2.9 -> North Star
174
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5 ?? ?? FF FF 8A 06 3C 00 74 12 8B F5 8D B5 ??
?? FF FF 8A 06 3C 01 0F 84 42 02 00 00 C6 06 01
8B D5 2B 95 ?? ?? FF FF 89 95 ?? ?? FF FF 01 95
?? ?? FF FF 8D B5 ?? ?? FF FF 01 16 60 6A 40 68
00 10 00 00 68 00 10 00 00 6A 00 FF 95 ?? ?? FF
FF 85 C0 0F 84 6A 03 00 00 89 85 ?? ?? FF FF E8
00 00 00 00 5B B9 68 03 00 00 03 D9 50 53 E8 B1
02 00 00 61 8B 36 8B FD 03 BD ?? ?? FF FF 8B DF
83 3F 00 75 0A 83 C7 04 B9 00 00 00 00 EB 16 B9
01 00 00 00 03 3B 83 C3 04 83 3B 00 74 36

NsPack 3.0 -> North Star
180
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5 ?? ?? FF FF 66 8B 06 66 83 F8 00 74 15 8B F5
8D B5 ?? ?? FF FF 66 8B 06 66 83 F8 01 0F 84 42
02 00 00 C6 06 01 8B D5 2B 95 ?? ?? FF FF 89 95
?? ?? FF FF 01 95 ?? ?? FF FF 8D B5 ?? ?? FF FF
01 16 60 6A 40 68 00 10 00 00 68 00 10 00 00 6A
00 FF 95 ?? ?? FF FF 85 C0 0F 84 6A 03 00 00 89
85 ?? ?? FF FF E8 00 00 00 00 5B B9 68 03 00 00
03 D9 50 53 E8 B1 02 00 00 61 8B 36 8B FD 03 BD
?? ?? FF FF 8B DF 83 3F 00 75 0A 83 C7 04 B9 00
00 00 00 EB 16 B9 01 00 00 00 03 3B 83 C3 04 83
3B 00 74 36

NsPack 3.4 -> North Star
209
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 85 ?? ?? FF
FF 80 38 01 0F 84 42 02 00 00 C6 00 01 8B D5 2B
95 ?? ?? FF FF 89 95 ?? ?? FF FF 01 95 ?? ?? FF
FF 8D B5 ?? ?? FF FF 01 16 60 6A 40 68 00 10 00
00 68 00 10 00 00 6A 00 FF 95 ?? ?? FF FF 85 C0
0F 84 6A 03 00 00 89 85 ?? ?? FF FF E8 00 00 00
00 5B B9 68 03 00 00 03 D9 50 53 E8 B1 02 00 00
61 8B 36 8B FD 03 BD ?? ?? FF FF 8B DF 83 3F 00
75 0A 83 C7 04 B9 00 00 00 00 EB 16 B9 01 00 00
00 03 3B 83 C3 04 83 3B 00 74 36 01 13 8B 33 03
7B 04 57 51 52 53 FF B5 ?? ?? FF FF FF B5 ?? ??
FF FF 8B D6 8B CF 8B 85 ?? ?? FF FF 05 AA 05 00
00 FF D0 5B 5A 59 5F 83 F9 00 74 05 83 C3 08 EB
C5

NSPack 3.x -> Liu Xing Ping
29
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 85 ?? ?? FF
FF ?? 38 01 0F 84 ?? 02 00 00 ?? 00 01

NsPack V1.1 -> LiuXingPing
18
9C 60 E8 00 00 00 00 5D B8 57 84 40 00 2D 50 84
40 00

NsPack V1.3 -> LiuXingPing
18
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00

NsPack V1.4 -> LiuXingPing
18
9C 60 E8 00 00 00 00 5D B8 B1 85 40 00 2D AA 85
40 00

nSpack V2.3 -> LiuXingPing
8
9C 60 70 61 63 6B 24 40

NsPack v2.3 -> North Star
85
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5 ?? ?? FF FF 8B 06 83 F8 00 74 11 8D B5 ?? ??
FF FF 8B 06 83 F8 01 0F 84 4B 02 00 00 C7 06 01
00 00 00 8B D5 8B 85 ?? ?? FF FF 2B D0 89 95 ??
?? FF FF 01 95 ?? ?? FF FF 8D B5 ?? ?? FF FF 01
16 8B 36 8B FD

NsPack v2.3 -> North Star
141
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5 ?? ?? FF FF 8B 06 83 F8 00 74 11 8D B5 ?? ??
FF FF 8B 06 83 F8 01 0F 84 4B 02 00 00 C7 06 01
00 00 00 8B D5 8B 85 ?? ?? FF FF 2B D0 89 95 ??
?? FF FF 01 95 ?? ?? FF FF 8D B5 ?? ?? FF FF 01
16 8B 36 8B FD 60 6A 40 68 00 10 00 00 68 00 10
00 00 6A 00 FF 95 ?? ?? FF FF 85 C0 0F 84 56 03
00 00 89 85 ?? ?? FF FF E8 00 00 00 00 5B B9 54
03 00 00 03 D9 50 53 E8 9D 02 00 00 61

NsPack V2.X -> LiuXingPing
8
6E 73 70 61 63 6B 24 40

nSpack V2.x -> LiuXingPing
17
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5

NsPacK V3.0 -> LiuXingPing
29
9C 60 E8 00 00 00 00 5D B8 07 00 00 00 2B E8 8D
B5 ?? ?? ?? ?? 66 8B 06 66 83 F8 00 74

NsPacK V3.1 -> LiuXingPing
22
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 9D ?? ?? ??
?? 8A 03 3C 00 74

NsPack v3.1 -> North Star
85
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 9D ?? ?? FF
FF 8A 03 3C 00 74 10 8D 9D ?? ?? FF FF 8A 03 3C
01 0F 84 42 02 00 00 C6 03 01 8B D5 2B 95 ?? ??
FF FF 89 95 ?? ?? FF FF 01 95 ?? ?? FF FF 8D B5
?? ?? FF FF 01 16 60 6A 40 68 00 10 00 00 68 00
10 00 00 6A 00

NsPack v3.1 -> North Star
229
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 9D ?? ?? FF
FF 8A 03 3C 00 74 10 8D 9D ?? ?? FF FF 8A 03 3C
01 0F 84 42 02 00 00 C6 03 01 8B D5 2B 95 ?? ??
FF FF 89 95 ?? ?? FF FF 01 95 ?? ?? FF FF 8D B5
?? ?? FF FF 01 16 60 6A 40 68 00 10 00 00 68 00
10 00 00 6A 00 FF 95 ?? ?? FF FF 85 C0 0F 84 6A
03 00 00 89 85 ?? ?? FF FF E8 00 00 00 00 5B B9
68 03 00 00 03 D9 50 53 E8 B1 02 00 00 61 8B 36
8B FD 03 BD ?? ?? FF FF 8B DF 83 3F 00 75 0A 83
C7 04 B9 00 00 00 00 EB 16 B9 01 00 00 00 03 3B
83 C3 04 83 3B 00 74 36 01 13 8B 33 03 7B 04 57
51 52 53 FF B5 ?? ?? FF FF FF B5 ?? ?? FF FF 8B
D6 8B CF 8B 85 ?? ?? FF FF 05 AA 05 00 00 FF D0
5B 5A 59 5F 83 F9 00 74 05 83 C3 08 EB C5 68 00
80 00 00 6A 00

NsPacK V3.3 -> LiuXingPing
21
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 85 ?? ?? ??
?? 80 38 00 74

NsPacK V3.4-V3.5 -> LiuXingPing
22
9C 60 E8 00 00 00 00 5D 83 ED 07 8D 85 ?? ?? ??
?? 80 38 01 0F 84

NsPacK V3.6 -> LiuXingPing
26
9C 60 E8 00 00 00 00 5D 83 ED 07 8D ?? ?? ?? ??
?? 83 38 01 0F 84 47 02 00 00

NsPacK V3.7 -> LiuXingPing
26
9C 60 E8 00 00 00 00 5D 83 ED 07 8D ?? ?? ?? ??
?? 80 39 01 0F ?? ?? ?? 00 00

NTkrnl Secure Suite -> NTkrnl team
84
34 10 00 00 28 10 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 41 10 00 00
50 10 00 00 00 00 00 00 4B 65 72 6E 65 6C 33 32
2E 64 6C 6C 00 00 00 4C 6F 61 64 4C 69 62 72 61
72 79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64
72 65 73 73

NTkrnl Secure Suite 0.1-0.15 -> NTkrnl Software
109
00 00 00 00 00 00 00 00 00 00 00 00 34 10 00 00
28 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C 6C
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 68 ?? ?? ?? ?? E8 01 00 00 00 C3 C3

NTkrnl Secure Suite 0.1-0.15 DLL -> NTkrnl Software
114
00 00 00 00 00 00 00 00 00 00 00 00 34 10 00 00
28 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C 6C
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 8B 44 24 04 05 ?? ?? ?? ?? 50 E8 01 00 00 00
C3 C3

NTKrnlPacker -> Ashkbiz Danehkar
85
00 00 00 00 00 00 00 00 00 00 00 00 34 10 00 00
28 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 41 10 00 00 50 10 00 00
00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 64 6C 6C
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74

NTPacker 1.0 -> ErazerZ
293
55 8B EC 83 C4 E0 53 33 C0 89 45 E0 89 45 E4 89
45 E8 89 45 EC B8 ?? ?? 40 00 E8 ?? ?? FF FF 33
C0 55 68 ?? ?? 40 00 64 FF 30 64 89 20 8D 4D EC
BA ?? ?? 40 00 A1 ?? ?? 40 00 E8 ?? FC FF FF 8B
55 EC B8 ?? ?? 40 00 E8 ?? ?? FF FF 8D 4D E8 BA
?? ?? 40 00 A1 ?? ?? 40 00 E8 ?? FE FF FF 8B 55
E8 B8 ?? ?? 40 00 E8 ?? ?? FF FF B8 ?? ?? 40 00
E8 ?? FB FF FF 8B D8 A1 ?? ?? 40 00 BA ?? ?? 40
00 E8 ?? ?? FF FF 75 26 8B D3 A1 ?? ?? 40 00 E8
?? ?? FF FF 84 C0 75 2A 8D 55 E4 33 C0 E8 ?? ??
FF FF 8B 45 E4 8B D3 E8 ?? ?? FF FF EB 14 8D 55
E0 33 C0 E8 ?? ?? FF FF 8B 45 E0 8B D3 E8 ?? ??
FF FF 6A 00 E8 ?? ?? FF FF 33 C0 5A 59 59 64 89
10 68 ?? ?? 40 00 8D 45 E0 BA 04 00 00 00 E8 ??
?? FF FF C3 E9 ?? ?? FF FF EB EB 5B E8 ?? ?? FF
FF 00 00 00 FF FF FF FF 01 00 00 00 25 00 00 00
FF FF FF FF 01 00 00 00 5C 00 00 00 FF FF FF FF
06 00 00 00 53 45 52 56 45 52 00 00 FF FF FF FF
01 00 00 00 31

NTPacker V2.X -> ErazerZ
59
4B 57 69 6E 64 6F 77 73 00 10 55 54 79 70 65 73
00 00 3F 75 6E 74 4D 61 69 6E 46 75 6E 63 74 69
6F 6E 73 00 00 47 75 6E 74 42 79 70 61 73 73 00
00 B7 61 50 4C 69 62 75 00 00 00

Nullsoft Install System v1.98
11
83 EC 0C 53 56 57 FF 15 2C 81 40

Nullsoft Install System v1.xx
85
55 8B EC 83 EC 2C 53 56 33 F6 57 56 89 75 DC 89
75 F4 BB A4 9E 40 00 FF 15 60 70 40 00 BF C0 B2
40 00 68 04 01 00 00 57 50 A3 AC B2 40 00 FF 15
4C 70 40 00 56 56 6A 03 56 6A 01 68 00 00 00 80
57 FF 15 9C 70 40 00 8B F8 83 FF FF 89 7D EC 0F
84 C3 00 00 00

Nullsoft Install System v1.xx
85
83 EC 0C 53 56 57 FF 15 20 71 40 00 05 E8 03 00
00 BE 60 FD 41 00 89 44 24 10 B3 20 FF 15 28 70
40 00 68 00 04 00 00 FF 15 28 71 40 00 50 56 FF
15 08 71 40 00 80 3D 60 FD 41 00 22 75 08 80 C3
02 BE 61 FD 41 00 8A 06 8B 3D F0 71 40 00 84 C0
74 0F 3A C3 74

Nullsoft Install System v2.0
85
83 EC 0C 53 55 56 57 C7 44 24 10 70 92 40 00 33
DB C6 44 24 14 20 FF 15 2C 70 40 00 53 FF 15 84
72 40 00 BE 00 54 43 00 BF 00 04 00 00 56 57 A3
A8 EC 42 00 FF 15 C4 70 40 00 E8 8D FF FF FF 8B
2D 90 70 40 00 85 C0 75 21 68 FB 03 00 00 56 FF
15 5C 71 40 00

Nullsoft Install System v2.0 RC2
85
83 EC 10 53 55 56 57 C7 44 24 14 70 92 40 00 33
ED C6 44 24 13 20 FF 15 2C 70 40 00 55 FF 15 84
72 40 00 BE 00 54 43 00 BF 00 04 00 00 56 57 A3
A8 EC 42 00 FF 15 C4 70 40 00 E8 8D FF FF FF 8B
1D 90 70 40 00 85 C0 75 21 68 FB 03 00 00 56 FF
15 5C 71 40 00

Nullsoft Install System v2.0a0
85
83 EC 0C 53 56 57 FF 15 B4 10 40 00 05 E8 03 00
00 BE E0 E3 41 00 89 44 24 10 B3 20 FF 15 28 10
40 00 68 00 04 00 00 FF 15 14 11 40 00 50 56 FF
15 10 11 40 00 80 3D E0 E3 41 00 22 75 08 80 C3
02 BE E1 E3 41 00 8A 06 8B 3D 14 12 40 00 84 C0
74 19 3A C3 74

Nullsoft Install System v2.0b2, v2.0b3
56
83 EC 0C 53 55 56 57 FF 15 ?? 70 40 00 8B 35 ??
92 40 00 05 E8 03 00 00 89 44 24 14 B3 20 FF 15
2C 70 40 00 BF 00 04 00 00 68 ?? ?? ?? 00 57 FF
15 ?? ?? 40 00 57 FF 15

Nullsoft Install System v2.0b4
85
83 EC 10 53 55 56 57 C7 44 24 14 F0 91 40 00 33
ED C6 44 24 13 20 FF 15 2C 70 40 00 55 FF 15 88
72 40 00 BE 00 D4 42 00 BF 00 04 00 00 56 57 A3
60 6F 42 00 FF 15 C4 70 40 00 E8 9F FF FF FF 8B
1D 90 70 40 00 85 C0 75 21 68 FB 03 00 00 56 FF
15 60 71 40 00

Nullsoft Install System v2.0b4
85
83 EC 14 83 64 24 04 00 53 55 56 57 C6 44 24 13
20 FF 15 30 70 40 00 BE 00 20 7A 00 BD 00 04 00
00 56 55 FF 15 C4 70 40 00 56 E8 7D 2B 00 00 8B
1D 8C 70 40 00 6A 00 56 FF D3 BF 80 92 79 00 56
57 E8 15 26 00 00 85 C0 75 38 68 F8 91 40 00 55
56 FF 15 60 71

Nullsoft PIMP Install System v1.3x
21
55 8B EC 81 EC ?? ?? 00 00 56 57 6A ?? BE ?? ??
?? ?? 59 8D BD

Nullsoft PiMP Install System v1.x
85
83 EC 0C 53 56 57 FF 15 ?? ?? 40 00 05 E8 03 00
00 BE ?? ?? ?? 00 89 44 24 10 B3 20 FF 15 28 ??
40 00 68 00 04 00 00 FF 15 ?? ?? 40 00 50 56 FF
15 ?? ?? 40 00 80 3D ?? ?? ?? 00 22 75 08 80 C3
02 BE ?? ?? ?? 00 8A 06 8B 3D ?? ?? 40 00 84 C0
74 ?? 3A C3 74

Nullsoft PIMP Install System v1.x
13
83 EC 5C 53 55 56 57 FF 15 ?? ?? ?? 00

NX PE Packer v1.0
20
FF 60 FF CA FF 00 BA DC 0D E0 40 00 50 00 60 00
70 00 80 00

Obsidium 1.2.0.0 -> Obsidium Software
9
EB 02 ?? ?? E8 3F 1E 00 00

Obsidium 1.2.5.8 -> Obsidium Software
161
EB 01 ?? E8 29 00 00 00 EB 02 ?? ?? EB 01 ?? 8B
54 24 0C EB 04 ?? ?? ?? ?? 83 82 B8 00 00 00 24
EB 04 ?? ?? ?? ?? 33 C0 EB 02 ?? ?? C3 EB 02 ??
?? EB 03 ?? ?? ?? 64 67 FF 36 00 00 EB 01 ?? 64
67 89 26 00 00 EB 03 ?? ?? ?? EB 01 ?? 50 EB 03
?? ?? ?? 33 C0 EB 04 ?? ?? ?? ?? 8B 00 EB 03 ??
?? ?? C3 EB 01 ?? E9 FA 00 00 00 EB 02 ?? ?? E8
D5 FF FF FF EB 04 ?? ?? ?? ?? EB 03 ?? ?? ?? EB
01 ?? 58 EB 01 ?? EB 02 ?? ?? 64 67 8F 06 00 00
EB 04 ?? ?? ?? ?? 83 C4 04 EB 01 ?? E8 7B 21 00
00

Obsidium 1.3.0.0 -> Obsidium Software
163
EB 04 ?? ?? ?? ?? E8 29 00 00 00 EB 02 ?? ?? EB
01 ?? 8B 54 24 0C EB 02 ?? ?? 83 82 B8 00 00 00
22 EB 02 ?? ?? 33 C0 EB 04 ?? ?? ?? ?? C3 EB 04
?? ?? ?? ?? EB 04 ?? ?? ?? ?? 64 67 FF 36 00 00
EB 04 ?? ?? ?? ?? 64 67 89 26 00 00 EB 04 ?? ??
?? ?? EB 01 ?? 50 EB 03 ?? ?? ?? 33 C0 EB 02 ??
?? 8B 00 EB 01 ?? C3 EB 04 ?? ?? ?? ?? E9 FA 00
00 00 EB 01 ?? E8 D5 FF FF FF EB 02 ?? ?? EB 03
?? ?? ?? 58 EB 04 ?? ?? ?? ?? EB 01 ?? 64 67 8F
06 00 00 EB 02 ?? ?? 83 C4 04 EB 02 ?? ?? E8 47
26 00 00

Obsidium 1.3.0.13 -> Obsidium Software
156
EB 01 ?? E8 26 00 00 00 EB 02 ?? ?? EB 02 ?? ??
8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 21 EB 04
?? ?? ?? ?? 33 C0 EB 02 ?? ?? C3 EB 01 ?? EB 04
?? ?? ?? ?? 64 67 FF 36 00 00 EB 02 ?? ?? 64 67
89 26 00 00 EB 01 ?? EB 03 ?? ?? ?? 50 EB 01 ??
33 C0 EB 03 ?? ?? ?? 8B 00 EB 02 ?? ?? C3 EB 02
?? ?? E9 FA 00 00 00 EB 01 ?? E8 D5 FF FF FF EB
03 ?? ?? ?? EB 02 ?? ?? 58 EB 03 ?? ?? ?? EB 04
?? ?? ?? ?? 64 67 8F 06 00 00 EB 03 ?? ?? ?? 83
C4 04 EB 03 ?? ?? ?? E8 13 26 00 00

Obsidium 1.3.0.17 -> Obsidium software
82
EB 02 ?? ?? E8 28 00 00 00 EB 04 ?? ?? ?? ?? EB
01 ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 25
EB 02 ?? ?? 33 C0 EB 03 ?? ?? ?? C3 EB 03 ?? ??
?? EB 02 ?? ?? 64 67 FF 36 00 00 EB 01 ?? 64 67
89 26 00 00 EB 03 ?? ?? ?? EB 04 ?? ?? ?? ?? 50
EB 04

Obsidium 1.3.0.21 -> Obsidium Software
167
EB 03 ?? ?? ?? E8 2E 00 00 00 EB 04 ?? ?? ?? ??
EB 04 ?? ?? ?? ?? 8B 54 24 0C EB 04 ?? ?? ?? ??
83 82 B8 00 00 00 23 EB 01 ?? 33 C0 EB 04 ?? ??
?? ?? C3 EB 03 ?? ?? ?? EB 02 ?? ?? 64 67 FF 36
00 00 EB 01 ?? 64 67 89 26 00 00 EB 02 ?? ?? EB
02 ?? ?? 50 EB 01 ?? 33 C0 EB 03 ?? ?? ?? 8B 00
EB 03 ?? ?? ?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00
EB 04 ?? ?? ?? ?? E8 D5 FF FF FF EB 01 ?? EB 01
?? 58 EB 04 ?? ?? ?? ?? EB 04 ?? ?? ?? ?? 64 67
8F 06 00 00 EB 03 ?? ?? ?? 83 C4 04 EB 04 ?? ??
?? ?? E8 2B 26 00 00

Obsidium 1.3.0.37 -> Obsidium Software
159
EB 02 ?? ?? E8 26 00 00 00 EB 03 ?? ?? ?? EB 01
?? 8B 54 24 0C EB 04 ?? ?? ?? ?? 83 82 B8 00 00
00 26 EB 01 ?? 33 C0 EB 02 ?? ?? C3 EB 01 ?? EB
04 ?? ?? ?? ?? 64 67 FF 36 00 00 EB 01 ?? 64 67
89 26 00 00 EB 01 ?? EB 03 ?? ?? ?? 50 EB 03 ??
?? ?? 33 C0 EB 03 ?? ?? ?? 8B 00 EB 04 ?? ?? ??
?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 03 ?? ??
?? E8 D5 FF FF FF EB 04 ?? ?? ?? ?? EB 01 ?? 58
EB 02 ?? ?? EB 03 ?? ?? ?? 64 67 8F 06 00 00 EB
01 ?? 83 C4 04 EB 03 ?? ?? ?? E8 23 27 00 00

Obsidium 1.3.1.1 -> Obsidium Software
146
EB 02 ?? ?? E8 27 00 00 00 EB 02 ?? ?? EB 03 ??
?? ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 22
EB 04 ?? ?? ?? ?? 33 C0 EB 01 ?? C3 EB 02 ?? ??
EB 02 ?? ?? 64 67 FF 36 00 00 EB 04 ?? ?? ?? ??
64 67 89 26 00 00 EB 01 ?? EB 03 ?? ?? ?? 50 EB
03 ?? ?? ?? 33 C0 EB 01 ?? 8B 00 EB 03 ?? ?? ??
C3 EB 01 ?? E9 FA 00 00 00 EB 03 ?? ?? ?? E8 D5
FF FF FF EB 01 ?? EB 03 ?? ?? ?? 58 EB 03 ?? ??
?? EB 01 ?? 64 67 8F 06 00 00 EB 01 ?? 83 C4 04
EB 03

Obsidium 1.3.2.2 -> Obsidium Software
155
EB 04 ?? ?? ?? ?? E8 2A 00 00 00 EB 03 ?? ?? ??
EB 04 ?? ?? ?? ?? 8B 54 24 0C EB 02 ?? ?? 83 82
B8 00 00 00 26 EB 04 ?? ?? ?? ?? 33 C0 EB 02 ??
?? C3 EB 01 ?? EB 03 ?? ?? ?? 64 67 FF 36 00 00
EB 02 ?? ?? 64 67 89 26 00 00 EB 02 ?? ?? EB 01
?? 50 EB 04 ?? ?? ?? ?? 33 C0 EB 04 ?? ?? ?? ??
8B 00 EB 02 ?? ?? C3 EB 03 ?? ?? ?? E9 FA 00 00
00 EB 04 ?? ?? ?? ?? E8 D5 FF FF FF EB 02 ?? ??
EB 04 ?? ?? ?? ?? 58 EB 01 ?? EB 01 ?? 64 67 8F
06 00 00 EB 01 ?? 83 C4 04 EB 04

Obsidium 1.3.3.1 -> Obsidium Software
158
EB 01 ?? E8 29 00 00 00 EB 02 ?? ?? EB 03 ?? ??
?? 8B 54 24 0C EB 02 ?? ?? 83 82 B8 00 00 00 24
EB 04 ?? ?? ?? ?? 33 C0 EB 02 ?? ?? C3 EB 02 ??
?? EB 02 ?? ?? 64 67 FF 36 00 00 EB 04 ?? ?? ??
?? 64 67 89 26 00 00 EB 01 ?? EB 02 ?? ?? 50 EB
01 ?? 33 C0 EB 04 ?? ?? ?? ?? 8B 00 EB 03 ?? ??
?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 02 ?? ??
E8 D5 FF FF FF EB 01 ?? EB 04 ?? ?? ?? ?? 58 EB
02 ?? ?? EB 04 ?? ?? ?? ?? 64 67 8F 06 00 00 EB
01 ?? 83 C4 04 EB 02 ?? ?? E8 5F 27 00 00

Obsidium 1.3.3.2 -> Obsidium Software
155
EB 01 ?? E8 2B 00 00 00 EB 02 ?? ?? EB 02 ?? ??
8B 54 24 0C EB 03 ?? ?? ?? 83 82 B8 00 00 00 24
EB 04 ?? ?? ?? ?? 33 C0 EB 04 ?? ?? ?? ?? C3 EB
02 ?? ?? EB 01 ?? 64 67 FF 36 00 00 EB 03 ?? ??
?? 64 67 89 26 00 00 EB 01 ?? EB 02 ?? ?? 50 EB
02 ?? ?? 33 C0 EB 02 ?? ?? 8B 00 EB 02 ?? ?? C3
EB 04 ?? ?? ?? ?? E9 FA 00 00 00 EB 03 ?? ?? ??
E8 D5 FF FF FF EB 03 ?? ?? ?? EB 01 ?? 58 EB 01
?? EB 02 ?? ?? 64 67 8F 06 00 00 EB 02 ?? ?? 83
C4 04 EB 02 ?? ?? E8 3B 27 00 00

Obsidium 1.3.3.3 -> Obsidium Software
85
EB 02 ?? ?? E8 29 00 00 00 EB 03 ?? ?? ?? EB 03
?? ?? ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00
28 EB 03 ?? ?? ?? 33 C0 EB 01 ?? C3 EB 04 ?? ??
?? ?? EB 02 ?? ?? 64 67 FF 36 00 00 EB 04 ?? ??
?? ?? 64 67 89 26 00 00 EB 02 ?? ?? EB 04 ?? ??
?? ?? 50 EB 04

Obsidium 1.3.3.3 -> Obsidium Software
167
EB 02 ?? ?? E8 29 00 00 00 EB 03 ?? ?? ?? EB 03
?? ?? ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00
28 EB 03 ?? ?? ?? 33 C0 EB 01 ?? C3 EB 04 ?? ??
?? ?? EB 02 ?? ?? 64 67 FF 36 00 00 EB 04 ?? ??
?? ?? 64 67 89 26 00 00 EB 02 ?? ?? EB 04 ?? ??
?? ?? 50 EB 04 ?? ?? ?? ?? 33 C0 EB 01 ?? 8B 00
EB 03 ?? ?? ?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00
EB 03 ?? ?? ?? E8 D5 FF FF FF EB 04 ?? ?? ?? ??
EB 04 ?? ?? ?? ?? 58 EB 01 ?? EB 03 ?? ?? ?? 64
67 8F 06 00 00 EB 04 ?? ?? ?? ?? 83 C4 04 EB 04
?? ?? ?? ?? E8 2B 27

Obsidium 1.3.3.4 -> Obsidium Software
85
EB 02 ?? ?? E8 29 00 00 00 EB 03 ?? ?? ?? EB 02
?? ?? 8B 54 24 0C EB 03 ?? ?? ?? 83 82 B8 00 00
00 25 EB 02 ?? ?? 33 C0 EB 02 ?? ?? C3 EB 03 ??
?? ?? EB 01 ?? 64 67 FF 36 00 00 EB 02 ?? ?? 64
67 89 26 00 00 EB 02 ?? ?? EB 04 ?? ?? ?? ?? 50
EB 02 ?? ?? 33

Obsidium 1.3.3.4 -> Obsidium Software
144
EB 02 ?? ?? E8 29 00 00 00 EB 03 ?? ?? ?? EB 02
?? ?? 8B 54 24 0C EB 03 ?? ?? ?? 83 82 B8 00 00
00 25 EB 02 ?? ?? 33 C0 EB 02 ?? ?? C3 EB 03 ??
?? ?? EB 01 ?? 64 67 FF 36 00 00 EB 02 ?? ?? 64
67 89 26 00 00 EB 02 ?? ?? EB 04 ?? ?? ?? ?? 50
EB 02 ?? ?? 33 C0 EB 01 ?? 8B 00 EB 04 ?? ?? ??
?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 02 ?? ??
E8 D5 FF FF FF EB 02 ?? ?? EB 03 ?? ?? ?? 58 EB
02 ?? ?? EB 03 ?? ?? ?? 64 67 8F 06 00 00 EB 03

Obsidium 1.3.3.6 -> Obsidium Software
153
EB 04 ?? ?? ?? ?? E8 28 00 00 00 EB 01 ?? ?? ??
?? ?? ?? ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00
00 26 EB 04 ?? ?? ?? ?? 33 C0 EB 01 ?? C3 EB 03
?? ?? ?? EB 04 ?? ?? ?? ?? 64 67 FF 36 00 00 EB
04 ?? ?? ?? ?? 64 67 89 26 00 00 EB 03 ?? ?? ??
EB 04 ?? ?? ?? ?? 50 EB 01 ?? 33 C0 EB 02 ?? ??
8B 00 EB 04 ?? ?? ?? ?? C3 EB 04 ?? ?? ?? ?? E9
FA 00 00 00 EB 03 ?? ?? ?? E8 D5 FF FF FF EB 01
?? EB 03 ?? ?? ?? 58 EB 02 ?? ?? EB 04 ?? ?? ??
?? 64 67 8F 06 00 00 EB 04

Obsidium 1.3.3.7 (2007.06.23) -> Obsidium Software
153
EB 02 ?? ?? E8 27 00 00 00 EB 03 ?? ?? ?? EB 01
?? 8B 54 24 0C EB 03 ?? ?? ?? 83 82 B8 00 00 00
23 EB 03 ?? ?? ?? 33 C0 EB 02 ?? ?? C3 EB 01 ??
EB 03 ?? ?? ?? 64 67 FF 36 00 00 EB 04 ?? ?? ??
?? 64 67 89 26 00 00 EB 01 ?? EB 01 ?? 50 EB 02
?? ?? 33 C0 EB 01 ?? 8B 00 EB 04 ?? ?? ?? ?? C3
EB 02 ?? ?? E9 FA 00 00 00 EB 04 ?? ?? ?? ?? E8
D5 FF FF FF EB 01 ?? EB 01 ?? 58 EB 04 ?? ?? ??
?? EB 01 ?? 64 67 8F 06 00 00 EB 02 ?? ?? 83 C4
04 EB 01 ?? E8 F7 26 00 00

Obsidium 1.3.3.7 -> Obsidium Software
168
EB 02 ?? ?? E8 2C 00 00 00 EB 04 ?? ?? ?? ?? EB
04 ?? ?? ?? ?? 8B 54 24 0C EB 02 ?? ?? 83 82 B8
00 00 00 27 EB 04 ?? ?? ?? ?? 33 C0 EB 02 ?? ??
C3 EB 02 ?? ?? EB 03 ?? ?? ?? 64 67 FF 36 00 00
EB 04 ?? ?? ?? ?? 64 67 89 26 00 00 EB 03 ?? ??
?? EB 01 ?? 50 EB 02 ?? ?? 33 C0 EB 02 ?? ?? 8B
00 EB 04 ?? ?? ?? ?? C3 EB 02 ?? ?? E9 FA 00 00
00 EB 04 ?? ?? ?? ?? E8 D5 FF FF FF EB 02 ?? ??
EB 04 ?? ?? ?? ?? 58 EB 04 ?? ?? ?? ?? EB 03 ??
?? ?? 64 67 8F 06 00 00 EB 01 ?? 83 C4 04 EB 03
?? ?? ?? E8 23 27 00 00

Obsidium 1.3.3.8 -> Obsidium Software
166
EB 04 ?? ?? ?? ?? E8 28 00 00 00 EB 01 ?? EB 01
?? 8B 54 24 0C EB 04 ?? ?? ?? ?? 83 82 B8 00 00
00 ?? EB 04 ?? ?? ?? ?? 33 C0 EB 03 ?? ?? ?? C3
EB 01 ?? EB 01 ?? 64 67 FF 36 00 00 EB 03 ?? ??
?? 64 67 89 26 00 00 EB 02 ?? ?? EB 01 ?? 50 EB
04 ?? ?? ?? ?? 33 C0 EB 02 ?? ?? 8B 00 EB 03 ??
?? ?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 03 ??
?? ?? E8 D5 FF FF FF EB 02 ?? ?? EB 04 ?? ?? ??
?? 58 EB 04 ?? ?? ?? ?? EB 02 ?? ?? 64 67 8F 06
00 00 EB 04 ?? ?? ?? ?? 83 C4 04 EB 04 ?? ?? ??
?? E8 57 27 00 00

Obsidium 1.3.3.9 -> Obsidium Software
169
EB 02 ?? ?? E8 29 00 00 00 EB 03 ?? ?? ?? EB 01
?? 8B 54 24 0C EB 04 ?? ?? ?? ?? 83 82 B8 00 00
00 28 EB 02 ?? ?? 33 C0 EB 02 ?? ?? C3 EB 03 ??
?? ?? EB 04 ?? ?? ?? ?? 64 67 FF 36 00 00 EB 03
?? ?? ?? 64 67 89 26 00 00 EB 01 ?? EB 01 ?? 50
EB 03 ?? ?? ?? 33 C0 EB 03 ?? ?? ?? 8B 00 EB 04
?? ?? ?? ?? C3 EB 04 ?? ?? ?? ?? E9 FA 00 00 00
EB 03 ?? ?? ?? E8 D5 FF FF FF EB 02 ?? ?? EB 04
?? ?? ?? ?? 58 EB 03 ?? ?? ?? EB 04 ?? ?? ?? ??
64 67 8F 06 00 00 EB 03 ?? ?? ?? 83 C4 04 EB 04
?? ?? ?? ?? E8 CF 27 00 00

Obsidium 1.3.4.1 -> Obsidium Software
159
EB 01 ?? E8 2A 00 00 00 EB 04 ?? ?? ?? ?? EB 02
?? ?? 8B 54 24 0C EB 03 ?? ?? ?? 83 82 B8 00 00
00 21 EB 02 ?? ?? 33 C0 EB 03 ?? ?? ?? C3 EB 02
?? ?? EB 01 ?? 64 67 FF 36 00 00 EB 01 ?? 64 67
89 26 00 00 EB 02 ?? ?? EB 03 ?? ?? ?? 50 EB 04
?? ?? ?? ?? 33 C0 EB 02 ?? ?? 8B 00 EB 04 ?? ??
?? ?? C3 EB 02 ?? ?? E9 FA 00 00 00 EB 02 ?? ??
E8 D5 FF FF FF EB 01 ?? EB 01 ?? 58 EB 03 ?? ??
?? EB 04 ?? ?? ?? ?? 64 67 8F 06 00 00 EB 04 ??
?? ?? ?? 83 C4 04 EB 02 ?? ?? E8 C3 27 00 00

Obsidium v1.1.1.1
9
EB 02 ?? ?? E8 E7 1C 00 00

Obsidium V1.2 -> Obsidium Software
9
EB 02 ?? ?? E8 77 1E 00 00

Obsidium v1.2.5.0 -> Obsidium Software
62
E8 0E 00 00 00 8B 54 24 0C 83 82 B8 00 00 00 0D
33 C0 C3 64 67 FF 36 00 00 64 67 89 26 00 00 50
33 C0 8B 00 C3 E9 FA 00 00 00 E8 D5 FF FF FF 58
64 67 8F 06 00 00 83 C4 04 E8 2B 13 00 00

Obsidium V1.2.5.8 -> Obsidium Software
8
EB 01 ?? E8 ?? 00 00 00

Obsidium V1.2.5.8-V1.3.3.X -> Obsidium Software
13
EB 01 ?? E8 ?? 00 00 00 EB 02 ?? ?? EB

Obsidium V1.2.X -> Obsidium Software
62
E8 0E 00 00 00 33 C0 8B 54 24 0C 83 82 B8 00 00
00 0D C3 64 67 FF 36 00 00 64 67 89 26 00 00 50
33 C0 8B 00 C3 E9 FA 00 00 00 E8 D5 FF FF FF 58
64 67 8F 06 00 00 83 C4 04 E8 2B 13 00 00

Obsidium V1.25 -> Obsidium Software
19
E8 0E 00 00 00 8B 54 24 0C 83 82 B8 00 00 00 0D
33 C0 C3

Obsidium v1.3.0.0 -> Obsidium Software
85
EB 04 25 80 34 CA E8 29 00 00 00 EB 02 C1 81 EB
01 3A 8B 54 24 0C EB 02 32 92 83 82 B8 00 00 00
22 EB 02 F2 7F 33 C0 EB 04 65 7E 14 79 C3 EB 04
05 AD 7F 45 EB 04 05 65 0B E8 64 67 FF 36 00 00
EB 04 0D F6 A8 7F 64 67 89 26 00 00 EB 04 8D 68
C7 FB EB 01 6B

Obsidium v1.3.0.0 -> Obsidium Software
163
EB 04 25 80 34 CA E8 29 00 00 00 EB 02 C1 81 EB
01 3A 8B 54 24 0C EB 02 32 92 83 82 B8 00 00 00
22 EB 02 F2 7F 33 C0 EB 04 65 7E 14 79 C3 EB 04
05 AD 7F 45 EB 04 05 65 0B E8 64 67 FF 36 00 00
EB 04 0D F6 A8 7F 64 67 89 26 00 00 EB 04 8D 68
C7 FB EB 01 6B 50 EB 03 8A 0B 93 33 C0 EB 02 28
B9 8B 00 EB 01 04 C3 EB 04 65 B3 54 0A E9 FA 00
00 00 EB 01 A2 E8 D5 FF FF FF EB 02 2B 49 EB 03
7C 3E 76 58 EB 04 B8 94 92 56 EB 01 72 64 67 8F
06 00 00 EB 02 23 72 83 C4 04 EB 02 A9 CB E8 47
26 00 00

Obsidium V1.3.0.0 -> Obsidium Software
11
EB 04 ?? ?? ?? ?? E8 29 00 00 00

Obsidium V1.3.0.0 -> Obsidium Software
11
EB 04 ?? ?? ?? ?? E8 ?? 00 00 00

Obsidium v1.3.0.37 -> Obsidium Software
157
EB 02 ?? ?? E8 26 00 00 00 EB 03 ?? ?? ?? EB 01
?? 8B 54 24 0C EB 04 ?? ?? ?? ?? 83 82 B8 00 00
00 26 EB 01 ?? 33 C0 EB 02 ?? ?? C3 EB 01 ?? EB
04 ?? ?? ?? ?? 64 67 FF 36 00 00 EB 01 ?? 64 67
89 26 00 00 EB 01 ?? EB 03 ?? ?? ?? 50 EB 03 ??
?? ?? 33 C0 EB 03 ?? ?? ?? 8B 00 EB 04 ?? ?? ??
?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 03 ?? ??
?? E8 D5 FF FF FF EB 04 ?? ?? ?? ?? EB 01 ?? 58
EB 02 ?? ?? EB 03 ?? ?? ?? 64 67 8F 06 00 00 EB
01 ?? 83 C4 04 EB 03 ?? ?? ?? E8 23 27

Obsidium v1.3.0.4 -> Obsidium Software
84
EB 02 ?? ?? E8 25 00 00 00 EB 04 ?? ?? ?? ?? EB
01 ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 23
EB 01 ?? 33 C0 EB 02 ?? ?? C3 EB 02 ?? ?? EB 04
?? ?? ?? ?? 64 67 FF 36 00 00 EB 03 ?? ?? ?? 64
67 89 26 00 00 EB 02 ?? ?? EB 01 ?? 50 EB 01 ??
33 C0 EB 01

Obsidium v1.3.0.4 -> Obsidium Software
153
EB 02 ?? ?? E8 25 00 00 00 EB 04 ?? ?? ?? ?? EB
01 ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 23
EB 01 ?? 33 C0 EB 02 ?? ?? C3 EB 02 ?? ?? EB 04
?? ?? ?? ?? 64 67 FF 36 00 00 EB 03 ?? ?? ?? 64
67 89 26 00 00 EB 02 ?? ?? EB 01 ?? 50 EB 01 ??
33 C0 EB 01 ?? 8B 00 EB 01 ?? C3 EB 02 ?? ?? E9
FA 00 00 00 EB 02 ?? ?? E8 D5 FF FF FF EB 03 ??
?? ?? EB 04 ?? ?? ?? ?? 58 EB 02 ?? ?? EB 04 ??
?? ?? ?? 64 67 8F 06 00 00 EB 03 ?? ?? ?? 83 C4
04 EB 01 ?? E8 3B 26 00 00

Obsidium V1.3.0.4 -> Obsidium Software
9
EB 02 ?? ?? E8 ?? 00 00 00

Obsidium V1.3.0.X -> Obsidium Software
51
EB 03 ?? ?? ?? E8 2E 00 00 00 EB 04 ?? ?? ?? ??
EB 04 ?? ?? ?? ?? 8B ?? ?? ?? EB 04 ?? ?? ?? ??
83 ?? ?? ?? ?? ?? ?? EB 01 ?? 33 C0 EB 04 ?? ??
?? ?? C3

Obsidium V1.3.4.2 -> Obsidium Software
164
EB 02 ?? ?? E8 26 00 00 00 EB 03 ?? ?? ?? EB 01
?? 8B 54 24 0C EB 02 ?? ?? 83 82 B8 00 00 00 24
EB 03 ?? ?? ?? 33 C0 EB 01 ?? C3 EB 02 ?? ?? EB
02 ?? ?? 64 67 FF 36 00 00 EB 03 ?? ?? ?? 64 67
89 26 00 00 EB 03 ?? ?? ?? EB 03 ?? ?? ?? 50 EB
04 ?? ?? ?? ?? 33 C0 EB 03 ?? ?? ?? 8B 00 EB 03
?? ?? ?? C3 EB 03 ?? ?? ?? E9 FA 00 00 00 EB 03
?? ?? ?? E8 D5 FF FF FF EB 01 ?? EB 03 ?? ?? ??
58 EB 04 ?? ?? ?? ?? EB 04 ?? ?? ?? ?? 64 67 8F
06 00 00 EB 04 ?? ?? ?? ?? 83 C4 04 EB 01 ?? E8
C3 27 00 00

Obsidium V1.3.5.0 -> Obsidium Software
158
EB 03 ?? ?? ?? E8 ?? ?? ?? ?? EB 02 ?? ?? EB 04
?? ?? ?? ?? 8B 54 24 0C EB 04 ?? ?? ?? ?? 83 82
B8 00 00 00 20 EB 03 ?? ?? ?? 33 C0 EB 01 ?? C3
EB 02 ?? ?? EB 03 ?? ?? ?? 64 67 FF 36 00 00 EB
03 ?? ?? ?? 64 67 89 26 00 00 EB 01 ?? EB 04 ??
?? ?? ?? 50 EB 04 ?? ?? ?? ?? 33 C0 EB 04 ?? ??
?? ?? 8B 00 EB 03 ?? ?? ?? C3 EB 02 ?? ?? E9 FA
00 00 00 EB 01 ?? E8 ?? ?? ?? ?? EB 01 ?? EB 02
?? ?? 58 EB 04 ?? ?? ?? ?? EB 02 ?? ?? 64 67 8F
06 00 00 EB 02 ?? ?? 83 C4 04 EB 01 ?? E8

Obsiduim 1.3.0.4 -> Obsiduim Software
64
EB 02 ?? ?? E8 25 00 00 00 EB 04 ?? ?? ?? ?? EB
01 ?? 8B 54 24 0C EB 01 ?? 83 82 B8 00 00 00 23
EB 01 ?? 33 C0 EB 02 ?? ?? C3 EB 02 ?? ?? EB 04
?? ?? ?? ?? 64 67 FF 36 00 00 EB 03 ?? ?? ?? 64

ocBat2Exe 1.0 -> OC
245
55 8B EC B9 08 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 58 3C 40 00 E8 6C FA FF FF 33 C0 55 68
8A 3F 40 00 64 FF 30 64 89 20 6A 00 6A 00 6A 03
6A 00 6A 01 68 00 00 00 80 8D 55 EC 33 C0 E8 81
E9 FF FF 8B 45 EC E8 41 F6 FF FF 50 E8 F3 FA FF
FF 8B F8 83 FF FF 0F 84 83 02 00 00 6A 02 6A 00
6A EE 57 E8 FC FA FF FF 6A 00 68 60 99 4F 00 6A
12 68 18 57 40 00 57 E8 E0 FA FF FF 83 3D 60 99
4F 00 12 0F 85 56 02 00 00 8D 45 E4 50 8D 45 E0
BA 18 57 40 00 B9 40 42 0F 00 E8 61 F4 FF FF 8B
45 E0 B9 12 00 00 00 BA 01 00 00 00 E8 3B F6 FF
FF 8B 45 E4 8D 55 E8 E8 04 FB ?? ?? ?? ?? E8 B8
58 99 4F 00 E8 67 F3 FF FF 33 C0 A3 60 99 4F 00
8D 45 DC 50 B9 05 00 00 00 BA 01 00 00 00 A1 58
99 4F 00 E8 04 F6 FF FF 8B 45 DC BA A4 3F 40 00
E8 E3 F4 FF FF

Open Source Code Crypter -> p0ke
230
55 8B EC B9 09 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 34 44 40 00 E8 28 F8 FF FF 33 C0 55 68
9F 47 40 00 64 FF 30 64 89 20 BA B0 47 40 00 B8
1C 67 40 00 E8 07 FD FF FF 8B D8 85 DB 75 07 6A
00 E8 C2 F8 FF FF BA 28 67 40 00 8B C3 8B 0D 1C
67 40 00 E8 F0 E0 FF FF BE 01 00 00 00 B8 2C 68
40 00 E8 E1 F0 FF FF BF 0A 00 00 00 8D 55 EC 8B
C6 E8 92 FC FF FF 8B 4D EC B8 2C 68 40 00 BA BC
47 40 00 E8 54 F2 FF FF A1 2C 68 40 00 E8 52 F3
FF FF 8B D0 B8 20 67 40 00 E8 A2 FC FF FF 8B D8
85 DB 0F 84 52 02 00 00 B8 24 67 40 00 8B 15 20
67 40 00 E8 78 F4 FF FF B8 24 67 40 00 E8 7A F3
FF FF 8B D0 8B C3 8B 0D 20 67 40 00 E8 77 E0 FF
FF 8D 55 E8 A1 24 67 40 00 E8 42 FD FF FF 8B 55
E8 B8 24 67 40 00

ORiEN V1.X-V2.X -> Fisun A.V.
40
4F 52 69 45 4E 20 65 78 65 63 75 74 61 62 6C 65
20 66 69 6C 65 73 20 70 72 6F 74 65 63 74 69 6F
6E 20 73 79 73 74 65 6D

ORiEN v2.11 (DEMO)
85
E9 5D 01 00 00 CE D1 CE CE 0D 0A 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 0D 0A 2D 20 4F 52 69 45 4E
20 65 78 65 63 75 74 61 62 6C 65 20 66 69 6C 65
73 20 70 72 6F

ORiEN v2.11 - 2.12 -> Fisun Alexander
85
E9 5D 01 00 00 CE D1 CE ?? 0D 0A 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D 0D 0A 2D 20 4F 52 69 45 4E
20 65 78 65 63 75 74 61 62 6C 65 20 66 69 6C 65
73 20 70 72 6F

ORiEN V2.12 -> Fisun A.V.
10
E9 5D 01 00 00 CE D1 CE CD 0D

Pack Master v1.0
43
60 E8 01 00 00 00 E8 83 C4 04 E8 01 00 00 00 E9
5D 81 ED D3 22 40 00 E8 04 02 00 00 E8 EB 08 EB
02 CD 20 FF 24 24 9A 66 BE 47 46

Pack Master v1.0
43
60 E8 01 ?? ?? ?? E8 83 C4 04 E8 01 ?? ?? ?? E9
5D 81 ED D3 22 40 ?? E8 04 02 ?? ?? E8 EB 08 EB
02 CD 20 FF 24 24 9A 66 BE 47 46

Packanoid -> Arkanoid
16
BF 00 10 40 00 BE ?? ?? ?? 00 E8 9D 00 00 00 B8

Packanoid 1.0 -> ackanoid
85
BF 00 ?? 40 00 BE ?? ?? ?? 00 E8 9D 00 00 00 B8
?? ?? ?? 00 8B 30 8B 78 04 BB ?? ?? ?? 00 8B 43
04 91 E3 1F 51 FF D6 56 96 8B 13 8B 02 91 E3 0D
52 51 56 FF D7 5A 89 02 83 C2 04 EB EE 83 C3 08
5E EB DB B9 ?? ?? 00 00 BE 00 ?? ?? 00 EB 01 00
BF ?? ?? ?? 00

Packanoid v1 -> Arkanoid
64
BF ?? ?? ?? ?? BE ?? ?? ?? ?? E8 9D 00 00 00 B8
?? ?? ?? ?? 8B 30 8B 78 04 BB ?? ?? ?? ?? 8B 43
04 91 E3 1F 51 FF D6 56 96 8B 13 8B 02 91 E3 0D
52 51 56 FF D7 5A 89 02 83 C2 04 EB EE 83 C3 08

Packed with: PKLITE v1.50 with CRC check (1)
13
1F B4 09 BA ?? ?? CD 21 B8 ?? ?? CD 21

PackItBitch 1.0 -> archphase
133
00 00 00 00 00 00 00 00 00 00 00 00 28 ?? ?? ??
35 ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4B 45 52 4E 45 4C 33 32
2E 44 4C 4C 00 41 ?? ?? ?? 50 ?? ?? ?? 00 00 00
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 ?? ?? ?? ?? ?? ?? ?? 79 ?? ?? ?? 7D ?? ??
?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

PackItBitch V1.0-> archphase
133
00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 4B 45 52 4E 45 4C 33 32
2E 44 4C 4C 00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 ?? 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ??
?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

Packman 0.0.0.1 -> bubba
25
60 E8 00 00 00 00 58 8D A8 ?? FE FF FF 8D 98 ??
?? ?? FF 8D ?? ?? 01 00 00

Packman 0.0.0.1 -> Bubbasoft
85
0F 85 ?? FF FF FF 8D B3 ?? ?? ?? ?? EB 3D 8B 46
0C 03 C3 50 FF 55 00 56 8B 36 0B F6 75 02 8B F7
03 F3 03 FB EB 1B D1 C1 D1 E9 73 05 0F B7 C9 EB
05 03 CB 8D 49 02 50 51 50 FF 55 04 AB 58 83 C6
04 8B 0E 85 C9 75 DF 5E 83 C6 14 8B 7E 10 85 FF
75 BC 8D 8B 00

Packman v0.0.0.1
55
60 E8 00 00 00 00 58 8D A8 ?? ?? FF FF 8D 98 ??
?? ?? FF 8D ?? ?? 01 00 00 ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 00 00

Packman V0.0.0.1 -> Bubbasoft
29
60 E8 00 00 00 00 58 8D ?? ?? ?? ?? ?? 8D ?? ??
?? ?? ?? 8D ?? ?? ?? ?? ?? 8D ?? ?? 48

Packman V1.0 -> Brandon LaCombe
26
60 E8 00 00 00 00 5B 8D 5B C6 01 1B 8B 13 8D 73
14 6A 08 59 01 16 AD 49 75 FA

Packman v1.0 -> Brandon LaCombe
52
60 E8 00 00 00 00 5B 8D 5B C6 01 1B 8B 13 8D 73
14 6A 08 59 01 16 AD 49 75 FA 8B E8 C6 06 E9 8B
43 0C 89 46 01 6A 04 68 00 10 00 00 FF 73 08 51
FF 55 08 8B

PACKWIN v1.01p
40
8C C0 FA 8E D0 BC ?? ?? FB 06 0E 1F 2E ?? ?? ??
?? 8B F1 4E 8B FE 8C DB 2E ?? ?? ?? ?? 8E C3 FD
F3 A4 53 B8 ?? ?? 50 CB

PAK-SFX Archive
33
55 8B EC 83 ?? ?? A1 ?? ?? 2E ?? ?? ?? 2E ?? ??
?? ?? ?? 8C D7 8E C7 8D ?? ?? BE ?? ?? FC AC 3C
0D

PassEXE v2.0
34
06 1E 0E 0E 07 1F BE ?? ?? B9 ?? ?? 87 14 81 ??
?? ?? EB ?? C7 ?? ?? ?? 84 00 87 ?? ?? ?? FB 1F
58 4A

PassLock 2000 v1.0 (Eng) -> Moonlight-Software
85
55 8B EC 53 56 57 BB 00 50 40 00 66 2E F7 05 34
20 40 00 04 00 0F 85 98 00 00 00 E8 1F 01 00 00
C7 43 60 01 00 00 00 8D 83 E4 01 00 00 50 FF 15
F0 61 40 00 83 EC 44 C7 04 24 44 00 00 00 C7 44
24 2C 00 00 00 00 54 FF 15 E8 61 40 00 B8 0A 00
00 00 F7 44 24

Password Protector (c) MiniSoft 1992
22
06 0E 0E 07 1F E8 00 00 5B 83 EB 08 BA 27 01 03
D3 E8 3C 02 BA EA

Password protector my SMT
46
E8 ?? ?? ?? ?? 5D 8B FD 81 ?? ?? ?? ?? ?? 81 ??
?? ?? ?? ?? 83 ?? ?? 89 ?? ?? ?? ?? ?? 8D ?? ??
?? ?? ?? 8D ?? ?? ?? ?? ?? 46 80 ?? ?? 74

PAV.Cryptor (Pawning AntiVirus Cryptor) -> masha_dev
232
53 56 57 55 BB 2C ?? ?? 70 BE 00 30 00 70 BF 20
?? ?? 70 80 7B 28 00 75 16 83 3F 00 74 11 8B 17
89 D0 33 D2 89 17 8B E8 FF D5 83 3F 00 75 EF 83
3D 04 30 00 70 00 74 06 FF 15 54 30 00 70 80 7B
28 02 75 0A 83 3E 00 75 05 33 C0 89 43 0C FF 15
1C 30 00 70 80 7B 28 01 76 05 83 3E 00 74 22 8B
43 10 85 C0 74 1B FF 15 14 30 00 70 8B 53 10 8B
42 10 3B 42 04 74 0A 85 C0 74 06 50 E8 8F FA FF
FF FF 15 20 30 00 70 80 7B 28 01 75 03 FF 53 24
80 7B 28 00 74 05 E8 35 FF FF FF 83 3B 00 75 17
83 3D 10 ?? ?? 70 00 74 06 FF 15 10 ?? ?? 70 8B
06 50 E8 A9 FA FF FF 8B 03 56 8B F0 8B FB B9 0B
00 00 00 F3 A5 5E E9 73 FF FF FF 5D 5F 5E 5B C3
A3 00 30 00 70 E8 26 FF FF FF C3 90 8F 05 04 30
00 70 E9 E9 FF FF FF C3

PC Guard for Win32 v5.00 -> SofPro/Blagoje Ceklic
85
FC 55 50 E8 00 00 00 00 5D 60 E8 03 00 00 00 83
EB 0E EB 01 0C 58 EB 01 35 40 EB 01 36 FF E0 0B
61 B8 ?? ?? ?? 00 EB 01 E3 60 E8 03 00 00 00 D2
EB 0B 58 EB 01 48 40 EB 01 35 FF E0 E7 61 2B E8
9C EB 01 D5 9D EB 01 0B 58 60 E8 03 00 00 00 83
EB 0E EB 01 0C

PC PE Encryptor Alpha preview
44
53 51 52 56 57 55 E8 00 00 00 00 5D 8B CD 81 ED
33 30 40 ?? 2B 8D EE 32 40 00 83 E9 0B 89 8D F2
32 40 ?? 80 BD D1 32 40 ?? 01 0F 84

PC Shrinker v0.20
13
E8 E8 01 ?? ?? 60 01 AD B3 27 40 ?? 68

PC Shrinker v0.29
17
?? BD ?? ?? ?? ?? 01 AD 55 39 40 ?? 8D B5 35 39
40

PC Shrinker v0.45
17
?? BD ?? ?? ?? ?? 01 AD E3 38 40 ?? FF B5 DF 38
40

PC Shrinker v0.71
36
9C 60 BD ?? ?? ?? ?? 01 AD 54 3A 40 ?? FF B5 50
3A 40 ?? 6A 40 FF 95 88 3A 40 ?? 50 50 2D ?? ??
?? ?? 89 85

PC-Guard v3.03d, v3.05d
27
55 50 E8 ?? ?? ?? ?? 5D EB 01 E3 60 E8 03 ?? ??
?? D2 EB 0B 58 EB 01 48 40 EB 01

PC-Guard v4.05d, v4.10d, v4.15d
11
FC 55 50 E8 00 00 00 00 5D EB 01

PC-Guard v5.00d
85
FC 55 50 E8 00 00 00 00 5D 60 E8 03 00 00 00 83
EB 0E EB 01 0C 58 EB 01 35 40 EB 01 36 FF E0 0B
61 B8 30 D2 40 00 EB 01 E3 60 E8 03 00 00 00 D2
EB 0B 58 EB 01 48 40 EB 01 35 FF E0 E7 61 2B E8
9C EB 01 D5 9D EB 01 0B 58 60 E8 03 00 00 00 83
EB 0E EB 01 0C

PCPEC "alpha - preview"
20
53 51 52 56 57 55 E8 00 00 00 00 5D 8B CD 81 ED
33 30 40 00

PCPEC [alpha]
27
53 51 52 56 57 55 E8 ?? ?? ?? ?? 5D 8B CD 81 ??
?? ?? ?? ?? 2B ?? ?? ?? ?? ?? 83

PCrypt v3.51
14
50 43 52 59 50 54 FF 76 33 2E 35 31 00 E9

PcShare æ–‡ä»¶æ†ç»‘å™¨ v4.0 -> æ— å¯éžè®®
17
55 8B EC 6A FF 68 90 34 40 00 68 B6 28 40 00 64
A1

PCShrink 0.71 beta
20
01 AD 54 3A 40 00 FF B5 50 3A 40 00 6A 40 FF 95
88 3A 40 00

PCShrink v0.40b
30
9C 60 BD ?? ?? ?? ?? 01 ?? ?? ?? ?? ?? FF ?? ??
?? ?? ?? 6A ?? FF ?? ?? ?? ?? ?? 50 50 2D

PE Crypt 1.5 -> BitShape Software
78
60 E8 00 00 00 00 5D 81 ED 55 20 40 00 B9 7B 09
00 00 8D BD 9D 20 40 00 8B F7 AC ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? AA E2 CC

PE Crypt v1.00/v1.01
20
E8 ?? ?? ?? ?? 5B 83 EB 05 EB 04 52 4E 44 21 EB
02 CD 20 EB

PE Crypt v1.02
14
E8 ?? ?? ?? ?? 5B 83 EB 05 EB 04 52 4E 44

PE Crypt32 (Console v1.0, v1.01, v1.02)
20
E8 00 00 00 00 5B 83 EB 05 EB 04 52 4E 44 21 EB
02 CD 20 EB

PE Crypt32 v1.02
15
E8 00 00 00 00 5B 83 ?? ?? EB ?? 52 4E 44 21

PE Diminisher v0.1
46
53 51 52 56 57 55 E8 00 00 00 00 5D 8B D5 81 ED
A2 30 40 00 2B 95 91 33 40 00 81 EA 0B 00 00 00
89 95 9A 33 40 00 80 BD 99 33 40 00 00 74

PE Diminisher v0.1
30
5D 8B D5 81 ED A2 30 40 ?? 2B 95 91 33 40 ?? 81
EA 0B ?? ?? ?? 89 95 9A 33 40 ?? 80 BD 99

PE Diminisher V0.1 -> Teraphy
11
53 51 52 56 57 55 E8 00 00 00 00

PE Diminisher v0.1 -> Teraphy
64
53 51 52 56 57 55 E8 00 00 00 00 5D 8B D5 81 ED
A2 30 40 00 2B 95 91 33 40 00 81 EA 0B 00 00 00
89 95 9A 33 40 00 80 BD 99 33 40 00 00 74 50 E8
02 01 00 00 8B FD 8D 9D 9A 33 40 00 8B 1B 8D 87

PE Encrypt 1.0 -> Liwuyue
153
55 8B EC 83 C4 D0 53 56 57 8D 75 FC 8B 44 24 30
25 00 00 FF FF 81 38 4D 5A 90 00 74 07 2D 00 10
00 00 EB F1 89 45 FC E8 C8 FF FF FF 2D 0F 05 00
00 89 45 F4 8B 06 8B 40 3C 03 06 8B 40 78 03 06
8B C8 8B 51 20 03 16 8B 59 24 03 1E 89 5D F0 8B
59 1C 03 1E 89 5D EC 8B 41 18 8B C8 49 85 C9 72
5A 41 33 C0 8B D8 C1 E3 02 03 DA 8B 3B 03 3E 81
3F 47 65 74 50 75 40 8B DF 83 C3 04 81 3B 72 6F
63 41 75 33 8B DF 83 C3 08 81 3B 64 64 72 65 75
26 83 C7 0C 66 81 3F 73 73

PE Intro v1.0
27
8B 04 24 9C 60 E8 ?? ?? ?? ?? 5D 81 ED 0A 45 40
?? 80 BD 67 44 40 ?? ?? 0F 85 48

PE Lock NT v2.01
20
EB 03 CD 20 EB EB 01 EB 1E EB 01 EB EB 02 CD 20
9C EB 03 CD

PE Lock NT v2.02c
20
EB 02 C7 85 1E EB 03 CD 20 EB EB 01 EB 9C EB 01
EB EB 02 CD

PE Lock NT v2.03
20
EB 02 C7 85 1E EB 03 CD 20 C7 9C EB 02 69 B1 60
EB 02 EB 01

PE Lock NT v2.04
40
EB ?? CD ?? ?? ?? ?? ?? CD ?? ?? ?? ?? ?? EB ??
EB ?? EB ?? EB ?? CD ?? ?? ?? ?? ?? E8 ?? ?? ??
?? E9 ?? ?? ?? ?? 50 C3

PE Lock v1.06
49
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41
00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 4B
45

PE Ninja v1.0 -> +DzA kRAker TNT
48
BE 5B 2A 40 00 BF 35 12 00 00 E8 40 12 00 00 3D
22 83 A3 C6 0F 85 67 0F 00 00 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90

PE Pack v0.99
20
60 E8 ?? ?? ?? ?? 5D 83 ED 06 80 BD E0 04 ?? ??
01 0F 84 F2

PE Packer
16
FC 8B 35 70 01 40 ?? 83 EE 40 6A 40 68 ?? 30 10

PE Password v0.2 SMT/SMF
49
E8 04 ?? ?? ?? 8B EC 5D C3 33 C0 5D 8B FD 81 ED
33 26 40 ?? 81 EF ?? ?? ?? ?? 83 EF 05 89 AD 88
27 40 ?? 8D 9D 07 29 40 ?? 8D B5 62 28 40 ?? 46
80

PE Protect v0.9
25
52 51 55 57 64 67 A1 30 00 85 C0 78 0D E8 ?? ??
?? ?? 58 83 C0 07 C6 ?? C3

PE Protect v0.9
85
E9 ?? 00 00 00 0D 0A 0D 0A C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
0D 0A 50 45 2D 50 52 4F 54 45 43 54 20 30 2E 39
20 28 43 29 6F

PE Protector 0.9.3 --> CRYPToCRACk
64
5B 81 E3 00 FF FF FF 66 81 3B 4D 5A 75 33 8B F3
03 73 3C 81 3E 50 45 00 00 75 26 0F B7 46 18 8B
C8 69 C0 AD 0B 00 00 F7 E0 2D AB 5D 41 4B 69 C9
DE C0 00 00 03 C1 75 09 83 EC 04 0F 85 DD 00 00

PE Spin v0.4x
10
EB 01 68 60 E8 00 00 00 00 8B

PE Spin v0.b
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 72 C8 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 26 E8 01 00 00
00 EA 5A 33 C9

PE-Armor 0.46 -> China Cracking Group
85
E8 AA 00 00 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 3D ?? ?? 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 4B ?? ??
00 5C ?? ?? 00 6F ?? ?? 00 00 00 00 00 4B 45 52
4E 45 4C 33 32 2E 64 6C 6C 00 00 00 00 47 65 74
50 72 6F 63 41

PE-Armor 0.46 -> Hying
125
E8 AA 00 00 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 3D ?? ?? 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 4B ?? ??
00 5C ?? ?? 00 6F ?? ?? 00 00 00 00 00 4B 45 52
4E 45 4C 33 32 2E 64 6C 6C 00 00 00 00 47 65 74
50 72 6F 63 41 64 64 72 65 73 73 00 00 00 47 65
74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00
00 4C 6F 61 64 4C 69 62 72 61 72 79 41

PE-Armor 0.46 -> Hying
18
E8 AA 00 00 00 2D ?? ?? ?? 00 00 00 00 00 00 00
00 3D

PE-Armor 0.460-0.759 -> hying
117
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 4B 45 52 4E 45 4C 33 32 2E 64 6C 6C
00 00 00 00 47 65 74 50 72 6F 63 41 64 64 72 65
73 73 00 00 00 47 65 74 4D 6F 64 75 6C 65 48 61
6E 64 6C 65 41 00 00 00 4C 6F 61 64 4C 69 62 72
61 72 79 41 00

PE-Armor 0.49 -> Hying
18
56 52 51 53 55 E8 15 01 00 00 32 ?? ?? 00 00 00
00 00

PE-Armor 0.760-0.765 -> hying
147
00 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00
00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
4B 45 52 4E 45 4C 33 32 2E 64 6C 6C 00 00 00 00
47 65 74 50 72 6F 63 41 64 64 72 65 73 73 00 00
00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00 00
47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41
00 00 00 00 00 08 00 00 00 00 00 00 00 60 E8 00
00 00 00

PE-Armor V0.7X -> hying
29
60 E8 00 00 00 00 5D 81 ED ?? ?? ?? ?? 8D B5 ??
?? ?? ?? 55 56 81 C5 ?? ?? ?? ?? 55 C3

PE-Crypt 1.02
20
E8 00 00 00 00 5B 83 EB 05 EB 04 52 4E 44 21 85
C0 73 02 F7

PE-Crypter
9
60 E8 00 00 00 00 5D EB 26

PE-PACK 0.99
20
60 E8 00 00 00 00 5D 83 ED 06 80 BD E0 04 00 00
01 0F 84 F2

PE-PaCK v1.0 -> (C) Copyright 1998 by ANAKiN
85
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 0D 0A 20 2D 3D FE 20 50 45 2D
50 41 43 4B 20 76 31 2E 30 20 2D FE 2D 20 28 43
29 20 43 6F 70

PE-PACK v1.0 by ANAKiN 1998 (???)
11
74 ?? E9 ?? ?? ?? ?? 00 00 00 00

PE-PROTECT 0.9
20
E9 CF 00 00 00 0D 0A 0D 0A C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4

PE-Protect 0.9 by Cristoph Gabler 1998
14
50 45 2D 50 52 4F 54 45 43 54 20 30 2E 39

PE-SHiELD 0.2
20
60 E8 00 00 00 00 41 4E 41 4B 49 4E 5D 83 ED 06
EB 02 EA 04

Pe123  v2006.4.12
85
8B C0 60 9C E8 01 00 00 00 C3 53 E8 72 00 00 00
50 E8 1C 03 00 00 8B D8 FF D3 5B C3 8B C0 E8 00
00 00 00 58 83 C0 05 C3 8B C0 55 8B EC 60 8B 4D
10 8B 7D 0C 8B 75 08 F3 A4 61 5D C2 0C 00 E8 00
00 00 00 58 83 E8 05 C3 8B C0 E8 00 00 00 00 58
83 C0 05 C3 8B

Pe123  v2006.4.4
85
8B C0 EB 01 34 60 EB 01 2A 9C EB 02 EA C8 E8 0F
00 00 00 EB 03 3D 23 23 EB 01 4A EB 01 5B C3 8D
40 00 53 EB 01 6C EB 01 7E EB 01 8F E8 15 01 00
00 50 E8 67 04 00 00 EB 01 9A 8B D8 FF D3 5B C3
8B C0 E8 00 00 00 00 58 83 C0 05 C3 8B C0 55 8B
EC 60 8B 4D 10

PEBundle v0.2 - v2.0x
44
9C 60 E8 02 ?? ?? ?? 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB ?? ?? 40 ?? 87 DD 6A 04 68 ??
10 ?? ?? 68 ?? 02 ?? ?? 6A ?? FF 95

PEBundle v2.0b5 - v2.3
36
9C 60 E8 02 ?? ?? ?? 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB ?? ?? 40 ?? 87 DD 01 AD ?? ??
?? ?? 01 AD

PEBundle v2.44
30
9C 60 E8 02 ?? ?? ?? 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB ?? ?? 40 ?? 87 DD 83 BD

PEBundle v3.10
35
9C 60 E8 02 00 00 00 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB 07 20 40 00 87 DD ?? ?? ?? ??
40 00 01

PeCompact 2.53 DLL (Slim Loader) --> BitSum Technologies
64
B8 ?? ?? ?? ?? 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 32 00 00 08 0C
00 48 E1 01 56 57 53 55 8B 5C 24 1C 85 DB 0F 84
AB 21 E8 BD 0E E6 60 0D 0B 6B 65 72 6E 6C 33 32

PECompact 2.xx (Slim Loader) --> BitSum Technologies
29
B8 ?? ?? ?? ?? 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 32 00

PECompact 2.xx --> BitSum Technologies
35
B8 ?? ?? ?? ?? 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 6F 6D 70 61 63
74 32 00

PECompact v0.90
38
EB 06 68 ?? ?? 40 00 C3 9C 60 BD ?? ?? 00 00 B9
02 00 00 00 B0 90 8D BD 7A 42 40 00 F3 AA 01 AD
D9 43 40 00 FF B5

PECompact v0.92
38
EB 06 68 ?? ?? ?? ?? C3 9C 60 BD ?? ?? ?? ?? B9
02 ?? ?? ?? B0 90 8D BD A5 4F 40 ?? F3 AA 01 AD
04 51 40 ?? FF B5

PECompact v0.94
39
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 ?? ?? ?? ?? 5D
55 58 81 ED ?? ?? ?? ?? 2B 85 ?? ?? ?? ?? 01 85
?? ?? ?? ?? 50 B9 02

PECompact v0.971 - v0.976
19
EB 06 68 C3 9C 60 E8 5D 55 5B 81 ED 8B 85 01 85
66 C7 85

PECompact v0.977
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB A0 86
40 ?? 87 DD 8B 85 2A 87

PECompact v0.978
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 24 88
40 ?? 87 DD 8B 85 A9 88

PECompact v0.978.1
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 49 87
40 ?? 87 DD 8B 85 CE 87

PECompact v0.978.2
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB D1 84
40 ?? 87 DD 8B 85 56 85

PECompact v0.98
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB D7 84
40 ?? 87 DD 8B 85 5C 85

PECompact v0.99
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 2F 85
40 ?? 87 DD 8B 85 B4 85

PECompact v1.00
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB C4 84
40 ?? 87 DD 8B 85 49 85

PECompact v1.10b1
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 28 63
40 ?? 87 DD 8B 85 AD 63

PECompact v1.10b2
40
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
40 ?? 87 DD 8B 85 94 60

PECompact v1.10b3
59
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
40 ?? 87 DD 8B 85 95 60 40 ?? 01 85 03 60 40 ??
66 C7 85 ?? 60 40 ?? 90 90 BB 95

PECompact v1.10b4
59
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
40 ?? 87 DD 8B 85 95 60 40 ?? 01 85 03 60 40 ??
66 C7 85 ?? 60 40 ?? 90 90 BB 44

PECompact v1.10b5
59
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
40 ?? 87 DD 8B 85 95 60 40 ?? 01 85 03 60 40 ??
66 C7 85 ?? 60 40 ?? 90 90 BB 49

PECompact v1.10b6
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
?? 00 87 DD 8B 85 9A 60 40 ?? 01 85 03 60 40 ??
66 C7 85 ?? 60 40 ?? 90 90 01 85 92 60 40 ?? BB
B7

PECompact v1.10b7
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 60
40 ?? 87 DD 8B 85 9A 60 40 ?? 01 85 03 60 40 ??
66 C7 85 ?? 60 40 ?? 90 90 01 85 92 60 40 ?? BB
14

PECompact v1.20 - v1.20.1
41
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 9A 70 40

PECompact v1.22
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 A6 70 40 ?? 01 85 03 70 40 ??
66 C7 85 ?? 70 40 ?? 90 90 01 85 9E 70 40 ?? BB
F3 08

PECompact v1.23b3 - v1.24.1
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 A6 70 40 ?? 01 85 03 70 40 ??
66 C7 85 70 40 90 ?? 90 01 85 9E 70 40 BB ?? D2
08

PECompact v1.24.2 - v1.24.3
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 A6 70 40 ?? 01 85 03 70 40 ??
66 C7 85 70 40 90 ?? 90 01 85 9E 70 40 BB ?? D2
09

PECompact v1.25
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 A6 70 40 ?? 01 85 03 70 40 ??
66 C7 85 70 40 90 ?? 90 01 85 9E 70 40 BB ?? F3
0D

PECompact v1.26b1 - v1.26b2
65
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 70
40 ?? 87 DD 8B 85 A6 70 40 ?? 01 85 03 70 40 ??
66 C7 85 70 40 90 ?? 90 01 85 9E 70 40 BB ?? 05
0E

PECompact v1.33
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 80
40 ?? 87 DD 8B 85 A6 80 40 ?? 01 85 03 80 40 ??
66 C7 85 00 80 40 ?? 90 90 01 85 9E 80 40 ?? BB
E8 0E

PECompact v1.34 - v1.40b1
67
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 80
40 ?? 87 DD 8B 85 A6 80 40 ?? 01 85 03 80 40 ??
66 C7 85 ?? 00 80 ?? 40 90 90 01 85 9E 80 ?? 40
BB F8 10

PECompact v1.40 - v1.45
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F A0
40 ?? 87 DD 8B 85 A6 A0 40 ?? 01 85 03 A0 40 ??
66 C7 85 ?? A0 40 ?? 90 90 01 85 9E A0 40 ?? BB
C3 11

PECompact v1.40b2 - v1.40b4
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F A0
40 ?? 87 DD 8B 85 A6 A0 40 ?? 01 85 03 A0 40 ??
66 C7 85 ?? A0 40 ?? 90 90 01 85 9E A0 40 ?? BB
86 11

PECompact v1.40b5 - v1.40b6
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F A0
40 ?? 87 DD 8B 85 A6 A0 40 ?? 01 85 03 A0 40 ??
66 C7 85 ?? A0 40 ?? 90 90 01 85 9E A0 40 ?? BB
8A 11

PECompact v1.46
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F A0
40 ?? 87 DD 8B 85 A6 A0 40 ?? 01 85 03 A0 40 ??
66 C7 85 ?? A0 40 ?? 90 90 01 85 9E A0 40 ?? BB
60 12

PECompact v1.47 - v1.50
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F A0
40 ?? 87 DD 8B 85 A6 A0 40 ?? 01 85 03 A0 40 ??
66 C7 85 ?? A0 40 ?? 90 90 01 85 9E A0 40 ?? BB
5B 12

PECompact v1.4x+
29
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81

PECompact v1.55
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 80
40 ?? 87 DD 8B 85 A2 80 40 ?? 01 85 03 80 40 ??
66 C7 85 ?? 80 40 ?? 90 90 01 85 9E 80 40 ?? BB
2D 12

PECompact v1.56
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 0F 90
40 ?? 87 DD 8B 85 A2 90 40 ?? 01 85 03 90 40 ??
66 C7 85 ?? 90 40 ?? 90 90 01 85 9E 90 40 ?? BB
2D 12

PECompact v1.60 - v1.65
66
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 80
40 ?? 87 DD 8B 85 D2 80 40 ?? 01 85 33 80 40 ??
66 C7 85 ?? 80 40 ?? 90 90 01 85 CE 80 40 ?? BB
BB 12

PECompact v1.66
78
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90
40 ?? 87 DD 8B 85 E6 90 40 ?? 01 85 33 90 40 ??
66 C7 85 ?? 90 40 ?? 90 90 01 85 DA 90 40 ?? 01
85 DE 90 40 ?? 01 85 E2 90 40 ?? BB 5B 11

PECompact v1.67
70
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90
40 87 DD 8B 85 E6 90 40 01 85 33 90 40 66 C7 85
90 40 90 90 01 85 DA 90 40 01 85 DE 90 40 01 85
E2 90 40 BB 8B 11

PECompact v1.68 - v1.84
70
EB 06 68 ?? ?? ?? ?? C3 9C 60 E8 02 ?? ?? ?? 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90
40 87 DD 8B 85 E6 90 40 01 85 33 90 40 66 C7 85
90 40 90 90 01 85 DA 90 40 01 85 DE 90 40 01 85
E2 90 40 BB 7B 11

PECompact v1.84
14
33 C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81

PECompact v2.0 beta -> Jeremy Collake
30
B8 ?? ?? ?? ?? 05 ?? ?? ?? ?? 50 64 FF 35 00 00
00 00 64 89 25 00 00 00 00 CC 90 90 90 90

PECompact v2.00 alpha 38
85
B8 ?? ?? ?? ?? 80 B8 BF 10 00 10 01 74 7A C6 80
BF 10 00 10 01 9C 55 53 51 57 52 56 8D 98 0F 10
00 10 8B 53 14 8B E8 6A 40 68 00 10 00 00 FF 73
04 6A 00 8B 4B 10 03 CA 8B 01 FF D0 8B F8 50 8B
33 8B 53 14 03 F2 8B 4B 0C 03 CA 8D 85 B7 10 00
10 FF 73 04 8F

PECompact v2.5 Retail (Slim Loader) -> Bitsum Technologies
29
B8 ?? ?? ?? 01 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 32 00

PECompact v2.5 Retail -> Bitsum Technologies
35
B8 ?? ?? ?? 01 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 6F 6D 70 61 63
74 32 00

PECompact V2.X-> Bitsum Technologies
27
B8 ?? ?? ?? ?? 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43

PECompact v2.xx
35
B8 ?? ?? ?? 00 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 33 C0 89 08 50 45 43 6F 6D 70 61 63
74 32 00

PeCompact2 2.53-2.76 --> BitSum Technologies
85
B8 ?? ?? ?? ?? 55 53 51 57 56 52 8D 98 C9 11 00
10 8B 53 18 52 8B E8 6A 40 68 00 10 00 00 FF 73
04 6A 00 8B 4B 10 03 CA 8B 01 FF D0 5A 8B F8 50
52 8B 33 8B 43 20 03 C2 8B 08 89 4B 20 8B 43 1C
03 C2 8B 08 89 4B 1C 03 F2 8B 4B 0C 03 CA 8D 43
1C 50 57 56 FF

PECrc32 0.88 -> ZhouJinYu
25
60 E8 00 00 00 00 5D 81 ED B6 A4 45 00 8D BD B0
A4 45 00 81 EF 82 00 00 00

PEcrypt - by archphase
435
55 8B EC 83 C4 E0 53 56 33 C0 89 45 E4 89 45 E0
89 45 EC ?? ?? ?? ?? 64 82 40 00 E8 7C C7 FF FF
33 C0 55 68 BE 84 40 00 64 FF 30 64 89 20 68 CC
84 40 00 ?? ?? ?? ?? 00 A1 10 A7 40 00 50 E8 1D
C8 FF FF 8B D8 85 DB 75 39 E8 3A C8 FF FF 6A 00
6A 00 68 A0 A9 40 00 68 00 04 00 00 50 6A 00 68
00 13 00 00 E8 FF C7 FF FF 6A 00 68 E0 84 40 00
A1 A0 A9 40 00 50 6A 00 E8 ?? ?? ?? ?? E9 7D 01
00 00 53 A1 10 A7 40 00 50 E8 42 C8 FF FF 8B F0
85 F6 75 18 6A 00 68 E0 84 40 00 68 E4 84 40 00
6A 00 E8 71 C8 FF FF E9 53 01 00 00 53 6A 00 E8
2C C8 FF FF A3 ?? ?? ?? ?? 83 3D 48 A8 40 00 00
75 18 6A 00 68 E0 84 40 00 68 F8 84 40 00 6A 00
E8 43 C8 FF FF E9 25 01 00 00 56 E8 F8 C7 FF FF
A3 4C A8 40 00 A1 48 A8 40 00 E8 91 A1 FF FF 8B
D8 8B 15 48 A8 40 00 85 D2 7C 16 42 33 C0 8B 0D
4C A8 40 00 03 C8 8A 09 8D 34 18 88 0E 40 4A 75
ED 8B 15 48 A8 40 00 85 D2 7C 32 42 33 C0 8D 34
18 8A 0E 80 F9 01 75 05 C6 06 FF EB 1C 8D 0C 18
8A 09 84 ?? ?? ?? ?? ?? 00 EB 0E 8B 0D 4C A8 40
00 03 C8 0F B6 09 49 88 0E 40 4A 75 D1 8D ?? ??
?? ?? E8 A5 A3 FF FF 8B 45 E8 8D 55 EC E8 56 D5
FF FF 8D 45 EC BA 18 85 40 00 E8 79 BA FF FF 8B
45 EC E8 39 BB FF FF 8B D0 B8 54 A8 40 00 E8 31
A6 FF FF BA 01 00 00 00 B8 54 A8 40 00 E8 12 A9
FF FF E8 DD A1 FF FF 68 50 A8 40 00 8B D3 8B 0D
48 A8 40 00 B8 54 A8 40 00 E8 56 A7 FF FF E8 C1
A1 FF FF

PEEncrypt v4.0b (JunkCode)
8
66 ?? ?? 00 66 83 ?? 00

PEiD-Bundle v1.00 - v1.01 --> BoB / BobSoft
64
60 E8 ?? 02 00 00 8B 44 24 04 52 48 66 31 C0 66
81 38 4D 5A 75 F5 8B 50 3C 81 3C 02 50 45 00 00
75 E9 5A C2 04 00 60 89 DD 89 C3 8B 45 3C 8B 54
28 78 01 EA 52 8B 52 20 01 EA 31 C9 41 8B 34 8A

PEiD-Bundle v1.00 --> BoB / BobSoft
64
60 E8 21 02 00 00 8B 44 24 04 52 48 66 31 C0 66
81 38 4D 5A 75 F5 8B 50 3C 81 3C 02 50 45 00 00
75 E9 5A C2 04 00 60 89 DD 89 C3 8B 45 3C 8B 54
28 78 01 EA 52 8B 52 20 01 EA 31 C9 41 8B 34 8A

PEiD-Bundle v1.01 --> BoB / BobSoft
64
60 E8 23 02 00 00 8B 44 24 04 52 48 66 31 C0 66
81 38 4D 5A 75 F5 8B 50 3C 81 3C 02 50 45 00 00
75 E9 5A C2 04 00 60 89 DD 89 C3 8B 45 3C 8B 54
28 78 01 EA 52 8B 52 20 01 EA 31 C9 41 8B 34 8A

PEiD-Bundle v1.02 - v1.03 --> BoB / BobSoft
64
60 E8 9C 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 36 ?? ?? ?? 2E ?? ?? ?? 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00
00 80 00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 44

PEiD-Bundle v1.02 - v1.03 DLL --> BoB / BobSoft
64
83 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 9C 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 41 00 08
00 39 00 08 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 01 00 00 80 00 00 00

PEiD-Bundle v1.02 - v1.04 --> BoB / BobSoft
64
60 E8 ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 36 ?? ?? ?? 2E ?? ?? ?? 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00
00 80 00 00 00 00 4B 65 72 6E 65 6C 33 32 2E 44

Pelles C 2.8.x-4.5.x -> Pelle Orinius
31
55 89 E5 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
FF 35 ?? ?? ?? ?? 64 89 25 ?? ?? ?? ?? 83 EC

Pelles C 2.80 -2.90 EXE (X86 CRT-LIB)
53
55 89 E5 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
FF 35 ?? ?? ?? ?? 64 89 25 ?? ?? ?? ?? 83 EC ??
83 EC ?? 53 56 57 89 65 E8 68 00 00 00 ?? E8 ??
?? ?? ?? 59 A3

Pelles C 2.90, 3.00, 4.00 DLL (X86 CRT-LIB)
50
55 89 E5 53 56 57 8B 5D 0C 8B 75 10 BF 01 00 00
00 85 DB 75 10 83 3D ?? ?? ?? ?? 00 75 07 31 C0
E9 ?? ?? ?? ?? 83 FB 01 74 05 83 FB 02 75 ?? 85
FF 74

Pelles C 2.x-4.x DLL -> Pelle Orinius
12
55 89 E5 53 56 57 8B 5D 0C 8B 75 10

Pelles C 3.00, 4.00, 4.50 EXE (X86 CRT-DLL)
62
55 89 E5 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
FF 35 ?? ?? ?? ?? 64 89 25 ?? ?? ?? ?? 83 EC ??
53 56 57 89 65 E8 C7 45 FC ?? ?? ?? ?? 68 ?? ??
?? ?? E8 ?? ?? ?? ?? 59 BE ?? ?? ?? ?? EB

Pelles C 3.00, 4.00, 4.50 EXE (X86 CRT-LIB)
50
55 89 E5 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
FF 35 ?? ?? ?? ?? 64 89 25 ?? ?? ?? ?? 83 EC ??
53 56 57 89 65 E8 68 00 00 00 02 E8 ?? ?? ?? ??
59 A3

Pelles C 4.50 DLL (X86 CRT-LIB)
38
55 89 E5 53 56 57 8B 5D 0C 8B 75 10 85 DB 75 0D
83 3D ?? ?? ?? ?? 00 75 04 31 C0 EB 57 83 FB 01
74 05 83 FB 02 75

PELOCKnt 2.04
20
EB 03 CD 20 C7 1E EB 03 CD 20 EA 9C EB 02 EB 01
EB 01 EB 60

PEMangle
22
60 9C BE ?? ?? ?? ?? 8B FE B9 ?? ?? ?? ?? BB 44
52 4F 4C AD 33 C3

PEncrypt 1.0 -> JunkCode
32
60 9C BE 00 10 40 00 8B FE B9 ?? ?? ?? ?? BB 78
56 34 12 AD 33 C3 AB E2 FA 9D 61 E9 ?? ?? ?? FF

PEncrypt 2.0 -> junkcode
85
EB 25 00 00 F7 BF 00 00 00 00 00 00 00 00 00 00
12 00 E8 00 56 69 72 74 75 61 6C 50 72 6F 74 65
63 74 00 00 00 00 00 E8 00 00 00 00 5D 81 ED 2C
10 40 00 8D B5 14 10 40 00 E8 33 00 00 00 89 85
10 10 40 00 BF 00 00 40 00 8B F7 03 7F 3C 8B 4F
54 51 56 8D 85

PEncrypt v1.0
27
60 9C BE 00 10 40 00 8B FE B9 28 03 00 00 BB 78
56 34 12 AD 33 C3 AB E2 FA 9D 61

PEncrypt v3.0
35
E8 00 00 00 00 5D 81 ED 05 10 40 00 8D B5 24 10
40 00 8B FE B9 0F 00 00 00 BB ?? ?? ?? ?? AD 33
C3 E2 FA

PEncrypt v3.1
8
E9 ?? ?? ?? 00 F0 0F C6

PEnguinCrypt v1.0
55
B8 93 ?? ?? 00 55 50 67 64 FF 36 00 00 67 64 89
26 00 00 BD 4B 48 43 42 B8 04 00 00 00 CC 3C 04
75 04 90 90 C3 90 67 64 8F 06 00 00 58 5D BB 00
00 40 00 33 C9 33 C0

PENightMare 2 Beta
22
60 E9 ?? ?? ?? ?? EF 40 03 A7 07 8F 07 1C 37 5D
43 A7 04 B9 2C 3A

PENightMare v1.3
18
60 E8 00 00 00 00 5D B9 ?? ?? ?? ?? 80 31 15 41
81 F9

PENinja
36
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90

PENinja modified
35
5D 8B C5 81 ED B2 2C 40 00 2B 85 94 3E 40 00 2D
71 02 00 00 89 85 98 3E 40 00 0F B6 B5 9C 3E 40
00 8B FD

PEQuake 0.06-> forgat
147
E8 A5 00 00 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 3D ?? ?? 00 2D ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 4A ?? ??
00 5B ?? ?? 00 6E ?? ?? 00 00 00 00 00 6B 45 72
4E 65 4C 33 32 2E 64 4C 6C 00 00 00 47 65 74 50
72 6F 63 41 64 64 72 65 73 73 00 00 00 47 65 74
4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00 00
4C 6F 61 64 4C 69 62 72 61 72 79 41 00 ?? ?? 00
00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 00 00
00 00 00

PEQuake v0.06 by fORGAT
85
E8 A5 00 00 00 2D ?? 00 00 00 00 00 00 00 00 00
00 3D ?? 00 00 2D ?? 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 4A ?? 00
00 5B ?? 00 00 6E ?? 00 00 00 00 00 00 6B 45 72
4E 65 4C 33 32 2E 64 4C 6C 00 00 00 47 65 74 50
72 6F 63 41 64

PerlApp 6.0.2 -> ActiveState
138
68 2C EA 40 00 FF D3 83 C4 0C 85 C0 0F 85 CD 00
00 00 6A 09 57 68 20 EA 40 00 FF D3 83 C4 0C 85
C0 75 12 8D 47 09 50 FF 15 1C D1 40 00 59 A3 B8
07 41 00 EB 55 6A 08 57 68 14 EA 40 00 FF D3 83
C4 0C 85 C0 75 11 8D 47 08 50 FF 15 1C D1 40 00
59 89 44 24 10 EB 33 6A 09 57 68 08 EA 40 00 FF
D3 83 C4 0C 85 C0 74 22 6A 08 57 68 FC E9 40 00
FF D3 83 C4 0C 85 C0 74 11 6A 0B 57 68 F0 E9 40
00 FF D3 83 C4 0C 85 C0 75 55

PerlApp 6.0.2 -> ActiveState
104
68 9C E1 40 00 FF 15 A4 D0 40 00 85 C0 59 74 0F
50 FF 15 1C D1 40 00 85 C0 59 89 45 FC 75 62 6A
00 8D 45 F8 FF 75 0C F6 45 14 01 50 8D 45 14 50
E8 9B 01 00 00 83 C4 10 85 C0 0F 84 E9 00 00 00
8B 45 F8 83 C0 14 50 FF D6 85 C0 59 89 45 FC 75
0E FF 75 14 FF 15 78 D0 40 00 E9 C9 00 00 00 68
8C E1 40 00 FF 75 14 50

PESHiELD v0.1b MTE
33
E8 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? B9 1B 01 ?? ??
D1

PESHiELD v0.2 / v0.2b / v0.2b2
20
60 E8 ?? ?? ?? ?? 41 4E 41 4B 49 4E 5D 83 ED 06
EB 02 EA 04

PESHiELD v0.251
9
5D 83 ED 06 EB 02 EA 04 8D

PEShit
26
B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? 83 F9 00 7E 06 80
30 ?? 40 E2 F5 E9 ?? ?? ?? FF

PESpin v0.1 -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 5C CB 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESpin v0.1 -> Cyberbob
288
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 5C CB 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF E8 01 00 00 00 EA 5A 83 EA 0B FF
E2 8B 95 B3 28 40 00 8B 42 3C 03 C2 89 85 BD 28
40 00 41 C1 E1 07 8B 0C 01 03 CA 8B 59 10 03 DA
8B 1B 89 9D D1 28 40 00 53 8F 85 C4 27 40 00 BB
?? 00 00 00 B9 A5 08 00 00 8D BD 75 29 40 00 4F
30 1C 39 FE CB E2 F9 68 2D 01 00 00 59 8D BD AA
30 40 00 C0 0C 39 02 E2 FA E8 02 00 00 00 FF 15
5A 8D 85 07 4F 56 00 BB 54 13 0B 00 D1 E3 2B C3
FF E0 E8 01 00 00 00 68 E8 1A 00 00 00 8D 34 28
B8 ?? ?? ?? ?? 2B C9 83 C9 15 0F A3 C8 0F 83 81
00 00 00 8D B4 0D C4 28 40 00 8B D6 B9 10 00 00
00 AC 84 C0 74 06 C0 4E FF 03 E2 F5 E8 00 00 00
00 59 81 C1 1D 00 00 00 52 51 C1 E9 05 23 D1 FF

PESpin v0.3 (Eng) -> cyberbob
30
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 B7 CD 46

PESpin v0.3 (Eng) -> cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 B7 CD 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESpin V0.3 -> cyberbob
255
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 B7 CD 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF E8 01 00 00 00 EA 5A 83 EA 0B FF
E2 8B 95 CB 2C 40 00 8B 42 3C 03 C2 89 85 D5 2C
40 00 41 C1 E1 07 8B 0C 01 03 CA 8B 59 10 03 DA
8B 1B 89 9D E9 2C 40 00 53 8F 85 B6 2B 40 00 BB
?? 00 00 00 B9 75 0A 00 00 8D BD 7E 2D 40 00 4F
30 1C 39 FE CB E2 F9 68 3C 01 00 00 59 8D BD B6
36 40 00 C0 0C 39 02 E2 FA E8 02 00 00 00 FF 15
5A 8D 85 1F 53 56 00 BB 54 13 0B 00 D1 E3 2B C3
FF E0 E8 01 00 00 00 68 E8 1A 00 00 00 8D 34 28
B9 08 00 00 00 B8 ?? ?? ?? ?? 2B C9 83 C9 15 0F
A3 C8 0F 83 81 00 00 00 8D B4 0D DC 2C 40 00

PESpin v0.7 -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 83 D5 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESpin V0.71 -> cyberbob
35
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 83 D5 46 00 0B
E4 74 9E

PESpin V1.1 -> cyberbob
35
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 7D DE 46 00 0B
E4 74 9E

PESpin v1.1 -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 7D DE 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESPin v1.3 -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 AC DF 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESpin v1.304 -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 88 DF 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PESpin v1.3beta -> Cyberbob
85
EB 01 68 60 E8 00 00 00 00 8B 1C 24 83 C3 12 81
2B E8 B1 06 00 FE 4B FD 82 2C 24 71 DF 46 00 0B
E4 74 9E 75 01 C7 81 73 04 D7 7A F7 2F 81 73 19
77 00 43 B7 F6 C3 6B B7 00 00 F9 FF E3 C9 C2 08
00 A3 68 72 01 FF 5D 33 C9 41 E2 17 EB 07 EA EB
01 EB EB 0D FF

PEStubOEP v1.x
21
40 48 BE 00 ?? ?? 00 40 48 60 33 C0 B8 ?? ?? ??
00 FF E0 C3 C3

PeStubOEP v1.x
12
90 33 C9 33 D2 B8 ?? ?? ?? 00 B9 FF

PeStubOEP v1.x
12
E8 05 00 00 00 33 C0 40 48 C3 E8 05

Petite 1.2
20
66 9C 60 E8 CA 00 00 00 03 00 04 00 05 00 06 00
07 00 08 00

Petite 1.2 -> (c)1998 Ian Luck
85
66 9C 60 E8 CA 00 00 00 03 00 04 00 05 00 06 00
07 00 08 00 09 00 0A 00 0B 00 0D 00 0F 00 11 00
13 00 17 00 1B 00 1F 00 23 00 2B 00 33 00 3B 00
43 00 53 00 63 00 73 00 83 00 A3 00 C3 00 E3 00
02 01 00 00 00 00 00 00 00 00 00 00 00 00 01 01
01 01 02 02 02

Petite 1.3
20
66 9C 60 50 8D 88 00 F0 00 00 8D 90 04 16 00 00
8B DC 8B E1

Petite 1.3 -> (c)1998 Ian Luck
85
?? ?? ?? ?? ?? ?? 9C 60 50 8D 88 00 ?? ?? ?? 8D
90 ?? ?? 00 00 8B DC 8B E1 68 00 00 ?? ?? 53 50
80 04 24 08 50 80 04 24 42 50 80 04 24 61 50 80
04 24 9D 50 80 04 24 BB 83 3A 00 0F 84 DA 14 00
00 8B 44 24 18 F6 42 03 80 74 19 FD 80 72 03 80
8B F0 8B F8 03

Petite 1.4
20
66 9C 60 50 8B D8 03 00 68 54 BC 00 00 6A 00 FF
50 14 8B CC

Petite 1.4 -> (c)1998-99 Ian Luck
85
?? ?? ?? ?? ?? 66 9C 60 50 8B D8 03 00 68 54 BC
00 00 6A 00 FF 50 14 8B CC 8D A0 54 BC 00 00 50
8B C3 8D 90 ?? 16 00 00 68 00 00 ?? ?? 51 50 80
04 24 08 50 80 04 24 42 50 80 04 24 61 50 80 04
24 9D 50 80 04 24 BB 83 3A 00 0F 84 D8 14 00 00
8B 44 24 18 F6

Petite 2.1
20
64 FF 35 00 00 00 00 64 89 25 00 00 00 00 66 9C
60 50 8B D8

Petite 2.2 -> (c)1998-99 Ian Luck
85
?? ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 FF 35 00 00 00
00 64 89 25 00 00 00 00 66 9C 60 50 68 00 00 ??
?? 8B 3C 24 8B 30 66 81 C7 80 07 8D 74 06 08 89
38 8B 5E 10 50 56 6A 02 68 80 08 00 00 57 6A ??
6A 06 56 6A 04 68 80 08 00 00 57 FF D3 83 EE 08
59 F3 A5 59 66

PEtite v1.2
18
9C 60 E8 CA ?? ?? ?? 03 ?? 04 ?? 05 ?? 06 ?? 07
?? 08

PEtite v1.3
41
?? ?? ?? ?? ?? 66 9C 60 50 8D 88 ?? F0 ?? ?? 8D
90 04 16 ?? ?? 8B DC 8B E1 68 ?? ?? ?? ?? 53 50
80 04 24 08 50 80 04 24 42

PEtite v1.4
20
66 9C 60 50 8B D8 03 ?? 68 54 BC ?? ?? 6A ?? FF
50 14 8B CC

PEtite v1.4
25
?? ?? ?? ?? ?? 66 9C 60 50 8B D8 03 00 68 54 BC
00 00 6A 00 FF 50 14 8B CC

Petite v1.4
20
B8 ?? ?? ?? ?? 66 9C 60 50 8B D8 03 00 68 ?? ??
?? ?? 6A 00

PEtite v2.0
40
B8 ?? ?? ?? ?? 66 9C 60 50 8B D8 03 ?? 68 54 BC
?? ?? 6A ?? FF 50 18 8B CC 8D A0 54 BC ?? ?? 8B
C3 8D 90 E0 15 ?? ?? 68

PEtite v2.1
30
B8 ?? ?? ?? ?? 6A ?? 68 ?? ?? ?? ?? 64 FF 35 ??
?? ?? ?? 64 89 25 ?? ?? ?? ?? 66 9C 60 50

Petite v2.1 (1)
28
B8 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 ?? ?? ?? ?? ??
?? 64 ?? ?? ?? ?? ?? ?? 66 9C 60 50

Petite v2.1 (2)
30
B8 ?? ?? ?? ?? 6A 00 68 ?? ?? ?? ?? 64 ?? ?? ??
?? ?? ?? 64 ?? ?? ?? ?? ?? ?? 66 9C 60 50

PEtite v2.2
28
B8 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 FF 35 ?? ?? ??
?? 64 89 25 ?? ?? ?? ?? 66 9C 60 50

Petite v?.? (after v1.4)
21
B8 ?? ?? ?? ?? 66 9C 60 50 8D ?? ?? ?? ?? ?? 68
?? ?? ?? ?? 83

PEtite vx.x
9
B8 ?? ?? ?? ?? 66 9C 60 50

PeX 0.99 -> bart^CrackPl
28
E9 F5 ?? ?? ?? 0D 0A C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4

PEX v0.99
18
60 E8 01 ?? ?? ?? ?? 83 C4 04 E8 01 ?? ?? ?? ??
5D 81

PeX v0.99 (Eng) -> bart/CrackPl
85
E9 F5 00 00 00 0D 0A C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4
C4 C4 C4 C4 C4

PEZip v1.0 by BaGIE
85
D9 D0 F8 74 02 23 DB F5 F5 50 51 52 53 8D 44 24
10 50 55 56 57 D9 D0 22 C9 C1 F7 A0 55 66 C1 C8
B0 5D 81 E6 FF FF FF FF F8 77 07 52 76 03 72 01
90 5A C1 E0 60 90 BD 1F 01 00 00 87 E8 E2 07 E3
05 17 5D 47 E4 42 41 7F 06 50 66 83 EE 00 58 25
FF FF FF FF 51

PE_Admin 1.0 (EncryptPE 1.2003.5.18 Sold) -> Flying Cat
257
60 9C 64 FF 35 00 00 00 00 E8 79 01 00 00 90 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
53 79 73 74 65 6D 44 69 72 65 63 74 6F 72 79 41
00 00 00 43 72 65 61 74 65 46 69 6C 65 41 00 00
00 43 72 65 61 74 65 46 69 6C 65 4D 61 70 70 69
6E 67 41 00 00 00 4D 61 70 56 69 65 77 4F 66 46
69 6C 65 00 00 00 55 6E 6D 61 70 56 69 65 77 4F
66 46 69 6C 65 00 00 00 43 6C 6F 73 65 48 61 6E
64 6C 65 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64 72
65 73 73 00 00 00 45 78 69 74 50 72 6F 63 65 73
73

PE_Admin 1.0 (EncryptPE 1.2003.5.18 Sold) -> Flying Cat
261
60 9C 64 FF 35 00 00 00 00 E8 79 01 00 00 90 00
00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65
72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 47 65 74
53 79 73 74 65 6D 44 69 72 65 63 74 6F 72 79 41
00 00 00 43 72 65 61 74 65 46 69 6C 65 41 00 00
00 43 72 65 61 74 65 46 69 6C 65 4D 61 70 70 69
6E 67 41 00 00 00 4D 61 70 56 69 65 77 4F 66 46
69 6C 65 00 00 00 55 6E 6D 61 70 56 69 65 77 4F
66 46 69 6C 65 00 00 00 43 6C 6F 73 65 48 61 6E
64 6C 65 00 00 00 4C 6F 61 64 4C 69 62 72 61 72
79 41 00 00 00 47 65 74 50 72 6F 63 41 64 64 72
65 73 73 00 00 00 45 78 69 74 50 72 6F 63 65 73
73 00 00 00 00

PGMPACK v0.13
39
FA 1E 17 50 B4 30 CD 21 3C 02 73 ?? B4 4C CD 21
FC BE ?? ?? BF ?? ?? E8 ?? ?? E8 ?? ?? BB ?? ??
BA ?? ?? 8A C3 8B F3

PGMPACK v0.14
38
1E 17 50 B4 30 CD 21 3C 02 73 ?? B4 4C CD 21 FC
BE ?? ?? BF ?? ?? E8 ?? ?? E8 ?? ?? BB ?? ?? BA
?? ?? 8A C3 8B F3

Pi Cryptor 1.0 - by Scofield
178
55 8B EC 83 C4 EC 53 56 57 31 C0 89 45 EC B8 40
1E 06 00 E8 48 FA FF FF 33 C0 55 68 36 1F 06 00
64 FF 30 64 89 20 6A 00 68 80 00 00 00 6A 03 6A
00 6A 01 68 00 00 00 80 8D 55 EC 31 C0 E8 4E F4
FF FF 8B 45 EC E8 F6 F7 FF FF 50 E8 CC FA FF FF
8B D8 83 FB FF 74 4E 6A 00 53 E8 CD FA FF FF 8B
F8 81 EF AC 26 00 00 6A 00 6A 00 68 AC 26 00 00
53 E8 DE FA FF FF 89 F8 E8 E3 F1 FF FF 89 C6 6A
00 68 28 31 06 00 57 56 53 E8 AE FA FF FF 53 E8
80 FA FF FF 89 FA 81 EA 72 01 00 00 8B C6 E8 55
FE FF FF 89 C6 89 F0 09 C0 74 05 E8 A8 FB FF FF
31 C0

Pi Cryptor 1.0 - by Scofield
198
55 8B EC 83 C4 EC 53 56 57 31 C0 89 45 EC B8 40
1E 06 00 E8 48 FA FF FF 33 C0 55 68 36 1F 06 00
64 FF 30 64 89 20 6A 00 68 80 00 00 00 6A 03 6A
00 6A 01 68 00 00 00 80 8D 55 EC 31 C0 E8 4E F4
FF FF 8B 45 EC E8 F6 F7 FF FF 50 E8 CC FA FF FF
8B D8 83 FB FF 74 4E 6A 00 53 E8 CD FA FF FF 8B
F8 81 EF AC 26 00 00 6A 00 6A 00 68 AC 26 00 00
53 E8 DE FA FF FF 89 F8 E8 E3 F1 FF FF 89 C6 6A
00 68 28 31 06 00 57 56 53 E8 AE FA FF FF 53 E8
80 FA FF FF 89 FA 81 EA 72 01 00 00 8B C6 E8 55
FE FF FF 89 C6 89 F0 09 C0 74 05 E8 A8 FB FF FF
31 C0 5A 59 59 64 89 10 68 3D 1F 06 00 8D 45 EC
E8 C3 F6 FF FF C3

Pi Cryptor 1.0 - by Scofield
95
89 55 F8 BB 01 00 00 00 8A 04 1F 24 0F 8B 55 FC
8A 14 32 80 E2 0F 32 C2 8A 14 1F 80 E2 F0 02 D0
88 14 1F 46 8D 45 F4 8B 55 FC E8 ?? ?? ?? ?? 8B
45 F4 E8 ?? ?? ?? ?? 3B F0 7E 05 BE 01 00 00 00
43 FF 4D F8 75 C2 ?? ?? ?? ?? 5A 59 59 64 89 10
68 ?? ?? ?? ?? 8D 45 F4 E8 ?? ?? ?? ?? C3 E9

PKLITE v1.00, v1.03
11
B8 ?? ?? BA ?? ?? 8C DB 03 D8 3B

PKLITE v1.00c (1)
39
2E 8C 1E ?? ?? 8B 1E ?? ?? 8C DA 81 C2 ?? ?? 3B
DA 72 ?? 81 EB ?? ?? 83 EB ?? FA 8E D3 BC ?? ??
FB FD BE ?? ?? 8B FE

PKLITE v1.00c (2)
36
BA ?? ?? A1 ?? ?? 2D ?? ?? 8C CB 81 C3 ?? ?? 3B
C3 77 ?? 05 ?? ?? 3B C3 77 ?? B4 09 BA ?? ?? CD
21 CD 20 90

PKLITE v1.12, v1.15, v1.20 (1)
50
B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 ?? ?? 73 ?? 2D
?? ?? FA 8E D0 FB 2D ?? ?? 8E C0 50 B9 ?? ?? 33
FF 57 BE ?? ?? FC F3 A5 CB B4 09 BA ?? ?? CD 21
CD 20

PKLITE v1.12, v1.15, v1.20 (2)
9
B8 ?? ?? BA ?? ?? 3B C4 73

PKLITE v1.14, v1.15, v1.20 (3)
26
B8 ?? ?? BA ?? ?? 05 ?? ?? 3B ?? ?? ?? 72 ?? B4
09 BA ?? 01 CD 21 CD 20 4E 6F

PKLITE v1.14, v1.20
24
B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 ?? ?? 72 ?? B4
09 BA ?? ?? CD 21 CD 20

PKLITE v1.20
26
B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 ?? ?? 72 ?? B4
09 BA ?? ?? CD 21 B4 4C CD 21

PKLITE v1.50 (1)
28
50 B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 ?? ?? 72 ??
B4 ?? BA ?? ?? CD 21 B8 ?? ?? CD 21

PKLITE v1.50 (Device driver compression)
24
B4 09 BA 14 01 CD 21 B8 00 4C CD 21 F8 9C 50 53
51 52 56 57 55 1E 06 BB

PKLITE v2.00b
72
50 B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 02 00 72 ??
B4 09 BA ?? ?? CD 21 B8 01 4C CD 21 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 59 2D ?? ?? 8E D0
51 2D ?? ?? 8E C0 50 B9

PKLITE v2.00b [extra]
78
50 B8 ?? ?? BA ?? ?? 05 ?? ?? 3B 06 02 00 72 ??
B4 09 BA ?? ?? CD 21 B8 01 4C CD 21 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? EA ?? ?? ?? ?? F3
A5 C3 59 2D ?? ?? 8E D0 51 2D ?? ?? 50 80

PKLITE v2.00c
28
50 B8 ?? ?? BA ?? ?? 3B C4 73 ?? 8B C4 2D ?? ??
25 ?? ?? 8B F8 B9 ?? ?? BE ?? ?? FC

PKLITE32 1.1
20
50 4B 4C 49 54 45 33 32 20 43 6F 70 79 72 69 67
68 74 20 31

PKLITE32 1.1 -> PKWARE Inc.
21
68 ?? ?? ?? 00 68 ?? ?? ?? 00 68 00 00 00 00 E8
?? ?? ?? ?? E9

PKLITE32 v1.1
30
55 8B EC A1 ?? ?? ?? ?? 85 C0 74 09 B8 01 00 00
00 5D C2 0C 00 8B 45 0C 57 56 53 8B 5D 10

PKLITE32 v1.1
30
55 8B EC A1 ?? ?? ?? ?? 85 C0 74 09 B8 01 ?? ??
?? 5D C2 0C ?? 8B 45 0C 57 56 53 8B 5D 10

PKLITE32 v1.1
16
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 68 00 00 00 00 E8

PKLITE32 v1.1
20
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 2B
44 24 0C 50

PKLITE32 v1.1
49
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 50 4B 4C
49 54 45 33 32 20 43 6F 70 79 72 69 67 68 74 20
31

Pksmart 1.0b
21
BA ?? ?? 8C C8 8B C8 03 C2 81 ?? ?? ?? 51 B9 ??
?? 51 1E 8C D3

PKTINY v1.0 with TINYPROG v3.8
25
2E C6 06 ?? ?? ?? 2E C6 06 ?? ?? ?? 2E C6 06 ??
?? ?? E9 ?? ?? E8 ?? ?? 83

PKZIP-SFX v1.1 1989-90
32
FC 2E 8C 0E ?? ?? A1 ?? ?? 8C CB 81 C3 ?? ?? 3B
C3 72 ?? 2D ?? ?? 2D ?? ?? FA BC ?? ?? 8E D0 FB

PLINK86 1984, 1985
13
FA 8C C7 8C D6 8B CC BA ?? ?? 8E C2 26

PluginToExe v1.00 -> BoB / BobSoft
119
E8 00 00 00 00 29 C0 5D 81 ED D1 40 40 00 50 FF
95 B8 40 40 00 89 85 09 40 40 00 FF 95 B4 40 40
00 89 85 11 40 40 00 50 FF 95 C0 40 40 00 8A 08
80 F9 22 75 07 50 FF 95 C4 40 40 00 89 85 0D 40
40 00 8B 9D 09 40 40 00 60 6A 00 6A 01 53 81 C3
?? ?? ?? 00 FF D3 61 6A 00 68 44 69 45 50 FF B5
0D 40 40 00 6A 00 81 C3 ?? ?? ?? 00 FF D3 83 C4
10 FF 95 B0 40 40 00

PluginToExe v1.01 -> BoB / BobSoft
262
E8 00 00 00 00 29 C0 5D 81 ED C6 41 40 00 50 8F
85 71 40 40 00 50 FF 95 A5 41 40 00 89 85 6D 40
40 00 FF 95 A1 41 40 00 50 FF 95 B5 41 40 00 80
38 00 74 16 8A 08 80 F9 22 75 07 50 FF 95 B9 41
40 00 89 85 75 40 40 00 EB 6C 6A 01 8F 85 71 40
40 00 6A 58 6A 40 FF 95 A9 41 40 00 89 85 69 40
40 00 89 C7 68 00 08 00 00 6A 40 FF 95 A9 41 40
00 89 47 1C C7 07 58 00 00 00 C7 47 20 00 08 00
00 C7 47 18 01 00 00 00 C7 47 34 04 10 88 00 8D
8D B9 40 40 00 89 4F 0C 8D 8D DB 40 40 00 89 4F
30 FF B5 69 40 40 00 FF 95 95 41 40 00 FF 77 1C
8F 85 75 40 40 00 8B 9D 6D 40 40 00 60 6A 00 6A
01 53 81 C3 ?? ?? ?? 00 FF D3 61 6A 00 68 44 69
45 50 FF B5 75 40 40 00 6A 00 81 C3 ?? ?? 00 00
FF D3 83 C4 10 83 BD 71 40 40 00 00 74 10 FF 77
1C FF 95 AD 41 40 00 57 FF 95 AD 41 40 00 6A 00
FF 95 9D 41 40 00

PluginToExe v1.02 -> BoB / BobSoft
120
E8 00 00 00 00 29 C0 5D 81 ED 32 42 40 00 50 8F
85 DD 40 40 00 50 FF 95 11 42 40 00 89 85 D9 40
40 00 FF 95 0D 42 40 00 50 FF 95 21 42 40 00 80
38 00 74 16 8A 08 80 F9 22 75 07 50 FF 95 25 42
40 00 89 85 E1 40 40 00 EB 6C 6A 01 8F 85 DD 40
40 00 6A 58 6A 40 FF 95 15 42 40 00 89 85 D5 40
40 00 89 C7 68 00 08 00 00 6A 40 FF 95 15 42 40
00 89 47 1C C7 07 58 00

PMODE/W v.1.12, 1.16, 1.21, 1.33 DOS extender
25
FC 16 07 BF ?? ?? 8B F7 57 B9 ?? ?? F3 A5 06 1E
07 1F 5F BE ?? ?? 06 0E A4

PocketPC ARM
82
F0 40 2D E9 00 40 A0 E1 01 50 A0 E1 02 60 A0 E1
03 70 A0 E1 ?? 00 00 EB 07 30 A0 E1 06 20 A0 E1
05 10 A0 E1 04 00 A0 E1 ?? ?? ?? EB F0 40 BD E8
?? 00 00 EA ?? 40 2D E9 ?? ?? 9F E5 ?? ?? ?? ??
?? 00 ?? ?? ?? ?? ?? ?? ?? ?? 9F E5 00 ?? ?? ??
?? 00

PocketPC MIB
82
E8 FF BD 27 14 00 BF AF 18 00 A4 AF 1C 00 A5 AF
20 00 A6 AF 24 00 A7 AF ?? ?? ?? 0C 00 00 00 00
18 00 A4 8F 1C 00 A5 8F 20 00 A6 8F ?? ?? ?? 0C
24 00 A7 8F ?? ?? ?? 0C 25 20 40 00 14 00 BF 8F
08 00 E0 03 18 00 BD 27 ?? FF BD 27 18 00 ?? AF
?? 00

PocketPC SHA
85
86 2F 96 2F A6 2F B6 2F 22 4F 43 68 53 6B 63 6A
73 69 F0 7F 0B D0 0B 40 09 00 09 D0 B3 65 A3 66
93 67 0B 40 83 64 03 64 04 D0 0B 40 09 00 10 7F
26 4F F6 6B F6 6A F6 69 0B 00 F6 68 ?? ?? ?? 00
?? ?? ?? 00 ?? ?? ?? 00 22 4F F0 7F 0A D0 06 D4
06 D5 0B 40 09

Pohernah 1.0.0 - by Kas
101
58 60 E8 00 00 00 00 5D 81 ED 20 25 40 00 8B BD
86 25 40 00 8B 8D 8E 25 40 00 6B C0 05 83 F0 04
89 85 92 25 40 00 83 F9 00 74 2D 81 7F 1C AB 00
00 00 75 1E 8B 77 0C 03 B5 8A 25 40 00 31 C0 3B
47 10 74 0E 50 8B 85 92 25 40 00 30 06 58 40 46
EB ED 83 C7 28 49 EB CE 8B 85 82 25 40 00 89 44
24 1C 61 FF E0

Pohernah 1.0.1 - by Kas
297
60 E8 00 00 00 00 5D 81 ED F1 26 40 00 8B BD 18
28 40 00 8B 8D 20 28 40 00 B8 38 28 40 00 01 E8
80 30 05 83 F9 00 74 71 81 7F 1C AB 00 00 00 75
62 8B 57 0C 03 95 1C 28 40 00 31 C0 51 31 C9 66
B9 FA 00 66 83 F9 00 74 49 8B 57 0C 03 95 1C 28
40 00 8B 85 24 28 40 00 83 F8 02 75 06 81 C2 00
02 00 00 51 8B 4F 10 83 F8 02 75 06 81 E9 00 02
00 00 57 BF C8 00 00 00 89 CE E8 27 00 00 00 89
C1 5F B8 38 28 40 00 01 E8 E8 24 00 00 00 59 49
EB B1 59 83 C7 28 49 EB 8A 8B 85 14 28 40 00 89
44 24 1C 61 FF E0 56 57 4F F7 D7 21 FE 89 F0 5F
5E C3 60 83 F0 05 40 90 48 83 F0 05 89 C6 89 D7
60 E8 0B 00 00 00 61 83 C7 08 83 E9 07 E2 F1 61
C3 57 8B 1F 8B 4F 04 68 B9 79 37 9E 5A 42 89 D0
48 C1 E0 05 BF 20 00 00 00 4A 89 DD C1 E5 04 29
E9 8B 6E 08 31 DD 29 E9 89 DD C1 ED 05 31 C5 29
E9 2B 4E 0C 89 CD C1 E5 04 29 EB 8B 2E 31 CD 29
EB 89 CD C1 ED 05 31 C5 29 EB 2B 5E 04 29 D0 4F
75 C8 5F 89 1F 89 4F 04 C3

Pohernah 1.0.2 - by Kas
297
60 E8 00 00 00 00 5D 81 ED DE 26 40 00 8B BD 05
28 40 00 8B 8D 0D 28 40 00 B8 25 28 40 00 01 E8
80 30 05 83 F9 00 74 71 81 7F 1C AB 00 00 00 75
62 8B 57 0C 03 95 09 28 40 00 31 C0 51 31 C9 66
B9 F7 00 66 83 F9 00 74 49 8B 57 0C 03 95 09 28
40 00 8B 85 11 28 40 00 83 F8 02 75 06 81 C2 00
02 00 00 51 8B 4F 10 83 F8 02 75 06 81 E9 00 02
00 00 57 BF C8 00 00 00 89 CE E8 27 00 00 00 89
C1 5F B8 25 28 40 00 01 E8 E8 24 00 00 00 59 49
EB B1 59 83 C7 28 49 EB 8A 8B 85 01 28 40 00 89
44 24 1C 61 FF E0 56 57 4F F7 D7 21 FE 89 F0 5F
5E C3 60 83 F0 05 40 90 48 83 F0 05 89 C6 89 D7
60 E8 0B 00 00 00 61 83 C7 08 83 E9 07 E2 F1 61
C3 57 8B 1F 8B 4F 04 68 B9 79 37 9E 5A 42 89 D0
48 C1 E0 05 BF 20 00 00 00 4A 89 DD C1 E5 04 29
E9 8B 6E 08 31 DD 29 E9 89 DD C1 ED 05 31 C5 29
E9 2B 4E 0C 89 CD C1 E5 04 29 EB 8B 2E 31 CD 29
EB 89 CD C1 ED 05 31 C5 29 EB 2B 5E 04 29 D0 4F
75 C8 5F 89 1F 89 4F 04 C3

Pohernah 1.0.3 - by Kas
354
60 E8 00 00 00 00 5D 81 ED 2A 27 40 00 31 C0 40
83 F0 06 40 3D 40 1F 00 00 75 07 BE 6A 27 40 00
EB 02 EB EB 8B 85 9E 28 40 00 83 F8 01 75 17 31
C0 01 EE 3D 99 00 00 00 74 0C 8B 8D 86 28 40 00
30 0E 40 46 EB ED ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 56
57 4F F7 D7 21 FE 89 F0 5F 5E C3 60 83 F0 05 40
90 48 83 F0 05 89 C6 89 D7 60 E8 0B 00 00 00 61
83 C7 08 83 E9 07 E2 F1 61 C3 57 8B 1F 8B 4F 04
68 B9 79 37 9E 5A 42 89 D0 48 C1 E0 05 BF 20 00
00 00 4A 89 DD C1 E5 04 29 E9 8B 6E 08 31 DD 29
E9 89 DD C1 ED 05 31 C5 29 E9 2B 4E 0C 89 CD C1
E5 04 29 EB 8B 2E 31 CD 29 EB 89 CD C1 ED 05 31
C5 29 EB 2B 5E 04 29 D0 4F 75 C8 5F 89 1F 89 4F
04 C3

PolyBox C -> Anskya
188
55 8B EC 83 C4 F0 53 56 B8 E4 41 00 10 E8 3A E1
FF FF 33 C0 55 68 11 44 00 10 64 FF 30 64 89 20
EB 08 FC FC FC FC FC FC 27 54 6A 0A 68 20 44 00
10 A1 1C 71 00 10 50 E8 CC E1 ?? ?? ?? ?? 85 DB
0F 84 77 01 00 00 53 A1 1C 71 00 10 50 E8 1E E2
FF FF 8B F0 85 F6 0F 84 61 01 00 00 53 A1 1C 71
00 10 50 E8 E0 E1 FF FF 85 C0 0F 84 4D 01 00 00
50 E8 DA E1 FF FF 8B D8 85 DB 0F 84 3D 01 00 00
56 B8 70 80 00 10 B9 01 00 00 00 8B 15 98 41 00
10 E8 9E DE FF FF 83 C4 04 A1 70 80 00 10 8B CE
8B D3 E8 E1 E1 FF FF 6A 00 6A 00 A1 70 80 00 10
B9 30 44 00 10 8B D6 E8 F8 FD FF FF

PolyBox D -> Anskya
135
55 8B EC 33 C9 51 51 51 51 51 53 33 C0 55 68 84
2C 40 00 64 FF 30 64 89 20 C6 45 FF 00 B8 B8 46
40 00 BA 24 00 00 00 E8 8C F3 FF FF 6A 24 BA B8
46 40 00 8B 0D B0 46 40 00 A1 94 46 40 00 E8 71
FB FF FF 84 C0 0F 84 6E 01 00 00 8B 1D D0 46 40
00 8B C3 83 C0 24 03 05 D8 46 40 00 3B 05 B4 46
40 00 0F 85 51 01 00 00 8D 45 F4 BA B8 46 40 00
B9 10 00 00 00 E8 A2 EC FF FF 8B 45 F4 BA 9C 2C
40 00 E8 F1 ED FF FF

PolyCrypt PE - 2.1.4b/2.1.5 -> JLab Software Creations (h-oep)
20
91 8B F4 AD FE C9 80 34 08 ?? E2 FA C3 60 E8 ED
FF FF FF EB

PolyCrypt PE - 2.1.4b/2.1.5 -> JLab Software Creations (h-signed)
49
50 6F 6C 79 43 72 79 70 74 20 50 45 20 28 63 29
20 32 30 30 34 2D 32 30 30 35 2C 20 4A 4C 61 62
53 6F 66 74 77 61 72 65 2E 00 50 00 43 00 50 00
45

PolyCryptor by SMT Version %v3.%v4
25
EB ?? 28 50 6F 6C 79 53 63 72 79 70 74 20 ?? ??
?? 20 62 79 20 53 4D 54 29

PolyEnE V0.01+ -> Lennart Hedlund
30
50 6F 6C 79 45 6E 45 00 4D 65 73 73 61 67 65 42
6F 78 41 00 55 53 45 52 33 32 2E 64 6C 6C

PoPa 0.01 (Packer on Pascal) -> bagie
169
55 8B EC 83 C4 EC 53 56 57 33 C0 89 45 EC B8 A4
3E 00 10 E8 30 F6 FF FF 33 C0 55 68 BE 40 00 10
?? ?? ?? ?? 89 20 6A 00 68 80 00 00 00 6A 03 6A
00 6A 01 68 00 00 00 80 8D 55 EC 33 C0 E8 62 E7
FF FF 8B 45 EC E8 32 F2 FF FF 50 E8 B4 F6 FF FF
A3 64 66 00 10 33 D2 55 68 93 40 00 10 64 FF 32
64 89 22 83 3D 64 66 00 10 FF 0F 84 3A 01 00 00
6A 00 6A 00 6A 00 A1 64 66 00 10 50 E8 9B F6 FF
FF 83 E8 10 50 A1 64 66 00 10 50 E8 BC F6 FF FF
6A 00 68 80 66 00 10 6A 10 68 68 66 00 10 A1 64
66 00 10 50 E8 8B F6 FF FF

PPC-PROTECT 1.1X -> Alexey Gorchakov
44
FF 5F 2D E9 20 00 9F E5 00 00 90 E5 18 00 8F E5
18 00 9F E5 00 00 90 E5 10 00 8F E5 01 00 A0 E3
00 00 00 EB 02 00 00 EA 04 F0 1F E5

PrincessSandy v1.0 eMiNENCE Process Patcher Patch
85
68 27 11 40 00 E8 3C 01 00 00 6A 00 E8 41 01 00
00 A3 00 20 40 00 8B 58 3C 03 D8 0F B7 43 14 0F
B7 4B 06 8D 7C 18 18 81 3F 2E 4C 4F 41 74 0B 83
C7 28 49 75 F2 E9 A7 00 00 00 8B 5F 0C 03 1D 00
20 40 00 89 1D 04 20 40 00 8B FB 83 C7 04 68 4C
20 40 00 68 08

Private EXE Protector 1.8
14
BB DC EE 0D 76 D9 D0 8D 16 85 D8 90 D9 D0

Private EXE Protector 1.8 -> SetiSoft
150
A4 B3 02 E8 6D 00 00 00 73 F6 31 C9 E8 64 00 00
00 73 1C 31 C0 E8 5B 00 00 00 73 23 B3 02 41 B0
10 E8 4F 00 00 00 10 C0 73 F7 75 3F AA EB D4 E8
4D 00 00 00 29 D9 75 10 E8 42 00 00 00 EB 28 AC
D1 E8 74 4D 11 C9 EB 1C 91 48 C1 E0 08 AC E8 2C
00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83
F8 7F 77 02 41 41 95 89 E8 B3 01 56 89 FE 29 C6
F3 A4 5E EB 8E 00 D2 75 05 8A 16 46 10 D2 C3 31
C9 41 E8 EE FF FF FF 11 C9 E8 E7 FF FF FF 72 F2
C3 31 FF 31 F6 C3

Private EXE Protector 1.9.7 -> SetiSoft
256
55 8B EC 83 C4 F4 FC 53 57 56 8B 74 24 20 8B 7C
24 24 66 81 3E 4A 43 0F 85 A5 02 00 00 83 C6 0A
33 DB BA 00 00 00 80 C7 44 24 14 08 00 00 00 43
8D A4 24 00 00 00 00 8B FF 03 D2 75 08 8B 16 83
C6 04 F9 13 D2 73 2C 8B 4C 24 10 33 C0 8D A4 24
00 00 00 00 05 00 00 00 00 03 D2 75 08 8B 16 83
C6 04 F9 13 D2 13 C0 49 75 EF 02 44 24 0C 88 07
47 EB C6 03 D2 75 08 8B 16 83 C6 04 F9 13 D2 0F
82 6E 01 00 00 03 D2 75 08 8B 16 83 C6 04 F9 13
D2 0F 83 DC 00 00 00 B9 04 00 00 00 33 C0 8D A4
24 00 00 00 00 8D 64 24 00 03 D2 75 08 8B 16 83
C6 04 F9 13 D2 13 C0 49 75 EF 48 74 B1 0F 89 EF
01 00 00 03 D2 75 08 8B 16 83 C6 04 F9 13 D2 73
42 BD 00 01 00 00 B9 08 00 00 00 33 C0 8D A4 24
00 00 00 00 05 00 00 00 00 03 D2 75 08 8B 16 83
C6 04 F9 13 D2 13 C0 49 75 EF 88 07 47 4D 75 D6

Private Exe Protector 1.x -> setisoft
26
B8 ?? ?? ?? ?? B9 ?? 90 01 ?? BE ?? 10 40 ?? 68
50 91 41 ?? 68 01 ?? ?? ?? C3

Private EXE Protector 2.0 -> SetiSoft
49
89 ?? ?? 38 00 00 00 8B ?? 00 00 00 00 81 ?? ??
?? ?? ?? 89 ?? 00 00 00 00 81 ?? 04 00 00 00 81
?? 04 00 00 00 81 ?? 00 00 00 00 0F 85 D6 FF FF
FF

Private exe Protector 2.0 -> SetiSoft Team
59
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 4B 45 52 4E 45 4C 33 32 2E 44 4C 4C
00 ?? ?? ?? ?? 00 00 00 00 00 00

Private exe Protector 2.15-2.2X -> SetiSoft Team
58
00 00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ??
?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 4B 45 52 4E 45 4C 33
32 2E 44 4C 4C 00 00 00 00 00

Private exe Protector V1.8 -> SetiSoft Team
54
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 4B 45 52 4E 45 4C 33 32 2E 44 4C 4C
00 ?? ?? ?? ?? 00 00 00 00 00 00 45 78 69 74 50
72 6F 63 65 73 73

Private EXE v2.0a
10
53 E8 00 00 00 00 5B 8B C3 2D

Private Personal Packer (PPP) 1.0.2 -> ConquestOfTroy.com
202
E8 17 00 00 00 E8 68 00 00 00 FF 35 2C 37 00 10
E8 ED 01 00 00 6A 00 E8 2E 04 00 00 E8 41 04 00
00 A3 74 37 00 10 6A 64 E8 5F 04 00 00 E8 30 04
00 00 A3 78 37 00 10 6A 64 E8 4E 04 00 00 E8 1F
04 00 00 A3 7C 37 00 10 A1 74 37 00 10 8B 1D 78
37 00 10 2B D8 8B 0D 7C 37 00 10 2B C8 83 FB 64
73 0F 81 F9 C8 00 00 00 73 07 6A 00 E8 D9 03 00
00 C3 6A 0A 6A 07 6A 00 E8 D3 03 00 00 A3 20 37
00 10 50 6A 00 E8 DE 03 00 00 A3 24 37 00 10 FF
35 20 37 00 10 6A 00 E8 EA 03 00 00 A3 30 37 00
10 FF 35 24 37 00 10 E8 C2 03 00 00 A3 28 37 00
10 8B 0D 30 37 00 10 8B 3D 28 37 00 10 EB 09 49
C0 04 39 55 80 34 39 24 0B C9

Private Personal Packer (PPP) 1.0.3 -> ConquestOfTroy.com
204
E8 19 00 00 00 90 90 E8 68 00 00 00 FF 35 2C 37
00 10 E8 ED 01 00 00 6A 00 E8 2E 04 00 00 E8 41
04 00 00 A3 74 37 00 10 6A 64 E8 5F 04 00 00 E8
30 04 00 00 A3 78 37 00 10 6A 64 E8 4E 04 00 00
E8 1F 04 00 00 A3 7C 37 00 10 A1 74 37 00 10 8B
1D 78 37 00 10 2B D8 8B 0D 7C 37 00 10 2B C8 83
FB 64 73 0F 81 F9 C8 00 00 00 73 07 6A 00 E8 D9
03 00 00 C3 6A 0A 6A 07 6A 00 E8 D3 03 00 00 A3
20 37 00 10 50 6A 00 E8 DE 03 00 00 A3 24 37 00
10 FF 35 20 37 00 10 6A 00 E8 EA 03 00 00 A3 30
37 00 10 FF 35 24 37 00 10 E8 C2 03 00 00 A3 28
37 00 10 8B 0D 30 37 00 10 8B 3D 28 37 00 10 EB
09 49 C0 04 39 55 80 34 39 24 0B C9

Private Personal Packer (PPP) v1.0.2 --> ConquestOfTroy.com
120
E8 17 00 00 00 E8 68 00 00 00 FF 35 2C 37 00 10
E8 ED 01 00 00 6A 00 E8 2E 04 00 00 E8 41 04 00
00 A3 74 37 00 10 6A 64 E8 5F 04 00 00 E8 30 04
00 00 A3 78 37 00 10 6A 64 E8 4E 04 00 00 E8 1F
04 00 00 A3 7C 37 00 10 A1 74 37 00 10 8B 1D 78
37 00 10 2B D8 8B 0D 7C 37 00 10 2B C8 83 FB 64
73 0F 81 F9 C8 00 00 00 73 07 6A 00 E8 D9 03 00
00 C3 6A 0A 6A 07 6A 00

PrivateEXE v2.0a
34
06 60 C8 ?? ?? ?? 0E 68 ?? ?? 9A ?? ?? ?? ?? 3D
?? ?? 0F ?? ?? ?? 50 50 0E 68 ?? ?? 9A ?? ?? ??
?? 0E

PrivateEXE v2.0a
22
53 E8 ?? ?? ?? ?? 5B 8B C3 2D ?? ?? ?? ?? 50 81
?? ?? ?? ?? ?? 8B

PRO-PACK v2.08
25
8C D3 8E C3 8C CA 8E DA 8B 0E ?? ?? 8B F1 83 ??
?? 8B FE D1 ?? FD F3 A5 53

PRO-PACK v2.08, emphasis on packed size, locked
21
83 EC ?? 8B EC BE ?? ?? FC E8 ?? ?? 05 ?? ?? 8B
C8 E8 ?? ?? 8B

ProActivate V1.0X -> TurboPower Software Company
165
55 8B EC B9 0E 00 00 00 6A 00 6A 00 49 75 F9 51
53 56 57 B8 ?? ?? ?? ?? 90 90 90 90 90 33 C0 55
68 ?? ?? ?? ?? 64 FF 30 64 89 20 A1 ?? ?? ?? ??
83 C0 05 A3 ?? ?? ?? ?? C7 05 ?? ?? ?? ?? 0D 00
00 00 E8 85 E2 FF FF 81 3D ?? ?? ?? ?? 21 7E 7E
40 75 7A 81 3D ?? ?? ?? ?? 43 52 43 33 75 6E 81
3D ?? ?? ?? ?? 32 40 7E 7E 75 62 81 3D ?? ?? ??
?? 21 7E 7E 40 75 56 81 3D ?? ?? ?? ?? 43 52 43
33 75 4A 81 3D ?? ?? ?? ?? 32 40 7E 7E 75 3E 81
3D ?? ?? ?? ?? 21 7E 7E 40 75 32 81 3D ?? ?? ??
?? 43 52 43 33

Program Protector XP v1.0
21
E8 ?? ?? ?? ?? 58 83 D8 05 89 C3 81 C3 ?? ?? ??
?? 8B 43 64 50

Protect Shareware V1.1 -> eCompserv CMS
85
53 00 74 00 72 00 69 00 6E 00 67 00 46 00 69 00
6C 00 65 00 49 00 6E 00 66 00 6F 00 00 00 ?? 01
00 00 01 00 30 00 34 00 30 00 39 00 30 00 34 00
42 00 30 00 00 00 34 00 ?? 00 01 00 43 00 6F 00
6D 00 70 00 61 00 6E 00 79 00 4E 00 61 00 6D 00
65 00 00 00 00

PROTECT! EXE/COM v6.0
15
1E B4 30 CD 21 3C 02 73 ?? CD 20 BE ?? ?? E8

Protection Plus vx.x
85
50 60 29 C0 64 FF 30 E8 ?? ?? ?? ?? 5D 83 ED 3C
89 E8 89 A5 14 ?? ?? ?? 2B 85 1C ?? ?? ?? 89 85
1C ?? ?? ?? 8D 85 27 03 ?? ?? 50 8B ?? 85 C0 0F
85 C0 ?? ?? ?? 8D BD 5B 03 ?? ?? 8D B5 43 03 ??
?? E8 DD ?? ?? ?? 89 85 1F 03 ?? ?? 6A 40 68 ??
10 ?? ?? 8B 85

pscrambler 1.2 -> by p0ke
428
55 8B EC B9 04 00 00 00 6A 00 6A 00 49 75 F9 51
53 ?? ?? ?? ?? 10 E8 2D F3 FF FF 33 C0 55 68 E8
31 00 10 64 FF 30 64 89 20 8D 45 E0 E8 53 F5 FF
FF 8B 45 E0 8D 55 E4 E8 30 F6 FF FF 8B 45 E4 8D
55 E8 E8 A9 F4 FF FF 8B 45 E8 8D 55 EC E8 EE F7
FF FF 8B 55 EC B8 C4 54 00 10 E8 D9 EC FF FF 83
3D C4 54 00 10 00 0F 84 05 01 00 00 80 3D A0 40
00 10 00 74 41 A1 C4 54 00 10 E8 D9 ED FF FF E8
48 E0 FF FF 8B D8 A1 C4 54 00 10 E8 C8 ED FF FF
50 B8 C4 54 00 10 E8 65 EF FF FF 8B D3 59 E8 69
E1 FF FF 8B C3 E8 12 FA FF FF 8B C3 E8 33 E0 FF
FF E9 AD 00 00 00 B8 05 01 00 00 E8 0C E0 FF FF
8B D8 53 68 05 01 00 00 E8 57 F3 FF FF 8D 45 DC
8B D3 E8 39 ED FF FF 8B 55 DC B8 14 56 00 10 B9
00 32 00 10 E8 BB ED FF FF 8B 15 14 56 00 10 B8
C8 54 00 10 E8 53 E5 FF FF BA 01 00 00 00 B8 C8
54 00 10 E8 8C E8 FF FF E8 DF E0 FF FF 85 C0 75
52 6A 00 A1 C4 54 00 10 E8 3B ED FF FF 50 B8 C4
54 00 10 E8 D8 EE FF FF 8B D0 B8 C8 54 00 10 59
E8 3B E6 FF FF E8 76 E0 FF FF B8 C8 54 00 10 E8
4C E6 FF FF E8 67 E0 FF FF 6A 00 6A 00 6A 00 A1
14 56 00 10 E8 53 EE FF FF 50 6A 00 6A 00 E8 41
F3 FF FF 80 3D 9C 40 00 10 00 74 05 E8 EF FB FF
FF 33 C0 5A 59 59 64 89 10 68 EF 31 00 10 8D 45
DC BA 05 00 00 00 E8 7D EB FF FF C3 E9 23 E9 FF
FF EB EB 5B E8 63 EA FF FF 00 00 00 FF FF FF FF
08 00 00 00 74 65 6D 70 2E 65 78 65

PUNiSHER v1.5 (DEMO) -> FEUERRADER/AHTeam
85
EB 04 83 A4 BC CE 60 EB 04 80 BC 04 11 E8 00 00
00 00 81 2C 24 CA C2 41 00 EB 04 64 6B 88 18 5D
E8 00 00 00 00 EB 04 64 6B 88 18 81 2C 24 86 00
00 00 EB 04 64 6B 88 18 8B 85 9C C2 41 00 EB 04
64 6B 88 18 29 04 24 EB 04 64 6B 88 18 EB 04 64
6B 88 18 8B 04

PUNiSHER v1.5 (DEMO) -> FEUERRADER/AHTeam
255
EB 04 83 A4 BC CE 60 EB 04 80 BC 04 11 E8 00 00
00 00 81 2C 24 CA C2 41 00 EB 04 64 6B 88 18 5D
E8 00 00 00 00 EB 04 64 6B 88 18 81 2C 24 86 00
00 00 EB 04 64 6B 88 18 8B 85 9C C2 41 00 EB 04
64 6B 88 18 29 04 24 EB 04 64 6B 88 18 EB 04 64
6B 88 18 8B 04 24 EB 04 64 6B 88 18 89 85 9C C2
41 00 EB 04 64 6B 88 18 58 68 9F 6F 56 B6 50 E8
5D 00 00 00 EB FF 71 78 C2 50 00 EB D3 5B F3 68
89 5C 24 48 5C 24 58 FF 8D 5C 24 58 5B 83 C3 4C
75 F4 5A 8D 71 78 75 09 81 F3 EB FF 52 BA 01 00
83 EB FC 4A FF 71 0F 75 19 8B 5C 24 00 00 81 33
50 53 8B 1B 0F FF C6 75 1B 81 F3 EB 87 1C 24 8B
8B 04 24 83 EC FC EB 01 E8 83 EC FC E9 E7 00 00
00 58 EB FF F0 EB FF C0 83 E8 FD EB FF 30 E8 C9
00 00 00 89 E0 EB FF D0 EB FF 71 0F 83 C0 01 EB
FF 70 F0 71 EE EB FA EB 83 C0 14 EB FF 70 ED

PUNiSHER V1.5 Demo-> FEUERRADER
18
EB 04 83 A4 BC CE 60 EB 04 80 BC 04 11 E8 00 00
00 00

PUNiSHER V1.5-> FEUERRADER
32
3F 00 00 80 66 20 ?? 00 7E 20 ?? 00 92 20 ?? 00
A4 20 ?? 00 00 00 00 00 4B 45 52 4E 45 4C 33 32

PuNkMoD 1.x -> PuNkDuDe
14
94 B9 ?? ?? 00 00 BC ?? ?? ?? ?? 80 34 0C

PureBasic 4.x -> Neil Hodgson
59
68 ?? ?? 00 00 68 00 00 00 00 68 ?? ?? ?? 00 E8
?? ?? ?? 00 83 C4 0C 68 00 00 00 00 E8 ?? ?? ??
00 A3 ?? ?? ?? 00 68 00 00 00 00 68 00 10 00 00
68 00 00 00 00 E8 ?? ?? ?? 00 A3

PureBasic 4.x DLL -> Neil Hodgson
76
83 7C 24 08 01 75 0E 8B 44 24 04 A3 ?? ?? ?? 10
E8 22 00 00 00 83 7C 24 08 02 75 00 83 7C 24 08
00 75 05 E8 ?? 00 00 00 83 7C 24 08 03 75 00 B8
01 00 00 00 C2 0C 00 68 00 00 00 00 68 00 10 00
00 68 00 00 00 00 E8 ?? 0F 00 00 A3

PureBasic DLL -> Neil Hodgson
17
83 7C 24 08 01 75 ?? 8B 44 24 04 A3 ?? ?? ?? 10
E8

QrYPt0r - by NuTraL
138
80 F9 00 0F 84 8D 01 00 00 8A C3 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 32 C1 3C
F3 75 89 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? BA D9 04 00 00 E8 00 00 00 00 5F
81 C7 16 01 00 00 80 2C 3A 01

QrYPt0r - by NuTraL
136
86 18 CC 64 FF 35 00 00 00 00 ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 64 89 25 00
00 00 00 BB 00 00 F7 BF ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? B8 78 56 34 12 87
03 E8 CD FE FF FF E8 B3

QrYPt0r - by NuTraL
80
EB 00 E8 B5 00 00 00 E9 2E 01 00 00 64 FF 35 00
00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 64 89 25 00 00 00 00 8B 44 24 04

R!SC's Process Patcher v1.4
85
E8 E1 01 00 00 80 38 22 75 13 80 38 00 74 2E 80
38 20 75 06 80 78 FF 22 74 18 40 EB ED 80 38 00
74 1B EB 19 40 80 78 FF 20 75 F9 80 38 00 74 0D
EB 0B 40 80 38 00 74 05 80 38 22 74 00 8B F8 B8
04 60 40 00 68 00 20 40 00 C7 05 A2 20 40 00 44
00 00 00 68 92

R!SC's Process Patcher v1.5.1
85
68 00 20 40 00 E8 C3 01 00 00 80 38 00 74 0D 66
81 78 FE 22 20 75 02 EB 03 40 EB EE 8B F8 B8 04
60 40 00 68 C4 20 40 00 68 D4 20 40 00 6A 00 6A
00 6A 04 6A 00 6A 00 6A 00 57 50 E8 9F 01 00 00
85 C0 0F 84 39 01 00 00 BE 00 60 40 00 8B 06 A3
28 21 40 00 83

RatPacker (Glue) stub
22
40 20 FF 00 00 00 00 00 00 00 ?? BE 00 60 40 00
8D BE 00 B0 FF FF

RAZOR 1911 encruptor
24
E8 ?? ?? BF ?? ?? 3B FC 72 ?? B4 4C CD 21 BE ??
?? B9 ?? ?? FD F3 A5 FC

RCryptor 1.5 -> Vaska
54
83 2C 24 4F 68 ?? ?? ?? ?? FF 54 24 04 83 44 24
04 4F B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74 06 80 30
?? ?? EB F3 B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74 06
80 30 ?? 40 EB F3

RCryptor 1.6c -> Vaska
57
8B C7 03 04 24 2B C7 80 38 50 0F 85 1B 8B 1F FF
68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74
06 80 30 ?? 40 EB F3 B8 ?? ?? ?? ?? 3D ?? ?? ??
?? 74 06 80 30 ?? 40 EB F3

RCryptor 2.0 -> Vaska
24
F7 D1 83 F1 FF 6A 00 F7 D1 83 F1 FF 81 04 24 ??
?? ?? ?? F7 D1 83 F1 FF

RCryptor v1.1 --> Vaska
13
8B 04 24 83 E8 4F 68 ?? ?? ?? ?? FF D0

RCryptor v1.1 --> Vaska
31
8B 04 24 83 E8 4F 68 ?? ?? ?? ?? FF D0 B8 ?? ??
?? ?? 3D ?? ?? ?? ?? 74 06 80 30 ?? 40 EB F3

RCryptor v1.3 / v1.4 --> Vaska
20
55 8B EC 8B 44 24 04 83 E8 4F 68 ?? ?? ?? ?? FF
D0 58 59 50

RCryptor v1.3 / v1.4 --> Vaska
38
55 8B EC 8B 44 24 04 83 E8 4F 68 ?? ?? ?? ?? FF
D0 58 59 50 B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74 06
80 30 ?? 40 EB F3

RCryptor v1.3b --> Vaska
12
61 83 EF 4F 60 68 ?? ?? ?? ?? FF D7

RCryptor v1.3b --> Vaska
30
61 83 EF 4F 60 68 ?? ?? ?? ?? FF D7 B8 ?? ?? ??
?? 3D ?? ?? ?? ?? 74 06 80 30 ?? 40 EB F3

RCryptor v1.5 (Private) --> Vaska
36
83 2C 24 4F 68 ?? ?? ?? ?? FF 54 24 04 83 44 24
04 4F B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74 06 80 30
?? 40 EB F3

RCryptor v1.5 --> Vaska
18
83 2C 24 4F 68 ?? ?? ?? ?? FF 54 24 04 83 44 24
04 4F

RCryptor v1.6 -> Vaska
9
33 D0 68 ?? ?? ?? ?? FF D2

RCryptor v1.6 -> Vaska
27
33 D0 68 ?? ?? ?? ?? FF D2 B8 ?? ?? ?? ?? 3D ??
?? ?? ?? 74 06 80 30 ?? 40 EB F3

RCryptor v1.6b / v1.6c --> Vaska
17
8B C7 03 04 24 2B C7 80 38 50 0F 85 1B 8B 1F FF
68

RCryptor v1.6b / v1.6c --> Vaska
39
8B C7 03 04 24 2B C7 80 38 50 0F 85 1B 8B 1F FF
68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 3D ?? ?? ?? ?? 74
06 80 30 ?? 40 EB F3

RCryptor v1.6d --> Vaska
17
60 90 61 61 80 7F F0 45 90 60 0F 85 1B 8B 1F FF
68

RCryptor v1.6d --> Vaska
40
60 90 61 61 80 7F F0 45 90 60 0F 85 1B 8B 1F FF
68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 90 3D ?? ?? ?? ??
74 06 80 30 ?? 40 EB F3

RCryptor V1.6d -> Vaska
59
60 90 61 61 80 7F F0 45 90 60 0F 85 1B 8B 1F FF
68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 90 3D ?? ?? ?? ??
74 06 80 30 ?? 40 EB F3 B8 ?? ?? ?? ?? 90 3D ??
?? ?? ?? 74 06 80 30 ?? 40 EB F3

RCryptor v1.6x --> Vaska
22
60 90 61 61 80 7F F0 45 90 60 0F 85 1B 8B 1F FF
68 ?? ?? ?? ?? C3

RCryptor v1.?? -> Vaska
20
90 58 90 50 90 8B 00 90 3C 50 90 58 0F 85 67 D6
EF 11 50 68

RCryptor v1.?? -> Vaska
42
90 58 90 50 90 8B 00 90 3C 50 90 58 0F 85 67 D6
EF 11 50 68 ?? ?? ?? ?? B8 ?? ?? ?? ?? 3D ?? ??
?? ?? 74 06 80 30 ?? 40 EB F3

RCryptor v2.0 (Hide EP) --> Vaska
35
F7 D1 83 F1 FF 6A 00 F7 D1 83 F1 FF 81 04 24 DC
20 ?? 00 F7 D1 83 F1 FF E8 00 00 00 00 F7 D1 83
F1 FF C3

RCryptor v2.0 --> Vaska
393
F7 D1 83 F1 FF 6A 00 F7 D1 83 F1 FF 81 04 24 ??
02 00 00 F7 D1 83 F1 FF 59 BA 32 21 ?? 00 F7 D1
83 F1 FF F7 D1 83 F1 FF 80 02 E3 F7 D1 83 F1 FF
C0 0A 05 F7 D1 83 F1 FF 80 02 6F F7 D1 83 F1 FF
80 32 A4 F7 D1 83 F1 FF 80 02 2D F7 D1 83 F1 FF
42 49 85 C9 75 CD 1C 4F 8D 5B FD 62 1E 1C 4F 8D
5B FD 4D 9D B9 ?? ?? ?? 1E 1C 4F 8D 5B FD 22 1C
4F 8D 5B FD 8E A2 B9 B9 E2 83 DB E2 E5 4D CD 1E
BF 60 AB 1F 4D DB 1E 1E 3D 1E 92 1B 8E DC 7D EC
A4 E2 4D E5 20 C6 CC B2 8E EC 2D 7D DC 1C 4F 8D
5B FD 83 56 8E E0 3A 7D D0 8E 9D 6E 7D D6 4D 25
06 C2 AB 20 CC 3A 4D 2D 9D 6B 0B 81 45 CC 18 4D
2D 1F A1 A1 6B C2 CC F7 E2 4D 2D 9E 8B 8B CC DE
2E 2D F7 1E AB 7D 45 92 30 8E E6 B9 7D D6 8E 9D
27 DA FD FD 1E 1E 8E DF B8 7D CF 8E A3 4D 7D DC
1C 4F 8D 5B FD 33 D7 1E 1E 1E A6 0B 41 A1 A6 42
61 6B 41 6B 4C 45 1E 21 F6 26 BC E2 62 1E 62 1E
62 1E 23 63 59 ?? 1E 62 1E 62 1E 33 D7 1E 1E 1E
85 6B C2 41 AB C2 9F 23 6B C2 41 A1 1E C0 FD F0
FD 30 20 33 9E 1E 1E 1E 85 A2 0B 8B C2 27 41 EB
A1 A2 C2 1E C0 FD F0 FD 30 62 1E 33 7E 1E 1E 1E
C6 2D 42 AB 9F 23 6B C2 41 A1 1E C0 FD F0 FD 30
C0 FD F0 8E 1D 1C 4F 8D 5B FD E0 00 33 5E 1E 1E
1E BF 0B EC C2 E6 42 A2 C2 45 1E C0 FD F0 FD 30
CE 36 CC F2 1C 4F 8D 5B FD

RE-Crypt v0.7x -> Crudd [RET] (h1)
85
60 E8 00 00 00 00 5D 81 ED F3 1D 40 00 B9 7B 09
00 00 8D BD 3B 1E 40 00 8B F7 61 60 E8 00 00 00
00 5D 55 81 04 24 0A 00 00 00 C3 8B F5 81 C5 ??
?? 00 00 89 6D 34 89 75 38 8B 7D 38 81 E7 00 FF
FF FF 81 C7 48 00 00 00 47 03 7D 60 8B 4D 5C 83
F9 00 7E 0F 8B

RE-Crypt v0.7x -> Crudd [RET] (h2)
73
60 E8 00 00 00 00 5D 55 81 04 24 0A 00 00 00 C3
8B F5 81 C5 ?? ?? 00 00 89 6D 34 89 75 38 8B 7D
38 81 E7 00 FF FF FF 81 C7 48 00 00 00 47 03 7D
60 8B 4D 5C 83 F9 00 7E 0F 8B 17 33 55 58 89 17
83 C7 04 83 C1 FC EB EC 8B

Reflexive Arcade Wrapper
85
55 8B EC 6A FF 68 98 68 42 00 68 14 FA 41 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 F8 50 42 00 33 D2 8A D4
89 15 3C E8 42 00 8B C8 81 E1 FF 00 00 00 89 0D
38 E8 42 00 C1 E1 08 03 CA 89 0D 34 E8 42 00 C1
E8 10 A3 30 E8

Reg2Exe 2.20/2.21 - by Jan Vorel
282
6A 00 E8 7D 12 00 00 A3 A0 44 40 00 E8 79 12 00
00 6A 0A 50 6A 00 FF 35 A0 44 40 00 E8 0F 00 00
00 50 E8 69 12 00 00 CC CC CC CC CC CC CC CC CC
68 2C 02 00 00 68 00 00 00 00 68 B0 44 40 00 E8
3A 12 00 00 83 C4 0C 8B 44 24 04 A3 B8 44 40 00
68 00 00 00 00 68 A0 0F 00 00 68 00 00 00 00 E8
32 12 00 00 A3 B0 44 40 00 68 F4 01 00 00 68 BC
44 40 00 FF 35 B8 44 40 00 E8 1E 12 00 00 B8 BC
44 40 00 89 C1 8A 30 40 80 FE 5C 75 02 89 C1 80
FE 00 75 F1 C6 01 00 E8 EC 18 00 00 E8 28 16 00
00 E8 4A 12 00 00 68 00 FA 00 00 68 08 00 00 00
FF 35 B0 44 40 00 E8 E7 11 00 00 A3 B4 44 40 00
8B 15 D4 46 40 00 E8 65 0A 00 00 BB 00 00 10 00
B8 01 00 00 00 E8 72 0A 00 00 74 09 C7 00 01 00
00 00 83 C0 04 A3 D4 46 40 00 FF 35 B4 44 40 00
E8 26 05 00 00 8D 0D B8 46 40 00 5A E8 CF 0F 00
00 FF 35 B4 44 40 00 FF 35 B8 46 40 00 E8 EE 06
00 00 8D 0D B4 46 40 00 5A E8

Reg2Exe 2.22/2.23 - by Jan Vorel
226
6A 00 E8 2F 1E 00 00 A3 C4 35 40 00 E8 2B 1E 00
00 6A 0A 50 6A 00 FF 35 C4 35 40 00 E8 07 00 00
00 50 E8 1B 1E 00 00 CC 68 48 00 00 00 68 00 00
00 00 68 C8 35 40 00 E8 76 16 00 00 83 C4 0C 8B
44 24 04 A3 CC 35 40 00 68 00 00 00 00 68 A0 0F
00 00 68 00 00 00 00 E8 EC 1D 00 00 A3 C8 35 40
00 E8 62 1D 00 00 E8 92 1A 00 00 E8 80 16 00 00
E8 13 14 00 00 68 01 00 00 00 68 08 36 40 00 68
00 00 00 00 8B 15 08 36 40 00 E8 71 3F 00 00 B8
00 00 10 00 BB 01 00 00 00 E8 82 3F 00 00 FF 35
48 31 40 00 B8 00 01 00 00 E8 0D 13 00 00 8D 0D
EC 35 40 00 5A E8 F2 13 00 00 68 00 01 00 00 FF
35 EC 35 40 00 E8 84 1D 00 00 A3 F4 35 40 00 FF
35 48 31 40 00 FF 35 F4 35 40 00 FF 35 EC 35 40
00 E8

Reg2Exe 2.24 - by Jan Vorel
240
6A 00 E8 CF 20 00 00 A3 F4 45 40 00 E8 CB 20 00
00 6A 0A 50 6A 00 FF 35 F4 45 40 00 E8 07 00 00
00 50 E8 BB 20 00 00 CC 68 48 00 00 00 68 00 00
00 00 68 F8 45 40 00 E8 06 19 00 00 83 C4 0C 8B
44 24 04 A3 FC 45 40 00 68 00 00 00 00 68 A0 0F
00 00 68 00 00 00 00 E8 8C 20 00 00 A3 F8 45 40
00 E8 02 20 00 00 E8 32 1D 00 00 E8 20 19 00 00
E8 A3 16 00 00 68 01 00 00 00 68 38 46 40 00 68
00 00 00 00 8B 15 38 46 40 00 E8 71 4F 00 00 B8
00 00 10 00 BB 01 00 00 00 E8 82 4F 00 00 FF 35
48 41 40 00 B8 00 01 00 00 E8 9D 15 00 00 8D 0D
1C 46 40 00 5A E8 82 16 00 00 68 00 01 00 00 FF
35 1C 46 40 00 E8 24 20 00 00 A3 24 46 40 00 FF
35 48 41 40 00 FF 35 24 46 40 00 FF 35 1C 46 40
00 E8 DC 10 00 00 8D 0D 14 46 40 00 5A E8 4A 16

Reg2Exe 2.25 - by Jan Vorel
220
68 68 00 00 00 68 00 00 00 00 68 70 7D 40 00 E8
AE 20 00 00 83 C4 0C 68 00 00 00 00 E8 AF 52 00
00 A3 74 7D 40 00 68 00 00 00 00 68 00 10 00 00
68 00 00 00 00 E8 9C 52 00 00 A3 70 7D 40 00 E8
24 50 00 00 E8 E2 48 00 00 E8 44 34 00 00 E8 54
28 00 00 E8 98 27 00 00 E8 93 20 00 00 68 01 00
00 00 68 D0 7D 40 00 68 00 00 00 00 8B 15 D0 7D
40 00 E8 89 8F 00 00 B8 00 00 10 00 68 01 00 00
00 E8 9A 8F 00 00 FF 35 A4 7F 40 00 68 00 01 00
00 E8 3A 23 00 00 8D 0D A8 7D 40 00 5A E8 5E 1F
00 00 FF 35 A8 7D 40 00 68 00 01 00 00 E8 2A 52
00 00 A3 B4 7D 40 00 FF 35 A4 7F 40 00 FF 35 B4
7D 40 00 FF 35 A8 7D 40 00 E8 5C 0C 00 00 8D 0D
A0 7D 40 00 5A E8 26 1F 00 00 FF 35

ReversingLabsProtector 0.7.4 beta -> Ap0x
12
68 00 00 41 00 E8 01 00 00 00 C3 C3

RJcrush v1.00
33
06 FC 8C C8 BA ?? ?? 03 D0 52 BA ?? ?? 52 BA ??
?? 03 C2 8B D8 05 ?? ?? 8E DB 8E C0 33 F6 33 FF
B9

RJoiner 1.2 by Vaska (25.03.2007 16:58)
64
55 8B EC 81 EC 0C 02 00 00 8D 85 F4 FD FF FF 56
50 68 04 01 00 00 FF 15 14 10 40 00 90 8D 85 F4
FD FF FF 50 FF 15 10 10 40 00 90 BE 00 20 40 00
90 83 3E FF 0F 84 84 00 00 00 53 57 33 FF 8D 46

RJoiner 1.2a -> Vaska
196
55 8B EC 81 EC 0C 01 00 00 8D 85 F4 FE FF FF 56
50 68 04 01 00 00 FF 15 0C 10 40 00 94 90 94 8D
85 F4 FE FF FF 50 FF 15 08 10 40 00 94 90 94 BE
00 20 40 00 94 90 94 83 3E FF 74 7D 53 57 33 DB
8D 7E 04 94 90 94 53 68 80 00 00 00 6A 02 53 6A
01 68 00 00 00 C0 57 FF 15 04 10 40 00 89 45 F8
94 90 94 8B 06 8D 74 06 04 94 90 94 8D 45 FC 53
50 8D 46 04 FF 36 50 FF 75 F8 FF 15 00 10 40 00
94 90 94 FF 75 F8 FF 15 10 10 40 00 94 90 94 8D
85 F4 FE FF FF 6A 0A 50 53 57 68 20 10 40 00 53
FF 15 18 10 40 00 94 90 94 8B 06 8D 74 06 04 94
90 94 83 3E FF 75 89 5F 5B 33 C0 5E C9 C2 10 00
CC CC 24 11

RJoiner by Vaska (Sign from pinch 25.03.2007 17:00)
64
E8 03 FD FF FF 6A 00 E8 0C 00 00 00 FF 25 6C 10
40 00 FF 25 70 10 40 00 FF 25 74 10 40 00 FF 25
78 10 40 00 FF 25 7C 10 40 00 FF 25 80 10 40 00
FF 25 84 10 40 00 FF 25 88 10 40 00 FF 25 8C 10

RLP V0.7.3.beta -> ap0x
40
2E 72 6C 70 00 00 00 00 00 50 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00
00 00 00 00 20 00 00 E0

RLP v0.7.3beta -> ap0x
85
60 8B DD E8 00 00 00 00 5D 95 32 C0 95 89 9D 80
00 00 00 B8 42 31 40 00 BB 41 30 40 00 2B C3 03
C5 33 D2 8A 10 40 B9 ?? ?? 00 00 8B F9 30 10 8A
10 40 49 75 F8 64 EF 86 3D 30 00 00 0F B9 FF 4B
89 52 5C 4C BD 77 C2 0C CE 88 4E 2D E8 00 00 00
5D 0D DB 5E 56

RLPack --> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 2C 0A
00 00 8D 9D 22 02 00 00 33 FF E8 83 01 00 00 6A
40 68 00 10 00 00 68 00 20 0C 00 6A 00 FF 95 CD
09 00 00 89 85 14 0A 00 00 EB 14 60 FF B5 14 0A

RLPack --> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 5A 0A
00 00 8D 9D 40 02 00 00 33 FF E8 83 01 00 00 6A
40 68 00 10 00 00 68 00 20 0C 00 6A 00 FF 95 EB
09 00 00 89 85 3A 0A 00 00 EB 14 60 FF B5 3A 0A

RLPack --> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 EB 03 0C 00
00 EB 03 0C 00 00 8D B5 CB 22 00 00 8D 9D F0 02
00 00 33 FF E8 47 02 00 00 EB 03 15 00 00 6A 40
68 00 10 00 00 68 00 20 0C 00 6A 00 FF 95 9B 0A

RLPack -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 2C 0A
00 00 8D 9D 22 02 00 00 33 FF E8 ?? ?? ?? ?? 6A
40 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00 FF 95 CD
09 00 00 89 85 ?? ?? ?? ?? EB 14 60 FF B5 14 0A

RLPack -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 5A 0A
00 00 8D 9D 40 02 00 00 33 FF E8 ?? ?? ?? ?? 6A
40 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00 FF 95 EB
09 00 00 89 85 ?? ?? ?? ?? EB 14 60 FF B5 3A 0A

RLPack -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 EB 03 ?? ??
?? EB 03 ?? ?? ?? 8D B5 CB 22 00 00 8D 9D F0 02
00 00 33 FF E8 ?? ?? ?? ?? EB 03 ?? ?? ?? 6A 40
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00 FF 95 9B 0A

RLPack 1.0 beta -> ap0x
85
60 E8 00 00 00 00 8D 64 24 04 8B 6C 24 FC 8D B5
4C 02 00 00 8D 9D 13 01 00 00 33 FF EB 0F FF 74
37 04 FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37
00 75 EB 8D 74 37 04 53 6A 40 68 00 10 00 00 68
?? ?? ?? ?? 6A 00 FF 95 F9 01 00 00 89 85 48 02
00 00 5B FF B5

RLPack 1.0 beta -> ap0x
288
60 E8 00 00 00 00 8D 64 24 04 8B 6C 24 FC 8D B5
4C 02 00 00 8D 9D 13 01 00 00 33 FF EB 0F FF 74
37 04 FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37
00 75 EB 8D 74 37 04 53 6A 40 68 00 10 00 00 68
?? ?? ?? ?? 6A 00 FF 95 F9 01 00 00 89 85 48 02
00 00 5B FF B5 48 02 00 00 56 FF D3 83 C4 08 8B
B5 48 02 00 00 8B C6 EB 01 40 80 38 01 75 FA 40
8B 38 83 C0 04 89 85 44 02 00 00 EB 7A 56 FF 95
F1 01 00 00 89 85 40 02 00 00 8B C6 EB 4F 8B 85
44 02 00 00 8B 00 A9 00 00 00 80 74 14 35 00 00
00 80 50 8B 85 44 02 00 00 C7 00 20 20 20 00 EB
06 FF B5 44 02 00 00 FF B5 40 02 00 00 FF 95 F5
01 00 00 89 07 83 C7 04 8B 85 44 02 00 00 EB 01
40 80 38 00 75 FA 40 89 85 44 02 00 00 80 38 00
75 AC EB 01 46 80 3E 00 75 FA 46 40 8B 38 83 C0
04 89 85 44 02 00 00 80 3E 01 75 81 68 00 40 00
00 68 ?? ?? ?? ?? FF B5 48 02 00 00 FF 95 FD 01
00 00 61 68 ?? ?? ?? ?? C3 60 8B 74 24 24 8B 7C

RLPack 1.1 BasicEdition -> ap0x
62
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 4A 02
00 00 8D 9D 11 01 00 00 33 FF EB 0F FF 74 37 04
FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75
EB 8D 74 37 04 53 6A 40 68 00 10 00 00 68

RLPack 1.18 (aPlib 0.43) -> ap0x
131
60 E8 00 00 00 00 8B 2C 24 83 C4 ?? 8D B5 1A 04
00 00 8D 9D C1 02 00 00 33 FF E8 61 01 00 00 EB
0F FF 74 37 04 FF 34 37 FF D3 83 C4 ?? 83 C7 ??
83 3C 37 00 75 EB 83 BD 06 04 00 00 00 74 0E 83
BD 0A 04 00 00 00 74 05 E8 D7 01 00 00 8D 74 37
04 53 6A ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00
FF 95 A7 03 00 00 89 85 16 04 00 00 5B FF B5 16
04 00 00 56 FF D3 83 C4 ?? 8B B5 16 04 00 00 8B
C6 EB 01

RLPack 1.18 (LZMA 4.30) -> ap0x
167
60 E8 00 00 00 00 8B 2C 24 83 C4 ?? 8D B5 21 0B
00 00 8D 9D FF 02 00 00 33 FF E8 9F 01 00 00 6A
?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00 FF 95 AA
0A 00 00 89 85 F9 0A 00 00 EB 14 60 FF B5 F9 0A
00 00 FF 34 37 FF 74 37 04 FF D3 61 83 C7 ?? 83
3C 37 00 75 E6 83 BD 0D 0B 00 00 00 74 0E 83 BD
11 0B 00 00 00 74 05 E8 F6 01 00 00 8D 74 37 04
53 6A ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A 00 FF
95 AA 0A 00 00 89 85 1D 0B 00 00 5B 60 FF B5 F9
0A 00 00 56 FF B5 1D 0B 00 00 FF D3 61 8B B5 1D
0B 00 00 8B C6 EB 01

RLPack 1.18 Dll (aPlib 0.43) -> ap0x
142
80 7C 24 08 01 0F 85 5C 01 00 00 60 E8 00 00 00
00 8B 2C 24 83 C4 ?? 8D B5 1A 04 00 00 8D 9D C1
02 00 00 33 FF E8 61 01 00 00 EB 0F FF 74 37 04
FF 34 37 FF D3 83 C4 ?? 83 C7 ?? 83 3C 37 00 75
EB 83 BD 06 04 00 00 00 74 0E 83 BD 0A 04 00 00
00 74 05 E8 D7 01 00 00 8D 74 37 04 53 6A ?? 68
?? ?? ?? ?? 68 ?? ?? ?? ?? 6A ?? FF 95 A7 03 00
00 89 85 16 04 00 00 5B FF B5 16 04 00 00 56 FF
D3 83 C4 ?? 8B B5 16 04 00 00 8B C6 EB 01

RLPack 1.18 Dll (LZMA 4.30) -> ap0x
178
80 7C 24 08 01 0F 85 ?? 01 00 00 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 ?? ?? ?? ?? 8D 9D ??
?? ?? ?? 33 FF E8 9F 01 00 00 6A ?? 68 ?? ?? ??
?? 68 ?? ?? ?? ?? 6A ?? FF 95 AA 0A 00 00 89 85
F9 0A 00 00 EB 14 60 FF B5 F9 0A 00 00 FF 34 37
FF 74 37 04 FF D3 61 83 C7 08 83 3C 37 00 75 E6
83 BD 0D 0B 00 00 00 74 0E 83 BD 11 0B 00 00 00
74 05 E8 F6 01 00 00 8D 74 37 04 53 6A ?? 68 ??
?? ?? ?? 68 ?? ?? ?? ?? 6A ?? FF 95 AA 0A 00 00
89 85 1D 0B 00 00 5B 60 FF B5 F9 0A 00 00 56 FF
B5 1D 0B 00 00 FF D3 61 8B B5 1D 0B 00 00 8B C6
EB 01

RLPack 1.20 Basic Edition [aPLib] -> Ap0x
120
60 E8 00 00 00 00 8B 2C 24 83 C4 04 83 7C 24 28
01 75 0C 8B 44 24 24 89 85 92 05 00 00 EB 0C 8B
85 8E 05 00 00 89 85 92 05 00 00 8D B5 BA 05 00
00 8D 9D 41 04 00 00 33 FF E8 38 01 00 00 EB 1B
8B 85 92 05 00 00 FF 74 37 04 01 04 24 FF 34 37
01 04 24 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75
DF 83 BD 9E 05 00 00 00 74 0E 83 BD A2 05 00 00
00 74 05 E8 D6 01 00 00

RLPack 1.20 Basic Edition [LZMA] -> Ap0x
120
60 E8 00 00 00 00 8B 2C 24 83 C4 04 83 7C 24 28
01 75 0C 8B 44 24 24 89 85 9C 0C 00 00 EB 0C 8B
85 98 0C 00 00 89 85 9C 0C 00 00 8D B5 C4 0C 00
00 8D 9D 82 04 00 00 33 FF 6A 40 68 00 10 00 00
68 00 20 0C 00 6A 00 FF 95 2D 0C 00 00 89 85 94
0C 00 00 E8 59 01 00 00 EB 20 60 8B 85 9C 0C 00
00 FF B5 94 0C 00 00 FF 34 37 01 04 24 FF 74 37
04 01 04 24 FF D3 61 83

RLPack Full Edition 1.17 -> Ap0x
41
60 E8 00 00 00 00 8B 2C 24 83 C4 04 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8D B5 ?? ?? ??
?? 8D 9D ?? ?? ?? ?? 33 FF

RLPack Full Edition 1.17 DLL -> Ap0x
38
80 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 ?? ?? ?? ?? 8D 9D ??
?? ?? ?? 33 FF E8

RLPack Full Edition 1.17 DLL [aPLib] -> Ap0x
64
80 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 53 03 00 00 8D 9D 02
02 00 00 33 FF E8 ?? ?? ?? ?? EB 0F FF 74 37 04
FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75

RLPack Full Edition 1.17 DLL [LZMA] -> Ap0x
64
80 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 5A 0A 00 00 8D 9D 40
02 00 00 33 FF E8 ?? ?? ?? ?? 6A 40 68 ?? ?? ??
?? 68 ?? ?? ?? ?? 6A 00 FF 95 EB 09 00 00 89 85

RLPack Full Edition 1.17 iBox [aPLib] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8D B5 79 29 00
00 8D 9D 2C 03 00 00 33 FF ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? EB 0F FF 74 37 04 FF 34

RLPack Full Edition 1.17 iBox [LZMA] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8D B5 67 30 00
00 8D 9D 66 03 00 00 33 FF ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 6A 40 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A

RLPack Full Edition 1.17 [aPLib] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8D B5 74 1F 00
00 8D 9D 1E 03 00 00 33 FF ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? EB 0F FF 74 37 04 FF 34

RLPack Full Edition 1.17 [LZMA] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8D B5 73 26 00
00 8D 9D 58 03 00 00 33 FF ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 6A 40 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A

RLPack Full Edition V1.1X -> ap0x
176
00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 6B 65 72 6E 65 6C 33 32
2E 64 6C 6C 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73 00
00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 00 56
69 72 74 75 61 6C 46 72 65 65 00 00 56 69 72 74
75 61 6C 50 72 6F 74 65 63 74 00 00 47 65 74 4D
6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00 00 10

RLPack V1.0.beta -> ap0x
51
60 E8 00 00 00 00 8D 64 24 04 8B 6C 24 FC 8D B5
4C 02 00 00 8D 9D 13 01 00 00 33 FF EB 0F FF 74
37 04 FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37
00 75 EB

RLPack V1.11 -> ap0x
49
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 4A 02
00 00 8D 9D 11 01 00 00 33 FF EB 0F FF 74 37 04
FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75
EB

RLPack V1.12-V1.14 (aPlib 0.43) -> ap0x
49
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 ?? ??
?? ?? 8D 9D ?? ?? ?? ?? 33 FF EB 0F FF ?? ?? ??
FF ?? ?? ?? D3 83 C4 ?? 83 C7 ?? 83 3C 37 00 75
EB

RLPack V1.12-V1.14 (LZMA 4.30) -> ap0x
55
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 ?? ??
?? ?? 8D 9D ?? ?? ?? ?? 33 FF 6A ?? 68 ?? ?? ??
?? 68 ?? ?? ?? ?? 6A ?? FF 95 ?? ?? ?? ?? 89 85
?? ?? ?? ?? EB ?? 60

RLPack V1.15-V1.17 (aPlib 0.43) -> ap0x
54
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 ?? ??
?? ?? 8D 9D ?? ?? ?? ?? 33 FF E8 45 01 00 00 EB
0F FF 74 37 04 FF 34 37 FF D3 83 C4 08 83 C7 08
83 3C 37 00 75 EB

RLPack V1.15-V1.17 (LZMA 4.30) -> ap0x
59
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 ?? ??
?? ?? 8D 9D ?? ?? ?? ?? 33 FF E8 83 01 00 00 6A
?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6A ?? FF 95 ??
?? ?? ?? 89 85 ?? ?? ?? ?? EB 14

RLPack V1.15-V1.17 Dll -> ap0x
38
80 7C 24 08 01 0F 85 ?? 01 00 00 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 ?? ?? ?? ?? 8D 9D ??
?? ?? ?? 33 FF E8

RLPack v1.18 Basic DLL [aPLib] -> Ap0x
75
80 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 1A 04 00 00 8D 9D C1
02 00 00 33 FF E8 61 01 00 00 EB 0F FF 74 37 04
FF 34 37 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75
EB 83 BD 06 04 00 00 00 74 0E 83

RLPack v1.18 Basic DLL [LZMA] -> Ap0x
75
80 7C 24 08 01 0F 85 ?? ?? ?? ?? 60 E8 00 00 00
00 8B 2C 24 83 C4 04 8D B5 21 0B 00 00 8D 9D FF
02 00 00 33 FF E8 9F 01 00 00 6A 40 68 00 10 00
00 68 00 20 0C 00 6A 00 FF 95 AA 0A 00 00 89 85
F9 0A 00 00 EB 14 60 FF B5 F9 0A

RLPack v1.18 Basic [aPLib] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 1A 04
00 00 8D 9D C1 02 00 00 33 FF E8 61 01 00 00 EB
0F FF 74 37 04 FF 34 37 FF D3 83 C4 08 83 C7 08
83 3C 37 00 75 EB 83 BD 06 04 00 00 00 74 0E 83

RLPack v1.18 Basic [LZMA] -> Ap0x
64
60 E8 00 00 00 00 8B 2C 24 83 C4 04 8D B5 21 0B
00 00 8D 9D FF 02 00 00 33 FF E8 9F 01 00 00 6A
40 68 00 10 00 00 68 00 20 0C 00 6A 00 FF 95 AA
0A 00 00 89 85 F9 0A 00 00 EB 14 60 FF B5 F9 0A

RLPack V1.19 (aPlib 0.43) -> ap0x
400
60 E8 00 00 00 00 8B 2C 24 83 C4 04 83 7C 24 28
01 75 0C 8B 44 24 24 89 85 3C 04 00 00 EB 0C 8B
85 38 04 00 00 89 85 3C 04 00 00 8D B5 60 04 00
00 8D 9D EB 02 00 00 33 FF E8 52 01 00 00 EB 1B
8B 85 3C 04 00 00 FF 74 37 04 01 04 24 FF 34 37
01 04 24 FF D3 83 C4 08 83 C7 08 83 3C 37 00 75
DF 83 BD 48 04 00 00 00 74 0E 83 BD 4C 04 00 00
00 74 05 E8 B8 01 00 00 8D 74 37 04 53 6A 40 68
00 10 00 00 68 ?? ?? ?? ?? 6A 00 FF 95 D1 03 00
00 89 85 5C 04 00 00 5B FF B5 5C 04 00 00 56 FF
D3 83 C4 08 8B B5 5C 04 00 00 8B C6 EB 01 40 80
38 01 75 FA 40 8B 38 03 BD 3C 04 00 00 83 C0 04
89 85 58 04 00 00 E9 94 00 00 00 56 FF 95 C9 03
00 00 85 C0 0F 84 B4 00 00 00 89 85 54 04 00 00
8B C6 EB 5B 8B 85 58 04 00 00 8B 00 A9 00 00 00
80 74 14 35 00 00 00 80 50 8B 85 58 04 00 00 C7
00 20 20 20 00 EB 06 FF B5 58 04 00 00 FF B5 54
04 00 00 FF 95 CD 03 00 00 85 C0 74 71 89 07 83
C7 04 8B 85 58 04 00 00 EB 01 40 80 38 00 75 FA
40 89 85 58 04 00 00 66 81 78 02 00 80 74 A5 80
38 00 75 A0 EB 01 46 80 3E 00 75 FA 46 40 8B 38
03 BD 3C 04 00 00 83 C0 04 89 85 58 04 00 00 80
3E 01 0F 85 63 FF FF FF 68 00 40 00 00 68 ?? ??
?? ?? FF B5 5C 04 00 00 FF 95 D5 03 00 00 E8 3D
00 00 00 E8 24 01 00 00 61 E9 ?? ?? ?? ?? 61 C3

RLPack V1.19 (LZMA 4.30) -> ap0x
462
60 E8 00 00 00 00 8B 2C 24 83 C4 04 83 7C 24 28
01 75 0C 8B 44 24 24 89 85 49 0B 00 00 EB 0C 8B
85 45 0B 00 00 89 85 49 0B 00 00 8D B5 6D 0B 00
00 8D 9D 2F 03 00 00 33 FF 6A 40 68 00 10 00 00
68 00 20 0C 00 6A 00 FF 95 DA 0A 00 00 89 85 41
0B 00 00 E8 76 01 00 00 EB 20 60 8B 85 49 0B 00
00 FF B5 41 0B 00 00 FF 34 37 01 04 24 FF 74 37
04 01 04 24 FF D3 61 83 C7 08 83 3C 37 00 75 DA
83 BD 55 0B 00 00 00 74 0E 83 BD 59 0B 00 00 00
74 05 E8 D7 01 00 00 8D 74 37 04 53 6A 40 68 00
10 00 00 68 ?? ?? ?? ?? 6A 00 FF 95 DA 0A 00 00
89 85 69 0B 00 00 5B 60 FF B5 41 0B 00 00 56 FF
B5 69 0B 00 00 FF D3 61 8B B5 69 0B 00 00 8B C6
EB 01 40 80 38 01 75 FA 40 8B 38 03 BD 49 0B 00
00 83 C0 04 89 85 65 0B 00 00 E9 98 00 00 00 56
FF 95 D2 0A 00 00 89 85 61 0B 00 00 85 C0 0F 84
C8 00 00 00 8B C6 EB 5F 8B 85 65 0B 00 00 8B 00
A9 00 00 00 80 74 14 35 00 00 00 80 50 8B 85 65
0B 00 00 C7 00 20 20 20 00 EB 06 FF B5 65 0B 00
00 FF B5 61 0B 00 00 FF 95 D6 0A 00 00 85 C0 0F
84 87 00 00 00 89 07 83 C7 04 8B 85 65 0B 00 00
EB 01 40 80 38 00 75 FA 40 89 85 65 0B 00 00 66
81 78 02 00 80 74 A1 80 38 00 75 9C EB 01 46 80
3E 00 75 FA 46 40 8B 38 03 BD 49 0B 00 00 83 C0
04 89 85 65 0B 00 00 80 3E 01 0F 85 5F FF FF FF
68 00 40 00 00 68 ?? ?? ?? ?? FF B5 69 0B 00 00
FF 95 DE 0A 00 00 68 00 40 00 00 68 00 20 0C 00
FF B5 41 0B 00 00 FF 95 DE 0A 00 00 E8 3D 00 00
00 E8 24 01 00 00 61 E9 ?? ?? ?? ?? 61 C3

RLPack V1.19 Dll (aPlib 0.43) -> ap0x
411
80 7C 24 08 01 0F 85 89 01 00 00 60 E8 00 00 00
00 8B 2C 24 83 C4 04 83 7C 24 28 01 75 0C 8B 44
24 24 89 85 3C 04 00 00 EB 0C 8B 85 38 04 00 00
89 85 3C 04 00 00 8D B5 60 04 00 00 8D 9D EB 02
00 00 33 FF E8 52 01 00 00 EB 1B 8B 85 3C 04 00
00 FF 74 37 04 01 04 24 FF 34 37 01 04 24 FF D3
83 C4 08 83 C7 08 83 3C 37 00 75 DF 83 BD 48 04
00 00 00 74 0E 83 BD 4C 04 00 00 00 74 05 E8 B8
01 00 00 8D 74 37 04 53 6A 40 68 00 10 00 00 68
?? ?? ?? ?? 6A 00 FF 95 D1 03 00 00 89 85 5C 04
00 00 5B FF B5 5C 04 00 00 56 FF D3 83 C4 08 8B
B5 5C 04 00 00 8B C6 EB 01 40 80 38 01 75 FA 40
8B 38 03 BD 3C 04 00 00 83 C0 04 89 85 58 04 00
00 E9 94 00 00 00 56 FF 95 C9 03 00 00 85 C0 0F
84 B4 00 00 00 89 85 54 04 00 00 8B C6 EB 5B 8B
85 58 04 00 00 8B 00 A9 00 00 00 80 74 14 35 00
00 00 80 50 8B 85 58 04 00 00 C7 00 20 20 20 00
EB 06 FF B5 58 04 00 00 FF B5 54 04 00 00 FF 95
CD 03 00 00 85 C0 74 71 89 07 83 C7 04 8B 85 58
04 00 00 EB 01 40 80 38 00 75 FA 40 89 85 58 04
00 00 66 81 78 02 00 80 74 A5 80 38 00 75 A0 EB
01 46 80 3E 00 75 FA 46 40 8B 38 03 BD 3C 04 00
00 83 C0 04 89 85 58 04 00 00 80 3E 01 0F 85 63
FF FF FF 68 00 40 00 00 68 ?? ?? ?? ?? FF B5 5C
04 00 00 FF 95 D5 03 00 00 E8 3D 00 00 00 E8 24
01 00 00 61 E9 ?? ?? ?? ?? 61 C3

RLPack V1.19 Dll (LZMA 4.30) -> ap0x
473
80 7C 24 08 01 0F 85 C7 01 00 00 60 E8 00 00 00
00 8B 2C 24 83 C4 04 83 7C 24 28 01 75 0C 8B 44
24 24 89 85 49 0B 00 00 EB 0C 8B 85 45 0B 00 00
89 85 49 0B 00 00 8D B5 6D 0B 00 00 8D 9D 2F 03
00 00 33 FF 6A 40 68 00 10 00 00 68 00 20 0C 00
6A 00 FF 95 DA 0A 00 00 89 85 41 0B 00 00 E8 76
01 00 00 EB 20 60 8B 85 49 0B 00 00 FF B5 41 0B
00 00 FF 34 37 01 04 24 FF 74 37 04 01 04 24 FF
D3 61 83 C7 08 83 3C 37 00 75 DA 83 BD 55 0B 00
00 00 74 0E 83 BD 59 0B 00 00 00 74 05 E8 D7 01
00 00 8D 74 37 04 53 6A 40 68 00 10 00 00 68 ??
?? ?? ?? 6A 00 FF 95 DA 0A 00 00 89 85 69 0B 00
00 5B 60 FF B5 41 0B 00 00 56 FF B5 69 0B 00 00
FF D3 61 8B B5 69 0B 00 00 8B C6 EB 01 40 80 38
01 75 FA 40 8B 38 03 BD 49 0B 00 00 83 C0 04 89
85 65 0B 00 00 E9 98 00 00 00 56 FF 95 D2 0A 00
00 89 85 61 0B 00 00 85 C0 0F 84 C8 00 00 00 8B
C6 EB 5F 8B 85 65 0B 00 00 8B 00 A9 00 00 00 80
74 14 35 00 00 00 80 50 8B 85 65 0B 00 00 C7 00
20 20 20 00 EB 06 FF B5 65 0B 00 00 FF B5 61 0B
00 00 FF 95 D6 0A 00 00 85 C0 0F 84 87 00 00 00
89 07 83 C7 04 8B 85 65 0B 00 00 EB 01 40 80 38
00 75 FA 40 89 85 65 0B 00 00 66 81 78 02 00 80
74 A1 80 38 00 75 9C EB 01 46 80 3E 00 75 FA 46
40 8B 38 03 BD 49 0B 00 00 83 C0 04 89 85 65 0B
00 00 80 3E 01 0F 85 5F FF FF FF 68 00 40 00 00
68 ?? ?? ?? ?? FF B5 69 0B 00 00 FF 95 DE 0A 00
00 68 00 40 00 00 68 00 20 0C 00 FF B5 41 0B 00
00 FF 95 DE 0A 00 00 E8 3D 00 00 00 E8 24 01 00
00 61 E9 ?? ?? ?? ?? 61 C3

ROD High TECH -> Ayman
20
60 8B 15 1D 13 40 00 F7 E0 8D 82 83 19 00 00 E8
58 0C 00 00

RosAsm 2050a -> Betov
70
55 8B EC 60 8B 5D 08 B9 08 00 00 00 BF ?? ?? ??
?? 83 C7 07 FD 8A C3 24 0F 04 30 3C 39 76 02 04
07 AA C1 EB 04 E2 EE FC 68 00 10 00 00 68 ?? ??
?? ?? 68 ?? ?? ?? ?? 6A 00 FF 15 ?? ?? ?? ?? 61
8B E5 5D C2 04 00

Rpoly crypt by Vaska (20.03.07 18:41)
66
58 ?? ?? ?? ?? ?? ?? ?? E8 00 00 00 58 E8 00 ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 ??
?? 04

RPolyCrypt v 1.0 (personal polycryptor) sign from pinch
64
50 58 97 97 60 61 8B 04 24 80 78 F3 6A E8 00 00
00 00 58 E8 00 00 00 00 58 91 91 EB 00 0F 85 6B
F4 76 6F E8 00 00 00 00 83 C4 04 E8 00 00 00 00
58 90 E8 00 00 00 00 83 C4 04 8B 04 24 80 78 F1

Safe 2.0
10
83 EC 10 53 56 57 E8 C4 01 00

SafeDisc v4
16
00 00 00 00 00 00 00 00 00 00 00 00 42 6F 47 5F

SafeGuard V1.0X -> simonzh2000
47
E8 00 00 00 00 EB 29 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? 59 9C 81 C1 E2 FF FF FF EB 01 ?? 9D FF E1

SC Obfuscator -> SuperCRacker
55
60 33 C9 8B 1D 00 ?? ?? ?? 03 1D 08 ?? ?? ?? 8A
04 19 84 C0 74 09 3C ?? 74 05 34 ?? 88 04 19 41
3B 0D 04 ?? ?? ?? 75 E7 A1 08 ?? ?? ?? 01 05 0C
?? ?? ?? 61 FF 25 0C

Sc Obfuscator -> SuperCRacker
60
60 33 C9 8B 1D ?? ?? ?? ?? 03 1D ?? ?? ?? ?? 8A
04 19 84 C0 74 09 3C ?? 74 05 34 ?? 88 04 19 41
3B 0D ?? ?? ?? ?? 75 E7 A1 ?? ?? ?? ?? 01 05 ??
?? ?? ?? 61 FF 25 ?? ?? ?? ?? 00 00

SDC 1.2 (Self Decrypting Binary Generator) - by Claes M Nyberg
390
55 89 E5 83 EC 08 C7 04 24 01 00 00 00 FF 15 A0
91 40 00 E8 DB FE FF FF 55 89 E5 53 83 EC 14 8B
45 08 8B 00 8B 00 3D 91 00 00 C0 77 3B 3D 8D 00
00 C0 72 4B BB 01 00 00 00 C7 44 24 04 00 00 00
00 C7 04 24 08 00 00 00 E8 CE 24 00 00 83 F8 01
0F 84 C4 00 00 00 85 C0 0F 85 A9 00 00 00 31 C0
83 C4 14 5B 5D C2 04 00 3D 94 00 00 C0 74 56 3D
96 00 00 C0 74 1E 3D 93 00 00 C0 75 E1 EB B5 3D
05 00 00 C0 8D B4 26 00 00 00 00 74 43 3D 1D 00
00 C0 75 CA C7 44 24 04 00 00 00 00 C7 04 24 04
00 00 00 E8 73 24 00 00 83 F8 01 0F 84 99 00 00
00 85 C0 74 A9 C7 04 24 04 00 00 00 FF D0 B8 FF
FF FF FF EB 9B 31 DB 8D 74 26 00 E9 69 FF FF FF
C7 44 24 04 00 00 00 00 C7 04 24 0B 00 00 00 E8
37 24 00 00 83 F8 01 74 7F 85 C0 0F 84 6D FF FF
FF C7 04 24 0B 00 00 00 8D 76 00 FF D0 B8 FF FF
FF FF E9 59 FF FF FF C7 04 24 08 00 00 00 FF D0
B8 FF FF FF FF E9 46 FF FF FF C7 44 24 04 01 00
00 00 C7 04 24 08 00 00 00 E8 ED 23 00 00 B8 FF
FF FF FF 85 DB 0F 84 25 FF FF FF E8 DB 15 00 00
B8 FF FF FF FF E9 16 FF FF FF C7 44 24 04 01 00
00 00 C7 04 24 04 00 00 00 E8 BD 23 00 00 B8 FF
FF FF FF E9 F8 FE FF FF C7 44 24 04 01 00 00 00
C7 04 24 0B 00 00 00 E8 9F 23 00 00 B8 FF FF FF
FF E9 DA FE FF FF

SDProtect -> Randy Li
55
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 E8 3B 00 00 00 E8
01 00 00 00 FF 58 05

SDProtector 1.x -> Randy Li
85
55 8B EC 6A FF 68 1D 32 13 05 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 E8 3B 00 00 00 E8
01 00 00 00 FF 58 05 53 00 00 00 51 8B 4C 24 10
89 81 B8 00 00 00 B8 55 01 00 00 89 41 20 33 C0
89 41 04 89 41

SDProtector Basic/Pro Edition 1.10 -> Randy Li
85
55 8B EC 6A FF 68 1D 32 13 05 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 50 83 EC 08 64 A1
00 00 00 00 64 FF 35 00 00 00 00 64 89 25 00 00
00 00 83 C4 08 50 64 FF 35 00 00 00 00 64 89 25
00 00 00 00 64

SDProtector Basic/Pro Edition 1.12 -> Randy Li
261
55 8B EC 6A FF 68 1D 32 13 05 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 E8 3B 00 00 00 E8
01 00 00 00 FF 58 05 53 00 00 00 51 8B 4C 24 10
89 81 B8 00 00 00 B8 55 01 00 00 89 41 20 33 C0
89 41 04 89 41 08 89 41 0C 89 41 10 59 C3 C3 C3
C3 C3 C3 C3 C3 C3 C3 C3 C3 C3 33 C0 64 FF 30 64
89 20 9C 80 4C 24 01 01 9D 90 90 C3 C3 C3 C3 C3
C3 C3 C3 C3 C3 C3 C3 64 8F 00 58 74 07 75 05 19
32 67 E8 E8 74 27 75 25 EB 00 EB FC 68 39 44 CD
00 59 9C 50 74 0F 75 0D E8 59 C2 04 00 55 8B EC
E9 FA FF FF 0E E8 EF FF FF FF 56 57 53 78 03 79
01 E8 68 A2 AF 47 01 59 E8 01 00 00 00 FF 58 05
7B 03 00 00 03 C8 74 C4 75 C2 E8 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 E2

SDProtector Pro Edition 1.16 -> Randy Li
85
55 8B EC 6A FF 68 1D 32 13 05 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 E8 3B 00 00 00 E8
01 00 00 00 FF 58 05 53 00 00 00 51 8B 4C 24 10
89 81 B8 00 00 00 B8 55 01 00 00 89 41 18 33 C0
89 41 04 89 41

SDProtector Pro Edition 1.16 -> Randy Li
219
55 8B EC 6A FF 68 1D 32 13 05 68 88 88 88 08 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 58 64 A3
00 00 00 00 58 58 58 58 8B E8 E8 3B 00 00 00 E8
01 00 00 00 FF 58 05 53 00 00 00 51 8B 4C 24 10
89 81 B8 00 00 00 B8 55 01 00 00 89 41 18 33 C0
89 41 04 89 41 08 89 41 0C 89 41 10 59 C3 C3 C3
C3 C3 C3 C3 C3 C3 C3 C3 C3 C3 33 C0 64 FF 30 64
89 20 9C 80 4C 24 01 01 9D 90 90 C3 C3 C3 C3 C3
C3 C3 C3 C3 C3 C3 C3 64 8F 00 58 74 07 75 05 19
32 67 E8 E8 74 27 75 25 EB 00 EB FC 68 39 44 CD
00 59 9C 50 74 0F 75 0D E8 59 C2 04 00 55 8B EC
E9 FA FF FF 0E E8 EF FF FF FF 56 57 53 78 03 79
01 E8 68 A2 AF 47 01 59 E8 01 00 00 00 FF 58 05
93 03 00 00 03 C8 74 C4 75 C2 E8

SDProtector V1.1x -> Randy Li
17
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 88 88 88 08 64
A1

SEA-AXE
25
FC BC ?? ?? 0E 1F E8 ?? ?? 26 A1 ?? ?? 8B 1E ??
?? 2B C3 8E C0 B1 ?? D3 E3

SEA-AXE v2.2
36
FC BC ?? ?? 0E 1F A3 ?? ?? E8 ?? ?? A1 ?? ?? 8B
?? ?? ?? 2B C3 8E C0 B1 03 D3 E3 8B CB BF ?? ??
8B F7 F3 A5

SecuPack v1.5
55
55 8B EC 83 C4 F0 53 56 57 33 C0 89 45 F0 B8 CC
3A 40 ?? E8 E0 FC FF FF 33 C0 55 68 EA 3C 40 ??
64 FF 30 64 89 20 6A ?? 68 80 ?? ?? ?? 6A 03 6A
?? 6A 01 ?? ?? ?? 80

SecureEXE 3.0 -> ZipWorx
22
E9 B8 00 00 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ??
00 00 00 00 00 00

SecurePE 1.X -> www.deepzone.org
102
8B 04 24 E8 00 00 00 00 5D 81 ED 4C 2F 40 00 89
85 61 2F 40 00 8D 9D 65 2F 40 00 53 C3 00 00 00
00 8D B5 BA 2F 40 00 8B FE BB 65 2F 40 00 B9 C6
01 00 00 AD 2B C3 C1 C0 03 33 C3 AB 43 81 FB 8E
2F 40 00 75 05 BB 65 2F 40 00 E2 E7 89 AD 1A 31
40 00 89 AD 55 34 40 00 89 AD 68 34 40 00 8D 85
BA 2F 40 00 50 C3

Securom7 -> Sony DADC
18
B8 ?? ?? ?? ?? 8B ?? ?? ?? ?? 0A ?? ?? ?? ?? ??
?? E8

SEN Debug Protector???
16
BB ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? 29 ?? ?? 4E E8

Sentinel SuperPro (Automatic Protection) v6.4.0 -> Safenet
81
68 ?? ?? ?? ?? 6A 01 6A 00 FF 15 ?? ?? ?? ?? A3
?? ?? ?? ?? FF 15 ?? ?? ?? ?? 33 C9 3D B7 00 00
00 A1 ?? ?? ?? ?? 0F 94 C1 85 C0 89 0D ?? ?? ??
?? 0F 85 ?? ?? ?? ?? 55 56 C7 05 ?? ?? ?? ?? 01
00 00 00 FF 15 ?? ?? ?? ?? 01 05 ?? ?? ?? ?? FF
15

Sentinel SuperPro (Automatic Protection) v6.4.1 -> Safenet
85
A1 ?? ?? ?? ?? 55 8B ?? ?? ?? 85 C0 74 ?? 85 ED
75 ?? A1 ?? ?? ?? ?? 50 55 FF 15 ?? ?? ?? ?? 8B
0D ?? ?? ?? ?? 55 51 FF 15 ?? ?? ?? ?? 85 C0 74
?? 8B 15 ?? ?? ?? ?? 52 FF 15 ?? ?? ?? ?? 6A 00
6A 00 68 ?? ?? ?? ?? E8 ?? ?? ?? ?? B8 01 00 00
00 5D C2 0C 00

Setup Factory v6.0.0.3 Setup Launcher
85
55 8B EC 6A FF 68 90 61 40 00 68 70 3B 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 14 61 40 00 33 D2 8A D4
89 15 5C 89 40 00 8B C8 81 E1 FF 00 00 00 89 0D
58 89 40 00 C1 E1 08 03 CA 89 0D 54 89 40 00 C1
E8 10 A3 50 89

Setup2Go Installer Stub
17
5B 53 45 54 55 50 5F 49 4E 46 4F 5D 0D 0A 56 65
72

Sexe Crypter 1.1 - by santasdad
258
55 8B EC 83 C4 EC 53 56 57 33 C0 89 45 EC B8 D8
39 00 10 E8 30 FA FF FF 33 C0 55 68 D4 3A 00 10
64 FF 30 64 89 ?? ?? ?? ?? E4 3A 00 10 A1 00 57
00 10 50 E8 CC FA FF FF 8B D8 53 A1 00 57 00 10
50 E8 FE FA FF FF 8B F8 53 A1 00 57 00 10 50 E8
C8 FA FF FF 8B D8 53 E8 C8 FA FF FF 8B F0 85 F6
74 26 8B D7 4A B8 14 57 00 10 E8 AD F6 FF FF B8
14 57 00 10 E8 9B F6 FF FF 8B CF 8B D6 E8 DA FA
FF FF 53 E8 84 FA FF FF 8D 4D EC BA F8 3A 00 10
A1 14 57 00 10 E8 0A FB FF FF 8B 55 EC B8 14 57
00 10 E8 65 F5 FF FF B8 14 57 00 10 E8 63 F6 FF
FF E8 52 FC FF FF 33 C0 5A 59 59 64 89 10 68 DB
3A 00 10 8D 45 EC E8 ED F4 FF FF C3 E9 83 EF FF
FF EB F0 5F 5E 5B E8 ED F3 FF FF 00 53 45 54 54
49 4E 47 53 00 00 00 00 FF FF FF FF 12 00 00 00
6B 75 74 68 37 36 67 62 62 67 36 37 34 76 38 38
67 79

Shegerd Dongle V4.78 -> MS.Co.
22
E8 32 00 00 00 B8 ?? ?? ?? ?? 8B 18 C1 CB 05 89
DA 36 8B 4C 24 0C

ShellModify 0.1 -> pll621
21
55 8B EC 6A FF 68 98 66 41 00 68 3C 3D 41 00 64
A1 00 00 00 00

Shrink v1.0
28
50 9C FC BE ?? ?? BF ?? ?? 57 B9 ?? ?? F3 A4 8B
?? ?? ?? BE ?? ?? BF ?? ?? F3 A4 C3

Shrink v2.0
21
E9 ?? ?? 50 9C FC BE ?? ?? 8B FE 8C C8 05 ?? ??
8E C0 06 57 B9

Shrink Wrap v1.4
18
58 60 8B E8 55 33 F6 68 48 01 ?? ?? E8 49 01 ??
?? EB

Shrinker 3.2
20
55 8B EC 56 57 75 65 68 00 01 00 00 E8 F1 E6 FF
FF 83 C4 04

Shrinker 3.3
15
00 00 55 8B EC 56 57 75 65 68 00 01 00 00 E8

Shrinker 3.4
20
55 8B EC 56 57 75 6B 68 00 01 00 00 E8 11 0B 00
00 83 C4 04

Shrinker v3.2
41
83 3D ?? ?? ?? ?? ?? 55 8B EC 56 57 75 65 68 00
01 ?? ?? E8 ?? E6 FF FF 83 C4 04 8B 75 08 A3 ??
?? ?? ?? 85 F6 74 1D 68 FF

Shrinker v3.3
20
83 3D ?? ?? ?? 00 00 55 8B EC 56 57 75 65 68 00
01 00 00 E8

Shrinker v3.4
47
83 3D B4 ?? ?? ?? ?? 55 8B EC 56 57 75 6B 68 00
01 00 00 E8 ?? 0B 00 00 83 C4 04 8B 75 08 A3 B4
?? ?? ?? 85 F6 74 23 83 7D 0C 03 77 1D 68 FF

Shrinker v3.4
30
BB ?? ?? BA ?? ?? 81 C3 07 00 B8 40 B4 B1 04 D3
E8 03 C3 8C D9 49 8E C1 26 03 0E 03 00 2B

Silicon Realms Install Stub
83
55 8B EC 6A FF 68 ?? 92 40 00 68 ?? ?? 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 ?? ?? 40 00 33 D2 8A D4
89 15 ?? ?? 40 00 8B C8 81 E1 FF 00 00 00 89 0D
?? ?? 40 00 C1 E1 08 03 CA 89 0D ?? ?? 40 00 C1
E8 10 A3

SimbiOZ -> Extranger
31
50 60 E8 00 00 00 00 5D 81 ED 07 10 40 00 68 80
0B 00 00 8D 85 1F 10 40 00 50 E8 84 0B 00 00

SimbiOZ 1.3 -> Extranger
16
57 57 8D 7C 24 04 50 B8 00 ?? ?? ?? AB 58 5F C3

SimbiOZ Poly 2.1 -> Extranger
16
55 50 8B C4 83 C0 04 C7 00 ?? ?? ?? ?? 58 C3 90

SimbiOZ PolyCryptor v.xx-> Extranger
27
55 60 E8 00 00 00 00 5D 81 ED ?? ?? ?? ?? 8D 85
?? ?? ?? ?? 68 ?? ?? ?? ?? 50 E8

Simple UPX Cryptor V30.4.2005 -> MANtiCORE
24
60 B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? ?? ?? ?? ?? E2
FA 61 68 ?? ?? ?? ?? C3

Simple UPX Cryptor v30.4.2005 [multi layer encryption] --> MANtiCORE
24
60 B8 ?? ?? ?? 00 B9 18 00 00 00 80 34 08 ?? E2
FA 61 68 ?? ?? ?? 00 C3

Simple UPX Cryptor v30.4.2005 [multi layer encryption] --> MANtiCORE
24
60 B8 ?? ?? ?? ?? B9 18 00 00 00 80 34 08 ?? E2
FA 61 68 ?? ?? ?? ?? C3

Simple UPX Cryptor v30.4.2005 [One layer encryption] --> MANtiCORE
24
60 B8 ?? ?? ?? 00 B9 ?? 01 00 00 80 34 08 ?? E2
FA 61 68 ?? ?? ?? 00 C3

SimplePack 1.0X -> bagie
41
60 E8 00 00 00 00 5B 8D 5B FA 6A 00 FF 93 ?? ??
00 00 89 C5 8B 7D 3C 8D 74 3D 00 8D BE F8 00 00
00 8B 86 88 00 00 00 09 C0

SimplePack 1.11 Method 1 -> bagie[TMX]
85
60 E8 00 00 00 00 5B 8D 5B FA BD 00 00 ?? ?? 8B
7D 3C 8D 74 3D 00 8D BE F8 00 00 00 0F B7 76 06
4E 8B 47 10 09 C0 74 55 0F B7 47 22 09 C0 74 4D
6A 04 68 00 10 00 00 FF 77 10 6A 00 FF 93 38 03
00 00 50 56 57 89 EE 03 77 0C 8B 4F 10 89 C7 89
C8 C1 E9 02 FC

SimplePack 1.11 Method 1 -> bagie[TMX]
224
60 E8 00 00 00 00 5B 8D 5B FA BD 00 00 ?? ?? 8B
7D 3C 8D 74 3D 00 8D BE F8 00 00 00 0F B7 76 06
4E 8B 47 10 09 C0 74 55 0F B7 47 22 09 C0 74 4D
6A 04 68 00 10 00 00 FF 77 10 6A 00 FF 93 38 03
00 00 50 56 57 89 EE 03 77 0C 8B 4F 10 89 C7 89
C8 C1 E9 02 FC F3 A5 89 C1 83 E1 03 F3 A4 5F 5E
8B 04 24 89 EA 03 57 0C E8 3F 01 00 00 58 68 00
40 00 00 FF 77 10 50 FF 93 3C 03 00 00 83 C7 28
4E 75 9E BE ?? ?? ?? ?? 09 F6 0F 84 0C 01 00 00
01 EE 8B 4E 0C 09 C9 0F 84 FF 00 00 00 01 E9 89
CF 57 FF 93 30 03 00 00 09 C0 75 3D 6A 04 68 00
10 00 00 68 00 10 00 00 6A 00 FF 93 38 03 00 00
89 C6 8D 83 6F 02 00 00 57 50 56 FF 93 44 03 00
00 6A 10 6A 00 56 6A 00 FF 93 48 03 00 00 89 E5

SimplePack 1.11 Method 2(NT) -> bagie[TMX]
38
4D 5A 90 EB 01 00 52 E9 89 01 00 00 50 45 00 00
4C 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00
E0 00 0F 03 0B 01

SimplePack 1.2.build.30.09 (Method2) -> bagie
92
4D 5A 90 EB 01 00 52 E9 86 01 00 00 50 45 00 00
4C 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00
E0 00 0F 03 0B 01 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 0C 00 00 00
00 ?? ?? ?? 00 10 00 00 00 02 00 00 01 00 00 00
00 00 00 00 04 00 00 00 00 00 00 00

SimplePack 1.21.build.09.09 (Method2) -> bagie
92
4D 5A 90 EB 01 00 52 E9 8A 01 00 00 50 45 00 00
4C 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00
E0 00 0F 03 0B 01 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 0C 00 00 00
00 ?? ?? ?? 00 10 00 00 00 02 00 00 01 00 00 00
00 00 00 00 04 00 00 00 00 00 00 00

SimplePack 1.X (Method2) -> bagie
92
4D 5A 90 EB 01 00 52 E9 ?? 01 00 00 50 45 00 00
4C 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00
E0 00 0F 03 0B 01 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 0C 00 00 00
00 ?? ?? ?? 00 10 00 00 00 02 00 00 01 00 00 00
00 00 00 00 04 00 00 00 00 00 00 00

SimplePack V1.1X (Method2) -> bagie
20
4D 5A 90 EB 01 00 52 E9 89 01 00 00 50 45 00 00
4C 01 02 00

SimplePack V1.1X (Method2) -> bagie
92
4D 5A 90 EB 01 00 52 E9 89 01 00 00 50 45 00 00
4C 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00
E0 00 0F 03 0B 01 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 0C 00 00 00
00 ?? ?? ?? 00 10 00 00 00 02 00 00 01 00 00 00
00 00 00 00 04 00 00 00 00 00 00 00

SimplePack V1.1X-V1.2X (Method1) -> bagie
38
60 E8 00 00 00 00 5B 8D 5B FA BD ?? ?? ?? ?? 8B
7D 3C 8D 74 3D 00 8D BE F8 00 00 00 0F B7 76 06
4E 8B 47 10 09 C0

SkD Undetectabler 3 (No FSG 2 Method) -> SkD
234
55 8B EC 81 EC 10 02 00 00 68 00 02 00 00 8D 85
F8 FD FF FF 50 6A 00 FF 15 38 10 00 01 50 FF 15
3C 10 00 01 8D 8D F8 FD FF FF 51 E8 4F FB FF FF
83 C4 04 8B 15 ?? 16 00 01 52 A1 ?? 16 00 01 50
E8 50 FF FF FF 83 C4 08 A3 ?? 16 00 01 C7 85 F4
FD FF FF 00 00 00 00 EB 0F 8B 8D F4 FD FF FF 83
C1 01 89 8D F4 FD FF FF 8B 95 F4 FD FF FF 3B 15
?? 16 00 01 73 1C 8B 85 F4 FD FF FF 8B 0D ?? 16
00 01 8D 54 01 07 81 FA 74 10 00 01 75 02 EB 02
EB C7 8B 85 F4 FD FF FF 50 E8 ?? 00 00 00 83 C4
04 89 85 F0 FD FF FF 8B 8D F0 FD FF FF 89 4D FC
C7 45 F8 00 00 00 00 EB 09 8B 55 F8 83 C2 01 89
55 F8 8B 45 F8 3B 85 F4 FD FF FF 73 15 8B 4D FC
03 4D F8 8B 15 ?? 16 00 01 03 55 F8 8A 02 88 01
EB D7 83 3D ?? 16 00 01 00 74

SkD Undetectabler Pro 2.0 (No UPX Method) -> SkD
35
55 8B EC 83 C4 F0 B8 FC 26 00 10 E8 EC F3 FF FF
6A 0F E8 15 F5 FF FF E8 64 FD FF FF E8 BB ED FF
FF 8D 40

SLVc0deProtector 0.60 -> SLV / ICU
48
EB 02 FA 04 E8 49 00 00 00 69 E8 49 00 00 00 95
E8 4F 00 00 00 68 E8 1F 00 00 00 49 E8 E9 FF FF
FF 67 E8 1F 00 00 00 93 E8 31 00 00 00 78 E8 DD

SLVc0deProtector 1.1x -> SLV / ICU
20
E8 00 00 00 00 58 C6 00 EB C6 40 01 08 FF E0 E9
4C ?? ?? 00

SLVc0deProtector v0.6 -> SLV
181
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
E8 49 00 00 00 69 E8 49 00 00 00 95 E8 4F 00 00
00 68 E8 1F 00 00 00 49 E8 E9 FF FF FF 67 E8 1F
00 00 00 93 E8 31 00 00 00 78 E8 DD FF FF FF 38
E8 E3 FF FF FF 66 E8 0D 00 00 00 04 E8 E3 FF FF
FF 70 E8 CB FF FF FF 69 E8 DD FF FF FF 58 E8 DD
FF FF FF 69 E8 E3 FF FF FF 79 E8 BF FF FF FF 69
83 C4 40 E8 00 00 00 00 5D 81 ED 97 11 40 00 8D
B5 EF 11 40 00 B9 FE 2D 00 00 8B FE AC F8 ?? ??
?? ?? ?? ?? 90

SLVc0deProtector v0.61 -> SLV
85
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
EB 02 FA 04 E8 49 00 00 00 69 E8 49 00 00 00 95
E8 4F 00 00 00 68 E8 1F 00 00 00 49 E8 E9 FF FF
FF 67 E8 1F 00

SLVc0deProtector v0.61 -> SLV
193
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
EB 02 FA 04 E8 49 00 00 00 69 E8 49 00 00 00 95
E8 4F 00 00 00 68 E8 1F 00 00 00 49 E8 E9 FF FF
FF 67 E8 1F 00 00 00 93 E8 31 00 00 00 78 E8 DD
FF FF FF 38 E8 E3 FF FF FF 66 E8 0D 00 00 00 04
E8 E3 FF FF FF 70 E8 CB FF FF FF 69 E8 DD FF FF
FF 58 E8 DD FF FF FF 69 E8 E3 FF FF FF 79 E8 BF
FF FF FF 69 83 C4 40 E8 00 00 00 00 5D 81 ED 9D
11 40 00 8D 95 B4 11 40 00 E8 CB 2E 00 00 33 C0
F7 F0 69 8D B5 05 12 40 00 B9 5D 2E 00 00 8B FE
AC

SLVc0deProtector v1.1 -> SLV
17
E8 00 00 00 00 58 C6 00 EB C6 40 01 08 FF E0 E9
4C

SLVc0deProtector v1.1 -> SLV
85
E8 01 00 00 00 A0 5D EB 01 69 81 ED 5F 1A 40 00
8D 85 92 1A 40 00 F3 8D 95 83 1A 40 00 8B C0 8B
D2 2B C2 83 E8 05 89 42 01 E8 FB FF FF FF 69 83
C4 08 E8 06 00 00 00 69 E8 F2 FF FF FF F3 B9 05
00 00 00 51 8D B5 BF 1A 40 00 8B FE B9 58 15 00
00 AC 32 C1 F6

SmartE -> Microsoft
78
EB 15 03 00 00 00 ?? 00 00 00 00 00 00 00 00 00
00 00 68 00 00 00 00 55 E8 00 00 00 00 5D 81 ED
1D 00 00 00 8B C5 55 60 9C 2B 85 8F 07 00 00 89
85 83 07 00 00 FF 74 24 2C E8 BB 01 00 00 0F 82
2F 06 00 00 E8 8E 04 00 00 49 0F 88 23 06

SmokesCrypt v1.2
26
60 B8 ?? ?? ?? ?? B8 ?? ?? ?? ?? 8A 14 08 80 F2
?? 88 14 08 41 83 F9 ?? 75 F1

Soft Defender v1.0 - v1.1
83
74 07 75 05 19 32 67 E8 E8 74 1F 75 1D E8 68 39
44 CD ?? 59 9C 50 74 0A 75 08 E8 59 C2 04 ?? 55
8B EC E8 F4 FF FF FF 56 57 53 78 0F 79 0D E8 34
99 47 49 34 33 EF 31 34 52 47 23 68 A2 AF 47 01
59 E8 ?? ?? ?? ?? 58 05 BA 01 ?? ?? 03 C8 74 BE
75 BC E8

Soft Defender v1.1x -> Randy Li
46
74 07 75 05 ?? ?? ?? ?? ?? 74 1F 75 1D ?? 68 ??
?? ?? 00 59 9C 50 74 0A 75 08 ?? 59 C2 04 00 ??
?? ?? E8 F4 FF FF FF ?? ?? ?? 78 0F 79 0D

SoftComp 1.x -> BG Soft PT
50
E8 00 00 00 00 81 2C 24 3A 10 41 00 5D E8 00 00
00 00 81 2C 24 31 01 00 00 8B 85 2A 0F 41 00 29
04 24 8B 04 24 89 85 2A 0F 41 00 58 8B 85 2A 0F
41 00

SoftDefender 1.x -> Randy Li
85
74 07 75 05 19 32 67 E8 E8 74 1F 75 1D E8 68 39
44 CD 00 59 9C 50 74 0A 75 08 E8 59 C2 04 00 55
8B EC E8 F4 FF FF FF 56 57 53 78 0F 79 0D E8 34
99 47 49 34 33 EF 31 34 52 47 23 68 A2 AF 47 01
59 E8 01 00 00 00 FF 58 05 E6 01 00 00 03 C8 74
BD 75 BB E8 00

SoftDefender V1.1x -> Randy Li
17
74 07 75 05 19 32 67 E8 E8 74 1F 75 1D E8 68 39
44

SoftProtect -> SoftProtect.by.ru
85
EB 01 E3 60 E8 03 ?? ?? ?? D2 EB 0B 58 EB 01 48
40 EB 01 35 FF E0 E7 61 60 E8 03 ?? ?? ?? 83 EB
0E EB 01 0C 58 EB 01 35 40 EB 01 36 FF E0 0B 61
EB 01 83 9C EB 01 D5 EB 08 35 9D EB 01 89 EB 03
0B EB F7 E8 ?? ?? ?? ?? 58 E8 ?? ?? ?? ?? 59 83
01 01 80 39 5C

SoftProtect -> www.softprotect.by.ru
46
E8 ?? ?? ?? ?? 8D ?? ?? ?? ?? ?? C7 00 00 00 00
00 E8 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D ?? ?? ?? ??
?? 50 E8 ?? ?? ?? ?? 83 ?? ?? ?? ?? ?? 01

SoftSentry v2.11
11
55 8B EC 83 EC ?? 53 56 57 E9 50

SoftSentry v3.0
12
55 8B EC 83 EC ?? 53 56 57 E9 B0 06

Software Compress -> BG Software
85
E9 BE 00 00 00 60 8B 74 24 24 8B 7C 24 28 FC B2
80 33 DB A4 B3 02 E8 6D 00 00 00 73 F6 33 C9 E8
64 00 00 00 73 1C 33 C0 E8 5B 00 00 00 73 23 B3
02 41 B0 10 E8 4F 00 00 00 12 C0 73 F7 75 3F AA
EB D4 E8 4D 00 00 00 2B CB 75 10 E8 42 00 00 00
EB 28 AC D1 E8

Software Compress V1.2 ->  BG Software Protect Technologies
26
E9 BE 00 00 00 60 8B 74 24 24 8B 7C 24 28 FC B2
80 33 DB A4 B3 02 E8 6D 00 00

Software Compress v1.2 -> BG Software Protect Technologies
229
E9 BE 00 00 00 60 8B 74 24 24 8B 7C 24 28 FC B2
80 33 DB A4 B3 02 E8 6D 00 00 00 73 F6 33 C9 E8
64 00 00 00 73 1C 33 C0 E8 5B 00 00 00 73 23 B3
02 41 B0 10 E8 4F 00 00 00 12 C0 73 F7 75 3F AA
EB D4 E8 4D 00 00 00 2B CB 75 10 E8 42 00 00 00
EB 28 AC D1 E8 74 4D 13 C9 EB 1C 91 48 C1 E0 08
AC E8 2C 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05
73 06 83 F8 7F 77 02 41 41 95 8B C5 B3 01 56 8B
F7 2B F0 F3 A4 5E EB 8E 02 D2 75 05 8A 16 46 12
D2 C3 33 C9 41 E8 EE FF FF FF 13 C9 E8 E7 FF FF
FF 72 F2 C3 2B 7C 24 28 89 7C 24 1C 61 C3 60 FF
74 24 24 6A 40 FF 95 1A 0F 41 00 89 44 24 1C 61
C2 04 00 E8 00 00 00 00 81 2C 24 3A 10 41 00 5D
E8 00 00 00 00 81 2C 24 31 01 00 00 8B 85 2A 0F
41 00 29 04 24

Software Compress v1.4 LITE -> BG Software Protect Technologies
85
E8 00 00 00 00 81 2C 24 AA 1A 41 00 5D E8 00 00
00 00 83 2C 24 6E 8B 85 5D 1A 41 00 29 04 24 8B
04 24 89 85 5D 1A 41 00 58 8B 85 5D 1A 41 00 8B
50 3C 03 D0 8B 92 80 00 00 00 03 D0 8B 4A 58 89
8D 49 1A 41 00 8B 4A 5C 89 8D 4D 1A 41 00 8B 4A
60 89 8D 55 1A

Software Compress v1.4 LITE -> BG Software Protect Technologies
345
E8 00 00 00 00 81 2C 24 AA 1A 41 00 5D E8 00 00
00 00 83 2C 24 6E 8B 85 5D 1A 41 00 29 04 24 8B
04 24 89 85 5D 1A 41 00 58 8B 85 5D 1A 41 00 8B
50 3C 03 D0 8B 92 80 00 00 00 03 D0 8B 4A 58 89
8D 49 1A 41 00 8B 4A 5C 89 8D 4D 1A 41 00 8B 4A
60 89 8D 55 1A 41 00 8B 4A 64 89 8D 51 1A 41 00
8B 4A 74 89 8D 59 1A 41 00 68 00 20 00 00 E8 D2
00 00 00 50 8D 8D 00 1C 41 00 50 51 E8 1B 00 00
00 83 C4 08 58 8D 78 74 8D B5 49 1A 41 00 B9 18
00 00 00 F3 A4 05 A4 00 00 00 50 C3 60 8B 74 24
24 8B 7C 24 28 FC B2 80 33 DB A4 B3 02 E8 6D 00
00 00 73 F6 33 C9 E8 64 00 00 00 73 1C 33 C0 E8
5B 00 00 00 73 23 B3 02 41 B0 10 E8 4F 00 00 00
12 C0 73 F7 75 3F AA EB D4 E8 4D 00 00 00 2B CB
75 10 E8 42 00 00 00 EB 28 AC D1 E8 74 4D 13 C9
EB 1C 91 48 C1 E0 08 AC E8 2C 00 00 00 3D 00 7D
00 00 73 0A 80 FC 05 73 06 83 F8 7F 77 02 41 41
95 8B C5 B3 01 56 8B F7 2B F0 F3 A4 5E EB 8E 02
D2 75 05 8A 16 46 12 D2 C3 33 C9 41 E8 EE FF FF
FF 13 C9 E8 E7 FF FF FF 72 F2 C3 2B 7C 24 28 89
7C 24 1C 61 C3 60 FF 74 24 24 6A 40 FF 95 4D 1A
41 00 89 44 24 1C 61 C2 04

SoftWrap
35
52 53 51 56 57 55 E8 ?? ?? ?? ?? 5D 81 ED 36 ??
?? ?? E8 ?? 01 ?? ?? 60 BA ?? ?? ?? ?? E8 ?? ??
?? ?? 5F

SOFTWrapper for Win9x/NT (Evaluation Version)
85
E8 00 00 00 00 5D 8B C5 2D ?? ?? ?? 00 50 81 ED
05 00 00 00 8B C5 2B 85 03 0F 00 00 89 85 03 0F
00 00 8B F0 03 B5 0B 0F 00 00 8B F8 03 BD 07 0F
00 00 83 7F 0C 00 74 2B 56 57 8B 7F 10 03 F8 8B
76 10 03 F0 83 3F 00 74 0C 8B 1E 89 1F 83 C6 04
83 C7 04 EB EF

SPEC b2
35
55 57 51 53 E8 ?? ?? ?? ?? 5D 8B C5 81 ED ?? ??
?? ?? 2B 85 ?? ?? ?? ?? 83 E8 09 89 85 ?? ?? ??
?? 0F B6

SPEC b3
44
5B 53 50 45 43 5D E8 ?? ?? ?? ?? 5D 8B C5 81 ED
41 24 40 ?? 2B 85 89 26 40 ?? 83 E8 0B 89 85 8D
26 40 ?? 0F B6 B5 91 26 40 ?? 8B FD

Special EXE Password Protector v1.0
31
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 89 AD 8C
01 00 00 8B C5 2B 85 FE 75 00 00 89 85 3E 77

Special EXE Pasword Protector V1.01 (Eng) -> Pavol Cerven
30
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 89 AD 8C
01 00 00 8B C5 2B 85 FE 75 00 00 89 85 3E

Special EXE Pasword Protector v1.01 (Eng) -> Pavol Cerven
85
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 89 AD 8C
01 00 00 8B C5 2B 85 FE 75 00 00 89 85 3E 77 00
00 8D 95 C6 77 00 00 8D 8D FF 77 00 00 55 68 00
20 00 00 51 52 6A 00 FF 95 04 7A 00 00 5D 6A 00
FF 95 FC 79 00 00 8D 8D 60 78 00 00 8D 95 85 01
00 00 55 68 00

Splash Bitmap v1.00 (With Unpack Code) --> BoB / Bobsoft
71
E8 00 00 00 00 60 8B 6C 24 20 55 81 ED ?? ?? ??
?? 8D BD ?? ?? ?? ?? 8D 8D ?? ?? ?? ?? 29 F9 31
C0 FC F3 AA 8B 04 24 48 66 25 00 F0 66 81 38 4D
5A 75 F4 8B 48 3C 81 3C 01 50 45 00 00 75 E8 89
85 ?? ?? ?? ?? 6A 40

Splash Bitmap v1.00 --> BoB / Bobsoft
77
E8 00 00 00 00 60 8B 6C 24 20 55 81 ED ?? ?? ??
?? 8D BD ?? ?? ?? ?? 8D 8D ?? ?? ?? ?? 29 F9 31
C0 FC F3 AA 8B 04 24 48 66 25 00 F0 66 81 38 4D
5A 75 F4 8B 48 3C 81 3C 01 50 45 00 00 75 E8 89
85 ?? ?? ?? ?? 8D BD ?? ?? ?? ?? 6A 00

Splasher v1.0 - v3.0
28
9C 60 8B 44 24 24 E8 ?? ?? ?? ?? 5D 81 ED ?? ??
?? ?? 50 E8 ED 02 ?? ?? 8C C0 0F 84

SPLayer v0.08
36
8D 40 00 B9 ?? ?? ?? ?? 6A ?? 58 C0 0C ?? ?? 48
?? ?? 66 13 F0 91 3B D9 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00

Splice 1.1 - by Tw1sted L0gic
200
68 00 1A 40 00 E8 EE FF FF FF 00 00 00 00 00 00
30 00 00 00 40 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
00 00 01 00 00 00 ?? ?? ?? ?? ?? ?? 50 72 6F 6A
65 63 74 31 00 ?? ?? ?? ?? ?? ?? ?? 00 00 00 00
06 00 00 00 AC 29 40 00 07 00 00 00 BC 28 40 00
07 00 00 00 74 28 40 00 07 00 00 00 2C 28 40 00
07 00 00 00 08 23 40 00 01 00 00 00 38 21 40 00
00 00 00 00 FF FF FF FF FF FF FF FF 00 00 00 00
8C 21 40 00 08 ?? 40 00 01 00 00 00 AC 19 40 00
00 00 00 00 00 00 00 00 00 00 00 00 AC 19 40 00
4F 00 43 00 50 00 00 00 E7 AF 58 2F 9A 4C 17 4D
B7 A9 CA 3E 57 6F F7 76

ST Protector V1.5 -> Silent Software
48
00 00 00 00 4B 65 52 6E 45 6C 33 32 2E 64 4C 6C
00 00 47 65 74 50 72 6F 63 41 64 64 72 65 73 73
00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00

StarForce 3.0 -> StarForce Technology
10
68 ?? ?? ?? ?? FF 25 ?? ?? 63

StarForce ProActive 1.1 -> StarForce Technology
10
68 ?? ?? ?? ?? FF 25 ?? ?? 57

StarForce Protection Driver -> Protection Technology
41
57 68 ?? 0D 01 00 68 00 ?? ?? 00 E8 50 ?? FF FF
68 ?? ?? ?? 00 68 ?? ?? ?? 00 68 ?? ?? ?? 00 68
?? ?? ?? 00 68 ?? ?? ?? 00

StarForce V1.X-V3.X -> StarForce Copy Protection System
16
68 ?? ?? ?? ?? FF 25 ?? ?? ?? ?? 00 00 00 00 00

StarForce V3.X DLL -> StarForce Copy Protection System
11
E8 ?? ?? ?? ?? 00 00 00 00 00 00

Ste@lth PE 1.01 -> BGCorp
10
?? ?? ?? ?? ?? BA ?? ?? ?? 00

Stealth PE v1.1
34
BA ?? ?? ?? 00 FF E2 BA ?? ?? ?? 00 B8 ?? ?? ??
?? 89 02 83 C2 03 B8 ?? ?? ?? ?? 89 02 83 C2 FD
FF E2

STNPEE 1.13
20
55 57 56 52 51 53 E8 00 00 00 00 5D 8B D5 81 ED
97 3B 40 00

Stone's PE Encryptor v1.0
44
55 57 56 52 51 53 E8 ?? ?? ?? ?? 5D 8B D5 81 ED
63 3A 40 ?? 2B 95 C2 3A 40 ?? 83 EA 0B 89 95 CB
3A 40 ?? 8D B5 CA 3A 40 ?? 0F B6 36

Stone's PE Encryptor v1.13
44
55 57 56 52 51 53 E8 ?? ?? ?? ?? 5D 8B D5 81 ED
97 3B 40 ?? 2B 95 2D 3C 40 ?? 83 EA 0B 89 95 36
3C 40 ?? 01 95 24 3C 40 ?? 01 95 28

Stone's PE Encryptor v2.0
44
53 51 52 56 57 55 E8 ?? ?? ?? ?? 5D 81 ED 42 30
40 ?? FF 95 32 35 40 ?? B8 37 30 40 ?? 03 C5 2B
85 1B 34 40 ?? 89 85 27 34 40 ?? 83

Stone`s PE Encruptor v1.13
15
55 57 56 52 51 53 E8 ?? ?? ?? ?? 5D 8B D5 81

STUD RC4 1.0 Jamie Edition (ScanTime UnDetectable) - by MarjinZ
384
68 2C 11 40 00 E8 F0 FF FF FF 00 00 00 00 00 00
30 00 00 00 38 00 00 00 00 00 00 00 37 BB 71 EC
A4 E1 98 4C 9B FE 8F 0F FA 6A 07 F6 00 00 00 00
00 00 01 00 00 00 20 20 46 6F 72 20 73 74 75 64
00 20 54 6F 00 00 00 00 06 00 00 00 CC 1A 40 00
07 00 00 00 D4 18 40 00 07 00 00 00 7C 18 40 00
07 00 00 00 2C 18 40 00 07 00 00 00 E0 17 40 00
56 42 35 21 F0 1F 2A 00 00 00 00 00 00 00 00 00
00 00 00 00 7E 00 00 00 00 00 00 00 00 00 00 00
00 00 0A 00 09 04 00 00 00 00 00 00 E8 13 40 00
F4 13 40 00 00 F0 30 00 00 FF FF FF 08 00 00 00
01 00 00 00 00 00 00 00 E9 00 00 00 04 11 40 00
04 11 40 00 C8 10 40 00 78 00 00 00 7C 00 00 00
81 00 00 00 82 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 61 61 61 00 53 74 75 64
00 00 73 74 75 64 00 00 01 00 01 00 30 16 40 00
00 00 00 00 FF FF FF FF FF FF FF FF 00 00 00 00
B4 16 40 00 10 30 40 00 07 00 00 00 24 12 40 00
0E 00 20 00 00 00 00 00 1C 9E 21 00 EC 11 40 00
5C 10 40 00 E4 1A 40 00 2C 34 40 00 68 17 40 00
58 17 40 00 78 17 40 00 8C 17 40 00 8C 10 40 00
62 10 40 00 92 10 40 00 F8 1A 40 00 24 19 40 00
98 10 40 00 9E 10 40 00 77 04 18 FF 04 1C FF 05
00 00 24 01 00 0D 14 00 78 1C 40 00 48 21 40 00

SuckStop v1.11
14
EB ?? ?? ?? BE ?? ?? B4 30 CD 21 EB ?? 9B

SuperDAT
64
55 8B EC 6A FF 68 40 F3 42 00 68 A4 BF 42 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58
53 56 57 89 65 E8 FF 15 08 F2 42 00 33 D2 8A D4
89 15 60 42 43 00 8B C8 81 E1 FF 00 00 00 89 0D

SVK Protector v1.32 (Eng) -> Pavol Cerven
85
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 EB 05 B8
06 36 42 00 64 A0 23 00 00 00 EB 03 C7 84 E8 84
C0 EB 03 C7 84 E9 75 67 B9 49 00 00 00 8D B5 C5
02 00 00 56 80 06 44 46 E2 FA 8B 8D C1 02 00 00
5E 55 51 6A 00 56 FF 95 0C 61 00 00 59 5D 40 85
C0 75 3C 80 3E

SVK Protector v1.3x (Eng) -> Pavol Cerven
85
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 EB 05 B8
?? ?? 42 00 64 A0 23 00 00 00 EB 03 C7 84 E8 84
C0 EB 03 C7 84 E9 75 67 B9 49 00 00 00 8D B5 C5
02 00 00 56 80 06 44 46 E2 FA 8B 8D C1 02 00 00
5E 55 51 6A 00 56 FF 95 0C 61 00 00 59 5D 40 85
C0 75 3C 80 3E

SVK Protector V1.3X -> Pavol Cerven
255
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 EB 05 B8
?? ?? 42 00 64 A0 23 00 00 00 EB 03 C7 84 E8 84
C0 EB 03 C7 84 E9 75 67 B9 49 00 00 00 8D B5 C5
02 00 00 56 80 06 44 46 E2 FA 8B 8D C1 02 00 00
5E 55 51 6A 00 56 FF 95 0C 61 00 00 59 5D 40 85
C0 75 3C 80 3E 00 74 03 46 EB F8 46 E2 E3 8B C5
8B 4C 24 20 2B 85 BD 02 00 00 89 85 B9 02 00 00
80 BD B4 02 00 00 01 75 06 8B 8D 0C 61 00 00 89
8D B5 02 00 00 8D 85 0E 03 00 00 8B DD FF E0 55
68 10 10 00 00 8D 85 B4 00 00 00 50 8D 85 B4 01
00 00 50 6A 00 FF 95 18 61 00 00 5D 6A FF FF 95
10 61 00 00 44 65 62 75 67 67 65 72 20 6F 72 20
74 6F 6F 6C 20 66 6F 72 20 6D 6F 6E 69 74 6F 72
69 6E 67 20 64 65 74 65 63 74 65 64 21 21 21 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

SVK-Protector v1.051
35
60 EB 03 C7 84 E8 EB 03 C7 84 9A E8 00 00 00 00
5D 81 ED 10 00 00 00 EB 03 C7 84 E9 64 A0 23 00
00 00 EB

SVK-Protector v1.11
16
60 E8 ?? ?? ?? ?? 5D 81 ED 06 ?? ?? ?? 64 A0 23

SVK-Protector v1.32
23
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 EB 05 B8
06 36 42 00 64 A0 23

T-PACK v0.5c -m1
26
68 ?? ?? FD 60 BE ?? ?? BF ?? ?? B9 ?? ?? F3 A4
8B F7 BF ?? ?? FC 46 E9 8E FE

T-PACK v0.5c -m2
26
68 ?? ?? FD 60 BE ?? ?? BF ?? ?? B9 ?? ?? F3 A4
8B F7 BF ?? ?? FC 46 E9 CE FD

tElock 0.51 -> tE!
120
C1 EE 00 66 8B C9 EB 01 EB 60 EB 01 EB 9C E8 00
00 00 00 5E 83 C6 5E 8B FE 68 79 01 00 00 59 EB
01 EB AC 54 E8 03 00 00 00 5C EB 08 8D 64 24 04
FF 64 24 FC 6A 05 D0 2C 24 72 01 E8 01 24 24 5C
F7 DC EB 02 CD 20 8D 64 24 FE F7 DC EB 02 CD 20
FE C8 E8 00 00 00 00 32 C1 EB 02 82 0D AA EB 03
82 0D 58 EB 02 1D 7A 49 EB 05 E8 01 00 00 00 7F
AE 14 7E A0 77 76 75 74

tElock 0.96 -> tE!
120
E9 59 E4 FF FF 00 00 00 00 00 00 00 ?? ?? ?? ??
EE ?? ?? 00 00 00 00 00 00 00 00 00 0E ?? ?? 00
FE ?? ?? 00 F6 ?? ?? 00 00 00 00 00 00 00 00 00
1B ?? ?? 00 06 ?? ?? 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 26 ?? ?? 00
00 00 00 00 39 ?? ?? 00 00 00 00 00 26 ?? ?? 00
00 00 00 00 39 ?? ?? 00 00 00 00 00 6B 65 72 6E
65 6C 33 32 2E 64 6C 6C

tElock 0.98 -> tE!
120
E9 25 E4 FF FF 00 00 00 ?? ?? ?? ?? 1E ?? ?? 00
00 00 00 00 00 00 00 00 3E ?? ?? 00 2E ?? ?? 00
26 ?? ?? 00 00 00 00 00 00 00 00 00 4B ?? ?? 00
36 ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 56 ?? ?? 00 00 00 00 00
69 ?? ?? 00 00 00 00 00 56 ?? ?? 00 00 00 00 00
69 ?? ?? 00 00 00 00 00 6B 65 72 6E 65 6C 33 32
2E 64 6C 6C 00 75 73 65

tElock 0.98 Special Build -> forgot & heXer
25
E9 99 D7 FF FF 00 00 00 ?? ?? ?? ?? AA ?? ?? 00
00 00 00 00 00 00 00 00 CA

tElock 0.99 - 1.0 private -> tE!
24
E9 ?? ?? FF FF 00 00 00 ?? ?? ?? ?? ?? ?? ?? 00
00 00 00 00 00 00 00 00

tElock 0.99 -> tE!
25
E9 5E DF FF FF 00 00 00 ?? ?? ?? ?? E5 ?? ?? 00
00 00 00 00 00 00 00 00 05

tElock 0.99c (Private ECLIPSE) -> tE!
120
E9 3F DF FF FF 00 00 00 ?? ?? ?? ?? 04 ?? ?? 00
00 00 00 00 00 00 00 00 24 ?? ?? 00 14 ?? ?? 00
0C ?? ?? 00 00 00 00 00 00 00 00 00 31 ?? ?? 00
1C ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 3C ?? ?? 00 00 00 00 00
4F ?? ?? 00 00 00 00 00 3C ?? ?? 00 00 00 00 00
4F ?? ?? 00 00 00 00 00 6B 65 72 6E 65 6C 33 32
2E 64 6C 6C 00 75 73 65

tElock v0.41x
44
66 8B C0 8D 24 24 EB 01 EB 60 EB 01 EB 9C E8 00
00 00 00 5E 83 C6 50 8B FE 68 78 01 ?? ?? 59 EB
01 EB AC 54 E8 03 ?? ?? ?? 5C EB 08

tElock v0.42
39
C1 EE 00 66 8B C9 EB 01 EB 60 EB 01 EB 9C E8 00
00 00 00 5E 83 C6 52 8B FE 68 79 01 59 EB 01 EB
AC 54 E8 03 5C EB 08

tElock v0.4x - v0.5x
33
C1 EE 00 66 8B C9 EB 01 EB 60 EB 01 EB 9C E8 00
00 00 00 5E 83 C6 ?? 8B FE 68 79 01 ?? ?? 59 EB
01

tElock v0.51
39
C1 EE 00 66 8B C9 EB 01 EB 60 EB 01 EB 9C E8 00
00 00 00 5E 83 C6 5E 8B FE 68 79 01 59 EB 01 EB
AC 54 E8 03 5C EB 08

tElock v0.60
15
E9 00 00 00 00 60 E8 00 00 00 00 58 83 C0 08

tElock v0.70
14
60 E8 BD 10 00 00 C3 83 E2 00 F9 75 FA 70

tElock v0.71
8
60 E8 ED 10 00 00 C3 83

tElock v0.71b2
8
60 E8 44 11 00 00 C3 83

tElock v0.71b7
8
60 E8 48 11 00 00 C3 83

tElock v0.80
8
60 E8 F9 11 00 00 C3 83

tElock v0.85f
19
60 E8 02 00 00 00 CD 20 E8 00 00 00 00 5E 2B C9
58 74 02

tElock v0.90
16
?? ?? E8 02 00 00 00 E8 00 E8 00 00 00 00 5E 2B

tElock v0.98
13
E9 25 E4 FF FF 00 00 00 ?? ?? ?? ?? 1E

tElock v0.98 -> tE!
85
E9 25 E4 FF FF 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00
?? ?? ?? ?? 00

tElock v0.99
85
E9 ?? ?? FF FF 00 00 00 ?? ?? ?? ?? ?? ?? ?? 00
?? ?? ?? ?? ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00
?? ?? 02 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00
?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 00 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? 00 00 00 00 00
?? ?? 02 00 00

tElock v0.99 Special Build -> heXer & forgot
85
E9 5E DF FF FF 00 00 00 ?? ?? ?? ?? E5 ?? ?? 00
00 00 00 00 00 00 00 00 05 ?? ?? 00 F5 ?? ?? 00
ED ?? ?? 00 00 00 00 00 00 00 00 00 12 ?? ?? 00
FD ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 1D ?? ?? 00 00 00 00 00
30 ?? ?? 00 00

tElock v0.99 Special Build -> heXer & forgot
104
E9 5E DF FF FF 00 00 00 ?? ?? ?? ?? E5 ?? ?? 00
00 00 00 00 00 00 00 00 05 ?? ?? 00 F5 ?? ?? 00
ED ?? ?? 00 00 00 00 00 00 00 00 00 12 ?? ?? 00
FD ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 1D ?? ?? 00 00 00 00 00
30 ?? ?? 00 00 00 00 00 1D ?? ?? 00 00 00 00 00
30 ?? ?? 00 00 00 00 00

The Guard Library
29
50 E8 ?? ?? ?? ?? 58 25 ?? F0 FF FF 8B C8 83 C1
60 51 83 C0 40 83 EA 06 52 FF 20 9D C3

TheHyper's protector -> TheHyper
85
55 8B EC 83 EC 14 8B FC E8 14 00 00 00 ?? ?? 01
01 ?? ?? 01 01 ?? ?? ?? 00 ?? ?? 01 01 ?? ?? 02
01 5E E8 0D 00 00 00 6B 65 72 6E 65 6C 33 32 2E
64 6C 6C 00 8B 46 04 FF 10 8B D8 E8 0D 00 00 00
56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 53 8B 06
FF 10 89 07 E8

Themida -> Oreans Technologies 2004
30
B8 00 00 00 00 60 0B C0 74 58 E8 00 00 00 00 58
05 43 00 00 00 80 38 E9 75 03 61 EB 35 E8

themida 1.0.0.5 -> http://www.oreans.com
64
B8 00 00 00 00 60 0B C0 74 58 E8 00 00 00 00 58
05 43 00 00 00 80 38 E9 75 03 61 EB 35 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44

Themida 1.0.x.x - 1.8.0.0 (compressed engine) -> Oreans Technologies
83
B8 ?? ?? ?? ?? 60 0B C0 74 58 E8 00 00 00 00 58
05 43 00 00 00 80 38 E9 75 03 61 EB 35 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44
00 00 83 C3 67 39 1A 74 07 2D 00 10 00 00 EB DA
8B F8 B8

Themida 1.0.x.x - 1.8.0.0 (compressed engine) -> Oreans Technologies
144
B8 ?? ?? ?? ?? 60 0B C0 74 58 E8 00 00 00 00 58
05 43 00 00 00 80 38 E9 75 03 61 EB 35 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44
00 00 83 C3 67 39 1A 74 07 2D 00 10 00 00 EB DA
8B F8 B8 ?? ?? ?? ?? 03 C7 B9 5A ?? ?? ?? 03 CF
EB 0A B8 ?? ?? ?? ?? B9 5A ?? ?? ?? 50 51 E8 84
00 00 00 E8 00 00 00 00 58 2D 26 00 00 00 B9 EF
01 00 00 C6 00 E9 83 E9 05 89 48 01 61 E9 AF 01

Themida 1.0.x.x - 1.8.x.x (no compression) -> Oreans Technologies
85
55 8B EC 83 C4 D8 60 E8 00 00 00 00 5A 81 EA ??
?? ?? ?? 8B DA C7 45 D8 00 00 00 00 8B 45 D8 40
89 45 D8 81 7D D8 80 00 00 00 74 0F 8B 45 08 89
83 ?? ?? ?? ?? FF 45 08 43 EB E1 89 45 DC 61 8B
45 DC C9 C2 04 00 55 8B EC 81 C4 7C FF FF FF 60
E8 00 00 00 00

Themida 1.0.x.x - 1.8.x.x (no compression) -> Oreans Technologies
256
55 8B EC 83 C4 D8 60 E8 00 00 00 00 5A 81 EA ??
?? ?? ?? 8B DA C7 45 D8 00 00 00 00 8B 45 D8 40
89 45 D8 81 7D D8 80 00 00 00 74 0F 8B 45 08 89
83 ?? ?? ?? ?? FF 45 08 43 EB E1 89 45 DC 61 8B
45 DC C9 C2 04 00 55 8B EC 81 C4 7C FF FF FF 60
E8 00 00 00 00 5A 81 EA ?? ?? ?? ?? 8D 45 80 8B
5D 08 C7 85 7C FF FF FF 00 00 00 00 8B 8D 7C FF
FF FF D1 C3 88 18 41 89 8D 7C FF FF FF 81 BD 7C
FF FF FF 80 00 00 00 75 E3 C7 85 7C FF FF FF 00
00 00 00 8D BA ?? ?? ?? ?? 8D 75 80 8A 0E BB F4
01 00 00 B8 AB 37 54 78 D3 D0 8A 0F D3 D0 4B 75
F7 0F AF C3 47 46 8B 8D 7C FF FF FF 41 89 8D 7C
FF FF FF 81 F9 80 00 00 00 75 D1 61 C9 C2 04 00
55 8B EC 83 C4 F0 8B 75 08 C7 45 FC 00 00 00 00
EB 04 FF 45 FC 46 80 3E 00 75 F7 BA 00 00 00 00
8B 75 08 8B 7D 0C EB 7F C7 45 F8 00 00 00 00 EB

Themida 1.2.0.1 (compressed) -> Oreans Technologies
83
B8 00 00 ?? ?? 60 0B C0 74 58 E8 00 00 00 00 58
05 43 00 00 00 80 38 E9 75 03 61 EB 35 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44
00 00 83 C3 67 39 1A 74 07 2D 00 10 00 00 EB DA
8B F8 B8

Themida 1.2.0.1 -> Oreans Technologies
85
8B C5 8B D4 60 E8 00 00 00 00 5D 81 ED ?? ?? 35
09 89 95 ?? ?? 35 09 89 B5 ?? ?? 35 09 89 85 ??
?? 35 09 83 BD ?? ?? 35 09 00 74 0C 8B E8 8B E2
B8 01 00 00 00 C2 0C 00 8B 44 24 24 89 85 ?? ??
35 09 6A 45 E8 A3 00 00 00 68 9A 74 83 07 E8 DF
00 00 00 68 25

Themida 1.8.x.x -> Oreans Technologies
85
B8 ?? ?? ?? ?? 60 0B C0 74 68 E8 00 00 00 00 58
05 53 00 00 00 80 38 E9 75 13 61 EB 45 DB 2D 37
?? ?? ?? FF FF FF FF FF FF FF FF 3D 40 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44
00 00 83 C3 67

Themida 1.8.x.x -> Oreans Technologies
158
B8 ?? ?? ?? ?? 60 0B C0 74 68 E8 00 00 00 00 58
05 53 00 00 00 80 38 E9 75 13 61 EB 45 DB 2D 37
?? ?? ?? FF FF FF FF FF FF FF FF 3D 40 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB 19 5A 66 83
C3 34 66 39 18 75 12 0F B7 50 3C 03 D0 BB E9 44
00 00 83 C3 67 39 1A 74 07 2D 00 10 00 00 EB DA
8B F8 B8 ?? ?? ?? ?? 03 C7 B9 ?? ?? ?? ?? 03 CF
EB 0A B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? 50 51 E8 84
00 00 00 E8 00 00 00 00 58 2D 26 00 00 00 B9 EF
01 00 00 C6 00 E9 83 E9 05 89 48 01 61 E9

Themida/WinLicense V1.0.0.0-V1.8.0.0-> Oreans Technologies
34
B8 00 00 00 00 60 0B C0 74 58 E8 00 00 00 00 58
05 ?? 00 00 00 80 38 E9 75 ?? 61 EB ?? E8 00 00
00 00

Themida/WinLicense V1.0.X-V1.7.X DLL -> Oreans Technologies
142
B8 ?? ?? ?? ?? 60 0B C0 74 58 E8 00 00 00 00 58
05 ?? ?? ?? ?? 80 38 E9 75 03 61 EB 35 E8 00 00
00 00 58 25 00 F0 FF FF 33 FF 66 BB ?? ?? 66 83
?? ?? 66 39 18 75 12 0F B7 50 3C 03 D0 BB ?? ??
?? ?? 83 C3 ?? 39 1A 74 07 2D 00 10 00 00 EB DA
8B F8 B8 ?? ?? ?? ?? 03 C7 B9 ?? ?? ?? ?? 03 CF
EB 0A B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? 50 51 E8 84
00 00 00 E8 00 00 00 00 58 2D ?? ?? ?? ?? B9 ??
?? ?? ?? C6 00 E9 83 E9 ?? 89 48 01 61 E9

Themida/WinLicense V1.8.0.2 + -> Oreans Technologies
50
B8 00 00 00 00 60 0B C0 74 68 E8 00 00 00 00 58
05 ?? 00 00 00 80 38 E9 75 ?? 61 EB ?? DB 2D ??
?? ?? ?? FF FF FF FF FF FF FF FF 3D 40 E8 00 00
00 00

Themida/WinLicense V1.8.X-V1.9.X  -> Oreans Technologies
158
B8 ?? ?? ?? ?? 60 0B C0 74 68 E8 00 00 00 00 58
05 53 00 00 00 80 38 E9 75 13 61 EB 45 DB 2D ??
?? ?? ?? FF FF FF FF FF FF FF FF 3D ?? ?? ?? ??
00 00 58 25 00 F0 FF FF 33 FF 66 BB ?? ?? 66 83
?? ?? 66 39 18 75 12 0F B7 50 3C 03 D0 BB ?? ??
?? ?? 83 C3 ?? 39 1A 74 07 2D ?? ?? ?? ?? EB DA
8B F8 B8 ?? ?? ?? ?? 03 C7 B9 ?? ?? ?? ?? 03 CF
EB 0A B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? 50 51 E8 ??
?? ?? ?? E8 ?? ?? ?? ?? 58 2D ?? ?? ?? ?? B9 ??
?? ?? ?? C6 00 E9 83 E9 05 89 48 01 61 E9

Themida/WinLicense V1.X NoCompression SecureEngine -> Oreans Technologies
118
8B C5 8B D4 60 E8 00 00 00 00 5D 81 ED ?? ?? ??
?? 89 95 ?? ?? ?? ?? 89 B5 ?? ?? ?? ?? 89 85 ??
?? ?? ?? 83 BD ?? ?? ?? ?? ?? 74 0C 8B E8 8B E2
B8 01 00 00 00 C2 0C 00 8B 44 24 24 89 85 ?? ??
?? ?? 6A 45 E8 A3 00 00 00 68 9A 74 83 07 E8 DF
00 00 00 68 25 4B 89 0A E8 D5 00 00 00 E9 ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00

theWRAP - by TronDoc
256
55 8B EC 83 C4 F0 53 56 57 33 C0 89 45 F0 B8 48
D2 4B 00 E8 BC 87 F4 FF BB 04 0B 4D 00 33 C0 55
68 E8 D5 4B 00 64 FF 30 64 89 20 E8 9C F4 FF FF
E8 F7 FB FF FF 6A 40 8D 55 F0 A1 F0 ED 4B 00 8B
00 E8 42 2E F7 FF 8B 4D F0 B2 01 A1 F4 C2 40 00
E8 F7 20 F5 FF 8B F0 B2 01 A1 B4 C3 40 00 E8 F1
5B F4 FF 89 03 33 D2 8B 03 E8 42 1E F5 FF 66 B9
02 00 BA FC FF FF FF 8B C6 8B 38 FF 57 0C BA B8
A7 4D 00 B9 04 00 00 00 8B C6 8B 38 FF 57 04 83
3D B8 A7 4D 00 00 0F 84 5E 01 00 00 8B 15 B8 A7
4D 00 83 C2 04 F7 DA 66 B9 02 00 8B C6 8B 38 FF
57 0C 8B 0D B8 A7 4D 00 8B D6 8B 03 E8 2B 1F F5
FF 8B C6 E8 B4 5B F4 FF 33 D2 8B 03 E8 DF 1D F5
FF BA F0 44 4E 00 B9 01 00 00 00 8B 03 8B 30 FF
56 04 80 3D F0 44 4E 00 0A 75 3F BA B8 A7 4D 00
B9 04 00 00 00 8B 03 8B 30 FF 56 04 8B 15 B8 A7

Thinstall 2.4x - 2.5x -> Jitit Software
52
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D ?? ?? ?? ?? B9 ?? ?? ?? ?? BA ??
?? ?? ?? BE ?? ?? ?? ?? BF ?? ?? ?? ?? BD ?? ??
?? ?? 03 E8

Thinstall 2.5 -> ???
83
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D A7 1A 00 00 B9 6C 1A 00 00 BA 20
1B 00 00 BE 00 10 00 00 BF B0 53 00 00 BD EC 1A
00 00 03 E8 81 75 00 ?? ?? ?? ?? 81 75 04 ?? ??
?? ?? 81 75 08 ?? ?? ?? ?? 81 75 0C ?? ?? ?? ??
81 75 10

Thinstall 2.5xx -> Jtit
83
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D ?? 1A 00 00 B9 ?? 1A 00 00 BA ??
1B 00 00 BE 00 10 00 00 BF ?? 53 00 00 BD ?? 1A
00 00 03 E8 81 75 00 ?? ?? ?? ?? ?? 75 04 ?? ??
?? ?? 81 75 08 ?? ?? ?? ?? 81 75 0C ?? ?? ?? ??
81 75 10

Thinstall 2.5xx -> Jtit
138
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D ?? 1A 00 00 B9 ?? 1A 00 00 BA ??
1B 00 00 BE 00 10 00 00 BF ?? 53 00 00 BD ?? 1A
00 00 03 E8 81 75 00 ?? ?? ?? ?? ?? 75 04 ?? ??
?? ?? 81 75 08 ?? ?? ?? ?? 81 75 0C ?? ?? ?? ??
81 75 10 ?? ?? ?? ?? 03 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 3B
F1 7C 04 3B F2 7C 02 89 2E 83 C6 04 3B F7 7C E3
58 50 68 00 00 40 00 68 80 5A

Thinstall 2.628 -> Jtit
85
E8 00 00 00 00 58 BB 34 1D 00 00 2B C3 50 68 00
00 40 00 68 00 40 00 00 68 BC 00 00 00 E8 C3 FE
FF FF E9 99 FF FF FF CC CC CC CC CC CC CC CC CC
CC 55 8B EC 83 C4 F4 FC 53 57 56 8B 75 08 8B 7D
0C C7 45 FC 08 00 00 00 33 DB BA 00 00 00 80 43
33 C0 E8 19 01

Thinstall 2.628 -> Jtit
345
E8 00 00 00 00 58 BB 34 1D 00 00 2B C3 50 68 00
00 40 00 68 00 40 00 00 68 BC 00 00 00 E8 C3 FE
FF FF E9 99 FF FF FF CC CC CC CC CC CC CC CC CC
CC 55 8B EC 83 C4 F4 FC 53 57 56 8B 75 08 8B 7D
0C C7 45 FC 08 00 00 00 33 DB BA 00 00 00 80 43
33 C0 E8 19 01 00 00 73 0E 8B 4D F8 E8 27 01 00
00 02 45 F7 AA EB E9 E8 04 01 00 00 0F 82 96 00
00 00 E8 F9 00 00 00 73 5B B9 04 00 00 00 E8 05
01 00 00 48 74 DE 0F 89 C6 00 00 00 E8 DF 00 00
00 73 1B 55 BD 00 01 00 00 E8 DF 00 00 00 88 07
47 4D 75 F5 E8 C7 00 00 00 72 E9 5D EB A2 B9 01
00 00 00 E8 D0 00 00 00 83 C0 07 89 45 F8 C6 45
F7 00 83 F8 08 74 89 E8 B1 00 00 00 88 45 F7 E9
7C FF FF FF B9 07 00 00 00 E8 AA 00 00 00 50 33
C9 B1 02 E8 A0 00 00 00 8B C8 41 41 58 0B C0 74
04 8B D8 EB 5E 83 F9 02 74 6A 41 E8 88 00 00 00
89 45 FC E9 48 FF FF FF E8 87 00 00 00 49 E2 09
8B C3 E8 7D 00 00 00 EB 3A 49 8B C1 55 8B 4D FC
8B E8 33 C0 D3 E5 E8 5D 00 00 00 0B C5 5D 8B D8
E8 5F 00 00 00 3D 00 00 01 00 73 14 3D FF 37 00
00 73 0E 3D 7F 02 00 00 73 08 83 F8 7F 77 04 41
41 41 41 56 8B F7 2B F0 F3

Thinstall 2.736 -> Jitit
371
9C 60 E8 00 00 00 00 58 BB F3 1C 00 00 2B C3 50
68 00 00 40 00 68 00 26 00 00 68 CC 00 00 00 E8
C1 FE FF FF E9 97 FF FF FF CC CC CC CC CC CC CC
CC CC CC CC 55 8B EC 83 C4 F4 FC 53 57 56 8B 75
08 8B 7D 0C C7 45 FC 08 00 00 00 33 DB BA 00 00
00 80 43 33 C0 E8 19 01 00 00 73 0E 8B 4D F8 E8
27 01 00 00 02 45 F7 AA EB E9 E8 04 01 00 00 0F
82 96 00 00 00 E8 F9 00 00 00 73 5B B9 04 00 00
00 E8 05 01 00 00 48 74 DE 0F 89 C6 00 00 00 E8
DF 00 00 00 73 1B 55 BD 00 01 00 00 E8 DF 00 00
00 88 07 47 4D 75 F5 E8 C7 00 00 00 72 E9 5D EB
A2 B9 01 00 00 00 E8 D0 00 00 00 83 C0 07 89 45
F8 C6 45 F7 00 83 F8 08 74 89 E8 B1 00 00 00 88
45 F7 E9 7C FF FF FF B9 07 00 00 00 E8 AA 00 00
00 50 33 C9 B1 02 E8 A0 00 00 00 8B C8 41 41 58
0B C0 74 04 8B D8 EB 5E 83 F9 02 74 6A 41 E8 88
00 00 00 89 45 FC E9 48 FF FF FF E8 87 00 00 00
49 E2 09 8B C3 E8 7D 00 00 00 EB 3A 49 8B C1 55
8B 4D FC 8B E8 33 C0 D3 E5 E8 5D 00 00 00 0B C5
5D 8B D8 E8 5F 00 00 00 3D 00 00 01 00 73 14 3D
FF 37 00 00 73 0E 3D 7F 02 00 00 73 08 83 F8 7F
77 04 41 41 41 41 56 8B F7 2B F0 F3 A4 5E E9 F0
FE FF FF 33 C0 EB 05 8B C7 2B 45 0C 5E 5F 5B C9
C2 08 00

Thinstall 3.035 -> Jtit
85
9C 60 68 53 74 41 6C 68 54 68 49 6E E8 00 00 00
00 58 BB 37 1F 00 00 2B C3 50 68 ?? ?? ?? ?? 68
00 28 00 00 68 04 01 00 00 E8 BA FE FF FF E9 90
FF FF FF CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA 00

Thinstall 3.035 -> Jtit
431
9C 60 68 53 74 41 6C 68 54 68 49 6E E8 00 00 00
00 58 BB 37 1F 00 00 2B C3 50 68 ?? ?? ?? ?? 68
00 28 00 00 68 04 01 00 00 E8 BA FE FF FF E9 90
FF FF FF CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA 00 00 00 80 43 33 C0 E8 19 01 00 00
73 0E 8B 4D F8 E8 27 01 00 00 02 45 F7 AA EB E9
E8 04 01 00 00 0F 82 96 00 00 00 E8 F9 00 00 00
73 5B B9 04 00 00 00 E8 05 01 00 00 48 74 DE 0F
89 C6 00 00 00 E8 DF 00 00 00 73 1B 55 BD 00 01
00 00 E8 DF 00 00 00 88 07 47 4D 75 F5 E8 C7 00
00 00 72 E9 5D EB A2 B9 01 00 00 00 E8 D0 00 00
00 83 C0 07 89 45 F8 C6 45 F7 00 83 F8 08 74 89
E8 B1 00 00 00 88 45 F7 E9 7C FF FF FF B9 07 00
00 00 E8 AA 00 00 00 50 33 C9 B1 02 E8 A0 00 00
00 8B C8 41 41 58 0B C0 74 04 8B D8 EB 5E 83 F9
02 74 6A 41 E8 88 00 00 00 89 45 FC E9 48 FF FF
FF E8 87 00 00 00 49 E2 09 8B C3 E8 7D 00 00 00
EB 3A 49 8B C1 55 8B 4D FC 8B E8 33 C0 D3 E5 E8
5D 00 00 00 0B C5 5D 8B D8 E8 5F 00 00 00 3D 00
00 01 00 73 14 3D FF 37 00 00 73 0E 3D 7F 02 00
00 73 08 83 F8 7F 77 04 41 41 41 41 56 8B F7 2B
F0 F3 A4 5E E9 F0 FE FF FF 33 C0 EB 05 8B C7 2B
45 0C 5E 5F 5B C9 C2 08 00 03 D2 75 08 8B 16 83
C6 04 F9 13 D2 C3 B9 08 00 00 00 E8 01 00 00 00
C3 33 C0 E8 E1 FF FF FF 13 C0 E2 F7 C3 33 C9 41
E8 D4 FF FF FF 13 C9 E8 CD FF FF FF 72 F2 C3

Thinstall Embedded 1.9X -> Jitit
55
55 8B EC 51 53 56 57 6A 00 6A 00 FF 15 ?? ?? ??
?? 50 E8 87 FC FF FF 59 59 A1 ?? ?? ?? ?? 8B 40
10 03 05 ?? ?? ?? ?? 89 45 FC 8B 45 FC FF E0 5F
5E 5B C9 C3 00 00 00

Thinstall Embedded 2.0X -> Jitit
196
B8 EF BE AD DE 50 6A 00 FF 15 ?? ?? ?? ?? E9 AD
FF FF FF 8B C1 8B 4C 24 04 89 88 29 04 00 00 C7
40 0C 01 00 00 00 0F B6 49 01 D1 E9 89 48 10 C7
40 14 80 00 00 00 C2 04 00 8B 44 24 04 C7 41 0C
01 00 00 00 89 81 29 04 00 00 0F B6 40 01 D1 E8
89 41 10 C7 41 14 80 00 00 00 C2 04 00 55 8B EC
53 56 57 33 C0 33 FF 39 45 0C 8B F1 76 0C 8B 4D
08 03 3C 81 40 3B 45 0C 72 F4 8B CE E8 43 00 00
00 8B 46 14 33 D2 F7 F7 8B 5E 10 33 D2 8B F8 8B
C3 F7 F7 89 7E 18 89 45 0C 33 C0 33 C9 8B 55 08
03 0C 82 40 39 4D 0C 73 F4 48 8B 14 82 2B CA 0F
AF CF 2B D9 0F AF FA 89 7E 14 89 5E 10 5F 5E 5B
5D C2 08 00

Thinstall Embedded 2.2X-2.308 -> Jitit
196
B8 EF BE AD DE 50 6A 00 FF 15 ?? ?? ?? ?? E9 B9
FF FF FF 8B C1 8B 4C 24 04 89 88 29 04 00 00 C7
40 0C 01 00 00 00 0F B6 49 01 D1 E9 89 48 10 C7
40 14 80 00 00 00 C2 04 00 8B 44 24 04 C7 41 0C
01 00 00 00 89 81 29 04 00 00 0F B6 40 01 D1 E8
89 41 10 C7 41 14 80 00 00 00 C2 04 00 55 8B EC
53 56 57 33 C0 33 FF 39 45 0C 8B F1 76 0C 8B 4D
08 03 3C 81 40 3B 45 0C 72 F4 8B CE E8 43 00 00
00 8B 46 14 33 D2 F7 F7 8B 5E 10 33 D2 8B F8 8B
C3 F7 F7 89 7E 18 89 45 0C 33 C0 33 C9 8B 55 08
03 0C 82 40 39 4D 0C 73 F4 48 8B 14 82 2B CA 0F
AF CF 2B D9 0F AF FA 89 7E 14 89 5E 10 5F 5E 5B
5D C2 08 00

Thinstall Embedded 2.312 -> Jitit
196
6A 00 FF 15 ?? ?? ?? ?? E8 D4 F8 FF FF E9 E9 AD
FF FF FF 8B C1 8B 4C 24 04 89 88 29 04 00 00 C7
40 0C 01 00 00 00 0F B6 49 01 D1 E9 89 48 10 C7
40 14 80 00 00 00 C2 04 00 8B 44 24 04 C7 41 0C
01 00 00 00 89 81 29 04 00 00 0F B6 40 01 D1 E8
89 41 10 C7 41 14 80 00 00 00 C2 04 00 55 8B EC
53 56 57 33 C0 33 FF 39 45 0C 8B F1 76 0C 8B 4D
08 03 3C 81 40 3B 45 0C 72 F4 8B CE E8 43 00 00
00 8B 46 14 33 D2 F7 F7 8B 5E 10 33 D2 8B F8 8B
C3 F7 F7 89 7E 18 89 45 0C 33 C0 33 C9 8B 55 08
03 0C 82 40 39 4D 0C 73 F4 48 8B 14 82 2B CA 0F
AF CF 2B D9 0F AF FA 89 7E 14 89 5E 10 5F 5E 5B
5D C2 08 00

Thinstall Embedded 2.422-2.428 -> Jitit
83
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D 9B 1A 00 00 B9 84 1A 00 00 BA 14
1B 00 00 BE 00 10 00 00 BF B0 53 00 00 BD E0 1A
00 00 03 E8 81 75 00 ?? ?? ?? ?? 81 75 04 ?? ??
?? ?? 81 75 08 ?? ?? ?? ?? 81 75 0C ?? ?? ?? ??
81 75 10

Thinstall Embedded 2.501 -> Jitit
83
55 8B EC B8 ?? ?? ?? ?? BB ?? ?? ?? ?? 50 E8 00
00 00 00 58 2D A8 1A 00 00 B9 6D 1A 00 00 BA 21
1B 00 00 BE 00 10 00 00 BF C0 53 00 00 BD F0 1A
00 00 03 E8 81 75 00 ?? ?? ?? ?? 81 75 04 ?? ??
?? ?? 81 75 08 ?? ?? ?? ?? 81 75 0C ?? ?? ?? ??
81 75 10

Thinstall Embedded 2.545 -> Jitit
32
E8 F2 FF FF FF 50 68 ?? ?? ?? ?? 68 40 1B 00 00
E8 42 FF FF FF E9 9D FF FF FF 00 00 00 00 00 00

Thinstall Embedded 2.547-V2.600 -> Jitit
41
E8 00 00 00 00 58 BB BC 18 00 00 2B C3 50 68 ??
?? ?? ?? 68 60 1B 00 00 68 60 00 00 00 E8 35 FF
FF FF E9 99 FF FF FF 00 00

Thinstall Embedded 2.609 -> Jitit
40
E8 00 00 00 00 58 BB AD 19 00 00 2B C3 50 68 ??
?? ?? ?? 68 B0 1C 00 00 68 80 00 00 00 E8 35 FF
FF FF E9 99 FF FF FF 00

Thinstall Embedded 2.620-2.623 -> Jitit
41
E8 00 00 00 00 58 BB AC 1E 00 00 2B C3 50 68 ??
?? ?? ?? 68 B0 21 00 00 68 C4 00 00 00 E8 C3 FE
FF FF E9 99 FF FF FF 00 00

Thinstall Embedded 2.717-2.719 -> Jitit
362
9C 60 E8 00 00 00 00 58 BB ?? ?? ?? ?? 2B C3 50
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8
C1 FE FF FF E9 97 FF FF FF CC CC 55 8B EC 83 C4
F4 FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00
00 00 33 DB BA 00 00 00 80 43 33 C0 E8 19 01 00
00 73 0E 8B 4D F8 E8 27 01 00 00 02 45 F7 AA EB
E9 E8 04 01 00 00 0F 82 96 00 00 00 E8 F9 00 00
00 73 5B B9 04 00 00 00 E8 05 01 00 00 48 74 DE
0F 89 C6 00 00 00 E8 DF 00 00 00 73 1B 55 BD 00
01 00 00 E8 DF 00 00 00 88 07 47 4D 75 F5 E8 C7
00 00 00 72 E9 5D EB A2 B9 01 00 00 00 E8 D0 00
00 00 83 C0 07 89 45 F8 C6 45 F7 00 83 F8 08 74
89 E8 B1 00 00 00 88 45 F7 E9 7C FF FF FF B9 07
00 00 00 E8 AA 00 00 00 50 33 C9 B1 02 E8 A0 00
00 00 8B C8 41 41 58 0B C0 74 04 8B D8 EB 5E 83
F9 02 74 6A 41 E8 88 00 00 00 89 45 FC E9 48 FF
FF FF E8 87 00 00 00 49 E2 09 8B C3 E8 7D 00 00
00 EB 3A 49 8B C1 55 8B 4D FC 8B E8 33 C0 D3 E5
E8 5D 00 00 00 0B C5 5D 8B D8 E8 5F 00 00 00 3D
00 00 01 00 73 14 3D FF 37 00 00 73 0E 3D 7F 02
00 00 73 08 83 F8 7F 77 04 41 41 41 41 56 8B F7
2B F0 F3 A4 5E E9 F0 FE FF FF 33 C0 EB 05 8B C7
2B 45 0C 5E 5F 5B C9 C2 08 00

Thinstall V2.403 -> Jitit
85
6A 00 FF 15 20 50 40 00 E8 D4 F8 FF FF E9 E9 AD
FF FF FF 8B C1 8B 4C 24 04 89 88 29 04 00 00 C7
40 0C 01 00 00 00 0F B6 49 01 D1 E9 89 48 10 C7
40 14 80 00 00 00 C2 04 00 8B 44 24 04 C7 41 0C
01 00 00 00 89 81 29 04 00 00 0F B6 40 01 D1 E8
89 41 10 C7 41

Thinstall V2.403 -> Jitit
255
6A 00 FF 15 20 50 40 00 E8 D4 F8 FF FF E9 E9 AD
FF FF FF 8B C1 8B 4C 24 04 89 88 29 04 00 00 C7
40 0C 01 00 00 00 0F B6 49 01 D1 E9 89 48 10 C7
40 14 80 00 00 00 C2 04 00 8B 44 24 04 C7 41 0C
01 00 00 00 89 81 29 04 00 00 0F B6 40 01 D1 E8
89 41 10 C7 41 14 80 00 00 00 C2 04 00 55 8B EC
53 56 57 33 C0 33 FF 39 45 0C 8B F1 76 0C 8B 4D
08 03 3C 81 40 3B 45 0C 72 F4 8B CE E8 43 00 00
00 8B 46 14 33 D2 F7 F7 8B 5E 10 33 D2 8B F8 8B
C3 F7 F7 89 7E 18 89 45 0C 33 C0 33 C9 8B 55 08
03 0C 82 40 39 4D 0C 73 F4 48 8B 14 82 2B CA 0F
AF CF 2B D9 0F AF FA 89 7E 14 89 5E 10 5F 5E 5B
5D C2 08 00 57 BF 00 00 80 00 39 79 14 77 36 53
56 8B B1 29 04 00 00 8B 41 0C 8B 59 10 03 DB 8A
14 30 83 E2 01 0B D3 C1 E2 07 40 89 51 10 89 41
0C 0F B6 04 30 C1 61 14 08 D1 E8 09 41 10 39

Thinstall v2.460 -> Jitit
64
55 8B EC 51 53 56 57 6A 00 6A 00 FF 15 F4 18 40
00 50 E8 87 FC FF FF 59 59 A1 94 1A 40 00 8B 40
10 03 05 90 1A 40 00 89 45 FC 8B 45 FC FF E0 5F
5E 5B C9 C3 00 00 00 76 0C 00 00 D4 0C 00 00 1E

Thinstall V2.7X -> Jitit
37
9C 60 E8 00 00 00 00 58 BB ?? ?? ?? ?? 2B C3 50
68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8
?? ?? ?? ?? E9

Thinstall Virtualization Suite 3.035-3.043 -> Thinstall Company
182
9C 60 68 53 74 41 6C 68 54 68 49 6E E8 00 00 00
00 58 BB 37 1F 00 00 2B C3 50 68 ?? ?? ?? ?? 68
00 28 00 00 68 04 01 00 00 E8 BA FE FF FF E9 90
FF FF FF CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA 00 00 00 80 43 33 C0 E8 19 01 00 00
73 0E 8B 4D F8 E8 27 01 00 00 02 45 F7 AA EB E9
E8 04 01 00 00 0F 82 96 00 00 00 E8 F9 00 00 00
73 5B B9 04 00 00 00 E8 05 01 00 00 48 74 DE 0F
89 C6 00 00 00 E8 DF 00 00 00 73 1B 55 BD 00 01
00 00 E8 DF 00 00 00 88 07 47 4D 75 F5 E8 C7 00
00 00 72 E9 5D EB

Thinstall Virtualization Suite 3.049-3.080 -> Thinstall Company
85
9C 60 68 53 74 41 6C 68 54 68 49 6E E8 00 00 00
00 58 BB 37 1F 00 00 2B C3 50 68 ?? ?? ?? ?? 68
00 2C 00 00 68 04 01 00 00 E8 BA FE FF FF E9 90
FF FF FF CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA 00

Thinstall Virtualization Suite 3.049-3.080 -> Thinstall Company
182
9C 60 68 53 74 41 6C 68 54 68 49 6E E8 00 00 00
00 58 BB 37 1F 00 00 2B C3 50 68 ?? ?? ?? ?? 68
00 2C 00 00 68 04 01 00 00 E8 BA FE FF FF E9 90
FF FF FF CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA 00 00 00 80 43 33 C0 E8 19 01 00 00
73 0E 8B 4D F8 E8 27 01 00 00 02 45 F7 AA EB E9
E8 04 01 00 00 0F 82 96 00 00 00 E8 F9 00 00 00
73 5B B9 04 00 00 00 E8 05 01 00 00 48 74 DE 0F
89 C6 00 00 00 E8 DF 00 00 00 73 1B 55 BD 00 01
00 00 E8 DF 00 00 00 88 07 47 4D 75 F5 E8 C7 00
00 00 72 E9 5D EB

Thinstall Virtualization Suite 3.0X -> Thinstall Company
84
9C 60 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8 00 00 00
00 58 BB ?? ?? ?? ?? 2B C3 50 68 ?? ?? ?? ?? 68
?? ?? ?? ?? 68 ?? ?? ?? ?? E8 BA FE FF FF E9 ??
?? ?? ?? CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA

Thinstall Virtualization Suite 3.0X -> Thinstall Company
182
9C 60 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? E8 00 00 00
00 58 BB ?? ?? ?? ?? 2B C3 50 68 ?? ?? ?? ?? 68
?? ?? ?? ?? 68 ?? ?? ?? ?? E8 BA FE FF FF E9 ??
?? ?? ?? CC CC CC CC CC CC CC 55 8B EC 83 C4 F4
FC 53 57 56 8B 75 08 8B 7D 0C C7 45 FC 08 00 00
00 33 DB BA ?? ?? ?? ?? 43 33 C0 E8 19 01 00 00
73 0E 8B 4D F8 E8 27 01 00 00 02 45 F7 AA EB E9
E8 04 01 00 00 0F 82 96 00 00 00 E8 F9 00 00 00
73 5B B9 04 00 00 00 E8 05 01 00 00 48 74 DE 0F
89 ?? ?? ?? ?? E8 DF 00 00 00 73 1B 55 BD ?? ??
?? ?? E8 DF 00 00 00 88 07 47 4D 75 F5 E8 C7 00
00 00 72 E9 5D EB

Thinstall vx.x
19
B8 EF BE AD DE 50 6A ?? FF 15 10 19 40 ?? E9 AD
FF FF FF

TMT-Pascal v0.40
22
0E 1F 06 8C 06 ?? ?? 26 A1 ?? ?? A3 ?? ?? 8E C0
66 33 FF 66 33 C9

TopSpeed v3.01 1989
20
1E BA ?? ?? 8E DA 8B ?? ?? ?? 8B ?? ?? ?? FF ??
?? ?? 50 53

TPPpack -> clane
16
E8 00 00 00 00 5D 81 ED F5 8F 40 00 60 33 ?? E8

Trainer Creation Kit v5 Trainer
85
6A 00 68 80 00 00 00 6A 02 6A 00 6A 00 68 00 00
00 40 68 25 45 40 00 E8 3C 02 00 00 50 6A 00 68
40 45 40 00 68 00 10 00 00 68 00 30 40 00 50 E8
54 02 00 00 58 50 E8 17 02 00 00 6A 00 E8 2E 02
00 00 A3 70 45 40 00 68 25 45 40 00 E8 2B 02 00
00 A3 30 45 40

Trivial173 by SMT/SMF
26
EB ?? ?? 28 54 72 69 76 69 61 6C 31 37 33 20 62
79 20 53 4D 54 2F 53 4D 46 29

UG2002 Cruncher v0.3b3
32
60 E8 ?? ?? ?? ?? 5D 81 ED ?? ?? ?? ?? E8 0D ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 58

UltraPro V1.0 -> SafeNet
27
A1 ?? ?? ?? ?? 85 C0 0F 85 3B 06 00 00 55 56 C7
05 ?? ?? ?? ?? 01 00 00 00 FF 15

UnderGround Crypter - by Booster2000
28
55 8B EC 83 C4 F0 B8 74 3C 00 11 E8 94 F9 FF FF
E8 BF FE FF FF E8 0A F3 FF FF 8B C0

Unknown by SMT
17
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 83 ?? ?? 57
EB

Unknown Joiner (sign from pinch 26.03.2007 02:12)
63
44 90 4C 90 B9 DE 00 00 00 BA 00 10 40 00 83 C2
03 44 90 4C B9 07 00 00 00 44 90 4C 33 C9 C7 05
08 30 40 00 00 00 00 00 90 68 00 01 00 00 68 21
30 40 00 6A 00 E8 C5 02 00 00 90 6A 00 68 80

Unnamed Scrambler 1.0 -> p0ke
222
55 8B EC 83 C4 EC 53 56 33 C0 89 45 ?? ?? ?? ??
40 00 E8 11 F4 FF FF BE 30 6B 40 00 33 C0 55 68
C9 42 40 00 64 FF 30 64 89 20 E8 C9 FA FF FF BA
D8 42 40 00 8B ?? ?? ?? ?? FF FF 8B D8 B8 28 6B
40 00 8B 16 E8 37 F0 FF FF B8 2C 6B 40 00 8B 16
E8 2B F0 FF FF B8 28 6B 40 00 E8 19 F0 FF FF 8B
D0 8B C3 8B 0E E8 42 E3 FF FF BA DC 42 40 00 8B
C6 E8 2A FA FF FF 8B D8 B8 20 6B 40 00 8B 16 E8
FC EF FF FF B8 24 6B 40 00 8B 16 E8 F0 EF FF FF
B8 20 6B 40 00 E8 DE EF FF FF 8B D0 8B C3 8B 0E
E8 07 E3 FF FF 6A 00 6A 19 6A 00 6A 32 A1 28 6B
40 00 E8 59 EF FF FF 83 E8 05 03 C0 8D 55 EC E8
94 FE FF FF 8B 55 EC B9 24 6B 40 00 A1 20 6B 40
00 E8 E2 F6 FF FF 6A 00 6A 19 6A 00 6A 32

Unnamed Scrambler 1.1C -> p0ke
227
55 8B EC 83 C4 E4 53 56 33 C0 89 45 E4 89 45 E8
89 45 EC B8 C0 47 00 10 E8 4F F3 FF FF BE 5C 67
00 10 33 C0 55 68 D2 4A 00 10 64 FF 30 64 89 20
E8 EB DE FF FF E8 C6 F8 FF FF BA E0 4A 00 10 B8
CC 67 00 10 E8 5F F8 FF FF 8B D8 8B D6 8B C3 8B
0D CC 67 00 10 E8 3A DD FF FF 8B 46 50 8B D0 B8
D4 67 00 10 E8 5B EF FF FF B8 D4 67 00 10 E8 09
EF FF FF 8B D0 8D 46 14 8B 4E 50 E8 14 DD FF FF
8B 46 48 8B D0 B8 D8 67 00 ?? ?? ?? ?? ?? FF B8
D8 67 00 10 E8 E3 EE FF FF 8B D0 8B C6 8B 4E 48
E8 EF DC FF FF FF 76 5C FF 76 58 FF 76 64 FF 76
60 B9 D4 67 00 10 8B 15 D8 67 00 10 A1 D4 67 00
10 E8 76 F6 FF FF A1 D4 67 00 10 E8 5C EE FF FF
8B D0 B8 CC 67 00 10 E8 CC F7 FF FF 8B D8 B8 DC
67 00 10

Unnamed Scrambler 1.2B -> p0ke
220
55 8B EC 83 C4 D8 53 56 57 33 C0 89 45 D8 89 45
DC 89 45 E0 89 45 E4 89 45 E8 B8 70 3A 40 00 E8
C4 EC FF FF 33 C0 55 68 5C 3F 40 00 64 FF 30 64
89 20 E8 C5 D7 FF FF E8 5C F5 FF FF B8 20 65 40
00 33 C9 BA 04 01 00 00 E8 D3 DB FF FF 68 04 01
00 00 68 20 65 40 00 6A 00 FF 15 10 55 40 00 BA
6C 3F 40 00 B8 14 55 40 00 E8 5A F4 FF FF 85 C0
0F 84 1B 04 00 00 BA 18 55 40 00 8B 0D 14 55 40
00 E8 16 D7 FF FF 8B 05 88 61 40 00 8B D0 B8 54
62 40 00 E8 D4 E3 FF FF B8 54 62 40 00 E8 F2 E2
FF FF 8B D0 B8 18 55 40 00 8B 0D 88 61 40 00 E8
E8 D6 FF FF FF 35 34 62 40 00 FF 35 30 62 40 00
FF 35 3C 62 40 00 FF 35 38 62 40 00 8D 55 E8 A1
88 61 40 00 E8 E3 F0 FF FF 8B 55 E8

Unnamed Scrambler 1.2C / 1.2D -> p0ke
215
55 8B EC B9 05 00 00 00 6A 00 6A 00 49 75 F9 51
53 56 57 B8 ?? 3A ?? ?? E8 ?? EC FF FF 33 C0 55
68 ?? ?? ?? ?? 64 FF 30 64 89 20 E8 ?? D7 FF FF
E8 ?? ?? FF FF B8 20 ?? ?? ?? 33 C9 BA 04 01 00
00 E8 ?? DB FF FF 68 04 01 00 00 68 20 ?? ?? ??
6A 00 FF 15 10 ?? ?? ?? BA ?? ?? ?? ?? B8 14 ??
?? ?? E8 ?? ?? FF FF 85 C0 0F 84 ?? 04 00 00 BA
18 ?? ?? ?? 8B 0D 14 ?? ?? ?? E8 ?? ?? FF FF 8B
05 88 ?? ?? ?? 8B D0 B8 54 ?? ?? ?? E8 ?? E3 FF
FF B8 54 ?? ?? ?? E8 ?? E2 FF FF 8B D0 B8 18 ??
?? ?? 8B 0D 88 ?? ?? ?? E8 ?? D6 FF FF FF 35 34
?? ?? ?? FF 35 30 ?? ?? ?? FF 35 3C ?? ?? ?? FF
35 38 ?? ?? ?? 8D 55 E8 A1 88 ?? ?? ?? E8 ?? F0
FF FF 8B 55 E8 B9 54

Unnamed Scrambler 1.3B -> p0ke
204
55 8B EC B9 08 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 98 56 00 10 E8 48 EB FF FF 33 C0 55 68
AC 5D 00 10 64 FF 30 64 89 20 6A 00 68 BC 5D 00
10 68 C4 5D 00 10 6A 00 E8 23 EC FF FF E8 C6 CE
FF FF 6A 00 68 BC 5D 00 10 68 ?? ?? ?? ?? 6A 00
E8 0B EC FF FF E8 F2 F4 FF FF B8 08 BC 00 10 33
C9 BA 04 01 00 00 E8 C1 D2 FF FF 6A 00 68 BC 5D
00 10 68 E4 5D 00 10 6A 00 E8 E2 EB FF FF 68 04
01 00 00 68 08 BC 00 10 6A 00 FF 15 68 77 00 10
6A 00 68 BC 5D 00 10 68 FC 5D 00 10 6A 00 E8 BD
EB FF FF BA 10 5E 00 10 B8 70 77 00 10 E8 CA F3
FF FF 85 C0 0F 84 F7 05 00 00 BA 74 77 00 10 8B
0D 70 77 00 10 E8 FE CD FF FF 6A 00

Unnamed Scrambler 2.0 -> p0ke
232
55 8B EC B9 0A 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 1C 2F 40 00 E8 C8 F1 FF FF 33 C0 55 68
FB 33 40 00 64 FF 30 64 89 20 BA 0C 34 40 00 B8
E4 54 40 00 E8 EF FE FF FF 8B D8 85 DB 75 07 6A
00 E8 5A F2 FF FF BA E8 54 40 00 8B C3 8B 0D E4
54 40 00 E8 74 E2 FF FF C7 05 20 6B 40 00 09 00
00 00 BB 98 69 40 00 C7 45 EC E8 54 40 00 C7 45
E8 31 57 40 00 C7 45 E4 43 60 40 00 BE D3 6A 40
00 BF E0 6A 40 00 83 7B 04 00 75 0B 83 3B 00 0F
86 AA 03 00 00 EB 06 0F 8E A2 03 00 00 8B 03 8B
D0 B8 0C 6B 40 00 E8 C1 EE FF FF B8 0C 6B 40 00
E8 6F EE FF FF 8B D0 8B 45 EC 8B 0B E8 0B E2 FF
FF 6A 00 6A 1E 6A 00 6A 2C A1 0C 6B 40 00 E8 25
ED FF FF 8D 55 E0 E8 15 FE FF FF 8B 55 E0 B9 10
6B 40 00 A1 0C 6B 40 00

Unnamed Scrambler 2.1(Beta) / 2.1.1 -> p0ke
226
55 8B EC B9 15 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 ?? 3A ?? ?? E8 ?? EE FF FF 33 C0 55 68
?? 43 ?? ?? 64 FF 30 64 89 20 BA ?? 43 ?? ?? B8
E4 64 ?? ?? E8 0F FD FF FF 8B D8 85 DB 75 07 6A
00 E8 ?? EE FF FF BA E8 64 ?? ?? 8B C3 8B 0D E4
64 ?? ?? E8 ?? D7 FF FF B8 F8 ?? ?? ?? BA 04 00
00 00 E8 ?? EF FF FF 33 C0 A3 F8 ?? ?? ?? BB ??
?? ?? ?? C7 45 EC E8 64 ?? ?? C7 45 E8 ?? ?? ??
?? C7 45 E4 ?? ?? ?? ?? BE ?? ?? ?? ?? BF ?? ??
?? ?? B8 E0 ?? ?? ?? BA 04 00 00 00 E8 ?? EF FF
FF 68 F4 01 00 00 E8 ?? EE FF FF 83 7B 04 00 75
0B 83 3B 00 0F 86 ?? 07 00 00 EB 06 0F 8E ?? 07
00 00 8B 03 8B D0 B8 E4 ?? ?? ?? E8 ?? E5 FF FF
B8 E4 ?? ?? ?? E8 ?? E3 FF FF 8B D0 8B 45 EC 8B
0B E8

Unnamed Scrambler 2.5.1(Beta 2) / 2.5.2 -> p0ke
230
55 8B EC B9 ?? 00 00 00 6A 00 6A 00 49 75 F9 53
56 57 B8 ?? ?? 40 00 E8 ?? EA FF FF 33 C0 55 68
?? ?? 40 00 64 FF 30 64 89 20 BA ?? ?? 40 00 B8
?? ?? 40 00 E8 63 F3 FF FF 8B D8 85 DB 75 07 6A
00 E8 ?? ?? FF FF BA ?? ?? 40 00 8B C3 8B 0D ??
?? 40 00 E8 ?? ?? FF FF C7 05 ?? ?? 40 00 0A 00
00 00 BB ?? ?? 40 00 BE ?? ?? 40 00 BF ?? ?? 40
00 B8 ?? ?? 40 00 BA 04 00 00 00 E8 ?? EB FF FF
83 3B 00 74 04 33 C0 89 03 8B D7 8B C6 E8 0A F3
FF FF 89 03 83 3B 00 0F 84 F7 04 00 00 B8 ?? ??
40 00 8B 16 E8 ?? E1 FF FF B8 ?? ?? 40 00 E8 ??
E0 FF FF 8B D0 8B 03 8B 0E E8 ?? ?? FF FF 8B C7
A3 ?? ?? 40 00 8D 55 EC 33 C0 E8 ?? D3 FF FF 8B
45 EC B9 ?? ?? 40 00 BA ?? ?? 40 00 E8 8B ED FF
FF 3C 01 75 2B A1

Unnamed Scrambler 2.5A -> p0ke
221
55 8B EC B9 0B 00 00 00 6A 00 6A 00 49 75 F9 51
53 56 57 B8 6C 3E 40 00 E8 F7 EA FF FF 33 C0 55
68 60 44 40 00 64 FF 30 64 89 20 BA 70 44 40 00
B8 B8 6C 40 00 E8 62 F3 FF FF 8B D8 85 DB 75 07
6A 00 E8 A1 EB FF FF BA E8 64 40 00 8B C3 8B 0D
B8 6C 40 00 E8 37 D3 FF FF C7 05 BC 6C 40 00 0A
00 00 00 BB 68 6C 40 00 BE 90 6C 40 00 BF E8 64
40 00 B8 C0 6C 40 00 BA 04 00 00 00 E8 07 EC FF
FF 83 3B 00 74 04 33 C0 89 03 8B D7 8B C6 E8 09
F3 FF FF 89 03 83 3B 00 0F 84 BB 04 00 00 B8 C0
6C 40 00 8B 16 E8 06 E2 FF FF B8 C0 6C 40 00 E8
24 E1 FF FF 8B D0 8B 03 8B 0E E8 D1 D2 FF FF 8B
C7 A3 20 6E 40 00 8D 55 EC 33 C0 E8 0C D4 FF FF
8B 45 EC B9 1C 6E 40 00 BA 18 6E 40 00

UnoPiX 0.75 -> BaGiE
31
60 E8 07 00 00 00 61 68 ?? ?? 40 00 C3 83 04 24
18 C3 20 83 B8 ED 20 37 EF C6 B9 79 37 9E 61

UnoPiX 1.03-1.10 -> BaGiE
89
83 EC 04 C7 04 24 00 ?? ?? ?? C3 00 ?? ?? 00 00
00 00 00 00 00 00 00 00 00 00 ?? ?? 00 10 00 00
00 02 00 00 01 00 00 00 00 00 00 00 04 00 00 00
00 00 00 00 00 ?? ?? 00 00 10 00 00 00 00 00 00
02 00 00 ?? 00 00 ?? 00 00 ?? ?? 00 00 00 10 00
00 10 00 00 00 00 00 00 10

Unpacked BS-SFX Archive v1.9
24
1E 33 C0 50 B8 ?? ?? 8E D8 FA 8E D0 BC ?? ?? FB
B8 ?? ?? CD 21 3C 03 73

Upack 0.10 - 0.12 beta -> Dwing
64
BE 48 01 40 00 AD 8B F8 95 A5 33 C0 33 C9 AB 48
AB F7 D8 B1 04 F3 AB C1 E0 0A B5 ?? F3 AB AD 50
97 51 AD 87 F5 58 8D 54 86 5C FF D5 72 5A 2C 03
73 02 B0 00 3C 07 72 02 2C 03 50 0F B6 5F FF C1

Upack 0.12 beta-->Dwing
64
BE 48 01 40 00 AD ?? ?? ?? A5 ?? C0 33 C9 ?? ??
?? ?? ?? ?? ?? F3 AB ?? ?? 0A ?? ?? ?? ?? AD 50
97 51 ?? 87 F5 58 8D 54 86 5C ?? D5 72 ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? B6 5F FF C1

Upack 0.20 beta -> Dwing
64
BE 88 01 40 00 AD 8B F8 95 A5 33 C0 33 C9 AB 48
AB F7 D8 B1 04 F3 AB C1 E0 0A B5 ?? F3 AB AD 50
97 51 58 8D 54 85 5C FF 16 72 5A 2C 03 73 02 B0
00 3C 07 72 02 2C 03 50 0F B6 5F FF C1 E3 ?? B3

Upack 0.21 beta -> Dwing
64
BE 88 01 40 00 AD 8B F8 6A 04 95 A5 33 C0 AB 48
AB F7 D8 59 F3 AB C1 E0 0A B5 ?? F3 AB AD 50 97
51 58 8D 54 85 5C FF 16 72 5A 2C 03 73 02 B0 00
3C 07 72 02 2C 03 50 0F B6 5F FF C1 E3 ?? B3 00

Upack 0.22 - 0.23 beta -> Dwing
26
6A 07 BE 88 01 40 00 AD 8B F8 59 95 F3 A5 AD B5
?? F3 AB AD 50 97 51 58 8D 54

Upack 0.22 - 0.23 beta -> Dwing
64
6A 07 BE 88 01 40 00 AD 8B F8 59 95 F3 A5 AD B5
?? F3 AB AD 50 97 51 58 8D 54 85 5C FF 16 72 59
2C 03 73 02 B0 00 3C 07 72 02 2C 03 50 0F B6 5F
FF C1 E3 ?? B3 00 8D 1C 5B 8D 9C 9D 0C 10 00 00

Upack 0.22 - 0.23 beta -> Dwing
64
?? ?? ?? ?? ?? ?? ?? AD 8B F8 59 95 F3 A5 AD B5
?? F3 AB AD 50 97 51 58 8D 54 85 5C FF 16 72 ??
2C 03 73 02 B0 00 3C 07 72 02 2C 03 50 0F B6 5F
FF C1 E3 ?? B3 00 8D 1C 5B 8D 9C 9D 0C 10 00 00

Upack 0.24 - 0.27 beta / 0.28 alpha -> Dwing
64
BE 88 01 40 00 AD 8B F8 95 AD 91 F3 A5 AD B5 ??
F3 AB AD 50 97 51 58 8D 54 85 5C FF 16 72 57 2C
03 73 02 B0 00 3C 07 72 02 2C 03 50 0F B6 5F FF
C1 E3 ?? B3 00 8D 1C 5B 8D 9C 9D 0C 10 00 00 B0

UPack Alt Stub -> Dwing
30
60 E8 09 00 00 00 C3 F6 00 00 E9 06 02 00 00 33
C9 5E 87 0E E3 F4 2B F1 8B DE AD 2B D8 AD

Upack v0.10 - v0.12 Beta -> Dwing
12
BE 48 01 ?? ?? ?? ?? ?? 95 A5 33 C0

Upack V0.10-V0.11 -> Dwing
107
BE ?? ?? ?? ?? AD 8B F8 95 A5 33 C0 33 C9 AB 48
AB F7 D8 B1 ?? F3 AB C1 E0 ?? B5 ?? F3 AB AD 50
97 51 AD 87 F5 58 8D 54 86 5C FF D5 72 5A 2C ??
73 ?? B0 ?? 3C ?? 72 02 2C ?? 50 0F B6 5F FF C1
E3 ?? B3 ?? 8D 1C 5B 8D ?? ?? ?? ?? ?? ?? B0 ??
67 E3 29 8B D7 2B 56 0C 8A 2A 33 D2 84 E9 0F 95
C6 52 FE C6 8A D0 8D 14 93 FF D5

UPack v0.11 -> Dwing
85
BE 48 01 40 00 AD 8B F8 95 A5 33 C0 33 C9 AB 48
AB F7 D8 B1 04 F3 AB C1 E0 0A B5 1C F3 AB AD 50
97 51 AD 87 F5 58 8D 54 86 5C FF D5 72 5A 2C 03
73 02 B0 00 3C 07 72 02 2C 03 50 0F B6 5F FF C1
E3 03 B3 00 8D 1C 5B 8D 9C 9E 0C 10 00 00 B0 01
67 E3 29 8B D7

Upack v0.1x - v0.2x -> Dwing
9
BE 88 01 ?? ?? AD 8B F8 95

Upack v0.2 Beta -> Dwing
13
BE 88 01 ?? ?? AD 8B F8 95 A5 33 C0 33

Upack v0.21 Beta -> Dwing
13
BE 88 01 ?? ?? AD 8B F8 ?? ?? ?? ?? 33

Upack v0.22 ~ v0.23 Beta -> Dwing
14
6A 07 BE 88 01 40 00 AD 8B F8 59 95 F3 A5

Upack v0.24 ~ v0.28 Alpha -> Dwing
14
BE 88 01 40 00 AD ?? ?? 95 AD 91 F3 A5 AD

Upack v0.29 beta -> Dwing
44
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00 4C 01 02 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 29

Upack v0.29 Beta ~ v0.31 Beta -> Dwing
17
BE 88 01 ?? ?? AD 8B F8 95 AD 91 F3 A5 AD B5 ??
F3

Upack v0.30 beta -> Dwing
44
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00 4C 01 02 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 30

Upack v0.31 beta -> Dwing
44
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00 4C 01 02 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 31

Upack v0.32 Beta (Patch) -> Dwing
12
BE 88 01 ?? ?? AD 50 ?? AD 91 F3 A5

Upack v0.32 Beta -> Dwing
13
BE 88 01 ?? ?? AD 50 ?? ?? AD 91 F3 A5

Upack v0.32 Beta -> Dwing
13
BE 88 01 ?? ?? AD 50 ?? AD 91 ?? F3 A5

Upack v0.32 beta -> Dwing
44
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00 4C 01 02 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 32

Upack v0.33 ~ v0.34 Beta -> Dwing
16
?? ?? ?? ?? 59 F3 A5 83 C8 FF 8B DF AB 40 AB 40

Upack v0.35 alpha -> Dwing
12
8B F2 8B CA 03 4C 19 1C 03 54 1A 20

Upack V0.36 -> Dwing
200
0B 01 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
18 10 00 00 10 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 10 00 00 00 02 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? 14 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
47 65 74 50 72 6F 63 41 64 64 72 65 73 73 00 FF
76 08 FF 76 0C BE 1C 01

Upack V0.36 -> Dwing
12
BE ?? ?? ?? ?? FF 36 E9 C3 00 00 00

Upack v0.36 alpha -> Dwing
14
AB E2 E5 5D 59 8B 76 68 51 59 46 AD 85 C0

Upack v0.36 beta -> Dwing
30
BE E0 11 ?? ?? FF 36 E9 C3 00 00 00 48 01 ?? ??
0B 01 4B 45 52 4E 45 4C 33 32 2E 44 4C 4C

Upack v0.36 beta -> Dwing
271
BE E0 11 ?? ?? FF 36 E9 C3 00 00 00 48 01 ?? ??
0B 01 4B 45 52 4E 45 4C 33 32 2E 44 4C 4C ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
47 65 74 50 72 6F 63 41 64 64 72 65 73 73 ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 82 8E FE FF FF 58 8B 4E 40 5F E3

Upack V0.37 -> Dwing
168
0B 01 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
18 10 00 00 10 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
00 10 00 00 00 02 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 ?? ?? ?? ?? 14 00 00 00
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 47 65 74 50 72 6F 63 41
64 64 72 65 73 73 00 00

Upack V0.37 -> Dwing
20
60 E8 09 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? 33
C9 5E 87 0E

Upack V0.37 -> Dwing
11
BE ?? ?? ?? ?? AD 50 FF ?? ?? EB

Upack v0.37 beta -> Dwing
84
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 37 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00

Upack v0.37 beta -> Dwing
320
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 37 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00 ?? 00 00 ?? 00 00 ?? 00 00 ?? ?? 00
00 00 10 00 00 10 00 00 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 EE ?? ?? ?? 14 00 00 00
00 ?? ?? ?? ?? ?? ?? 00 FF 76 38 AD 50 8B 3E BE
F0 ?? ?? ?? 6A 27 59 F3 A5 FF 76 04 83 C8 FF 8B
DF AB EB 1C 00 00 00 00 47 65 74 50 72 6F 63 41
64 64 72 65 73 73 00 00 ?? ?? ?? ?? ?? 00 00 00
40 AB 40 B1 04 F3 AB C1 E0 0A B5 ?? F3 AB 8B 7E
0C 57 51 E9 ?? ?? ?? ?? E3 B1 04 D3 E0 03 E8 8D
53 18 33 C0 55 40 51 D3 E0 8B EA 91 FF 56 4C 33
D2 59 D1 E8 13 D2 E2 FA 5D 03 EA 45 59 89 6B 08
56 8B F7 2B F5 F3 A4 AC 5E B1 80 AA 3B 7E 34 0F
82 8E FE FF FF 58 5F 59 E3 1B 8A 07 47 04 18 3C
02 73 F7 8B 07 3C ?? 75 F1 B0 00 0F C8 03 46 38
2B C7 AB E2 E5 5E 5D 59 51 59 46 AD 85 C0 74 1F

Upack v0.37 ~ v0.38 Beta (Strip base relocation table Option)-> Dwing
16
53 18 33 C0 55 40 51 D3 E0 8B EA 91 FF 56 4C 33

Upack v0.38 beta -> Dwing
84
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 38 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00

Upack v0.38 beta -> Dwing
320
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 38 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00 ?? 00 00 ?? 00 00 ?? 00 00 ?? ?? 00
00 00 10 00 00 10 00 00 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 EE ?? ?? ?? 14 00 00 00
00 ?? ?? ?? ?? ?? ?? 00 FF 76 38 AD 50 8B 3E BE
F0 ?? ?? ?? 6A 27 59 F3 A5 FF 76 04 83 C8 FF 8B
DF AB EB 1C 00 00 00 00 47 65 74 50 72 6F 63 41
64 64 72 65 73 73 00 00 ?? ?? ?? ?? ?? 00 00 00
40 AB 40 B1 04 F3 AB C1 E0 0A B5 ?? F3 AB 8B 7E
0C 57 51 E9 ?? ?? ?? ?? E3 B1 04 D3 E0 03 E8 8D
53 18 33 C0 55 40 51 D3 E0 8B EA 91 FF 56 4C 33
D2 59 D1 E8 13 D2 E2 FA 5D 03 EA 45 59 89 6B 08
56 8B F7 2B F5 F3 A4 AC 5E B1 80 AA 3B 7E 34 0F
82 97 FE FF FF 58 5F 59 E3 1B 8A 07 47 04 18 3C
02 73 F7 8B 07 3C ?? 75 F1 B0 00 0F C8 03 46 38
2B C7 AB E2 E5 5E 5D 59 51 59 46 AD 85 C0 74 1F

Upack v0.39 final -> Dwing
23
56 10 E2 E3 B1 04 D3 E0 03 E8 8D 53 18 33 C0 55
40 51 D3 E0 8B EA 91

Upack v0.39 final -> Dwing
23
FF 76 38 AD 50 8B 3E BE F0 ?? ?? ?? 6A 27 59 F3
A5 FF 76 04 83 C8 FF

Upack v0.399 -> Dwing
187
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? 00 00 00 40 00
00 10 00 00 00 02 00 00 04 00 00 00 00 00 3A 00
04 00 00 00 00 00 00 00 00 ?? ?? 00 00 02 00 00
00 00 00 00 ?? 00 00 00 00 00 10 00 00 ?? 00 00
00 00 10 00 00 10 00 00 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 EE ?? ?? 00 14 00 00 00
00 ?? ?? 00 ?? ?? 00 00 FF 76 38 AD 50 8B 3E BE
F0 ?? ?? 00 6A 27 59 F3 A5 FF 76 04 83 C8 FF 8B
DF AB EB 1C 00 00 00 00 47 65 74 50 72 6F 63 41
64 64 72 65 73 73 00 00 ?? ?? ?? 00 ?? 00 00 00
40 AB 40 B1 04 F3 AB C1 E0 0A B5

Upack v0.399 -> Dwing
84
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 3A 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00

Upack v0.399 -> Dwing
271
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 3A 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00 ?? 00 00 ?? 00 00 10 00 00 ?? ?? 00
00 00 10 00 00 10 00 00 00 00 00 00 0A 00 00 00
00 00 00 00 00 00 00 00 EE ?? ?? ?? 14 00 00 00
00 ?? ?? ?? ?? ?? 00 00 FF 76 38 AD 50 8B 3E BE
F0 ?? ?? ?? 6A 27 59 F3 A5 FF 76 04 83 C8 FF 8B
DF AB EB 1C 00 00 00 00 47 65 74 50 72 6F 63 41
64 64 72 65 73 73 00 00 ?? ?? ?? ?? ?? 00 00 00
40 AB 40 B1 04 F3 AB C1 E0 0A B5 ?? F3 AB 8B 7E
0C 57 51 E9 ?? ?? ?? ?? 56 10 E2 E3 B1 04 D3 E0
03 E8 8D 53 18 33 C0 55 40 51 D3 E0 8B EA 91 FF
56 4C 99 59 D1 E8 13 D2 E2 FA 5D 03 EA 45 59 89
6B 08 56 8B F7 2B F5 F3 A4 AC 5E B1 80 AA 3B

Upack_Patch -> Dwing
10
81 3A 00 00 00 02 00 00 00 00

Upack_Patch or any Version -> Dwing
13
60 E8 09 00 00 00 ?? ?? ?? 00 E9 06 02

Upack_Unknown (DLL ???) -> Dwing
13
60 E8 09 00 00 00 17 CD 00 00 E9 06 02

UPolyX v0.5
85
55 8B EC ?? 00 BD 46 00 8B ?? B9 ?? 00 00 00 80
?? ?? 51 ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

UPolyX v0.5
84
83 EC 04 89 14 24 59 BA ?? 00 00 00 52 ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 00

UPolyX v0.5
85
BB 00 BD 46 00 83 EC 04 89 1C 24 ?? B9 ?? 00 00
00 80 33 ?? ?? ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

UPolyX v0.5
85
E8 00 00 00 00 59 83 C1 07 51 C3 C3 ?? 00 BD 46
00 83 EC 04 89 ?? 24 B9 ?? 00 00 00 81 ?? ?? ??
?? 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

UPolyX v0.5
85
E8 00 00 00 00 59 83 C1 07 51 C3 C3 ?? 00 BD 46
00 ?? B9 ?? 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

UPolyX v0.5
85
EB 01 C3 ?? 00 BD 46 00 ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

UPX + ECLiPSE layer
33
B8 ?? ?? ?? ?? B9 ?? ?? ?? ?? 33 D2 EB 01 0F 56
EB 01 0F E8 03 00 00 00 EB 01 0F EB 01 0F 5E EB
01

UPX 0.50 - 0.70
10
60 E8 00 00 00 00 58 83 E8 3D

UPX 0.72
12
60 E8 00 00 00 00 83 CD FF 31 DB 5E

UPX 2.00-3.0X -> Markus Oberhumer & Laszlo Molnar & John Reiser
186
5E 89 F7 B9 ?? ?? ?? ?? 8A 07 47 2C E8 3C 01 77
F7 80 3F ?? 75 F2 8B 07 8A 5F 04 66 C1 E8 08 C1
C0 10 86 C4 29 F8 80 EB E8 01 F0 89 07 83 C7 05
88 D8 E2 D9 8D ?? ?? ?? ?? ?? 8B 07 09 C0 74 3C
8B 5F 04 8D ?? ?? ?? ?? ?? ?? 01 F3 50 83 C7 08
FF ?? ?? ?? ?? ?? 95 8A 07 47 08 C0 74 DC 89 F9
57 48 F2 AE 55 FF ?? ?? ?? ?? ?? 09 C0 74 07 89
03 83 C3 04 EB E1 FF ?? ?? ?? ?? ?? 8B AE ?? ??
?? ?? 8D BE 00 F0 FF FF BB 00 10 00 00 50 54 6A
04 53 57 FF D5 8D 87 ?? ?? ?? ?? 80 20 7F 80 60
28 7F 58 50 54 50 53 57 FF D5 58 61 8D 44 24 80
6A 00 39 C4 75 FA 83 EC 80 E9

UPX 2.90 [LZMA] (Delphi stub) -> Markus Oberhumer, Laszlo Molnar & John Reiser
64
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? C7 87 ?? ??
?? ?? ?? ?? ?? ?? 57 83 CD FF 89 E5 8D 9C 24 ??
?? ?? ?? 31 C0 50 39 DC 75 FB 46 46 53 68 ?? ??
?? ?? 57 83 C3 04 53 68 ?? ?? ?? ?? 56 83 C3 04

UPX 2.90 [LZMA] -> Markus Oberhumer, Laszlo Molnar & John Reiser
64
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF
89 E5 8D 9C 24 ?? ?? ?? ?? 31 C0 50 39 DC 75 FB
46 46 53 68 ?? ?? ?? ?? 57 83 C3 04 53 68 ?? ??
?? ?? 56 83 C3 04 53 50 C7 03 ?? ?? ?? ?? 90 90

UPX 2.90 [LZMA] -> Markus Oberhumer, Laszlo Molnar & John Reiser
63
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF
EB 10 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB

UPX 2.93 - 3.00 [LZMA] -> Markus Oberhumer, Laszlo Molnar & John Reiser
64
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 89 E5 8D
9C 24 ?? ?? ?? ?? 31 C0 50 39 DC 75 FB 46 46 53
68 ?? ?? ?? ?? 57 83 C3 04 53 68 ?? ?? ?? ?? 56
83 C3 04 53 50 C7 03 03 00 02 00 90 90 90 90 90

UPX Alternative stub
32
01 DB 07 8B 1E 83 EE FC 11 DB ED B8 01 00 00 00
01 DB 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73 0B

UPX Inliner v1.0 by GPcH
85
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5 D5 FE FF FF 8B 06 83 F8 00 74
11 8D B5 E1 FE FF FF 8B 06 83 F8 01 0F 84 F1 01
00 00 C7 06 01 00 00 00 8B D5 8B 85 B1 FE FF FF
2B D0 89 95 B1 FE FF FF 01 95 C9 FE FF FF 8D B5
E5 FE FF FF 01

UPX Modified stub
43
79 07 0F B7 07 47 50 47 B9 57 48 F2 AE 55 FF 96
84 ?? 00 00 09 C0 74 07 89 03 83 C3 04 EB D8 FF
96 88 ?? 00 00 61 E9 ?? ?? ?? FF

UPX Modified Stub b -> Farb-rausch Consumer Consulting
85
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF
FC B2 80 31 DB A4 B3 02 E8 6D 00 00 00 73 F6 31
C9 E8 64 00 00 00 73 1C 31 C0 E8 5B 00 00 00 73
23 B3 02 41 B0 10 E8 4F 00 00 00 10 C0 73 F7 75
3F AA EB D4 E8 4D 00 00 00 29 D9 75 10 E8 42 00
00 00 EB 28 AC

UPX Modified Stub c -> Farb-rausch Consumer Consulting
85
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF
FC B2 80 E8 00 00 00 00 5B 83 C3 66 A4 FF D3 73
FB 31 C9 FF D3 73 14 31 C0 FF D3 73 1D 41 B0 10
FF D3 10 C0 73 FA 75 3C AA EB E2 E8 4A 00 00 00
49 E2 10 E8 40 00 00 00 EB 28 AC D1 E8 74 45 11
C9 EB 1C 91 48

UPX Modifier v0.1x
15
50 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD

UPX Protector v1.0x
16
EB EC ?? ?? ?? ?? 8A 06 46 88 07 47 01 DB 75 07

UPX Protector v1.0x (2)
23
EB ?? ?? ?? ?? ?? 8A 06 46 88 07 47 01 DB 75 07
8B 1E 83 EE FC 11 DB

UPX v1.03 - v1.04
74
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 8A 07 72 EB B8 01 00
00 00 01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01
DB 73 ?? 75 ?? 8B 1E 83 EE FC

UPX v1.03 - v1.04 Modified
37
01 DB ?? 07 8B 1E 83 EE FC 11 DB 8A 07 ?? EB B8
01 00 00 00 01 DB ?? 07 8B 1E 83 EE FC 11 DB 11
C0 01 DB 73 EF

Upx v1.2 -> Marcus & Lazlo
64
60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF
EB 05 A4 01 DB 75 07 8B 1E 83 EE FC 11 DB 72 F2
31 C0 40 01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0
01 DB 75 07 8B 1E 83 EE FC 11 DB 73 E6 31 C9 83

UPX V1.94 -> Markus Oberhumer & Laszlo Molnar & John Reiser
33
FF D5 80 A7 ?? ?? ?? ?? ?? 58 50 54 50 53 57 FF
D5 58 61 8D 44 24 ?? 6A 00 39 C4 75 FA 83 EC 80
E9

UPX v2.0 -> Markus, Laszlo & Reiser
85
55 FF 96 ?? ?? ?? ?? 09 C0 74 07 89 03 83 C3 04
EB ?? FF 96 ?? ?? ?? ?? 8B AE ?? ?? ?? ?? 8D BE
00 F0 FF FF BB 00 10 00 00 50 54 6A 04 53 57 FF
D5 8D 87 ?? ?? 00 00 80 20 7F 80 60 28 7F 58 50
54 50 53 57 FF D5 58 61 8D 44 24 80 6A 00 39 C4
75 FA 83 EC 80

UPX V2.00-V2.90 -> Markus Oberhumer & Laszlo Molnar & John Reiser
39
FF D5 8D 87 ?? ?? ?? ?? 80 20 ?? 80 60 ?? ?? 58
50 54 50 53 57 FF D5 58 61 8D 44 24 ?? 6A 00 39
C4 75 FA 83 EC 80 E9

UPX$HiT 0.0.1 -> DJ Siba
13
E2 FA 94 FF E0 61 00 00 00 00 00 00 00

UPX$HiT v0.0.1 -> DJ Siba
21
94 BC ?? ?? ?? 00 B9 ?? 00 00 00 80 34 0C ?? E2
FA 94 FF E0 61

Upx-Lock 1.0 - 1.2 --> CyberDoom / Team-X & BoB / BobSoft
20
60 E8 00 00 00 00 5D 81 ED 48 12 40 00 60 E8 2B
03 00 00 61

UPX-SCRAMBLER 3.06 -> ãŽ¡nTç•‚L
53
E8 00 00 00 00 59 83 C1 07 51 C3 C3 BE ?? ?? ??
?? 83 EC 04 89 34 24 B9 80 00 00 00 81 36 ?? ??
?? ?? 50 B8 04 00 00 00 50 03 34 24 58 58 83 E9
03 E2 E9 EB D6

UPX-Scrambler RC v1.x
17
90 61 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD
FF

UPX-Shit v0.1 -> 500mhz
85
E8 00 00 00 00 5E 83 C6 14 AD 89 C7 AD 89 C1 AD
30 07 47 E2 FB AD FF E0 C3 00 ?? ?? 00 ?? ?? ??
00 ?? ?? ?? 01 ?? ?? ?? 00 55 50 58 2D 53 68 69
74 20 76 30 2E 31 20 2D 20 77 77 77 2E 62 6C 61
63 6B 6C 6F 67 69 63 2E 6E 65 74 20 2D 20 63 6F
64 65 20 62 79

UPX-Shit v0.1 -> 500mhz
85
E8 00 00 00 00 5E 83 C6 14 AD 89 C7 AD 89 C1 AD
30 07 47 E2 FB AD FF E0 C3 00 ?? ?? 00 ?? ?? ??
00 ?? ?? ?? ?? ?? ?? ?? 00 55 50 58 2D 53 68 69
74 20 76 30 2E 31 20 2D 20 77 77 77 2E 62 6C 61
63 6B 6C 6F 67 69 63 2E 6E 65 74 20 2D 20 63 6F
64 65 20 62 79

UPX-Shit v0.1 -> 500mhz
25
E8 ?? ?? ?? ?? 5E 83 C6 ?? AD 89 C7 AD 89 C1 AD
30 07 47 E2 ?? AD FF E0 C3

UPXcrypter -> archphase/NWC
40
BF ?? ?? ?? 00 81 FF ?? ?? ?? 00 74 10 81 2F ??
00 00 00 83 C7 04 BB 05 ?? ?? 00 FF E3 BE ?? ??
?? 00 FF E6 00 00 00 00

UPXFreak v0.1 (Borland Delphi) -> HMX0101
85
BE ?? ?? ?? ?? 83 C6 01 FF E6 00 00 00 ?? ?? ??
00 03 00 00 00 ?? ?? ?? ?? 00 10 00 00 00 00 ??
?? ?? ?? 00 00 ?? F6 ?? 00 B2 4F 45 00 ?? F9 ??
00 EF 4F 45 00 ?? F6 ?? 00 8C D1 42 00 ?? 56 ??
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? 24 ??
00 ?? ?? ?? 00

UPXFreak v0.1 (Borland Delphi) -> HMX0101
245
BE ?? ?? ?? ?? 83 C6 01 FF E6 00 00 00 ?? ?? ??
00 03 00 00 00 ?? ?? ?? ?? 00 10 00 00 00 00 ??
?? ?? ?? 00 00 ?? F6 ?? 00 B2 4F 45 00 ?? F9 ??
00 EF 4F 45 00 ?? F6 ?? 00 8C D1 42 00 ?? 56 ??
00 ?? ?? ?? 00 ?? ?? ?? 00 ?? ?? ?? 00 ?? 24 ??
00 ?? ?? ?? 00 34 50 45 00 ?? ?? ?? 00 FF FF 00
00 ?? 24 ?? 00 ?? 24 ?? 00 ?? ?? ?? 00 40 00 00
C0 00 00 ?? ?? ?? ?? 00 00 ?? 00 00 00 ?? 1E ??
00 ?? F7 ?? 00 A6 4E 43 00 ?? 56 ?? 00 AD D1 42
00 ?? F7 ?? 00 A1 D2 42 00 ?? 56 ?? 00 0B 4D 43
00 ?? F7 ?? 00 ?? F7 ?? 00 ?? 56 ?? 00 ?? ?? ??
?? ?? 00 00 00 ?? ?? ?? ?? ?? ?? ?? 77 ?? ?? ??
00 ?? ?? ?? 00 ?? ?? ?? 77 ?? ?? 00 00 ?? ?? ??
00 ?? ?? ?? ?? ?? ?? 00 00 ?? ?? ?? 00 ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? 00 ?? ?? ?? ?? 00 00 00
00 ?? ?? ?? 00

UPXFreak V0.1 -> HMX0101
12
BE ?? ?? ?? ?? 83 C6 01 FF E6 00 00

UPXShit 0.06
21
B8 ?? ?? 43 00 B9 15 00 00 00 80 34 08 ?? E2 FA
E9 D6 FF FF FF

USERNAME v3.00
47
FB 2E ?? ?? ?? ?? 2E ?? ?? ?? ?? 2E ?? ?? ?? ??
2E ?? ?? ?? ?? 8C C8 2B C1 8B C8 2E ?? ?? ?? ??
2E ?? ?? ?? ?? 33 C0 8E D8 06 0E 07 FC 33 F6

USSR 0.31 - by Spirit
50
E8 00 00 00 00 5D 83 C5 12 55 C3 20 83 B8 ED 20
37 EF C6 B9 79 37 9E 8C C9 30 C9 E3 01 C3 BE 32
?? ?? ?? B0 ?? 30 06 8A 06 46 81 FE 00 ?? ?? ??
7C F3

VBOX v4.2 MTE
16
8C E0 0B C5 8C E0 0B C4 03 C5 74 00 74 00 8B C5

VBOX v4.3 - v4.6
32
8B C5 8B C5 8B C5 8B C5 8B C5 8B C5 8B C5 8B C5
8B C5 8B C5 8B C5 8B C5 8B C5 8B C5 8B C5 8B C5

VBOX v4.3 - v4.6
39
?? ?? ?? ?? 90 03 C4 33 C4 33 C5 2B C5 33 C5 8B
C5 ?? ?? 2B C5 48 ?? ?? 0B C0 86 E0 8C E0 ?? ??
8C E0 86 E0 03 C4 40

VcAsm Protector -> VcAsm
46
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50 C3

VcAsm Protector V1.0X-> VcAsm
34
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00

Vcasm Protector V1.X -> vcasm
12
EB ?? 5B 56 50 72 6F 74 65 63 74 5D

Vcasm-Protector 1.0
85
55 8B EC 6A FF 68 ?? ?? ?? 00 68 ?? ?? ?? 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50 C3 FF 35
E8 03 00 00 00 C7 84 00 58 EB 01 E9 83 C0 07 50
C3 FF 35 E8 07 00 00 00 C7 83 83 C0 13 EB 0B 58
EB 02 CD 20 83

Vcasm-Protector 1.0e -> vcasm
12
EB 0A 5B 56 50 72 6F 74 65 63 74 5D

Vcasm-Protector 1.1 - 1.2 -> vcasm
12
EB 0B 5B 56 50 72 6F 74 65 63 74 5D

vfp&exeNc V5.00 -> Wang JianGuo
35
60 E8 00 00 00 00 5D ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? 50 64 FF 35 00 00 00 00 64 89 25 00 00
00 00 CC

vfp&exeNc v6.00 -> Wang JianGuo
58
60 E8 01 00 00 00 63 58 E8 01 00 00 00 7A 58 2D
0D 10 40 00 8D 90 C1 10 40 00 52 50 8D 80 49 10
40 00 5D 50 8D 85 65 10 40 00 50 64 FF 35 00 00
00 00 64 89 25 00 00 00 00 CC

Video-Lan-Client
23
55 89 E5 83 EC 08 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? FF FF

Video-Lan-Client -> (UnknownCompiler)
51
55 89 E5 83 EC 08 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? FF FF ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 ?? ?? ?? ?? ??
?? ?? 00

Virogen Crypt v0.75
20
9C 55 E8 EC 00 00 00 87 D5 5D 60 87 D5 80 BD 15
27 40 00 01

Virogen`s PE Shrinker v0.14
31
9C 55 E8 ?? ?? ?? ?? 87 D5 5D 60 87 D5 8D ?? ??
?? ?? ?? 8D ?? ?? ?? ?? ?? 57 56 AD 0B C0 74

VIRUS - I-Worm.Bagle
85
6A 00 E8 95 01 00 00 E8 9F E6 FF FF 83 3D 03 50
40 00 00 75 14 68 C8 AF 00 00 E8 01 E1 FF FF 05
88 13 00 00 A3 03 50 40 00 68 5C 57 40 00 68 F6
30 40 00 FF 35 03 50 40 00 E8 B0 EA FF FF E8 3A
FC FF FF 83 3D 54 57 40 00 00 74 05 E8 F3 FA FF
FF 68 E8 03 00

VIRUS - I-Worm.Hybris
32
EB 16 A8 54 ?? ?? 47 41 42 4C 4B 43 47 43 ?? ??
?? ?? ?? ?? 52 49 53 ?? FC 68 4C 70 40 ?? FF 15

VIRUS - I-Worm.KLEZ
42
55 8B EC 6A FF 68 40 D2 40 ?? 68 04 AC 40 ?? 64
A1 ?? ?? ?? ?? 50 64 89 25 ?? ?? ?? ?? 83 EC 58
53 56 57 89 65 E8 FF 15 BC D0

VMProtect 0.7x - 0.8 -> PolyTech
32
5B 20 56 4D 50 72 6F 74 65 63 74 20 76 20 30 2E
38 20 28 43 29 20 50 6F 6C 79 54 65 63 68 20 5D

VMProtect 1.06..1.07 -> PolyTech
25
9C 60 68 00 00 00 00 8B 74 24 28 BF ?? ?? ?? ??
FC 89 F3 03 34 24 AC 00 D8

VOB ProtectCD
38
5F 81 EF ?? ?? ?? ?? BE ?? ?? 40 ?? 8B 87 ?? ??
?? ?? 03 C6 57 56 8C A7 ?? ?? ?? ?? FF 10 89 87
?? ?? ?? ?? 5E 5F

Vpacker -> ttui
142
89 C6 C7 45 E0 01 00 00 00 F7 03 00 00 FF FF 75
18 0F B7 03 50 8B 45 D8 50 FF 55 F8 89 07 8B C3
E8 ?? FE FF FF 8B D8 EB 13 53 8B 45 D8 50 FF 55
F8 89 07 8B C3 E8 ?? FE FF FF 8B D8 83 C7 04 FF
45 E0 4E 75 C4 8B F3 83 3E 00 75 88 8B 45 E4 8B
40 10 03 45 DC 8B 55 14 83 C2 20 89 02 68 00 80
00 00 6A 00 8B 45 D4 50 FF 55 EC 8B 55 DC 8B 42
3C 03 45 DC 83 C0 04 8B D8 83 C3 14 8D 45 E0 50
6A 40 68 00 10 00 00 52 FF 55 E8 8D 43 60

VProtector -> vcasm
337
00 00 00 00 4B 45 52 4E 45 4C 33 32 2E 64 6C 6C
00 00 55 53 45 52 33 32 2E 64 6C 6C 00 00 47 44
49 33 32 2E 64 6C 6C 00 00 00 00 00 00 00 00 47
65 74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00
47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 53 6C 65 65 70 00 00 00 47 65 74 56 65 72
73 69 6F 6E 00 00 00 47 65 74 43 6F 6D 6D 61 6E
64 4C 69 6E 65 41 00 00 00 47 65 74 53 74 61 72
74 75 70 49 6E 66 6F 41 00 00 00 47 65 74 41 43
50 00 00 00 43 72 65 61 74 65 54 68 72 65 61 64
00 00 00 44 65 66 57 69 6E 64 6F 77 50 72 6F 63
41 00 00 00 52 65 67 69 73 74 65 72 43 6C 61 73
73 45 78 41 00 00 00 43 72 65 61 74 65 57 69 6E
64 6F 77 45 78 41 00 00 00 47 65 74 53 79 73 74
65 6D 4D 65 74 72 69 63 73 00 00 00 53 68 6F 77
57 69 6E 64 6F 77 00 00 00 47 65 74 44 43 00 00
00 52 65 6C 65 61 73 65 44 43 00 00 00 46 69 6E
64 57 69 6E 64 6F 77 41 00 00 00 47 65 74 4D 65
73 73 61 67 65 41 00 00 00 44 65 73 74 72 6F 79
57 69 6E 64 6F 77 00 00 00 53 65 74 50 69 78 65
6C

VProtector -> vcasm
341
00 00 00 00 4B 45 52 4E 45 4C 33 32 2E 64 6C 6C
00 00 55 53 45 52 33 32 2E 64 6C 6C 00 00 47 44
49 33 32 2E 64 6C 6C 00 00 00 00 00 00 00 00 47
65 74 50 72 6F 63 41 64 64 72 65 73 73 00 00 00
47 65 74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41
00 00 00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00
00 00 53 6C 65 65 70 00 00 00 47 65 74 56 65 72
73 69 6F 6E 00 00 00 47 65 74 43 6F 6D 6D 61 6E
64 4C 69 6E 65 41 00 00 00 47 65 74 53 74 61 72
74 75 70 49 6E 66 6F 41 00 00 00 47 65 74 41 43
50 00 00 00 43 72 65 61 74 65 54 68 72 65 61 64
00 00 00 44 65 66 57 69 6E 64 6F 77 50 72 6F 63
41 00 00 00 52 65 67 69 73 74 65 72 43 6C 61 73
73 45 78 41 00 00 00 43 72 65 61 74 65 57 69 6E
64 6F 77 45 78 41 00 00 00 47 65 74 53 79 73 74
65 6D 4D 65 74 72 69 63 73 00 00 00 53 68 6F 77
57 69 6E 64 6F 77 00 00 00 47 65 74 44 43 00 00
00 52 65 6C 65 61 73 65 44 43 00 00 00 46 69 6E
64 57 69 6E 64 6F 77 41 00 00 00 47 65 74 4D 65
73 73 61 67 65 41 00 00 00 44 65 73 74 72 6F 79
57 69 6E 64 6F 77 00 00 00 53 65 74 50 69 78 65
6C 00 00 00 00

VProtector -> vcasm
364
00 00 00 00 55 73 65 72 33 32 2E 64 6C 6C 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 47 64 69 33 32 2E 64 6C 6C 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
4B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
44 65 66 57 69 6E 64 6F 77 50 72 6F 63 41 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
52 65 67 69 73 74 65 72 43 6C 61 73 73 45 78 41
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
43 72 65 61 74 65 57 69 6E 64 6F 77 45 78 41 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
47 65 74 53 79 73 74 65 6D 4D 65 74 72 69 63 73
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
53 68 6F 77 57 69 6E 64 6F 77 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
47 65 74 44 43 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
52 65 6C 65 61 73 65 44 43 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00
46 69 6E 64 57 69 6E 64 6F 77 41 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
47 65 74 4D 65 73 73 61 67 65 41 00

VProtector 0.X-1.2X -> vcasm
199
00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 00
00 00 00 76 63 61 73 6D 5F 70 72 6F 74 65 63 74
5F ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 33 F6 E8 10 00 00 00 8B 64 24 08 64
8F 05 00 00 00 00 58 EB 13 C7 83 64 FF 35 00 00
00 00 64 89 25 00 00 00 00 AD CD 20 EB 01 0F 31
F0 EB 0C 33 C8 EB 03 EB 09 0F 59 74 05 75 F8 51
EB F1 B9 04 00 00 00 E8 1F 00 00 00 EB FA E8 16
00 00 00 E9 EB F8 00 00 58 EB 09 0F 25 E8 F2 FF
FF FF 0F B9 49 75 F1 EB 05 EB F9 EB F0 D6 E8 07
00 00 00 C7 83 83 C0 13 EB 0B 58 EB 02 CD 20 83
C0 02 EB 01 E9 50 C3

VProtector 1.0X -> vcasm
210
55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50 C3 FF 35
E8 03 00 00 00 C7 84 00 58 EB 01 E9 83 C0 07 50
C3 FF 35 E8 07 00 00 00 C7 83 83 C0 13 EB 0B 58
EB 02 CD 20 83 C0 02 EB 01 E9 50 C3 E8 B9 04 00
00 00 E8 1F 00 00 00 EB FA E8 16 00 00 00 E9 EB
F8 00 00 58 EB 09 0F 25 E8 F2 FF FF FF 0F B9 49
75 F1 EB 05 EB F9 EB F0 D6 EB 01 0F 31 F0 EB 0C
33 C8 EB 03 EB 09 0F 59 74 05 75 F8 51 EB F1 E8
16 00 00 00 8B 5C 24 0C 8B A3 C4 00 00 00 64 8F
05 00 00 00 00 83 C4 04 EB 14 64 FF 35 00 00 00
00 64 89 25 00 00 00 00 33 C9 99 F7 F1 E9 E8 05
00 00

VProtector 1.1A-1.2 -> vcasm
198
00 00 56 69 72 74 75 61 6C 41 6C 6C 6F 63 00 00
00 00 00 76 63 61 73 6D 5F 70 72 6F 74 65 63 74
5F 32 30 30 35 5F 33 5F 31 38 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 33 F6 E8 10 00 00 00 8B 64 24 08 64 8F
05 00 00 00 00 58 EB 13 C7 83 64 FF 35 00 00 00
00 64 89 25 00 00 00 00 AD CD 20 EB 01 0F 31 F0
EB 0C 33 C8 EB 03 EB 09 0F 59 74 05 75 F8 51 EB
F1 B9 04 00 00 00 E8 1F 00 00 00 EB FA E8 16 00
00 00 E9 EB F8 00 00 58 EB 09 0F 25 E8 F2 FF FF
FF 0F B9 49 75 F1 EB 05 EB F9 EB F0 D6 E8 07 00
00 00 C7 83 83 C0 13 EB 0B 58 EB 02 CD 20 83 C0
02 EB 01 E9 50 C3

VProtector 1.1X -> vcasm
220
EB 0B 5B 56 50 72 6F 74 65 63 74 5D 00 E8 24 00
00 00 8B 44 24 04 8B 00 3D 04 00 00 80 75 08 8B
64 24 08 EB 04 58 EB 0C E9 64 8F 05 00 00 00 00
74 F3 75 F1 EB 24 64 FF 35 00 00 00 00 EB 12 FF
9C 74 03 75 01 E9 81 0C 24 00 01 00 00 9D 90 EB
F4 64 89 25 00 00 00 00 EB E6 E8 16 00 00 00 8B
5C 24 0C 8B A3 C4 00 00 00 64 8F 05 00 00 00 00
83 C4 04 EB 14 64 FF 35 00 00 00 00 64 89 25 00
00 00 00 33 C9 99 F7 F1 E9 E8 03 00 00 00 C7 84
00 58 EB 01 E9 83 C0 07 50 C3 FF 35 E8 16 00 00
00 8B 5C 24 0C 8B A3 C4 00 00 00 64 8F 05 00 00
00 00 83 C4 04 EB 14 64 FF 35 00 00 00 00 64 89
25 00 00 00 00 33 C9 99 F7 F1 E9 E8 03 00 00 00
C7 84 00 58 EB 01 E9 83 C0 07 50 C3

vprotector 1.2 -> vcasm
85
EB 0B 5B 56 50 72 6F 74 65 63 74 5D 00 E8 24 00
00 00 8B 44 24 04 8B 00 3D 04 00 00 80 75 08 8B
64 24 08 EB 04 58 EB 0C E9 64 8F 05 00 00 00 00
74 F3 75 F1 EB 24 64 FF 35 00 00 00 00 EB 12 FF
9C 74 03 75 01 E9 81 0C 24 00 01 00 00 9D 90 EB
F4 64 89 25 00

vprotector 1.2 -> vcasm
288
EB 0B 5B 56 50 72 6F 74 65 63 74 5D 00 E8 24 00
00 00 8B 44 24 04 8B 00 3D 04 00 00 80 75 08 8B
64 24 08 EB 04 58 EB 0C E9 64 8F 05 00 00 00 00
74 F3 75 F1 EB 24 64 FF 35 00 00 00 00 EB 12 FF
9C 74 03 75 01 E9 81 0C 24 00 01 00 00 9D 90 EB
F4 64 89 25 00 00 00 00 EB E6 E8 16 00 00 00 8B
5C 24 0C 8B A3 C4 00 00 00 64 8F 05 00 00 00 00
83 C4 04 EB 14 64 FF 35 00 00 00 00 64 89 25 00
00 00 00 33 C9 99 F7 F1 E9 E8 03 00 00 00 C7 84
00 58 EB 01 E9 83 C0 07 50 C3 FF 35 E8 16 00 00
00 8B 5C 24 0C 8B A3 C4 00 00 00 64 8F 05 00 00
00 00 83 C4 04 EB 14 64 FF 35 00 00 00 00 64 89
25 00 00 00 00 33 C9 99 F7 F1 E9 E8 03 00 00 00
C7 84 00 58 EB 01 E9 83 C0 07 50 C3 FF 35 33 F6
E8 10 00 00 00 8B 64 24 08 64 8F 05 00 00 00 00
58 EB 13 C7 83 64 FF 35 00 00 00 00 64 89 25 00
00 00 00 AD CD 20 E8 05 00 00 00 0F 01 EB 05 E8
EB FB 00 00 83 C4 04 E8 08 00 00 00 0F 01 83 C0

VProtector 1.3X -> vcasm
208
00 00 00 00 00 ?? ?? ?? ?? 00 00 00 00 00 00 00
00 ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 00 00 6B 65 72
6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 47 65 74
50 72 6F 63 41 64 64 72 65 73 73 00 00 00 47 65
74 4D 6F 64 75 6C 65 48 61 6E 64 6C 65 41 00 00
00 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 60 8B
B4 24 24 00 00 00 8B BC 24 28 00 00 00 FC C6 C2
80 33 DB A4 C6 C3 02 E8 A9 00 00 00 0F 83 F1 FF
FF FF 33 C9 E8 9C 00 00 00 0F 83 2D 00 00 00 33
C0 E8 8F 00 00 00 0F 83 37 00 00 00 C6 C3 02 41
C6 C0 10 E8 7D 00 00 00 10 C0 0F 83 F3 FF FF FF

VProtector 1.3X -> vcasm
239
E9 B9 16 00 00 55 8B EC 81 EC 74 04 00 00 57 68
00 00 00 00 68 00 00 C2 14 68 FF FF 00 00 68 ??
?? ?? ?? 9C 81 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9D
54 FF 14 24 68 00 00 00 00 68 00 00 C2 10 68 ??
?? ?? ?? 9C 81 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9D
54 FF 14 24 68 00 00 00 00 68 ?? ?? ?? ?? 9C 81
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9D 54 FF 14 24 68
00 00 00 00 68 FF FF C2 10 68 ?? ?? ?? ?? 9C 81
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9D 54 FF 14 24 68
00 00 00 00 68 ?? ?? ?? ?? 9C 81 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 9D 54 FF 14 24 68 00 00 00 00 68
00 00 C2 14 68 FF FF 00 00 68 ?? ?? ?? ?? 9C 81
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 9D 54 FF 14 24 68
00 00 00 00 68 ?? ?? ?? ?? 9C 81 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? 9D 54 FF 14 24 68 00 00 00 00

VProtector V1.0 [Build 2004.12.13] test! -> vcasm
45
55 8B EC 6A FF 68 1A 89 40 00 68 56 89 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50

VProtector V1.0A -> vcasm
45
55 8B EC 6A FF 68 8A 8E 40 00 68 C6 8E 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50

VProtector V1.0B -> vcasm
45
55 8B EC 6A FF 68 CA 37 41 00 68 06 38 41 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50

VProtector V1.0D -> vcasm
45
55 8B EC 6A FF 68 CA 31 41 00 68 06 32 41 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 E8 03 00
00 00 C7 84 00 58 EB 01 E9 83 C0 07 50

VProtector V1.0E -> vcasm
60
EB 0A 5B 56 50 72 6F 74 65 63 74 5D E8 24 00 00
00 8B 44 24 04 8B 00 3D 04 00 00 80 75 08 8B 64
24 08 EB 04 58 EB 0C E9 64 8F 05 00 00 00 00 74
F3 75 F1 EB 24 64 FF 35 00 00 00 00

VProtector V1.1 -> vcasm
31
B8 1A ED 41 00 B9 EC EB 41 00 50 51 E8 74 00 00
00 E8 51 6A 00 00 58 83 E8 10 B9 B3 00 00 00

VProtector V1.1A -> vcasm
48
EB 0B 5B 56 50 72 6F 74 65 63 74 5D 00 E8 24 00
00 00 8B 44 24 04 8B 00 3D 04 00 00 80 75 08 8B
64 24 08 EB 04 58 EB 0C E9 64 8F 05 00 00 00 00

Vterminal V1.0X -> Lei Peng
16
E8 00 00 00 00 58 05 ?? ?? ?? ?? 9C 50 C2 04 00

Vx: ACME (Clonewar Mutant)
25
FC AD 3D FF FF 74 20 E6 42 8A C4 E6 42 E4 61 0C
03 E6 61 AD B9 40 1F E2 FE

Vx: ARCV.4
27
E8 00 00 5D 81 ED 06 01 81 FC 4F 50 74 0B 8D B6
86 01 BF 00 01 57 A4 EB 11 1E 06

Vx: August 16th (Iron Maiden)
24
BA 79 02 03 D7 B4 1A CD 21 B8 24 35 CD 21 5F 57
89 9D 4E 02 8C 85 50 02

Vx: Backfont.900
57
E8 ?? ?? B4 30 CD 21 3C 03 ?? ?? B8 ?? ?? BA ??
?? CD 21 81 FA ?? ?? ?? ?? BA ?? ?? 8C C0 48 8E
C0 8E D8 80 ?? ?? ?? 5A ?? ?? 03 ?? ?? ?? 40 8E
D8 80 ?? ?? ?? 5A ?? ?? 83

Vx: Caz.1204
16
E8 ?? ?? 5E 83 EE 03 1E 06 B8 FF FF CD 2F 3C 10

Vx: CIH Version 1.2 TTIT (! WIN95CIH !)
17
55 8D ?? ?? ?? 33 DB 64 87 03 E8 ?? ?? ?? ?? 5B
8D

Vx: Compiler
17
8C C3 83 C3 10 2E 01 1E ?? 02 2E 03 1E ?? 02 53
1E

Vx: Danish tiny
18
33 C9 B4 4E CD 21 73 02 FF ?? BA ?? 00 B8 ?? 3D
CD 21

Vx: Doom.666
48
E8 ?? ?? ?? 5E 83 EE ?? B8 CF 7B CD 21 3D CF 7B
?? ?? 0E 1F 81 C6 ?? ?? BF ?? ?? B9 ?? ?? FC F3
A4 06 1F 06 B8 ?? ?? 50 CB B4 48 BB 2C 00 CD 21

Vx: Eddie.1028
61
E8 ?? ?? 5E FC 83 ?? ?? 81 ?? ?? ?? 4D 5A ?? ??
FA 8B E6 81 C4 ?? ?? FB 3B ?? ?? ?? ?? ?? 50 06
56 1E B8 FE 4B CD 21 81 FF BB 55 ?? ?? 07 ?? ??
?? 07 B4 49 CD 21 BB FF FF B4 48 CD 21

Vx: Eddie.1530
55
E8 ?? ?? 5E 81 EE ?? ?? FC 2E ?? ?? ?? ?? 4D 5A
?? ?? FA 8B E6 81 C4 ?? ?? FB 3B ?? ?? ?? ?? ??
2E ?? ?? ?? ?? 50 06 56 1E 33 C0 50 1F C4 ?? ??
?? 2E ?? ?? ?? ?? 2E

Vx: Eddie.1800
53
E8 ?? ?? 5E 81 EE ?? ?? FC 2E ?? ?? ?? ?? 4D 5A
?? ?? FA 8B E6 81 C4 ?? ?? FB 3B ?? ?? ?? ?? ??
50 06 56 1E 8B FE 33 C0 50 8E D8 C4 ?? ?? ?? 2E
?? ?? ?? ?? 2E

Vx: Eddie.2000
56
E8 ?? ?? 5E 81 EE ?? ?? FC 2E ?? ?? ?? ?? 2E ??
?? ?? ?? 4D 5A ?? ?? FA 8B E6 81 C4 ?? ?? FB 3B
?? ?? ?? ?? ?? 50 06 56 1E 8B FE 33 C0 50 8E D8
C5 ?? ?? ?? B4 30 CD 21

Vx: Eddie.2100
49
E8 ?? ?? 4F 4F 0E E8 ?? ?? 47 47 1E FF ?? ?? CB
E8 ?? ?? 84 C0 ?? ?? 50 53 56 57 1E 06 B4 51 CD
21 8E C3 ?? ?? ?? ?? ?? ?? ?? 8B F2 B4 2F CD 21
AC

Vx: Eddie.based.1745
48
E8 ?? ?? 5E 81 EE ?? ?? FC ?? 2E ?? ?? ?? ?? 4D
5A ?? ?? FA ?? 8B E6 81 ?? ?? ?? FB ?? 3B ?? ??
?? ?? ?? 50 06 ?? 56 1E 8B FE 33 C0 ?? 50 8E D8

Vx: Einstein
24
00 42 CD 21 72 31 B9 6E 03 33 D2 B4 40 CD 21 72
19 3B C1 75 15 B8 00 42

Vx: Explosion.1000
42
E8 ?? ?? 5E 1E 06 50 81 ?? ?? ?? 56 FC B8 21 35
CD 21 2E ?? ?? ?? ?? 2E ?? ?? ?? ?? 26 ?? ?? ??
?? ?? ?? 74 ?? 8C D8 48 8E D8

Vx: FaxFree.Topo
40
FA 06 33 C0 8E C0 B8 ?? ?? 26 ?? ?? ?? ?? 50 8C
C8 26 ?? ?? ?? ?? 50 CC 58 9D 58 26 ?? ?? ?? ??
58 26 ?? ?? ?? ?? 07 FB

Vx: Gotcha.879
61
E8 ?? ?? 5B 81 EB ?? ?? 9C FC 2E ?? ?? ?? ?? ??
?? ?? 8C D8 05 ?? ?? 2E ?? ?? ?? ?? 50 2E ?? ??
?? ?? ?? ?? 8B C3 05 ?? ?? 8B F0 BF 00 01 B9 20
00 F3 A4 0E B8 00 01 50 B8 DA DA CD 21

Vx: Grazie.883
24
1E 0E 1F 50 06 BF 70 03 B4 1A BA 70 03 CD 21 B4
47 B2 00 BE 32 04 CD 21

Vx: GRUNT.2.Family
20
48 E2 F7 C3 51 53 52 E8 DD FF 5A 5B 59 C3 B9 00
00 E2 FE C3

Vx: GRUNT.4.Family
28
E8 1C 00 8D 9E 41 01 40 3E 8B 96 14 03 B9 EA 00
87 DB F7 D0 31 17 83 C3 02 E2 F7 C3

Vx: Hafen.1641
35
E8 ?? ?? 01 ?? ?? ?? CE CC 25 ?? ?? 25 ?? ?? 25
?? ?? 40 51 D4 ?? ?? ?? CC 47 CA ?? ?? 46 8A CC
44 88 CC

Vx: Hafen.809
27
E8 ?? ?? 1C ?? 81 EE ?? ?? 50 1E 06 8C C8 8E D8
06 33 C0 8E C0 26 ?? ?? ?? 07 3D

Vx: Haryanto
17
81 EB 2A 01 8B 0F 1E 5B 03 CB 0E 51 B9 10 01 51
CB

Vx: Heloween.1172
44
E8 ?? ?? 5E 81 EE ?? ?? 56 50 06 0E 1F 8C C0 01
?? ?? 01 ?? ?? 80 ?? ?? ?? ?? 8B ?? ?? A3 ?? ??
8A ?? ?? A2 ?? ?? B8 ?? ?? CD 21 3D

Vx: Horse.1776
33
E8 ?? ?? 5D 83 ?? ?? 06 1E 26 ?? ?? ?? ?? BF ??
?? 1E 0E 1F 8B F7 01 EE B9 ?? ?? FC F3 A6 1F 1E
07

Vx: Hymn.1865
48
E8 ?? ?? 5E 83 EE 4C FC 2E ?? ?? ?? ?? 4D 5A ??
?? FA 8B E6 81 ?? ?? ?? FB 3B ?? ?? ?? ?? ?? 2E
?? ?? ?? ?? ?? 50 06 56 1E 0E 1F B8 00 C5 CD 21

Vx: Igor
20
1E B8 CD 7B CD 21 81 FB CD 7B 75 03 E9 87 00 33
DB 0E 1F 8C

Vx: Involuntary.1349
29
?? BA ?? ?? B9 ?? ?? 8C DD ?? 8C C8 ?? 8E D8 8E
C0 33 F6 8B FE FC ?? ?? AD ?? 33 C2 AB

Vx: KBDflags.1024
16
8B EC 2E 89 2E 24 03 BC 00 04 8C D5 2E 89 2E 22

Vx: Keypress.1212
35
E8 ?? ?? E8 ?? ?? E8 ?? ?? E8 ?? ?? ?? ?? E8 ??
?? ?? ?? E8 ?? ?? ?? ?? EA ?? ?? ?? ?? 1E 33 DB
8E DB BB

Vx: Kuku.448
18
AE 75 ED E2 F8 89 3E ?? ?? BA ?? ?? 0E 07 BF ??
?? EB

Vx: Kuku.886
26
06 1E 50 8C C8 8E D8 BA 70 03 B8 24 25 CD 21 ??
?? ?? ?? ?? 90 B4 2F CD 21 53

Vx: Modification of Hi.924
22
50 53 51 52 1E 06 9C B8 21 35 CD 21 53 BB ?? ??
26 ?? ?? 49 48 5B

Vx: MTE (non-encrypted)
20
F7 D9 80 E1 FE 75 02 49 49 97 A3 ?? ?? 03 C1 24
FE 75 02 48

Vx: Ncu-Li.1688
17
0E 1E B8 55 AA CD 21 3D 49 4C 74 ?? 0E 0E 1F 07
E8

Vx: Necropolis
10
50 FC AD 33 C2 AB 8B D0 E2 F8

Vx: Necropolis.1963
44
B4 30 CD 21 3C 03 ?? ?? B8 00 12 CD 2F 3C FF B8
?? ?? ?? ?? B4 4A BB 40 01 CD 21 ?? ?? FA 0E 17
BC ?? ?? E8 ?? ?? FB A1 ?? ?? 0B C0

Vx: Noon.1163
31
E8 ?? ?? 5B 50 56 B4 CB CD 21 3C 07 ?? ?? 81 ??
?? ?? 2E ?? ?? 4D 5A ?? ?? BF 00 01 89 DE FC

Vx: November 17.768
23
E8 ?? ?? 5E 81 EE ?? ?? 50 33 C0 8E D8 80 3E ??
?? ?? 0E 1F ?? ?? FC

Vx: Number One
10
F9 07 3C 53 6D 69 6C 65 3E E8

Vx: Phoenix.927
17
E8 00 00 5E 81 C6 ?? ?? BF 00 01 B9 04 00 F3 A4
E8

Vx: Predator.2448
24
0E 1F BF ?? ?? B8 ?? ?? B9 ?? ?? 49 ?? ?? ?? ??
2A C1 4F 4F ?? ?? F9 CC

Vx: Quake.518
19
1E 06 8C C8 8E D8 ?? ?? ?? ?? ?? ?? ?? B8 21 35
CD 21 81

Vx: SK
15
CD 20 B8 03 00 CD 10 51 E8 00 00 5E 83 EE 09

Vx: Slowload
20
03 D6 B4 40 CD 21 B8 02 42 33 D2 33 C9 CD 21 8B
D6 B9 78 01

Vx: Sonik Youth
15
8A 16 02 00 8A 07 32 C2 88 07 43 FE C2 81 FB

Vx: Spanz
18
E8 00 00 5E 81 EE ?? ?? 8D 94 ?? ?? B4 1A CD 21
C7 84

Vx: SYP
17
47 8B C2 05 1E 00 52 8B D0 B8 02 3D CD 21 8B D8
5A

VX: Tibs/Zhelatin "StormWorm" variant
18
FF 74 24 1C 58 8D 80 ?? ?? 77 04 50 68 62 34 35
04 E8

Vx: TravJack.883
49
EB ?? 9C 9E 26 ?? ?? 51 04 ?? 7D ?? 00 ?? 2E ??
?? ?? ?? 8C C8 8E C0 8E D8 80 ?? ?? ?? ?? 74 ??
8A ?? ?? ?? BB ?? ?? 8A ?? 32 C2 88 ?? FE C2 43
81

Vx: Trivial.25
18
B4 4E FE C6 CD 21 B8 ?? 3D BA ?? 00 CD 21 93 B4
40 CD

Vx: Trivial.46
17
B4 4E B1 20 BA ?? ?? CD 21 BA ?? ?? B8 ?? 3D CD
21

Vx: Trojan.Telefoon
16
60 1E E8 3B 01 BF CC 01 2E 03 3E CA 01 2E C7 05

Vx: Uddy.2617
68
2E ?? ?? ?? ?? ?? 2E ?? ?? ?? ?? ?? 2E ?? ?? ??
8C C8 8E D8 8C ?? ?? ?? 2B ?? ?? ?? 03 ?? ?? ??
A3 ?? ?? A1 ?? ?? A3 ?? ?? A1 ?? ?? A3 ?? ?? 8C
C8 2B ?? ?? ?? 03 ?? ?? ?? A3 ?? ?? B8 AB 9C CD
2F 3D 76 98

Vx: VCL
16
AC B9 00 80 F2 AE B9 04 00 AC AE 75 ?? E2 FA 89

Vx: VCL (encrypted)
13
01 B9 ?? ?? 81 34 ?? ?? 46 46 E2 F8 C3

Vx: VCL (encrypted)
13
01 B9 ?? ?? 81 35 ?? ?? 47 47 E2 F8 C3

Vx: VirusConstructor(IVP).based
39
E9 ?? ?? E8 ?? ?? 5D ?? ?? ?? ?? ?? 81 ED ?? ??
?? ?? ?? ?? E8 ?? ?? 81 FC ?? ?? ?? ?? 8D ?? ??
?? BF ?? ?? 57 A4 A5

Vx: VirusConstructor.based
42
BB ?? ?? B9 ?? ?? 2E ?? ?? ?? ?? 43 43 ?? ?? 8B
EC CC 8B ?? ?? 81 ?? ?? ?? 06 1E B8 ?? ?? CD 21
3D ?? ?? ?? ?? 8C D8 48 8E D8

Vx: VirusConstructor.based
39
E8 ?? ?? 5D 81 ?? ?? ?? 06 1E E8 ?? ?? E8 ?? ??
?? ?? 2E ?? ?? ?? ?? ?? ?? B4 4A BB FF FF CD 21
83 ?? ?? B4 4A CD 21

Vx: XPEH.4768
33
E8 ?? ?? 5B 81 ?? ?? ?? 50 56 57 2E ?? ?? ?? ??
?? 2E ?? ?? ?? ?? ?? ?? B8 01 00 50 B8 ?? ?? 50
E8

Vx: XRCV.1015
36
E8 ?? ?? 5E 83 ?? ?? 53 51 1E 06 B4 99 CD 21 80
FC 21 ?? ?? ?? ?? ?? 33 C0 50 8C D8 48 8E C0 1F
A1 ?? ?? 8B

W32.Jeefo (PE File Infector)
25
55 89 E5 83 EC 08 83 C4 F4 6A 02 A1 C8 ?? ?? ??
FF D0 E8 ?? ?? ?? ?? C9 C3

WARNING -> TROJAN -> ADinjector
29
90 61 BE 00 20 44 00 8D BE 00 F0 FB FF C7 87 9C
E0 04 00 6A F0 8A 5E 57 83 CD FF EB 0E

WARNING -> TROJAN -> HuiGeZi
20
55 8B EC 81 C4 ?? FE FF FF 53 56 57 33 C0 89 85
?? FE FF FF

WARNING -> TROJAN -> RobinPE
15
60 6A 00 6A 20 6A 02 6A 00 6A 03 68 00 00 00

WARNING -> TROJAN -> XiaoHui
18
60 9C E8 00 00 00 00 5D B8 ?? 85 40 00 2D ?? 85
40 00

Warning! may be SimbyOZ polycryptor by 3xpl01t ver 2.xx (25.03.2007 22:00)
18
57 57 8D 7C 24 04 50 B8 00 D0 17 13 AB 58 5F C3
00 00

WebCops [DLL] -> LINK Data Security
23
A8 BE 58 DC D6 CC C4 63 4A 0F E0 02 BB CE F3 5C
50 23 FB 62 E7 3D 2B

WebCops [EXE] -> LINK Data Security
23
EB 03 05 EB 02 EB FC 55 EB 03 EB 04 05 EB FB EB
53 E8 04 00 00 00 72

Werus Crypter 1.0 - by Kas
13
BB E8 12 40 00 80 33 05 E9 7D FF FF FF

Werus Crypter 1.0 -> Kas
145
68 98 11 40 00 6A 00 E8 50 00 00 00 C9 C3 ED B3
FE FF FF 6A 00 E8 0C 00 00 00 FF 25 80 10 40 00
FF 25 84 10 40 00 FF 25 88 10 40 00 FF 25 8C 10
40 00 FF 25 90 10 40 00 FF 25 94 10 40 00 FF 25
98 10 40 00 FF 25 9C 10 40 00 FF 25 A0 10 40 00
FF 25 A4 10 40 00 FF 25 A8 10 40 00 FF 25 B0 10
40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 BB E8 12 40 00 80 33 05 E9 7D FF FF
FF

WIBU-Key V4.10A -> http://wibu.com/us/
12
F7 05 ?? ?? ?? ?? FF 00 00 00 75 12

Wind of Crypt 1.0 - by DarkPressure
326
55 8B EC 83 C4 EC 53 ?? ?? ?? ?? 89 45 EC B8 64
40 00 10 E8 28 EA FF FF 33 C0 55 68 CE 51 00 10
64 ?? ?? ?? ?? 20 6A 00 68 80 00 00 00 6A 03 6A
00 6A 01 68 00 00 00 80 8D 55 EC 33 C0 E8 F6 DB
FF FF 8B 45 EC E8 12 E7 FF FF 50 E8 3C EA FF FF
8B D8 83 FB FF 0F 84 A6 00 00 00 6A 00 53 E8 41
EA FF FF 8B F0 81 EE 00 5E 00 00 6A 00 6A 00 68
00 5E 00 00 53 E8 52 EA FF FF B8 F4 97 00 10 8B
D6 E8 2E E7 FF FF B8 F8 97 00 10 8B D6 E8 22 E7
FF FF 8B C6 E8 AB D8 FF FF 8B F8 6A 00 68 F0 97
00 10 56 A1 F4 97 00 10 50 53 E8 05 EA FF FF 53
E8 CF E9 FF FF B8 FC 97 00 10 BA E8 51 00 10 E8
74 EA FF FF A1 F4 97 00 10 85 C0 74 05 83 E8 04
8B 00 50 B9 F8 97 00 10 B8 FC 97 00 10 8B 15 F4
97 00 10 E8 D8 EA FF FF B8 FC 97 00 10 E8 5A EB
FF FF 8B CE 8B 15 F8 97 00 10 8B C7 E8 EB E9 FF
FF 8B C7 85 C0 74 05 E8 E4 EB FF FF 33 C0 5A 59
59 64 89 10 68 D5 51 00 10 8D 45 EC E8 BB E5 FF
FF C3 E9 A9 DF FF FF EB F0 5F 5E 5B E8 B7 E4 FF
FF 00 00 00 FF FF FF FF 0A 00 00 00 63 5A 6C 56
30 55 6C 6B 70 4D

Winkript v1.0
40
33 C0 8B B8 00 ?? ?? ?? 8B 90 04 ?? ?? ?? 85 FF
74 1B 33 C9 50 EB 0C 8A 04 39 C0 C8 04 34 1B 88
04 39 41 3B CA 72 F0 58

WinKript v1.0 -> Mr. Crimson
85
33 C0 8B B8 00 ?? ?? ?? 8B 90 04 ?? ?? ?? 85 FF
74 1B 33 C9 50 EB 0C 8A 04 39 C0 C8 04 34 1B 88
04 39 41 3B CA 72 F0 58 83 C0 08 EB D5 61 E9 ??
?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00

WinRAR 32-bit SFX Module
27
E9 ?? ?? 00 00 00 00 00 00 90 90 90 ?? ?? ?? ??
?? ?? 00 ?? 00 ?? ?? ?? ?? ?? FF

WinUpack v0.30 beta -> By Dwing
20
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00

WinUpack v0.30 beta -> By Dwing
23
E9 ?? ?? ?? ?? 42 79 44 77 69 6E 67 40 00 00 00
50 45 00 00 4C 01 02

WinUpack v0.39 final (relocated image base) -> By Dwing (c)2005 (h2)
85
60 E8 09 00 00 00 ?? ?? ?? 00 E9 06 02 00 00 33
C9 5E 87 0E E3 F4 2B F1 8B DE AD 2B D8 AD 03 C3
50 97 AD 91 F3 A5 5E AD 56 91 01 1E AD E2 FB AD
8D 6E 10 01 5D 00 8D 7D 1C B5 ?? F3 AB 5E AD 53
50 51 97 58 8D 54 85 5C FF 16 72 57 2C 03 73 02
B0 00 3C 07 72

WinUpack v0.39 final -> By Dwing (c)2005 (h1)
84
BE B0 11 ?? ?? AD 50 FF 76 34 EB 7C 48 01 ?? ??
0B 01 4C 6F 61 64 4C 69 62 72 61 72 79 41 00 00
18 10 00 00 10 00 00 00 00 ?? ?? ?? 00 00 ?? ??
00 10 00 00 00 02 00 00 04 00 00 00 00 00 39 00
04 00 00 00 00 00 00 00 00 ?? ?? ?? 00 02 00 00
00 00 00 00

WinZip (32-bit) 6.x
20
FF 15 FC 81 40 00 B1 22 38 08 74 02 B1 20 40 80
38 00 74 10

WinZip 32-bit SFX v6.x module
44
FF 15 ?? ?? ?? 00 B1 22 38 08 74 02 B1 20 40 80
38 00 74 10 38 08 74 06 40 80 38 00 75 F6 80 38
00 74 01 40 33 C9 ?? ?? ?? ?? FF 15

WinZip 32-bit SFX v8.x module
47
53 FF 15 ?? ?? ?? 00 B3 22 38 18 74 03 80 C3 FE
8A 48 01 40 33 D2 3A CA 74 0A 3A CB 74 06 8A 48
01 40 EB F2 38 10 74 01 40 ?? ?? ?? ?? FF 15

WinZip Self-Extractor 2.2 personal edition -> WinZip Computing
65
53 FF 15 58 70 40 00 B3 22 38 18 74 03 80 C3 FE
40 33 D2 8A 08 3A CA 74 10 3A CB 74 07 40 8A 08
3A CA 75 F5 38 10 74 01 40 52 50 52 52 FF 15 5C
70 40 00 50 E8 15 FB FF FF 50 FF 15 8C 70 40 00
5B

Wise Installer Stub
85
55 8B EC 81 EC 78 05 00 00 53 56 BE 04 01 00 00
57 8D 85 94 FD FF FF 56 33 DB 50 53 FF 15 34 20
40 00 8D 85 94 FD FF FF 56 50 8D 85 94 FD FF FF
50 FF 15 30 20 40 00 8B 3D 2C 20 40 00 53 53 6A
03 53 6A 01 8D 85 94 FD FF FF 68 00 00 00 80 50
FF D7 83 F8 FF

Wise Installer Stub
85
55 8B EC 81 EC ?? 04 00 00 53 56 57 6A ?? ?? ??
?? ?? ?? ?? FF 15 ?? ?? 40 00 ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? 80 ?? 20

Wise Installer Stub
85
55 8B EC 81 EC ?? ?? 00 00 53 56 57 6A 01 5E 6A
04 89 75 E8 FF 15 ?? 40 40 00 FF 15 ?? 40 40 00
8B F8 89 7D ?? 8A 07 3C 22 0F 85 ?? 00 00 00 8A
47 01 47 89 7D ?? 33 DB 3A C3 74 0D 3C 22 74 09
8A 47 01 47 89 7D ?? EB EF 80 3F 22 75 04 47 89
7D ?? 80 3F 20

Wise Installer Stub v1.10.1029.1
85
55 8B EC 81 EC 40 0F 00 00 53 56 57 6A 04 FF 15
F4 30 40 00 FF 15 74 30 40 00 8A 08 89 45 E8 80
F9 22 75 48 8A 48 01 40 89 45 E8 33 F6 84 C9 74
0E 80 F9 22 74 09 8A 48 01 40 89 45 E8 EB EE 80
38 22 75 04 40 89 45 E8 80 38 20 75 09 40 80 38
20 74 FA 89 45

WWPACK v3.00, v3.01 (Extractable)
27
B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ?? ?? 51 6A ??
06 06 8C D3 83 ?? ?? 53 6A ?? FC

WWPACK v3.00, v3.01 (Relocations pack)
29
BE ?? ?? BA ?? ?? BF ?? ?? B9 ?? ?? 8C CD 8E DD
81 ED ?? ?? 06 06 8B DD 2B DA 8B D3 FC

WWPACK v3.02, v3.02a (Extractable)
27
B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ?? ?? 51 33 C9
B1 ?? 51 06 06 BB ?? ?? 53 8C D3

WWPACK v3.02, v3.02a, v3.04 (Relocations pack)
34
BE ?? ?? BF ?? ?? B9 ?? ?? 8C CD 81 ED ?? ?? 8B
DD 81 EB ?? ?? 8B D3 FC FA 1E 8E DB 01 15 33 C0
2E AC

WWPACK v3.03
24
B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ?? ?? 51 B9 ??
?? 51 06 06 BB ?? ?? 53

WWPACK v3.05c4 (Extr. Passw.check. Vir. shield)
29
03 05 C0 1A B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Extractable + Password checking)
29
03 05 80 1A B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Extractable + Virus Shield)
29
03 05 40 1A B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Extractable)
29
03 05 00 1A B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Modified)
25
B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ?? ?? 51 B9 ??
?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Unextr. Passw.check. Vir. shield)
29
03 05 C0 1B B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Unextractable + Password checking)
29
03 05 80 1B B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Unextractable + Virus Shield)
29
03 05 40 1B B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPACK v3.05c4 (Unextractable)
29
03 05 00 1B B8 ?? ?? 8C CA 03 D0 8C C9 81 C1 ??
?? 51 B9 ?? ?? 51 06 06 B1 ?? 51 8C D3

WWPack32 v1.00, v1.11, v1.12, v1.20
20
53 55 8B E8 33 DB EB 60 0D 0A 0D 0A 57 57 50 61
63 6B 33 32

WWPack32 v1.x
8
53 55 8B E8 33 DB EB 60

X-Hider 1.0 -> GlobaL
167
55 8B EC 83 C4 EC 33 C0 89 45 EC B8 54 20 44 44
E8 DF F8 FF FF 33 C0 55 68 08 21 44 44 64 FF 30
64 89 20 8D 55 EC B8 1C 21 44 44 E8 E0 F9 FF FF
8B 55 EC B8 40 ?? ?? 44 E8 8B F5 FF FF 6A 00 6A
00 6A 02 6A 00 6A 01 68 00 00 00 40 A1 40 ?? ??
44 E8 7E F6 FF FF 50 E8 4C F9 FF FF 6A 00 50 E8
4C F9 FF FF A3 28 ?? ?? 44 E8 CE FE FF FF 33 C0
5A 59 59 64 89 10 68 0F 21 44 44 8D 45 EC E8 F1
F4 FF FF C3 E9 BB F2 FF FF EB F0 E8 FC F3 FF FF
FF FF FF FF 0E 00 00 00 63 3A 5C 30 30 30 30 30
30 31 2E 64 61 74 00

X-Hider 1.0 -> GlobaL
112
85 D2 74 23 8B 4A F8 41 7F 1A 50 52 8B 42 FC E8
30 00 00 00 89 C2 58 52 8B 48 FC E8 48 FB FF FF
5A 58 EB 03 FF 42 F8 87 10 85 D2 74 13 8B 4A F8
49 7C 0D FF 4A F8 75 08 8D 42 F8 E8 5C FA FF FF
C3 8D 40 00 85 C0 7E 24 50 83 C0 0A 83 E0 FE 50
E8 2F FA FF FF 5A 66 C7 44 02 FE 00 00 83 C0 08
5A 89 50 FC C7 40 F8 01 00 00 00 C3 31 C0 C3 90

X-Pack v1.4.2
32
72 ?? C3 8B DE 83 ?? ?? C1 ?? ?? 8C D8 03 C3 8E
D8 8B DF 83 ?? ?? C1 ?? ?? 8C C0 03 C3 8E C0 C3

X-PEOR v0.99b
20
E8 00 00 00 00 5D 8B CD 81 ED 7A 29 40 00 89 AD
0F 6D 40 00

X-PEOR v0.99b
19
E8 ?? ?? ?? ?? 5D 8B CD 81 ED 7A 29 40 ?? 89 AD
0F 6D 40

XCR v0.12
18
60 9C E8 ?? ?? ?? ?? 8B DD 5D 81 ED ?? ?? ?? ??
89 9D

XCR v0.13
68
93 71 08 ?? ?? ?? ?? ?? ?? ?? ?? 8B D8 78 E2 ??
?? ?? ?? 9C 33 C3 ?? ?? ?? ?? 60 79 CE ?? ?? ??
?? E8 01 ?? ?? ?? ?? 83 C4 04 E8 AB FF FF FF ??
?? ?? ?? 2B E8 ?? ?? ?? ?? 03 C5 FF 30 ?? ?? ??
?? C6 ?? EB

XJ / XPAL -> LiNSoN
37
55 8B EC 6A FF 68 ?? ?? 40 00 68 ?? ?? 40 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 44
53 56 57 66 9C

XPack 1.52 - 1.64
21
8B EC FA 33 C0 8E D0 BC ?? ?? 2E ?? ?? ?? ?? 2E
?? ?? ?? ?? EB

XPack 1.67
27
B8 8C D3 15 33 75 81 3E E8 0F 00 9A E8 F9 FF 9A
9C EB 01 9A 59 80 CD 01 51 9D EB

xPEP 0.3x -> xIkUg
11
55 53 56 51 52 57 E8 16 00 00 00

Xtreme-Protector v1.05
11
E9 ?? ?? 00 00 00 00 00 00 00 00

Xtreme-Protector v1.06
85
B8 ?? ?? ?? 00 B9 75 ?? ?? 00 50 51 E8 05 00 00
00 E9 4A 01 00 00 60 8B 74 24 24 8B 7C 24 28 FC
B2 80 8A 06 46 88 07 47 BB 02 00 00 00 02 D2 75
05 8A 16 46 12 D2 73 EA 02 D2 75 05 8A 16 46 12
D2 73 4F 33 C0 02 D2 75 05 8A 16 46 12 D2 0F 83
DF 00 00 00 02

XXPack 0.1 -> bagie
63
E8 04 00 00 00 83 60 EB 0C 5D EB 05 45 55 EB 04
B8 EB F9 00 C3 E8 00 00 00 00 5D EB 01 00 81 ED
5E 1F 40 00 EB 02 83 09 8D B5 EF 1F 40 00 EB 02
83 09 BA A3 11 00 00 EB 00 68 00 ?? ?? ?? C3

y0da's Crypter v1.0
30
60 E8 00 00 00 00 5D 81 ED E7 1A 40 00 E8 A1 00
00 00 E8 D1 00 00 00 E8 85 01 00 00 F7 85

y0da's Crypter v1.1
27
60 E8 00 00 00 00 5D 81 ED 8A 1C 40 00 B9 9E 00
00 00 8D BD 4C 23 40 00 8B F7 33

y0da's Crypter v1.2
78
60 E8 00 00 00 00 5D 81 ED F3 1D 40 00 B9 7B 09
00 00 8D BD 3B 1E 40 00 8B F7 AC ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? AA E2 CC

y0da's Crypter v1.x / Modified
27
60 E8 00 00 00 00 5D 81 ED ?? ?? ?? ?? B9 ?? ??
00 00 8D BD ?? ?? ?? ?? 8B F7 AC

yC v1.3 by Ashkbiz Danehkar
75
55 8B EC 81 EC C0 00 00 00 53 56 57 8D BD 40 FF
FF FF B9 30 00 00 00 B8 CC CC CC CC F3 AB 60 E8
00 00 00 00 5D 81 ED 84 52 41 00 B9 75 5E 41 00
81 E9 DE 52 41 00 8B D5 81 C2 DE 52 41 00 8D 3A
8B F7 33 C0 EB 04 90 EB 01 C2 AC

yoda's Crypter 1.3 -> Ashkbiz Danehkar
51
55 8B EC 53 56 57 60 E8 00 00 00 00 5D 81 ED 6C
28 40 00 B9 5D 34 40 00 81 E9 C6 28 40 00 8B D5
81 C2 C6 28 40 00 8D 3A 8B F7 33 C0 EB 04 90 EB
01 C2 AC

yoda's Protector 1.02 - 1.03 -> Ashkbiz Danehkar
64
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AB 00 00

yoda's Protector 1.02 -> Ashkibiz Danehlar
85
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AB 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75

yoda's Protector 1.0x -> Ashkbiz Danehkar
13
55 8B EC 53 56 57 E8 03 00 00 00 EB 01

yoda's Protector v1.01 -> Ashkbiz Danehkar
85
55 8B EC 53 56 57 E8 03 00 00 00 EB 01 ?? E8 86
00 00 00 E8 03 00 00 00 EB 01 ?? E8 79 00 00 00
E8 03 00 00 00 EB 01 ?? E8 A4 00 00 00 E8 03 00
00 00 EB 01 ?? E8 97 00 00 00 E8 03 00 00 00 EB
01 ?? E8 2D 00 00 00 E8 03 00 00 00 EB 01 ?? 60
E8 00 00 00 00

yoda's Protector V1.01 -> Ashkbiz Danehkar
163
55 8B EC 53 56 57 E8 03 00 00 00 EB 01 ?? E8 86
00 00 00 E8 03 00 00 00 EB 01 ?? E8 79 00 00 00
E8 03 00 00 00 EB 01 ?? E8 A4 00 00 00 E8 03 00
00 00 EB 01 ?? E8 97 00 00 00 E8 03 00 00 00 EB
01 ?? E8 2D 00 00 00 E8 03 00 00 00 EB 01 ?? 60
E8 00 00 00 00 5D 81 ED D5 E4 41 00 8B D5 81 C2
23 E5 41 00 52 E8 01 00 00 00 C3 C3 E8 03 00 00
00 EB 01 ?? E8 0E 00 00 00 E8 D1 FF FF FF C3 E8
03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20 CC
C3 E8 03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89
20 CC C3

yoda's Protector V1.02 -> Ashkbiz Danehkar
247
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AB 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75 2E E8 03 00 00 00 EB 01 ?? C3 60
E8 00 00 00 00 5D 81 ED 23 3F 42 00 8B D5 81 C2
72 3F 42 00 52 E8 01 00 00 00 C3 C3 E8 03 00 00
00 EB 01 ?? E8 0E 00 00 00 E8 D1 FF FF FF C3 E8
03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20 CC
C3 E8 03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89
20 4B CC C3 E8 03 00 00 00 EB 01 ?? 33 DB B9 3A
66 42 00 81 E9 1D 40 42 00 8B D5 81 C2 1D 40 42
00 8D 3A 8B F7 33 C0 E8 03 00 00 00 EB 01 ?? E8
17 00 00 00 90 90 90 E9 C3 1F 00 00 33 C0 64 FF
30 64 89 20 43 CC C3

yoda's Protector V1.03.1 -> Ashkbiz Danehkar
247
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AB 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75 2E E8 03 00 00 00 EB 01 ?? C3 60
E8 00 00 00 00 5D 81 ED 74 72 42 00 8B D5 81 C2
C3 72 42 00 52 E8 01 00 00 00 C3 C3 E8 03 00 00
00 EB 01 ?? E8 0E 00 00 00 E8 D1 FF FF FF C3 E8
03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20 CC
C3 E8 03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89
20 4B CC C3 E8 03 00 00 00 EB 01 ?? 33 DB B9 3F
A9 42 00 81 E9 6E 73 42 00 8B D5 81 C2 6E 73 42
00 8D 3A 8B F7 33 C0 E8 03 00 00 00 EB 01 ?? E8
17 00 00 00 90 90 90 E9 98 2E 00 00 33 C0 64 FF
30 64 89 20 43 CC C3

yoda's Protector V1.03.2 -> Ashkbiz Danehkar
247
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AB 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75 2E E8 03 00 00 00 EB 01 ?? C3 60
E8 00 00 00 00 5D 81 ED 94 73 42 00 8B D5 81 C2
E3 73 42 00 52 E8 01 00 00 00 C3 C3 E8 03 00 00
00 EB 01 ?? E8 0E 00 00 00 E8 D1 FF FF FF C3 E8
03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20 CC
C3 E8 03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89
20 4B CC C3 E8 03 00 00 00 EB 01 ?? 33 DB B9 BF
A4 42 00 81 E9 8E 74 42 00 8B D5 81 C2 8E 74 42
00 8D 3A 8B F7 33 C0 E8 03 00 00 00 EB 01 ?? E8
17 00 00 00 90 90 90 E9 63 29 00 00 33 C0 64 FF
30 64 89 20 43 CC C3

Yoda's Protector v1.03.2 Beta2 -> Ashkbiz Danehkar
52
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8F 00 00 00 E8 03 00 00 00 EB
01 ?? E8 82 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B8 00 00 00

yoda's Protector v1.03.3 (.exe,.scr,.com) -> Ashkbiz Danehkar
85
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8E 00 00 00 E8 03 00 00 00 EB
01 ?? E8 81 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B7 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AA 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75

yoda's Protector V1.03.3 -> Ashkbiz Danehkar
179
E8 03 00 00 00 EB 01 ?? BB 55 00 00 00 E8 03 00
00 00 EB 01 ?? E8 8E 00 00 00 E8 03 00 00 00 EB
01 ?? E8 81 00 00 00 E8 03 00 00 00 EB 01 ?? E8
B7 00 00 00 E8 03 00 00 00 EB 01 ?? E8 AA 00 00
00 E8 03 00 00 00 EB 01 ?? 83 FB 55 E8 03 00 00
00 EB 01 ?? 75 2D E8 03 00 00 00 EB 01 ?? 60 E8
00 00 00 00 5D 81 ED 07 E2 40 00 8B D5 81 C2 56
E2 40 00 52 E8 01 00 00 00 C3 C3 E8 03 00 00 00
EB 01 ?? E8 0E 00 00 00 E8 D1 FF FF FF C3 E8 03
00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20 CC C3
E8 03 00 00 00 EB 01 ?? 33 C0 64 FF 30 64 89 20
4B CC C3

yoda's Protector v1.0b -> Ashkbiz Danehkar
68
55 8B EC 53 56 57 60 E8 00 00 00 00 5D 81 ED 4C
32 40 00 E8 03 00 00 00 EB 01 ?? B9 EA 47 40 00
81 E9 E9 32 40 00 8B D5 81 C2 E9 32 40 00 8D 3A
8B F7 33 C0 E8 04 00 00 00 90 EB 01 ?? E8 03 00
00 00 EB 01

yP v1.0b by Ashkbiz Danehkar
80
55 8B EC 53 56 57 60 E8 00 00 00 00 5D 81 ED 4C
32 40 00 E8 03 00 00 00 EB 01 ?? B9 EA 47 40 00
81 E9 E9 32 40 00 8B D5 81 C2 E9 32 40 00 8D 3A
8B F7 33 C0 E8 04 00 00 00 90 EB 01 C2 E8 03 00
00 00 EB 01 ?? AC ?? ?? ?? ?? ?? ?? ?? EB 01 E8

yzpack 1.12 -> UsAr
95
5A 52 45 60 83 EC 18 8B EC 8B FC 33 C0 64 8B 40
30 78 0C 8B 40 0C 8B 70 1C AD 8B 40 08 EB 09 8B
40 34 83 C0 7C 8B 40 3C AB E9 ?? ?? ?? ?? B4 09
BA 00 00 1F CD 21 B8 01 4C CD 21 40 00 00 00 50
45 00 00 4C 01 02 00 ?? ?? ?? ?? 00 00 00 00 00
00 00 00 E0 00 ?? ?? 0B 01 ?? ?? ?? ?? 00 00

YZPack 1.2 --> UsAr
43
4D 5A 52 45 60 83 EC 18 8B EC 8B FC 33 C0 64 8B
40 30 78 0C 8B 40 0C 8B 70 1C AD 8B 40 08 EB 09
8B 40 34 83 C0 7C 8B 40 3C AB E9

yzpack 2.0 -> UsAr
133
25 ?? ?? ?? ?? 61 87 CC 55 45 45 55 81 ED CA 00
00 00 55 A4 B3 02 FF 14 24 73 F8 33 C9 FF 14 24
73 18 33 C0 FF 14 24 73 1F B3 02 41 B0 10 FF 14
24 12 C0 73 F9 75 3C AA EB DC FF 54 24 04 2B CB
75 0F FF 54 24 08 EB 27 AC D1 E8 74 30 13 C9 EB
1B 91 48 C1 E0 08 AC FF 54 24 08 3D 00 7D 00 00
73 0A 80 FC 05 73 06 83 F8 7F 77 02 41 41 95 8B
C5 B3 01 56 8B F7 2B F0 F3 A4 5E EB 99 BD ?? ??
?? ?? FF 65 28

yzpack V1.1 -> UsAr
81
60 33 C0 8D 48 07 50 E2 FD 8B EC 64 8B 40 30 78
0C 8B 40 0C 8B 70 1C AD 8B 40 08 EB 09 8B 40 34
8D 40 7C 8B 40 3C 89 45 04 E8 F3 07 00 00 60 8B
5D 04 8B 73 3C 8B 74 33 78 03 F3 56 8B 76 20 03
F3 33 C9 49 92 41 AD 03 C3 52 33 FF 0F B6 10 38
F2

ZCode Win32/PE Protector v1.01
31
E9 12 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? E9 FB FF FF FF C3 68 ?? ?? ?? ?? 64 FF 35

ZealPack 1.0 -> Zeal
88
C7 45 F4 00 00 40 00 C7 45 F0 ?? ?? ?? ?? 8B 45
F4 05 ?? ?? ?? ?? 89 45 F4 C7 45 FC 00 00 00 00
EB 09 8B 4D FC 83 C1 01 89 4D FC 8B 55 FC 3B 55
F0 7D 22 8B 45 F4 03 45 FC 8A 08 88 4D F8 0F BE
55 F8 83 F2 0F 88 55 F8 8B 45 F4 03 45 FC 8A 4D
F8 88 08 EB CD FF 65 F4

ZipWorxSecureEXE v2.5 -> ZipWORX Technologies LLC
85
E9 B8 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? 00 00 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
00 53 65 63 75 72 65 45 58 45 20 45 78 65 63 75
74 61 62 6C 65 20 46 69 6C 65 20 50 72 6F 74 65
63 74 6F 72 0D 0A 43 6F 70 79 72 69 67 68 74 28
63 29 20 32 30

[MSLRH]
288
60 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8
0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2
FF FF FF 83 C4 08 2B 04 24 74 04 75 02 EB 02 EB
01 81 83 C4 04 E8 0A 00 00 00 E8 EB 0C 00 00 E8
F6 FF FF FF E8 F2 FF FF FF 83 C4 08 3D FF 0F 00
00 EB 01 68 EB 02 CD 20 EB 01 E8 76 1B EB 01 68
EB 02 CD 20 EB 01 E8 CC 66 B8 FE 00 74 04 75 02
EB 02 EB 01 81 66 E7 64 E8 0A 00 00 00 E8 EB 0C
00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74
04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00
00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF
FF 83 C4 08 2B 04 24 74 04 75 02 EB 02 EB 01 81

[MSLRH] v0.1 -> emadicius
276
60 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8
EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4
08 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8
0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2
FF FF FF 83 C4 08 2B 04 24 74 04 75 02 EB 02 EB
01 81 83 C4 04 E8 0A 00 00 00 E8 EB 0C 00 00 E8
F6 FF FF FF E8 F2 FF FF FF 83 C4 08 3D FF 0F 00
00 EB 01 68 EB 02 CD 20 EB 01 E8 76 1B EB 01 68
EB 02 CD 20 EB 01 E8 CC 66 B8 FE 00 74 04 75 02
EB 02 EB 01 81 66 E7 64 E8 0A 00 00 00 E8 EB 0C
00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74
04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00
00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF
FF 83 C4 08

[MSLRH] v0.31a
255
60 D1 CB 0F CA C1 CA E0 D1 CA 0F C8 EB 01 F1 0F
C0 C9 D2 D1 0F C1 C0 D3 DA C0 D6 A8 EB 01 DE D0
EC 0F C1 CB D0 CF 0F C1 D1 D2 DB 0F C8 EB 01 BC
C0 E9 C6 C1 D0 91 0F CB EB 01 73 0F CA 87 D9 87
D2 D0 CF 87 D9 0F C8 EB 01 C1 EB 01 A2 86 CA D0
E1 0F C0 CB 0F CA C0 C7 91 0F CB C1 D9 0C 86 F9
86 D7 D1 D9 EB 01 A5 EB 01 11 EB 01 1D 0F C1 C2
0F CB 0F C1 C2 EB 01 A1 C0 E9 FD 0F C1 D1 EB 01
E3 0F CA 87 D9 EB 01 F3 0F CB 87 C2 0F C0 F9 D0
F7 EB 01 2F 0F C9 C0 DC C4 EB 01 35 0F CA D3 D1
86 C8 EB 01 01 0F C0 F5 87 C8 D0 DE EB 01 95 EB
01 E1 EB 01 FD EB 01 EC 87 D3 0F CB C1 DB 35 D3
E2 0F C8 86 E2 86 EC C1 FB 12 D2 EE 0F C9 D2 F6
0F CA 87 C3 C1 D3 B3 EB 01 BF D1 CB 87 C9 0F CA
0F C1 DB EB 01 44 C0 CA F2 0F C1 D1 0F CB EB 01
D3 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00

[MSLRH] v0.32a (fake .BJFNT 1.3) -> emadicius
155
EB 03 3A 4D 3A 1E EB 02 CD 20 9C EB 02 CD 20 EB
02 CD 20 60 EB 02 C7 05 EB 02 CD 20 E8 03 00 00
00 E9 EB 04 58 40 50 C3 61 9D 1F EB 05 E8 EB 04
40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6
FF FF FF E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB
02 EB 01 81 50 E8 02 00 00 00 29 5A 58 6B C0 03
E8 02 00 00 00 29 5A 83 C4 04 58 74 04 75 02 EB
02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
2B 04 24 74 04 75 02 EB 02 EB 01

[MSLRH] v0.32a (fake ASPack 2.11d) -> emadicius
116
60 E8 02 00 00 00 EB 09 5D 55 81 ED 39 39 44 00
C3 61 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00
E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83
C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02 00 00
00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A 83 C4
04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31
E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8
F2 FF FF FF

[MSLRH] v0.32a (fake ASPack 2.12) -> emadicius
130
60 E8 03 00 00 00 E9 EB 04 5D 45 55 C3 E8 01 00
00 00 EB 5D BB ED FF FF FF 03 DD 81 EB 00 A0 02
EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
74 04 75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29
5A 58 6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58
74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A
00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF
FF FF

[MSLRH] v0.32a (fake EXE32Pack 1.3x) -> emadicius
138
3B C0 74 02 81 83 55 3B C0 74 02 81 83 53 3B C9
74 01 BC 56 3B D2 74 02 81 85 57 E8 00 00 00 00
3B DB 74 01 90 83 C4 14 EB 05 E8 EB 04 40 00 EB
FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01
81 50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00
00 00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01
81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00
E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake Microsoft Visual C++) -> emadicius
152
55 8B EC 6A FF 68 CA 37 41 00 68 06 38 41 00 64
A1 00 00 00 00 50 64 89 25 00 00 00 00 64 8F 05
00 00 00 00 83 C4 0C 5D EB 05 E8 EB 04 40 00 EB
FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01
81 50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00
00 00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01
81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00
E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 2B 04 24
74 04 75 02 EB 02 EB 01

[MSLRH] v0.32a (fake MSVC++ 6.0 DLL) -> emadicius
119
55 8B EC 53 8B 5D 08 56 8B 75 0C 57 8B 7D 10 85
F6 5F 5E 5B 5D EB 05 E8 EB 04 40 00 EB FA E8 0A
00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF
FF FF 83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8
02 00 00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29
5A 83 C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31
50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF
FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake MSVC++ 7.0 DLL Method 3) -> emadicius
112
55 8B EC 53 8B 5D 08 56 8B 75 0C 5E 5B 5D EB 05
E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00
00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74 04
75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29 5A 58
6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58 74 04
75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake MSVC++ DLL Method 4) -> emadicius
116
55 8B EC 56 57 BF 01 00 00 00 8B 75 0C 85 F6 5F
5E 5D EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00
E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83
C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02 00 00
00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A 83 C4
04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31
E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8
F2 FF FF FF

[MSLRH] v0.32a (fake Neolite 2.0) -> emadicius
283
E9 A6 00 00 00 B0 7B 40 00 78 60 40 00 7C 60 40
00 00 00 00 00 B0 3F 00 00 12 62 40 00 4E 65 6F
4C 69 74 65 20 45 78 65 63 75 74 61 62 6C 65 20
46 69 6C 65 20 43 6F 6D 70 72 65 73 73 6F 72 0D
0A 43 6F 70 79 72 69 67 68 74 20 28 63 29 20 31
39 39 38 2C 31 39 39 39 20 4E 65 6F 57 6F 72 78
20 49 6E 63 0D 0A 50 6F 72 74 69 6F 6E 73 20 43
6F 70 79 72 69 67 68 74 20 28 63 29 20 31 39 39
37 2D 31 39 39 39 20 4C 65 65 20 48 61 73 69 75
6B 0D 0A 41 6C 6C 20 52 69 67 68 74 73 20 52 65
73 65 72 76 65 64 2E 00 00 00 00 EB 05 E8 EB 04
40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6
FF FF FF E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB
02 EB 01 81 50 E8 02 00 00 00 29 5A 58 6B C0 03
E8 02 00 00 00 29 5A 83 C4 04 58 74 04 75 02 EB
02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
2B 04 24 74 04 75 02 EB 02 EB 01

[MSLRH] v0.32a (fake nSPack 1.3) -> emadicius
164
9C 60 E8 00 00 00 00 5D B8 B3 85 40 00 2D AC 85
40 00 2B E8 8D B5 D3 FE FF FF 8B 06 83 F8 00 74
11 8D B5 DF FE FF FF 8B 06 83 F8 01 0F 84 F1 01
00 00 61 9D EB 05 E8 EB 04 40 00 EB FA E8 0A 00
00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF
FF 83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02
00 00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A
83 C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50
0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF
FF E8 F2 FF FF FF 83 C4 08 2B 04 24 74 04 75 02
EB 02 EB 01

[MSLRH] v0.32a (fake PC-Guard 4.xx) -> emadicius
133
FC 55 50 E8 00 00 00 00 5D EB 01 E3 60 E8 03 00
00 00 D2 EB 0B 58 EB 01 48 40 EB 01 35 FF E0 E7
61 58 5D EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF
83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02 00
00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A 83
C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F
31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF

[MSLRH] v0.32a (fake PE Crypt 1.02) -> emadicius
144
E8 00 00 00 00 5B 83 EB 05 EB 04 52 4E 44 21 85
C0 73 02 F7 05 50 E8 08 00 00 00 EA FF 58 EB 18
EB 01 0F EB 02 CD 20 EB 03 EA CD 20 58 58 EB 05
E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00
00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74 04
75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29 5A 58
6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58 74 04
75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PE Lock NT 2.04) -> emadicius
153
EB 03 CD 20 C7 1E EB 03 CD 20 EA 9C EB 02 EB 01
EB 01 EB 60 EB 03 CD 20 EB EB 01 EB E8 03 00 00
00 E9 EB 04 58 40 50 C3 EB 03 CD 20 EB EB 03 CD
20 03 61 9D 83 C4 04 EB 05 E8 EB 04 40 00 EB FA
E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8
F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01 81
50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00 00
00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01 81
0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8
F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PEBundle 0.2 - 3.x) -> emadicius
128
9C 60 E8 02 00 00 00 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB 07 30 40 00 87 DD 61 9D EB 05
E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00
00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74 04
75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29 5A 58
6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58 74 04
75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PEBundle 2.0x - 2.4x) -> emadicius
135
9C 60 E8 02 00 00 00 33 C0 8B C4 83 C0 04 93 8B
E3 8B 5B FC 81 EB 07 30 40 00 87 DD 83 BD 9C 38
40 00 01 61 9D EB 05 E8 EB 04 40 00 EB FA E8 0A
00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF
FF FF 83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8
02 00 00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29
5A 83 C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31
50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF
FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PECompact 1.4x) -> emadicius
134
EB 06 68 2E A8 00 00 C3 9C 60 E8 02 00 00 00 33
C0 8B C4 83 C0 04 93 8B E3 8B 5B FC 81 EB 3F 90
40 00 61 9D EB 05 E8 EB 04 40 00 EB FA E8 0A 00
00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF
FF 83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02
00 00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A
83 C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50
0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF
FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PESHiELD 0.25) -> emadicius
149
60 E8 2B 00 00 00 0D 0A 0D 0A 0D 0A 52 65 67 69
73 74 41 72 65 64 20 74 6F 3A 20 4E 4F 4E 2D 43
4F 4D 4D 45 52 43 49 41 4C 21 21 0D 0A 0D 0A 0D
00 58 61 EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF
83 C4 08 74 04 75 02 EB 02 EB 01 81 50 E8 02 00
00 00 29 5A 58 6B C0 03 E8 02 00 00 00 29 5A 83
C4 04 58 74 04 75 02 EB 02 EB 01 81 0F 31 50 0F
31 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF

[MSLRH] v0.32a (fake PEtite 2.1) -> emadicius
144
B8 00 50 40 00 6A 00 68 BB 21 40 00 64 FF 35 00
00 00 00 64 89 25 00 00 00 00 66 9C 60 50 83 C4
04 61 66 9D 64 8F 05 00 00 00 00 83 C4 08 EB 05
E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00
00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74 04
75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29 5A 58
6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58 74 04
75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00
00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake PEX 0.99) -> emadicius
136
60 E8 01 00 00 00 E8 83 C4 04 E8 01 00 00 00 E9
5D 81 ED FF 22 40 00 61 EB 05 E8 EB 04 40 00 EB
FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01
81 50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00
00 00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01
81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00
E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 2B 04 24
74 04 75 02 EB 02 EB 01

[MSLRH] v0.32a (fake SVKP 1.11) -> emadicius
135
60 E8 00 00 00 00 5D 81 ED 06 00 00 00 64 A0 23
00 00 00 83 C5 06 61 EB 05 E8 EB 04 40 00 EB FA
E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8
F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01 81
50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00 00
00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01 81
0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00 E8
F6 FF FF FF E8 F2 FF FF FF 83 C4 08 2B 04 24 74
04 75 02 EB 02 EB 01

[MSLRH] v0.32a (fake UPX 0.89.6 - 1.02 / 1.05 - 1.24) -> emadicius
177
60 BE 00 90 8B 00 8D BE 00 80 B4 FF 57 83 CD FF
EB 3A 90 90 90 90 90 90 8A 06 46 88 07 47 01 DB
75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00 00 00
01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB 73
0B 75 19 8B 1E 83 EE FC 11 DB 72 10 58 61 90 EB
05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB 0C
00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74
04 75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29 5A
58 6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58 74
04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A 00
00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF
FF

[MSLRH] v0.32a (fake WWPack32 1.x) -> emadicius
205
53 55 8B E8 33 DB EB 60 0D 0A 0D 0A 57 57 50 61
63 6B 33 32 20 64 65 63 6F 6D 70 72 65 73 73 69
6F 6E 20 72 6F 75 74 69 6E 65 20 76 65 72 73 69
6F 6E 20 31 2E 31 32 0D 0A 28 63 29 20 31 39 39
38 20 50 69 6F 74 72 20 57 61 72 65 7A 61 6B 20
61 6E 64 20 52 61 66 61 6C 20 57 69 65 72 7A 62
69 63 6B 69 0D 0A 0D 0A 5D 5B 90 EB 05 E8 EB 04
40 00 EB FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6
FF FF FF E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB
02 EB 01 81 50 E8 02 00 00 00 29 5A 58 6B C0 03
E8 02 00 00 00 29 5A 83 C4 04 58 74 04 75 02 EB
02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a (fake yoda's cryptor 1.2) -> emadicius
138
60 E8 00 00 00 00 5D 81 ED F3 1D 40 00 B9 7B 09
00 00 8D BD 3B 1E 40 00 8B F7 AC 90 2C 8A C0 C0
78 90 04 62 EB 01 00 61 EB 05 E8 EB 04 40 00 EB
FA E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF
E8 F2 FF FF FF 83 C4 08 74 04 75 02 EB 02 EB 01
81 50 E8 02 00 00 00 29 5A 58 6B C0 03 E8 02 00
00 00 29 5A 83 C4 04 58 74 04 75 02 EB 02 EB 01
81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB 0C 00 00
E8 F6 FF FF FF E8 F2 FF FF FF

[MSLRH] v0.32a -> emadicius
163
E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83
C4 08 74 04 75 02 EB 02 EB 01 81 74 04 75 02 EB
02 EB 01 81 0F 31 50 0F 31 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
2B 04 24 74 04 75 02 EB 02 EB 01 81 83 C4 04 E8
0A 00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2
FF FF FF 83 C4 08 3D FF FF FF 00 EB 01 68 EB 02
CD 20 EB 01 E8 76 1B EB 01 68 EB 02 CD 20 EB 01
E8 CC 66 B8 FE 00 74 04 75 02 EB 02 EB 01 81 66
E7 64 74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00
E8 EB 0C

[MSLRH] v32a -> emadicius
252
EB 05 E8 EB 04 40 00 EB FA E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
74 04 75 02 EB 02 EB 01 81 E8 0A 00 00 00 E8 EB
0C 00 00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08
74 04 75 02 EB 02 EB 01 81 50 E8 02 00 00 00 29
5A 58 6B C0 03 E8 02 00 00 00 29 5A 83 C4 04 58
74 04 75 02 EB 02 EB 01 81 0F 31 50 0F 31 E8 0A
00 00 00 E8 EB 0C 00 00 E8 F6 FF FF FF E8 F2 FF
FF FF 83 C4 08 2B 04 24 74 04 75 02 EB 02 EB 01
81 83 C4 04 E8 0A 00 00 00 E8 EB 0C 00 00 E8 F6
FF FF FF E8 F2 FF FF FF 83 C4 08 3D FF 0F 00 00
EB 01 68 EB 02 CD 20 EB 01 E8 76 1B EB 01 68 EB
02 CD 20 EB 01 E8 CC 66 B8 FE 00 74 04 75 02 EB
02 EB 01 81 66 E7 64 E8 0A 00 00 00 E8 EB 0C 00
00 E8 F6 FF FF FF E8 F2 FF FF FF 83 C4 08 74 04
75 02 EB 02 EB 01 81 0F 31 50 0F 31


```

`build.sh`:

```sh
#!/bin/bash

./build_qt5.sh

```

`build_qt4.sh`:

```sh
#!/bin/bash

echo "Trying to build PE-bear..."

#QT check

QT_VER=`qmake -v`
QTV="version"
if echo "$QT_VER" | grep -q "$QTV"; then
    QT4_FOUND=`whereis qt4`
    if echo "$QT4_FOUND" | grep -q "lib"; then
        echo "[+] Qt4 found!"
    else
        echo "Install Qt4 SDK first"
        exit -2
    fi
else
    echo "Install Qt4 SDK first"
    exit -1
fi

CMAKE_VER=`cmake --version`
CMAKEV="cmake version"
if echo "$CMAKE_VER" | grep -q "$CMAKEV"; then
    echo "[+] CMake found!"
else
    echo "[-] CMake NOT found!"
    echo "Install cmake first"
    exit -1
fi

echo $CMAKE_VER
mkdir build_qt4
echo "[+] build directory created"
cd build_qt4
cmake -DUSE_QT4=ON -DCMAKE_INSTALL_PREFIX:PATH=$(pwd) ..
cmake --build . --target install
make
cd ..

```

`build_qt5.sh`:

```sh
#!/bin/bash

echo "Trying to build PE-bear..."

#QT check

QT_VER=`qmake -v`
str=$QT_VER
substr="Qt version 5"

echo $QT_VER
if [[ $str == *"$substr"* ]]; then
    echo "[+] Qt5 found!"
else
    str2=`whereis qt5`
    substr2="/qt5"
    if [[ $str2 == *"$substr2"* ]]; then
        echo "[+] Qt5 found!"
    else
        echo "Install Qt5 SDK first"
        exit -1
    fi
fi


CMAKE_VER=`cmake --version`
CMAKEV="cmake version"
if echo "$CMAKE_VER" | grep -q "$CMAKEV"; then
    echo "[+] CMake found!"
else
    echo "[-] CMake NOT found!"
    echo "Install cmake first"
    exit -1
fi
echo $CMAKE_VER
mkdir build_qt5
echo "[+] build directory created"
cd build_qt5
cmake -DCMAKE_INSTALL_PREFIX:PATH=$(pwd) ..
cmake --build . --target install
make
cd ..


```

`disasm/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)
project (libdisasm)

# Offer the user the choice of overriding the installation directories
set(INSTALL_LIB_DIR lib CACHE PATH "Installation directory for libraries")
set(INSTALL_BIN_DIR bin CACHE PATH "Installation directory for executables")

if(USE_QT4)
	find_package (Qt4 REQUIRED)
	include_directories( ${QT_INCLUDE_DIR} ${QT_QTCORE_INCLUDE_DIR} )
	INCLUDE( ${QT_USE_FILE} )
	ADD_DEFINITIONS( ${QT_DEFINITIONS} )
else()
	find_package(Qt5Core REQUIRED)
	get_target_property(QtCore_location Qt5::Core LOCATION)
endif()

include_directories ( ${UDIS86_DIR} ${CAPSTONE_INC} )
include_directories( ${PARSER_INC} )

if (USE_UDIS86)
	set (disasm_wrappers_srcs
		udis/UDisasm.cpp
	)
	set (disasm_wrappers_hdrs
		udis/UDisasm.h
	)
	message(STATUS "udis_dir='${UDIS86_DIR}'")
	message(STATUS "udis_lib='${UDIS86_LIB}'")
else()
	set (disasm_wrappers_srcs
		cdis/CDisasm.cpp
	)
	set (disasm_wrappers_hdrs
		cdis/CDisasm.h
	)
	message(STATUS "capstone_includes='${CAPSTONE_INC}'")
	message(STATUS "capstone_lib='${CAPSTONE_LIB}'")
endif ()


set (disasm_srcs
	Disasm.cpp
	PeDisasm.cpp
	${disasm_wrappers_srcs}
)

set (disasm_hdrs
	bear_disasm.h
	Disasm.h
	PeDisasm.h
	MnemType.h
	${disasm_wrappers_hdrs}
)

add_library( ${PROJECT_NAME} STATIC ${disasm_srcs} ${disasm_hdrs} )

if (USE_UDIS86)
    set (def
        "BUILD_WITH_UDIS86"
    )
    list(APPEND deflist ${def})
    set_target_properties(${PROJECT_NAME} PROPERTIES COMPILE_DEFINITIONS "${deflist}")
endif()

if (USE_UDIS86)
    target_link_libraries( ${PROJECT_NAME} ${PARSER_LIB} ${UDIS86_LIB} )
else()
    target_link_libraries( ${PROJECT_NAME} ${PARSER_LIB} ${CAPSTONE_LIB} )
endif()

if(USE_QT4)
	target_link_libraries ( ${PROJECT_NAME} ${QT_QTCORE_LIBRARIES} )
else()
	target_link_libraries( ${PROJECT_NAME} Qt5::Core)
endif()


```

`disasm/Disasm.cpp`:

```cpp
#include "Disasm.h"
#include <QtGlobal>

using namespace pe_bear;
using namespace minidis;

const int Disasm::MAX_ARG_NUM = 2;

void pe_bear::resetCond(cond_buf &buf)
{
	buf.CF = FLAG_UNK;
	buf.PF = FLAG_UNK;
	buf.AF = FLAG_UNK;
	buf.ZF = FLAG_UNK;
	buf.SF = FLAG_UNK;
	buf.IF = FLAG_UNK;
	buf.DF = FLAG_UNK;
	buf.OF = FLAG_UNK;
	buf.cx = FLAG_UNK;
	buf.affectedCounter = 0;
}

Disasm::Disasm() 
	: is_init(false), m_buf(NULL), m_bufSize(0),
	startOffset(0), m_offset(0), m_disasmSize(0),
	m_iptr(0)
{
}

Disasm::~Disasm()
{
	is_init = false;
}

uint64_t Disasm::trimToBitMode(int64_t value, uint8_t bits) 
{
	offset_t lval = value;
	const size_t max_bits = sizeof(lval) * 8;
	const size_t dif = max_bits - bits;
	lval = (lval << dif) >> dif;
	return lval;
}


int64_t Disasm::signExtend(int64_t operand, size_t opSize)
{
	size_t opBits = opSize * 8;
	int64_t lval = operand;
	size_t dif = sizeof(lval) * 8 - opBits;
	lval = (operand << dif) >> dif;
	return lval;
}

QString Disasm::printBytes(const uint8_t* buf, const size_t size)
{
	QString str;
	for (size_t i = 0; i < size; i++) {
#if QT_VERSION >= 0x050000
		str += QString().asprintf("%02X", buf[i]);
#else
		str += QString().sprintf("%02X", buf[i]);
#endif
	}
	return str;
}

offset_t Disasm::getJmpDestAddr(offset_t currVA, int instrLen, int lVal) const
{
	if (currVA == INVALID_ADDR) {
		return INVALID_ADDR;
	}
	int delta = instrLen + lVal;
	const offset_t addr = (offset_t)((int64_t)currVA + (int64_t)delta);
	return addr;
}

bool Disasm::isBranching(minidis::mnem_type m_mnemType)
{
	switch (m_mnemType) {
		case MT_COND_JUMP:
		case MT_LOOP:
			return true;
	}
	return isUnconditionalBranching(m_mnemType);
}

bool Disasm::isUnconditionalBranching(minidis::mnem_type m_mnemType)
{
	switch (m_mnemType) {
		case MT_JUMP:
		case MT_CALL:
			return true;
	}
	return false;
}

```

`disasm/Disasm.h`:

```h
#pragma once

#include <QtCore>
#include <vector>
#include <bearparser/bearparser.h>
#include "MnemType.h"

namespace pe_bear {

enum flag_val { FLAG_UNK = 0, FLAG_UNSET = (-1), FLAG_SET = 1, FLAG_REL, FLAG_RELNEG };

struct cond_buf {
	flag_val CF, PF, AF, ZF, SF, IF, DF, OF;
	int8_t cx;
	int8_t affectedCounter;
};

void resetCond(cond_buf &buf);

//----------------------------------------------

class Disasm
{
public:
	const  static int MAX_ARG_NUM;
	
	static QString printBytes(const uint8_t* buf, const size_t size);
	
	Disasm();
	~Disasm();

	virtual bool init(uint8_t* buf, size_t bufSize, size_t disasmSize, offset_t offset, Executable::exe_bits bitMode) = 0;
	virtual bool fillTable() = 0;
	virtual bool clearTable() = 0;
	virtual size_t getChunkSize(int index) const = 0;
	
	virtual bool isPushRet(int push_index,/*out*/ int* ret_index = NULL) const = 0;

	offset_t getJmpDestAddr(offset_t currVA, int instrLen, int lVal) const;
	//---

	virtual size_t chunksCount() const  = 0;

	bool isBranching(size_t index) const
	{
		if (index >= chunksCount()) return false;
		return isBranching(getMnemType(index));
	}
	
	bool isUnconditionalBranching(size_t index) const
	{
		if (index >= chunksCount()) return false;
		return isUnconditionalBranching(getMnemType(index));
	}
	
	virtual QString mnemStr(size_t index) const = 0;
	
	virtual QString getHexStr(size_t index) const = 0;
	virtual bool isImmediate(size_t index) const = 0;
	
	virtual int32_t getImmediateVal(size_t index) const = 0;
	virtual minidis::mnem_type getMnemType(size_t index) const = 0;

	virtual offset_t getRawAt(int index) const = 0;
	
	virtual offset_t getRvaAt(int index) const
	{
		return getRawAt(index);
	}
	
	virtual offset_t getVaAt(int index) const
	{
		return getRvaAt(index);
	}
	
	virtual offset_t convertToRVA(offset_t raw) const = 0;
	
	virtual offset_t convertToVA(offset_t raw) const = 0;

	/* returns target VA or INVALID_ADDR */
	virtual offset_t getTargetVA(int index, bool &isOk) const = 0;
	
	virtual bool isAddrOperand(int index) const = 0;
	
	/* returns target VA or INVALID_ADDR */
	virtual offset_t getArgVA(int index, int argNum, bool &isOk) const = 0;
	
	virtual QString translateBranching(const int index) const = 0;
	
	virtual bool isFollowable(const int y) const = 0;
	
protected:
	static offset_t trimToBitMode(int64_t value, uint8_t bits);
	static int64_t signExtend(int64_t operand, size_t opSize);

	static bool isBranching(minidis::mnem_type mType);
	static bool isUnconditionalBranching(minidis::mnem_type mType);
	
	virtual size_t disasmNext() = 0;

	bool is_init;

	Executable::exe_bits m_bitMode;

	uint8_t* m_buf;
	size_t m_bufSize;
	
	size_t m_disasmSize; // the part of buffer that will be used as a preview
	offset_t m_offset;
	offset_t startOffset;

	offset_t m_iptr; //instruction pointer
	QMutex m_disasmMutex;

}; /* class Disasm */

}; /* namespace pe_bear */


```

`disasm/MnemType.h`:

```h
#pragma once
#include <stdio.h>

namespace minidis {

const BYTE OP_RET = 0xc3;

typedef enum {
    MT_INVALID, // invalid instruction
    MT_RET,
    MT_NOP,
    MT_INTX,
    MT_INT3,
    MT_CALL,
    MT_JUMP,
    MT_COND_JUMP,
    MT_LOOP,
    MT_PUSH,
    MT_POP,
    MT_ARITHMETICAL,
    MT_MOV,
    MT_TEST,
    MT_OTHER,
    MT_NONE, // invalid input
    COUNT_MT
} mnem_type;

}; /* namespace minidis */

```

`disasm/PeDisasm.cpp`:

```cpp
#include "PeDisasm.h"
#include <QtCore>
#define PREVIEW_SIZE 0x200

using namespace pe_bear;

PeDisasm::PeDisasm(PEFile *pe)
	: __disasm_super(),
	m_PE(pe), previewSize(PREVIEW_SIZE), 
	firstOffset(0), isInit(false), isBitModeAuto(true)
{
	if (pe == NULL) throw CustomException("PE not initialized!");
}

bool PeDisasm::init(const offset_t offset, Executable::exe_bits bitMode)
{
	this->isInit = false;
	clearTable();
	if (!m_PE) {
		return false;
	}
	
	this->firstOffset = offset;
	if (bitMode == Executable::UNKNOWN) {
		this->isBitModeAuto = true;
		this->m_bitMode = m_PE->getBitMode();
	} else {
		this->m_bitMode = bitMode;
	}
	if (m_PE->getContentSize() < offset) {
		return false;
	}
	size_t maxSize = m_PE->getContentSize() - offset;
	size_t disasmSize = (maxSize > previewSize) ? previewSize : maxSize;
	
	uint8_t *buf = m_PE->getContentAt(offset, disasmSize);
	if (!buf) {
		return false;
	}
	const bool isOk = __disasm_super::init(buf, maxSize, disasmSize, offset, m_bitMode);
	this->isInit = isOk;
	return isOk;
}

bool PeDisasm::fillTable()
{
	clearTable();
	if (!this->isInit) {
		return false;
	}
	bool isOk = __disasm_super::fillTable();
	if (isOk) {
		isOk = fillOffsetTable();
	}
	return isOk;
}

bool PeDisasm::fillOffsetTable() {

	this->offsetTable.clear();
	size_t count = this->m_table.size();
	if (count == 0) return false;

	for (size_t i = 0; i < count; i++) {
		offset_t offset = getRawAt(i);
		if (offset == INVALID_ADDR) {
			this->offsetTable.push_back(INVALID_ADDR);
			continue;
		}

		try {
			offset_t rva = m_PE->rawToRva(offset);
			this->offsetTable.push_back(rva);
		} catch (CustomException e) {
			this->offsetTable.push_back(INVALID_ADDR);
		}
	}
	return true;
}

bool PeDisasm::isRvaContnuous(int index) const
{
	if (index == 0) return true;
	if ((size_t)index >= m_table.size()) return true;

	offset_t prevRva = this->getRvaAt(index-1);
	size_t chunkSize = getChunkSize(index-1);
	offset_t calcRva = prevRva + chunkSize;

	offset_t currRva = this->getRvaAt(index);

	if (currRva != calcRva) {
		return false;
	}
	return true;
}

offset_t PeDisasm::getRawAt(int index) const
{
	const offset_t instrOffset = __disasm_super::getRawAt(index);
	if (instrOffset == INVALID_ADDR) {
		return INVALID_ADDR;
	}
	offset_t offset = firstOffset + instrOffset;
	return offset;
}

offset_t PeDisasm::getRvaAt(int index) const
{
	if ((size_t)index >= this->offsetTable.size()) return INVALID_ADDR;
	return this->offsetTable[index];
}

int32_t PeDisasm::getTargetDelta(int index) const
{
	if (!m_PE) return 0;

	bool isOk = false;
	offset_t rva = getTargetRVA(index, isOk);
	if (!isOk) return 0;

	offset_t currRVA = getRvaAt(index);
	return (int32_t)(rva - currRVA);
}

offset_t PeDisasm::getArgRVA(int index, int argNum, bool &isOk) const
{
	offset_t targetVA = PeDisasm::getArgVA(index,  argNum, isOk);
	if (!isOk) {
		return INVALID_ADDR;
	}
	// only if the target address belongs to the current executable, convert it to RVA:
	if (m_PE->isValidVA(targetVA)) {
		return m_PE->VaToRva(targetVA);
	}
	return INVALID_ADDR;
}

offset_t PeDisasm::getTargetVA(int index, bool &isOk) const
{
	offset_t targetAddr = INVALID_ADDR;
	for (int i = 0; i <= MAX_ARG_NUM; i++ ) {
		targetAddr = getArgVA(index, i, isOk);
		if (targetAddr != INVALID_ADDR) break;
	}
	return targetAddr;
}

offset_t PeDisasm::getTargetRVA(int index, bool &isOk) const
{
	offset_t targetAddr = getTargetVA(index, isOk);
	if (!isOk || !m_PE) {
		return INVALID_ADDR;
	}
	// only if the target address belongs to the current executable, convert it to RVA:
	if (!m_PE->isValidVA(targetAddr)) {
		return INVALID_ADDR;
	}
	return m_PE->VaToRva(targetAddr);
}

offset_t PeDisasm::getTargetRaw(int index, bool &isOk) const
{
	isOk = false;

	if (!m_PE) return INVALID_ADDR;

	bool ok = false;
	offset_t rva = getTargetRVA(index, ok);
	if (!ok) return INVALID_ADDR; //failed to get RVA

	offset_t raw = m_PE->toRaw(rva, Executable::RVA);

	if (raw != INVALID_ADDR) {
		isOk = true;
	}
	return raw;
}

QString PeDisasm::getStringAt(offset_t rva) const
{
	if (!m_PE) return "";

	offset_t raw_target = INVALID_ADDR;
	bool isValid = true;
	try {
		raw_target = m_PE->rvaToRaw(rva);
	} catch (CustomException e) {
		isValid = false;
	}
	if (!isValid) return "";

	QString str = m_PE->getStringValue(raw_target, 150);
	if (str.size() == 1) {
		str = m_PE->getWAsciiStringValue(raw_target, 150);
		if (str.trimmed().length() > 1) {
			return "L\'" + str + "\'";
		}
	}
	if (str.trimmed().length() == 0) return "";
	return "\'" + str + "\'";
}

bool PeDisasm::isCallToRet(int index) const
{
	using namespace minidis;
	
	if (!m_PE) return false;

	const mnem_type mnem = this->getMnemType(index);
	if (mnem != MT_CALL) return false;
	//is pointer to RET?
	static const BYTE OP_RET = 0xc3;

	bool isOk = false;
	uint64_t raw = this->getTargetRaw(index, isOk);
	if (raw == INVALID_ADDR || !isOk) return false;

	BYTE *cntnt = m_PE->getContent();
	if (cntnt[raw] == OP_RET) {
		return true;
	}
	return false;
}

//-------------------------

```

`disasm/PeDisasm.h`:

```h
#pragma once

#include "Disasm.h"

#ifdef BUILD_WITH_UDIS86
#include "udis/UDisasm.h"
typedef pe_bear::UDisasm __disasm_super; 
#else
#include "cdis/CDisasm.h"
typedef pe_bear::CDisasm __disasm_super; 
#endif

namespace pe_bear {

class PeDisasm : public __disasm_super
{
	
public:
	PeDisasm(PEFile *pe);
	bool init(const offset_t offset, Executable::exe_bits bitMode = Executable::UNKNOWN);
	bool fillTable();

	bool isRvaContnuous(int index) const;

	offset_t getRawAt(int index) const;
	offset_t getRvaAt(int index) const;
	
	offset_t getVaAt(int index) const
	{
		offset_t myRva = getRvaAt(index);
		if (myRva == INVALID_ADDR || !m_PE){
			return INVALID_ADDR;
		}
		return m_PE->rvaToVa(myRva);
	}

	/* returns target VA or INVALID_ADDR */
	offset_t getTargetVA(int index, bool &isOk) const;
	
	/* wrapper over getTargetVA,
	returns target RVA (if the target address belongs to the current module) or INVALID_ADDR 
	* */
	offset_t getTargetRVA(int index, bool &isOk) const;
	
	/* wrapper over getArgVA,
	returns target RVA (if the target address belongs to the current module) or INVALID_ADDR 
	* */
	offset_t getArgRVA(int index, int argNum, bool &isOk) const;

	/* returns target Raw or INVALID_ADDR */
	offset_t getTargetRaw(int index, bool &isOk) const;

	/* distance between current RVA and Target RVA */
	int32_t getTargetDelta(int index) const;

	bool isCallToRet(int index) const;

	QString getStringAt(offset_t rva) const;
	
	offset_t convertToRVA(offset_t raw) const
	{
		offset_t myRVA = INVALID_ADDR;
		try {
			myRVA = m_PE->convertAddr(raw, Executable::RAW, Executable::RVA);
		} catch (CustomException &e) {
			myRVA = raw;
		}
		return myRVA;
	}
	
	virtual offset_t convertToVA(offset_t raw) const
	{
		offset_t myVA = INVALID_ADDR;
		try {
			myVA = m_PE->convertAddr(raw, Executable::RAW, Executable::VA);
		} catch (CustomException &e) {
			myVA = raw;
		}
		return myVA;
	}
	
protected:
	bool fillOffsetTable();

	std::vector<offset_t> offsetTable;
	PEFile *m_PE;
	offset_t firstOffset;
	size_t previewSize;
	
	bool isBitModeAuto;
	bool isInit;

}; /* class PeDisasm */

}; /* namespace pe_bear */


```

`disasm/bear_disasm.h`:

```h
#pragma once

#include <bearparser/bearparser.h>
#include <PeDisasm.h>


```

`disasm/cdis/CDisasm.cpp`:

```cpp
#include "CDisasm.h"
#include <iostream>
using namespace pe_bear;

//const int CDisasm::MAX_ARG_NUM = 2;

CDisasm::CDisasm()
	: Disasm(),
	m_insn(NULL)
{
}

CDisasm::~CDisasm()
{
	is_init = false;
}

cs_mode toCSmode(Executable::exe_bits bitMode)
{
	switch (bitMode) {
	case Executable::BITS_16:
		return CS_MODE_16;
	case Executable::BITS_32:
		return CS_MODE_32;
	case Executable::BITS_64:
		return CS_MODE_64;
	}
	return CS_MODE_32; //Default
}

bool CDisasm::init_capstone(Executable::exe_bits bitMode)
{
	cs_err err;
	err = cs_open(CS_ARCH_X86, toCSmode(bitMode), &handle);
	if (err) {
		printf("Failed on cs_open() with error returned: %u\n", err);
		return false;
	}
	cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);
	cs_option(handle, CS_OPT_SKIPDATA, CS_OPT_ON);
	m_insn = cs_malloc(handle);
	if (!m_insn) {
		cs_close(&handle);
		return false;
	}
	return true;
}

bool CDisasm::init(uint8_t* buf, size_t bufSize, size_t disasmSize, offset_t offset, Executable::exe_bits bitMode)
{
	QMutexLocker locker(&m_disasmMutex);
	is_init = false;
	if (!buf || bufSize == 0) return false;

	m_buf = buf;
	m_bufSize = bufSize;
	m_disasmSize = disasmSize;
	m_iptr = 0;

	this->m_offset = 0;
	this->startOffset = this->convertToVA(offset);
	m_bitMode = bitMode;

	is_init = init_capstone(m_bitMode);
	return this->is_init;
}

size_t CDisasm::disasmNext()
{
	if (!is_init && m_insn) {
		printf("Cannot disasm next = NOT INIT!\n");
		return 0;
	}
	//--
	bool isOk = cs_disasm_iter(handle, (const unsigned char**)&m_buf, &m_bufSize, &m_offset, m_insn);
	if (!isOk || !m_insn) {
		is_init = false;
		return 0;
	}
	//--
	const size_t step = m_insn->size;
	m_iptr += step;
	return step;
}

bool CDisasm::fillTable()
{
	QMutexLocker locker(&m_disasmMutex);

	if (!is_init) {
		return false;
	}
	this->clearTable();
	size_t processedSize = 0;
	while (processedSize < this->m_disasmSize) {
		if (!disasmNext()) {
			break; //could not disasemble more
		}
		if (!m_insn) continue;
		processedSize += m_insn->size;

		const cs_insn next_insn = *m_insn;
		const cs_detail *detail = m_insn->detail;
		m_table.push_back(next_insn);
		m_details.push_back(*detail);
	}
	if (m_table.size() == 0) {
		return false;
	}
	return true;
}

bool CDisasm::clearTable()
{
	m_table.clear();
	m_details.clear();
	return true;
}

offset_t CDisasm::getRawAt(int index) const
{
	if (index >= m_table.size()) {
		return INVALID_ADDR;
	}
	const cs_insn m_insn = m_table.at(index);
	return m_insn.address;
}

offset_t CDisasm::getArgVA(int index, int argNum, bool &isOk) const
{
	isOk = false;
	if (index >= m_table.size()) {
		printf("Out of bounds\n");
		return INVALID_ADDR;
	}
	const cs_insn m_insn = m_table.at(index);
	const cs_detail *m_detail = &m_details.at(index);
	size_t cnt = static_cast<size_t>(m_detail->x86.op_count);
	if (argNum >= cnt) return INVALID_ADDR;

	offset_t currVA = getVaAt(index);
	minidis::mnem_type mType = this->getMnemType(index);

	const x86_reg reg = static_cast<x86_reg>(m_detail->x86.operands[argNum].mem.base);
	//const size_t opSize = m_detail->x86.operands[argNum].size;
	const x86_op_type type = m_detail->x86.operands[argNum].type;

	size_t instrLen = getChunkSize(index);
	offset_t va = INVALID_ADDR;

	if (type == X86_OP_MEM) {
		int64_t lval = m_detail->x86.operands[argNum].mem.disp;

		const bool isEIPrelative = (reg == X86_REG_IP || reg == X86_REG_EIP || reg == X86_REG_RIP);
		if (isEIPrelative) {
			va = Disasm::getJmpDestAddr(currVA, instrLen, lval);
		}
		else if (reg <= X86_REG_INVALID) { //simple case, no reg value to add
			va = Disasm::trimToBitMode(lval, this->m_bitMode);
		}
	}
	if (type == X86_OP_IMM) {

		int64_t lval = m_detail->x86.operands[argNum].imm;
		if (this->isBranching(mType) && !isLongOp(m_insn)) {
			lval = this->startOffset + lval;
		}
		va = lval;
		if (reg > X86_REG_INVALID) { //if there are registers involved, it is not supported
			va = INVALID_ADDR;
		}
	}
	if (va != INVALID_ADDR) {
		isOk = true;
		va = Disasm::trimToBitMode(va, this->m_bitMode);
	}
	return va;
}

minidis::mnem_type CDisasm::fetchMnemType(const x86_insn cMnem) const
{
	using namespace minidis;
	if (cMnem == X86_INS_INVALID) {
		return MT_INVALID;
	}
	if (cMnem >= X86_INS_JAE && cMnem <= X86_INS_JS) {
		if (cMnem == X86_INS_JMP || cMnem == X86_INS_LJMP) return MT_JUMP;
		return MT_COND_JUMP;
	}
	if (cMnem >= X86_INS_MOV && cMnem <= X86_INS_MOVZX) {
		return MT_MOV;
	}

	switch (cMnem) {
	case X86_INS_LOOP:
	case X86_INS_LOOPE:
	case X86_INS_LOOPNE:
		return MT_LOOP;

	case X86_INS_CALL:
	case X86_INS_LCALL:
		return MT_CALL;

	case X86_INS_RET:
	case X86_INS_RETF:
	case X86_INS_RETFQ:
		return MT_RET;

	case X86_INS_NOP: return MT_NOP;

	case X86_INS_POP:
	case X86_INS_POPAW:
	case X86_INS_POPAL:
	case X86_INS_POPCNT:
	case X86_INS_POPF:
	case X86_INS_POPFD:
	case X86_INS_POPFQ:
	{
		return MT_POP;
	}
	case X86_INS_PUSH:
	case X86_INS_PUSHAW:
	case X86_INS_PUSHAL:
	case X86_INS_PUSHF:
	case X86_INS_PUSHFD:
	case X86_INS_PUSHFQ:
	{
		return MT_PUSH;
	}
	case X86_INS_INT3:
		return MT_INT3;

	case X86_INS_INT:
		return MT_INTX;
	}
	return MT_OTHER;
}

bool CDisasm::isPushRet(int index, /*out*/ int* ret_index) const
{
	if (index >= this->_chunksCount()) {
		return false;
	}

	const cs_insn m_insn = m_table.at(index);
	const cs_detail *detail = &m_details.at(index);

	const minidis::mnem_type mnem = fetchMnemType(static_cast<x86_insn>(m_insn.id));
	if (mnem == minidis::MT_PUSH) {
		int y2 = index + 1;
		if (y2 >= m_table.size()) {
			return false;
		}
		const cs_insn m_insn2 = m_table.at(y2);
		const minidis::mnem_type mnem2 = fetchMnemType(static_cast<x86_insn>(m_insn2.id));
		if (mnem2 == minidis::MT_RET) {
			if (ret_index != NULL) {
				(*ret_index) = y2;
			}
			return true;
		}
	}
	return false;
}

bool CDisasm::isAddrOperand(int index) const
{
	if (index >= m_table.size()) {
		return false;
	}
	using namespace minidis;
	mnem_type mnem = this->getMnemType(index);
	if (mnem == MT_PUSH || mnem == MT_MOV) return true;

	const cs_detail *detail = &m_details.at(index);
	const size_t cnt = static_cast<size_t>(detail->x86.op_count);

	for (int argNum = 0; argNum < cnt; argNum++) {
		const x86_op_type type = detail->x86.operands[argNum].type;
		const size_t opSize = detail->x86.operands[argNum].size;

		const x86_reg reg = static_cast<x86_reg>(detail->x86.operands[argNum].mem.base);
		const bool isEIPrelative = (reg == X86_REG_IP || reg == X86_REG_EIP || reg == X86_REG_RIP);

		if (type == X86_OP_IMM
			&& opSize > 8)
		{
			return true;
		}
		if (type == X86_OP_MEM && isEIPrelative) {
			return true;
		}
	}
	return false;
}

bool CDisasm::isFollowable(const int y) const
{
	if (y >= this->chunksCount()) return false;

	if (getRvaAt(y) == INVALID_ADDR) return false;

	if (isBranching(y) == false && isPushRet(y) == false) {
		return false;
	}
	const cs_detail *detail = &m_details.at(y);
	if (!detail) return false;

	const size_t cnt = static_cast<size_t>(detail->x86.op_count);
	if (!cnt) return false;

	const size_t argNum = 0;
	const x86_op_type type = detail->x86.operands[argNum].type;
	const x86_reg reg = static_cast<x86_reg>(detail->x86.operands[argNum].mem.base);

	if (type == X86_OP_IMM) {
		return true;
	}

	if (type == X86_OP_MEM || type == X86_OP_IMM) {
		if (reg <= X86_REG_INVALID) { //simple case, no reg value to add
			return true;
		}
		const bool isEIPrelative = (reg == X86_REG_IP || reg == X86_REG_EIP || reg == X86_REG_RIP);
		if (isEIPrelative) {
			return true;
		}
		return false;
	}
	return false;
}

QString CDisasm::translateBranching(const int y) const
{
	if (y >= this->_chunksCount()) {
		return "";
	}
	const cs_insn m_insn = m_table.at(y);
	const minidis::mnem_type mType = this->fetchMnemType(static_cast<x86_insn>(m_insn.id));

	if (!this->isBranching(mType) || !m_insn.mnemonic) {
		return "";
	}
	if (!this->isImmediate(y)) {
		return this->mnemStr(y);
	}
	QString mnemDesc = QString(m_insn.mnemonic);
	const size_t mnenSize = m_insn.size * 8;

	if ((mType == minidis::MT_JUMP || mType == minidis::MT_COND_JUMP)
		&& mnenSize < 32)
	{
		mnemDesc += " SHORT";
	}
	bool isOk = false;
	offset_t targetVA = getTargetVA(y, isOk);

	if (targetVA == INVALID_ADDR || !isOk) {
		mnemDesc += " <INVALID>";
		return mnemDesc;
	}
	mnemDesc += " 0x" + QString::number(targetVA, 16);
	return mnemDesc;
}

```

`disasm/cdis/CDisasm.h`:

```h
#pragma once

#include <vector>
#include <capstone/capstone.h>
#include <bearparser/bearparser.h>
#include "../Disasm.h"
#include "../MnemType.h"

namespace pe_bear {

//----------------------------------------------

class CDisasm : public Disasm
{
public:
	//const  static int MAX_ARG_NUM;

	CDisasm();
	~CDisasm();

	bool init(uint8_t* buf, size_t bufSize, size_t disasmSize, offset_t offset, Executable::exe_bits bitMode);
	bool fillTable();
	bool clearTable();
	offset_t getRawAt(int index) const;
	offset_t getArgVA(int index, int argNum, bool &isOk) const;
	
	size_t getChunkSize(int index) const
	{
		if ((size_t)index >= this->chunksCount()) {
			return 0;
		}
		const cs_insn m_insn = m_table.at(index);
		return m_insn.size;
	}
	
	bool isPushRet(int push_index,/*out*/ int* ret_index = NULL) const;
	
	//---

	size_t chunksCount() const
	{
		return _chunksCount();
	}

	QString mnemStr(size_t index) const
	{
		if (index >= this->_chunksCount()) {
			return "";
		}
		const cs_insn m_insn = m_table.at(index);
		const QString str = QString(m_insn.mnemonic) + " " + QString(m_insn.op_str);
		return str;
	}
	
	QString getHexStr(size_t index) const 
	{
		if (index >= this->_chunksCount()) {
			return "";
		}
		
		const cs_insn m_insn = m_table.at(index);
		return printBytes((uint8_t*) m_insn.bytes, m_insn.size);
	}
	
	bool isImmediate(size_t index) const
	{
		if (index >= this->_chunksCount()) {
			return false;
		}
		const cs_insn m_insn = m_table.at(index);
		const cs_detail *detail = &m_details.at(index);
		
		const size_t argNum = 0;
		const x86_op_type type = detail->x86.operands[argNum].type;
		if (type == X86_OP_IMM) {
			return true;
		}
		return false;
	}
	
	int32_t getImmediateVal(size_t index) const
	{
		if (!isImmediate(index)) {
			return 0;
		}
		if (index >= this->_chunksCount()) {
			return false;
		}
		const cs_insn m_insn = m_table.at(index);
		const cs_detail *detail = &m_details.at(index);
		
		const size_t argNum = 0;
		const x86_op_type type = detail->x86.operands[argNum].type;
		const x86_reg reg = static_cast<x86_reg>(detail->x86.operands[argNum].mem.base);
		int32_t val = static_cast<x86_reg>(detail->x86.operands[argNum].imm);
		return val;
	}
	
	minidis::mnem_type getMnemType(size_t index) const
	{
		using namespace minidis;
		if (index >= this->_chunksCount()) {
			return MT_NONE;
		}
		const cs_insn &m_insn =  m_table.at(index);
		return fetchMnemType(static_cast<x86_insn>(m_insn.id));
	}
	
	virtual bool isAddrOperand(int index) const;
	
	bool isFollowable(const int y) const;
	
	QString translateBranching(const int y) const;
protected:
	size_t _chunksCount() const { return this->m_table.size(); }
	bool isLongOp(const cs_insn &m_insn) const { return (m_insn.id == X86_INS_LCALL || m_insn.id == X86_INS_LJMP); }
	minidis::mnem_type fetchMnemType(const x86_insn cMnem) const;
	
	size_t disasmNext();
	bool init_capstone(Executable::exe_bits bitMode);
	
	//capstone stuff:
	std::vector<cs_insn> m_table;
	std::vector<cs_detail> m_details;
	
	csh handle;
	cs_insn* m_insn;

}; /* class Disasm */

}; /* namespace pe_bear */


```

`disasm/udis/UDisasm.cpp`:

```cpp
#include "UDisasm.h"

using namespace pe_bear;

const int UDisasm::MAX_ARG_NUM = 2;

UDisasm::UDisasm() 
	: Disasm()
{
}

UDisasm::~UDisasm()
{
	is_init = false;
}

bool UDisasm::init(uint8_t* buf, size_t bufSize, size_t disasmSize, offset_t offset, Executable::exe_bits bitMode)
{
	QMutexLocker locker(&m_disasmMutex);
	is_init = false;
	if (!buf || bufSize == 0) return false;

	m_buf = buf;
	m_bufSize = bufSize;
	m_iptr = 0;

	m_disasmSize = disasmSize;
	m_offset = 0;
	this->startOffset = this->convertToVA(offset);
	m_bitMode = bitMode;
    
    //udis:
	ud_init(&this->ud_obj);
	ud_set_input_buffer(&this->ud_obj, m_buf, m_bufSize);
	ud_set_mode(&this->ud_obj, (uint8_t)bitMode);
	ud_set_syntax(&ud_obj, UD_SYN_INTEL);

	is_init = true;
	return true;
}

size_t UDisasm::disasmNext()
{
	if (!is_init)
		return 0;
        
	if (!ud_disassemble(&this->ud_obj)) {
		is_init = false;
		return 0;
	}

	size_t step =  ud_insn_len(&this->ud_obj);
	m_iptr += step;
	return step;
}

bool UDisasm::fillTable()
{
	QMutexLocker locker(&m_disasmMutex);
	if (!is_init){
		return false;
	}
	this->clearTable();
	size_t processedSize = 0;
	while (processedSize < this->m_disasmSize) {
		size_t step = disasmNext();
		if (!step) {
			break; //could not disasemble more
		}
		processedSize += step;
		m_table.push_back(ud_obj);
	}
	if (m_table.size() == 0) {
		return false;
	}
	return true;
}

bool UDisasm::clearTable()
{
	m_table.clear();
	return true;
}

size_t UDisasm::getChunkSize(int index) const
{
	if (index >= m_table.size()) return 0;
	ud_t obj =  m_table.at(index);
	size_t chunkSize = ud_insn_len(&obj);
	return chunkSize;
}

uint64_t UDisasm::getRawAt(int index) const
{
	if (index >= m_table.size()) return INVALID_ADDR;
	ud_t ud_obj =  m_table.at(index);
	return ud_insn_off(&ud_obj);
}

bool UDisasm::isAddrOperand(int index) const
{
	ud_t obj =  m_table.at(index);
	if (obj.mnemonic == UD_Ipush || obj.mnemonic == UD_Imov) return true;

	for (int i = 0 ; i <Disasm::MAX_ARG_NUM; i++) {
		if (obj.operand[i].type == UD_OP_IMM 
			&& obj.operand[i].size > 8)
		{
			return true;
		}
	}
	return false;
}

uint64_t UDisasm::getArgVA(int index, int argNum, bool &isOk) const
{
	if (index >= m_table.size()) return 0;
	isOk = false;
	if (argNum > MAX_ARG_NUM) return INVALID_ADDR;

	if (index >= m_table.size()) {
		printf("Out of bounds\n");
		return INVALID_ADDR;
	}

	int instrLen = getChunkSize(index);
	uint64_t currVA = getVaAt(index);// + myPe->getImageBase();

	bool got = false;
	uint64_t lval = getSignedLVal(index, argNum, got);
	if (!got) return INVALID_ADDR;
	
	ud_t inpObj = m_table.at(index);
	ud_type opType = inpObj.operand[argNum].type;
	
	uint64_t va = INVALID_ADDR;
	if (opType == UD_OP_JIMM) {
		va = this->getJmpDestAddr(currVA, instrLen, lval);
	}
	//TODO: implement it
	
	if (opType == UD_OP_MEM || opType == UD_OP_IMM) {
		ud_type regType = inpObj.operand[argNum].base;

		if (regType == UD_R_RIP) {
			va = this->getJmpDestAddr(currVA, instrLen, lval);
		} 
		else if (regType == UD_NONE) { // may be VA
			va = Disasm::trimToBitMode(lval, this->m_bitMode);
			/*if (myPe->isValidVA(lval)) {
				rva = lval - myPe->getImageBase();
			}*/
		}
	}
	if (va != INVALID_ADDR) {
		isOk = true;
		va = Disasm::trimToBitMode(va, this->m_bitMode);
	}
	return va;
}

QString UDisasm::translateBranching(int index) const
{
	if (index >= m_table.size()) return "";
	
	ud_t ud_obj =  m_table.at(index);
	/* substitute branching istructions with immediate operands */
	ud_mnemonic_code_t mnem = ud_obj.mnemonic;

	QString mnemDesc = "";
	switch (mnem) {
		case UD_Iloop: mnemDesc = "LOOP"; break;
	    case UD_Ijo : mnemDesc = "JO"; break;
	    case UD_Ijno : mnemDesc = "JNO"; break;
	    case UD_Ijb : mnemDesc = "JB"; break;
	    case UD_Ijae : mnemDesc = "JLAE"; break;
	    case UD_Ijz : mnemDesc = "JZ"; break;
	    case UD_Ijnz : mnemDesc = "JNZ"; break;
	    case UD_Ijbe : mnemDesc = "JBE"; break;
	    case UD_Ija : mnemDesc = "JA"; break;
	    case UD_Ijs : mnemDesc = "JS"; break;
	    case UD_Ijns : mnemDesc = "JNS"; break;
	    case UD_Ijp : mnemDesc = "JP"; break;
	    case UD_Ijnp : mnemDesc = "JNP"; break;
	    case UD_Ijl : mnemDesc = "JL"; break;
	    case UD_Ijge : mnemDesc = "JGE"; break;
	    case UD_Ijle : mnemDesc = "JLE"; break;
	    case UD_Ijg : mnemDesc = "JG"; break;
	    case UD_Ijcxz : mnemDesc = "JCXZ"; break;
	    case UD_Ijecxz : mnemDesc = "JECXZ"; break;
	    case UD_Ijrcxz : mnemDesc = "JRCXZ"; break;
	    case UD_Ijmp : mnemDesc = "JMP"; break;
	    case UD_Icall : mnemDesc = "CALL"; break;
	    default:
		return ud_insn_asm(&ud_obj);
	}

	if (ud_obj.operand[0].type != UD_OP_JIMM) {
		return ud_insn_asm(&ud_obj);
	}

	if (ud_obj.operand[0].size <= 8 && mnem != UD_Icall) {
		mnemDesc = mnemDesc + " SHORT";
	}

	bool isOk = false;
	uint64_t targetVA = getTargetVA(index, isOk);
	if (targetVA == INVALID_ADDR || !isOk) {
			mnemDesc += " <INVALID>";
			return mnemDesc;
	}
	mnemDesc += " 0x" + QString::number(targetVA, 16);
	return mnemDesc;
}

minidis::mnem_type UDisasm::getMnemType(size_t index) const
{
	using namespace minidis;
	if (index >= this->chunksCount()) {
		return MT_NONE;
	}
	const ud_t &ud_obj =  m_table.at(index);
	switch(ud_obj.mnemonic)
	{
		case UD_Ijo : case UD_Ijno : case UD_Ijb : case UD_Ijae :
		case UD_Ijz : case UD_Ijnz : case UD_Ijbe : case UD_Ija :
		case UD_Ijs : case UD_Ijns : case UD_Ijp : case UD_Ijnp :
		case UD_Ijl : case UD_Ijge : case UD_Ijle : case UD_Ijg :
		case UD_Ijcxz : case UD_Ijecxz : case UD_Ijrcxz :
			return MT_COND_JUMP;

		case UD_Ijmp :
			return MT_JUMP;

		case UD_Iloop: return MT_LOOP;
		case UD_Icall : return MT_CALL;

		case UD_Iret:
		case UD_Iretf :
			return MT_RET;

		case UD_Inop : return MT_NOP;
		case UD_Iinvalid :
			return MT_INVALID;

		case UD_Ipush :
		case UD_Ipusha:
		case UD_Ipushad:
		case UD_Ipushfd:
		case UD_Ipushfq:
		case UD_Ipushfw:
			return MT_PUSH;

		case UD_Ipop :
		case UD_Ipopa:
		case UD_Ipopad:
		//case UD_Ipopcnt:
		case UD_Ipopfd:
		case UD_Ipopfq:
		case UD_Ipopfw:
			return MT_POP;

		case UD_Iint3 :
			return MT_INT3;

		case UD_Iint:
			return MT_INTX;
	}
	return MT_OTHER;
}

bool UDisasm::isBranching(ud_t ud_obj)
{
	ud_mnemonic_code_t mnem = ud_obj.mnemonic;
	switch (mnem) {
		case UD_Iloop:
		case UD_Ijo : case UD_Ijno : case UD_Ijb : case UD_Ijae :
		case UD_Ijz : case UD_Ijnz : case UD_Ijbe : case UD_Ija :
		case UD_Ijs : case UD_Ijns : case UD_Ijp : case UD_Ijnp :
		case UD_Ijl : case UD_Ijge : case UD_Ijle : case UD_Ijg :
		case UD_Ijcxz : case UD_Ijecxz : case UD_Ijrcxz :
		case UD_Ijmp :
		case UD_Icall :
			return true;
	}
	return false;
}

bool UDisasm::isFollowable(const int y) const
{
	if (y >= this->chunksCount()) return false;
	
	if (getRvaAt(y) == INVALID_ADDR) return false;

	if (isBranching(y) == false && isPushRet(y) == false) {
		return false;
	}
	const ud_t &obj =  m_table.at(y);
	if (obj.operand[0].type == UD_OP_JIMM) {
		return true;
	}

	if (obj.operand[0].type == UD_OP_MEM || obj.operand[0].type == UD_OP_IMM) {
		ud_type reg_type = obj.operand[0].base;
		if (reg_type == UD_NONE) {
			return true;
		}

		if (reg_type == UD_R_RIP) {
			return true;
		}
		return false;
	}
	return false;
}

uint64_t UDisasm::getJmpDestAddr(uint64_t currVA, int instrLen, int lVal) const
{
	int delta = instrLen + lVal;
	uint64_t addr = currVA + delta;
	return addr;
}

/* TODO: test it!!! */
int64_t UDisasm::getSignedLVal(ud_t &inpObj, size_t argNum, bool &isOk) const
{
	if (argNum > MAX_ARG_NUM) return INVALID_ADDR;
	isOk = false;
	int64_t lValue = 0;
	uint8_t size = inpObj.operand[argNum].size;

	if (size == 0) return 0;
	uint8_t maxSize = sizeof(uint64_t) * 8; // in bits
	uint8_t dif = maxSize - size;

	lValue = inpObj.operand[argNum].lval.uqword;
	int64_t mlValue = (lValue << dif) >> dif; // gives signed!!!
	isOk = true;
	return mlValue;
}

bool UDisasm::isUnconditionalBranching(ud_t ud_obj)
{
	ud_mnemonic_code_t mnem = ud_obj.mnemonic;
	switch (mnem) {
		case UD_Ijmp :
		case UD_Icall :
			return true;
	}
	return false;
}

bool UDisasm::isPushRet(int tab_index, /*out*/ int* ret_index) const
{
	ud_t ud_obj =  m_table.at(tab_index);
	ud_mnemonic_code_t mnem = ud_obj.mnemonic;

	/* push ... ret = CALL */
	if (mnem == UD_Ipush) {
		int y2 = tab_index + 1;
		if (y2 >= m_table.size()) {
			return false;
		}
		ud_t ud_obj2 =  m_table.at(y2);
		if (ud_obj2.mnemonic == UD_Iret) {
			if (ret_index != NULL) {
				(*ret_index) = y2;
			}
			return true;
		}
	}
	//TODO: implement more complex cases
	return false;
}

```

`disasm/udis/UDisasm.h`:

```h
#pragma once

#include <vector>
#include <udis86.h>
#include <bearparser.h>
#include "../Disasm.h"
#include "../MnemType.h"

namespace pe_bear {

//----------------------------------------------

class UDisasm : public Disasm
{
public:
	const  static int MAX_ARG_NUM;

	UDisasm();
	~UDisasm();

	bool init(uint8_t* buf, size_t bufSize, size_t disasmSize, offset_t offset, Executable::exe_bits bitMode);
	bool fillTable();
	bool clearTable();
	size_t getChunkSize(int index) const;
	
	//get Raw offset of the instruction
	offset_t getRawAt(int index) const;
	
	offset_t getArgVA(int index, int argNum, bool &isOk) const;
	
	QString translateBranching(int index) const;
	
	bool isAddrOperand(int index) const;
	
	bool isPushRet(int push_index,/*out*/ int* ret_index = NULL) const;
	
	uint64_t getJmpDestAddr(uint64_t currVA, int instrLen, int lVal) const;

	int64_t getSignedLVal(size_t index, size_t operandNum, bool &isOk) const
	{
		if (index >= chunksCount()) return 0;
		ud_t udObj = m_table.at(index);
		return getSignedLVal(udObj, operandNum, isOk);
	}
	//---
    
	size_t chunksCount() const { return this->m_table.size(); }
    
	bool isBranching(size_t index) const
	{
		if (index >= chunksCount()) return false;
		return isBranching(m_table.at(index));
	}
	
	bool isUnconditionalBranching(size_t index) const
	{
		if (index >= chunksCount()) return false;
		return isUnconditionalBranching(m_table.at(index));
	}
	
	QString mnemStr(size_t index) const
	{
		if (index >= this->chunksCount()) {
			return "";
		}
		ud_t udObj = m_table.at(index);
		const char* str = ud_insn_asm(&udObj);
		if (!str) return "";
		return str;
	}
	
	QString getHexStr(size_t index) const 
	{
		if (index >= this->chunksCount()) {
			return "";
		}
		ud_t ud_obj =  m_table.at(index);
		char *hex_str = ud_insn_hex(&ud_obj);
		if (!hex_str) return "";
		return hex_str;
	}
	
	bool isImmediate(size_t index) const
	{
		if (index >= this->chunksCount()) {
			return false;
		}
		const ud_t &ud_obj =  m_table.at(index);
		ud_type type = ud_obj.operand[0].type;
		if (type != UD_OP_IMM) {
			return false;
		}
		return true;
	}
	
	int32_t getImmediateVal(size_t index) const
	{
		if (!isImmediate(index)) {
			return 0;
		}
		const ud_t &ud_obj =  m_table.at(index);
		int32_t val = ud_obj.operand[0].lval.sdword;
		return val;
	}
	
	minidis::mnem_type getMnemType(size_t index) const;
	
	bool isFollowable(const int y) const;
	
protected:
	static bool isBranching(ud_t ud_obj);
	static bool isUnconditionalBranching(ud_t ud_obj);
	
	int64_t getSignedLVal(ud_t &obj, size_t operandNum, bool &isOk) const; /* TODO: test it!!! */

	size_t disasmNext();
	
	ud_t ud_obj;
	std::vector<ud_t> m_table;

}; /* class Disasm */

}; /* namespace pe_bear */


```

`macos_wrap.sh`:

```sh
#!/bin/bash

#locate macdeployqt:
MPATH=`whereis macdeployqt`
echo $MPATH

read P1 P2 <<<$(IFS=":"; echo $MPATH)

if [[ -z $P2 ]]; then
	echo "macdeployqt not found"
	exit -1
fi
echo $P2
APP_PATH="./build_qt5/pe-bear/"
# clean the previous build
rm -rf $APP_PATH/PE-bear.app

#build stuff
./build_qt5.sh

#strip the created build
strip $APP_PATH/PE-bear.app/Contents/MacOS/PE-bear

#wrap by macdeployqt:
$P2 $APP_PATH/PE-bear.app

# if wrapping succeeded, zip and store:
if [[ $? == 0 ]]; then
	CURR_DIR=`pwd`
	ZIP_OUT=$CURR_DIR/PE-bear.app.zip
	
	cd $APP_PATH
	zip $ZIP_OUT ./PE-bear.app -r
	echo "Wrapped: "$ZIP_OUT
	cd $CURR_DIR
fi


```

`pe-bear/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)
project (PE-bear)

# Offer the user the choice of overriding the installation directories
set(INSTALL_LIB_DIR lib CACHE PATH "Installation directory for libraries")
set(INSTALL_BIN_DIR bin CACHE PATH "Installation directory for executables")
set(COMMIT_HASH "" CACHE STRING "Commit Hash")

message(STATUS "sigfind_dir='${SIGFIND_DIR}'")
message(STATUS "sigfind_lib='${SIGFIND_LIB}'")

message(STATUS "parser_dir='${PARSER_DIR}'")
message(STATUS "parser_lib='${PARSER_LIB}'")

message(STATUS "disasm_dir='${DISASM_DIR}'")
message(STATUS "disasm_lib='${DISASM_DIR}'")

if(USE_QT4)
	find_package (Qt4 REQUIRED)
	include_directories ( ${QT_INCLUDE_DIR} ${QT_QTCORE_INCLUDE_DIR} ${QT_QTGUI_INCLUDE_DIR} )
	INCLUDE(${QT_USE_FILE})
	ADD_DEFINITIONS(${QT_DEFINITIONS})
else()
	find_package(Qt5Core REQUIRED)
	find_package(Qt5Widgets REQUIRED)
	get_target_property(QtCore_location Qt5::Core LOCATION)
endif()

include_directories( ${PARSER_INC} )
include_directories( ${SIGFIND_DIR} )
include_directories( ${DISASM_DIR} ${CAPSTONE_INC})

set (pebear_base_srcs
	base/BearVers.cpp
	base/MainSettings.cpp
	base/CommentHandler.cpp
	base/Modification.cpp
	base/PeHandler.cpp
	base/PeHandlerFactory.cpp
	base/PeHandlersManager.cpp
	base/RegKeyManager.cpp
)

set (pebear_base_hdrs
	base/BearVers.h
	base/MainSettings.h
	base/CommentHandler.h
	base/Modification.h
	base/Releasable.h
	base/PeHandler.h
	base/PeHandlerFactory.h
	base/PeHandlersManager.h
	base/RegKeyManager.h
)

set (pebear_gui_base_srcs
	gui_base/PeGuiItem.cpp
	gui_base/ExtTableView.cpp
	gui_base/PEViewsManager.cpp
	gui_base/ClipboardUtil.cpp
	gui_base/TreeCpView.cpp
	gui_base/PeTreeView.cpp
	gui_base/PeTableModel.cpp
	gui_base/FollowablePeTreeView.cpp
	gui_base/HexSpinBox.cpp
	gui_base/HexInputDialog.cpp
	gui_base/AddressInputDialog.cpp
	gui_base/OffsetDependentAction.cpp
	gui_base/WrapperTableModel.cpp
	gui_base/WrapperInterface.cpp
)

set (pebear_gui_base_hdrs
	gui_base/PeGuiItem.h
	gui_base/ExtTableView.h
	gui_base/PEViewsManager.h
	gui_base/ClipboardUtil.h
	gui_base/TreeCpView.h
	gui_base/PeTreeView.h
	gui_base/PeTableModel.h
	gui_base/FollowablePeTreeView.h
	gui_base/HexSpinBox.h
	gui_base/HexInputDialog.h
	gui_base/AddressInputDialog.h
	gui_base/OffsetDependentAction.h
	gui_base/WrapperTableModel.h
	gui_base/WrapperInterface.h
)

set (pebear_gui_pe_mod_srcs
	gui/pe_models/BoundImpTreeModel.cpp
	gui/pe_models/DebugTreeModel.cpp
	gui/pe_models/DelayImpTreeModel.cpp
	gui/pe_models/ExceptionTreeModel.cpp
	gui/pe_models/ExportsTreeModel.cpp
	gui/pe_models/FileHdrTreeModel.cpp
	gui/pe_models/RichHdrTreeModel.cpp
	gui/pe_models/ImportsTreeModel.cpp
	gui/pe_models/LdConfigTreeModel.cpp
	gui/pe_models/OptionalHdrTreeModel.cpp
	gui/pe_models/RelocsTreeModel.cpp
	gui/pe_models/ResourcesTreeModel.cpp
	gui/pe_models/SecHdrsTreeModel.cpp
	gui/pe_models/SecurityTreeModel.cpp
	gui/pe_models/TLSTreeModel.cpp
	gui/pe_models/ClrHdrTreeModel.cpp
)

set (pebear_gui_pe_mod_hdrs
	gui/pe_models/BoundImpTreeModel.h
	gui/pe_models/DebugTreeModel.h
	gui/pe_models/DelayImpTreeModel.h
	gui/pe_models/ExceptionTreeModel.h
	gui/pe_models/ExportsTreeModel.h
	gui/pe_models/FileHdrTreeModel.h
	gui/pe_models/RichHdrTreeModel.h
	gui/pe_models/ImportsTreeModel.h
	gui/pe_models/LdConfigTreeModel.h
	gui/pe_models/OptionalHdrTreeModel.h
	gui/pe_models/RelocsTreeModel.h
	gui/pe_models/ResourcesTreeModel.h
	gui/pe_models/SecHdrsTreeModel.h
	gui/pe_models/SecurityTreeModel.h
	gui/pe_models/TLSTreeModel.h
	gui/pe_models/ClrHdrTreeModel.h
	gui/DarkStyle.h
)

set (pebear_gui_srcs
	gui/CommentView.cpp
	gui/DetailsTab.cpp
	gui/ContentPreview.cpp
	gui/GeneralPanel.cpp
	gui/DosHdrTableModel.cpp
	gui/PackersTableModel.cpp
	gui/HexDiffModel.cpp
	gui/WrapperSplitter.cpp
	gui/DataDirWrapperSplitter.cpp
	gui/ResourceDirSplitter.cpp
	gui/WrapperTreeView.cpp
	gui/TreeModel.cpp
	gui/PeTreeModel.cpp
	gui/PeWrapperModel.cpp
	DateDisplay.cpp
	HexView.cpp
	HexCompareView.cpp
	HexDumpModel.cpp
	OffsetHeader.cpp
	DisasmView.cpp
	PEDockedWidget.cpp
	PEFileTreeModel.cpp
	SectionsDiagram.cpp
	ExeDependentAction.cpp
	ViewSettings.cpp
)

set (pebear_gui_hdrs
	gui/CommentView.h
	gui/DetailsTab.h
	gui/ContentPreview.h
	gui/GeneralPanel.h
	gui/DosHdrTableModel.h
	gui/PackersTableModel.h
	gui/HexDiffModel.h
	gui/WrapperSplitter.h
	gui/DataDirWrapperSplitter.h
	gui/ResourceDirSplitter.h
	gui/WrapperTreeView.h
	gui/TreeModel.h
	gui/PeTreeModel.h
	gui/PeWrapperModel.h
	DateDisplay.h
	HexView.h
	HexCompareView.h
	HexDumpModel.h
	OffsetHeader.h
	DisasmView.h
	PEDockedWidget.h
	PEFileTreeModel.h
	SectionsDiagram.h
	ExeDependentAction.h
	ViewSettings.h
	TempBuffer.h
	gui/pe_models.h
)

set (pebear_windows_srcs
	gui/windows/OffsetsBrowseWindow.cpp
	gui/windows/SignaturesBrowseWindow.cpp
	gui/windows/SectionAddWindow.cpp
	gui/windows/UserConfigWindow.cpp
	gui/windows/DiffWindow.cpp
	gui/windows/MainWindow.cpp
)

set (pebear_windows_hdrs
	gui/windows/OffsetsBrowseWindow.h
	gui/windows/SignaturesBrowseWindow.h
	gui/windows/SectionAddWindow.h
	gui/windows/UserConfigWindow.h
	gui/windows/DiffWindow.h
	gui/windows/MainWindow.h
)

set (pebear_srcs
	${pebear_base_srcs}
	${pebear_gui_base_srcs}
	${pebear_gui_srcs}
	${pebear_gui_pe_mod_srcs}
	${pebear_windows_srcs}
	main.cpp
)

set (pebear_hdrs
	REbear.h
	${pebear_base_hdrs}
	${pebear_gui_base_hdrs}
	${pebear_gui_hdrs}
	${pebear_gui_pe_mod_hdrs}
	${pebear_windows_hdrs}
)

set (pebear_rcc application.qrc )

if(USE_QT4)
	qt4_add_resources(pebear_rcc_src ${pebear_rcc})
	qt4_wrap_cpp(pebear_hdrs_moc ${pebear_hdrs})
else()
	qt5_add_resources(pebear_rcc_src ${pebear_rcc})
	qt5_wrap_cpp(pebear_hdrs_moc ${pebear_hdrs})
endif()

SOURCE_GROUP("Source Files\\base" FILES ${pebear_base_srcs} )
SOURCE_GROUP("Source Files\\gui" FILES ${pebear_gui_srcs} )
SOURCE_GROUP("Source Files\\gui\\pe_models" FILES ${pebear_gui_pe_mod_srcs} )
SOURCE_GROUP("Source Files\\gui\\windows" FILES ${pebear_windows_srcs} )
SOURCE_GROUP("Source Files\\gui_base" FILES ${pebear_gui_base_srcs} )
SOURCE_GROUP("Source Files\\Auto Generated" FILES ${pebear_hdrs_moc} ${pebear_rcc_src} )

SOURCE_GROUP("Header Files\\base" FILES ${pebear_base_hdrs} )
SOURCE_GROUP("Header Files\\gui" FILES ${pebear_gui_hdrs} )
SOURCE_GROUP("Header Files\\gui\\pe_models" FILES ${pebear_gui_pe_mod_hdrs} )
SOURCE_GROUP("Header Files\\gui\\windows" FILES ${pebear_windows_hdrs} )
SOURCE_GROUP("Header Files\\gui_base" FILES ${pebear_gui_base_hdrs} )

IF (WIN32)
	IF(NOT SHOW_CONSOLE)
		#console hidden
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup")
	ENDIF()
ENDIF()

add_definitions(-DCOMMIT_HASH=${COMMIT_HASH})

IF (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
	set(MACOSX TRUE)
ENDIF()

IF(MACOSX)
	add_executable (${PROJECT_NAME} MACOSX_BUNDLE resources.rc ${pebear_hdrs} ${pebear_srcs} ${pebear_hdrs_moc} ${pebear_rcc_src} )

	set_target_properties(${PROJECT_NAME} PROPERTIES
	    BUNDLE True
	    #MACOSX_BUNDLE_GUI_IDENTIFIER my.domain.style.identifier.${PROJECT_NAME}
	    MACOSX_BUNDLE_BUNDLE_NAME ${PROJECT_NAME}
	    MACOSX_BUNDLE_BUNDLE_VERSION "0.1"
	    MACOSX_BUNDLE_SHORT_VERSION_STRING "0.1"
	    #MACOSX_BUNDLE_INFO_PLIST ${CMAKE_SOURCE_DIR}/customtemplate.plist.in
	)
ELSE()
	add_executable (${PROJECT_NAME} resources.rc ${pebear_hdrs} ${pebear_srcs} ${pebear_hdrs_moc} ${pebear_rcc_src} )
ENDIF()

target_link_libraries( ${PROJECT_NAME} ${SIGFIND_LIB} ${PARSER_LIB} )
target_link_libraries (${PROJECT_NAME}  ${DISASM_LIB} ${CAPSTONE_LIB} )

if(USE_QT4)
	target_link_libraries (${PROJECT_NAME} ${QT_QTGUI_LIBRARIES} ${QT_QTCORE_LIBRARIES})
else()	
	target_link_libraries (${PROJECT_NAME} Qt5::Core Qt5::Widgets )
endif()

IF(MACOSX)
	install(TARGETS ${PROJECT_NAME}
		BUNDLE DESTINATION ${CMAKE_INSTALL_PREFIX}/bin
		RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/bin
		COMPONENT ${PROJECT_NAME}
	)
ELSE()
	install(TARGETS ${PROJECT_NAME}
		RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/bin
		COMPONENT ${PROJECT_NAME}
	)
ENDIF()


```

`pe-bear/DateDisplay.cpp`:

```cpp
#include "DateDisplay.h"

#include <time.h>

QString getDateString(const quint64 timestamp)
{
	const time_t rawtime = (const time_t)timestamp;
	QString format = "dddd, dd.MM.yyyy hh:mm:ss";
	QDateTime date1(QDateTime(QDateTime::fromTime_t(rawtime)));
	return date1.toUTC().toString(format) + " UTC";
}


```

`pe-bear/DateDisplay.h`:

```h
#pragma once

#ifdef WITH_QT5
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <QDateTime>

QString getDateString(const quint64 timestamp);


```

`pe-bear/DisasmView.cpp`:

```cpp
#include "DisasmView.h"
#include <QtGlobal>
#include <bearparser/Util.h>
#include <set>
#include "gui/CommentView.h"
#include "TempBuffer.h"

#define VHDR_WIDTH 50
#define COL_WIDTH 18

#define MIN_FIELD_HEIGHT 18
#define MIN_FIELD_WIDTH 18
#define MIN_OFFSET_HDR_WIDTH 18

using namespace pe_bear;
using namespace DisasmView;


void ArgDependentAction::onOffsetChanged(int argNum, offset_t offset)
{
	//printf("ArgDependentAction:: got arg: %d RVA = %llx\n", argNum, offset);
	if (this->myArgNum != argNum) return; // not mine...
	OffsetDependentAction::onOffsetChanged(offset);
}

void ArgDependentAction::onOffsetChanged(int argNum, offset_t offset, Executable::addr_type addrType)
{
	if (this->myArgNum != argNum) return; // not mine...
	OffsetDependentAction::onOffsetChanged(offset, addrType);
}

//-------------------------
DisasmScrollBar::DisasmScrollBar(QWidget *parent) 
	: QScrollBar(parent), myModel(NULL)
{
	this->setAutoFillBackground(true);
	this->setBackgroundRole(QPalette::Dark);

	initMenu();
	enableMenu(true);
	connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(customMenuEvent(QPoint)) );
}

void DisasmScrollBar::setModel(DisasmModel* disasmModel)
{
	myModel = disasmModel;
	setSliderPosition(0);
}

void DisasmScrollBar::enableMenu(bool enable)
{
	if (enable) {
		this->setContextMenuPolicy(Qt::CustomContextMenu);
	} else {
		this->setContextMenuPolicy(Qt::DefaultContextMenu);
	}
}

void DisasmScrollBar::initMenu()
{
	QString pageSize = QString::number(PREVIEW_SIZE, 16);
	QAction *upAction = new QAction("$-" + pageSize, &defaultMenu);
	upAction->setShortcut(Qt::Key_PageUp);
	QAction *downAction = new QAction("$+" + pageSize, &defaultMenu);
	downAction->setShortcut(Qt::Key_PageDown);

	defaultMenu.addAction(downAction);
	defaultMenu.addAction(upAction);

	connect(upAction, SIGNAL(triggered()), this, SLOT(pgUp()) );
	connect(downAction, SIGNAL(triggered()), this, SLOT(pgDown()) );
}

void DisasmScrollBar::pgUp()
{
	if (!myModel) return;

	int last = this->myModel->disasmCount() - 1;
	
	bool isOk = false;
	offset_t rva = myModel->getRvaAt(last);
	if (rva == INVALID_ADDR) return;

	if (!myModel->getPeHandler()->setDisplayed(true, rva)) {
		printf("Conversion failed, simple advance...\n");
		myModel->getPeHandler()->advanceOffset(PREVIEW_SIZE);
	}
}

void DisasmScrollBar::pgDown()
{
	if (!myModel) return;
	myModel->getPeHandler()->advanceOffset((-1)*(PREVIEW_SIZE));
}

void DisasmScrollBar::mousePressEvent(QMouseEvent *e)
{
	if (myModel){
		int count = myModel->disasmCount();
		if (value() == maximum()) pgUp();//myModel->getPeHandler()->advanceOffset(1);
		if (value() == 0) myModel->getPeHandler()->advanceOffset(-1);
	}
	
	QScrollBar::mousePressEvent(e);
}

//---

QWidget* DisasmItemDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
	QWidget* editor = QStyledItemDelegate::createEditor(parent, option, index);
	QLineEdit *lineEdit = qobject_cast<QLineEdit*>(editor);
	if (!lineEdit) {
		return editor;
	}
	QPalette *palette = new QPalette();
	palette->setColor(QPalette::Text, Qt::red);
	palette->setColor(QPalette::Window, Qt::blue);
	palette->setColor(QPalette::Base, Qt::blue);
	lineEdit->setPalette(*palette);
	lineEdit->setAutoFillBackground(true);
	lineEdit->setFrame(false);
	
	QTableView *parentView = qobject_cast<QTableView*>(this->parent());
	DisasmModel *myModel = (!parentView) ? NULL : qobject_cast<DisasmModel*>(parentView->model());
	if (myModel) {
		QFont littleFont(myModel->getSettings()->myFont);
		littleFont.setPointSize(littleFont.pointSize() + 2);
		littleFont.setBold(true);
		lineEdit->setFont(littleFont);
		
		const int x = index.column();
		const int y = index.row();
		if (x == HEX_COL) {
			lineEdit->setValidator(&validator);
			lineEdit->setMaxLength(myModel->getChunkSize(y) * 2);
		}
	}
	return editor;
}
//---------------------------------------------------------

DisasmTreeView::DisasmTreeView(QWidget *parent)
	: ExtTableView(parent),
	myModel(NULL), commentsView(NULL),
	vHdr(this), 
	imgBaseA(NULL), undoAction(NULL)
{
	this->setVerticalScrollBar(&vScrollbar);
	this->setVerticalHeader(&vHdr);

	setDragEnabled(false);
	setShowGrid(false);
	setAutoFillBackground(true);
	setWordWrap(false);

	setCursor(Qt::PointingHandCursor);
	setSelectionBehavior(QTreeWidget::SelectItems);
	setSelectionMode(QTreeWidget::ExtendedSelection);

	setDragDropMode(QAbstractItemView::NoDragDrop);
	setHorizontalScrollMode(QAbstractItemView::ScrollPerItem);
	setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
	
	init();
	initHeader();
	initHeaderMenu();
	initMenu();

	enableMenu(true);
	setMouseTracking(true);
	
	DisasmItemDelegate *delegate = new DisasmItemDelegate(this);
	setItemDelegate(delegate);
}

void DisasmTreeView::init()
{
	setContentsMargins(0, 0, 0, 0);
	setIconSize(QSize(MIN_FIELD_WIDTH, MIN_FIELD_HEIGHT));
	/* init palette */
	QPalette p = this->palette();
	p.setColor(QPalette::Highlight, QColor(HEXDMP_HBG));
	p.setColor(QPalette::HighlightedText, QColor(HEXDMP_HTXT));
	
	p.setColor(QPalette::Base, QColor(DISASMDMP_BG)); 
	p.setColor(QPalette::Text, QColor(DISASMDMP_TXT));
	setPalette(p);
}

void DisasmTreeView::onSetComment(offset_t offset, Executable::addr_type aT)
{
	if (!myModel) return;
	if (this->commentsView == NULL) return;
	if (aT == Executable::RAW || aT == Executable::NOT_ADDR) return; // TODO...
	if (aT == Executable::VA) {
		offset = myModel->m_PE->VaToRva(offset);
	}
	this->commentsView->onSetComment(offset);
}

void DisasmTreeView::onSetEpAction(offset_t offset, Executable::addr_type aT)
{
	if (!myModel || !myModel->m_PE) return;
	if (aT == Executable::RAW || aT == Executable::NOT_ADDR) return; // TODO...
	if (aT == Executable::VA) {
		offset = myModel->m_PE->VaToRva(offset);
	}
	PeHandler *hndl = this->myModel->getPeHandler();
	if (!hndl) return;
	hndl->setEP(offset);
}

void DisasmTreeView::onFollowOffset(offset_t offset, Executable::addr_type aT)
{
	if (!myModel) return;

	PeHandler *hndl = this->myModel->getPeHandler();
	if (!hndl || !hndl->getPe()) return;

	try {
		offset_t raw = hndl->getPe()->toRaw(offset, aT, true);
		hndl->setDisplayed(false, raw);

	} catch (CustomException e) {
		this->lastErrorString = "Address: "+ QString::number(offset, 16) +" is invalid:\n" + e.what();
		QMessageBox::warning(0, "Warning!", this->lastErrorString );
	}
}

void DisasmTreeView::copySelected()
{
	if (!this->myModel) return;
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = this->uniqOffsets(model->selectedIndexes());
	const int size = list.size();
	if (size == 0) return;

	//selected area may not be continuous
	QByteArray bytes;
	for (int i = 0; i < size; i++) {
		QModelIndex index = list.at(i);

		QVariant c = myModel->getRawContentAt(index);
		if (c.canConvert(QVariant::ByteArray)) {
			bytes.append(c.toByteArray());
		}
	}
	QMimeData *mimeData = new QMimeData;
	mimeData->setText(getSelectedText("\t", "\n"));
	mimeData->setData("application/octet-stream", bytes);
	QApplication::clipboard()->setMimeData(mimeData);
}

void DisasmTreeView::pasteToSelected()
{
	if (!this->myModel) return;
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = this->uniqOffsets(model->selectedIndexes());
	if (!this->isIndexListContinuous(list)) {
		QMessageBox::warning(0, "Warning!", "Select continuous area!");
		return;
	}
	if (list.size() == 0) return;

	offset_t firstOffset = myModel->contentOffsetAt(list.at(0));
	int bufSize = this->blockSize(list);

	BYTE *cntntPtr = myModel->m_PE->getContent();
	offset_t cntntSize = myModel->m_PE->getRawSize();

	TempBuffer temp;
	temp.init(bufSize);
	BYTE *buf = temp.getContent();
	if (!buf) return;

	size_t clipSize = ClipboardUtil::getFromClipboard(false, buf, bufSize);
	myModel->myPeHndl->substBlock(firstOffset, clipSize, buf);
}


void DisasmTreeView::initMenu()
{
	QMenu *menu = &defaultMenu;;

	QAction *copySelAction = new QAction("Copy", menu);
	copySelAction->setShortcut(Qt::CTRL + Qt::Key_C);

	menu->addAction(copySelAction);
	connect(copySelAction, SIGNAL(triggered()), this, SLOT(copySelected()));

	QAction *pasteSelAction = new QAction("Paste to selected", menu);
	pasteSelAction->setShortcut(Qt::CTRL + Qt::Key_V);
	menu->addAction(pasteSelAction);
	connect(pasteSelAction, SIGNAL(triggered()), this, SLOT(pasteToSelected()));

	QMenu *followMenu = new QMenu("Follow", menu);
	menu->addMenu(followMenu);

	OffsetDependentAction* followRvaAction = new OffsetDependentAction(Executable::RVA, "Selection RVA:\t", followMenu);
	followMenu->addAction(followRvaAction);
	connect(this, SIGNAL(currentRvaChanged(offset_t)), followRvaAction, SLOT(onOffsetChanged(offset_t)) );
	connect(followRvaAction, SIGNAL(triggered(offset_t, Executable::addr_type)), this, SLOT(onFollowOffset(offset_t, Executable::addr_type)));

	for ( int argNum = 0; argNum < Disasm::MAX_ARG_NUM; argNum++) {
		ArgDependentAction* followArgsAction = new ArgDependentAction(argNum, Executable::RVA, "Arg " + QString::number(argNum) + " RVA:\t", followMenu);
		followMenu->addAction(followArgsAction);
		connect(this, SIGNAL(argRvaChanged(int, offset_t)), followArgsAction, SLOT(onOffsetChanged(int, offset_t)) );
		connect(followArgsAction, SIGNAL(triggered(offset_t, Executable::addr_type)), this, SLOT(onFollowOffset(offset_t, Executable::addr_type)));
	}
	/*

	QMenu *editMenu = new QMenu("Edit", menu);
	menu->addMenu(editMenu);

	OffsetDependentAction* editAction = new OffsetDependentAction(Executable::RVA, "Selection", editMenu);
	editMenu->addAction(editAction);
	connect(this, SIGNAL(currentRvaChanged(uint64_t)), editAction, SLOT(onOffsetChanged(uint64_t)) );
	connect(editAction, SIGNAL(triggered(uint64_t, Executable::addr_type)), this, SLOT(onHexLineEdit(uint64_t, Executable::addr_type)));
	*/
	menu->addSeparator();
	// tag menu
	QPixmap tagIco(":/icons/star.ico");
	//QMenu* tagSubmenu = menu->addMenu(tagIco, "Tag");
	//---
	OffsetDependentAction* setCommentAction = new OffsetDependentAction(Executable::RVA, "Tag", menu);
	setCommentAction->setIcon(tagIco);
	menu->addAction(setCommentAction);
	connect(this, SIGNAL(currentRvaChanged(offset_t)), setCommentAction, SLOT(onOffsetChanged(offset_t)) );
	connect(setCommentAction, SIGNAL(triggered(offset_t, Executable::addr_type) ), this, SLOT(onSetComment(offset_t, Executable::addr_type)));

	//set EP at offset:
	QPixmap epIco(":/icons/arrow-right.ico");
	OffsetDependentAction* setEpAction = new OffsetDependentAction(Executable::RVA, "Set EP =", menu);
	setEpAction->setIcon(epIco);
	menu->addAction(setEpAction);
	connect(this, SIGNAL(currentRvaChanged(offset_t)), setEpAction, SLOT(onOffsetChanged(offset_t)) );
	connect(setEpAction, SIGNAL(triggered(offset_t, Executable::addr_type) ), this, SLOT(onSetEpAction(offset_t, Executable::addr_type)));
}

void DisasmTreeView::initHeaderMenu()
{
	QMenu &hdrMenu = vHdr.defaultMenu;
	//------------

	QMenu *hdrSettings = new QMenu("Settings", &hdrMenu);
	hdrMenu.addSeparator();
	hdrMenu.addMenu(hdrSettings);

	imgBaseA = hdrSettings->addAction("RVA -> VA");
	imgBaseA->setCheckable(true);
	imgBaseA->setToolTip("Add ImageBase");
	imgBaseA->setChecked(false);

	/*Bitmode setting actions */
	QActionGroup *group = new QActionGroup(this);
	group->setExclusive(true);
	QMenu* bitModeSubmenu = hdrSettings->addMenu("&Bit mode");
	const int MODES_NUM = 4;
	QAction *actions[MODES_NUM];

	actions[0] = group->addAction("Automatic");
	actions[0]->setData(0);

	for (int i = 1; i < MODES_NUM; i++) {
		int bitmode = 16<<(i-1);
		actions[i] = group->addAction(QString::number(bitmode));
		actions[i]->setData(bitmode);
	}

	for (int i = 0; i < MODES_NUM; i++) {
		actions[i]->setCheckable(true);
		bitModeSubmenu->addAction(actions[i]);
	}
	actions[0]->setChecked(true);
	connect(group, SIGNAL( triggered(QAction*) ), this, SLOT( setBitMode(QAction*) ));
}

void DisasmTreeView::setBitMode(QAction* action)
{
	QVariant data = action->data();
	int bit = data.toInt();
	if (!myModel) return;

	myModel->resetDisasmMode(bit);
	reset();
}

void DisasmTreeView::changeDisasmViewSettings(DisasmViewSettings &_settings)
{
	if (!myModel) return;
	
	myModel->changeDisasmSettings(_settings);
	resetFont(_settings.myFont);
	reset();
}

void DisasmTreeView::resetFont(const QFont &f)
{
	const int fontDim = ViewSettings::getIconDim(f);
	setFont(f);
	setIconSize(QSize(fontDim, fontDim));

	QHeaderView *verticalHeader = this->verticalHeader();
	if (!verticalHeader) return;

	verticalHeader->setContentsMargins(QMargins(0, 0, 0, 0));

	if (verticalHeader) {
#if QT_VERSION >= 0x050000
		verticalHeader->setSectionResizeMode(QHeaderView::ResizeToContents);
		verticalHeader->setMaximumSectionSize(fontDim);
		verticalHeader->resetDefaultSectionSize();
#else
		verticalHeader->setResizeMode(QHeaderView::ResizeToContents);
#endif
	}
}

void DisasmTreeView::setModel(DisasmModel *model)
{
	ExtTableView::setModel(model);
	vHdr.setHexModel(model);

	if (this->myModel) {
		disconnect(this->myModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
		disconnect(this->myModel, SIGNAL(scrollReset()), &vScrollbar, SLOT(onReset()));
		disconnect(imgBaseA, SIGNAL( triggered(bool) ), this->myModel, SLOT( setShowImageBase(bool)) );
	}
	this->myModel = model;
	delete this->commentsView;
	this->commentsView = NULL;

	if (this->myModel) {
		connect(this->myModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
		connect(this->myModel, SIGNAL(scrollReset()), &vScrollbar, SLOT(onReset()));
	}

	// update actions according to model
	if (this->myModel) {
		bool isImgBase = (myModel->getAddrType() == Executable::VA);
		imgBaseA->setChecked(isImgBase);
		connect(imgBaseA, SIGNAL( triggered(bool) ), this->myModel, SLOT( setShowImageBase(bool)) );

		commentsView = new CommentView(myModel->getPeHandler(), this);
		connect(commentsView, SIGNAL(commentModified()), this, SLOT(reset()));
	}

	this->resizeColumnsToContents();
	this->resizeRowsToContents();
	this->vScrollbar.setModel(myModel);
	initHeader();
}

bool DisasmTreeView::markBranching(QModelIndex index)
{
	if (!index.isValid()) return false;
	if (!this->myModel->myPeHndl || !this->myModel->m_PE) return false;

	offset_t currentRva = this->myModel->getRvaAt(index.row());
	if (this->myModel->m_PE->toRaw(currentRva, Executable::RVA) == INVALID_ADDR) return false; //unmapped area

	offset_t targetRva = this->myModel->getTargetRVA(index);
	if (this->myModel->m_PE->toRaw(targetRva, Executable::RVA) == INVALID_ADDR) return false; //not convertable target

	if (currentRva == INVALID_ADDR || targetRva == INVALID_ADDR) return false;
	this->myModel->setMarkedAddress(currentRva, targetRva);
	return true;
}

void DisasmTreeView::followBranching(QModelIndex index)
{
	if (!index.isValid()) return;
	if (!this->myModel->myPeHndl || !this->myModel->m_PE) return;

	offset_t targetRva = this->myModel->getTargetRVA(index);
	if (targetRva == INVALID_ADDR) {
		return;
	}
	onFollowOffset(targetRva, Executable::RVA);
	return;
}

void DisasmTreeView::emitArgsRVA(const QModelIndex &index)
{
	static offset_t prevTargetRVA = INVALID_ADDR;
	for (int argNum = 0; argNum < Disasm::MAX_ARG_NUM; argNum++) {
		offset_t argRVA = myModel->getArgRVA(argNum, index);
		emit argRvaChanged(argNum, argRVA);
	}
}

void DisasmTreeView::mouseMoveEvent(QMouseEvent *event)
{
	if (!myModel) return;

	QModelIndex index = this->indexAt(event->pos());
	emitArgsRVA(index);

	if (index.column() == DisasmView::DISASM_COL || index.column() == DisasmView::ICON_COL) {
		if (myModel->isClickable(index)) {
			this->setCursor(Qt::PointingHandCursor);
			return;
		}
	}
	this->setCursor(Qt::ArrowCursor);
}

void DisasmTreeView::mousePressEvent(QMouseEvent *event)
{
	QModelIndex index = this->indexAt(event->pos());
	emit currentRvaChanged(myModel->getRvaAt(index.row()));
	emitArgsRVA(index);

	int column = index.column();

	if (this->markBranching(index) && column == DisasmView::ICON_COL) {
		followBranching(index);
	}
	ExtTableView::mousePressEvent(event);
}

void DisasmTreeView::setHovered(QModelIndexList list)
{
	if (!myModel) return;

	const int num = list.size();
	if (num == 0) return;

	std::sort(list.begin(), list.end());
	QModelIndex indexStart = list[0];
	QModelIndex indexEnd = list[num - 1];
	
	offset_t rvaStart = this->myModel->getRvaAt(indexStart.row());
	offset_t rvaEnd = this->myModel->getRvaAt(indexEnd.row());
	if (rvaStart == INVALID_ADDR || rvaEnd == INVALID_ADDR) return;

	bufsize_t bytesNum = myModel->getCurrentChunkSize(indexEnd) + (rvaEnd - rvaStart);
	if (bytesNum == 0) return;

	myModel->myPeHndl->setHovered(true, rvaStart, bytesNum);
}

void DisasmTreeView::selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel)
{
	QItemSelectionModel* selModel = selectionModel();
	if (selModel == NULL) return;
	this->setHovered(selModel->selectedIndexes());
	ExtTableView::selectionChanged(newSel, prevSel);
}

QModelIndexList DisasmTreeView::uniqOffsets(QModelIndexList list)
{
	QModelIndexList uniqueList;
	std::set<offset_t> uniqueOffsets;

	for (int i = 0; i < list.size(); i++) {
		QModelIndex index = list.at(i);
		offset_t currOffset = myModel->contentOffsetAt(index);

		int sizeBefore = uniqueOffsets.size();
		uniqueOffsets.insert(currOffset);

		if (sizeBefore == uniqueOffsets.size()) {
			//not unique
			continue;
		}
		uniqueList.push_back(index);
	}
	return uniqueList;
}

bool DisasmTreeView::isIndexListContinuous(QModelIndexList &uniqList)
{
	//QModelIndexList uniqueList = uniqueRows(list);
	const int size = uniqList.size();
	if (size == 0) return true;

	std::sort(uniqList.begin(), uniqList.end());

	offset_t nextOffset = INVALID_ADDR;

	for (int i = 0; i < uniqList.size(); i++) {
		QModelIndex index = uniqList.at(i);

		offset_t currOffset = myModel->contentOffsetAt(index);
		if (nextOffset != INVALID_ADDR && nextOffset != currOffset) return false;

		nextOffset = currOffset + myModel->getCurrentChunkSize(index);
	}
	return true;
}

int DisasmTreeView::blockSize(QModelIndexList &uniqList)
{
	const int size = uniqList.size();
	if (size == 0) return 0;
	
	offset_t firstOffset = myModel->contentOffsetAt(uniqList.at(0));
	offset_t lastOffset = myModel->contentOffsetAt(uniqList.at(size - 1));
	if (firstOffset == INVALID_ADDR || lastOffset == INVALID_ADDR) {
		return 0;
	}

	if (lastOffset < firstOffset) {
		printf ("Warning: list is not sorted!\n");
		std::sort(uniqList.begin(), uniqList.end());

		firstOffset = myModel->contentOffsetAt(uniqList.at(0));
		lastOffset = myModel->contentOffsetAt(uniqList.at(size - 1));
	}

	size_t dif = (lastOffset - firstOffset);
	size_t blockSize = dif + myModel->getCurrentChunkSize(uniqList.at(size - 1));
	return blockSize;
}

void DisasmTreeView::reset()
{
	ExtTableView::reset();
	resizeColumnsToContents();
	resizeRowsToContents();
	this->horizontalHeader()->reset();
	this->verticalHeader()->reset();
}

void DisasmTreeView::initHeader()
{
	this->verticalHeader()->setContentsMargins(QMargins(0,0,0,0));
	this->verticalHeader()->setAlternatingRowColors(true);
	this->horizontalHeader()->setMinimumSectionSize(MIN_FIELD_WIDTH);

	this->verticalHeader()->setMinimumSectionSize(MIN_FIELD_HEIGHT);
	this->verticalHeader()->setMinimumWidth(MIN_OFFSET_HDR_WIDTH);

	QString styleSheet = "::section {" // "QHeaderView::section {"
		"background-color: #222222;"
	"}";

	verticalHeader()->setStyleSheet(styleSheet);
	horizontalHeader()->setStretchLastSection(true);

	this->resizeColumnsToContents();
	this->resizeRowsToContents();
}

//---

DisasmModel::DisasmModel(PeHandler *peHndl, QObject *parent)
	: HexDumpModel(peHndl, parent), startOff(0),
	isBitModeAuto(true), myDisasm(peHndl->getPe())
{
	addrType = Executable::RVA;
	makeIcons(this->settings.getIconSize());
	connectSignals();
}

void DisasmModel::makeIcons(const QSize &vSize)
{
	tracerIcon = ViewSettings::makeScaledIcon(":/icons/space.ico", vSize.width(),  vSize.height());
	tracerUpIcon = ViewSettings::makeScaledIcon(":/icons/space_up.ico", vSize.width(),  vSize.height());
	tracerDownIcon = ViewSettings::makeScaledIcon(":/icons/space_down.ico", vSize.width(), vSize.height());
	tracerSelf = ViewSettings::makeScaledIcon(":/icons/space_this.ico", vSize.width(), vSize.height());

	callUpIcon = ViewSettings::makeScaledIcon(":/icons/up.ico", vSize.width(),  vSize.height());
	callDownIcon = ViewSettings::makeScaledIcon(":/icons/down.ico", vSize.width(),  vSize.height());
	callWrongIcon = ViewSettings::makeScaledIcon(":/icons/wrong_way.ico", vSize.width(),  vSize.height());
	tagIcon = ViewSettings::makeScaledIcon(":/icons/star.ico", vSize.width(),  vSize.height());
}

void DisasmModel::rebuildDisamTab()
{
	if (this->isBitModeAuto) 
		this->bitMode = (m_PE) ? m_PE->getBitMode() : 32;

	myDisasm.init(startOff, (Executable::exe_bits) this->bitMode);
	myDisasm.fillTable();
	reset();
	emit modelUpdated();
}

void DisasmModel::resetDisasmMode(uint8_t bitMode)
{
	if (!m_PE) return;
	if (bitMode != 16 && bitMode != 32 && bitMode != 64) {
		this->isBitModeAuto = true;
		this->bitMode = m_PE->getBitMode();
	} else {
		this->isBitModeAuto = false;
		this->bitMode = bitMode;
	}
	rebuildDisamTab();
}

void DisasmModel::setShowImageBase(bool flag)
{ 
	this->addrType = (flag) ? Executable::VA : Executable::RVA;
	reset();
}

int DisasmModel::columnCount(const QModelIndex &parent) const
{
	return DISASM_COL_NUM;
}

QVariant DisasmModel::horizHeader(int section, int role) const
{
	if (role == Qt::FontRole) {
		QFont hdrFont = settings.myFont;
		hdrFont.setBold(true);
		hdrFont.setItalic(false);
		return hdrFont;
	}
	
	if (role == Qt::SizeHintRole) {
		return QVariant();
	}
	
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case HEX_COL: return " Hex ";
		case DISASM_COL: return " Disasm ";
		case HINT_COL: return " Hint ";
	}
	return QVariant();
}


QVariant DisasmModel::verticHeader(int section, int role) const
{
	/* independent from value */
	
	if (role == Qt::FontRole) {
		QFont hdrFont = settings.myFont;
		hdrFont.setBold(true);
		hdrFont.setItalic(false);
		return hdrFont;
	}
	if (role == Qt::SizeHintRole) {
		return settings.getVerticalSize();
	}

	/* dependend from value */
	int y = section;
	if (y >= myDisasm.chunksCount()) return QVariant();
	offset_t rva = this->getRvaAt(y);

	if (rva == INVALID_ADDR) {
		if (role == Qt::DisplayRole) return "<invalid>";
		if (role == Qt::ToolTipRole) {
			const offset_t raw = this->getRawAt(y);
			return "Not mapped. Raw = 0x" + QString::number(raw, 16);
		}
		if (role == Qt::TextColorRole) return QColor("red");
	}

	//rva valid
	if (role == Qt::DisplayRole) {
		if (this->addrType == Executable::VA) {
			rva = m_PE->rvaToVa(rva);
		}
		return QString::number(rva, 16).toUpper();
	}

	if (role == Qt::ToolTipRole) {
		return QString::number(rva, 16).toUpper() +"\nRight click to follow";
	}

	if (!myDisasm.isRvaContnuous(y)) {
		if (role == Qt::TextColorRole) return QColor("magenta");
	}

	DWORD ep = m_PE->getEntryPoint();
	size_t disChunk = myDisasm.getChunkSize(y);

	if (ep >= rva && ep < (rva + disChunk)) {
		if (role == Qt::TextColorRole) return QColor("cyan");
		if (role == Qt::ToolTipRole) return "Entry Point = " + QString::number(ep, 16).toUpper();
	}
	// normal color
	if (role == Qt::TextColorRole) return QColor("white");

	return QVariant();
}

QVariant DisasmModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	switch (orientation) {
		case Qt::Horizontal : return horizHeader(section, role);
		case Qt::Vertical : return verticHeader(section, role);
	}
	return QVariant();
}

Qt::ItemFlags DisasmModel::flags(const QModelIndex &index) const 
{
	Qt::ItemFlags f = Qt::ItemIsEnabled;
	int col = index.column();

	if (col == HEX_COL || col == DISASM_COL || col == HINT_COL)
		f |= Qt::ItemIsSelectable;

	if (col == HINT_COL || col == HEX_COL) {
		f |=  Qt::ItemIsEditable;
	}
	return f;
}

QString DisasmModel::getAsm(int index) const
{
	QString str = myDisasm.mnemStr(index);
	
	if (myDisasm.isBranching(index)) {
		str = myDisasm.translateBranching(index);
	}
	return str;
}

QVariant DisasmModel::getHint(const QModelIndex &index) const
{
	if (!index.isValid()) return false;

	QStringList hints;
	int y = index.row();

	/* push ... ret = CALL */
	if (myDisasm.isPushRet(y) && myDisasm.isImmediate(y)) {
		int32_t val = myDisasm.getImmediateVal(y);
		hints.append("RET -> CALL 0x" + QString::number(val, 16));
	}
	if (myDisasm.isAddrOperand(y)) {
		bool isOk = false;
		offset_t targetRva = myDisasm.getTargetRVA(y, isOk);
		if (targetRva != INVALID_ADDR) {
			QString str = myDisasm.getStringAt(targetRva);
			if (str.length() > 0) {
				hints.append(str);
			}
		}
	}
	QString comment = getComment(myDisasm.getRvaAt(y));
	if (comment.length() > 0) {
		hints.append(comment);
	}
	if (hints.size()) {
		return hints.join(" ; ");
	}
	return QVariant();
}

bool DisasmModel::isClickable(const QModelIndex &index) const
{
	bool isValid = false;
	if (index.isValid() == false) return false;
	
	int y = index.row();
	return myDisasm.isFollowable(y);
}

uint32_t DisasmModel::getCurrentChunkSize(const QModelIndex &index) const
{
	bool isValid = false;
	if (index.isValid() == false) return 0;
	return myDisasm.getChunkSize(index.row());
}

offset_t DisasmModel::getTargetRVA(const QModelIndex &index) const
{
	if (index.isValid() == false)  {
		return INVALID_ADDR;
	}
	bool isOk = false;
	offset_t targetRva = myDisasm.getTargetRVA(index.row(), isOk);
	if (targetRva == INVALID_ADDR || !isOk) return INVALID_ADDR;
	return targetRva;
}

offset_t DisasmModel::getArgRVA(const int argNum, const QModelIndex &index) const
{
	if (index.isValid() == false) {
		return INVALID_ADDR;
	}
	bool isOk = false;
	offset_t argRva = myDisasm.getArgRVA(index.row(), argNum, isOk);
	if (argRva == INVALID_ADDR || !isOk) return INVALID_ADDR;
	return argRva;
}

QVariant DisasmModel::getRawContentAt(const QModelIndex &index) const
{
	offset_t indx = contentOffsetAt(index);
	if (indx == INVALID_ADDR) return QVariant();

	const size_t chunkSize = this->getCurrentChunkSize(index);
	if (!chunkSize) return QVariant();

	QByteArray bytes;
	for (size_t i = 0; i < chunkSize; i++) {
		BYTE* contentPtr = m_PE->getContentAt(indx + i, 1);
		if (!contentPtr) break;

		char c = contentPtr[0];
		bytes.append(c);
	}
	return bytes;
}

void DisasmModel::setMarkedAddress(uint64_t cRva, uint64_t tRva)
{
	if (!myPeHndl) return;
	myPeHndl->markedBranching(cRva, tRva);
	reset();
}

bool DisasmModel::setHexData(offset_t offset, const size_t bytesCount, const QString &data)
{
	if (offset == INVALID_ADDR || !myPeHndl || !m_PE) {
		return false;
	}

	BYTE* contentPtr = m_PE->getContentAt(offset, bytesCount);
	if (!contentPtr) {
		return false;
	}

	TempBuffer temp;
	const size_t chunkSize = bytesCount;
	temp.init(contentPtr, chunkSize); //alloc & fill the buffer with the previous content

	BYTE *chunk = temp.getContent();
	if (!chunk) return false;
	
	// convert hex string to bytes:
	size_t modifBytes = 0;
	for (size_t i = 0; i < bytesCount * 2 && i < data.size(); i += 2) {

		QString text = data.mid(i, 2);
		bool isConv = false;
		BYTE number = text.toUShort(&isConv, 16);
		if (!isConv) {
			return false;
		}
		if (modifBytes >= chunkSize) break;
		chunk[modifBytes++] = number;
	}
	if (memcmp(contentPtr, chunk, modifBytes) == 0) {
		// not modified
		return false;
	}
	myPeHndl->backupModification(offset, modifBytes);
	memcpy(contentPtr, chunk, modifBytes);
	myPeHndl->setBlockModified(offset, modifBytes);
	return true;
}

bool DisasmModel::setData(const QModelIndex &index, const QVariant &val, int role)
{
	if (!index.isValid() || !myPeHndl) {
		return false;
	}

	const int y = index.row();
	const int x = index.column();

	const offset_t rva = this->getRvaAt(y);
	const offset_t raw = this->getRawAt(y);

	size_t disChunk = this->getChunkSize(y);
	
	if (x == HEX_COL) {
		return setHexData(raw, disChunk, val.toString());
	}
	if (rva == INVALID_ADDR) {
		return false;
	}
	if (x == HINT_COL) {
		return setComment(rva, val.toString());
	}
	return false;
}


QVariant DisasmModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid() || !myPeHndl) {
		return QVariant();
	}

	if (role == Qt::FontRole) {
		return settings.myFont;
	}
	
	const int y = index.row();
	const int x = index.column();
	
	if (role == Qt::SizeHintRole) {
		if (x == TAG_COL) {
			const QSize iconSize = this->settings.getIconSize();
			return QSize(iconSize.width() + 2, iconSize.height());
		}
		return QVariant();
	}
	
	if (x >= DISASM_COL_NUM || y >= myDisasm.chunksCount()) return QVariant();

	offset_t rva = this->getRvaAt(y);
	const size_t disChunk = this->getChunkSize(y);

	/* TAG */
	if (x == TAG_COL) {
		if (role != Qt::DecorationRole && role != Qt::ToolTipRole) return QVariant();
		QString comment = this->getComment(rva);
		if (comment.size() > 0 ) {
			if (role == Qt::DecorationRole) return tagIcon;
			if (role == Qt::ToolTipRole) return comment;
		}
		return QVariant();
	}
	
	if (rva != INVALID_ADDR && x == PTR_COL && role == Qt::DecorationRole) {
		if (rva == myPeHndl->markedOrigin && rva == myPeHndl->markedTarget) {
			return tracerSelf;
		}

		if (rva > myPeHndl->markedOrigin && rva < myPeHndl->markedTarget 
			|| rva > myPeHndl->markedTarget && rva < myPeHndl->markedOrigin)
		{
			return tracerIcon;
		}

		if ((myPeHndl->markedTarget == rva && myPeHndl->markedTarget > myPeHndl->markedOrigin) 
			|| (myPeHndl->markedOrigin == rva && myPeHndl->markedTarget < myPeHndl->markedOrigin))
		{
			return tracerUpIcon;
		}

		if ((myPeHndl->markedTarget == rva && myPeHndl->markedTarget < myPeHndl->markedOrigin) 
			|| (myPeHndl->markedOrigin == rva && myPeHndl->markedTarget > myPeHndl->markedOrigin))
		{
			return tracerDownIcon;
		}
	}

	if ( myDisasm.isCallToRet(y)) {
		if (role == Qt::TextColorRole) return settings.nopColor;
		if (role == Qt::DisplayRole && x == HINT_COL) return "(CALL -> RET) == NOP";
	}
	if (this->myDisasm.isBranching(y) && !this->myDisasm.isUnconditionalBranching(y)) {
		if (role == Qt::TextColorRole && x != HINT_COL) return settings.conditionalColor;
	}
	
	//---------------------
	bool isOk = false;
	offset_t tRva =  myDisasm.getTargetRVA(y, isOk);

	if (isClickable(index) && isOk) {
		if (role == Qt::BackgroundColorRole) return settings.branchingColor;
				
		int32_t lval =  myDisasm.getTargetDelta(y);
		bool isDelay = false;
		// is Import Call ?
		QString funcName = myPeHndl->importDirWrapper.thunkToFuncName(tRva, false);
		if (funcName.length() == 0 ) {
			// is Delay Import Call ?
			isDelay = true;
			funcName = myPeHndl->delayImpDirWrapper.thunkToFuncName(tRva, false);
		}

		if (funcName.length() > 0) {
			if (x == HINT_COL && (role == Qt::DisplayRole || role == Qt::ToolTipRole )) {
				QString name = funcName;

				QString comment = getComment(rva);
				if (comment.size() > 0) name += " ; " + comment;
				return name;
			}
			if (role == Qt::TextColorRole) {
				if (isDelay) return settings.delayImpColor;
				return this->settings.importColor;
			}
		}

		uint64_t imgSize = m_PE->getImageSize();
		if (x == ICON_COL) {
			
			if (role == Qt::DecorationRole) {
				if (tRva >= imgSize || myDisasm.getRawAt(y) == INVALID_ADDR) {
					return callWrongIcon;
				}
				if (lval < 0) return callUpIcon;
				return callDownIcon;
			}
			
			if (role == Qt::ToolTipRole) {
				if (tRva >= imgSize) {
					return "RVA out of ImageSize: 0x" + QString::number(imgSize, 16);
				}
				if (lval < 0) {
					return "$- 0x" + QString::number(~lval + 1, 16);
				}
				return "$+ 0x" + QString::number(lval, 16);
			}
		}
		
		if (role == Qt::ToolTipRole && x == DISASM_COL) {
			QString s = "Click arrow icon to follow  (RVA: " + QString::number(tRva, 16).toUpper() + ")";
			return s;
		}
	}

	if (role == Qt::TextColorRole) {
		using namespace minidis;
		minidis::mnem_type mnem = myDisasm.getMnemType(y);
		switch (mnem) {
			case MT_RET : return settings.retColor;
			case MT_NOP : return settings.nopColor;
			case MT_INT3 : return settings.int3Color;
			case MT_INTX : return settings.intXColor;
			case MT_CALL : return settings.callColor;
			case MT_JUMP: return settings.jumpColor;
			case MT_INVALID : return settings.invalidColor;
			default : return QVariant();
		}
	}
	if (role == Qt::ToolTipRole && x == HEX_COL) {
		return "Double-click to edit";
	}
	if (x == HEX_COL) {
		if (role == Qt::DisplayRole || role == Qt::ToolTipRole || role == Qt::EditRole) {
			return myDisasm.getHexStr(y).toUpper();
		}
	}
	if (x == DISASM_COL) {
		if (role == Qt::DisplayRole || role == Qt::ToolTipRole || role == Qt::EditRole) {
			return getAsm(y).toUpper();
		}
	}
	if (x == HINT_COL) {
		if (role == Qt::EditRole) {
			return this->getComment(rva);
		}
		if (role == Qt::DisplayRole || role == Qt::ToolTipRole) {
			return getHint(index);
		}
	}
	return QVariant();
}

//--------------------------------------------------------------------

```

`pe-bear/DisasmView.h`:

```h
#pragma once

#ifdef WITH_QT5
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>
#include <bear_disasm.h>
#include "gui/CommentView.h"

#include "PEFileTreeModel.h"
#include "HexView.h"
#include "gui_base/OffsetDependentAction.h"

#include "OffsetHeader.h"
#include "ViewSettings.h"

class DisasmModel;

class ArgDependentAction : public OffsetDependentAction 
{
	Q_OBJECT
public:
	ArgDependentAction(int argNum, const Executable::addr_type addrType, const QString &title, QObject* parent)
		: OffsetDependentAction(addrType, title,  parent), myArgNum(argNum) {}

public slots:
	void onOffsetChanged(int argNum, offset_t offset);
	void onOffsetChanged(int argNum, offset_t offset, Executable::addr_type addrType);

protected:
	int myArgNum;
};

//----
class DisasmItemDelegate: public QStyledItemDelegate
{
    Q_OBJECT
public:
	DisasmItemDelegate(QObject* parent)
		: QStyledItemDelegate(parent)
	{
		validator.setRegExp(QRegExp("[0-9A-Fa-f]{1,}"));
	}

	QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const override;

private:
	QRegExpValidator validator;
};

//--------------------------------------------------------------------
namespace DisasmView {
	enum DisasmFieldId {
		TAG_COL = 0, 
		HEX_COL, 
		ICON_COL, 
		PTR_COL, 
		DISASM_COL, 
		HINT_COL, 
		DISASM_COL_NUM
	};
};

class DisasmScrollBar : public QScrollBar
{
	Q_OBJECT

public slots:
	void onReset() { setSliderPosition(0); }

public:
	explicit DisasmScrollBar(QWidget *parent=0);

	explicit DisasmScrollBar(Qt::Orientation orientation, QWidget *parent=0) 
		: QScrollBar(orientation, parent), myModel(NULL) {}

	void setModel(DisasmModel* disasmModel);
	void enableMenu(bool enable);

protected slots:
	void customMenuEvent(QPoint p) { defaultMenu.exec(mapToGlobal(p)); }
	void pgUp();
	void pgDown();

protected:
	virtual void mousePressEvent(QMouseEvent *);
	virtual void initMenu();

	DisasmModel *myModel;
	QMenu defaultMenu;
};

class DisasmTreeView : public ExtTableView
{
	Q_OBJECT

signals:
	void changePage(bool up);
	void currentRvaChanged(offset_t targetRVA);
	void argRvaChanged(int argNum, offset_t targetRVA);

public:
	DisasmTreeView(QWidget *parent);
	void setModel(DisasmModel *model);

public slots:
	void onModelUpdated() { reset(); }
	void setBitMode(QAction* action);
	void changeDisasmViewSettings(DisasmViewSettings &_settings);

protected slots:
	void onSetComment(offset_t offset, Executable::addr_type aT);
	void onSetEpAction(offset_t offset, Executable::addr_type aT);
	void onFollowOffset(offset_t offset, Executable::addr_type aT);

	virtual void copySelected();
	virtual void pasteToSelected();

protected:
	/* input: unique list */
	bool isIndexListContinuous(QModelIndexList &uniqueList);

	/* input: sorted, unique, continuous list */
	int blockSize(QModelIndexList &uniqueList);

	void reset();

	void init();
	void initHeader();
	void initHeaderMenu();
	void initMenu();
	void resetFont(const QFont &f);

	bool markBranching(QModelIndex currIndex);
	
	void followBranching(QModelIndex currIndex);
	void setHovered(QModelIndexList indexList);

	void mouseMoveEvent(QMouseEvent *event);
	void mousePressEvent(QMouseEvent *event);
	void selectionChanged(const QItemSelection &, const QItemSelection &);

	DisasmScrollBar vScrollbar;
	OffsetHeader vHdr;
	DisasmModel *myModel;
	CommentView *commentsView;

	/* actions */
	QAction *imgBaseA, *undoAction;

private:
	void emitArgsRVA(const QModelIndex &index);

	/* returns List of indexes with unique offsets (removes repetition) */
	QModelIndexList uniqOffsets(QModelIndexList list);
};
//--------------------------------------------------------------------
class DisasmModel : public HexDumpModel
{
	Q_OBJECT
/*
signals:
	void scrollReset(); // inherited from HexDumpModel
	*/
public slots:
	virtual void onNeedReset() { rebuildDisamTab(); }
	void setStartingOffset(offset_t start) { startOff = start; rebuildDisamTab(); }
	void setShownContent(offset_t start, bufsize_t size) { setStartingOffset(start);  emit scrollReset(); }

	void resetDisasmMode(uint8_t bitMode);
	void setShowImageBase(bool flag);
	bool setComment(offset_t rva, const QString &comment)
	{
		if (myPeHndl && rva != INVALID_ADDR) {
			myPeHndl->comments.setComment(rva, comment);
			return true;
		}
		return false;
	}
	
	bool setHexData(offset_t raw, size_t size, const QString &data);
	
	void changeDisasmSettings(DisasmViewSettings &_settings)
	{
		this->settings = _settings;
		const QSize iSize = this->settings.getIconSize();
		makeIcons(iSize);
		reset();
	}
	
public:
	DisasmModel(PeHandler *peHndl, QObject *parent = 0);

	/* wrappers for Disasm */
	offset_t getRawAt(int index) const { return myDisasm.getRawAt(index); }
	offset_t getRvaAt(int index) const { return myDisasm.getRvaAt(index); }
	size_t getChunkSize(int index) const { return myDisasm.getChunkSize(index); }
	
	offset_t getTargetRVA(const QModelIndex &index) const;
	offset_t getArgRVA(const int argNum, const QModelIndex &index) const;

	virtual offset_t contentOffsetAt(const QModelIndex &index) const { return getRawAt(index.row()); }
	QVariant getRawContentAt(const QModelIndex &index) const;

	void setMarkedAddress(offset_t cRva, offset_t tRva);
	int disasmCount() const { int size = myDisasm.chunksCount(); return size > 0 ? size - 1 : 0; }

	int rowCount(const QModelIndex &parent) const { return disasmCount(); }
	int columnCount(const QModelIndex &parent) const;

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);

	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	QVariant horizHeader(int section, int role) const;
	QVariant verticHeader(int section, int role) const;

	Qt::ItemFlags flags(const QModelIndex &index) const;

	uint32_t getCurrentChunkSize(const QModelIndex &index) const;

	bool isClickable(const QModelIndex &index) const;

	QString getComment(offset_t rva) const { return (myPeHndl) ?  myPeHndl->comments.getCommentAt(rva) : ""; }

	virtual ViewSettings* getSettings()
	{
		return &settings;
	}

protected:
	void makeIcons(const QSize &vSize);
	void rebuildDisamTab();

	QVariant getHint(const QModelIndex &index) const;
	QString getAsm(int index) const;

private:
	pe_bear::PeDisasm myDisasm;
	uint32_t startOff;

	uint8_t bitMode;
	bool isBitModeAuto;
	bool showImageBase;

	QIcon tracerIcon, tracerUpIcon, tracerDownIcon, tracerSelf;
	QIcon callUpIcon, callDownIcon, callWrongIcon, tagIcon;
	
	DisasmViewSettings settings;

friend class DisasmTreeView;
};

```

`pe-bear/ExeDependentAction.cpp`:

```cpp
#include "ExeDependentAction.h"

void ExeDependentAction::updateEnabled()
{
	bool isSet = this->currHndl != NULL;
	this->setEnabled(this->currHndl != NULL);
}

void ExeDependentAction::init()
{
	connect(this, SIGNAL(triggered()), this, SLOT(onTriggered()));
	updateEnabled();
}

void ExeDependentAction::onHandlerSelected(PeHandler *hndl)
{
	if (this->currHndl == hndl) return; 
	this->currHndl = hndl; 
	
	updateEnabled();
	emit currHndlChanged();
}
//-------------------------

void ExeDependentMenu::addAction(QAction *action)
{
	if (!action) return;

	ExeDependentAction *exeAction = dynamic_cast <ExeDependentAction*> (action);
	if (exeAction) {
		connect(this, SIGNAL(handlerSet(PeHandler*)), action, SLOT(onHandlerSelected(PeHandler*)) );
	}
	QMenu::addAction(action);
}

void ExeDependentMenu::removeAction(QAction *action)
{
	if (!action) return;

	ExeDependentAction *exeAction = dynamic_cast <ExeDependentAction*> (action);
	if (exeAction) {
		disconnect(this, SIGNAL(handlerSet(PeHandler*)), action, SLOT(onHandlerSelected(PeHandler*)) );
	}
	QMenu::removeAction(action);
}

void ExeDependentMenu::onExeChanged(PeHandler* hndl) 
{
	if (this->myHndl == hndl) {
		return; //no changes
	}
	this->myHndl = hndl;

	bool isEnabled = this->myHndl != NULL;
	this->setEnabled(isEnabled);
	
	emit handlerSet(this->myHndl);
}

```

`pe-bear/ExeDependentAction.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "base/PeHandlersManager.h"

class ExeDependentAction : public QAction
{
	Q_OBJECT

signals:
	void currHndlChanged();

public slots:
	void onHandlerSelected(PeHandler *hndl);

public :
	ExeDependentAction(QObject *parent) : QAction(parent), currHndl(NULL) { init(); }
	ExeDependentAction(const QString text, QObject *parent) : QAction(text, parent), currHndl(NULL) { init(); }
	ExeDependentAction(const QIcon ico, const QString text, QObject *parent) : QAction(ico, text, parent), currHndl(NULL) { init(); }

signals:
    void triggered(PeHandler*);

private slots:
	void onTriggered() { emit triggered(currHndl); }

protected:
	void init();
	void updateEnabled();

	PeHandler *currHndl;
};

class ExeDependentMenu : public QMenu
{
	Q_OBJECT

signals:
	void handlerSet(PeHandler* hndl);

protected slots:
	void onExeChanged(PeHandler* hndl);

public:
	ExeDependentMenu(QWidget *parent = 0) : QMenu(parent),  myHndl(NULL) {}
	virtual ~ExeDependentMenu() { }

	void addAction(QAction *action);
	void removeAction(QAction *action);

protected:
	PeHandler* myHndl;
};

```

`pe-bear/HexCompareView.cpp`:

```cpp
#include "HexCompareView.h"

#define MIN_FIELD_HEIGHT 18
#define MIN_FIELD_WIDTH 10

MenuHeader::MenuHeader(QWidget *parent)
	: QHeaderView(Qt::Vertical, parent), tableModel(NULL)
{
#if QT_VERSION >= 0x050000
	setSectionsClickable(true);
	setSectionsMovable(false);
#else
	setClickable(true);
	setMovable(false);
#endif
	setAutoFillBackground(true);

	this->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(customMenuEvent(QPoint)) );

	this->copyAction = new QAction("Copy the offset", this);
	connect(copyAction, SIGNAL(triggered()), this, SLOT(copyOffset()));

	this->defaultMenu.addAction(copyAction);
}

void MenuHeader::customMenuEvent(QPoint p)
{
	if (this->selectedOffset == INVALID_ADDR) {
		return;
	}
	const QPoint p2 = this->mapToGlobal(p); 
	this->defaultMenu.exec(p2);
}

void MenuHeader::mousePressEvent(QMouseEvent *event)
{
	QPoint p = event->pos();
	int indx = logicalIndexAt(p) ;

	if (this->tableModel) {
		
		QVariant data = this->tableModel->headerData(indx, Qt::Vertical, Qt::DisplayRole);
		bool isOk;
		offset_t offset = data.toString().toLongLong(&isOk, 16);
		if (isOk) {
			selectedOffset = offset;
		}
		copyAction->setText("Copy the offset: " + QString::number(selectedOffset, 16).toUpper());
	}
	QHeaderView::mousePressEvent(event);
}

//----

HexCompareView::HexCompareView(QWidget *parent)
{
	vHdr = new MenuHeader(parent);
	this->setVerticalHeader(vHdr);
	
	init();
	initHeader();
}

void HexCompareView::init()
{
	setShowGrid(false);
	setDragEnabled(false);
	setAutoFillBackground(true);
	setAlternatingRowColors(true);

	this->resizeColumnsToContents();
	this->resizeRowsToContents();

	this->setCursor(Qt::PointingHandCursor);
	setSelectionBehavior(QTreeWidget::SelectItems);
	setSelectionMode(QTreeWidget::ExtendedSelection);
	setDragDropMode(QAbstractItemView::NoDragDrop);

	this->setContentsMargins(0, 0, 0, 0);
	this->setContextMenuPolicy(Qt::CustomContextMenu);
}

void HexCompareView::initHeader()
{
	horizontalHeader()->setContentsMargins(QMargins(0, 0, 0, 0));
	verticalHeader()->setContentsMargins(QMargins(0, 0, 0, 0));
	this->horizontalHeader()->setMinimumSectionSize(MIN_FIELD_WIDTH);
	this->verticalHeader()->setMinimumSectionSize(MIN_FIELD_HEIGHT);

#if QT_VERSION >= 0x050000
	this->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setSectionsClickable(true);
#else
	this->horizontalHeader()->setResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setClickable(true);
#endif
}

```

`pe-bear/HexCompareView.h`:

```h
#pragma once

#include <stack>
#include <QtGlobal>
#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <QStyledItemDelegate>

#include "REbear.h"
#include "base/PeHandlersManager.h"
#include "PEFileTreeModel.h"

#include "gui_base/ExtTableView.h"

class MenuHeader : public QHeaderView
{
	Q_OBJECT
public:
	MenuHeader(QWidget *parent);

	virtual void setTableModel(QAbstractItemModel *model)
	{
		this->tableModel = model;
	}
	
	QMenu defaultMenu;

public slots:
	virtual void customMenuEvent(QPoint p);
	
	void copyOffset()
	{
		QMimeData *mimeData = new QMimeData;
		mimeData->setText(QString::number(selectedOffset, 16));
		QApplication::clipboard()->setMimeData(mimeData);
	}

protected:
	void mousePressEvent(QMouseEvent *event);
	
	QAbstractItemModel *tableModel;
	QAction *copyAction;
	
	offset_t selectedOffset;
};


class HexCompareView : public ExtTableView
{
	Q_OBJECT
	
public:
	HexCompareView(QWidget *parent = 0);
	
	virtual void setModel(QAbstractItemModel *model) override
	{
		ExtTableView::setModel(model);
		if (vHdr) {
			vHdr->setTableModel(model);
		}
	}

protected:
	void init();
	void initHeader();
	
	MenuHeader *vHdr;
};




```

`pe-bear/HexDumpModel.cpp`:

```cpp
#include "HexDumpModel.h"

#define HEX_COL_NUM 16
#define COL_NUM (HEX_COL_NUM)

HexDumpModel::HexDumpModel(PeHandler *peHndl, bool isHexFormat, QObject *parent)
	: PeTableModel(peHndl, parent),
	showHex(isHexFormat),
	startOff(0), endOff(0), pageSize(PREVIEW_SIZE),
	addrType(Executable::RAW)
{
	connectSignals();
	connect(myPeHndl, SIGNAL(marked()), this, SLOT (onNeedReset()));
}

void HexDumpModel::setShownContent(offset_t start, bufsize_t size)
{
	this->startOff = start;
	endOff = start + size;
	reset();
	emit scrollReset();
}

int HexDumpModel::rowCount(const QModelIndex &parent) const
{
	if (startOff == INVALID_ADDR) return 0;

	const offset_t peSize = this->m_PE->getRawSize();
	if (peSize < this->startOff) return 0;

	bufsize_t viewSize = pageSize;
	size_t diff = peSize - this->startOff;
	if (diff < pageSize) {
		viewSize = diff;
	}
	return pe_util::unitsCount(viewSize, HEX_COL_NUM);
}

int HexDumpModel::columnCount(const QModelIndex &parent) const
{
	return COL_NUM;
}

QVariant HexDumpModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (orientation == Qt::Horizontal) {
		if (role == Qt::DisplayRole) {
			if (section == COL_NUM) return QVariant();
			return QString::number(section, 16).toUpper();
		}
		if (role == Qt::SizeHintRole) return QVariant();
	}
	if (orientation == Qt::Vertical) {

		if (role == Qt::SizeHintRole) {
			return settings.getVerticalSize();
		}

		offset_t offset = this->startOff + (section * HEX_COL_NUM);

		if (role == Qt::DisplayRole) {
			return QString::number(offset, 16).toUpper();
		}
		if ( role == Qt::ToolTipRole) {
			return QString::number(offset, 16).toUpper() +"\nRight click to follow.";
		}
	}

	if (role == Qt::FontRole) {
		QFont hdrFont = settings.myFont;
		hdrFont.setBold(true);
		hdrFont.setItalic(false);
		return hdrFont;
	}
	return QVariant();
}

Qt::ItemFlags HexDumpModel::flags(const QModelIndex &index) const 
{
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
}

offset_t HexDumpModel::contentOffsetAt(const QModelIndex &index) const
{
	if (!index.isValid()) return INVALID_ADDR;

	offset_t fileSize = m_PE->getRawSize();
	int x = index.column();
	int y = index.row();

	y *= HEX_COL_NUM;
	offset_t offset = (y + x) + startOff;

	if (offset >= fileSize) {
		return INVALID_ADDR; /* out of bounds */
	}
	return offset;
}

QVariant HexDumpModel::getRawContentAt(const QModelIndex &index) const
{
	offset_t offset = contentOffsetAt(index);
	if (offset == INVALID_ADDR) return QVariant();

	BYTE* contentPtr = m_PE->getContentAt(offset, 1);
	if (!contentPtr) {
		return QVariant();
	}
	const QChar c = contentPtr[0];
	return c;
}

QVariant HexDumpModel::getElement(offset_t offset) const
{
	if (!m_PE || offset == INVALID_ADDR || offset > m_PE->getContentSize()) {
		return QVariant();
	}
	BYTE* contentPtr = m_PE->getContentAt(offset, 1);
	if (!contentPtr) {
		return QVariant();
	}
	const BYTE val = contentPtr[0];
	if (showHex) {
#if QT_VERSION >= 0x050000
		return QString().asprintf("%02X", val);
#else
		return QString().sprintf("%02X", val);
#endif
	}
	
	const QChar c = val;
	if (c.isPrint() && !c.isSpace())
		return c;
	return QChar('.');
}

QVariant HexDumpModel::data(const QModelIndex &index, int role) const
{
	if (index.isValid() == false) return QVariant();
	
	if (role == Qt::SizeHintRole) {
		return QVariant();
	}
	
	if (index.column() >= COL_NUM) {
		return QVariant();
	}

	int x = index.column();
	int y = index.row() * HEX_COL_NUM;
	offset_t offset = (y + x) + this->startOff;
	if (offset >= m_PE->getRawSize()) {
		return QVariant(); /* out of bounds */
	}

	if (offset >= myPeHndl->hoveredOffset 
		&& offset < (myPeHndl->hoveredOffset + myPeHndl->hoveredSize))
	{
		if (role == Qt::BackgroundColorRole) return settings.hoveredColor;
	}
	
	if (role == Qt::FontRole) {
		return settings.myFont;
	}
	if (role == Qt::ToolTipRole) {
		return "Double-click to edit";
	}
	if (role == Qt::ForegroundRole) {
		bool isActiveArea = this->myPeHndl->isInActiveArea(offset);
		bool isModifiedArea = this->myPeHndl->isInModifiedArea(offset);

		if (isModifiedArea) {
			if (!isActiveArea) return this->settings.inactiveModifColor;
			return this->settings.modifColor;
		}
		if (!isActiveArea) {
			return this->settings.inactiveColor;
		}
	}
	if (role == Qt::DisplayRole || role == Qt::EditRole) {
		return getElement(offset);
	}
	return QVariant();
}

bool HexDumpModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (index.isValid() == false) return false;
	if (!myPeHndl || !m_PE) return false;

	offset_t offset = contentOffsetAt(index);
	if (offset == INVALID_ADDR) return false;
	
	QString text = value.toString();
	const size_t el_size = (showHex) ? 2 : 1;
	if (text.length() < el_size) {
		return false;
	}
	text = text.left(el_size);

	BYTE* contentPtr = m_PE->getContentAt(offset, 1);
	if (!contentPtr) return false;
	
	BYTE prev_val = contentPtr[0];
	BYTE val = 0;

	if (showHex) {
		bool isConv = false;
		BYTE number = text.toUShort(&isConv, 16);
		if (!isConv) return false;
		val = number;
	} else {
#if QT_VERSION >= 0x050000
		val = (BYTE) text.at(0).toLatin1();
#else
		val = (BYTE) text.at(0).toAscii();
#endif
	}
	if (prev_val == val) {
		return false; // nothing has changed
	}
	myPeHndl->backupModification(offset, 1);
	contentPtr[0] = val;
	myPeHndl->setBlockModified(offset, 1);
	return true;
}

```

`pe-bear/HexDumpModel.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "gui_base/PeTableModel.h"
#include "ViewSettings.h"

class HexDumpModel : public PeTableModel//QAbstractTableModel, public PeViewItem
{
	Q_OBJECT

signals:
	void scrollReset();

public slots:
	void setHexView(bool isSet) { showHex = isSet; reset(); }

	void setShownContent(offset_t start, bufsize_t size);

public:
	HexDumpModel(PeHandler *peHndl, bool isHex, QObject *parent = 0);
	
	Executable::addr_type getAddrType() { return this->addrType; }
	bool isHexView() const { return showHex; }

	bufsize_t getPageSize() { return pageSize; };
	offset_t getStartOff() { return startOff; }

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const;

	QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &, const QVariant &, int role);

	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual offset_t contentOffsetAt(const QModelIndex &index) const;
	QVariant getRawContentAt(const QModelIndex &index) const;
	QVariant getElement(offset_t offset) const;

	virtual ViewSettings* getSettings()
	{
		return &settings;
	}

	void changeSettings(HexViewSettings &newSettings) 
	{
		settings = newSettings;
	}

protected:
	Executable::addr_type addrType;

private:
	HexViewSettings settings;
	bool showHex;
	offset_t startOff, endOff;
	bufsize_t pageSize;

friend class HexTableView;
friend class OffsetHeader;
};

```

`pe-bear/HexView.cpp`:

```cpp
#include "HexView.h"

#include <QClipboard>

#define HEX_COL_NUM 16
#define COL_NUM (HEX_COL_NUM)
#define VHDR_UNITS 6

#define COL_WIDTH 10
#define MIN_FIELD_HEIGHT 18
#define MIN_FIELD_WIDTH 10

#include <iostream>
#include "TempBuffer.h"

//----
QModelIndex getNextIndex(QAbstractItemModel &model, const QModelIndex &index)
{
	const int rowcount = model.rowCount();
	const int colcount = model.columnCount();
	if (rowcount == 0 || colcount == 0) {
		return QModelIndex();
	}
	
	int currCol = index.column();
	int currRow = index.row();

	if (currCol == (colcount - 1)) {
		currRow++;
		currCol = 0;
	} else {
		currCol++;
	}
	return model.index(currRow, currCol);
}

//----

HexItemDelegate::HexItemDelegate(QObject* parent) :
	QStyledItemDelegate(parent)
{
	validator.setRegExp(QRegExp("[0-9A-Fa-f]{2,}"));
}

void HexItemDelegate::selectNextParentItem(const QModelIndex &index) const
{
	QTableView *parentView = qobject_cast<QTableView*>(this->parent());
	if (!parentView) return;
	
	parentView->setCurrentIndex(index);
	parentView->edit(index);
}


QWidget* HexItemDelegate::createEditor(QWidget *parent,
	const QStyleOptionViewItem &option,
	const QModelIndex &index) const
{
	QWidget* editor = QStyledItemDelegate::createEditor(parent, option, index);

	QLineEdit *lineEdit = qobject_cast<QLineEdit*>(editor);
	if (!lineEdit) {
		return editor;
	}
	QPalette *palette = new QPalette();
	palette->setColor(QPalette::Text, Qt::red);
	palette->setColor(QPalette::Window, Qt::yellow);
	palette->setColor(QPalette::Base, Qt::white);
	lineEdit->setPalette(*palette);
	lineEdit->setAutoFillBackground(true);
	lineEdit->setFrame(false);

	QTableView *parentView = qobject_cast<QTableView*>(this->parent());
	HexDumpModel *hexModel = (!parentView) ? NULL : qobject_cast<HexDumpModel*>(parentView->model());
	if (hexModel) {
		QFont littleFont(hexModel->getSettings()->myFont);
		littleFont.setPointSize(littleFont.pointSize() + 2);
		littleFont.setBold(true);
		lineEdit->setFont(littleFont);
	
		if (hexModel->isHexView()) {
			lineEdit->setValidator(&validator);
			lineEdit->setMaxLength(2);
		} else {
			lineEdit->setMaxLength(1);
		}
	}
	return editor;
}

void HexItemDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex& index) const
{
	QStyledItemDelegate::setModelData(editor, model, index);
	emit dataSet(index.column(), index.row());
}

//--------------------------------------------------------------------

HexTableView::HexTableView(QWidget *parent)
	: ExtTableView(parent), hexModel(NULL), hexColWidth(COL_WIDTH)
{
	this->vHdr = new OffsetHeader(this);
	hHdr = new QHeaderView(Qt::Horizontal, this);	
	
	this->setVerticalHeader(vHdr);
	this->setHorizontalHeader(hHdr);
	vHdr->setVisible(true);
	hHdr->setVisible(true);
	//hHdr->setFrameShape(QFrame::Shape::Panel);
#if QT_VERSION >= 0x050000
	vHdr->setSectionsClickable(true);
#else
	vHdr->setClickable(true);
#endif
	init();
	initHeader();
	initHeaderMenu();
	initMenu();

	adjustMinWidth();
	enableMenu(true);

	HexItemDelegate *delegate = new HexItemDelegate(this);
	setItemDelegate(delegate);
	connect (delegate, SIGNAL(dataSet(int, int)), this, SLOT(onDataSet(int, int)) );
}

void HexTableView::init()
{
	setShowGrid(false);
	setDragEnabled(false);
	setAutoFillBackground(true);

	this->resizeColumnsToContents();
	this->resizeRowsToContents();

	this->setCursor(Qt::PointingHandCursor);
	setSelectionBehavior(QTreeWidget::SelectItems);
	setSelectionMode(QTreeWidget::ExtendedSelection);
	setDragDropMode(QAbstractItemView::NoDragDrop);

	this->setContentsMargins(0, 0, 0, 0);
	this->setContextMenuPolicy(Qt::CustomContextMenu);
}

void HexTableView::initHeaderMenu()
{
	if (!vHdr) return;
	QMenu &hdrMenu = vHdr->defaultMenu;
	QMenu *naviSubMenu = hdrMenu.addMenu("Navigation");

	QString pageSize = QString::number(PREVIEW_SIZE, 16);

	QAction *pgUp = new QAction("$-" + pageSize, naviSubMenu);
	pgUp->setShortcut(QKeySequence(Qt::Key_PageUp));
	connect(pgUp, SIGNAL(triggered()), this, SLOT(setPageUp()));
	naviSubMenu->addAction(pgUp);

	QAction *pgDn = new QAction("$+" + pageSize, naviSubMenu);
	pgDn->setShortcut(QKeySequence(Qt::Key_PageDown));
	connect(pgDn, SIGNAL(triggered()), this, SLOT(setPageDown()));
	naviSubMenu->addAction(pgDn);

	back = new QAction("Back to offset", &hdrMenu);
	back->setShortcut(Qt::Key_B);
	connect(back, SIGNAL(triggered()), this, SLOT(undoOffset()));
	naviSubMenu->addAction(back);
}

void HexTableView::initMenu()
{
	QMenu* menu = &defaultMenu;
	//QMenu* editSubmenu = menu.addMenu("&Selection");

	QAction *copySelAction = new QAction("Copy", menu);
	copySelAction->setShortcut(Qt::CTRL + Qt::Key_C);

	menu->addAction(copySelAction);
	connect(copySelAction, SIGNAL(triggered()), this, SLOT(copySelected()));

	QAction *pasteSelAction = new QAction("Paste to selected", menu);
	pasteSelAction->setShortcut(Qt::CTRL + Qt::Key_V);
	menu->addAction(pasteSelAction);
	connect(pasteSelAction, SIGNAL(triggered()), this, SLOT(pasteToSelected()));

	QMenu* fillSubmenu = menu->addMenu("Fill selected");
	
	QAction *clearSelAction = new QAction("Clear", fillSubmenu);
	clearSelAction->setShortcut(Qt::Key_Delete);
	fillSubmenu->addAction(clearSelAction);
	connect(clearSelAction, SIGNAL(triggered()), this, SLOT(clearSelected()));

	QAction *fillSelAction = new QAction("NOP", fillSubmenu);
	fillSubmenu->addAction(fillSelAction);
	connect(fillSelAction, SIGNAL(triggered()), this, SLOT(fillSelected()));

	undo = new QAction("Undo", menu);
	undo->setShortcut(Qt::CTRL + Qt::Key_Z);
	connect(undo, SIGNAL(triggered()), this, SLOT(undoLastModification()));
}

void HexTableView::initHeader()
{
	horizontalHeader()->setContentsMargins(QMargins(0, 0, 0, 0));
	verticalHeader()->setContentsMargins(QMargins(0, 0, 0, 0));
	this->verticalHeader()->setMinimumWidth(40);
	this->verticalHeader()->setAlternatingRowColors(true);
	
	this->horizontalHeader()->setMinimumSectionSize(MIN_FIELD_WIDTH);
	this->verticalHeader()->setMinimumSectionSize(MIN_FIELD_HEIGHT);
#if QT_VERSION >= 0x050000
	this->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
#else
	this->horizontalHeader()->setResizeMode(QHeaderView::ResizeToContents);
	this->verticalHeader()->setResizeMode(QHeaderView::ResizeToContents);
#endif
}


void HexTableView::adjustMinWidth()
{
	int width = (COL_NUM) * this->hexColWidth;
	if (this->hexModel) {
		this->hexColWidth = this->hexModel->isHexView() ? (2 * COL_WIDTH) : COL_WIDTH;
		width = (COL_NUM) * this->hexColWidth;
		//if (this->hexModel->isHexView()) width += (VHDR_UNITS * COL_WIDTH);
	}
	if (this->isVHdrVisible) width += (VHDR_UNITS * COL_WIDTH);
	this->setMinimumWidth(width);
}

void HexTableView::onDataSet(int col, int row)
{
	if (!this->model()) return; // invalid
	
	QModelIndex indx = model()->index(row, col);
	QModelIndex nextIndx = getNextIndex(*this->model(), indx);
	this->setCurrentIndex(nextIndx);
	this->edit(nextIndx);
}

void HexTableView::copySelected()
{
	if (!this->hexModel) return;
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = model->selectedIndexes();
	const int size = list.size();
	if (size == 0) return;

	std::sort(list.begin(), list.end());

	QByteArray bytes;
	for (int i = 0; i < size; i++) {
		QModelIndex index = list.at(i);
		QVariant c = hexModel->getRawContentAt(index);
		if (c.canConvert(QVariant::Char)){ 
#if QT_VERSION >= 0x050000
			BYTE b = c.toChar().toLatin1();
#else
			BYTE b = c.toChar().toAscii();
#endif
			bytes.append(b);
		}
	}
	QString separator = this->hexModel->isHexView() ? " " : "";

	QMimeData *mimeData = new QMimeData;
	//mimeData->setText(getSelectedText(separator, separator));
	QString text = getSelectedText(separator, separator);
#if QT_VERSION >= 0x050000
	mimeData->setData("text/plain", text.toLatin1());
#else
	mimeData->setData("text/plain", text.toAscii());
#endif
	mimeData->setData("application/octet-stream", bytes);
	QApplication::clipboard()->setMimeData(mimeData);
}

bool HexTableView::isIndexListContinuous(QModelIndexList &list)
{
	const int size = list.size();
	if (size == 0) return true;
	std::sort(list.begin(), list.end());

	bool isContinuous = true;
	offset_t prevIndx = INVALID_ADDR;

	for (int i = 0; i < list.size(); i++) {
		QModelIndex index = list.at(i);
		offset_t cIndx = hexModel->contentOffsetAt(index);
		if (prevIndx != INVALID_ADDR && cIndx != prevIndx + 1) {
			return false;
		}
		prevIndx = cIndx;
	}
	return true;
}

void HexTableView::pasteToSelected()
{
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = model->selectedIndexes();
	const int bufSize = list.size();
	if (bufSize == 0) return;

	if (!isIndexListContinuous(list)) {
		QMessageBox::warning(0, "Warning!", "Select continuous area!");
		return;
	}
	offset_t first = hexModel->contentOffsetAt(list.at(0));
	if (first == INVALID_ADDR) return;

	TempBuffer temp;
	temp.init(bufSize);
	BYTE *buf = temp.getContent();
	if (!buf) return;

	bool isHex = this->hexModel->isHexView();
	size_t clipSize = ClipboardUtil::getFromClipboard(isHex, buf, bufSize);
	
	bool success = hexModel->myPeHndl->substBlock(first, clipSize, buf);
	if (success == false) {
		QMessageBox::warning(0, "Error!", "Modification in this area in  unacceptable!\n(Causes format corruption)");
		return;
	}
}

void HexTableView::fillSelected()
{
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = model->selectedIndexes();
	const int size = list.size();
	if (size == 0) return;

	if (!isIndexListContinuous(list)) {
		QMessageBox::warning(0,"Warning!", "Select continuous area!");
		return;
	}

	offset_t first = hexModel->contentOffsetAt(list.at(0));
	if (first == INVALID_ADDR) return;

	if (hexModel->myPeHndl->fillBlock(first, size, 0x90) == false) {
		QMessageBox::warning(0, "Error!", "Modification in this area in  unacceptable!\n(Causes format corruption)");
		return;
	}
}


void HexTableView::clearSelected()
{
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return;

	QModelIndexList list = model->selectedIndexes();
	const int size = list.size();
	if (size == 0) return;

	if (!isIndexListContinuous(list)) {
		QMessageBox::warning(0,"Warning!", "Select continuous area!");
		return;
	}
	offset_t first = hexModel->contentOffsetAt(list.at(0));
	if (first == INVALID_ADDR) return;

	if (hexModel->myPeHndl->fillBlock(first, size, 0) == false) {
		QMessageBox::warning(0, "Error!", "Modification in this area in  unacceptable!\n(Causes format corruption)");
		return;
	}
}

void HexTableView::setPageUp() 
{ 
	if (!hexModel) return; 
	hexModel->myPeHndl->advanceOffset(-(PREVIEW_SIZE));
}

void HexTableView::setPageDown()
{ 
	if (!hexModel) return; ;
	hexModel->myPeHndl->advanceOffset(PREVIEW_SIZE);
}

void HexTableView::undoOffset()
{
	if (!hexModel) return; 
	hexModel->myPeHndl->undoDisplayOffset();
}

void HexTableView::undoLastModification()
{
	if (!hexModel) return; 
	hexModel->myPeHndl->unModify();
}

void HexTableView::updateUndoAction()
{
	if (!hexModel) return; 
	if (hexModel->myPeHndl->prevOffsets.size() > 0) {
		this->back->setEnabled(true);
		this->back->setText("Back to: 0x" + QString::number(hexModel->myPeHndl->prevOffsets.top(), 16).toUpper());
	} else {
		this->back->setEnabled(false);
	}
}

void HexTableView::keyPressEvent(QKeyEvent *event) 
{
	bool isHex = (this->hexModel) ? this->hexModel->showHex : false;

	if (event->matches(QKeySequence::Undo)) {
		undoLastModification();
		return;
	} else if (event->matches(QKeySequence::Copy)) {
		copySelected();
		return;
	} else if (event->matches(QKeySequence::Paste)) {
		pasteToSelected();
		return;
	} else if (event->matches(QKeySequence::Delete)) {
		clearSelected();
		return;
	}
	ExtTableView::keyPressEvent(event);
}

void HexTableView::setVHdrVisible(bool isVisible)
{
	this->vHdr->setVisible(isVisible);
	isVHdrVisible = isVisible;
	adjustMinWidth();
}

void HexTableView::setModel(HexDumpModel *model)
{
	QTableView::setModel(model);
	this->vHdr->setHexModel(model);
	if (this->hexModel){
		disconnect(this->hexModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
		disconnect(this->hexModel, SIGNAL(scrollReset()), this, SLOT(onScrollReset()));

		disconnect(this->hexModel->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), this, SLOT(updateUndoAction()) );
		disconnect(this->hexModel->myPeHndl, SIGNAL(hovered()), this, SLOT(onResetRequested()) );
	}

	this->hexModel = model;
	connect(this->hexModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
	connect(this->hexModel, SIGNAL(scrollReset()), this, SLOT(onScrollReset()));

	connect(this->hexModel->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), this, SLOT(updateUndoAction()) );
	connect(this->hexModel->myPeHndl, SIGNAL(hovered()), this, SLOT(onResetRequested()) );
	adjustMinWidth();
}

void HexTableView::changeSettings(HexViewSettings &_settings)
{
	if (!hexModel) return;
	hexModel->changeSettings(_settings);
	initHeader();
	reset();
}

void HexTableView::onScrollReset()
{
	QScrollBar *scroll = this->verticalScrollBar();
	if (scroll) {
		scroll->setSliderPosition(0);
	}
}

```

`pe-bear/HexView.h`:

```h
#pragma once

#include <stack>
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <QStyledItemDelegate>

#include "REbear.h"
#include "base/PeHandlersManager.h"
#include "PEFileTreeModel.h"

#include "gui_base/ExtTableView.h"
#include "gui_base/ClipboardUtil.h"

#include "HexDumpModel.h"
#include "OffsetHeader.h"


class HexItemDelegate: public QStyledItemDelegate
{
	Q_OBJECT
public:
	HexItemDelegate(QObject* parent);

	virtual void setModelData(QWidget * editor, QAbstractItemModel * model,
		const QModelIndex & index) const override;

	QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,
		const QModelIndex &index) const override;
Q_SIGNALS:
	void dataSet(int col, int row) const;

private:
	void selectNextParentItem(const QModelIndex &index) const;

	QRegExpValidator validator;
};

//---

class HexTableView : public ExtTableView //TreeCpView
{
	Q_OBJECT
public:
	HexTableView(QWidget *parent);
	virtual QSize span(const QModelIndex &index) const { return QSize(0,0); }

	virtual void setModel(HexDumpModel *model);

	void setVHdrVisible(bool isVisible);
	virtual void keyPressEvent(QKeyEvent *event);

public slots:
	void onDataSet(int col, int row);
	void onScrollReset();
	void onModelUpdated() { reset(); }
	void changeSettings(HexViewSettings &settings);

	virtual void copySelected();
	virtual void pasteToSelected();
	virtual void clearSelected();
	virtual void fillSelected();

	void setPageUp();
	void setPageDown();
	void undoOffset();
	void undoLastModification();
	void updateUndoAction();

public slots:
	void onResetRequested() { reset(); }

protected:
	bool isIndexListContinuous(QModelIndexList &list);

	inline void adjustMinWidth();
	int hexColWidth;
	bool isVHdrVisible;
	void init();
	void initHeader();
	void initHeaderMenu();
	void initMenu();

	QAction *back, *undo;

	OffsetHeader* vHdr;
	QHeaderView *hHdr;
	HexDumpModel *hexModel;
	QScrollBar vScrollbar;
};


```

`pe-bear/OffsetHeader.cpp`:

```cpp
#include "OffsetHeader.h"

OffsetHeader::OffsetHeader(QWidget *parent)
	: QHeaderView(Qt::Vertical, parent),
	hexModel(NULL), selectedOffset(INVALID_ADDR), selectedType(Executable::RAW)
{
#if QT_VERSION >= 0x050000
	setSectionsClickable(true);
	setSectionsMovable(false);
#else
	setClickable(true);
	setMovable(false);
#endif
	setAutoFillBackground(true);
	this->setContentsMargins(QMargins(0, 0, 0, 0));
	setDefaultAlignment(Qt::AlignLeft | Qt::AlignVCenter);
	this->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(customMenuEvent(QPoint)) );
	
	this->followAction = new QAction("Follow the offset", this);
	connect(followAction, SIGNAL(triggered()), this, SLOT(followOffset()));

	this->copyAction = new QAction("Copy the offset", this);
	connect(copyAction, SIGNAL(triggered()), this, SLOT(copyOffset()));

	this->defaultMenu.addAction(followAction);
	this->defaultMenu.addAction(copyAction);
}

void OffsetHeader::customMenuEvent(QPoint p)
{
	if (!hexModel) return;
	
	if (selectedOffset == INVALID_ADDR) {
		followAction->setText("Invalid offset");
		followAction->setEnabled(false);
	
	} else {

		QString type;
		switch (selectedType) {
			case Executable::RAW :
				type = "Raw"; break;
			case Executable::RVA :
				type = "RVA"; break;
			case Executable::VA :
				type = "VA"; break;
		}
		followAction->setEnabled(true);
		followAction->setText("Follow " + type + ": " + QString::number(selectedOffset, 16).toUpper());
	}
	QPoint p2 = this->mapToGlobal(p); 
	this->defaultMenu.exec(p2);
}

void OffsetHeader::followOffset()
{
	if (hexModel == NULL || selectedOffset == INVALID_ADDR) return;
	bool isVirtual = (selectedType != Executable::RAW);
	uint64_t offset = selectedOffset;

	if (selectedType == Executable::VA) {
		offset = hexModel->m_PE->VaToRva(selectedOffset);
	}
	hexModel->myPeHndl->setDisplayed(isVirtual, offset);
}

void OffsetHeader::copyOffset()
{
	if (hexModel == NULL || selectedOffset == INVALID_ADDR) return;
	bool isVirtual = (selectedType != Executable::RAW);

	QMimeData *mimeData = new QMimeData;
	mimeData->setText(QString::number(selectedOffset, 16));
	QApplication::clipboard()->setMimeData(mimeData);
}

offset_t OffsetHeader::getSelectedOffset()
{
	offset_t offset = selectedOffset;
	if (selectedType == Executable::VA) {
		offset = hexModel->m_PE->VaToRva(selectedOffset);
	}
	return offset;
}

void OffsetHeader::mousePressEvent(QMouseEvent *event)
{
	QPoint p = event->pos();
	int indx = logicalIndexAt(p) ;

	if (this->hexModel) {
		QVariant data = this->hexModel->headerData(indx, Qt::Vertical, Qt::DisplayRole);
		bool isOk;
		offset_t offset = data.toString().toLongLong(&isOk, 16);
		if (isOk) {
			selectedType = this->hexModel->getAddrType();
			selectedOffset = offset;
		} else {
			selectedType = Executable::NOT_ADDR;
			selectedOffset = INVALID_ADDR;
		}
	}
	QHeaderView::mousePressEvent(event);
}


```

`pe-bear/OffsetHeader.h`:

```h
#pragma once

#include <stack>
#include <QtGlobal>
#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "REbear.h"
#include "base/PeHandlersManager.h"
#include "PEFileTreeModel.h"

#include "HexDumpModel.h"

class OffsetHeader : public QHeaderView
{
	Q_OBJECT
public:
	OffsetHeader(QWidget *parent);
	virtual void setHexModel(HexDumpModel *model) { this->hexModel = model; }

	QMenu defaultMenu;

public slots:
	virtual void customMenuEvent(QPoint p);
	void followOffset();
	void copyOffset();
	offset_t getSelectedOffset();

protected:
	void mousePressEvent(QMouseEvent *event);

	HexDumpModel *hexModel;
	QAction *followAction;
	QAction *copyAction;

	Executable::addr_type selectedType;
	offset_t selectedOffset;
};

```

`pe-bear/PEDockedWidget.cpp`:

```cpp
#include "PEDockedWidget.h"
#include "gui_base/AddressInputDialog.h"

PEDockedWidget::PEDockedWidget(PeHandler *peHndl, QWidget *parent)
	: PeViewItem(peHndl),  QDockWidget(parent),
	mainSplitter(Qt::Horizontal, this), tagBrowser(peHndl, this),
	cntntSplitter(NULL),
	contentPrev(NULL),
	tabWidget(NULL),
	toolBar(NULL)
{
	if (!myPeHndl || !m_PE) return;

	this->setWidget(&dockWindow);
	dockWindow.setCentralWidget(&mainSplitter);
	
	this->setWindowTitle(myPeHndl->getShortName());
	this->setAutoFillBackground(true);

	cntntSplitter = new QSplitter(Qt::Vertical, &mainSplitter);
	contentPrev = new ContentPreview(peHndl, cntntSplitter);
	tabWidget = new DetailsTab(peHndl, cntntSplitter);
	diagramModel = new SecDiagramModel(this->myPeHndl);
	diagram = new SelectableSecDiagram(diagramModel, true, cntntSplitter);

	tabWidget->setFocusPolicy(Qt::StrongFocus);
	tabWidget->setAutoFillBackground(true);
	setupActionsToolbar(cntntSplitter);

	cntntSplitter->addWidget(contentPrev);
	cntntSplitter->addWidget(tabWidget);

	mainSplitter.addWidget(cntntSplitter);
	mainSplitter.addWidget(diagram);
	setupDiagram();
	
	connect(this, SIGNAL(signalChangeHexViewSettings(HexViewSettings &)),
		contentPrev, SLOT(changeHexViewSettings(HexViewSettings &)) );
		
	connect(this, SIGNAL(signalChangeDisasmViewSettings(DisasmViewSettings &)), 
		&tabWidget->disasmView, SLOT(changeDisasmViewSettings(DisasmViewSettings &)) );
}

void PEDockedWidget::setScaledIcons()
{
	if (!toolBar) return;

	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	toolBar->setIconSize(QSize(iconDim, iconDim));
	toolBar->layout()->setSpacing(iconDim);

	//tool bar icons:
	QIcon previewIco = ViewSettings::makeScaledIcon(":/icons/arrow-right.ico", iconDim, iconDim);
	this->goToEntryPointA->setIcon(previewIco);
	
	QIcon goToRvaIco = ViewSettings::makeScaledIcon(":/icons/go_to_rva.ico", iconDim, iconDim);
	this->goToRvaAction->setIcon(goToRvaIco);
	
	QIcon goToRawIco = ViewSettings::makeScaledIcon(":/icons/go_to_raw.ico", iconDim, iconDim);
	this->goToRawAction->setIcon(goToRawIco);
	
	QIcon backIco = ViewSettings::makeScaledIcon(":/icons/undo.ico", iconDim, iconDim);
	backAction->setIcon(backIco);
	
	QIcon pinIco = ViewSettings::makeScaledIcon(":/icons/red_pin.ico", iconDim, iconDim);
	this->goToModifAction->setIcon(pinIco);
	
	QIcon umodIco = ViewSettings::makeScaledIcon(":/icons/unmodify.ico", iconDim, iconDim);
	this->unModifyAction->setIcon(umodIco);
	
	QIcon tagIco = ViewSettings::makeScaledIcon(":/icons/star.ico", iconDim, iconDim);
	this->tagsAction->setIcon(tagIco);
}

void PEDockedWidget::setupActionsToolbar(QSplitter* owner)
{
	if (!owner) return;
	
	this->toolBar = new QToolBar(&dockWindow);
	dockWindow.addToolBar(Qt::TopToolBarArea, toolBar);;
	
	//const Qt::ShortcutContext context = Qt::WidgetWithChildrenShortcut;
 	this->goToEntryPointA = new QAction(QString("&Preview Entry Point\n[CTRL + E]"), &dockWindow);
	//goToEntryPointA->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_E));
	//goToEntryPointA->setShortcutContext(context);
 	connect(goToEntryPointA, SIGNAL(triggered()), this, SLOT(goToEntryPoint()) );
 
 	this->goToRvaAction = new QAction(QString("&Go to RVA/VA\n[CTRL + R]"), &dockWindow);
	//goToRvaAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_R));
	//goToRvaAction->setShortcutContext(context);
 	connect(goToRvaAction, SIGNAL(triggered()), this, SLOT(goToRVA()) );
 	
 	this->goToRawAction = new QAction(QString("&Go to raw\n[CTRL + G]"), &dockWindow);
	//goToRawAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_G));
	//goToRawAction->setShortcutContext(context);
 	connect(goToRawAction, SIGNAL(triggered()), this, SLOT(goToOffset()) );
 
 	backAction = new QAction(QString("&Back to last visited offset\n[CTRL + B]"), &dockWindow);
	//backAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_B));
	//backAction->setShortcutContext(context);
 	connect(backAction, SIGNAL(triggered()), this, SLOT(undoOffset()) );
 
 	this->goToModifAction = new QAction(QString("&Go to last modification"), &dockWindow);
 	connect(goToModifAction, SIGNAL(triggered()), this, SLOT(goToLastModif()) );
 
 	this->unModifyAction = new QAction( QString("&Undo last modifications\n[CTRL + Z]"), &dockWindow);
	//unModifyAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_Z));
	//unModifyAction->setShortcutContext(context);
 	connect(unModifyAction, SIGNAL(triggered()), this, SLOT(unModify()) );
 
	this->tagsAction = new QAction(QString("&Tag"), &dockWindow);
	//tagsAction->setShortcut(QKeySequence(Qt::CTRL + ';'));
	//tagsAction->setShortcutContext(context);
 	connect(tagsAction, SIGNAL(triggered()), this, SLOT(browseTags()) );

	toolBar->addAction(goToEntryPointA);
	toolBar->addAction(goToRvaAction);
	toolBar->addAction(goToRawAction);
	toolBar->addAction(backAction);
	toolBar->addAction(goToModifAction);
	toolBar->addAction(unModifyAction);
	toolBar->addAction(tagsAction);

	const size_t marginSize = 5;
	toolBar->layout()->setContentsMargins(marginSize, marginSize, marginSize, marginSize);
	toolBar->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

	setScaledIcons();
	updateModifActions();
	updateNavigActions();

	connect(this->myPeHndl, SIGNAL(modified()), this, SLOT(updateModifActions()));
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), this, SLOT( updateNavigActions() ));
}

void PEDockedWidget::keyPressEvent(QKeyEvent *event)
{
	if (event->matches(QKeySequence::Undo)) {
		return myPeHndl->unModify();
	}
	
	switch (event->key()) {
		case Qt::Key_PageUp:
			myPeHndl->advanceOffset(- PREVIEW_SIZE);
			break;
		case Qt::Key_PageDown:
			myPeHndl->advanceOffset(PREVIEW_SIZE);
			break;
		case Qt::Key_Up:
			myPeHndl->advanceOffset(-1);
			break;
		case Qt::Key_Down:
			myPeHndl->advanceOffset(1);
			break;
		case Qt::Key_G:
			goToOffset();
			break;
		case Qt::Key_E:
			goToEntryPoint();
			break;
		case Qt::Key_R:
			goToRVA();
			break;
		case Qt::Key_B:
			myPeHndl->undoDisplayOffset();
			break;
	}
	QDockWidget::keyPressEvent(event);
}

void PEDockedWidget::updateNavigActions()
{
	bool hasModif = this->myPeHndl->prevOffsets.size() > 0;
	QString num;
	if (hasModif) {
		const offset_t off = this->myPeHndl->prevOffsets.top();
		num = ": " + QString::number(off, 16);
	}
	QString text = "&Back to last visited offset" + num + "\n[CTRL + B]";
	backAction->setText(text);
	backAction->setEnabled(hasModif);
}

void PEDockedWidget::updateModifActions()
{
	bool hasModif = this->myPeHndl->modifHndl.countOperations() ? true : false;
	goToModifAction->setEnabled(hasModif);
	unModifyAction->setEnabled(hasModif);
}

void PEDockedWidget::setupDiagram()
{
	this->diagram->setBackgroundColor(Qt::black);
	this->diagram->contourColor = Qt::lightGray;
	this->diagram->setMaximumWidth(this->diagram->minimumSizeHint().width());
	this->diagram->setMinimumWidth(this->diagram->minimumSizeHint().width());
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), 
		this->diagramModel, SLOT(setSelectedArea(offset_t, bufsize_t)) );
}


void PEDockedWidget::goToLastModif()
{
	offset_t modS = this->myPeHndl->modifHndl.getLastModifiedOffset();
	if (modS == INVALID_ADDR) {
		QMessageBox::warning(0, "Cannot go", "No modifications!");
		return;
	}

	myPeHndl->setDisplayed(false, modS);
}

void PEDockedWidget::goToEntryPoint()
{
	if (!m_PE) return; 

	offset_t raw =  0;
	try {
		raw = m_PE->rvaToRaw(m_PE->getEntryPoint());
	} catch (CustomException e) {
		QMessageBox::warning(0,"Warning!", "Wrong RVA supplied!"+ QString::fromStdString(e.what()));
		return;
	}
	myPeHndl->setDisplayed(false, raw);
}

void PEDockedWidget::goToOffset()
{
	goToAddress(true);
}

void PEDockedWidget::goToRVA()
{
	goToAddress(false);
}

void PEDockedWidget::goToAddress(bool isRaw)
{
	if (!m_PE) return; 

	long long number = myPeHndl->displayedOffset;
	if (!isRaw) {
		try {
			number = m_PE->rawToRva(number);
		} catch (CustomException e) {
			number = 0;
		}
	}
	AddressInputDialog dialog(m_PE, isRaw, this->addrColors, this);
	dialog.setDefaultValue(number);

	int dialogRet = dialog.exec();
	bool isOk = false;
	number = dialog.getNumValue(NULL);
	
	if (dialogRet != QDialog::Accepted) {
		return;
	}
	//----
	Executable::addr_type aT = dialog.getAddrType();
	try {
		offset_t raw = m_PE->toRaw(number, aT, true);
		if (raw == INVALID_ADDR) {
			QMessageBox::warning(0, "Warning!", "Wrong address supplied!");
			return;
		}
		myPeHndl->setDisplayed(false, raw);

	} catch (CustomException e) {
		QMessageBox::warning(0,"Warning!", "Wrong address supplied: "+ QString::fromStdString(e.what()));
	}
}

//--------------------------------------------------------------------------------------

SectionMenu::SectionMenu(MainSettings &settings, QWidget *parent) 
	: QMenu(parent), 
	mainSettings(settings), peHndl(NULL), selectedSection(NULL)
{
	createActions();
}

void SectionMenu::createActions()
{
	this->dumpSelSecAction = new QAction("&Save the content as...", this);
	connect(this->dumpSelSecAction, SIGNAL(triggered()), this, SLOT(dumpSelectedSection()) );

	QIcon clearContentIco(":/icons/eraser.ico");
	this->clearSelSecAction = new QAction(clearContentIco, "&Clear the content", this);
	connect(this->clearSelSecAction, SIGNAL(triggered()), this, SLOT(clearSelectedSection()) );

	this->loadSelSecAction = new QAction("Substitute the content", this);
	connect(this->loadSelSecAction, SIGNAL(triggered()), this, SLOT(loadSelectedSection()) );

	addAction(this->dumpSelSecAction);
	addAction(this->loadSelSecAction);
	addAction(this->clearSelSecAction);
	//addAction(this->searchSigAction);
}

void SectionMenu::sectionSelected(PeHandler *pe, SectionHdrWrapper *sec)
{
	this->peHndl = pe;
	this->selectedSection = sec;
	bool isEnabled = sec != NULL ? true : false;
	if (!pe) isEnabled = false;

	this->setEnabled(isEnabled);
	this->setTitle("No section selected");

	if (!isEnabled) return;

	this->setTitle("Section: [" + sec->mappedName + "]");
}

void SectionMenu::dumpSelectedSection()
{
	if (!peHndl) return;
	PEFile *pe = peHndl->getPe();
	if (!pe) return;
	if (!selectedSection) return;

	QString outDir = mainSettings.dirDump;
	if (outDir == "") outDir = peHndl->getDirPath();

	QString defaultPath = outDir + QDir::separator() + peHndl->getShortName() + "[" + selectedSection->mappedName + "]";
	QString path = QFileDialog::getSaveFileName(this, "Save as...", defaultPath);
	if (path.size() == 0) return;

	if (pe->dumpSection(selectedSection, path)) {
		QMessageBox::information(this, "Done!", "Dumped section: "+ selectedSection->mappedName +"\ninto: " + path);
		return;
	}
	QMessageBox::warning(this, "Error", "Dumping section failed!");
}

void SectionMenu::clearSelectedSection()
{
	if (!peHndl) return;
	PEFile *pe = peHndl->getPe();
	if (!pe) return;

	if (!selectedSection) return;

	int answer = QMessageBox::warning(0, "Clearing section", "Do you really want to clear content of " + selectedSection->mappedName + "?", 
		QMessageBox::Yes | QMessageBox::No);

	if (answer != QMessageBox::Yes) return;

	const offset_t secOffset = selectedSection->getContentOffset(Executable::RAW, true);
	const bufsize_t secSize = selectedSection->getContentSize(Executable::RAW, true);

	peHndl->backupModification(secOffset, secSize);
	bool isOk = pe->clearContent(selectedSection);
	if (isOk) {
		peHndl->setDisplayed(false, secOffset, secSize);
		peHndl->setBlockModified(secOffset, secSize);
	}
	if (!isOk) {
		QMessageBox::warning(this, "Failed", "Cannot clear the section content");
	}
}

void SectionMenu::loadSelectedSection()
{
	if (!peHndl) return;
	PEFile *pe = peHndl->getPe();
	if (!pe) return;

	if (!selectedSection) return;

	QString path = QFileDialog::getOpenFileName(this, "Open", peHndl->getFullName(), "*");
	if (path.length() == 0) return;

	QFile fIn(path);
	if (fIn.open(QFile::ReadOnly) == false) {
		QMessageBox::warning(this,"Failed", "Cannot open file");
		return;
	}

	size_t loaded = peHndl->loadSectionContent(selectedSection, fIn);
	fIn.close();

	QMessageBox::information(this, "Loaded", "Loaded from file: 0x" + QString::number(loaded, 16) + " bytes");
}

```

`pe-bear/PEDockedWidget.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "gui_base/PeGuiItem.h"

#include "gui/ContentPreview.h"
#include "gui/DetailsTab.h"
#include "gui/windows/OffsetsBrowseWindow.h"


class PEDockedWidget : public QDockWidget, public PeViewItem
{
    Q_OBJECT
public:
	PEDockedWidget(PeHandler *peHndl, QWidget *parent);
	~PEDockedWidget() { delete diagramModel; }
	
Q_SIGNALS:
	void signalChangeHexViewSettings(HexViewSettings &);
	void signalChangeDisasmViewSettings(DisasmViewSettings &);

public slots:
	void goToEntryPoint();
	void goToRVA();
	void goToOffset();
	void goToLastModif();
	
	void undoOffset() { if (myPeHndl) myPeHndl->undoDisplayOffset(); }
	void unModify() { if (myPeHndl) myPeHndl->unModify(); }
	
	void pageUp() { if (myPeHndl) myPeHndl->advanceOffset(-PREVIEW_SIZE); }
	void pageDown() { if (myPeHndl) myPeHndl->advanceOffset(PREVIEW_SIZE); }
	
	void offsetUp(){ if (myPeHndl) myPeHndl->advanceOffset(-1); }
	void offsetDown(){ if (myPeHndl) myPeHndl->advanceOffset(1); }
	
	void offsetPrev(){ if (myPeHndl) myPeHndl->undoDisplayOffset(); }
	
	void browseTags()
	{
		tagBrowser.show();
		tagBrowser.raise();
	}
	
	void updateModifActions();
	void updateNavigActions();

	void changeHexViewSettings(HexViewSettings &_settings)
	{
		emit signalChangeHexViewSettings(_settings);
	}
	
	void changeDisasmViewSettings(DisasmViewSettings &_settings)
	{
		emit signalChangeDisasmViewSettings(_settings);
	}

	void refreshFonts()
	{
		this->setFont(QApplication::font());
		setScaledIcons();
		
		// adjust side diagram:
		this->diagram->setMaximumWidth(this->diagram->minimumSizeHint().width());
		this->diagram->setMinimumWidth(this->diagram->minimumSizeHint().width());
		this->tabWidget->onGlobalFontChanged();
	}
	
protected:
	void keyPressEvent(QKeyEvent *event);
	void setScaledIcons();
	void goToAddress(bool isRaw);

	void setupDiagram();
	void setupActionsToolbar(QSplitter* owner);
	
	QMainWindow dockWindow;
	QToolBar *toolBar;

	//toolbar actions:
	QAction *goToEntryPointA, *goToRvaAction, *goToRawAction,
		*goToModifAction, *unModifyAction, *tagsAction, *backAction;

	OffsetsBrowseWindow tagBrowser;
	QSplitter mainSplitter;
	ContentPreview *contentPrev;
	DetailsTab *tabWidget;
	QSplitter *cntntSplitter;
	
	SecDiagramModel* diagramModel;
	SelectableSecDiagram* diagram;
};

//--------------------------------------------------------------------------------------

class SectionMenu : public QMenu
{
	Q_OBJECT
public:
	SectionMenu(MainSettings &settings, QWidget *parent = 0);

public slots:
	void sectionSelected(PeHandler *pe, SectionHdrWrapper *sec);

	void dumpSelectedSection();
	void clearSelectedSection();
	void loadSelectedSection();

protected:
	void createActions();

	MainSettings &mainSettings;
	PeHandler *peHndl;
	SectionHdrWrapper* selectedSection;
	QAction *dumpSecAction, *dumpSelSecAction, *clearSelSecAction, *loadSelSecAction, *searchSigAction;
};

```

`pe-bear/PEFileTreeModel.cpp`:

```cpp
#include "PEFileTreeModel.h"
#include "ViewSettings.h"

#define MAX_COL 1
///------------------------

PEFileTreeItem::PEFileTreeItem(PeHandler *peHndl, level_t level, enum PEFileFieldId role, PEFileTreeItem *parent)
	: PeTreeItem(peHndl, role, FIELD_NONE, parent), role(PEFILE_NONE), level(DESC),
	entryPointItem(NULL)
{
	m_parentItem = parent;
	this->level = level;
	this->role = role;

	if (!this->myPeHndl || !m_PE) {
		this->level = DESC;
		if (role != PEFILE_ROOT) this->role = PEFILE_NONE;
		return;
	}

	if (role == PEFILE_MAIN) {
		createTree();
		connect(this->myPeHndl, SIGNAL(modified()), this, SLOT(onModified()));
	}
}

PEFileTreeItem* PEFileTreeItem::findNodeByRole(int my_role)
{
	PEFileTreeItem *searchedNode = NULL;
	for (auto itr = this->m_childItems.begin(); itr != this->m_childItems.end(); ++itr) {
		PEFileTreeItem *node = dynamic_cast<PEFileTreeItem*>(*itr);
		if (!node) continue;

		if (node->role == my_role) {
			searchedNode = node;
			break;
		}
	}
	return searchedNode;
}

void PEFileTreeItem::deleteOverlayNode()
{
	PEFileTreeItem *overlayNode = findNodeByRole(PEFILE_OVERLAY);
	if (overlayNode) {
		this->detachChild(overlayNode);
		delete overlayNode;
	}
}

void PEFileTreeItem::appendOverlayNode()
{
	PEFileTreeItem *overlayNode = findNodeByRole(PEFILE_OVERLAY);
	if (overlayNode) return;

	overlayNode = new PEFileTreeItem(this->myPeHndl, PEFileTreeItem::DESC, PEFILE_OVERLAY);
	appendChild(overlayNode);
}

void PEFileTreeItem::createTree()
{
	this->fileName = this->myPeHndl->getShortName();

	for (int indx = PEFILE_IMG_DOS_HDR; indx < PEFILE_FIELD_COUNTER; indx++) {
		enum PEFileFieldId role = PEFileFieldId(indx);

		if (role == PEFILE_OVERLAY) {
			if (getOverlaySize()) {
				appendOverlayNode();
			}
			continue;
		}

		if (role == PEFILE_SECTIONS) {
			PEFileSectionsTreeItem *secRoot = new PEFileSectionsTreeItem(this->myPeHndl, PEFileTreeItem::DESC);
			appendChild(secRoot);
			connect(this->myPeHndl, SIGNAL(secHeadersModified()), secRoot, SLOT(onSectionNumChanged()));
		}
		else if (role == PEFILE_IMG_NT_HDRS)
			appendChild(new PEFileNTHdrTreeItem(this->myPeHndl, PEFileTreeItem::DESC));
		else {
			appendChild(new PEFileTreeItem(this->myPeHndl, PEFileTreeItem::DESC, role));
		}
	}
	if (entryPointItem) {
		entryPointItem->setParent(NULL);
		delete entryPointItem;
	}
	entryPointItem = new PEFileEntryPointItem(this->myPeHndl, this, NULL);
	if (!this->attachIfBelongs(entryPointItem)) {
		entryPointItem->setParent(this);
	}
}

bool PEFileTreeItem::attachIfBelongs(PEFileTreeItem *item)
{
	if (!item || !m_PE) return false;
	if (this == item) return false;

	// first try to attach the element to children:
	for (QList<TreeItem*>::iterator itr = m_childItems.begin(); itr != m_childItems.end(); ++itr) {
		PEFileTreeItem *child = dynamic_cast<PEFileTreeItem*>(*itr);
		if (!child) continue;

		if (child->attachIfBelongs(item)) {
			return true;
		}
	}

	// if failed, try with the current element:
	const offset_t from = this->getContentOffset();
	if (from == INVALID_ADDR) {
		return false;
	}
	const bufsize_t size = this->getContentSize();
	const offset_t to = from + size;

	const offset_t itemFrom = item->getContentOffset();
	if (itemFrom >= from && itemFrom < to) {
		//std::cout << "> Attached. ItemFrom: " << std::hex << itemFrom << " Searched in role: " << this->role << " bounds: " << from << " to " << to << " ( size " << size << " )" << std::endl;
		this->appendChild(item);
		return true;
	}
	return false;
}

offset_t PEFileTreeItem::getContentOffset() const
{
	if (!this->myPeHndl) return 0;
	PEFile *m_PE = this->myPeHndl->getPe();

	if (!m_PE->getContent()) return 0;

	switch (role) {
		case PEFILE_MAIN :
		{
			return 0;
		}
		case PEFILE_IMG_DOS_HDR :
			return 0;
		case PEFILE_DOS_STUB :
			return sizeof(IMAGE_DOS_HEADER);
		case PEFILE_IMG_NT_HDRS : 
			return m_PE->peNtHdrOffset();
		case PEFILE_SEC_HDRS :
			return m_PE->secHdrsOffset();
		case PEFILE_OVERLAY :
			return m_PE->getLastMapped(Executable::RAW);
	}
	return 0;
}

bufsize_t PEFileTreeItem::getContentSize() const
{
	if (!this->myPeHndl) return 0;
	PEFile *m_PE = this->myPeHndl->getPe();

	if (!m_PE || !m_PE->getContent()) return 0;
	
	const bufsize_t totalSize = m_PE->getRawSize();
	const offset_t offset = getContentOffset();
	
	if (((offset_t)totalSize) <= offset) return 0;

	switch (role) {
		case PEFILE_MAIN :
		{
			return totalSize;
		}
		case PEFILE_DOS_STUB :
		{
			const offset_t ntHdrsOffset = m_PE->peNtHdrOffset();
			if (ntHdrsOffset < offset) {
				return 0;
			}
			return ntHdrsOffset - offset;
		}
		case PEFILE_IMG_DOS_HDR :
			return sizeof(IMAGE_DOS_HEADER);
		case PEFILE_IMG_NT_HDRS :
			return  m_PE->peNtHeadersSize();
		case PEFILE_SEC_HDRS:
		{
			return m_PE->secHdrsEndOffset() - offset;
		}
		case PEFILE_OVERLAY:
			return getOverlaySize();
	}
	return totalSize;
}

bufsize_t PEFileTreeItem::getOverlaySize() const
{
	if (!this->myPeHndl) return 0;
	PEFile *m_PE = this->myPeHndl->getPe();

	if (!m_PE || !m_PE->getContent()) return 0;
	
	if (m_PE->getRawSize() > m_PE->getLastMapped(Executable::RAW)) {
		return m_PE->getRawSize() - m_PE->getLastMapped(Executable::RAW);
	}
	return 0;
}

void PEFileTreeItem::onModified()
{
	if (this->entryPointItem == NULL) {
		//printf("EP Item is NULL, recreating...\n");
		entryPointItem = new PEFileEntryPointItem(this->myPeHndl, this, this);
	}

	entryPointItem->savedEP = this->m_PE->getEntryPoint();
	if (!this->attachIfBelongs(entryPointItem)) {
		entryPointItem->setParent(this);
	}
	if (getOverlaySize()) {
		appendOverlayNode();
	} else {
		deleteOverlayNode(); // the PE has no overlay
	}
	emit needReset();
}

int PEFileTreeItem::columnCount() const
{
	return MAX_COL;
}

QVariant PEFileTreeItem::background(int column) const
{
	if (!this->myPeHndl) return QVariant();
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return QVariant();

	if (role == PEFILE_MAIN && m_PE->isTruncated()) {
		QColor color(ERR_COLOR);
		color.setAlpha(100);
		return color;
	}
	return QVariant();
}

QVariant PEFileTreeItem::foreground(int column) const
{
	int fieldIndx = column;
	return QVariant();
}

QVariant PEFileTreeItem::toolTip(int column) const
{
	if (!this->myPeHndl) return QVariant();
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return QVariant();

	int fieldIndx = column;
	if (this->level == DESC) {
		if (role == PEFILE_MAIN) {
			QString truncated = m_PE->isTruncated() ? "\n(truncated)" : "";
			QString resized = m_PE->isResized() ? "\n(resized)" : "";
			return myPeHndl->getFullName() + truncated + resized;
		}
		if (role == PEFILE_OVERLAY) {
			return "Overlay size: 0x" + QString::number(this->getOverlaySize(), 16);
		}
	}
	return data(column);
}

QVariant PEFileTreeItem::decoration(int column) const 
{
	if (!this->myPeHndl) return QVariant();

	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return QVariant();

	if (role == PEFILE_MAIN) {
		if (this->myPeHndl->isPacked()) {
			return ViewSettings::getScaledPixmap(":/icons/Locked.ico");
		}
		
		if (m_PE->getBitMode() == Executable::BITS_64) {
			if (myPeHndl->isPeValid()) {
				return ViewSettings::getScaledPixmap(":/icons/app64.ico");
			}
			else {
				return ViewSettings::getScaledPixmap(":/icons/app64_w.ico");
			}
		} else {
			if (myPeHndl->isPeValid()) {
				return ViewSettings::getScaledPixmap(":/icons/app32.ico");
			}
			else {
				return ViewSettings::getScaledPixmap(":/icons/app32_w.ico");
			}
		}
	}
	if (role == PEFILE_DOS_STUB) {
		return ViewSettings::getScaledPixmap(":/icons/dos.ico");
	}
	return ViewSettings::getScaledPixmap(":/icons/hdr.ico");
}

QVariant PEFileTreeItem::font(int column) const
{
	if (role != PEFILE_MAIN) {
		return QVariant();
	}
	QFont f = QApplication::font();
	f.setBold(true);
	if (this->myPeHndl && this->myPeHndl->isFileOnDiskChanged())  {
		f.setItalic(true);
	}
	return f;
}

BYTE* PEFileTreeItem::getContent()
{
	if (!this->myPeHndl) return NULL;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return NULL;

	offset_t offset = getContentOffset();
	bufsize_t size = getContentSize();
	
	BYTE *content = m_PE->getContentAt(offset, size);
	return content;
}

QVariant PEFileTreeItem::data(int column) const
{
	if (!this->myPeHndl) return QVariant();
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return QVariant();

	int fieldIndx = column;
	if (fieldIndx != 0) return QVariant();

	if (this->level == DESC) {
		switch (role) {
			case PEFILE_MAIN :
			{
				bool isResized = m_PE->isResized();
				if (this->myPeHndl->isPEModified() || isResized) 
					return fileName + "*";
				return fileName;
			}
			case PEFILE_IMG_DOS_HDR: return "DOS Header";
			case PEFILE_DOS_STUB: return "DOS stub";
			case PEFILE_IMG_NT_HDRS: return "NT Headers";
			case PEFILE_SEC_HDRS: return "Section Headers";
			case PEFILE_SECTIONS: return "Sections";
			case PEFILE_OVERLAY: return "Overlay";
		}
		return QVariant();
	}
	return QVariant();
}

//-------------------

PEFileSectionsTreeItem::PEFileSectionsTreeItem(PeHandler *peHndl, level_t level, int secIndx, PEFileTreeItem *parent)
	: PEFileTreeItem(peHndl, level, role = PEFILE_SECTIONS, parent)
{
	SectionHdrWrapper* entrySec = m_PE->getEntrySection();
	this->secIndx = secIndx;
	if (this->level == DESC) {
		this->secIndx = (-1);
		//create subrecords
		int secNum = this->m_PE->getSectionsCount();
		for (int i = 0; i < secNum; i++) {
			PEFileSectionsTreeItem *sec = new PEFileSectionsTreeItem(this->myPeHndl, DETAILS, i, this);
			this->appendChild(sec);
		}
	}
}

void PEFileSectionsTreeItem::onSectionNumChanged()
{
	size_t oldNum = this->m_childItems.size();
	if (oldNum == this->m_PE->getSectionsCount()) return;
	int diff = 0;
	bool add = true;

	if (oldNum < this->m_PE->getSectionsCount()) {
		add = true;
		diff = this->m_PE->getSectionsCount() - oldNum;
	} else {
		add = false;
		diff = oldNum - this->m_PE->getSectionsCount();
	}

	for (int i = 0; i < diff; i++) {
		if (add) {
			PEFileSectionsTreeItem *sec = new PEFileSectionsTreeItem(this->myPeHndl, DETAILS, oldNum + i, this);
			this->appendChild(sec);
		} else {
			TreeItem *child = this->child((oldNum - 1) - i);
			this->detachChild(child);
			delete child;
		}
	}
}

SectionHdrWrapper* PEFileSectionsTreeItem::getMySection() const
{
	if (!m_PE) return NULL;
	return m_PE->getSecHdr(secIndx);
}

QVariant PEFileSectionsTreeItem::data(int column) const
{
	if (!m_PE) return QVariant();
	if (column != 0) return QVariant();

	if (this->level == DESC) return ("Sections");
	SectionHdrWrapper *sec = getMySection();
	if (sec == NULL) return QVariant();
	return sec->mappedName;
}

QVariant PEFileSectionsTreeItem::background(int column) const
{
	return QVariant();
}

QVariant PEFileSectionsTreeItem::decoration(int column) const
{
	SectionHdrWrapper *sec = getMySection();
	if (sec == NULL) return QVariant();
	if (!m_PE) return QVariant();

	if (this->level == DESC) return QVariant();
	
	if (sec == m_PE->getEntrySection() && sec != NULL) {
		return ViewSettings::getScaledPixmap(":/icons/EP.ico");
	}
	return ViewSettings::getScaledPixmap(":/icons/section.ico");
}

offset_t PEFileSectionsTreeItem::getContentOffset() const
{
	if (!m_PE) return 0;
	SectionHdrWrapper *sec = getMySection();

	if (sec == NULL) {
		if (m_PE->getSectionsCount() == 0)
			return 0;

		SectionHdrWrapper *firstSec = m_PE->getSecHdr(0); //TODO: get first Section by Raw Address!
		if (!firstSec)
			return 0;

		return firstSec->getRawPtr();
	}
	return sec->getRawPtr();
}

BYTE* PEFileSectionsTreeItem::getContent()
{
	if (!m_PE) return NULL;
	BYTE *content = m_PE->getContent();
	if (!content) return NULL;

	SectionHdrWrapper *sec = getMySection();
	if (!sec) {
		if (m_PE->getSectionsCount() == 0) return NULL;
		sec = m_PE->getSecHdr(0); //TODO: get first Section by Raw Address!
	}
	if (!sec) return NULL;
	return m_PE->getContentAt(sec->getRawPtr(), 1);;
}

bufsize_t PEFileSectionsTreeItem::getContentSize() const
{
	if (!m_PE) return 0;
	SectionHdrWrapper *sec = getMySection();
	if (sec) {
		return sec->getContentSize(Executable::RAW, true);
	}
	if (m_PE->getSectionsCount() == 0) return 0;
	SectionHdrWrapper *firstSec = m_PE->getSecHdr(0); //TODO: get first Section by Raw Address!
	if (!firstSec) return 0;
	
	BYTE *secContent = m_PE->getSecContent(firstSec);
	if (!secContent) {
		return 0;
	}
	offset_t contentOffset = m_PE->getOffset(secContent);
	if (contentOffset == INVALID_ADDR) {
		return 0;
	}
	const offset_t totalSize = m_PE->getRawSize();
	return totalSize - contentOffset;
}

//-----------------------------------------------------------------------------

PEFileEntryPointItem::PEFileEntryPointItem(PeHandler *peHndl, PEFileTreeItem *mainIt, PEFileTreeItem *parent)
	 : PEFileTreeItem(peHndl, level, role = PEFILE_NONE, parent), mainItem(mainIt)
{
	PEFile *pe = this->myPeHndl->getPe();
	if (!pe) return;
	this->savedEP = pe->getEntryPoint();
}

PEFileEntryPointItem::~PEFileEntryPointItem()
{
	if (mainItem) mainItem->setEntryPointItem(NULL);
}

QVariant PEFileEntryPointItem::decoration(int column) const
{
	PEFile *pe = this->myPeHndl->getPe();
	if (!pe) return QVariant();
	
	return ViewSettings::getScaledPixmap(":/icons/arrow-right.ico");
}

QVariant PEFileEntryPointItem::data(int column) const
{
	if (!this->myPeHndl) return QVariant();
	PEFile *pe = this->myPeHndl->getPe();
	if (!pe) return QVariant();
	
	offset_t offset = getContentOffset();
	if (offset == INVALID_ADDR) {
		return "Invalid EP";
	}
	return "EP = " + QString::number(offset, 16).toUpper();
}

BYTE* PEFileEntryPointItem::getContent()
{
	if (!this->myPeHndl) return NULL;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return NULL;

	return m_PE->getContentAt(getContentOffset(), 1);
}

offset_t PEFileEntryPointItem::getContentOffset() const
{
	if (!this->myPeHndl) return INVALID_ADDR;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return INVALID_ADDR;

	offset_t offset = m_PE->getEntryPoint();
	try{
		offset = m_PE->rvaToRaw(offset);
	} catch (CustomException(e)) {
		offset = INVALID_ADDR;
	}
	return offset;
}

bufsize_t PEFileEntryPointItem::getContentSize() const
{
	if (!m_PE) return 0;
	BYTE *content = m_PE->getContent();
	if (!content) return 0;
	
	offset_t totalSize = m_PE->getRawSize();
	offset_t offset = getContentOffset();
	if (offset == INVALID_ADDR) return 0;
	if (offset >= totalSize) return 0;

	bufsize_t dif = bufsize_t(totalSize - offset);
	return dif;
}
//-----------------------------------------

PEFileNTHdrTreeItem::PEFileNTHdrTreeItem(PeHandler *peHndl, level_t level, enum PEFileNTHdrFieldId subrole, PEFileTreeItem *parent)
	: PEFileTreeItem(peHndl, level, role = PEFILE_IMG_NT_HDRS, parent)
{
	this->subrole = subrole;
	
	//this->icon = QPixmap (":/icons/hdr.ico");
	if (this->level == DESC) {
		this->subrole = PEFILE_NTHDR_NONE;
		//create subrecords
		for (int i = PEFILE_NTHDR_SIGN; i < PEFILE_NTHDR_COUNTER; i++) {
			this->appendChild(new PEFileNTHdrTreeItem(this->myPeHndl, DETAILS,  PEFileNTHdrFieldId(i), this));
		}
	}
}

QVariant PEFileNTHdrTreeItem::data(int column) const
{
	if (!this->myPeHndl) return QVariant();
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return QVariant();

	if (column != 0) return QVariant();

	if (this->level == DESC) return ("NT Headers");
	switch (subrole) {
		case PEFILE_NTHDR_SIGN : return "Signature";
		case PEFILE_NTHDR_FILEHDR : return "File Header";
		case PEFILE_NTHDR_OPTHDR : return "Optional Header";
	}
	return QVariant();
}

offset_t PEFileNTHdrTreeItem::getContentOffset() const
{
	if (!this->myPeHndl) return 0;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return 0;

	if (!m_PE->getContent()) return 0;
	BYTE *content = m_PE->getContent();

	offset_t offset = m_PE->peNtHdrOffset();

	if (this->level == DESC) 
		return offset;

	switch (subrole) {
		case PEFILE_NTHDR_SIGN :
			return offset;
		case PEFILE_NTHDR_FILEHDR :
			return offset + sizeof(pe::S_NT);
		case PEFILE_NTHDR_OPTHDR :
			return offset + sizeof(pe::S_NT) + sizeof(IMAGE_FILE_HEADER);
	}
	
	return offset;
}

bufsize_t PEFileNTHdrTreeItem::getContentSize() const
{
	if (!this->myPeHndl) return 0;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return 0;

	BYTE *content = m_PE->getContent();
	offset_t totalSize = m_PE->getRawSize();

	offset_t offset = m_PE->peNtHdrOffset();
	bufsize_t contentSize = bufsize_t(m_PE->secHdrsOffset() - offset);

	if (this->level == DESC) 
		return contentSize;
	
	switch (subrole) {
		case PEFILE_NTHDR_SIGN :
			return sizeof(pe::S_NT);

		case PEFILE_NTHDR_FILEHDR :
			return sizeof(IMAGE_FILE_HEADER);

		case PEFILE_NTHDR_OPTHDR :
			return contentSize - (sizeof(pe::S_NT) + sizeof(IMAGE_FILE_HEADER));
	}

	return contentSize;
}

BYTE* PEFileNTHdrTreeItem::getContent()
{
	if (!this->myPeHndl) return NULL;
	PEFile *m_PE = this->myPeHndl->getPe();
	if (!m_PE) return NULL;

	const offset_t offset = this->getContentOffset();
	return m_PE->getContentAt(offset, 1);
}

//-----------------------------------------------------------------------------
PEFileTreeModel::PEFileTreeModel(QObject *parent)
	: QAbstractItemModel(parent)
{
	root = new PEFileTreeItem(NULL, PEFileTreeItem::DESC, PEFILE_ROOT);
}

PEFileTreeModel::~PEFileTreeModel()
{
	delete root; root = NULL;
	loadedPeFiles.clear();
}

void PEFileTreeModel::refreshView()
{
	this->reset();
	emit modelUpdated();
}

QModelIndex PEFileTreeModel::addHandler(PeHandler *peHndl)
{
	if (!peHndl) return QModelIndex();
	PEFile *pe = peHndl->getPe();
	if (!pe) return QModelIndex();

	PEFileTreeItem *item = new PEFileTreeItem(peHndl, PEFileTreeItem::DESC, PEFILE_MAIN);
	connect(item, SIGNAL(needReset()), this, SLOT(refreshView()));
	connect(peHndl, SIGNAL(secHeadersModified()), this, SLOT(refreshView()));

	root->appendChild(item);
	loadedPeFiles[pe] = item;
	this->reset();
	emit modelUpdated();

	return createIndex(item->row(), 0, item);
}

void PEFileTreeModel::deleteHandler(PeHandler *peHndl)
{
	if (!peHndl) return;
	PEFile *pe = peHndl->getPe();
	if (!pe) return;

	PEFileTreeItem *item = loadedPeFiles[pe];
	if (!item) return;

	disconnect(item, SIGNAL(needReset()), this, SLOT(refreshView()));

	loadedPeFiles.erase(pe);
	
	TreeItem *parent = item->m_parentItem;
	if (parent) {
		parent->detachChild(item);
	}
	delete item;
	this->reset();
	emit modelUpdated();
}

int PEFileTreeModel::rowCount(const QModelIndex &parent) const
{
	if (parent.column() > 0)
		return 0;

	PEFileTreeItem *parentItem = root;
	if (parent.isValid())
		parentItem = static_cast<PEFileTreeItem*>(parent.internalPointer());

	if (!parentItem)
		return 0;
	return parentItem->childCount();
}

int PEFileTreeModel::columnCount(const QModelIndex &parent) const
{
	if (!root) return 0;

	if (parent.isValid())
		return static_cast<PEFileTreeItem*>(parent.internalPointer())->columnCount();

	return root->columnCount();
}

QVariant PEFileTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid())
		return QVariant();

	PEFileTreeItem *item = static_cast<PEFileTreeItem*>(index.internalPointer());
	if (item == NULL) return QVariant();
	switch (role) {
		case Qt::BackgroundColorRole : return item->background(index.column());
		case Qt::SizeHintRole :
		{
			return QVariant(); //get default
		}
		case Qt::ForegroundRole : return item->foreground(index.column());
		case Qt::DisplayRole : return item->data(index.column());
		case Qt::ToolTipRole : return item->toolTip(index.column());
		case Qt::WhatsThisRole : return item->whatsThis(index.column());
		case Qt::DecorationRole : return item->decoration(index.column());
		case Qt::FontRole : return item->font(index.column());
	}
	return QVariant();
}

QVariant PEFileTreeModel::headerData(int section, Qt::Orientation /* orientation */, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();

	return QVariant();
}

Qt::ItemFlags PEFileTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return 0;
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

QModelIndex PEFileTreeModel::index(int row, int column, const QModelIndex &parent) const
{
	if (!hasIndex(row, column, parent))
		return QModelIndex();

	TreeItem *parentItem = root;
	if (parent.isValid()) {
		parentItem = static_cast<PEFileTreeItem*>(parent.internalPointer());
	}
	TreeItem* childItem = parentItem->child(row);
	if (childItem)
		return createIndex(row, column, childItem);
	return QModelIndex();
}

QModelIndex PEFileTreeModel::parent(const QModelIndex &index) const
{
	if (!index.isValid())
		return QModelIndex();

	PEFileTreeItem *childItem = static_cast<PEFileTreeItem*>(index.internalPointer());
	if (childItem == NULL)
		return QModelIndex();

	TreeItem* parentItem = childItem->m_parentItem;

	if (!parentItem || parentItem == root)
		return QModelIndex();
	if (parentItem->row() == (-1)) {
		//printf("Invalid row value\n");
		return QModelIndex();
	}
	return createIndex(parentItem->row(), 0, parentItem);
}
//-----------------------------------------------------------------

PEStructureView::PEStructureView(QWidget *parent)
	: TreeCpView(parent), peTreeModel(NULL)
{
	setHeaderHidden(true);
	setAutoFillBackground(true);
	setAutoScroll(true);
	setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);

	this->setCursor(Qt::PointingHandCursor);
	this->setSelectionMode(SingleSelection);
	setFocusPolicy(Qt::WheelFocus);
}

void PEStructureView::setModel(PEFileTreeModel *model)
{ 
	if (this->peTreeModel) {
		disconnect(this->peTreeModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
	}

	TreeCpView::setModel(model);
	this->peTreeModel = model;

	if (model != NULL) {
		connect(model, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()));
	}
	this->reset();
}

void PEStructureView::selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel)
{
	QModelIndexList indexes = newSel.indexes();
	if (indexes.size() == 0) {
		return;
	}
	QModelIndex index = indexes[0];
	if (!index.isValid()) {
		emit handlerSelected(NULL);
		//----
		return;
	}

	PEFileTreeItem* item = static_cast<PEFileTreeItem*> (index.internalPointer());
	if (!item) {
		emit handlerSelected(NULL);
		return;
	}
	PeHandler* hndl = item->getPeHandler();
	if (hndl) {
		const offset_t offset = item->getContentOffset();
		const bufsize_t size  = item->getContentSize();
		hndl->setDisplayed(false, offset, size);
		hndl->setHilighted(offset, size);
	}
	emit handlerSelected(hndl);
}

bool PEStructureView::selectHandler(PeHandler *hndl)
{
	emit handlerSelected(hndl);
	return true;
}


```

`pe-bear/PEFileTreeModel.h`:

```h
#pragma once

#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <map>
#include <set>

#include "gui_base/PeTreeView.h"
#include "ExeDependentAction.h"
#include "gui/PeTreeModel.h"

enum PEFileFieldId {
	PEFILE_NONE = -1,
	PEFILE_ROOT,
	PEFILE_MAIN,
	//PEFILE_SIGNATURE,
	PEFILE_IMG_DOS_HDR,
	PEFILE_DOS_STUB,
	PEFILE_IMG_NT_HDRS,
	PEFILE_SEC_HDRS,
	PEFILE_SECTIONS,
	PEFILE_OVERLAY,
	PEFILE_FIELD_COUNTER
};

enum PEFileNTHdrFieldId {
	PEFILE_NTHDR_NONE = -1,
	PEFILE_NTHDR_SIGN,
	PEFILE_NTHDR_FILEHDR,
	PEFILE_NTHDR_OPTHDR,
	PEFILE_NTHDR_COUNTER
};

class PEFileEntryPointItem;

class PEFileTreeItem : public PeTreeItem
{
	Q_OBJECT

public:
	enum ViewLevel { DESC = 0, DETAILS = 1 };
	typedef enum ViewLevel level_t;

	PEFileTreeItem(PeHandler *peHndl, level_t level = DESC, PEFileFieldId role = PEFILE_NONE, PEFileTreeItem *parent = NULL);

	bool attachIfBelongs(PEFileTreeItem *child);
	int columnCount() const;

	virtual QVariant data(int column) const;
	virtual QVariant foreground(int column) const;
	virtual QVariant background(int column) const;
	virtual QVariant toolTip(int column) const;
	virtual QVariant whatsThis(int column) const { return this->role; } //WhatsThisRole
	virtual QVariant decoration(int column) const;
	virtual QVariant font(int column) const;

	virtual BYTE* getContent();
	ViewLevel getViewLevel() { return level; }

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

signals:
	void needReset();

protected slots:
	void onModified();

protected:
	void createTree();
	void deleteOverlayNode();
	void appendOverlayNode();

	PEFileTreeItem* findNodeByRole(int role);

	bufsize_t getOverlaySize() const;

	virtual bool isChildOk(TreeItem* child)
	{
		return (dynamic_cast<PEFileTreeItem*>(child) != 0);
	}

	void setEntryPointItem(PEFileEntryPointItem *EpItem)
	{
		entryPointItem = EpItem;
	}

	PEFileEntryPointItem *entryPointItem;
	ViewLevel level;

	PEFileFieldId role;
	QString fileName;

friend class PEFileTreeModel;
friend class PEFileEntryPointItem;
};

//----------

class PEFileSectionsTreeItem : public PEFileTreeItem
{
	Q_OBJECT

public:
	PEFileSectionsTreeItem(PeHandler *peHndl, level_t level = DESC, int secIndx = (-1), PEFileTreeItem *parent = NULL);
	inline SectionHdrWrapper* getMySection() const;

	virtual QVariant data(int column) const;
	virtual QVariant background(int column) const;
	virtual QVariant decoration(int column) const; // DecorationRole

	virtual BYTE* getContent();

public slots:
	void onSectionNumChanged();

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;
protected:
	
	int secIndx;
};

//----------

class PEFileNTHdrTreeItem : public PEFileTreeItem
{
public:
	PEFileNTHdrTreeItem(PeHandler *peHndl, level_t level = DESC, enum PEFileNTHdrFieldId subrole = PEFILE_NTHDR_NONE, PEFileTreeItem *parent = NULL);

	virtual QVariant data(int column) const;
	virtual BYTE* getContent();

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;
protected:
	enum PEFileNTHdrFieldId subrole;
};

//----------

class PEFileEntryPointItem : public PEFileTreeItem
{
public:
	PEFileEntryPointItem(PeHandler *peHndl, PEFileTreeItem *mainItem, PEFileTreeItem *parent);
	virtual ~PEFileEntryPointItem();

	virtual QVariant decoration(int column) const;
	virtual QVariant data(int column) const;

	virtual BYTE* getContent();

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	offset_t savedEP;
	PEFileTreeItem *mainItem;

friend class PEFileTreeItem;
};

//----------

class PEFileTreeModel : public QAbstractItemModel
{
	Q_OBJECT

signals:
	void modelUpdated();

public slots:
	void refreshView();
	
	QModelIndex addHandler(PeHandler *peHndl);
	void deleteHandler(PeHandler *peHndl);

public:
	PEFileTreeModel(QObject *parent = 0);
	~PEFileTreeModel();

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const;
	
	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int) { return false; } //external modifications not allowed
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
	QModelIndex parent(const QModelIndex &index) const;

protected:
	void reset()
	{
		//>
		this->beginResetModel();
		this->endResetModel();
		//<
	}

	std::map<PEFile*, PEFileTreeItem*> loadedPeFiles;
	PEFileTreeItem* root;
};

class PEStructureView : public TreeCpView
{
	Q_OBJECT

signals:
	void handlerSelected(PeHandler *);

public:
	PEStructureView(QWidget *parent);
	void setModel(PEFileTreeModel *model);
	void selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel);
	bool selectHandler(PeHandler *hndl);

protected slots:
	virtual void onNeedReset() { reset(); expandAll(); }
	virtual void onModelUpdated() { emit handlerSelected(NULL); onNeedReset(); }

protected:
	PEFileTreeModel* peTreeModel;
};

```

`pe-bear/REbear.h`:

```h
// RE-bear release version and settings
#pragma once
#include <bearparser/bearparser.h>

#define TITLE "PE-bear"
#define V_MAJOR 0
#define V_MINOR 6
#define V_PATCH 1
#define V_PATCH_SUB 0
#define V_DESC ""

#define DISASMDMP_BG "black"
#define DISASMDMP_TXT "lime"

#define HEXDIFF_BG "#E5E6F8"
#define HEXDIFF_ALTBG "snow"

#define HEXDMP_ALTBG "snow"
#define HEXDMP_BG "rgba(229,230,248,160)" // light blue
#define HEXDMP_TXT "black"
#define HEXDMP_HBG "#00008A" // dark blue
#define HEXDMP_HTXT "white"
#define DIAGRAM_BG "#e3e4fa"

#define ERR_COLOR "#FF0000"
#define APPROVED_COLOR "#40EE40" // lightgreen

#define PREVIEW_SIZE 0x200

#define MY_SITE_LINK "https://hasherezade.net/"
#define PEBEAR_LINK "https://pe-bear.hasherezade.net/"
#define SOURCE_LINK "https://github.com/hasherezade/pe-bear/"

#define CAPSTONE_LICENSE "https://github.com/capstone-engine/capstone/blob/master/LICENSE.TXT"
#define BEARPARSER_LICENSE "https://github.com/hasherezade/bearparser/blob/master/LICENSE"

```

`pe-bear/SectionsDiagram.cpp`:

```cpp
#include "SectionsDiagram.h"
#include "REbear.h"
#include "ViewSettings.h"

#include <math.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

int getHPad()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return iconDim;
}

int getMinLeftPad()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return static_cast<int>(iconDim * 1.5);
}

int getMaxLeftPad()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return static_cast<int>(iconDim * 5);
}

int getMinRightPad()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return static_cast<int>(iconDim * 1.5);
}

int getMaxRightPad()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return static_cast<int>(iconDim * 4);
}

int getMinBarWidth()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	return static_cast<int>(iconDim * 1.8);
}

//-----------------------------------------------------------

SecDiagramModel::SecDiagramModel(PeHandler* peHndl) 
	: QObject(), PeViewItem(peHndl), selectedStart(0), selectedEnd(0)
{
	if (myPeHndl) {
		this->selectedStart = myPeHndl->pageStart;
		this->selectedEnd = myPeHndl->pageStart + myPeHndl->pageSize;
		connect(myPeHndl, SIGNAL(secHeadersModified()), this, SLOT(onSectionsUpdated()));
	}
}

SectionHdrWrapper* SecDiagramModel::getSectionAtUnit(int unitNum, bool isRaw)
{
	const size_t totalUnits = getUnitsNum(isRaw);
	if (unitNum > totalUnits) return NULL;

	bufsize_t unitSize = this->getUnitSize(isRaw);
	const offset_t addr = unitSize * unitNum;
	Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	return this->m_PE->getSecHdrAtOffset(addr, aType, false);
}

int SecDiagramModel::secIndexAtUnit(int unitNum, bool isRaw)
{
	SectionHdrWrapper* sec = getSectionAtUnit(unitNum, isRaw);
	if (!sec) {
		return SectHdrsWrapper::SECT_INVALID_INDEX;
	}
	return m_PE->getSecIndex(sec);
}

void SecDiagramModel::setSelectedArea(offset_t selStart, bufsize_t pageSize)
{
	if (!this->myPeHndl) return;

	this->selectedStart = selStart;
	this->selectedEnd = selStart + pageSize;

	emit modelUpdated();
}

void SecDiagramModel::selectFromAddress(offset_t offset)
{
	if (!this->myPeHndl) return;
	if (offset == INVALID_ADDR || offset >= m_PE->getRawSize()) return;
	
	this->selectedStart = offset;
	this->myPeHndl->setPageOffset(this->selectedStart);
	emit modelUpdated();
}

bufsize_t SecDiagramModel::getUnitSize(bool isRaw)
{
	const Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	const bufsize_t unit = m_PE ? m_PE->getAlignment(aType) : 0;
	return (unit > 0) ? unit : PAGE_SIZE;
}

size_t SecDiagramModel::getUnitsNum(bool isRaw)
{
	if (this->m_PE == NULL) {
		return 0;
	}
	const bufsize_t unitSize = this->getUnitSize(isRaw);
	const bufsize_t size = isRaw ? this->m_PE->getRawSize() : this->m_PE->getImageSize();
	if (!unitSize) return 0;

	return pe_util::unitsCount(size, unitSize);
}

size_t SecDiagramModel::unitsOfSection(int index, bool isRaw, bool showMapped)
{
	if (this->m_PE == NULL) return 0;
	if (index > this->m_PE->getSectionsCount()) return 0;
	SectionHdrWrapper *sec = this->m_PE->getSecHdr(index);
	if (sec == NULL) return 0;

	const bufsize_t unitSize = this->getUnitSize(isRaw);
	if (!unitSize) return 0;

	Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	const bufsize_t size = showMapped 
		? sec->getContentSize(Executable::RAW, true) // always use the RAW section size:
		: sec->getContentSize(aType, true);

	return pe_util::unitsCount(size, unitSize);
}

double SecDiagramModel::percentFilledInSection(int index, bool isRaw, bool showMapped)
{
	if (!this->m_PE) return 0;
	if (index > this->m_PE->getSectionsCount()) return 0;
	
	SectionHdrWrapper *sec = this->m_PE->getSecHdr(index);
	if (!sec) return 0;

	Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	const bufsize_t size = showMapped 
		? sec->getContentSize(Executable::RAW, true) // always use the RAW section size:
		: sec->getContentSize(aType, true);

	bufsize_t unitSize = this->getUnitSize(isRaw);
	size_t units = unitsOfSection(index, isRaw, showMapped);
	bufsize_t roundedSize = units * unitSize;
	if (roundedSize == 0) return 0;
	
	const double res = double(size)/ double(roundedSize);
	return res;
}

double SecDiagramModel::unitOfSectionBegin(int index, bool isRaw)
{
	if (!this->m_PE) return 0;
	if (index > this->m_PE->getSectionsCount()) return 0;

	SectionHdrWrapper *sec = this->m_PE->getSecHdr(index);
	if (!sec) return 0;

	const Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	DWORD bgn = sec->getContentOffset(aType);
	return unitOfAddress(bgn, isRaw);
}

DWORD SecDiagramModel::getSectionBegin(int index, bool isRaw)
{
	if (!this->m_PE) return 0;
	if (index > this->m_PE->getSectionsCount()) return 0;

	SectionHdrWrapper *sec = this->m_PE->getSecHdr(index);
	if (!sec) return 0;

	const Executable::addr_type aType = isRaw ? Executable::RAW : Executable::RVA;
	const offset_t bgn = sec->getContentOffset(aType);
	return bgn;
}

double SecDiagramModel::unitOfAddress(offset_t address, bool isRaw)
{
	if (!this->m_PE || address == INVALID_ADDR) return (-1);

	bufsize_t unitSize = this->getUnitSize(isRaw);
	if (!unitSize) return (-1);
	return (double)address/(double)unitSize;
}

double SecDiagramModel::unitOfEntryPoint(bool isRaw)
{
	if (!this->m_PE) return -1;
	DWORD ep = this->m_PE->getEntryPoint();
	if (isRaw) {
		try {
			ep = this->m_PE->rvaToRaw(ep);
		} catch (CustomException e) {
			return -1;
		}
	}
	return unitOfAddress(ep, isRaw);
}

double SecDiagramModel::unitOfHeadersEnd(bool isRaw)
{
	if (!this->m_PE) return -1;
	offset_t secHdrsOffset = m_PE->secHdrsEndOffset();
	return unitOfAddress(secHdrsOffset, isRaw);
}

DWORD SecDiagramModel::getEntryPoint(bool isRaw)
{
	if (!this->m_PE) return 0;
	DWORD ep = this->m_PE->getEntryPoint();
	if (!isRaw) return ep;
	try {
		ep = this->m_PE->rvaToRaw(ep);
	} catch (CustomException e) {
		return -1;
	}
	return ep;
}

QString SecDiagramModel::nameOfSection(int index)
{
	if (!this->m_PE) return "";
	if (index > this->m_PE->getSectionsCount()) return "";
	SectionHdrWrapper *sec = this->m_PE->getSecHdr(index);
	if (!sec) return "";
	return "[" + sec->mappedName + "]";
}

size_t SecDiagramModel::getSecNum()
{
	if (!this->m_PE) return 0;
	return this->m_PE->getSectionsCount();
}
//-----------------------------------------------------------

void SectionsDiagram::createActions()
{
	this->dataViewAction = new QAction("Show mapped raw", this);
	this->dataViewAction->setCheckable(true);
	connect(this->dataViewAction, SIGNAL(triggered(bool)), &settings, SLOT(setShowMapped(bool)));

	this->enableDrawEPAction = new QAction("Entry Point", this);
	this->enableDrawEPAction->setCheckable(true);
	connect(this->enableDrawEPAction, SIGNAL(triggered(bool)), &settings, SLOT(setDrawEP(bool)));

	this->enableDrawSecHdrsAction = new QAction("Sections Headers end", this);
	this->enableDrawSecHdrsAction->setCheckable(true);
	connect(this->enableDrawSecHdrsAction, SIGNAL(triggered(bool)), &settings, SLOT(setDrawSecHdrs(bool)));

	this->enableGridAction = new QAction("Grid (Alignment Units)", this);
	this->enableGridAction->setCheckable(true);
	connect(this->enableGridAction, SIGNAL(triggered(bool)), &settings, SLOT(setEnableGrid(bool)));

	this->enableOffsetsAction = new QAction("Sections &Offsets", this);
	this->enableOffsetsAction->setCheckable(true);
	connect(this->enableOffsetsAction, SIGNAL(triggered(bool)), &settings, SLOT(setDrawOffsets(bool)));

	this->enableSecNamesAction = new QAction("Sections &Names", this);
	this->enableSecNamesAction->setCheckable(true);
	connect(this->enableSecNamesAction, SIGNAL(triggered(bool)), &settings, SLOT(setDrawSecNames(bool)));

	connect(&settings, SIGNAL(settingsUpdated()), this, SLOT(refreshPixmap()));
}

void SectionsDiagram::destroyActions()
{
	delete this->dataViewAction;
	delete this->enableGridAction;
	delete this->enableDrawEPAction;
	delete this->enableDrawSecHdrsAction;
	delete this->enableOffsetsAction;
	delete this->enableSecNamesAction;
}

SectionsDiagram::SectionsDiagram(SecDiagramModel *model, bool viewRawAddresses , QWidget *parent)
	: QMainWindow(parent), myModel(NULL), isRaw(viewRawAddresses), settings(viewRawAddresses, this), menu(this),
	selY1(0), selY2(0), needRefresh(true)
{
	setModel(model);
	this->setMouseTracking(true);

	this->contourColor = Qt::black;

	this->setContextMenuPolicy(Qt::CustomContextMenu);
	createActions();
	menu.addAction(this->dataViewAction);
	menu.addAction(this->enableGridAction);
	menu.addAction(this->enableDrawEPAction);
	menu.addAction(this->enableDrawSecHdrsAction);
	menu.addAction(this->enableOffsetsAction);
	menu.addAction(this->enableSecNamesAction);

	if (isRaw) {
		dataViewAction->setEnabled(false);
	}

	this->dataViewAction->setChecked(settings.showMapped);
	this->enableGridAction->setChecked(settings.isGridEnabled);
	this->enableDrawEPAction->setChecked(settings.isDrawEPEnabled);
	this->enableDrawSecHdrsAction->setChecked(settings.isDrawSecHdrsEnabled);
	
	QColor bgColor(DIAGRAM_BG);
	bgColor.setAlpha(140);
	this->setBackgroundColor(bgColor);

	setAutoFillBackground(true);
	setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
	setFocusPolicy(Qt::StrongFocus);

	connect( this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(showMenu(QPoint)) );
}

void SectionsDiagram::mouseMoveEvent(QMouseEvent *event)
{
	int currY = event->pos().y();
	int unitNum = unitAtPosY(currY);
	if (unitNum == (-1)) return;

	int unitSize = this->myModel->getUnitSize(this->isRaw);
	if (unitSize <= 0) return;
	int value = unitSize * unitNum;
	SectionHdrWrapper *sec = this->myModel->getSectionAtUnit(unitNum, this->isRaw);
	QString secName = (sec) ? "\n[" + sec->mappedName + "]" : "";

	this->setToolTip(QString::number(value, 16) + secName);
}

void SectionsDiagram::setBackgroundColor(QColor bgColor)
{
	this->settings.bgColor = bgColor;
	QPalette p = this->palette();
	p.setColor(QPalette::Base, bgColor);
	setPalette(p);
	setBackgroundRole(p.Base);
}

QSize SectionsDiagram::minimumSizeHint() const
{
	const int MIN_BAR_WIDTH = getMinBarWidth();
	
	const int MIN_LEFT_PAD = getMinLeftPad();
	const int MIN_RIGHT_PAD = getMinRightPad();
	
	const int MAX_LEFT_PAD = getMaxLeftPad();
	const int MAX_RIGHT_PAD = getMaxRightPad();

	const int Y_TOP = getHPad();
	
	if (!this->settings.isDrawOffsets && !this->settings.isDrawSecNames)
		return QSize((MIN_LEFT_PAD + MIN_BAR_WIDTH + MIN_RIGHT_PAD), Y_TOP);

	return QSize((MAX_LEFT_PAD + MIN_BAR_WIDTH + MAX_RIGHT_PAD), 4 * Y_TOP);
}

QSize SectionsDiagram::sizeHint() const
{
	//const int Y_TOP = getMaxRightPad() * 5;
	
	QSize size = minimumSizeHint();
	return QSize(size.width() * 5,  size.height() * 5);
}

void SectionsDiagram::paintEvent(QPaintEvent *)
{
	QStylePainter painter(this);
	painter.drawPixmap(0, 0, this->pixmap);
	if (hasFocus()) {
		QStyleOptionFocusRect option;
		option.initFrom(this);
		option.backgroundColor = palette().dark().color();
		painter.drawPrimitive(QStyle::PE_FrameFocusRect, option);
	}
}

void SectionsDiagram::setModel(SecDiagramModel *model)
{
	if (this->myModel)
		disconnect(this->myModel, SIGNAL(modelUpdated()), this, SLOT(refreshPixmap()) );
	
	this->myModel = model;

	if (this->myModel)
		connect(this->myModel, SIGNAL(modelUpdated()), this, SLOT(refreshPixmap()) );
}

void SectionsDiagram::showMenu(QPoint p)
{ 
	this->enableDrawEPAction->setChecked(settings.isDrawEPEnabled);
	this->enableDrawSecHdrsAction->setChecked(this->settings.isDrawSecHdrsEnabled);
	this->enableGridAction->setChecked(this->settings.isGridEnabled);

	this->enableOffsetsAction->setChecked(this->settings.isDrawOffsets);
	this->enableSecNamesAction->setChecked(this->settings.isDrawSecNames);
	menu.exec(mapToGlobal(p)); 
}

void SectionsDiagram::refreshPixmap()
{
	if (!this->isVisible()) {
		 needRefresh = true;
		return;
	}
	needRefresh = false;
	this->setMinimumWidth(minimumSizeHint().width());
	pixmap = QPixmap(size());
	pixmap.fill(this->settings.bgColor);
	
	QPainter painter(&pixmap);
	if (this->myModel) 
		drawSections(&painter);
	update();
}

void SectionsDiagram::drawSections(QPainter *painter)
{
	const int MIN_LEFT_PAD = getMinLeftPad();
	const int MIN_RIGHT_PAD = getMinRightPad();
	
	const int MAX_LEFT_PAD = getMaxLeftPad();
	const int MAX_RIGHT_PAD = getMaxRightPad();
	
	const int MIN_BAR_WIDTH = getMinBarWidth();
	
	const int HPAD = getHPad();
	
	int LEFT_PAD = MAX_LEFT_PAD;
	int RIGHT_PAD = MAX_RIGHT_PAD;
	
	if (!this->settings.isDrawSecNames && !this->settings.isDrawOffsets) {
		LEFT_PAD = MIN_LEFT_PAD;
		RIGHT_PAD = MIN_RIGHT_PAD;
	}

	QRect rect(LEFT_PAD, HPAD, width() - (LEFT_PAD + RIGHT_PAD), height() - 2 * HPAD);
	if (!rect.isValid())
		return;

	QPen descPen(Qt::red);
	QPen textPen(this->contourColor);

	size_t totalUnits = this->myModel->getUnitsNum(this->isRaw);
	if (totalUnits == 0) return;

	painter->setPen(textPen);
	painter->drawRect(rect.adjusted(0, 0, -1, -1));

	int textY = 0;
	int prevSecNum = 0;
	size_t secNum = this->myModel->getSecNum();

	if (secNum > 0) {
		size_t secUnits = 0;

		const size_t colorsNum = settings.colors.size();

		/* draw sections */
		painter->setPen(textPen);
		int secIndex = -1;
		for (int j = 0; j < secNum; j++) {
			const QColor currColor = settings.colors[j % colorsNum];

			double startPosition = this->myModel->unitOfSectionBegin(j, isRaw);
			int yBgn = rect.top() + (startPosition * (rect.height() - 1) / totalUnits);
			if (settings.isDrawOffsets) {
				offset_t secBgn = this->myModel->getSectionBegin(j, isRaw);
				QString name = QString::number(secBgn, 16).toUpper();
				painter->drawText(5, yBgn, name);
			}
			painter->drawLine(rect.left(), yBgn, rect.right(), yBgn);
			secUnits = this->myModel->unitsOfSection(j, isRaw, settings.showMapped);
			if (secUnits > 0) {
				int h = (secUnits * rect.height()) / totalUnits;
				h = h * this->myModel->percentFilledInSection(j, isRaw, settings.showMapped);
				h += (h > 0)? 1: 0; 
				int w = rect.right() - rect.left();
				painter->fillRect(QRect(rect.left() + 1, yBgn, w, h), currColor);
			}
			if (settings.isDrawSecNames) {
				QString secName = this->myModel->nameOfSection(j);
				painter->drawText(rect.left() + MIN_BAR_WIDTH, yBgn + HPAD, secName);
			}
		}
	}

	if (settings.isDrawEPEnabled) drawEntryPoint(painter, rect, LEFT_PAD, RIGHT_PAD);
	if (settings.isDrawSecHdrsEnabled) drawSecHeaders(painter, rect, LEFT_PAD, RIGHT_PAD);
	if (settings.isDrawSelected) drawSelected(painter, rect, LEFT_PAD, RIGHT_PAD);

	/* draw grid */
	const int MAX_TO_DRAW = 1000;
	if (settings.isGridEnabled) {
		
		QPen borderPen(Qt::lightGray);
		borderPen.setStyle(Qt::DotLine);
		painter->setPen(borderPen);

		for (int j = 0; j < totalUnits && j < MAX_TO_DRAW; j++) {
			int y = rect.top() + (j * (rect.height() - 1) / totalUnits);
			painter->drawLine(rect.left(), y, rect.right(), y);
		}
	}
}

void SectionsDiagram::drawSecHeaders(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD)
{
	const size_t totalUnits = this->myModel->getUnitsNum(this->isRaw);
	if (totalUnits == 0) return;
	
	double hdrsEndPosition = this->myModel->unitOfHeadersEnd(isRaw);
	if (hdrsEndPosition >= 0) {
		QPen hdrPen(this->contourColor);
		hdrPen.setStyle(Qt::DashLine);
		
		painter->setPen(hdrPen);
		int y = rect.top() + (hdrsEndPosition * (rect.height() - 1) / totalUnits);
		painter->drawLine(rect.left() - LEFT_PAD, y, rect.right() + RIGHT_PAD, y);
		painter->setPen(Qt::SolidLine);
	}
}

void SectionsDiagram::drawEntryPoint(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD)
{
	const size_t totalUnits = this->myModel->getUnitsNum(this->isRaw);
	if (totalUnits == 0) return;
	
	QPen epPen(Qt::red);
	painter->setPen(epPen);
	
	double epUnitPosition = this->myModel->unitOfEntryPoint(isRaw);
	DWORD ep = this->myModel->getEntryPoint(isRaw);
	
	if (epUnitPosition >= 0) {
		painter->setPen(QColor(255, 0, 0));
		int y = rect.top() + (epUnitPosition * (rect.height() - 1) / totalUnits);
		painter->drawLine(rect.left() - LEFT_PAD, y, rect.right() + RIGHT_PAD, y);
	
		QString name = QString::number(ep, 16).toUpper();
		painter->drawText(5, y, name);
	}
}

int SectionsDiagram::unitAtPosY(int posY)
{
	const int MIN_LEFT_PAD = getMinLeftPad();
	const int MIN_RIGHT_PAD = getMinRightPad();
	
	const int MAX_LEFT_PAD = getMaxLeftPad();
	const int MAX_RIGHT_PAD = getMaxRightPad();
	
	const int HPAD = getHPad();

	int LEFT_PAD = MAX_LEFT_PAD;
	int RIGHT_PAD = MAX_RIGHT_PAD;
	
	if (!this->settings.isDrawSecNames && !this->settings.isDrawOffsets) {
		LEFT_PAD = MIN_LEFT_PAD;
		RIGHT_PAD = MIN_RIGHT_PAD;
	}

	QRect rect(LEFT_PAD, HPAD, width() - (LEFT_PAD + RIGHT_PAD), height() - 2 * HPAD);
	if (!rect.isValid())
		return (-1);

	size_t totalUnits = this->myModel->getUnitsNum(this->isRaw);
	if (totalUnits == 0) return (-1);
	
	int prevY = 0;
	/* grid */
	for (int unitNum = 0; unitNum < totalUnits; unitNum++) {
		int y = rect.top() + (unitNum * (rect.height() - 1) / totalUnits);
		if (posY > prevY && posY <= y) return unitNum;
		prevY = y;
	}
	return (-1);
}

//--------------------------------------------------------------------------------------

SelectableSecDiagram::SelectableSecDiagram(SecDiagramModel *model, bool isRawView, QWidget *parent)
	: SectionsDiagram(model, isRawView, parent)
{
	this->setMouseTracking(true);

	// default settings for this type of diagram:
	settings.isDrawSelected = true;
	settings.setDrawOffsets(false);
	settings.setDrawSecNames(false);

	cursorUpPix = QPixmap(":/icons/arr_up.ico");
	cursorDownPix = QPixmap(":/icons/arr_down.ico");
	upCursor = QCursor(cursorUpPix, 0, 0);
	downCursor = QCursor(cursorDownPix, 0,0);
}

void SelectableSecDiagram::drawSelected(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD)
{
	const size_t totalUnits = this->myModel->getUnitsNum(this->isRaw);
	if (totalUnits == 0) return;
	
	if (this->myModel->selectedEnd == 0 && this->myModel->selectedStart == 0) {
		return;
	}
	
	QPen epPen(settings.selectionColor);
	
	epPen.setWidth(3);
	painter->setPen(epPen);

	double unit1 =  this->myModel->unitOfAddress(this->myModel->selectedStart, isRaw);
	double unit2 =  this->myModel->unitOfAddress(this->myModel->selectedEnd, isRaw);

	double val = (unit1 /totalUnits) * (rect.height() - 1);
	int y1 = rect.top() + val;
		
	val = (unit2 /totalUnits) * (rect.height() - 1);
	int y2 = rect.top() + val + 1;

	QRect rect1( QPoint(rect.left() - LEFT_PAD, y1), QPoint(rect.right() + RIGHT_PAD, y2) );
	selY1 = y1;
	selY2 = y2;
	painter->fillRect(rect1, settings.selectionColor);
}

void SelectableSecDiagram::mousePressEvent(QMouseEvent *event)
{
	if (event->button() != Qt::LeftButton) return;

	int currY = event->pos().y();
	int unitNum = unitAtPosY(currY);
	if (unitNum == (-1)) return;

	bufsize_t unitSize = this->myModel->getUnitSize(true);
	if (unitSize <= 0) {
		unitSize = PAGE_SIZE;
	}
	const offset_t value = unitSize * unitNum;
	this->myModel->selectFromAddress(value);
}

void SelectableSecDiagram::mouseMoveEvent(QMouseEvent *event)
{
	int currY = event->pos().y();
	if (currY < selY1) {
		this->setCursor(upCursor);
	} else if (currY > selY2) {
		this->setCursor(downCursor);
	}
	SectionsDiagram::mouseMoveEvent(event);
}

```

`pe-bear/SectionsDiagram.h`:

```h
#pragma once
#include <QtGlobal>
#include <vector>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "gui_base/PeGuiItem.h"

//--------------------------------------------------------------------------------------
class SecDiagramModel : public QObject, public PeViewItem
{
	Q_OBJECT
signals:
	void modelUpdated();

public slots:
	void setSelectedArea(offset_t selectedStart, bufsize_t selectedEnd);

protected slots:
	void onSectionsUpdated() { emit modelUpdated(); }

public:
	SecDiagramModel(PeHandler* peHndl);
	size_t getSecNum();
	bufsize_t getUnitSize(bool isRaw);
	size_t getUnitsNum(bool isRaw);

	size_t unitsOfSection(int index, bool isRaw, bool showMapped);
	double percentFilledInSection(int index, bool isRaw, bool showMapped);
	
	double unitOfEntryPoint(bool isRaw);
	double unitOfHeadersEnd(bool isRaw);
	double unitOfSectionBegin(int index, bool isRaw);
	DWORD getSectionBegin(int index, bool isRaw);
	double unitOfAddress(offset_t address, bool isRaw);

	DWORD getEntryPoint(bool isRaw);

	QString nameOfSection(int index);
	int secIndexAtUnit(int unitNum, bool isRaw);

	void selectFromAddress(offset_t offset);
	SectionHdrWrapper* getSectionAtUnit(int unitNum, bool isRaw);

protected:
	offset_t selectedStart, selectedEnd;
friend class SelectableSecDiagram;
};
//--------------------------------------------------------------------------------------

class SectionsDiagramSettings : public QObject
{
	Q_OBJECT

signals:
	void settingsUpdated();

public:
	SectionsDiagramSettings(bool _isRaw, QObject *parent)
		: QObject(parent),
		isRaw(_isRaw),
		showMapped(true),
		isGridEnabled(false), isDrawEPEnabled(true), isDrawSecHdrsEnabled(true), isDrawOffsets(true), isDrawSecNames(true),
		isDrawSelected(false)
	{
		loadDefaultColors();

		bgColor = QColor(DIAGRAM_BG);
		selectionColor = QColor(DIAGRAM_BG);
		selectionColor.setAlpha(150);
	}

public slots:
	void setEnableGrid(bool enable) { isGridEnabled = enable; refreshParent(); }
	void setDrawEP(bool enable) { isDrawEPEnabled = enable; refreshParent(); }
	void setDrawSecHdrs(bool enable) { isDrawSecHdrsEnabled = enable; refreshParent(); }
	void setDrawOffsets(bool enable) { isDrawOffsets = enable;  refreshParent(); }
	void setDrawSecNames(bool enable) { isDrawSecNames = enable; refreshParent(); }
	void setShowMapped(bool enable) { showMapped = enable; refreshParent(); }

protected:
	void loadDefaultColors()
	{
		colors.push_back(QColor(0, 0, 255, 100));
		colors.push_back(QColor(255, 255, 0, 100));
		colors.push_back(QColor(25, 255, 0, 100));
		colors.push_back(QColor(255, 34, 0, 100));
		colors.push_back(QColor(200, 0, 255, 100));
	}

	void refreshParent()
	{
		emit settingsUpdated();
	}

	bool isRaw;
	bool showMapped;
	bool isGridEnabled;
	bool isDrawEPEnabled;
	bool isDrawSecHdrsEnabled;
	bool isDrawOffsets;
	bool isDrawSecNames;
	bool isDrawSelected;

	std::vector<QColor> colors;
	QColor bgColor, selectionColor;

	friend class SectionsDiagram;
	friend class SelectableSecDiagram;
};

//--------------------------------------------------------------------------------------
class SectionsDiagram : public QMainWindow
{
	Q_OBJECT

public:
	SectionsDiagram(SecDiagramModel *model, bool viewRawAddresses, QWidget *parent);
	~SectionsDiagram() { destroyActions(); }

	QSize minimumSizeHint() const;
	QSize sizeHint() const;
	void setBackgroundColor(QColor bgColor);
	
	QColor contourColor;

public slots:
	void showMenu(QPoint p);
	void refreshPixmap();

protected:
	void setModel(SecDiagramModel *model);
	void mouseMoveEvent(QMouseEvent *event);
	void paintEvent(QPaintEvent *);
	void resizeEvent(QResizeEvent *) { refreshPixmap(); }
	void showEvent ( QShowEvent *e) { if (needRefresh) refreshPixmap(); }

	void drawSections(QPainter *painter);
	virtual void drawSelected(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD) { }
	void drawEntryPoint(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD);
	void drawSecHeaders(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD);

	void createActions();
	void destroyActions();

	int unitAtPosY(int y);

	QAction *dataViewAction;
	QAction *enableGridAction, *enableDrawEPAction, *enableDrawSecHdrsAction;
	QAction *enableOffsetsAction, *enableSecNamesAction;
	QMenu menu;

	SecDiagramModel *myModel;
	QPixmap pixmap;
	int curZoom;
	SectionsDiagramSettings settings;
	bool isRaw;

	int selY1, selY2;
	bool needRefresh;
};

class SelectableSecDiagram : public SectionsDiagram
{
	Q_OBJECT
public:
	SelectableSecDiagram(SecDiagramModel *model, bool isRawView, QWidget *parent);

protected:
	virtual void drawSelected(QPainter *painter, QRect &rect, int LEFT_PAD, int RIGHT_PAD);
	void mousePressEvent(QMouseEvent *event);
	void mouseMoveEvent(QMouseEvent *event);
	QCursor upCursor, downCursor;
	QPixmap cursorUpPix, cursorDownPix;
};

```

`pe-bear/TempBuffer.h`:

```h
#pragma once

#include <stdio.h>
#include <stdlib.h>

//util:
struct TempBuffer
{
public:
	TempBuffer()
		:buf(NULL), buf_size(0)
	{
	}

	bool init(size_t _buf_size)
	{
		buf = (BYTE*)calloc(_buf_size, 1);
		if (!buf) {
			return false;
		}
		buf_size = _buf_size;
		return true;
	}

	bool init(const BYTE *_buf, size_t _buf_size)
	{
		buf = (BYTE*)calloc(_buf_size, 1);
		if (!buf) {
			return false;
		}
		buf_size = _buf_size;
		::memcpy(buf, _buf, _buf_size);
		return true;
	}

	~TempBuffer()
	{
		if (buf) {
			free(buf);
			buf = NULL;
		}
		buf_size = 0;
	}

	BYTE* getContent() { return buf; }

protected:
	BYTE *buf;
	size_t buf_size;
};

```

`pe-bear/ViewSettings.cpp`:

```cpp
#include "ViewSettings.h"

QPixmap ViewSettings::makeScaledPixMap(const QString &resource, int width, int height)
{
	QPixmap pix(resource);
	pix = pix.scaled(width, height, Qt::KeepAspectRatio, Qt::SmoothTransformation);
	return pix;
}

QIcon ViewSettings::makeScaledIcon(const QString &resource, int width, int height)
{
	return QIcon(ViewSettings::makeScaledPixMap(resource, width, height));
}

```

`pe-bear/ViewSettings.h`:

```h
#pragma once

#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

class ViewSettings
{
public:

	static int scalingPercent()
	{
#if QT_VERSION >= 0x050000
		QScreen *screen = QApplication::primaryScreen();
		const int scaling_percent = (screen->logicalDotsPerInch() / 96) * 100;
		return scaling_percent;
#else
		return 100;
#endif
	}

	static qreal scaledFontSize(const QFont &font)
	{
		int sFactor = scalingPercent();
		
		int size = font.pointSize();
		if (size == -1) size = font.pixelSize();

		const qreal pointSize = (qreal(size) * sFactor) / 100.0;
		return pointSize;
	}
	
	static int getSmallIconDim(const QFont &font)
	{
		const int minDim = 12;
		int iconDim = ceil(scaledFontSize(font));
		if (iconDim < minDim) {
			iconDim = minDim;
		}
		return iconDim;
	}
	
	static int getMediumIconDim(const QFont &font)
	{
		const qreal minDim = 16;
		qreal iconDim = scaledFontSize(font) * 1.5;
		if (iconDim < minDim) {
			iconDim = minDim;
		}
		return static_cast<int>(ceil(iconDim));
	}
	
	static int getIconDim(const QFont &font)
	{
		const qreal minDim = 16;
		qreal iconDim = scaledFontSize(font) * 2.2;
		if (iconDim < minDim) {
			iconDim = minDim;
		}
		return static_cast<int>(ceil(iconDim));
	}

	static QPixmap makeScaledPixMap(const QString &resource,int w, int h);
	static QIcon makeScaledIcon(const QString &resource, int w, int h);

	static QPixmap getScaledPixmap(const QString &resource)
	{
		const int dim = ViewSettings::getMediumIconDim(QApplication::font());
		return ViewSettings::makeScaledPixMap(resource, dim, dim);
	}

	QFont myFont;
};

class HexViewSettings : public ViewSettings
{
public:

	static QFont defaultFont()
	{
#ifdef __APPLE__
		QFont myFont;
#else
		QFont myFont("TypeWriter");
#endif

#if QT_VERSION >= 0x040700
		myFont.setStyleHint (QFont::Monospace);
#else
		myFont.setStyleHint (QFont::TypeWriter);
#endif
		myFont.setPointSize(8);
		myFont.setLetterSpacing(QFont::AbsoluteSpacing, 0);
		myFont.setStretch(QFont::Unstretched);
		return myFont;
	}

	HexViewSettings()
	{
		myFont = defaultFont();

		hoveredColor = QColor("CornflowerBlue");
		hoveredColor.setAlpha(100);

		vHdrColor = QColor("LightGrey");
		vHdrColor.setAlpha(100);

		modifColor = QColor("red");
		inactiveModifColor = modifColor;
		inactiveModifColor.setAlpha(150);

		inactiveColor = QColor("grey");
	}

	~HexViewSettings() {}
	
	QSize getVerticalSize() const
	{
		const int fontDim = ViewSettings::getIconDim(myFont);
		return QSize(ceil(scaledFontSize(myFont) * 7), fontDim);
	}

	QColor hoveredColor;
	QColor vHdrColor;
	QColor modifColor, inactiveModifColor;
	QColor inactiveColor;
};

//---

class DisasmViewSettings : public ViewSettings
{
public:
	static QFont defaultFont()
	{
#ifdef __APPLE__
		QFont myFont;
#else
		QFont myFont("TypeWriter");
#endif

#if QT_VERSION >= 0x040700
		myFont.setStyleHint (QFont::Monospace);
#else
		myFont.setStyleHint (QFont::TypeWriter);
#endif
		myFont.setPointSize(8);
		myFont.setLetterSpacing(QFont::AbsoluteSpacing, 0);
		myFont.setStretch(QFont::Unstretched);
		return myFont;
	}

	DisasmViewSettings()
	{
		myFont = defaultFont();

		vHdrColor = QColor("LightGrey");
		vHdrColor.setAlpha(50);

		branchingColor = QColor("darkGrey");
		branchingColor.setAlpha(30);

		retColor = QColor("DodgerBlue");
		nopColor = QColor("grey");
		int3Color = QColor("#FF00FF");
		intXColor = QColor("#da7bef");
		callColor = QColor("orange");
		jumpColor = QColor("khaki");
		invalidColor = QColor("red");
		importColor = QColor("cyan");
		delayImpColor = QColor("pink");
		conditionalColor = QColor("yellow");
	}
	
	QSize getIconSize() const
	{
		const int fontDim = ViewSettings::getIconDim(myFont);
		return QSize(fontDim, fontDim);
	}
	
	QSize getVerticalSize() const
	{
		const int fontDim = ViewSettings::getIconDim(myFont);
		return QSize(fontDim * 5, fontDim);
	}
	
	QColor vHdrColor;
	QColor branchingColor;
	QColor retColor, nopColor, int3Color, intXColor, invalidColor, callColor, jumpColor,
		importColor, delayImpColor,
		conditionalColor;
};

```

`pe-bear/application.qrc`:

```qrc
<RCC>
    <qresource prefix="/">
        <file>main_ico.ico</file>
        <file>icons/EP.ico</file>
        <file>icons/arrow-right.ico</file>
        <file>icons/section.ico</file>
        <file>icons/Delete.ico</file>
        <file>icons/app32.ico</file>
        <file>icons/app64.ico</file>
        <file>icons/Save.ico</file>
        <file>icons/Add.ico</file>
        <file>icons/hdr.ico</file>
        <file>icons/dos.ico</file>
        <file>icons/app32_w.ico</file>
        <file>icons/app64_w.ico</file>
        <file>icons/Locked.ico</file>
        <file>icons/DeleteAll.ico</file>
        <file>icons/eraser.ico</file>
        <file>icons/go_to_raw.ico</file>
        <file>icons/go_to_rva.ico</file>
        <file>icons/List.ico</file>
        <file>icons/Preview.ico</file>
        <file>icons/down.ico</file>
        <file>icons/up.ico</file>
        <file>icons/wrong_way.ico</file>
        <file>icons/space.ico</file>
        <file>icons/space_down.ico</file>
        <file>icons/space_up.ico</file>
        <file>icons/space_this.ico</file>
        <file>icons/undo.ico</file>
        <file>icons/arr_down.ico</file>
        <file>icons/arr_up.ico</file>
        <file>icons/enlarge.ico</file>
        <file>icons/shrink.ico</file>
        <file>icons/add_entry.ico</file>
        <file>icons/add_subentry.ico</file>
        <file>icons/move.ico</file>
        <file>icons/red_pin.ico</file>
        <file>icons/resize.ico</file>
        <file>icons/unmodify.ico</file>
        <file>icons/star.ico</file>
        <file>icons/data_dir_color.ico</file>
        <file>icons/data_dir_gray.ico</file>
        <file>icons/save_black.ico</file>
        <file>icons/reload.ico</file>
        <file>icons/dump.ico</file>
        <file>icons/information.ico</file>
    </qresource>
</RCC>

```

`pe-bear/base/BearVers.cpp`:

```cpp
#include "BearVers.h"
using namespace pe_bear;

BearVers::BearVers(int ma, int mi, int p, int s, const QString &desc)
	: vMajor(ma), vMinor(mi), vPatch(p), vSub(s), vDesc(desc), 
	valid(true)
{
}

BearVers::BearVers(QString replyString)
	: vMajor(0), vMinor(0), vPatch(0), vSub(0), vDesc(""), valid(false)
{
	replyString = replyString.trimmed();
	QStringList strings = replyString.split(".", QString::SkipEmptyParts);
	if (strings.length() < 3) return;

	this->vMajor = strings[0].toInt();
	this->vMinor = strings[1].toInt();
	this->vPatch = strings[2].toInt();
	this->vSub = (strings.length() > 3) ? 0 : strings[3].toInt();
	valid = true;
}

QString BearVers::toString()
{
	if (!isValid()) return "";
	QString str = QString::number(vMajor) + "." + QString::number(vMinor) + "." + QString::number(vPatch);
	if (vSub != 0) {
		str += "." + QString::number(vSub);
	}
	if (vDesc.length() > 0) {
		str += "-" + vDesc;
	}
	return str;
}

int BearVers::operator==(BearVers const &ver2) const
{
	return ((ver2.vMajor == this->vMajor) 
		&& (ver2.vMinor == this->vMinor) 
		&& (ver2.vPatch == this->vPatch)
		&& (ver2.vSub == this->vSub));
}

bool BearVers::operator< (BearVers const &ver2) const
{
	if (ver2.vMajor > this->vMajor) return true;
	if (ver2.vMajor < this->vMajor) return false;

	if (ver2.vMinor > this->vMinor) return true;
	if (ver2.vMinor < this->vMinor) return false;

	if (ver2.vPatch > this->vPatch) return true;
	if (ver2.vPatch < this->vPatch) return false;
	
	if (ver2.vSub > this->vSub) return true;
	if (ver2.vSub < this->vSub) return false;
	return false;
}

BearVers::VersionStatus BearVers::compare(BearVers &ver)
{
	if (!this->isValid() || !ver.isValid()) return BearVers::VER_INVALID;
	if ((*this) == ver) {
		return BearVers::VER_OK;
	}
	if (ver > (*this)) {
		return BearVers::VER_OLD;
	}
	return BearVers::VER_NEW;
}

```

`pe-bear/base/BearVers.h`:

```h
#pragma once

#include <QtCore>

namespace pe_bear {
class BearVers
{
public:
	enum VersionStatus { VER_INVALID = (-1), VER_OK, VER_OLD, VER_NEW };

	BearVers(int major, int minor, int patch, int sub, const QString &desc="");
	BearVers(QString s);
	bool isValid() { return valid; }

	VersionStatus compare(BearVers &latestVer);
	QString toString();

	int operator==(BearVers const &ver) const;
	int operator!=(BearVers const &ver) const { return !((*this) == ver); }

	bool operator< (BearVers const &ver) const;
	bool operator> (BearVers const &ver) const { if ((*this) == ver) return false; return !((*this) < ver); }

protected:
	int vMajor, vMinor, vPatch, vSub;
	QString vDesc;
	bool valid;
};
}; // namespace pe_bear

```

`pe-bear/base/CommentHandler.cpp`:

```cpp
#include "CommentHandler.h"
#include <algorithm>

#define START_ID 1
#define DELIMITER ';'
#define MAX_COMMENTLINE 0xFF

//--------------------
void CommentHandler::LoaderThread::breakReading()
{
	QMutexLocker locker(&m_readMutex);
	isBreakReading = true;
}

bool CommentHandler::_preprocessFile(QString &path, std::map<offset_t, QString> &all_comments)
{
	QFile fIn(path);
	if (fIn.open(QFile::ReadOnly | QFile::Text) == false)  {
		return false;
	}
	
	QTextStream sIn(&fIn);
	while (!sIn.atEnd()) {
		
		QString line = sIn.readLine();
		
		int delimOffset = line.indexOf(DELIMITER);
		if (delimOffset == (-1)) continue; // delimiter not found
		
		QString offsetStr = line.left(delimOffset);

		bool isOk = false;
		offset_t offset = offsetStr.toLongLong(&isOk, 16);
		if (!isOk) continue;
		
		QString comment = line.mid(delimOffset + 1);
		all_comments[offset] = comment;
	}
	fIn.close();
	return true;
}

void CommentHandler::LoaderThread::loadFromQFile(QString path)
{
	std::map<offset_t, QString> all_comments;
	
	if (!_preprocessFile(path, all_comments)) {
		return;
	}
	
	std::map<offset_t, QString>::iterator itr;
	
	for (itr = all_comments.begin(); itr != all_comments.end(); ++itr) {
		
		QMutexLocker locker(&m_readMutex);
		if (isBreakReading) break;
		
		QString &line = itr->second;
		offset_t offset = itr->first;
		
		cmntHndl->_insertComment(offset, line);
	}
}

void CommentHandler::LoaderThread::run()
{
	isBreakReading = false;
	loadFromQFile(this->fPath);
	//printf("thread stopped\n");
}

//--------------------

void CommentHandler::clear()
{
	if (t != NULL) { 
		t->breakReading();
		while (t->isFinished() == false) {
			printf("Waiting to finish...\n");
			t->wait();
		}
	}
	delete this->t;
	this->t = NULL;

	size_t entriesCount = this->commentsVec.size();
	for (int i = 0; i < entriesCount; i++) {
		delete this->commentsVec[i];
	}
	this->commentsVec.clear();
	this->commentsMap.clear();
}

QString CommentHandler::getCommentAt(offset_t rva)
{
	QMutexLocker ml(&m_loadMutex);

	if (this->commentsMap.find(rva) == this->commentsMap.end()) {
		return "";
	}
	return this->commentsMap.at(rva)->content;
}

void CommentHandler::setComment(offset_t rva, QString comment)
{
	QMutexLocker ml(&m_loadMutex);
	_insertComment(rva, comment);
	emit commentsUpdated();
}

bool CommentHandler::_updateComment(offset_t rva, QString &comment)
{
	std::map<offset_t, Comment*>::iterator itr = this->commentsMap.find(rva);

	if (itr == this->commentsMap.end()) {
		return false;
	}
	if (comment.length() == 0) {
		Comment *cmnt = itr->second;
		std::vector<Comment*>::iterator vecItr = std::find(this->commentsVec.begin(), commentsVec.end(), cmnt);
		this->commentsVec.erase(vecItr);
		this->commentsMap.erase(itr);
		delete cmnt; // delete comment

	} else {
		itr->second->content = comment;
	}
	return true;
}

void CommentHandler::_insertComment(offset_t rva, QString &comment)
{
	if (_updateComment(rva, comment)) {
		return; //updated
	}
	
	if (comment.length() == 0) {
		return; // do not add empty tags
	}
	// create a new comment
	Comment* commentVal = new Comment(rva, comment);
	if (commentsVec.size() == 0) {
		commentVal->id = START_ID;
	} else {
		commentVal->id = commentsVec.back()->id + 1;
	}
	commentsVec.push_back(commentVal);
	commentsMap[rva] = commentVal;
}

bool CommentHandler::saveToFile(QString fileName)
{
	QMutexLocker ml(&m_loadMutex);

	if (isLoaded == false && this->commentsVec.size() == 0) {
		return true;
	}

	QFile fOut(fileName);
	if (fOut.open(QFile::WriteOnly| QFile::Text) == false) {
		return false;
	}
	QTextStream out(&fOut);

	std::vector<Comment*>::iterator vecItr;
    for (vecItr = this->commentsVec.begin(); vecItr != this->commentsVec.end(); ++vecItr ) {
		Comment* cmnt = *vecItr;
		QString offsetStr = QString::number(cmnt->offset, 16);
		QString qComment = cmnt->content;
		qComment = qComment.trimmed();
		
		QString line = offsetStr + DELIMITER + qComment;
		out << line << endl;
	}
	fOut.close();
	return true;
}

size_t CommentHandler::getCommentsNum()
{
	QMutexLocker ml(&m_loadMutex);

	size_t size = this->commentsMap.size();
	return size;
}

void CommentHandler::onLoaded()
{
	// delete loader thread:
	delete this->t;
	this->t = NULL;
	emit commentsUpdated();
}

bool CommentHandler::isFileOk(QString fileName)
{
	QFile fIn(fileName);
	if (fIn.open(QFile::ReadOnly | QFile::Text) == false) return false;
	fIn.close();
	return true;
}

bool CommentHandler::loadFromFile(QString fileName)
{
	if (this->t != NULL) return false;
	if (isFileOk(fileName) == false) return false;

	clear(); // clear all before load!

	this->t = new LoaderThread(fileName, this);
	QObject::connect(t, SIGNAL(finished()), this, SLOT(onLoaded()));
	t->start();
	return true;
}

//--------------------

```

`pe-bear/base/CommentHandler.h`:

```h
#pragma once
#include <QtCore>
#include <bearparser/bearparser.h>
#include <map>
#include <list>

class Comment;
class CommentHandler;

//-------------------

class Comment
{
public:
	Comment(offset_t Offset, QString Content) :
		offset(Offset),
		content(Content) { }

	offset_t offset;
	QString content;
	uint32_t id;
};

//-------------------

class CommentHandler : public QObject
{
	Q_OBJECT
signals:
	void commentsUpdated();

protected slots:
	void onLoaded();

public:
	CommentHandler() : QObject(), isLoaded(false), t(NULL) {}
	~CommentHandler() { clear(); }

	QString getCommentAt(offset_t rva);
	void setComment(offset_t rva, QString comment);
	//---
	bool saveToFile(QString fileName);
	bool loadFromFile(QString fileName);
	size_t commentsNum() { return commentsMap.size(); }

	std::vector<Comment*> commentsVec;
	size_t getCommentsNum();

protected:
	// BEGIN inner class: LoaderThread
	class LoaderThread : public QThread
	{
	public:
		LoaderThread(QString filePath, CommentHandler *handler)
			: cmntHndl(handler), fPath(filePath)
		{
		}
		
		void breakReading();
		
	private:
		void run();
		void loadFromQFile(QString path);

		bool isLoaded;
		QString fPath;
		CommentHandler *cmntHndl;

		bool isBreakReading;
		QMutex m_readMutex;
	};
	// END of inner class: LoaderThread

	static bool isFileOk(QString fileName);
	static bool _preprocessFile(QString &path, std::map<offset_t, QString> &all_comments);

	void _insertComment(offset_t rva, QString &comment);
	bool _updateComment(offset_t rva, QString &comment);
	void clear();

	std::map<offset_t, Comment*> commentsMap;
	bool isLoaded; //indicates if tags are fresh or loaded from file
	QMutex m_loadMutex;
	LoaderThread *t;

//friend class LoaderThread;
};



```

`pe-bear/base/MainSettings.cpp`:

```cpp
#include "MainSettings.h"

#include "../gui/DarkStyle.h"


//--------------------


QString ColorSettings::defaultRawColor = "green";
QString ColorSettings::defaultRvaColor = "blue";
QString ColorSettings::defaultVaColor = "purple";

QString ColorSettings::defaultFlagsColor = "#E3E4FA"; // lavender
QString ColorSettings::defaultDataDirColor = "#e3e4fa"; // lavender
QString ColorSettings::defaultDataDirNameColor = "#4169e1"; // RoyalBlue

QString ColorSettings::defaultStyle = QString() + 
	"ColorSettings { qproperty-rawColor: " + ColorSettings::defaultRawColor
	+ "; qproperty-rvaColor: " + ColorSettings::defaultRvaColor
	+ "; qproperty-vaColor: " + ColorSettings::defaultVaColor
	+ "; qproperty-flagsColor: " + ColorSettings::defaultFlagsColor
	+ "; qproperty-dataDirColor: " + ColorSettings::defaultDataDirColor
	+ "; qproperty-dataDirNameColor: " + ColorSettings::defaultDataDirNameColor
	+ "; }";

QColor ColorSettings::addrTypeToColor(const Executable::addr_type &aT) const
{
	QColor addrColor = QColor();
	switch (aT) {
		case Executable::RAW:
			addrColor = rawColor();
			break;
		case Executable::RVA:
			addrColor = rvaColor();
			break;
		case Executable::VA:
			addrColor = vaColor();
			break;
	}
	return addrColor;
}

//--------------------

t_reload_mode intToReloadMode(int val)
{
	if (val < 0 || val >= RELOAD_MODES_COUNT) {
		return RELOAD_ASK;
	}
	return (t_reload_mode) val;
}

////

bool MainSettings::readPersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	this->autoSaveTags = settings.value("AutoSaveTags", true).toBool();
	this->autoReloadOnFileChange = intToReloadMode(settings.value("AutoReloadOnChage", RELOAD_ASK).toInt());
	this->uDataDir = settings.value("UDD", "").toString();
	this->followOnClick = settings.value("FollowOnClick", false).toBool();
	this->lExePath = settings.value("LastOpened", false).toString();
	this->dirDump = settings.value("LastDumpDir", false).toString();

	if (settings.status() != QSettings::NoError ) {
		return false;
	}
	return true;
}

bool MainSettings::writePersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	settings.setValue("UDD", uDataDir);
	settings.setValue("AutoSaveTags", autoSaveTags);
	settings.setValue("AutoReloadOnChage", autoReloadOnFileChange);
	settings.setValue("FollowOnClick", followOnClick);
	settings.setValue("LastOpened", this->lExePath);
	settings.setValue("LastDumpDir", this->dirDump);

	if ( settings.status() == QSettings::NoError ) {
		return true;
	}
	return false;
}
//--------------------

bool writeFontProperties(QSettings &settings, QFont &font, QString propertyName)
{
	settings.setValue(propertyName, font.toString());
	settings.setValue(propertyName + ".size", font.pointSize());
	
	if ( settings.status() == QSettings::NoError ) {
		return true;
	}
	return false;
}

QFont readFontProperties(QSettings &settings, QString propertyName, QFont defaultFont)
{
	const QString defaultFontString = defaultFont.toString();
	const int defaultFontSize = defaultFont.pointSize();

	QString fontStr = settings.value(propertyName, defaultFontString).toString();
	if (settings.status() != QSettings::NoError ) {
		return defaultFont;
	}
	QFont font(fontStr);
	font.fromString(fontStr);
	font.setPointSize(settings.value(propertyName + ".size", defaultFontSize).toInt());
	if (settings.status() != QSettings::NoError ) {
		return defaultFont;
	}
	return font;
}

bool GuiSettings::readPersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	
	QFont gFont = readFontProperties(settings, "globalFont", this->defaultGlobalFont);
	QFont hFont =  readFontProperties(settings, "hexFont", HexViewSettings::defaultFont());
	QFont dFont = readFontProperties(settings, "disasmFont", DisasmViewSettings::defaultFont());
	QString styleName = settings.value("style", "").toString();
	
	this->_setGlobalFont(gFont);
	this->_setDisasmViewFont(dFont);
	this->_setHexViewFont(hFont);

	this->setStyleByName(styleName);

	emit globalFontChanged();
	emit hexViewSettingsChanged(hexVSettings);
	emit disasmViewSettingsChanged(disasmVSettings);
	
	if (settings.status() != QSettings::NoError ) {
		return false;
	}
	return true;
}

bool GuiSettings::writePersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	
	QFont currFont = QApplication::font();
	writeFontProperties(settings, currFont, "globalFont");
	writeFontProperties(settings, this->hexVSettings.myFont, "hexFont");
	writeFontProperties(settings, this->disasmVSettings.myFont, "disasmFont");
	
	// save the style:
	settings.setValue("style", this->currentStyle);
	
	if ( settings.status() == QSettings::NoError ) {
		return true;
	}
	return false;
}

void GuiSettings::initStyles()
{
	this->defaultStylesheet = qApp->styleSheet();
	this->defaultStyleName = "*System Default*";

	nameToStyle[this->defaultStyleName] = this->defaultStylesheet;
	nameToStyle["Dark"] = g_DarkStyle;
}

```

`pe-bear/base/MainSettings.h`:

```h
#pragma once
#include <QtCore>
#include <bearparser/bearparser.h>
#include "../ViewSettings.h"

#define APP_NAME "PE-bear"
#define COMPANY_NAME APP_NAME

//--------------------

class ColorSettings : public QWidget
{
	Q_OBJECT
	Q_PROPERTY(QColor rawColor	READ rawColor	WRITE setRawColor)
	Q_PROPERTY(QColor rvaColor	READ rvaColor	WRITE setRvaColor)
	Q_PROPERTY(QColor vaColor	READ vaColor	WRITE setVaColor)
	
	Q_PROPERTY(QColor flagsColor	READ flagsColor	WRITE setFlagsColor)
	Q_PROPERTY(QColor dataDirColor	READ dataDirColor	WRITE setDataDirColor)
	Q_PROPERTY(QColor dataDirNameColor	READ dataDirNameColor	WRITE setDataDirNameColor)
	
public:
	static QString defaultRawColor, defaultRvaColor, defaultVaColor,
		defaultFlagsColor, defaultDataDirColor, defaultDataDirNameColor;

	static QString defaultStyle;
	
	ColorSettings()
	{
		init();
	}
	
	void setRawColor(const QColor &_rawColor)
	{
		this->m_rawColor = _rawColor;
	}
	
	QColor rawColor() const
	{
		return m_rawColor;
	}
	
	void setRvaColor(const QColor &_rvaColor)
	{
		this->m_rvaColor = _rvaColor;
	}
	
	QColor rvaColor() const
	{
		return m_rvaColor;
	}
	
	void setVaColor(const QColor &_vaColor)
	{
		this->m_vaColor = _vaColor;
	}
	
	QColor vaColor() const
	{
		return m_vaColor;
	}
	
	QColor addrTypeToColor(const Executable::addr_type &aT) const;
	
	void setFlagsColor(const QColor &_flagsColor)
	{
		this->m_flagsColor = _flagsColor;
	}
	
	QColor flagsColor() const
	{
		return m_flagsColor;
	}

	int flagsAlpha() const
	{
		return 200;
	}

	void setDataDirColor(const QColor &_dataDirColor)
	{
		this->m_dataDirColor = _dataDirColor;
	}
	
	QColor dataDirColor() const
	{
		return m_dataDirColor;
	}

	void setDataDirNameColor(const QColor &_dataDirNameColor)
	{
		this->m_dataDirNameColor = _dataDirNameColor;
	}
	
	QColor dataDirNameColor() const
	{
		return m_dataDirNameColor;
	}
	
	int dataDirNameAlpha() const
	{
		return 150;
	}
	
private:
	virtual void init()
	{
		m_rawColor = QColor(defaultRawColor);
		m_rvaColor = QColor(defaultRvaColor);
		m_vaColor = QColor(defaultVaColor);
		
		m_flagsColor = QColor(defaultFlagsColor);
		m_dataDirColor = QColor(defaultDataDirColor);
		m_dataDirNameColor = QColor(defaultDataDirNameColor);
	}

	QColor m_rawColor, m_rvaColor, m_vaColor;
	QColor m_flagsColor;
	QColor m_dataDirColor;
	QColor m_dataDirNameColor;
};

//--------------------

class GuiSettings : public QObject
{
	Q_OBJECT

signals:
	void disasmViewSettingsChanged(DisasmViewSettings&);
	void hexViewSettingsChanged(HexViewSettings&);
	void globalFontChanged();

private slots:
	void resetStyleSheet()
	{
		QString style = qApp->styleSheet();
		if (style.length() > 0) {
			qApp->setStyleSheet(qApp->styleSheet());
		}
	}

public:
	GuiSettings() 
	: QObject(),
		hexVSettings(), disasmVSettings()
	{
		initDefaultGlobalFont();
		initStyles();
	}

	bool readPersistent();
	bool writePersistent();

	void resetFontsToDefaults()
	{
		QApplication::setFont(defaultGlobalFont);
		hexVSettings.myFont = HexViewSettings::defaultFont();
		disasmVSettings.myFont = DisasmViewSettings::defaultFont();
		
		resetStyleSheet();
		
		emit globalFontChanged();
		emit disasmViewSettingsChanged(disasmVSettings);
		emit hexViewSettingsChanged(hexVSettings);
	}
	
	void resetSizesToDefaults()
	{
		QFont currFont = QApplication::font();
		currFont.setPointSize(defaultGlobalFont.pointSize());
		QApplication::setFont(currFont);
		
		hexVSettings.myFont.setPointSize(HexViewSettings::defaultFont().pointSize());
		disasmVSettings.myFont.setPointSize(DisasmViewSettings::defaultFont().pointSize());
		
		resetStyleSheet();

		emit globalFontChanged();
		emit disasmViewSettingsChanged(disasmVSettings);
		emit hexViewSettingsChanged(hexVSettings);
	}
	
	void setGlobalFont(QFont &font)
	{
		_setGlobalFont(font);
		resetStyleSheet();
		emit globalFontChanged();
	}

	void setHexViewFont(QFont &font)
	{
		if (_setHexViewFont(font)) {
			resetStyleSheet();
			emit hexViewSettingsChanged(hexVSettings);
		}
	}
	
	void setDisasmViewFont(QFont &font)
	{
		if (_setDisasmViewFont(font)) {
			resetStyleSheet();
			emit disasmViewSettingsChanged(disasmVSettings);

		}
	}
	
	void zoomHexViewFont(bool zoomIn)
	{
		if (zoomFont(this->hexVSettings.myFont, zoomIn)) {
			resetStyleSheet();
			emit hexViewSettingsChanged(hexVSettings);
		}
	}
	
	void zoomDisasmViewFont(bool zoomIn)
	{
		if (zoomFont(this->disasmVSettings.myFont, zoomIn)) {
			resetStyleSheet();
			emit disasmViewSettingsChanged(disasmVSettings);
		}
	}

	void zoomGlobalFont(bool zoomIn)
	{
		if (_zoomGlobalFont(zoomIn)) {
			emit globalFontChanged();
		}
	}
	
	void zoomAllFonts(bool zoomIn)
	{
		enum el_states { GLOBAL, HEX, DISASM, COUNT };
		int state[COUNT] = { 0 };
		state[GLOBAL] = _zoomGlobalFont(zoomIn);
		state[HEX] = _zoomHexViewFont(zoomIn);
		state[DISASM] = _zoomDisasmViewFont(zoomIn);
		
		if (state[GLOBAL] || state[HEX] || state[DISASM]) {
			resetStyleSheet();
			emit globalFontChanged();
			emit hexViewSettingsChanged(hexVSettings);
			emit disasmViewSettingsChanged(disasmVSettings);
		}
	}
	
	void resetFonts()
	{
		QFont currFont = QApplication::font();
		_setGlobalFont(currFont);

		emit globalFontChanged();
	}
	
	QFont getHexViewFont()
	{
		return hexVSettings.myFont;
	}
	
	QFont getDisasmViewFont()
	{
		return disasmVSettings.myFont;
	}

	void setDefaultStyle()
	{
		qApp->setStyleSheet(defaultStylesheet);
		qApp->setStyleSheet(ColorSettings::defaultStyle);
		qApp->setStyleSheet("QLineEdit[readOnly=\"true\"]{ border: 2px ridge gray; }");
		resetFonts();
		this->currentStyle = "";
	}

	void setStyleByName(const QString &name)
	{
		if (this->nameToStyle.contains(name)) {
			const QString styleSheet = this->nameToStyle.value(name);
			
			if (styleSheet.length() != 0) {
				qApp->setStyleSheet(styleSheet);
				resetFonts();
				this->currentStyle = name;
				return;
			}
		}
		// set default style:
		setDefaultStyle();
	}
	
	QList<QString> getStyles()
	{
		return this->nameToStyle.keys();
	}
	
	QString currentStyleName()
	{
		if (this->currentStyle.length() == 0) {
			return this->defaultStyleName;
		}
		return this->currentStyle;
	}
	
protected:
	void _setGlobalFont(QFont &font)
	{
		qApp->setFont(font);
	}

	bool _setHexViewFont(QFont &font)
	{
		if (font == hexVSettings.myFont) {
			return false;
		}
		hexVSettings.myFont = font;
		return true;
	}

	bool _setDisasmViewFont(QFont &font)
	{
		if (font == hexVSettings.myFont) {
			return false;
		}
		disasmVSettings.myFont = font;
		return true;
	}

	bool zoomFont(QFont &font, bool zoomIn)
	{
		const int val = (zoomIn) ? 1 : (-1);
		const int minFontSize = 4;
		
		if (zoomIn || font.pointSize() > minFontSize) {
			font.setPointSize(font.pointSize() + val);
			return true;
		}
		return false;
	}
	
	bool _zoomGlobalFont(bool zoomIn)
	{
		QFont gFont = QApplication::font();
		if (zoomFont(gFont, zoomIn)) {
			_setGlobalFont(gFont);
			return true;
		}
		return false;
	}
	
	bool _zoomDisasmViewFont(bool zoomIn)
	{
		return (zoomFont(this->disasmVSettings.myFont, zoomIn));
	}
	
	bool _zoomHexViewFont(bool zoomIn)
	{
		return (zoomFont(this->hexVSettings.myFont, zoomIn));
	}
	
	void initDefaultGlobalFont()
	{
		// retrieve a default system font before loading the saved settings:
		defaultGlobalFont = QApplication::font();
	}

	void initStyles();

	QFont defaultGlobalFont;
	QString defaultStylesheet;
	
	QMap<QString, QString> nameToStyle;
	QString currentStyle;
	QString defaultStyleName;

	//current settings:
	HexViewSettings hexVSettings;
	DisasmViewSettings disasmVSettings;
};

//--------------------

typedef enum _reload_mode {
	RELOAD_ASK = 0,
	RELOAD_IGNORE = 1,
	RELOAD_AUTO = 2,
	RELOAD_MODES_COUNT
} t_reload_mode;

t_reload_mode intToReloadMode(int val);

////

class MainSettings : public QObject
{
	Q_OBJECT
	Q_PROPERTY(bool isFollowOnClick READ isFollowOnClick WRITE setFollowOnClick)
	Q_PROPERTY(bool autoSaveTags READ isAutoSaveTags WRITE setAutoSaveTags)
	Q_PROPERTY(t_reload_mode reloadOnFileChange READ isReloadOnFileChange WRITE setReloadOnFileChange )
	
	Q_PROPERTY(QString uDataDir READ userDataDir WRITE setUserDataDir)
	Q_PROPERTY(QString lExePath READ lastExePath WRITE setLastExePath)

signals:
	void settingsChanged();

public:
	MainSettings() : QObject(), followOnClick(false), autoSaveTags(true), autoReloadOnFileChange(RELOAD_ASK), uDataDir("") {}

	void setFollowOnClick(bool enable) {  this->followOnClick = enable; emit settingsChanged(); }
	bool isFollowOnClick() const { return this->followOnClick; }

	void setUserDataDir(QString newUDD) { this->uDataDir = newUDD; emit settingsChanged(); }
	QString userDataDir() { return uDataDir; }

	void setLastExePath(const QString path) { this->lExePath = path; }
	QString lastExePath() { return lExePath; }

	void setAutoSaveTags(bool enable) {  this->autoSaveTags = enable; emit settingsChanged(); }
	bool isAutoSaveTags() const { return this->autoSaveTags; }

	void setReloadOnFileChange(t_reload_mode enable) {  this->autoReloadOnFileChange = enable; emit settingsChanged(); }
	t_reload_mode isReloadOnFileChange() const { return this->autoReloadOnFileChange; }

	bool readPersistent();
	bool writePersistent();

	QString dirDump;

protected:
	bool followOnClick;
	QString uDataDir;
	QString lExePath;
	bool autoSaveTags;
	t_reload_mode autoReloadOnFileChange;
};

```

`pe-bear/base/Modification.cpp`:

```cpp
#include "Modification.h"

#include <algorithm>
	
ModifBackup::ModifBackup(AbstractByteBuffer* file, offset_t modOffset, bufsize_t modSize)
	: buffer(NULL), offset(INVALID_ADDR), size(0)
{
	if (!file) throw CustomException("Uninitialized file");
	
	BYTE *content = file->getContent();
	if (!content) throw CustomException("File buffer is NULL!");

	//fetch the file fragment at the offset where the modification will happen:
	BYTE *modPtr = file->getContentAt(modOffset, modSize);
	if (!modPtr) {
		throw CustomException("Could not fetch the content at the offset!");
	}

	//allocate a buffer to store the patch:
	this->buffer = (BYTE*) calloc(modSize, sizeof(BYTE));
	if (!buffer) throw CustomException("Cannot allocate modification buffer!");
	
	this->offset = modOffset;
	this->size = modSize;

	//store the backup in the patch buffer:
	::memcpy(buffer, modPtr, modSize);
}

ModifBackup::~ModifBackup()
{
	if (buffer) free(buffer);
}

bool ModifBackup::apply(AbstractByteBuffer* file)
{
	if (!file) return false;

	BYTE *modPtr = file->getContentAt(this->offset, this->size);
	
	if (!modPtr) {
		std::cerr << "Cannot apply backup at: " << std::hex << this->offset << "  on the given file! Area size mismatch!" << std::endl;
		return false;
	}

	::memcpy(modPtr, this->buffer, this->size);
	return true;
}

bool ModifBackup::isOffsetAffected(offset_t curr_offset)
{
	const offset_t modS = getOffset();
	const offset_t modE = modS + getSize();

	return (curr_offset >= modS && curr_offset < modE);
}
//-------

void OperationBackup::deleteChildren()
{
	std::vector<ModifBackup*>::iterator itr =  modifs.begin();

	while (itr != modifs.end()) {
		ModifBackup* modif = *itr;
		++itr;
		delete modif;
	}
	this->clear();
}

bool OperationBackup::contains(ModifBackup* backup)
{
	if (!backup) return false;
	std::vector<ModifBackup*>::iterator found = find(modifs.begin(), modifs.end(), backup);

	if (found != modifs.end()) {
		return true;
	}
	return false;
}

bool OperationBackup::appendBackup(ModifBackup* backup)
{
	if (!backup) return false;
	if (contains(backup)) return false;

	modifs.push_back(backup);
	return true;
}


bool OperationBackup::removeBackup(ModifBackup* backup) //it is not deleting object!
{
	if (!backup) return false;

	std::vector<ModifBackup*>::iterator found = find(modifs.begin(), modifs.end(), backup);

	if (found != modifs.end()) {
		modifs.erase(found);
		return true;
	}
	return false;
}

size_t OperationBackup::undoOperation(AbstractByteBuffer* file)
{
	size_t undone = 0;

	for (std::vector<ModifBackup*>::iterator itr = modifs.begin(); 
		itr != modifs.end(); 
		++itr)
	{
		ModifBackup* modif = *itr;
		if (!modif) continue;
		if (modif->apply(file)) undone++;
	}
	return undone;
}

bool OperationBackup::isOffsetAffected(offset_t offset)
{
	for (std::vector<ModifBackup*>::iterator itr = modifs.begin();
		itr != modifs.end();
		++itr)
	{
		ModifBackup* modif = *itr;
		if (!modif) continue;
		if (modif->isOffsetAffected(offset)) return true;
	}
	return false;
}
//----

ModificationHandler::ModificationHandler(AbstractByteBuffer* fileBuffer, QObject* parent)
	: QObject(parent)
{
	if (!fileBuffer) throw CustomException("Uninitialized file");
	this->file = fileBuffer;
}

ModificationHandler::~ModificationHandler()
{
	while (modifs.size()) {
		OperationBackup* backup = modifs.top();
		modifs.pop();
		delete backup;
	}
}

bool ModificationHandler::backupModification(offset_t modifOffset, bufsize_t modifSize, bool continueLastOperation)
{
	if (modifOffset == INVALID_ADDR || !modifSize) return false;

	bool isOk = true;
	try {
		OperationBackup *last = this->getLastOperation();
		if (!continueLastOperation || !last) {
			store(modifOffset, modifSize);
		} else {
			isOk = last->appendBackup(new ModifBackup(this->file, modifOffset, modifSize));
		}

	} catch (CustomException &e) {
		std::cerr << "Backup error: " << e.what() << std::endl;
		isOk = false;
	}
	return isOk;
}

void ModificationHandler::store(offset_t modOffset, bufsize_t modSize)
{
	try {
		ModifBackup * modif = new ModifBackup(file, modOffset, modSize);
		OperationBackup * backup = new OperationBackup(modif);
		storeOperation(backup);
	}
	catch (CustomException &e)
	{
		std::cerr << "Backup error: " << e.what() << std::endl;
	}
}

bool ModificationHandler::unStoreLast()
{
	if (modifs.size() == 0) return false;

	OperationBackup* last = modifs.top();
	//TODO... do not remove full if have to destroy only one modification in operation!
	modifs.pop();
	delete last;

	return true;
}

bool ModificationHandler::undoLastOperation()
{
	OperationBackup* op = getLastOperation();
	if (!op) return false;

	size_t undone = 0;
	for (std::vector<ModifBackup*>::iterator itr = op->modifs.begin();
		itr != op->modifs.end();
		++itr)
	{
		ModifBackup* patch = *itr;
		if (!patch) continue;

		if (patch->apply(this->file)) {
			undone++;
		}
	}
	this->unStoreLast();
	return undone ? true : false;
}

OperationBackup* ModificationHandler::getLastOperation()
{
	if (modifs.size() == 0) return NULL;
	return modifs.top();
}

ModifBackup* ModificationHandler::getLastModif()
{
	OperationBackup* op = getLastOperation();
	if (!op) return NULL;

	if (op->modifs.size() == 0) return NULL;

	ModifBackup* mod = op->modifs.back();
	return mod;
}


```

`pe-bear/base/Modification.h`:

```h
#pragma once

#include <QtCore>
#include <stack>

#include <bearparser/bearparser.h>

class ModifBackup
{
public:
	ModifBackup(AbstractByteBuffer *fileBuffer, offset_t modOffset, bufsize_t modSize);
	~ModifBackup();

	bufsize_t getSize() { return size; }
	offset_t getOffset() { return offset; }

	bool apply(AbstractByteBuffer* file);
	bool isOffsetAffected(offset_t offset);

protected:
	BYTE* buffer;
	bufsize_t size;
	offset_t offset;

friend class ModificationHandler;
};

class OperationBackup
{
public:
	OperationBackup() {}

	OperationBackup(ModifBackup* backup)
	{
		appendBackup(backup);
	}

	~OperationBackup() { deleteChildren(); }

	 /* NOT deleting objects! */
	void clear() { modifs.clear(); }

	 /* deleting objects! */
	void deleteChildren();

	bool contains(ModifBackup* backup);
	bool appendBackup(ModifBackup* backup);

	/* removes from vector, not deleting object! */
	bool removeBackup(ModifBackup* backup);

	/* returns: how many modifications undone, not deleting objects! */
	size_t undoOperation(AbstractByteBuffer* file);
	
	bool isOffsetAffected(offset_t offset);

protected:
	std::vector<ModifBackup*> modifs;

friend class ModificationHandler;
};

class ModificationHandler : public QObject
{
	Q_OBJECT
public:
	ModificationHandler(AbstractByteBuffer* fileBuffer, QObject* parent);
	~ModificationHandler();

	bool backupModification(offset_t modifOffset, bufsize_t modifSize, bool continueLastOperation);

	/* unstore last operation - delete object */
	bool unStoreLast();

	bool undoLastOperation();

	size_t countOperations()
	{
		return modifs.size();
	}

	bool isInLastModifiedArea(offset_t offset)
	{
		OperationBackup* op = this->getLastOperation();
		if (!op) return false;

		return op->isOffsetAffected(offset);
	}

	offset_t getLastModifiedOffset()
	{
		ModifBackup* mod = this->getLastModif();
		if (!mod) {
			return INVALID_ADDR;
		}
		return mod->getOffset();
	}

protected:
	
	/* Creates operation with single modification. Throws a CustomException of error. */
	void store(offset_t modOffset, bufsize_t modSize);

	/* stores already prepared operation */
	void  storeOperation(OperationBackup* backup)
	{
		if (!backup) return;
		this->modifs.push(backup);
	}

	OperationBackup* getLastOperation();
	ModifBackup* getLastModif();

	AbstractByteBuffer* file;
	std::stack< OperationBackup* > modifs;
};

```

`pe-bear/base/PeHandler.cpp`:

```cpp
#include <new>
#include "PeHandler.h"

#include "../base/PeHandlersManager.h"
#include <bearparser/bearparser.h>

using namespace sig_ma;
using namespace pe;

enum operation_ids { SIMPLE = 0, OP_ADD_SECTION = 1 };


CalcThread::CalcThread(CalcThread::hash_type hType, PEFile* pe, offset_t checksumOffset)
	: m_PE(pe), hashType(hType), checksumOff(checksumOffset)
{
}

void CalcThread::run()
{
	QMutexLocker lock(&m_arrMutex);

	QString fileHash = "Cannot calculate!";
	if (!m_PE || !m_PE->getContent()) {
		emit gotHash(fileHash, hashType);
		return;
	}
	QCryptographicHash::Algorithm qHashType = QCryptographicHash::Md5;
	if (hashType == MD5) {
		qHashType = QCryptographicHash::Md5;
	} else if (hashType == SHA1) {
		qHashType = QCryptographicHash::Sha1;
	} 
#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0) //the feature was introduced in Qt5.0
	else if (hashType == SHA256) {
		qHashType = QCryptographicHash::Sha256;
	}
#endif
	try {
		if (hashType == CHECKSUM) {
			long checksum = PEFile::computeChecksum((BYTE*) m_PE->getContent(), m_PE->getContentSize(), checksumOff);
			fileHash = QString::number(checksum, 16);
		} else {
			QCryptographicHash calcHash(qHashType);
			calcHash.addData((char*) m_PE->getContent(), m_PE->getContentSize());
			fileHash = QString(calcHash.result().toHex());
		}
	} catch (...) {
		fileHash = "Cannot calculate!";
	}
	emit gotHash(fileHash, hashType);
}

//-------------------------------------------------
PeHandler::PeHandler(PEFile *pe, FileBuffer *fileBuffer)
	: QObject(), 
	m_fileModDate(QDateTime()), // init with empty
	m_loadedFileModDate(QDateTime()), // init with empty
	dosHdrWrapper(pe), 
	fileHdrWrapper(pe), optHdrWrapper(pe), richHdrWrapper(pe), dataDirWrapper(pe),
	exportDirWrapper(pe), importDirWrapper(pe), tlsDirWrapper(pe), relocDirWrapper(pe), 
	securityDirWrapper(pe), ldConfDirWrapper(pe), boundImpDirWrapper(pe),
	delayImpDirWrapper(pe), debugDirWrapper(pe), exceptDirWrapper(pe), clrDirWrapper(pe),
	resourcesAlbum(pe),
	resourcesDirWrapper(pe, &resourcesAlbum),
	signFinder(NULL), 
	modifHndl(pe->getFileBuffer(), this)
{
	if (!pe) return;

	m_PE = pe;
	m_fileBuffer = fileBuffer;

	markedTarget = INVALID_ADDR;
	markedOrigin = INVALID_ADDR;

	displayedOffset = 0;
	displayedSize = 0;

	this->hoveredOffset = INVALID_ADDR;
	this->hoveredSize = 0;
	this->hilightedOffset = INVALID_ADDR;
	this->hilightedSize = 0;
	pageStart = 0;
	pageSize = PREVIEW_SIZE;
	
	updateFileModifTime();
	m_loadedFileModDate = m_fileModDate; // init
	
	associateWrappers();
	this->wrapAlbum();
	
	for (int i = 0; i < CalcThread::HASHES_NUM; i++) {
		calcThread[i] = NULL;
		calcQueued[i] = false;
	}
	//---
	this->runHashesCalculation();
}

void PeHandler::associateWrappers()
{
	// clear associations
	for (int i = 0; i < DIR_ENTRIES_COUNT ; i++) {
		dataDirWrappers[i] = NULL;
	}
	// make associations
	dataDirWrappers[DIR_EXPORT] = &exportDirWrapper;
	dataDirWrappers[DIR_IMPORT] = &importDirWrapper;
	dataDirWrappers[DIR_TLS] = &tlsDirWrapper;
	dataDirWrappers[DIR_BASERELOC] = &relocDirWrapper;

	dataDirWrappers[DIR_SECURITY] = &securityDirWrapper;
	dataDirWrappers[DIR_LOAD_CONFIG] = &ldConfDirWrapper;
	dataDirWrappers[DIR_BOUND_IMPORT] = &boundImpDirWrapper;

	dataDirWrappers[DIR_DELAY_IMPORT] = &delayImpDirWrapper;
	dataDirWrappers[DIR_DEBUG] = &debugDirWrapper;
	dataDirWrappers[DIR_EXCEPTION] = &exceptDirWrapper;
	dataDirWrappers[DIR_RESOURCE] = &resourcesDirWrapper;
	dataDirWrappers[DIR_COM_DESCRIPTOR] = &clrDirWrapper;
}

bool PeHandler::hasDirectory(dir_entry dirNum)
{
	if (dirNum >= DIR_ENTRIES_COUNT) return false;

	if (!this->m_PE || !this->m_PE->hasDirectory(dirNum)) return false;

	if (!dataDirWrappers[dirNum]) return false;
	if (!dataDirWrappers[dirNum]->getPtr()) return false;
	return true;
}

QString PeHandler::getCurrentHash(CalcThread::hash_type type)
{
	QMutexLocker ml(&m_hashMutex[type]);
	return hash[type];
}

void PeHandler::onHashReady(QString hash, int hType)
{
	if (hType >= CalcThread::HASHES_NUM) return;
	QMutexLocker ml(&m_hashMutex[hType]);
	this->hash[hType] = hash;
	emit hashChanged();
}

void PeHandler::onCalcThreadFinished()
{
	for (int hType = 0; hType < CalcThread::HASHES_NUM; hType++) {
		if (calcThread[hType] != NULL && calcThread[hType]->isFinished()) {
			delete calcThread[hType];
			calcThread[hType] = NULL;
			if (calcQueued[hType]) {
				//printf("starting queued\n");
				calculateHash((CalcThread::hash_type) hType);
			}
		}
	}
}

void PeHandler::deleteThreads()
{
	for (int hType = 0; hType < CalcThread::HASHES_NUM; hType++) {
		if (calcThread[hType] != NULL) {
			while (calcThread[hType]->isFinished() == false) {
				calcThread[hType]->wait();
			}
			delete calcThread[hType];
			calcThread[hType] = NULL;
		}
	}
}

void PeHandler::calculateHash(CalcThread::hash_type type)
{
	if (type >= CalcThread::HASHES_NUM) return;
	
	if (calcThread[type] != NULL) {
		calcQueued[type] = true;
		return; //previous thread didn't finished
	}
	const char* content = (char*) m_PE->getContent();
	const offset_t size = m_PE->getRawSize();
	const bool isSizeAcceptable = (offset_t(int(size)) == size) ? true : false;

	if (!content || !size || !isSizeAcceptable) {
		hash[type] = "Cannot calculate!";
	} else {
		hash[type] = "Calculating...";
		offset_t checksumOffset = this->optHdrWrapper.getFieldOffset(OptHdrWrapper::CHECKSUM);
		this->calcThread[type] = new CalcThread(type, m_PE, checksumOffset);
		QObject::connect(calcThread[type], SIGNAL(gotHash(QString, int)), this, SLOT(onHashReady(QString, int)));
		QObject::connect(calcThread[type], SIGNAL(finished()), this, SLOT(onCalcThreadFinished()));
		calcThread[type]->start();
		calcQueued[type] = false;
	}
}

void PeHandler::setPackerSignFinder(SigFinder *sFinder)
{
	this->signFinder = sFinder;
	findPackerSign(m_PE->getEntryPoint(), Executable::RVA, sig_ma::FIXED);
}

bool PeHandler::isPacked()
{
	return (this->packerAtOffset.size() > 0);
}

PckrSign* PeHandler::findPackerSign(offset_t startAddr, Executable::addr_type aT, match_direction md)
{
	if (!signFinder || !m_PE) return NULL;
	BYTE* content = m_PE->getContent();
	if (!content) return NULL;
	size_t contentSize = m_PE->getRawSize();

	offset_t startingRaw = m_PE->toRaw(startAddr, aT);
	if (startingRaw == INVALID_ADDR) return NULL;

	sig_ma::matched matchedSet = signFinder->getMatching(content, contentSize, startingRaw, md);
	int foundCount = matchedSet.signs.size();
	if (foundCount == 0) return NULL;

	PckrSign* packer = *(matchedSet.signs.begin());
	if (!packer) foundCount = 0;

	if (foundCount > 0) {
		FoundPacker pckr(startingRaw + matchedSet.match_offset, packer);
		std::vector<FoundPacker>::iterator itr = std::find(this->packerAtOffset.begin(), this->packerAtOffset.end(), pckr);

		if (itr != this->packerAtOffset.end()) { //already exist
			FoundPacker &found = *itr;
			packer = found.signaturePtr;
		} else {
			this->packerAtOffset.push_back(pckr);
		}
	}

	emit foundSignatures(foundCount, 0);
	return packer;
}


PckrSign* PeHandler::findPackerInArea(offset_t rawOff, size_t areaSize, sig_ma::match_direction md)
{
	if (!signFinder || !m_PE) return NULL;
	
	BYTE *content = NULL;

	bool isDeepSearch = false;
	offset_t foundOffset = 0;
	PckrSign* packer = NULL;
	int foundCount = 0;

	for (size_t step = 0; step < areaSize; step++) {

		size_t size = areaSize - step;
		content = m_PE->getContentAt(rawOff + step, Executable::RAW, size);
		if (content == NULL) {
			//printf("content is NULL\n");
			break;
		}
		sig_ma::matched matchedSet = signFinder->getMatching(content, size, 0, md);
		
		foundCount += matchedSet.signs.size();
		if (matchedSet.signs.size() == 0) break;

		packer = *(matchedSet.signs.begin());
		if (!packer) break;
		
		foundOffset = step + matchedSet.match_offset + rawOff;
		//printf("Found %s, at %x searching next...\n", packer->get_name().c_str(), foundOffset);

		step += matchedSet.match_offset;
		FoundPacker pckr(foundOffset , packer);
		std::vector<FoundPacker>::iterator itr = std::find(this->packerAtOffset.begin(), this->packerAtOffset.end(), pckr);
		if (itr != this->packerAtOffset.end()) {
			//already exist
			FoundPacker &found = *itr;
			packer = found.signaturePtr;
			continue;
		} else {
			this->packerAtOffset.push_back(pckr);
		}
		if (isDeepSearch == false) break;
	}

	emit foundSignatures(foundCount, 1);
	return packer;
}


void PeHandler::setHilighted(offset_t hOffset, uint32_t hSize)
{
	this->hilightedOffset = hOffset;
	this->hilightedSize = hSize;
}

void PeHandler::setHovered(bool isRVA, offset_t hOffset, uint32_t hSize)
{
	if (!m_PE) return;

	Executable::addr_type aType = isRVA ? Executable::RVA : Executable::RAW;
	offset_t raw =  m_PE->toRaw(hOffset, aType);
	if (raw == INVALID_ADDR) return;
	
	hOffset = raw;
	if (this->hoveredOffset == hOffset && this->hoveredSize == hSize) return;

	this->hoveredOffset = hOffset;
	this->hoveredSize = hSize;
	emit hovered();
}

bool PeHandler::setDisplayed(bool isRVA, offset_t dOffset, bufsize_t dSize)
{
	if (!m_PE) return false;

	Executable::addr_type aType = isRVA ? Executable::RVA : Executable::RAW;
	offset_t raw =  m_PE->toRaw(dOffset, aType);
	if (raw == INVALID_ADDR) return false;

	dOffset = raw;
	if (dOffset >= this->m_PE->getRawSize()) { //out of scope!
		dOffset = this->m_PE->getRawSize();
		dSize = 0;
	}
	/* store previous */
	offset_t prevOff = this->displayedOffset;
	if (prevOff >= 0) this->prevOffsets.push(prevOff);

	/* set current */ 
	this->displayedOffset = dOffset;
	if (dSize != SIZE_UNLIMITED) {
		this->displayedSize = dSize;
	}
	setPageOffset(this->displayedOffset);
	return true;
}

void  PeHandler::undoDisplayOffset()
{
	if (this->prevOffsets.size() == 0) return;

	uint32_t prevOff =  this->prevOffsets.top();
	this->prevOffsets.pop();
	this->displayedOffset = prevOff;
//	emit displayAreaModified(this->displayedOffset, this->displayedSize);
	setPageOffset(this->displayedOffset);
}

void PeHandler::setPageOffset(offset_t pageO)
{
	pageStart = pageO;
	emit pageOffsetModified(this->pageStart, this->pageSize);
}

void PeHandler::advanceOffset(int increment)
{ 
	offset_t page = pageStart;

	if (increment < 0) {
		increment *= (-1);
		if (increment > page) 
			page = 0;
		else 
			page -= increment;
	} else {
		offset_t max = m_PE->getRawSize();
		if (page + increment > max) 
			page = max;
		else 
			page += increment;
	}

	setPageOffset(page);
}


bool PeHandler::setDisplayedEP()
{
	if (!this->m_PE) return false;
	bool isOk = true;
	offset_t epRVA = this->m_PE->getEntryPoint();
	//
	offset_t epOff = 0;
	try {
		epOff = m_PE->rvaToRaw(epRVA);
	} catch (CustomException &e) {
		isOk = false;
	}
	if (!isOk) return false;
	//
	offset_t dispO = epOff;
	bufsize_t dispS = this->m_PE->getRawSize() - epOff;
	setDisplayed(false, dispO, dispS);
	return true;
}

bool PeHandler::isDataDirModified(offset_t modO, bufsize_t modS)
{
	BYTE *content = m_PE->getContent();
	bufsize_t contentSize = m_PE->getRawSize();
	IMAGE_DATA_DIRECTORY* dir = this->m_PE->getDataDirectory();
	if (content && dir) {
		offset_t offsetS = ((BYTE*) dir) - content;
		offset_t offsetE = offsetS + (sizeof(IMAGE_DATA_DIRECTORY) * pe::DIR_ENTRIES_COUNT);
		
		offset_t modE = modO + modS;
		if ((modO >= offsetS && modO <= offsetE) || (modE >= offsetS && modE <= offsetE)) {
				return true;
		}
	}
	return false;
}

bool PeHandler::isSectionsHeadersModified(offset_t modO, bufsize_t modSize)
{
	BYTE *content = m_PE->getContent();
	size_t contentSize = m_PE->getRawSize();
	if (!content) return false;
	offset_t modE = modO + modSize;

	offset_t optOff = this->fileHdrWrapper.getFieldOffset(FileHdrWrapper::OPTHDR_SIZE);
	bufsize_t optSize = this->fileHdrWrapper.getFieldSize(FileHdrWrapper::OPTHDR_SIZE);
	
	if (modO >= optOff && modE <= (optOff + optSize)) {
		//printf("OPTHDR_SIZE modified!\n");
		return true;
	}
	int bgn = m_PE->secHdrsOffset();
	int end = m_PE->secHdrsEndOffset();

	if (modO >= bgn && modO < end) return true;
	if (modE >= bgn && modO < end) return true;
	return false;
}

bool PeHandler::isInActiveArea(offset_t offset)
{
	bool isActiveArea = true;
	if (this->displayedSize != ULONG_MAX) {

		offset_t highO = this->hilightedOffset;
		offset_t highS = this->hilightedSize;
			
		if (highO != (-1) && highS != (-1) && (offset < highO || offset >= (highO + highS))) {
			isActiveArea = false;
		}
	}
	return isActiveArea;
}

bool PeHandler::isInModifiedArea(offset_t offset)
{
	return this->modifHndl.isInLastModifiedArea(offset);
}

bool PeHandler::resize(bufsize_t newSize)
{
	if (m_PE->resize(newSize)) {
		updatePeOnResized();
		emit modified();
		return true;
	}
	return false;
}

bool PeHandler::resizeImage(bufsize_t newSize)
{
	if (m_PE->getImageSize() == newSize) return false; //nothing to change

	offset_t modOffset = this->optHdrWrapper.getFieldOffset(OptHdrWrapper::IMAGE_SIZE);
	bufsize_t modSize = this->optHdrWrapper.getFieldSize(OptHdrWrapper::IMAGE_SIZE);
	this->modifHndl.backupModification(modOffset, modSize, false);

	m_PE->setImageSize(newSize);
	return true;
}

SectionHdrWrapper* PeHandler::addSection(QString name, bufsize_t rSize, bufsize_t vSize) //throws exception
{
	offset_t modOffset = this->optHdrWrapper.getFieldOffset(OptHdrWrapper::IMAGE_SIZE);
	bufsize_t modSize = this->optHdrWrapper.getFieldSize(OptHdrWrapper::IMAGE_SIZE);
	this->modifHndl.backupModification(modOffset, modSize, false);

	modOffset = this->fileHdrWrapper.getFieldOffset(FileHdrWrapper::SEC_NUM);
	modSize = this->fileHdrWrapper.getFieldSize(FileHdrWrapper::SEC_NUM);
	this->modifHndl.backupModification(modOffset, modSize, true);

	//--
	modOffset = m_PE->secHdrsEndOffset();
	modSize = sizeof(IMAGE_SECTION_HEADER);
	this->modifHndl.backupModification(modOffset, modSize, true);
	//---
	SectionHdrWrapper* newSec = NULL;
	try {
		newSec = m_PE->addNewSection(name, rSize, vSize);
	} catch (CustomException e) {
		this->modifHndl.unStoreLast();
		throw (e);
	}

	if (!newSec) {
		this->modifHndl.unStoreLast();
		throw CustomException("Cannot add new section!");
	}
	emit modified();
	emit secHeadersModified();
	return newSec;
}

offset_t PeHandler::loadSectionContent(SectionHdrWrapper* sec, QFile &fIn, bool continueLastOperation)
{
	if (!m_PE || !sec) return 0;

	offset_t modifOffset = sec->getRawPtr();
	bufsize_t modifSize = sec->getContentSize(Executable::RAW, true);
	backupModification(modifOffset, modifSize, continueLastOperation);

	AbstractByteBuffer *buf = m_PE->getFileBuffer();
	if (!buf) return 0;

	offset_t loaded = buf->substFragmentByFile(modifOffset, modifSize, fIn);

	setDisplayed(false, modifOffset, modifSize);
	setBlockModified(modifOffset, loaded);
	return loaded;
}

bool PeHandler::moveDataDirEntry(pe::dir_entry dirNum, offset_t targetRaw)
{
	if (dirNum >= DIR_ENTRIES_COUNT) return false;
	if (!dataDirWrappers[dirNum]) return false;

	const offset_t fieldOffset = this->dataDirWrapper.getFieldOffset(dirNum);
	const bufsize_t fieldSize = this->dataDirWrapper.getFieldSize(dirNum, FIELD_NONE);
	if (fieldOffset == INVALID_ADDR) return false;

	// current directory:
	BYTE* ptr = (BYTE*)dataDirWrappers[dirNum]->getPtr();
	const offset_t dirOffset = m_PE->getOffset(ptr);
	bufsize_t dirSize = getDirSize(dirNum);

	if (!ptr || !dirSize || dirOffset == INVALID_ADDR) return false;

	backupModification(dirOffset, dirSize, false); // backup current area
	backupModification(targetRaw, dirSize, true); // backup the target area
	backupModification(fieldOffset, fieldSize, true); //backup the offset
	bool isOk = false;
	try {
		isOk = m_PE->moveDataDirEntry(dirNum, targetRaw, Executable::RAW);
	}
	catch (CustomException e) {
		isOk = false;
	}
	if (!isOk) {
		unbackupLastModification();
		return false;
	}
	dataDirWrappers[dirNum]->wrap();
	emit modified();
	return true;
}
size_t PeHandler::getDirSize(dir_entry dirNum)
{
	if (dirNum >= DIR_ENTRIES_COUNT) return 0;
	if (dataDirWrappers[dirNum] == NULL) return 0;
	
	bufsize_t dirSize = dataDirWrappers[dirNum]->getSize();
	return dirSize;
}

bool PeHandler::addImportLib(bool continueLastOperation)
{
	const bufsize_t tableSize = importDirWrapper.getSize();

	offset_t impDirOffset = importDirWrapper.getOffset();
	if (impDirOffset == INVALID_ADDR) return false;

	const bufsize_t fieldSize = sizeof(IMAGE_IMPORT_DESCRIPTOR);

	if (!m_PE->getContentAt(impDirOffset, tableSize + fieldSize)) return false;

	offset_t fieldOffset = (tableSize < fieldSize) ? impDirOffset : impDirOffset + tableSize - fieldSize; // substract the terminator record from the table
	BYTE *ptr = m_PE->getContentAt(fieldOffset, fieldSize * 2); // space for the new record + terminator
	if (!ptr) return false;

	if (!pe_util::isSpaceClear(ptr, fieldSize)) return false;

	backupModification(fieldOffset, fieldSize, continueLastOperation); // backup Section Header

	IMAGE_IMPORT_DESCRIPTOR* field = (IMAGE_IMPORT_DESCRIPTOR*)ptr;
	memset(field, 0, fieldSize);

	field->OriginalFirstThunk = (-1);
	field->FirstThunk = (-1);
	field->Name = (-1);

	importDirWrapper.wrap();
	//---
	emit modified();
	return true;
}

bool PeHandler::addImportFunc(size_t libNum)
{
	//ImportEntryWrapper 
	ImportEntryWrapper *lib = dynamic_cast<ImportEntryWrapper*>(importDirWrapper.getEntryAt(libNum));
	if (!lib) return false;

	const size_t funcNum = lib->getEntriesCount();
	
	bool isOk = false;
	offset_t callVia = lib->getNumValue(ImportEntryWrapper::FIRST_THUNK, &isOk);
	if (!isOk) return false;

	{ //scope0
		// create a temporary wrapper to check if adding a terminating record is possible:
		ImportedFuncWrapper *nextFunc = new ImportedFuncWrapper(m_PE, lib, funcNum + 1);
		if (nextFunc->getThunkValue()) {
			// not an empty space
			delete nextFunc;
			return false;
		}
		// space check - OK! enough space for terminate record
		delete nextFunc;
	}

	bool isSet = false;

	{ //scope1
		// create a temporary wrapper to help filling in the space:
		ImportedFuncWrapper *nextFunc = new ImportedFuncWrapper(m_PE, lib, funcNum);
		offset_t offset = nextFunc->getFieldOffset(ImportEntryWrapper::FIRST_THUNK);
		bufsize_t fieldSize = nextFunc->getFieldSize(ImportEntryWrapper::FIRST_THUNK);

		if (offset && fieldSize) {
			backupModification(offset, fieldSize);
			isSet = nextFunc->setNumValue(ImportEntryWrapper::FIRST_THUNK, (-1));
		}
		delete nextFunc;
	}
	if (!isSet) {
		this->unbackupLastModification();
		return false;
	}

	lib->wrap();
	//---
	emit modified();
	return true;
}

void PeHandler::setEP(offset_t newEpRva)
{
	if (!m_PE) return;

	if (newEpRva >= m_PE->getImageSize()) return;
	offset_t epOffset = this->m_PE->peOptHdrOffset();
	
	// TODO: implement it in better way
	Executable::exe_bits mode = this->m_PE->getBitMode();
	if (mode != Executable::BITS_32 && mode != Executable::BITS_64) return;

	static IMAGE_OPTIONAL_HEADER32 h32;
	static IMAGE_OPTIONAL_HEADER64 h64;
	epOffset += (mode == Executable::BITS_32 ? ((uint64_t) &h32.AddressOfEntryPoint - (uint64_t) &h32) : ((uint64_t) &h64.AddressOfEntryPoint - (uint64_t) &h64));

	backupModification(epOffset , sizeof(DWORD)); // backup
	if (m_PE->setEntryPoint(newEpRva, Executable::RVA)) {
		emit modified();
		return;
	}
	this->unbackupLastModification(); // unbackup
}

bool PeHandler::clearBlock(offset_t offset, uint64_t size)
{
	return fillBlock(offset, size, 0);
}

bool PeHandler::fillBlock(offset_t offset, uint64_t size, BYTE val)
{
	if (!m_PE) return false;

	this->backupModification(offset, size);
	BYTE *buf = m_PE->getContentAt(offset, size);
	if (!buf) {
		this->unbackupLastModification();
		return false;
	}
	::memset(buf, val, size);
	return this->setBlockModified(offset, size);
}


bool PeHandler::substBlock(offset_t offset, uint64_t size, BYTE* buf)
{
	if (!m_PE) return false;
	BYTE *content = m_PE->getContent();
	bufsize_t fileSize = m_PE->getRawSize();
	if (offset > fileSize) return false;

	offset_t maxSize = ((offset_t)fileSize) - offset;
	if (size > maxSize) size = maxSize;
	
	this->backupModification(offset, size);
	if (buf) {
		memcpy(content + offset, buf, size);
	} else {
		memset(content + offset, 0, size);
	}
	return this->setBlockModified(offset, size);
}

void PeHandler::backupModification(offset_t modifOffset, bufsize_t modifSize, bool continueLastOperation)
{
	modifHndl.backupModification(modifOffset, modifSize, continueLastOperation);
}

void PeHandler::unbackupLastModification()
{
	modifHndl.unStoreLast();
}

bool PeHandler::setBlockModified(offset_t modO, bufsize_t modSize)
{
	bool isOk = false;
	try {
		updatePeOnModified(modO, modSize); // throws exception
		isOk = true;

	} catch (CustomException &e) {
		this->unModify();
		std::cerr << "Unacceptable modification: " << e.what() << "\n";
		isOk = false;
	}
	if (isOk) {
		emit modified();
	}
	return isOk;
}

bool PeHandler::isBaseHdrModif(offset_t modO, bufsize_t modSize)
{
	bool baseHdrsModified = false;
	if (this->dosHdrWrapper.intersectsBlock(modO, modSize)) {
		//std::cout << "DOS header affected[" << std::hex << modO  << " - " << modO + modSize  << "]!\n";
		baseHdrsModified = true;
	}
	if (this->fileHdrWrapper.intersectsBlock(modO, modSize)) {
		//std::cout << "File Header affected[" << std::hex << modO << " - " << modO + modSize << "]!\n";
		baseHdrsModified = true;
	}
	if (this->optHdrWrapper.intersectsBlock(modO, modSize)) {
		//std::cout << "Optional header affected[" << std::hex << modO << " - " << modO + modSize << "]!\n";
		baseHdrsModified = true;
	}

	return baseHdrsModified;
}

bool PeHandler::rewrapDataDirs()
{
	bool anyModified = false;

	//std::cout << "Rewrapped: ";
	for (size_t i = 0; i < DIR_ENTRIES_COUNT; i++) {
		if (!dataDirWrappers[i]) continue;

		bool result = dataDirWrappers[i]->wrap();
		if (result) {
			//std::cout << i << " ";
			anyModified = true;
		}
	}
	//std::cout <<  "\n";
	this->wrapAlbum();
	return anyModified;
}


bool PeHandler::updatePeOnModified(offset_t modO, bufsize_t modSize)// throws exception
{
	if (!m_PE) return false;

	m_PE->wrap();

	bool isSecHdrModified = false;
	bool baseHdrModified = false;

	if (modO != INVALID_ADDR && modSize) { // if modification offset is specified
		if (isBaseHdrModif(modO, modSize)) {
			baseHdrModified = true;
			isSecHdrModified = true;
		}
		if (this->m_PE->getSectionsCount() != m_PE->hdrSectionsNum()) {
			isSecHdrModified = true;
		}
		if (isSectionsHeadersModified(modO, modSize)) {
			isSecHdrModified = true;
		}
	}
	else {
		// if the modification offset is unknown, assume modified:
		baseHdrModified = true;
		isSecHdrModified = true;
	}

	if (baseHdrModified) {
		fileHdrWrapper.wrap();
		optHdrWrapper.wrap();
	}

	rewrapDataDirs();

	runHashesCalculation();

	if (isSecHdrModified) {
		emit secHeadersModified();
	}
	return true;
}

void PeHandler::updatePeOnResized()
{
	rewrapDataDirs();
	runHashesCalculation();

	emit secHeadersModified();
}


void PeHandler::runHashesCalculation()
{
	for (int i = 0; i < CalcThread::HASHES_NUM; i++) {
		CalcThread::hash_type hType = static_cast<CalcThread::hash_type>(i);
		calculateHash(hType);
	}
}

void PeHandler::unModify()
{
	if (this->modifHndl.undoLastOperation()) {
		try {
			updatePeOnModified();
		}
		catch (CustomException &e)
		{
			std::cerr << "Failed to update PE on modification: " << e.what() << std::endl;
		}
		emit modified();
	}
}

bool PeHandler::markedBranching(offset_t cRva, offset_t tRva)
{
	if (m_PE == NULL) return false;
	//validate...
	if (m_PE->toRaw(cRva, Executable::RVA) == INVALID_ADDR) return false;
	if (m_PE->toRaw(tRva, Executable::RVA) == INVALID_ADDR) return false;

	markedTarget = cRva;
	markedOrigin = tRva;

	emit marked();
	return true;
}

```

`pe-bear/base/PeHandler.h`:

```h
#pragma once

#include <QtCore>
#include <stack>

#include "../REbear.h"
#include <bearparser/bearparser.h>
#include <sig_finder.h>

#include "Releasable.h"
#include "Modification.h"
#include "CommentHandler.h"

#define SIZE_UNLIMITED (-1)
//-------------------------------------------------

class CalcThread : public QThread
{
	Q_OBJECT
public:
	enum hash_type {
		MD5 = 0,
		SHA1 = 1,
		SHA256,
		CHECKSUM,
		HASHES_NUM
	};

	CalcThread(hash_type hType, PEFile* pe, offset_t checksumOffset = 0);
	bool isByteArrInit() { return (m_PE && m_PE->getContent()); }

signals:
	void gotHash(QString hash, int type);

private:
	void run();
	
	PEFile* m_PE;
	QMutex m_arrMutex;

	hash_type hashType;
	offset_t checksumOff;
};

class PeHandler : public QObject, public Releasable
{
	Q_OBJECT

public:
	PeHandler(PEFile *_pe, FileBuffer *_fileBuffer);
	PEFile* getPe() { return m_PE; }

	bool isPeValid() 
	{
		if (!m_PE) return false;
		if (m_PE->getSectionsCount() == 0) {
			return false;
		}
		offset_t lastRva = this->m_PE->getLastMapped(Executable::RVA);
		if (lastRva != m_PE->getImageSize()) {
			return false;
		}
		// TODO: verify the internals of the PE file
		return true;
	}
	
	bool updateFileModifTime()
	{
		QDateTime modDate = QDateTime(); //default: empty date
		const QString path = this->getFullName();
		QFileInfo fileInfo(path);
		if (fileInfo.exists()) {
			QFileInfo fileInfo = QFileInfo(path);
			modDate = fileInfo.lastModified();
		}
		const QDateTime prevDate = this->m_fileModDate;
		if (prevDate.toMSecsSinceEpoch() == modDate.toMSecsSinceEpoch()) {
			// no need to update:
			return false;
		}
		this->m_fileModDate = modDate;
		return true;
	}
	
	bool isFileOnDiskChanged()
	{
		if (this->m_fileModDate.toMSecsSinceEpoch() == this->m_loadedFileModDate.toMSecsSinceEpoch()) {
			// the loaded file is the same as the file on the disk
			return false;
		}
		return true;
	}

	bool hasDirectory(pe::dir_entry dirNum);

	QString getCurrentSHA256() { return getCurrentHash(CalcThread::SHA256); }
	QString getCurrentMd5() { return getCurrentHash(CalcThread::MD5); }
	QString getCurrentSHA1() { return getCurrentHash(CalcThread::SHA1); }
	QString getCurrentChecksum() { return getCurrentHash(CalcThread::CHECKSUM); }
	QString getCurrentHash(CalcThread::hash_type type);

	void setPackerSignFinder(sig_ma::SigFinder* signFinder);
	bool isPacked();
	sig_ma::PckrSign* findPackerSign(offset_t startOff, Executable::addr_type addrType, sig_ma::match_direction md = sig_ma::FIXED);
	sig_ma::PckrSign* findPackerInArea(offset_t rawOff, size_t size, sig_ma::match_direction md);

	void calculateHash(CalcThread::hash_type type);

	/* fetch info about offset */
	bool isInActiveArea(offset_t offset);
	bool isInModifiedArea(offset_t offset);

	/* resize */
	bool resize(bufsize_t newSize);
	bool resizeImage(bufsize_t newSize);

	SectionHdrWrapper* addSection(QString name,  bufsize_t rSize, bufsize_t vSize); //throws exception
	offset_t loadSectionContent(SectionHdrWrapper* sec, QFile &fIn, bool continueLastOperation = false);

	bool moveDataDirEntry(pe::dir_entry dirNum, offset_t targetRaw);

	size_t getDirSize(pe::dir_entry dirNum);
	bool addImportLib(bool continueLastOperation = false);
	bool addImportFunc(size_t parentLibNum);

	void setEP(offset_t newEpRva);
	void wrapAlbum() { resourcesAlbum.wrapLeafsContent(); }

	/* content manipulation / substitution */
	bool clearBlock(offset_t offset, uint64_t size);
	bool fillBlock(offset_t offset, uint64_t size, BYTE val);
	bool substBlock(offset_t offset, uint64_t size, BYTE* buf);

	/* modifications */
	bool isDataDirModified(offset_t modOffset, bufsize_t modSize);
	bool isSectionsHeadersModified(offset_t modOffset, bufsize_t modSize);
	void backupModification(offset_t  modOffset, bufsize_t modSize, bool continueLastOp = false);
	void unbackupLastModification();
	bool setBlockModified(offset_t  modOffset, bufsize_t modSize);
	void unModify();
	bool isPEModified() { return this->modifHndl.countOperations() ? true : false;  }

	/* display */
	bool markedBranching(offset_t origin, offset_t target);
	bool setDisplayed(bool isRVA, offset_t displayedOffset, bufsize_t displayedSize = SIZE_UNLIMITED);

	offset_t getDisplayedOffset() { return displayedOffset; }
	size_t getDisplayedSize() { return displayedSize; }

	void setHilighted(offset_t hilightedOffset, bufsize_t hilightedSize);
	void setHovered(bool isRVA, offset_t hilightedOffset, bufsize_t hilightedSize);

	void setPageOffset(offset_t pageOffset);
	void advanceOffset(int increment);

	bool setDisplayedEP();
	void undoDisplayOffset();

	/* File name wrappers */
	QString getFullName() { return this->m_fileBuffer->getFileName(); }

	QString getShortName()
	{
		const QString path = getFullName();
		QFileInfo fileInfo(path);
		return fileInfo.fileName();
	}

	QString getDirPath()
	{
		const QString path = getFullName();
		QFileInfo fileInfo(path);
		return fileInfo.absoluteDir().absolutePath();
	}
//--------
	/* wrappers for PE structures */
	DosHdrWrapper dosHdrWrapper;
	RichHdrWrapper richHdrWrapper;
	FileHdrWrapper fileHdrWrapper;
	OptHdrWrapper optHdrWrapper;
	DataDirWrapper dataDirWrapper;

	ResourcesAlbum resourcesAlbum;

	/*Directory wrappers */
	ExportDirWrapper exportDirWrapper;
	ImportDirWrapper importDirWrapper;
	TlsDirWrapper tlsDirWrapper;
	RelocDirWrapper relocDirWrapper;
	SecurityDirWrapper securityDirWrapper;
	LdConfigDirWrapper ldConfDirWrapper;
	BoundImpDirWrapper boundImpDirWrapper;
	DelayImpDirWrapper delayImpDirWrapper;
	DebugDirWrapper debugDirWrapper;
	ClrDirWrapper clrDirWrapper;
	ExceptionDirWrapper exceptDirWrapper;
	ResourceDirWrapper resourcesDirWrapper;

	ExeElementWrapper* dataDirWrappers[pe::DIR_ENTRIES_COUNT]; // Pointers to above wrappers

	/* editon related handlers */
	CommentHandler comments;
	ModificationHandler modifHndl;
	//---
	offset_t markedOrigin, markedTarget;//, markedOriginRaw, markedTargetRaw;
	offset_t displayedOffset, displayedSize;
	offset_t hilightedOffset, hilightedSize;
	offset_t hoveredOffset, hoveredSize;

	offset_t pageStart;
	bufsize_t pageSize;
	std::stack<offset_t> prevOffsets;
	std::vector<sig_ma::FoundPacker> packerAtOffset;

signals:
	void pageOffsetModified(offset_t pageStart, bufsize_t pageSize);

	void modified();
	void secHeadersModified();
	void marked();
	void hovered();

	void foundSignatures(int count, int requestType);
	void hashChanged();

protected slots:
	void onHashReady(QString hash, int hType);
	void onCalcThreadFinished();

protected:
	~PeHandler() {
		deleteThreads();
		if (m_PE) {
			delete m_PE;
			m_PE = NULL;
		}
		if (m_fileBuffer) {
			delete m_fileBuffer;
			m_fileBuffer = NULL;
		}
	}
	
	void deleteThreads();

	void associateWrappers();

	bool isBaseHdrModif(offset_t modifOffset, bufsize_t size);
	bool rewrapDataDirs();
	bool updatePeOnModified(offset_t modOffset = INVALID_ADDR, bufsize_t modSize = 0);// throws exception
	void updatePeOnResized();
	void runHashesCalculation();

	PEFile* m_PE;
	FileBuffer *m_fileBuffer;

	QDateTime m_fileModDate; //modification time of the corresponding file on the disk
	QDateTime m_loadedFileModDate; //modification time of the version that is currently loaded

	CalcThread* calcThread[CalcThread::HASHES_NUM];
	QString hash[CalcThread::HASHES_NUM];
	QMutex m_hashMutex[CalcThread::HASHES_NUM];
	bool calcQueued[CalcThread::HASHES_NUM];

	sig_ma::SigFinder *signFinder;
};

```

`pe-bear/base/PeHandlerFactory.cpp`:

```cpp
 #include <new>
#include "PeHandlerFactory.h"

bool PeHandlerFactory::addHandler(QString path, bool canTruncate)
{
	FileBuffer *fileBuffer = NULL;
	PEFile *newPE = NULL;
	try {
		const size_t peMinSize = sizeof(IMAGE_DOS_HEADER) + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER64);
		fileBuffer = new FileBuffer(path, peMinSize, canTruncate);
		newPE = makePeFile(fileBuffer);
		if (!newPE) {
			delete fileBuffer; fileBuffer = NULL;
		}
	} catch (CustomException &e) {
		Logger::append(Logger::D_ERROR, e.what());
		return false;
	}
	if (!newPE) return false;

	PeHandler* hndl = new PeHandler(newPE, fileBuffer);
	bool isInserted = this->myManager.insertHandler(hndl);
	return isInserted;
}

PEFile*  PeHandlerFactory::makePeFile(FileBuffer* fileBuffer)
{
	PEFile *newPE = NULL;
	if (!fileBuffer) return NULL;
	try {
		newPE = new PEFile(fileBuffer);
	}
	catch (CustomException &e) {
		Logger::append(Logger::D_ERROR, e.what());
	}
	return newPE;
}


```

`pe-bear/base/PeHandlerFactory.h`:

```h
#pragma once

#include "PeHandlersManager.h"

class PeHandlerFactory : public ExeHandlerFactory
{
	Q_OBJECT
public :
	PeHandlerFactory(PeHandlersManager &manager, ExeFactory::exe_type type, bool canTruncate = true)
		: ExeHandlerFactory(manager, type, canTruncate) {}

	virtual bool addHandler(QString path, bool canTruncate);

protected:
	virtual PEFile* makePeFile(FileBuffer* buffer);
};

```

`pe-bear/base/PeHandlersManager.cpp`:

```cpp
 #include <new>

#include "PeHandlersManager.h"
#include <bearparser/bearparser.h>

#include "PeHandlerFactory.h"

#include <iostream>

//--------------------------------------------------------------------

PeHandlersManager::PeHandlersManager()
{
	addSupportedType(ExeFactory::PE, new PeHandlerFactory(*this, ExeFactory::PE));
}

bool PeHandlersManager::addSupportedType(ExeFactory::exe_type type, ExeHandlerFactory *factory)
{
	if (isSupportedType(type)) {
		//already supported
		return false;
	}
	this->supportedTypes[type] = factory;
	return true;
}

bool PeHandlersManager::isSupportedType(ExeFactory::exe_type type)
{
	if (this->supportedTypes.find(type) == this->supportedTypes.end()) {
		return false;
	}
	return true;
}


bool PeHandlersManager::openExe(QString path, ExeFactory::exe_type type, bool canTruncate)
{
	if (this->isSupportedType(type) == false) return false;
	this->supportedTypes[type]->addHandler(path, canTruncate);
	return true;
}

PeHandlersManager::~PeHandlersManager()
{
	clear();
	std::map<ExeFactory::exe_type, ExeHandlerFactory*>::iterator stItr;
	for (stItr = this->supportedTypes.begin(); stItr != this->supportedTypes.end(); ++stItr) {
		ExeHandlerFactory* factory = stItr->second;
		delete factory;
	}
	this->supportedTypes.clear();
}

bool PeHandlersManager::insertHandler(PeHandler* hndl)
{
	if (hndl == NULL) return false;
	const QString fileName = hndl->getFullName();

	{ //lock:
		QMutexLocker locker(&this->m_loadMutex);
		if (this->nameToHandlerMap[fileName] != NULL) {
			//printf("Already exist : %s\n", fileName.toStdString().c_str());
			hndl->release();
			return false;
		}
		PEFile *pe = hndl->getPe();
		this->PeHandlers[pe] = hndl;
		this->nameToHandlerMap[fileName] = hndl;
	} //unlock

	emit exeHandlerAdded(hndl);
	//---
	emit PeListUpdated();
	return true;
}

PeHandler* PeHandlersManager::getPeHandler(PEFile* pe)
{
	if (pe == NULL) return NULL;

	//lock:
	QMutexLocker locker(&this->m_loadMutex);
	PeHandler* hndl = NULL;
	if (this->PeHandlers.find(pe) == this->PeHandlers.end()) {
		return NULL;
	}
	hndl = this->PeHandlers[pe];
	return hndl;
}

PeHandler* PeHandlersManager::getByName(QString name)
{
	//lock:
	QMutexLocker locker(&this->m_loadMutex);
	if (nameToHandlerMap.find(name) != nameToHandlerMap.end()) {
		return nameToHandlerMap[name]; 
	}
	return NULL;
}

bool PeHandlersManager::removePe(PEFile* pe)
{
	if (!pe) return false;

	PeHandler* hndl = getPeHandler(pe);
	if (!hndl) return false;

	emit exeHandlerRemoved(hndl);
	{ //lock:
		QMutexLocker locker(&this->m_loadMutex);
		const QString peName = hndl->getFullName();

		// get handler :
		std::map<PEFile*, PeHandler*>::iterator peHndlItr = this->PeHandlers.find(pe);
		if (peHndlItr != this->PeHandlers.end()) {
			/* delete from PE -> Handler map */
			this->PeHandlers.erase(peHndlItr);
		}

		/* delete from name -> Handler map */
		nameToHandlerMap.remove(peName);

		//printf("PE handler release counter: %d\n", hndl->getRefCntr());
		hndl->release();
	} //unlock
	//---
	//emit exeHandlerRemoved(hndl);
	emit PeListUpdated();
	return true;
}

void PeHandlersManager::clear()
{
	{ //lock:
		QMutexLocker locker(&this->m_loadMutex);

		std::map<PEFile*, PeHandler*>::iterator histItr;
		for ( histItr = PeHandlers.begin(); histItr != PeHandlers.end(); ++histItr) {
			PeHandler* hndl = histItr->second;
			hndl->release();
		}
		PeHandlers.clear();
		nameToHandlerMap.clear();
	}//unlock
	//---
	emit PeListUpdated();
}

void PeHandlersManager::checkAllSignatures()
{
	bool foundAny = false;
	
	{ //lock:
		QMutexLocker locker(&this->m_loadMutex);
		std::map<PEFile*, PeHandler*> &map = PeHandlers;
		std::map<PEFile*, PeHandler*>::iterator peIter;
		for (peIter = map.begin(); peIter != map.end(); ++peIter) {
			PEFile *pe = peIter->first;
			PeHandler* hndl = peIter->second;
			if (hndl->findPackerSign(pe->getEntryPoint(), Executable::RVA, sig_ma::FIXED) != NULL) {
				foundAny = true;
			}
		}
	} //unlock

	if (foundAny) {
		emit matchedSignatures();
	}
}


```

`pe-bear/base/PeHandlersManager.h`:

```h
#pragma once

#include <QtCore>
#include <stack>

#include "../REbear.h"
#include <bearparser/bearparser.h>
#include <sig_finder.h>

#include "Modification.h"
#include "CommentHandler.h"
#include "PeHandler.h"

#define SIZE_UNLIMITED (-1)
//-------------------------------------------------

class PeHandlersManager;

class ExeHandlerFactory : public QObject 
{
	Q_OBJECT
public :
	ExeHandlerFactory(PeHandlersManager &manager, ExeFactory::exe_type type, bool canTruncate) 
		: QObject(),
		myManager(manager), exeType(type), allowTruncated(canTruncate) {}

	virtual bool addHandler(QString path, bool canTruncate) = 0;
	virtual bool addHandler(QString path) { return addHandler(path, this->allowTruncated); }
	
protected:
	virtual ~ExeHandlerFactory() {} // will be deleted in its manager

	ExeFactory::exe_type exeType;
	PeHandlersManager &myManager;
	bool allowTruncated;

friend class PeHandlersManager;
};

//-------------------------------------------------

class PeHandlersManager : public QObject
{
	Q_OBJECT

signals:
	void exeHandlerAdded(PeHandler*);
	void exeHandlerRemoved(PeHandler*);

	void PeListUpdated();
	void matchedSignatures();

public:
	PeHandlersManager();
	~PeHandlersManager();
	bool addSupportedType(ExeFactory::exe_type, ExeHandlerFactory *factory);

	bool isSupportedType(ExeFactory::exe_type);
	bool openExe(QString path, ExeFactory::exe_type type, bool canTruncate);

	bool insertHandler(PeHandler* hndl);
	PeHandler* getPeHandler(PEFile* pe);
	PeHandler* getByName(QString name);

	bool removePe(PEFile* pe);
	void clear();
	std::map<PEFile*, PeHandler*> &getHandlersMap() { return PeHandlers; }
	QList<QString> getFilenames() { return nameToHandlerMap.keys(); }

public slots:
	void checkAllSignatures();

protected:
	std::map<PEFile*, PeHandler*> PeHandlers;
	QMap<QString, PeHandler*> nameToHandlerMap;
	std::map<ExeFactory::exe_type, ExeHandlerFactory*> supportedTypes;
	QMutex m_loadMutex;
};

```

`pe-bear/base/RegKeyManager.cpp`:

```cpp
#ifdef _WINDOWS
#include <windows.h>
#include <stdio.h>
#include <strsafe.h>
#endif //_WINDOWS

#include "RegKeyManager.h"

std::string PART = "file\\shell\\Open with ";

bool RegKeyManager::removeRegPath(const std::string &extension, const std::string &appName)
{
#ifdef _WINDOWS
	int res1 = 0, res2 = 0;
	HKEY hKey = 0;

	std::string fullName = extension;
	fullName.append(PART).append(appName);
	LPCSTR lpSubKey = fullName.c_str();

	LONG res = RegCreateKeyA(HKEY_CLASSES_ROOT, lpSubKey, &hKey);
	if (res != ERROR_SUCCESS) {
		return false;
	}

	res1 = RegDeleteKeyA(hKey, "command");
	res2 = RegDeleteKeyA(hKey, "");

	res = RegCloseKey(HKEY_CLASSES_ROOT);
	if (res != ERROR_SUCCESS) {
		return false;
	}
	if (res1 == ERROR_SUCCESS || res2 == ERROR_SUCCESS) {
		return true;
	}
#endif //_WINDOWS
	return false;
}

bool RegKeyManager::addRegPath(const std::string &extension, const std::string &appName, const std::string &path)
{
#ifdef _WINDOWS

	int res1 = 0, res2 = 0;
	HKEY hKey = 0;

	std::string fullName = extension;
	fullName.append(PART).append(appName); // example: "dllfile\\shell\\Open with PE-bear";
	const std::string cmdName = fullName + "\\command";

	// set command:
	const std::string cmdPath = path + " \"%1\"";
	LONG res = RegCreateKeyA(HKEY_CLASSES_ROOT, cmdName.c_str(), &hKey);
	if (res != ERROR_SUCCESS) {
		return false;
	}
	res1 = RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)cmdPath.c_str(), cmdPath.length());
	res = RegCloseKey(HKEY_CLASSES_ROOT);
	if (res1 != ERROR_SUCCESS || res != ERROR_SUCCESS) {
		return false;
	}
	
	//set icon:
	hKey = 0;
	res = RegCreateKeyA(HKEY_CLASSES_ROOT, fullName.c_str(), &hKey);
	if (res != ERROR_SUCCESS) {
		return false;
	}

	const std::string iconPath = path + ",0";
	res1 = RegSetValueExA(hKey, "Icon", 0, REG_SZ, (BYTE*)iconPath.c_str(), iconPath.length());

	res = RegCloseKey(HKEY_CLASSES_ROOT);
	if (res1 != ERROR_SUCCESS || res != ERROR_SUCCESS) {
		return false;
	}
	if (res1 == ERROR_SUCCESS) {
		return true;
	}
#endif //_WINDOWS
	return false;
}


bool RegKeyManager::isKeySet(const std::string &extension, const std::string &appName)
{
#ifdef _WINDOWS

	HKEY hKey = 0;
	std::string fullName = extension;
	fullName.append(PART).append(appName);
	LPCSTR lpSubKey = fullName.c_str();

	LONG res = RegOpenKeyExA(HKEY_CLASSES_ROOT, lpSubKey, 0, KEY_READ, &hKey);
	if (res != ERROR_SUCCESS) {
		return false;
	}
	res = RegCloseKey(HKEY_CLASSES_ROOT);
	if (res == ERROR_SUCCESS) {
		return true;
	}
#endif //_WINDOWS
	return false;
}


```

`pe-bear/base/RegKeyManager.h`:

```h
#include <string>

namespace RegKeyManager {
	bool removeRegPath(const std::string &extension, const std::string &appName);
	bool addRegPath(const std::string &extension, const std::string &appName, const std::string &value);
	bool isKeySet(const std::string &extension, const std::string &appName);
};

```

`pe-bear/base/Releasable.h`:

```h
#pragma once

#include <stdio.h>

//-----------------

class Releasable
{
public:
	Releasable() : refCntr(0) {}
	
	void release() { if (refCntr > 0) refCntr--; else delete this; }
	void incRefCntr() { this->refCntr++; }
	size_t getRefCntr() { return refCntr; } 
protected:
	virtual ~Releasable() {}
	size_t refCntr; // reference Counter
};



```

`pe-bear/gui/CMakeLists.txt`:

```txt
#S:/PE-bear/pe-bear/gui

cmake_minimum_required(VERSION 2.8)

find_package (Qt4 REQUIRED)

set (MY_DIR gui)

set ( my_hdrs
	ContentPreview.h
	DetailsTab.h
	DosHdrTableModel.h
	GeneralPanel.h
	SectionAddWindow.h
)

set ( my_cpp
	ContentPreview.cpp
	DetailsTab.cpp
	DosHdrTableModel.cpp
	GeneralPanel.cpp
	SectionAddWindow.cpp
)

#qt4_wrap_cpp( my_hdrs_moc ${my_hdrs} )

SET(resfile_list "")
foreach(file ${my_hdrs})
	SET(resfile_list ${resfile_list} ${MY_DIR}/${file})
	message(STATUS "file='${resfile_list}'")
endforeach()

set (gui_h
	${resfile_list}
	PARENT_SCOPE
)

SET(resfile_list "")
foreach(file ${my_cpp})
	SET(resfile_list ${resfile_list} ${MY_DIR}/${file})
	message(STATUS "file='${resfile_list}'")
endforeach()

set (gui_cpp
	${resfile_list}
	PARENT_SCOPE
)
```

`pe-bear/gui/CommentView.cpp`:

```cpp
#include "CommentView.h"


//-------------------------------------------------------------------------------

CommentView::CommentView(PeHandler *peHandler, QWidget *parent) 
		: QWidget(parent), PeGuiItem(peHandler), commentHndl(NULL)
{
	if (peHandler) commentHndl = &peHandler->comments;

	this->filter = "Tag files (*.tag);;Text files (*.txt);;All Files (*)";
}

void CommentView::onSetComment(offset_t offset)
{
	bool isOk = false;
	QString prev = this->commentHndl->getCommentAt(offset);
	QString title = "RVA : "+ QString::number(offset, 16).toUpper();
	QString text = QInputDialog::getText(this, title, "Comment", QLineEdit::Normal, prev,  &isOk);
	if (!isOk) return;

	this->commentHndl->setComment(offset, text);
	emit commentModified();
}

void CommentView::onSaveComments()
{
	QFileDialog dialog;
	MainSettings *set = this->getSettings();
	if (set) {
		dialog.setDirectory(set->userDataDir());
	}
	QString fName = dialog.getSaveFileName(NULL, "Save", "", filter);
	if (fName.size() == 0) {
		return;
	}
	if (this->commentHndl->saveToFile(fName) == false) {
		 QMessageBox::warning(this, "Failed", "Saving failed!", QMessageBox::Ok);
	}
}

void CommentView::onLoadComments()
{
	QFileDialog dialog;
	MainSettings *set = this->getSettings();
	if (set) {
		dialog.setDirectory(set->userDataDir());
	}
	QString fName = dialog.getOpenFileName(NULL, "Open", "", filter);
	if (fName.size() == 0) return;

	if (loadComments(fName) == false) {
		 QMessageBox::warning(this, "Failed", "Loading failed!", QMessageBox::Ok);
		 return;
	}
	//---
	/*size_t loadedNum = this->commentHndl->commentsNum();
	QString infoStr = "Loaded " + QString::number(loadedNum) + " tag" + ((loadedNum > 1) ? "s!" : "!");
	QMessageBox::information(this, "Done!", infoStr, QMessageBox::Ok);*/
}

bool CommentView::loadComments(QString fName)
{
	if (this->commentHndl->loadFromFile(fName) == false) {
		return false;
	}
	emit commentModified();
	return true;
}

```

`pe-bear/gui/CommentView.h`:

```h
#pragma once
#include <QtCore>
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui_base/PeGuiItem.h"
#include "../base/CommentHandler.h"

class CommentView : public QWidget, public PeGuiItem, public MainSettingsHolder
{
	Q_OBJECT

signals:
	void commentModified();

public slots:
	void onSetComment(offset_t offset);
	void onSaveComments();
	void onLoadComments();
public:
	bool loadComments(QString fName);
	CommentView(PeHandler *peHandler, QWidget *parent);

protected:
	CommentHandler *commentHndl;

private:
	QString filter;
};

```

`pe-bear/gui/ContentPreview.cpp`:

```cpp
#include "ContentPreview.h"

void ContentPreview::createModels()
{
	hexModel = new HexDumpModel(this->myPeHndl, true);
	textModel = new HexDumpModel(this->myPeHndl, false);
	
	connect(this, SIGNAL(signalChangeHexViewSettings(HexViewSettings &)), &hexView, SLOT(changeSettings(HexViewSettings &)) );
	connect(this, SIGNAL(signalChangeHexViewSettings(HexViewSettings &)), &textView, SLOT(changeSettings(HexViewSettings &)) );
}

void ContentPreview::deleteModels()
{
	delete hexModel;
	delete textModel;
}

ContentPreview::ContentPreview(PeHandler *peHndl, QWidget *parent)
	: QSplitter(Qt::Horizontal, parent), PeViewItem(peHndl),
	hexView(this), textView(this),
	textModel(NULL), hexModel(NULL)
{
	if (!this->myPeHndl) return;
	if (this->myPeHndl->getPe() == NULL) return;

	createModels();
	addWidget(&this->hexView);
	addWidget(&this->textView);
	
	setAutoFillBackground(true);
	applyViewsSettings();

	/* set Models */
	this->hexView.setModel(hexModel);
	this->textView.setModel(textModel);

	this->textModel->setHexView(false);
	this->hexView.setVHdrVisible(true);
	this->textView.setVHdrVisible(false);

	hexScroll = new QScrollBar(Qt::Vertical, &hexView);
	hexView.setVerticalScrollBar(hexScroll);
	hexView.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
	hexScroll->setVisible(false);

	textScroll = new QScrollBar(Qt::Vertical, &textView);
	textView.setVerticalScrollBar(textScroll);
	textView.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);

	connect(textScroll, SIGNAL(sliderMoved(int)), this, SLOT(onSliderMoved(int)) );
	connectViewsSignals();
}

ContentPreview::~ContentPreview()
{
	deleteModels();
}

void ContentPreview::onSliderMoved(int val)
{
	if (hexScroll == NULL || textScroll == NULL) return;
	hexScroll->setSliderPosition(val);
}

void ContentPreview::applyViewsSettings()
{
	QString textStyle = QString() + 
	"HexTableView"
	"{"
		"background-color: " + HEXDMP_HBG + ";"
		"alternate-background-color: " + HEXDMP_ALTBG +";"
		"selection-background-color: " + HEXDMP_BG + ";"
		"selection-color: "+ HEXDMP_TXT +";"
		"color: " + HEXDMP_HTXT + ";"
	"}";
	this->textView.setStyleSheet(textStyle);

	QString hexStyle = QString() + 
	"HexTableView"
	"{"
		"background-color: " + HEXDMP_BG + ";"
		"alternate-background-color: " + HEXDMP_ALTBG +";"
		"selection-background-color: " + HEXDMP_HBG + ";"
		"selection-color: "+ HEXDMP_HTXT +";"
		"color: " + HEXDMP_TXT + ";"
	"}";
	this->hexView.setStyleSheet(hexStyle);
	
	this->hexView.setVHdrVisible(true);
	this->textView.setVHdrVisible(false);
}

void ContentPreview::connectViewsSignals()
{
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), textModel, SLOT(setShownContent(offset_t, bufsize_t)) );
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), hexModel, SLOT(setShownContent(offset_t, bufsize_t)) );
}

void ContentPreview::onGoToRVA()
{
	if (!this->m_PE) return;
	
	bool isValid = true;
	offset_t number = 0;
	
	try {
		number = m_PE->rawToRva(this->myPeHndl->displayedOffset);
	} catch (CustomException e) {
		number = 0;
	}

	QString text = QInputDialog::getText(this, 
	    tr("Go to address"),
	    tr("Pointer To RVA (hex):"), 
	    QLineEdit::Normal, 
	    QString::number(number, 16).toUpper(), 
	    &isValid
	);

	if (!isValid || text.isEmpty()) return;
	offset_t raw = 0;

	number = text.toUpper().toLongLong(&isValid, 16);
	if (!isValid) {
		QMessageBox::warning(0,"Warning!", "Wrong number format supplied!");
		return;
	}

	try {
		number = m_PE->VaToRva(number);
		raw = m_PE->rvaToRaw(number);
	} catch (CustomException e) {
		isValid = false;
		QMessageBox::warning(0, "Warning!","RVA:"+ QString::number(number, 16) + " is invalid:\n" + e.what());
	}
	if (!isValid) return;

	this->myPeHndl->setDisplayed(false, raw);
}

```

`pe-bear/gui/ContentPreview.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui_base/PeGuiItem.h"
#include "../HexView.h"

class ContentPreview : public QSplitter, public PeViewItem
{
	Q_OBJECT
public:
	ContentPreview(PeHandler *peHndl, QWidget *parent);
	~ContentPreview();

signals:
	void signalChangeHexViewSettings(HexViewSettings &settings);

public slots:
	// forward the settings change to the individual HexTableView-s:
	void changeHexViewSettings(HexViewSettings &_settings)
	{
		emit signalChangeHexViewSettings(_settings);
	}

protected slots:
	void onGoToRVA();
	void onSliderMoved(int val);

protected:
	void applyViewsSettings();
	void connectViewsSignals();

	void createModels();
	void deleteModels();

	QScrollBar *hexScroll, *textScroll;
	HexTableView hexView,  textView;
	HexDumpModel *hexModel, *textModel;

	QMenu defaultMenu;
};

```

`pe-bear/gui/DarkStyle.h`:

```h
#pragma once

#include "../REbear.h"

size_t scrollSize = 20;
QString sliderHandleBg = "rgba(0,0,0,240);";
QString sliderBg = "rgba(62,43,62,128);";
QString sliderHoverColor = "rgba(255,255,255,112);";

QString g_DarkStyle = QString() +
"QWidget"
"{"
"    color: #eff0f1;"
"    background-color: #30353a;"
"    selection-background-color:#3daee9;"
"    selection-color: #eff0f1;"
"    background-clip: border;"
"    border-image: none;"
"    border: 0px transparent black;"
"    alternate-background-color: #353941;"
"    outline: 0;"
"    font: inherit;"
"}"
"QWidget:item:pressed"
"{"
"    background-color: #3daee9;"
"    color: #eff0f1;"
"}"
"QWidget:disabled"
"{"
"    color: gray;"
"}"
"QSpinBox,"
"QLineEdit,"
"QTreeView,"
"QListView,"
"QTextEdit"
"{"
"    border: 1px solid #76797c;"
"    font: inherit;"
"}"
"QLineEdit:hover"
"{"
"    border-color: white;"
"}"
"QTabBar"
"{"
"    font: inherit;"
"}"
"QTabBar::tab"
"{"
"    border: 1px solid #76797c;"
"    background-color: qlineargradient(x1: 0.5, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #31363b, stop: 0.5 #3b4045);"
"    selection-background-color: #3daee9;"
"    border-radius: 2px;"
"    padding: 5px;"
"    font: inherit;"
"}"
"QTabBar::tab:hover {"
"    background-color: qlineargradient(x1: 0.5, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #3b4045, stop: 0.5 black);"
"    border: 1px solid cyan;"
"}"
"QTabBar::tab:selected {"
"    border: 1px solid #734f96;"
"    border-radius: 2px;"
"    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 black, stop: 1 #3b4045);"
"}"
"QComboBox"
"{"
"    border: 1px solid #76797c;"
"    background-color: qlineargradient(x1: 0.5, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #31363b, stop: 0.5 #3b4045);"
"    selection-background-color: #3daee9;"
"    border-radius: 2px;"
"}"
"QComboBox:drop-down {"
"	border: 3px solid " + sliderBg + ";"
"	border-radius: 4px;"
"	background: rgba(242, 242, 242, 150);"
"	background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #FFFFFD, stop: 0.3 #96ADB2);"
"}"
"QComboBox:drop-down:hover {"
"	border: 3px solid #5E749C;"
"}"
"QComboBox:down-arrow {"
"      border: 1px solid black;"
"      width: 1px;"
"      height: 1px;"
"      background: white;"
"}"
"QToolBar"
"{"
"    border: 1px solid #76797c;"
"    padding: 5px;"
"    selection-background-color: #3daee9;"
"    background-color: qlineargradient(x1: 0, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #31363b, stop: 0.5 #3b4045);"
"}"
"QToolBar[dataDir=\"true\"] { background: #8b9095; border-radius: 3px; outline: 0; }"
"QToolButton{ "
"    background-color: transparent;"
"}"
"QTabBar QToolButton { "
"    border: 1px solid #76797c;"
"    border-radius: 2px;"
"    background-color: qlineargradient(x1: 0, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #31363b, stop: 0.5 #3b4045);"
"}"
"QToolButton:hover"
"{"
"    border: 1px solid cyan;"
"    border-radius: 2px;"
"}"
"QToolButton:checked"
"{"
"    border: 1px solid;"
"    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 black, stop: 1 #3b4045);"
"    border-color: #734f96;"
"    border-radius: 2px;"
"}"
"QPushButton"
"{"
"    color: #eff0f1;"
"    background-color: qlineargradient(x1: 0.5, y1: 0.5 x2: 0.5, y2: 1, stop: 0 #3b4045, stop: 0.5 #31363b);"
"    border-width: 1px;"
"    border-color: #76797c;"
"    border-style: solid;"
"    padding: 5px;"
"    border-radius: 2px;"
"    outline: none;"
"}"
"QPushButton:pressed,"
"QToolButton:pressed"
"{"
"    background-color: #31363b;"
"    padding-top: -15px;"
"    padding-bottom: -17px;"
"}"
"QPushButton:checked"
"{"
"    background-color: #76797c;"
"    border-color: #6A6969;"
"}"
"QPushButton:hover"
"{"
"    border-color: cyan;"
"}"
"DisasmTreeView"
"{"
	"background-color: " + DISASMDMP_BG + ";"
	"alternate-background-color: " + HEXDMP_HBG + ";"
	"selection-background-color: darkblue;"
	"color: " + DISASMDMP_TXT + ";"
"}"
"QHeaderView"
"{"
"	background-color: #31363b;"
"	border: 1px transparent;"
"	border-radius: 0px;"
"	margin: 0px;"
"	padding: 0px;"
"}"
"QHeaderView::section "
"{"
	"background-color: #222222;"
"}"
"QTableCornerButton::section { background-color: black; }"
"ContentPreview"
"{"
	"background-color: #222222;"
	"alternate-background-color: cyan;"
	"color: white;"
"}"
"HexCompareView"
"{"
	"background-color: #584454;"
	"alternate-background-color: #3e2b3e;"
	"color: white;"
"}"
"ColorSettings {"
"	qproperty-rawColor: #2FA530; qproperty-rvaColor: #0080ff; qproperty-vaColor: #c364c5; "
"	qproperty-flagsColor: #584454;"
"	qproperty-dataDirColor: #584454;"
"	qproperty-dataDirNameColor: #452f5b;"
"}"
"QLabel[hasUrl=\"true\"] { background: #5b6065; border-radius: 1px; }"
"QLineEdit[readOnly=\"true\"]{"
"	border: 2px ridge black;"
"	background-color: #353941;"
"}"
"QCheckBox::indicator:unchecked {"
"	border: 1px solid white;"
"	border-radius: 2px;"
"}"
""
"QScrollBar:horizontal {"
"     border: 1px solid #222222;"
"     background: "+ sliderBg + ";"
"     height: 13px;"
"     margin: 0px " + QString::number(scrollSize) + "px 0 " + QString::number(scrollSize) + "px;"
"}"
""
"QScrollBar::handle:horizontal"
"{"
"      background: " + sliderHandleBg + ";"
"      min-height: " + QString::number(scrollSize) + "px;"
"      border-radius: 2px;"
"}"
"QScrollBar::handle:horizontal:hover"
"{"
"      border: 1px solid black;"
"      background: " + sliderHoverColor + ";"
"      min-height: " + QString::number(scrollSize) + "px;"
"      border-radius: 2px;"
"}"
""
"QScrollBar::add-line:horizontal {"
"      border: 1px solid #1b1b19;"
"      border-radius: 2px;"
"      background: " + sliderBg + ";"
"      width: " + QString::number(scrollSize) + "px;"
"      subcontrol-position: right;"
"      subcontrol-origin: margin;"
"}"
""
"QScrollBar::sub-line:horizontal {"
"      border: 1px solid #1b1b19;"
"      border-radius: 2px;"
"      background: " + sliderBg + ";"
"      width: " + QString::number(scrollSize) + "px;"
"      subcontrol-position: left;"
"      subcontrol-origin: margin;"
"}"
""
"QScrollBar::right-arrow:horizontal, QScrollBar::left-arrow:horizontal"
"{"
"      border: 1px solid black;"
"      width: 1px;"
"      height: 1px;"
"      background: white;"
"}"
""
"QScrollBar:vertical"
"{"
"      background: " + sliderBg + ";"
"      width: 13px;"
"      margin: " + QString::number(scrollSize) + "px 0 " + QString::number(scrollSize) + "px 0;"
"      border: 1px solid #222222;"
"}"
""
"QScrollBar::handle:vertical"
"{"
"      background: " + sliderHandleBg + ";"
"      min-height: " + QString::number(scrollSize) + "px;"
"      border-radius: 5px;"
"}"
"QScrollBar::handle:vertical:hover"
"{"
"      border: 1px solid black;"
"      background: " + sliderHoverColor + ";"
"      min-height: " + QString::number(scrollSize) + "px;"
"      border-radius: 2px;"
"}"
""
"QScrollBar::add-line:vertical"
"{"
"      border: 1px solid #1b1b19;"
"      border-radius: 2px;"
"      background: " + sliderBg + ";"
"      height: " + QString::number(scrollSize) + "px;"
"      subcontrol-position: bottom;"
"      subcontrol-origin: margin;"
"}"
""
"QScrollBar::sub-line:vertical"
"{"
"      border: 1px solid #1b1b19;"
"      border-radius: 2px;"
"      background: " + sliderBg + ";"
"      height: " + QString::number(scrollSize) + "px;"
"      subcontrol-position: top;"
"      subcontrol-origin: margin;"
"}"
""
"QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical"
"{"
"      border: 1px solid black;"
"      width: 1px;"
"      height: 1px;"
"      background: white;"
"}"
""
"QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal"
"{"
"      background: none;"
"}"
""
"QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical"
"{"
"      background: none;"
"}"
"QMenuBar"
"{"
"    background-color: transparent;"
"}"
"QMenuBar::item"
"{"
"    background-color: transparent;"
"    border-radius: 2px;"
"    padding: 5px;"
"}"
"QMenu"
"{"
"    background-color: " + sliderBg + ";"
"    border: 1px solid black;"
"}"
"QMenu::item"
"{"
"    background-color: transparent;"
"}"
"QMenuBar::item::selected,"
"QMenu::item::selected"
"{"
"    background-color: " + sliderHandleBg + ";"
"}"
"QTabWidget::pane {"
"   border: 0px;"
"}"
;

```

`pe-bear/gui/DataDirWrapperSplitter.cpp`:

```cpp
#include "DataDirWrapperSplitter.h"

//--------------------------------

void DataDirWrapperSplitter::onMoveDirTable()
{
	if (this->dataDirId >= pe::DIR_ENTRIES_COUNT) {
		return;
	}
	Executable::addr_type aType = Executable::RVA;
	if (this->dataDirId == pe::DIR_SECURITY) {
		aType = Executable::RAW;
	}
	size_t size = myPeHndl->getDirSize(this->dataDirId);
	bool ok;
	QString typeStr = (aType == Executable::RVA) ? "RVA" : "Raw";

	QString text = QInputDialog::getText(this, 
		"Move Dir. Table", "Target "+ typeStr + ":\n(required free space: 0x" + QString::number(size, 16).toUpper() + ")", 
		QLineEdit::Normal, "",  &ok);

	if (ok == false) return;

	offset_t target = text.toLongLong(&ok, 16);
	if (ok == false) {
		QMessageBox::warning(NULL, "Input error", "Invalid format!"); 
		return;
	}

	offset_t targetRaw = m_PE->toRaw(target, aType);
	if (targetRaw == INVALID_ADDR) {
		QMessageBox::warning(NULL, "Input error", "Offset out of scope!"); 
		return;
	}
	if (myPeHndl->moveDataDirEntry(this->dataDirId, targetRaw)) {
		QMessageBox::information(NULL, "Done!","Directory Table moved!");
	} else {
		QMessageBox::warning(NULL, "Cannot move!", 
			"Not enough free space to fit the table!\n Required size: 0x" + QString::number(size, 16));
	}
}

QString DataDirWrapperSplitter::chooseDumpOutDir()
{
	const QString EMPTY_STR = "";
	if (!myPeHndl) return EMPTY_STR;
	//---
	QFileDialog dialog;
	dialog.setWindowTitle("Choose target directory");
	dialog.setFileMode(QFileDialog::Directory);
	dialog.setOption(QFileDialog::ShowDirsOnly, true);

	QString dirPathStr = myPeHndl->getDirPath();

	dialog.setDirectory(dirPathStr);
	int ret = dialog.exec();

	if((QDialog::DialogCode) ret != QDialog::Accepted) return EMPTY_STR;
	//---
	QDir dir = dialog.directory();
	QString fName = dir.absolutePath();
	if (fName.length() > 0) {
		dirPathStr = fName;
	}
	return dirPathStr;
}

void DataDirWrapperSplitter::setScaledIcons()
{
	if (!moveDirTable) return; //not initialized
	
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	QIcon moveIco = ViewSettings::makeScaledIcon(":/icons/move.ico", iconDim, iconDim);
	moveDirTable->setIcon(moveIco);

	toolBar.setMaximumHeight(iconDim * 2);
}

bool DataDirWrapperSplitter::initToolbar()
{
	this->moveDirTable = new QAction(QString("&Move the Data Directory table"), this);
	toolBar.setProperty("dataDir", true);
	toolBar.addAction(moveDirTable);
	setScaledIcons();
	connect(moveDirTable, SIGNAL(triggered()), this, SLOT(onMoveDirTable()) );
	return true;
}

//----------------------------------

bool SecurityDirSplitter::initToolbar()
{
	this->saveCertAction = new QAction(QString("&Save certificate"), this);
	connect(saveCertAction, SIGNAL(triggered()), this, SLOT(onSaveCert()) );
	setScaledIcons();
	toolBar.addAction(saveCertAction);
	return true;
}

void SecurityDirSplitter::setScaledIcons()
{
	DataDirWrapperSplitter::setScaledIcons();
	if (!saveCertAction) return;
	
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	QIcon saveIco = ViewSettings::makeScaledIcon(":/icons/save_black.ico", iconDim, iconDim);
	saveCertAction->setIcon(saveIco);
}

void SecurityDirSplitter::onSaveCert()
{
	if (m_PE == NULL || myPeHndl == NULL) return;

	offset_t offset = myPeHndl->securityDirWrapper.getFieldOffset(SecurityDirWrapper::CERT_CONTENT);
	if (offset == INVALID_ADDR) return;

	bufsize_t certLen = myPeHndl->securityDirWrapper.getFieldSize(SecurityDirWrapper::CERT_CONTENT);
	
	QString filter = "All Files (*)";
	QString filename = QFileDialog::getSaveFileName(this, "Dump certificate content as...", myPeHndl->getDirPath(), filter);
	if (filename.size() == 0)
		return;

	if (m_PE->dumpFragment(offset, certLen, filename)) {
		QMessageBox::information(this,"Success","Dumped to: " + filename);
	} else {
		QMessageBox::warning(this,"Failed", "Dumping failed!");
	}
}

```

`pe-bear/gui/DataDirWrapperSplitter.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui/pe_models.h"
#include "WrapperTreeView.h"
#include "WrapperSplitter.h"

class DataDirWrapperSplitter : public WrapperSplitter, public PeViewItem
{
	Q_OBJECT

public:
	DataDirWrapperSplitter(PeHandler *peHndl, pe::dir_entry dirId, QWidget *parent)
		: PeViewItem(peHndl), WrapperSplitter(parent), dataDirId(dirId), moveDirTable(NULL)
	{
	}

	DataDirWrapperSplitter(PeHandler *peHndl, pe::dir_entry dirId, PeTreeModel *upModel, PeTreeModel *downModel, QWidget *parent)
		: PeViewItem(peHndl), WrapperSplitter(upModel, downModel, parent), dataDirId(dirId), moveDirTable(NULL)
	{
		initToolbar();
	}

	virtual ~DataDirWrapperSplitter() {}

	virtual bool initToolbar();
	virtual void setScaledIcons();
	QString chooseDumpOutDir();

public slots:
	void onMoveDirTable();
	void onGlobalFontChanged()
	{
		setScaledIcons();
	}

protected:
	QAction* moveDirTable;
	pe::dir_entry dataDirId;
};

//-----------------------------

class SecurityDirSplitter : public DataDirWrapperSplitter
{
	Q_OBJECT
public:
	SecurityDirSplitter(PeHandler *peHndl, WrapperTableModel *upModel, WrapperTableModel *downModel, QWidget *parent)
		: DataDirWrapperSplitter(peHndl, pe::DIR_SECURITY, upModel, downModel, parent), saveCertAction(NULL)
	{
		initToolbar();
	}

	virtual bool initToolbar();
	virtual void setScaledIcons();
	
public slots:
	void onSaveCert();

private:
	QAction* saveCertAction;
};

```

`pe-bear/gui/DetailsTab.cpp`:

```cpp
#include "DetailsTab.h"
#include <QtGlobal>

#define ACTION_PROP_RAW "raw"

//---------------------------------------------------------------------------
void DetailsTab::createModels()
{
	if (!m_PE) return;
	dosHdrModel = new DosHdrTableModel(myPeHndl);
	fileHdrModel = new FileHdrTreeModel(myPeHndl);
	richHdrModel = new RichHdrTreeModel(myPeHndl);
	optHdrModel = new OptionalHdrTreeModel(myPeHndl);

	secHdrsModel = new SecHdrsTreeModel(myPeHndl);
	secDiagramModel = new SecDiagramModel(myPeHndl);
	disasmModel = new DisasmModel(this->myPeHndl);

	importsModel = new ImportsTreeModel(this->myPeHndl);
	impFuncModel  = new ImportedFuncModel(myPeHndl);

	exportsModel = new ExportsTreeModel(myPeHndl);
	expFuncModel = new ExportedFuncTreeModel(myPeHndl);
	tlsModel = new TLSTreeModel(myPeHndl);
	tlsCallbacksModel = new TLSCallbacksModel(myPeHndl);
	securityModel = new SecurityTreeModel(myPeHndl);
	
	relocsModel = new RelocsTreeModel(myPeHndl);
	relocEntriesModel = new RelocEntriesModel(myPeHndl);

	ldConfigModel = new LdConfigTreeModel(myPeHndl);
	ldEntryModel = new LdEntryTreeModel(myPeHndl);

	boundImpModel = new BoundImpTreeModel(myPeHndl);
	delayImpModel = new DelayImpTreeModel(myPeHndl);
	delayFuncModel = new DelayImpFuncModel(myPeHndl);

	debugModel = new DebugTreeModel(myPeHndl);
	debugEntryModel = new DebugRDSIEntryTreeModel(myPeHndl);
	
	exceptionModel = new ExceptionTreeModel(myPeHndl);
	resourcesModel = new ResourcesTreeModel(myPeHndl);
	resourcesLeafModel = new ResourceLeafModel(myPeHndl);
	clrModel = new ClrTreeModel(myPeHndl);
}

void DetailsTab::deleteModels()
{
	delete dosHdrModel;
	delete fileHdrModel;
	delete richHdrModel;
	delete optHdrModel;
	delete secHdrsModel;
	delete disasmModel;
	delete secDiagramModel;
}

void DetailsTab::deleteSplitters()
{
	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++) {
		if (dirSplitters[i]) dirSplitters[i]->setParent(this); // will be deleted with parent
	}
	richHdrTree.setParent(this);
}

void DetailsTab::createViews()
{
	secVirtualDiagram = new SectionsDiagram(secDiagramModel, false, &secDiagramSplitter);
	secRawDiagram = new SectionsDiagram(secDiagramModel,true,  &secDiagramSplitter);

	dockedRDiagram = new QDockWidget(&this->secDiagramSplitter);
	dockedVDiagram = new QDockWidget(&this->secDiagramSplitter);
}

DetailsTab::DetailsTab(PeHandler *peHndl, QWidget *parent)
	: PeViewItem(peHndl), QTabWidget(parent),
	winAddSec(this),
	generalPanel(peHndl, this),
	dosHdrTree(this), richHdrTree(NULL),
	fileHdrTree(this), optionalHdrTree(this), disasmView(this),
	hdrsSplitter(this), secHdrTreeView(&hdrsSplitter), secDiagramSplitter(&hdrsSplitter),
	fileHdrModel(NULL), optHdrModel(NULL), secHdrsModel(NULL), importsModel(NULL), exportsModel(NULL), expFuncModel(NULL), 
	secDiagramModel(NULL), disasmModel(NULL), resourcesModel(NULL), clrModel(NULL)
{
	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++)  {
		dirSplitters[i] = NULL;
		dirUpModels[i] = NULL;
		dirDownModels[i] = NULL;
	}
	if (!myPeHndl || !m_PE) return;

	setFocusPolicy(Qt::StrongFocus);
	memset(dirTabIds, (-1), pe::DIR_ENTRIES_COUNT * sizeof(dirTabIds[0]));

	createModels();
	createViews();

	this->setWindowTitle(myPeHndl->getShortName());
	this->disasmView.setModel(disasmModel);

	// dosHdrTree
	this->dosHdrTree.setModel(this->dosHdrModel);
	this->dosHdrTree.resizeColsToContent();
	
	//RichHdr
	this->richHdrTree.setModel(this->richHdrModel);
	this->richHdrTree.resizeColsToContent();

	// FileHeader tree
	this->fileHdrTree.setModel(fileHdrModel);
	this->fileHdrTree.resizeColumnToContents(1);
	this->fileHdrTree.expandAll();

	// Optional Header tree
	this->optionalHdrTree.setModel(optHdrModel);
	this->optionalHdrTree.expandAll();
	this->optionalHdrTree.resizeColumnToContents(1);
	this->optionalHdrTree.resizeColumnToContents(3);
	
	this->hdrsSplitter.setOrientation(Qt::Vertical);
	setupSectionsToolbar(&hdrsSplitter);
	this->hdrsSplitter.addWidget(&this->secHdrTreeView);
	this->hdrsSplitter.addWidget(&this->secDiagramSplitter);
	this->hdrsSplitter.setAutoFillBackground(true);

	this->secHdrTreeView.autoExpand = false;
	this->secHdrTreeView.setModel(secHdrsModel);
	
#if QT_VERSION >= 0x050000
	this->secHdrTreeView.header()->setSectionResizeMode(QHeaderView::ResizeToContents);
#else
	this->secHdrTreeView.header()->setResizeMode(QHeaderView::ResizeToContents);
#endif
	
	// sections graph
	dockedRDiagram->setWindowTitle("Raw");
	dockedVDiagram->setWindowTitle("Virtual");

	dockedRDiagram->setWidget(this->secRawDiagram);
	this->dockedRDiagram->setParent(&this->secDiagramSplitter);

	this->dockedVDiagram->setWidget(this->secVirtualDiagram);
	this->dockedVDiagram->setParent(&this->secDiagramSplitter);
	this->secDiagramSplitter.setAutoFillBackground(true);

	// IMPORTS
	dirSplitters[pe::DIR_IMPORT] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_IMPORT, importsModel, impFuncModel, NULL);
	dirSplitters[pe::DIR_IMPORT]->title = "Imports";
	setupImportsToolbar();

	// EXPORTS
	dirSplitters[pe::DIR_EXPORT] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_EXPORT, exportsModel, expFuncModel, NULL);
	dirSplitters[pe::DIR_EXPORT]->title = "Exports";
	//---
	// TLS
	dirSplitters[pe::DIR_TLS] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_TLS, tlsModel, tlsCallbacksModel, NULL);
	dirSplitters[pe::DIR_TLS]->title = "TLS";

	// BASE_RELOCS
	dirSplitters[pe::DIR_BASERELOC] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_BASERELOC, relocsModel, relocEntriesModel, NULL);
	dirSplitters[pe::DIR_BASERELOC]->title = "BaseReloc.";
	
	//SECURITY
	dirSplitters[pe::DIR_SECURITY] = new SecurityDirSplitter(this->myPeHndl, securityModel, NULL, NULL);
	dirSplitters[pe::DIR_SECURITY]->title = "Security";

	// LD_CONFIG
	dirSplitters[pe::DIR_LOAD_CONFIG] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_LOAD_CONFIG, ldConfigModel, ldEntryModel, NULL);
	dirSplitters[pe::DIR_LOAD_CONFIG]->title = "LoadConfig";
	
	// BOUND_IMPORTS
	dirSplitters[pe::DIR_BOUND_IMPORT] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_BOUND_IMPORT, boundImpModel, NULL, NULL);
	dirSplitters[pe::DIR_BOUND_IMPORT]->title = "BoundImports";

	// DELAY_IMPORTS
	dirSplitters[pe::DIR_DELAY_IMPORT] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_DELAY_IMPORT, delayImpModel, delayFuncModel, NULL);
	dirSplitters[pe::DIR_DELAY_IMPORT]->title = "DelayedImps";
	
	// DEBUG
	dirSplitters[pe::DIR_DEBUG] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_DEBUG, debugModel, debugEntryModel, NULL);
	dirSplitters[pe::DIR_DEBUG]->title = "Debug";

	// EXCEPTION
	dirSplitters[pe::DIR_EXCEPTION] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_EXCEPTION, exceptionModel, NULL, NULL);
	dirSplitters[pe::DIR_EXCEPTION]->title = "Exception";

	// RESOURCES
	dirSplitters[pe::DIR_RESOURCE] = new ResourcesDirSplitter(this->myPeHndl, resourcesModel, resourcesLeafModel, NULL);
	dirSplitters[pe::DIR_RESOURCE]->title = "Resources";
	
	//CLR
	dirSplitters[pe::DIR_COM_DESCRIPTOR] = new DataDirWrapperSplitter(this->myPeHndl, pe::DIR_COM_DESCRIPTOR, clrModel, NULL, NULL);
	dirSplitters[pe::DIR_COM_DESCRIPTOR]->title = ".NET Hdr";

	cDisasmTab = addTab(&disasmView, "Disasm");
	cGeneralTab = addTab(&generalPanel, "General");

	cDOSHdrTab = addTab(&dosHdrTree, "DOS Hdr");
	if (peHndl && peHndl->getPe() && peHndl->getPe()->getRichHeaderSign()) {
		cRichHdrTab = addTab(&richHdrTree, "Rich Hdr");
	}
	cFileHdrsTab = addTab(&fileHdrTree, "File Hdr");
	cOptHdrsTab = addTab(&optionalHdrTree, "Optional Hdr");
	cSecHdrsTab = addTab(&hdrsSplitter, "Section Hdrs");

	setScaledIcons();
	reloadDirView();

	connect(this->myPeHndl, SIGNAL(modified()), this, SLOT(reloadDirView()) );
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), this, SLOT(setDisasmTabText(offset_t)) );
	connect(this->myPeHndl, SIGNAL(pageOffsetModified(offset_t, bufsize_t)), disasmModel, SLOT(setShownContent(offset_t, bufsize_t)) );

	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++) {
		const pe::dir_entry dirNum = pe::dir_entry(i);
		const DataDirWrapperSplitter *splitter = dirSplitters[dirNum];
		if (splitter) {
			connect(this, SIGNAL(globalFontChanged()), splitter, SLOT(onGlobalFontChanged()) );
		}
	}
}

DetailsTab::~DetailsTab()
{
	deleteModels();
	deleteSplitters();
}

void DetailsTab::onAddSection()
{
	this->winAddSec.onAddSectionToPe(myPeHndl);
}

void DetailsTab::onFitSections()
{
	offset_t fileSize = m_PE->getRawSize();
	offset_t lastRaw = this->m_PE->getLastMapped(Executable::RAW);

	offset_t imageSize = m_PE->getImageSize();
	offset_t lastRva = this->m_PE->getLastMapped(Executable::RVA);
	const bool fileToResize = fileSize != lastRaw;
	const bool imageToResize = imageSize != lastRva;

	QString info = "Last mapped raw = "+ QString::number(lastRaw, 16) + " when File Size = "+ QString::number(fileSize, 16);
	info += "\nLast mapped RVA = " +  QString::number(lastRva, 16) + " when Image Size = "+ QString::number(imageSize, 16);

	if (!fileToResize && !imageToResize) {
		QMessageBox::information(NULL, "No resizing required!", info);
		return;
	}

	QString whatToResize = fileToResize ? "File": "";
	if (imageToResize) {
		if (whatToResize.length() > 0) whatToResize +=" and ";
		whatToResize += "Image";
	}
	QString confirmation = "Do you want to resize " + whatToResize  +" to fit?\nFile resizing cannot be undone!\n";
	QMessageBox::StandardButton reply = QMessageBox::question(NULL, "Do you really want to resize?", confirmation + '\n' + info,  QMessageBox::Yes|QMessageBox::No);                     
	if (reply != QMessageBox::Yes) return;  

	bool fOk = !fileToResize;
	bool iOk = !imageToResize;

	if (imageToResize) iOk = this->myPeHndl->resizeImage(lastRva);
	if (fileToResize) fOk = this->myPeHndl->resize(lastRaw);

	if (fOk && iOk) {
		QMessageBox::information(NULL, "Done!", "Resizing succeeded!");
		return;
	}

	if (!fOk) QMessageBox::warning(NULL, "Failed!", "Failed resizing the File!");
	if (!iOk) QMessageBox::warning(NULL, "Failed!", "Failed resizing the Image!");
}

void DetailsTab::onAddImportLib()
{
	if (!myPeHndl->addImportLib()) {
		QMessageBox::warning(NULL, "Failed!", "No space to add a new entry!\nYou must move the table first!");
		return;
	}
}

void DetailsTab::onAddImportFunc()
{
	if (dirSplitters[pe::DIR_IMPORT] == NULL) return;

	QModelIndexList list = dirSplitters[pe::DIR_IMPORT]->getUpperViewSelected();
	if (list.size() == 0) {
		QMessageBox::warning(NULL, "Failed", "No library selected!");
		return;
	}
	uint32_t selectedLib = list.at(0).row();
	if (!myPeHndl->addImportFunc(selectedLib)) {
		QMessageBox::warning(NULL, "Failed!", "No space to add a function entry!");
		return;
	}
}

void DetailsTab::onGlobalFontChanged()
{
	QMutexLocker locker(&fontMutex);
	
	setFont(QApplication::font());
	setScaledIcons();
	reloadDirViewIcons();
	emit globalFontChanged(); // forward the signal
}

void DetailsTab::setScaledIcons()
{
	if (!sectionsToolBar) {
		return; //not initialized
	}

	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());

	QIcon addIco = ViewSettings::makeScaledIcon(":/icons/add_entry.ico", iconDim, iconDim);
	this->addSection->setIcon(addIco);
	this->addImportLib->setIcon(addIco);

	QIcon resizeIco = ViewSettings::makeScaledIcon(":/icons/resize.ico", iconDim, iconDim);
	this->fitSections->setIcon(resizeIco);

	QIcon addSubIco = ViewSettings::makeScaledIcon(":/icons/add_subentry.ico", iconDim, iconDim);
	this->addImportFunc->setIcon(addSubIco);
	
	sectionsToolBar->setFont(QApplication::font());
	sectionsToolBar->setMaximumHeight(iconDim * 2);
	sectionsToolBar->layout()->setSpacing(iconDim);
	
	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++) {
		pe::dir_entry dirNum = pe::dir_entry(i);
		if (dirTabIds[dirNum] != (-1)) {
			QToolBar *toolBar = &dirSplitters[dirNum]->toolBar;
			toolBar->setMaximumHeight(iconDim * 2);
			toolBar->layout()->setSpacing(iconDim);
			toolBar->setFont(QApplication::font());
		}
	}
}

void DetailsTab::setupSectionsToolbar(QSplitter *owner)
{
	if (!owner) return;
	
	this->sectionsToolBar = new QToolBar(owner);
	sectionsToolBar->setProperty("dataDir", true);
	owner->addWidget(sectionsToolBar);

	this->addSection = new QAction(QString("&Add a section"), this);
	connect(addSection, SIGNAL(triggered()), this, SLOT(onAddSection()) );

	this->fitSections = new QAction(QString("&Resize to fit sections"), this);
	connect(fitSections, SIGNAL(triggered()), this, SLOT(onFitSections()) );

	sectionsToolBar->addAction(addSection);
	sectionsToolBar->addAction(fitSections);
}

void DetailsTab::setupImportsToolbar()
{
	if (dirSplitters[pe::DIR_IMPORT] == NULL) return;

	QToolBar *toolBar = &dirSplitters[pe::DIR_IMPORT]->toolBar;

	this->addImportLib = new QAction(QString("&Add a library"), this);
	connect(addImportLib, SIGNAL(triggered()), this, SLOT(onAddImportLib()) );

	this->addImportFunc = new QAction(QString("&Add a function to the library"), this);
	connect(addImportFunc, SIGNAL(triggered()), this, SLOT(onAddImportFunc()) );

	toolBar->addAction(addImportLib);
	toolBar->addAction(addImportFunc);
}

void DetailsTab::setDisasmTabText(offset_t raw)
{
	if (!m_PE) {
		setTabText(this->cDisasmTab, "Disasm");
		return;
	}
	int size = PREVIEW_SIZE;
	offset_t endAddr = raw + size;
	//roundup to the file end
	if (m_PE->getRawSize() < size) 
		endAddr = raw + m_PE->getRawSize();
	
	QString secName = "";
	SectionHdrWrapper *sec = m_PE->getSecHdrAtOffset(raw, Executable::RAW);
	SectionHdrWrapper *sec2 = m_PE->getSecHdrAtOffset(endAddr, Executable::RAW);

	//display section names
	if (sec && sec == sec2) {
		secName = ": " + sec->mappedName;
	} else if (sec || sec2) {
		QString sec1Name = sec ? "[" + sec->mappedName + "]" : "Headers";
		QString sec2Name = sec2 ? "[" + sec2->mappedName + "]" : "";

		secName = ": " + sec1Name;
		if (sec2Name.size()) 
			secName += " to " + sec2Name;
	}
	setTabText(this->cDisasmTab, "Disasm" + secName);
}

void DetailsTab::shirtTabsAfter(pe::dir_entry dirNum, bool toTheLeft)
{
	if (!m_PE || (dirNum >= pe::DIR_ENTRIES_COUNT)) return;
	// shift tabs:
	for (int nextTab = dirNum + 1; nextTab < pe::DIR_ENTRIES_COUNT; nextTab++) {
		if (dirTabIds[nextTab] == (-1)) {
			continue; // the tab not found, nothing to do
		}
		if (toTheLeft) {
			dirTabIds[nextTab]--; // shift the tab index to the left
		}
		else {
			dirTabIds[nextTab]++; // shift the tab index to the right
		}
	}
}

void DetailsTab::manageDirTab(pe::dir_entry dirNum)
{
	if (!myPeHndl || !m_PE) return;

	const bool hasDataDir = this->myPeHndl->hasDirectory(dirNum); //can the Data Dir be properly parsed?
	const bool hasDirTab = (dirTabIds[dirNum] != (-1)) ? true : false;
	if (hasDataDir == hasDirTab) {
		// no changes required
		return;
	}
	// Data Dir no longer exist, remove the tab:
	if (!hasDataDir && hasDirTab) {
		// the tab for non-existing dir was found:
		removeTab(dirTabIds[dirNum]);
		dirTabIds[dirNum] = (-1);
		// shift tabs:
		shirtTabsAfter(dirNum, true);
		return;
	}
	// Data Dir was created, add a tab for it:
	if (hasDataDir && !hasDirTab) {
		//find index
		int lastBefore = this->cSecHdrsTab;
		for (int i = dirNum - 1; i >= 0; i--) {
			if (dirTabIds[i] != (-1)) {
				lastBefore = dirTabIds[i];
				break;
			}
		}
		int tabIndex = lastBefore + 1;

		if (!dirSplitters[dirNum]) return; // should never happen
		//attach tab
		dirTabIds[dirNum] = this->insertTab(tabIndex, dirSplitters[dirNum], dirSplitters[dirNum]->title);

		const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
		QIcon dataDirIco = ViewSettings::makeScaledIcon(":/icons/data_dir_gray.ico", iconDim, iconDim);

		this->setTabIcon(dirTabIds[dirNum], dataDirIco);
		this->setTabToolTip(dirTabIds[dirNum], "Data Directory[" + QString::number(dirNum) + "]: " + dirSplitters[dirNum]->title);
		// shift tabs:
		shirtTabsAfter(dirNum, false);
	}
}

void DetailsTab::reloadDirView()
{
	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++) {
		manageDirTab(pe::dir_entry(i));
	}
}

void DetailsTab::reloadDirViewIcons()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	QIcon dataDirIco = ViewSettings::makeScaledIcon(":/icons/data_dir_gray.ico", iconDim, iconDim);
	
	setIconSize(QSize(iconDim, iconDim));
	
	for (int i = 0; i < pe::DIR_ENTRIES_COUNT; i++) {
		pe::dir_entry dirNum = pe::dir_entry(i);
		if (dirTabIds[dirNum] != (-1)) {
			this->setTabIcon(dirTabIds[dirNum], dataDirIco);
		}
	}
}

//----------------------------------


```

`pe-bear/gui/DetailsTab.h`:

```h
#pragma once

#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui/pe_models.h"
#include "../gui_base/PeGuiItem.h"
#include "../gui/windows/SectionAddWindow.h"
#include "../gui/DosHdrTableModel.h"

#include "../HexView.h"
#include "../DisasmView.h"
#include "../gui_base/PeTreeView.h"
#include "../SectionsDiagram.h"
#include "GeneralPanel.h"
#include "WrapperTreeView.h"
#include "DataDirWrapperSplitter.h"
#include "ResourceDirSplitter.h"

class DetailsTab : public QTabWidget, public PeViewItem
{
    Q_OBJECT
public:
	DetailsTab(PeHandler *peHndl, QWidget *parent);
	~DetailsTab();
	
	DisasmTreeView disasmView;
	
signals:
	void globalFontChanged();

public slots:
	void onGlobalFontChanged();

protected slots:
	void onAddSection();
	void onFitSections();
	void onAddImportLib();
	void onAddImportFunc();

	void setDisasmTabText(offset_t raw);

	void reloadDirView();
	void manageDirTab(pe::dir_entry dirNum);

protected:
	void shirtTabsAfter(pe::dir_entry dirNum, bool toTheLeft);
	void createModels();
	void deleteModels();
	void deleteSplitters();
	void createViews();

	void setupSectionsToolbar(QSplitter *owner);
	void setupImportsToolbar();
	void setScaledIcons();
	void reloadDirViewIcons();

	/* models */
	DosHdrTableModel *dosHdrModel;
	RichHdrTreeModel* richHdrModel;
	FileHdrTreeModel* fileHdrModel;
	OptionalHdrTreeModel* optHdrModel;
	SecHdrsTreeModel* secHdrsModel;
	
	ImportsTreeModel* importsModel;
	ImportedFuncModel* impFuncModel;

	ExportsTreeModel* exportsModel;
	ExportedFuncTreeModel* expFuncModel;

	SecDiagramModel *secDiagramModel;

	TLSTreeModel *tlsModel;
	TLSCallbacksModel *tlsCallbacksModel;
	RelocsTreeModel *relocsModel;
	RelocEntriesModel *relocEntriesModel;

	SecurityTreeModel *securityModel;
	LdConfigTreeModel *ldConfigModel;
	LdEntryTreeModel* ldEntryModel;
	BoundImpTreeModel *boundImpModel;

	DelayImpTreeModel *delayImpModel;
	DelayImpFuncModel *delayFuncModel;
	ClrTreeModel *clrModel;

	DebugTreeModel *debugModel;
	DebugRDSIEntryTreeModel *debugEntryModel;
	
	ExceptionTreeModel *exceptionModel;
	ResourcesTreeModel *resourcesModel;
	ResourceLeafModel  *resourcesLeafModel;

	DisasmModel *disasmModel;

	/* splitters */
	QSplitter hdrsSplitter;
	QSplitter secDiagramSplitter;
	DataDirWrapperSplitter* dirSplitters[pe::DIR_ENTRIES_COUNT];
	WrapperTableModel* dirUpModels[pe::DIR_ENTRIES_COUNT];
	WrapperTableModel* dirDownModels[pe::DIR_ENTRIES_COUNT];

	GeneralPanel generalPanel;

	/* views */
	FollowablePeTreeView dosHdrTree;
	FollowablePeTreeView richHdrTree;
	FollowablePeTreeView fileHdrTree;
	FollowablePeTreeView optionalHdrTree;
	FollowablePeTreeView secHdrTreeView;

	SectionsDiagram *secRawDiagram, *secVirtualDiagram;
	
	/* widgets */
	QDockWidget* dockedRDiagram, *dockedVDiagram;
	
	QToolBar *sectionsToolBar;
	QAction *addSection, *fitSections, *addImportLib, *addImportFunc;

	SectionAddWindow winAddSec;
	QMutex fontMutex;

	/* tabs indexes */
	int cDisasmTab, cDOSHdrTab, cRichHdrTab, cFileHdrsTab, cOptHdrsTab, cSecHdrsTab, cGeneralTab;
	int dirTabIds[pe::DIR_ENTRIES_COUNT];
};

```

`pe-bear/gui/DosHdrTableModel.cpp`:

```cpp
#include "DosHdrTableModel.h"

enum COLS {
	COL_OFFSET = 0,
	COL_NAME,
	COL_VALUE,
	MAX_COL
};


DosHdrTableModel::DosHdrTableModel(PeHandler *peHndl, QObject *parent)
    : WrapperTableModel(peHndl, parent)
{
	connectSignals();
}

QVariant DosHdrTableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case COL_OFFSET: return "Offset";
		case COL_NAME: return "Name";
		case COL_VALUE:  return "Value";
	}
	return QVariant();
}

Qt::ItemFlags DosHdrTableModel::flags(const QModelIndex &index) const
{ 
	if (!index.isValid()) return Qt::NoItemFlags;

	if (index.column() == COL_VALUE) return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
	
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

bool DosHdrTableModel::isComplexValue(const QModelIndex &index) const
{
	int fId = getFID(index);

	if (fId == DosHdrWrapper::RES || fId == DosHdrWrapper::RES2) return true;
	return false;
}

QVariant DosHdrTableModel::data(const QModelIndex &index, int role) const
{
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (index.column() == COL_OFFSET || index.column() == COL_VALUE) {
			return offsetFont;
		}
	}
	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role == Qt::DisplayRole || role == Qt::EditRole) {

		if (index.column() == COL_OFFSET) return QString::number(getFieldOffset(index), 16);
		if (index.column() == COL_NAME) {
			int fId = getFID(index);
			return wrapper()->getFieldName(fId);
		}
		return this->dataValue(index);
	}	
	return QVariant();
}

bool DosHdrTableModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	int fId = getFID(index);
	uint32_t offset = wrapper()->getFieldOffset(fId);
	uint32_t fieldSize = wrapper()->getFieldSize(fId);

	bool isModified = false;

	if (this->isComplexValue(index)) {
		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = setComplexValue(index, value, role);
	} else {
		QString text = value.toString();
		bool isOk = false;
		ULONGLONG number = text.toLongLong(&isOk, 16);
		if (!isOk) return false;

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = wrapper()->setNumValue(fId, index.column(), number);
	}

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}


```

`pe-bear/gui/DosHdrTableModel.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <map>
#include <set>

#include "PeWrapperModel.h"
#include "../gui_base/WrapperTableModel.h"

class DosHdrTableModel : public WrapperTableModel
{
	Q_OBJECT

public:
	enum COLS {
		COL_OFFSET = 0,
		COL_NAME,
		COL_VALUE,
		MAX_COL
	};

	DosHdrTableModel(PeHandler *peHndl, QObject *parent = 0);
	virtual ~DosHdrTableModel() { }

	virtual int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;
	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	bool containsValue(QModelIndex index) const { return (index.column() == COL_VALUE); }

protected:
	virtual int getSID(const QModelIndex &index) const { return index.column() - COL_VALUE; }
	virtual bool isComplexValue(const QModelIndex &index) const;

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->dosHdrWrapper; }
};

```

`pe-bear/gui/GeneralPanel.cpp`:

```cpp
#include "GeneralPanel.h"
#include <QtGlobal>
#include <bearparser/bearparser.h>

enum InfoFieldId {
	INFO_NONE = -1,
	INFO_NAME = 0,
	INFO_IS_TRUNCATED,
	INFO_FILE_SIZE,
	INFO_LOADED_SIZE,
	INFO_UNITS,
	INFO_CHECKSUM,
	INFO_MD5,
	INFO_SHA1,
	INFO_SHA256,
	INFO_COUNTER
};

InfoTableModel::InfoTableModel(PeHandler *peHndl, QObject *parent)
	: PeTableModel(peHndl, parent)
{
}

QVariant InfoTableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	if (orientation == Qt::Horizontal) return "File info";
	if (orientation == Qt::Vertical) {
		switch (section) {
			case INFO_NAME: return "Path";
			case INFO_IS_TRUNCATED : return "Is Truncated?";
			case INFO_UNITS : return "File Alignment Units";
			case INFO_LOADED_SIZE: return "Loaded size";
			case INFO_FILE_SIZE: return "File size";
			case INFO_MD5:  return "MD5";
			case INFO_SHA1: return "SHA1";
#if QT_VERSION >= 0x050000
			case INFO_SHA256: return "SHA256";
#endif
			case INFO_CHECKSUM: return "Checksum";
		}
	}
	return QVariant();
}

Qt::ItemFlags InfoTableModel::flags(const QModelIndex &index) const
{
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}
	const int row = index.row();
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
}

int InfoTableModel::rowCount(const QModelIndex &parent) const
{
#if QT_VERSION >= 0x050000
	return INFO_COUNTER;
#else
	return (INFO_COUNTER - 1);
#endif
}


QVariant InfoTableModel::data(const QModelIndex &index, int role) const
{
	int row = index.row();
	int column = index.column();
	
	if (row == INFO_UNITS || row == INFO_LOADED_SIZE) {
		if (role == Qt::ToolTipRole) return "(decimal)\nedit to resize the file";
	}
	if (row != INFO_UNITS && row != INFO_LOADED_SIZE) {
		if (role == Qt::BackgroundRole) return QColor(211, 211, 211, 100); // not editable
	}
	
	if (role != Qt::DisplayRole && role != Qt::EditRole && role != Qt::ToolTipRole) return QVariant();

	switch (row) {
		case INFO_NAME: return this->myPeHndl->getFullName();
		case INFO_IS_TRUNCATED : {
			if (role == Qt::ToolTipRole) {
				static QString info = "Some files are too large and they must be loaded truncated.";
				return info;
			}
			return m_PE->isTruncated() ? "Yes" : "No";
		}
		case INFO_LOADED_SIZE: return static_cast<qlonglong>(m_PE->getRawSize());
		case INFO_FILE_SIZE: return static_cast<qlonglong>(m_PE->getFileSize());
		case INFO_UNITS: {
			const size_t fileAlign = m_PE->getFileAlignment();
			if (!fileAlign) return 0;
			return static_cast<qlonglong>(pe_util::roundup(m_PE->getRawSize(), fileAlign) / fileAlign);
		}
		case INFO_MD5: return myPeHndl->getCurrentMd5();
		case INFO_SHA1: return myPeHndl->getCurrentSHA1();
#if QT_VERSION >= 0x050000
		case INFO_SHA256: return myPeHndl->getCurrentSHA256();
#endif
		case INFO_CHECKSUM: return myPeHndl->getCurrentChecksum();
	}
	return QVariant();
}

bool InfoTableModel::setData(const QModelIndex &index, const QVariant &data, int role)
{
	const int row = index.row();
	if (row != INFO_UNITS && row != INFO_LOADED_SIZE) return false;

	int64_t newSize = 0;
	if (row == INFO_UNITS) {
		int64_t newUnits = data.toInt();
		const bufsize_t fileAlign = m_PE->getFileAlignment();
		int64_t current = fileAlign ? (pe_util::roundup(m_PE->getRawSize(), fileAlign) / fileAlign) : 0;

		if (newUnits == current) return false;
		int64_t dif = (newUnits - current) * m_PE->getFileAlignment();
		newSize = m_PE->getRawSize() + dif;

	} else if (row == INFO_LOADED_SIZE) {
			newSize = data.toInt();
	}

	static QString alert = "Do your really want to resize file?\nThis operation cannot be undone...";
	static QPixmap enlarge(":/icons/enlarge.ico");
	static QPixmap shrink(":/icons/shrink.ico");

	QMessageBox msgBox;
	msgBox.setText(alert);

	msgBox.addButton("Yes, continue", QMessageBox::AcceptRole);
	msgBox.addButton("No, abort", QMessageBox::RejectRole);
	QString info;

	int64_t currentSize = m_PE->getRawSize();
	int64_t dif;
	if (!m_PE->canResize(newSize)) {
		QMessageBox msgBox;
		msgBox.setText("Incorrect new size supplied!");

		if (newSize < currentSize)
			msgBox.setInformativeText("Choose the size that will not damage headers!");
		else
			msgBox.setInformativeText("Too big!");
		msgBox.exec();
		return false;
	}
	if (newSize == currentSize)  return false;

	if (newSize < currentSize) {
		dif = currentSize - newSize;
		msgBox.setIconPixmap(shrink);
		info = "bytes are going to be cropped!";
	} else {
		dif = newSize - currentSize;
		msgBox.setIconPixmap(enlarge);
		info = "bytes are going to be added!";
	}
	msgBox.setInformativeText( QString::number((uint32_t) dif) + " (0x"+ QString::number((uint32_t)dif, 16) + ") "+ info);

	int res = msgBox.exec();
	if (res != QMessageBox::AcceptRole) return false;

	bool isOk = myPeHndl->resize(newSize);
	if (!isOk) {
		QMessageBox msgBox;
		msgBox.setText("Resizing failed!");
		msgBox.exec();
	}
	return isOk;
}

//--------------------------
GeneralPanel::GeneralPanel(PeHandler *peHndl, QWidget *parent)
	: QSplitter(Qt::Horizontal, parent), PeViewItem(peHndl),
	packersModel(peHndl, this), packersTree(this),
	generalInfoModel(peHndl, this), generalInfo(this),
	packersDock(NULL)
{
	if (!this->myPeHndl) return;
	if (!this->myPeHndl->getPe()) return;
	init();
	connectSignals();
}

void GeneralPanel::init()
{
	this->setOrientation(Qt::Vertical);
	QHeaderView *hdr = generalInfo.horizontalHeader();
	if (hdr) hdr->setStretchLastSection(true);

	generalInfo.setModel(&generalInfoModel);
	this->addWidget(&generalInfo);

	packersTree.setItemsExpandable(false);
	packersTree.setRootIsDecorated(false);
	packersTree.setModel(&this->packersModel);

	packersDock = new QDockWidget(this);
	packersDock->setFeatures(0);
	packersDock->setWidget(&packersTree);
	packersDock->setWindowIcon(QIcon(":/icons/Locked.ico"));
	packersDock->setWindowTitle("Found signatures");
	this->addWidget(packersDock);
	this->packersDock->setVisible(this->myPeHndl->isPacked());
}

void GeneralPanel::connectSignals()
{
	if (!myPeHndl) return;

	connect(myPeHndl, SIGNAL(modified()), this, SLOT(refreshView()));
	connect(myPeHndl, SIGNAL(foundSignatures(int, int)), this, SLOT(refreshView()));
	connect(myPeHndl, SIGNAL(hashChanged()), &generalInfoModel, SLOT(onNeedReset()));
}

void GeneralPanel::refreshView()
{
	if (!myPeHndl) return;

	this->generalInfo.reset();
	this->packersTree.reset();
	this->packersDock->setVisible(this->myPeHndl->isPacked());
}

```

`pe-bear/gui/GeneralPanel.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui_base/PeGuiItem.h"
#include "../gui_base/ExtTableView.h"

#include "PackersTableModel.h"


class InfoTableModel : public PeTableModel
{
	Q_OBJECT

public:
	InfoTableModel(PeHandler *peHndl, QObject *parent = 0);
	virtual ~InfoTableModel() { }
	
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;
	
	int columnCount(const QModelIndex &parent) const { return 1; }
	int rowCount(const QModelIndex &parent) const;
	
	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);

	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const 
	{
		return createIndex(row, column); //no index item pointer
	}

	QModelIndex parent(const QModelIndex &index) const { return QModelIndex(); } // no parent
};

class GeneralPanel : public QSplitter, public PeViewItem
{
	Q_OBJECT
public:
	GeneralPanel(PeHandler *peHndl, QWidget *parent);

protected slots:
	void refreshView();

protected:
	void init();
	void connectSignals();
	
	QDockWidget *packersDock;
	QTextEdit md5Text;
	QTextEdit pathText;

	ExtTableView generalInfo;
	InfoTableModel generalInfoModel;
	FollowablePeTreeView packersTree;
	PackersTableModel packersModel;
};

```

`pe-bear/gui/HexDiffModel.cpp`:

```cpp
#include "HexDiffModel.h"
#include <QtGlobal>
#include <bear_disasm.h>

#define PREVIEW_SIZE 0x200

int32_t HexDiffModel::getDiffStart(BYTE *content1Ptr, bufsize_t size1, BYTE *content2Ptr, bufsize_t size2)
{
	if (content1Ptr == NULL && content2Ptr == NULL) return (-1);
	
	if (content1Ptr == NULL || content2Ptr == NULL) return 0;

	if (content1Ptr == content2Ptr && size1 == size2) return (-1);
	
	size_t cmpSize = (size1 > size2 )? size2 : size1;
	int cmpRes = memcmp(content1Ptr, content2Ptr, cmpSize);
	if (cmpRes == 0) return -1;

	int32_t minSize = (size1 < size2) ? size1 : size2;
	for (int32_t i = 0; i < minSize; i++) {
		if (content1Ptr[i] != content2Ptr[i]) return i;
	}
	return (-1);
}

int32_t HexDiffModel::getDiffEnd(BYTE *content1Ptr, bufsize_t size1, BYTE *content2Ptr, bufsize_t size2)
{
	if (content1Ptr == NULL && content2Ptr == NULL) return (-1);
	
	if (content1Ptr == NULL || content2Ptr == NULL) return 0;

	if (content1Ptr == content2Ptr && size1 == size2) return (-1);
		
	int32_t minSize = (size1 < size2) ? size1 : size2;

	for (int32_t i = 0; i < minSize; i++) {
		if (content1Ptr[i] == content2Ptr[i]) return i;
	}
	return (-1);
}


HexDiffModel::HexDiffModel(ContentIndx indx, QObject *parent)
	: QAbstractTableModel(parent), myIndx(indx),
	showHex(true), startOff(0), pageSize(PREVIEW_SIZE), 
	relativeOffset(false)
{
	clearContent(CNTR);

	diffColor = QColor("red");
	diffColor.setAlpha(150);

	limitColor = QColor("yellow");
	limitColor.setAlpha(150);
}

void HexDiffModel::setContent(BYTE* contentPtr, int size, offset_t contentOff, ContentIndx indx)
{
	startOff = 0;
	if (contentPtr == NULL || size == 0) {
		clearContent(indx);
		return;
	}
	if (indx == CNTR) return;
	
	this->contentPtr[indx] = contentPtr;
	this->contentSize[indx] = size;
	contentOffset[indx] = contentOff;
	this->reset();
}

void HexDiffModel::clearContent(ContentIndx indx)
{
	startOff = 0;
	if (indx == CNTR) {
		contentPtr[LEFT] = NULL;
		contentPtr[RIGHT] = NULL;
		
		contentSize[LEFT] = 0;
		contentSize[RIGHT] = 0;

		contentOffset[LEFT] = 0;
		contentOffset[RIGHT] = 0;
	} else {
		contentPtr[indx] = NULL;
		contentSize[indx] = 0;
		contentOffset[indx] = 0;
	}
	this->reset();
}

void HexDiffModel::onGoToNextDiff()
{
	if (contentSize[LEFT] == 0 || contentSize[RIGHT] == 0) return;
	if (contentSize[LEFT] < this->startOff) return;
	if (contentSize[RIGHT] < this->startOff) return;

	offset_t offset = this->startOff;
	int leftSize = contentSize[LEFT] - offset;
	int rightSize = contentSize[RIGHT] - offset;

	bufsize_t diff = HexDiffModel::getDiffStart(
		&contentPtr[LEFT][this->startOff],
		contentSize[LEFT],
		&contentPtr[RIGHT][this->startOff],
		contentSize[RIGHT]
	);
	
	if (diff == (-1)) return;
	
	offset += diff;
	if (diff != 0) {
		setStartingOffset(offset);
		return;
	}

	leftSize = contentSize[LEFT] - offset;
	rightSize = contentSize[RIGHT] - offset;

	diff = HexDiffModel::getDiffEnd(&contentPtr[LEFT][offset], leftSize, &contentPtr[RIGHT][offset], rightSize);

	if (diff == (-1)) return;

	offset += diff;
	leftSize = contentSize[LEFT] - offset;
	rightSize = contentSize[RIGHT] - offset;
	diff = HexDiffModel::getDiffStart(&contentPtr[LEFT][offset], leftSize, &contentPtr[RIGHT][offset], rightSize);

	if (diff != (-1)) {
		offset += diff;
		if (diff != 0)
			setStartingOffset(offset);
	}
}

void HexDiffModel::onGoToPrevDiff()
{
	//TODO....
}

int HexDiffModel::rowCount(const QModelIndex &parent) const
{
	if (this->contentSize[myIndx] < this->startOff)
		return 0;
	int rows = pageSize / HEX_COL_NUM;
	return rows;
}

int HexDiffModel::columnCount(const QModelIndex &parent) const
{
	return COL_NUM;
}

QVariant HexDiffModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role == Qt::FontRole) {
		QFont hdrFont = settings.myFont;
		hdrFont.setBold(true);
		hdrFont.setItalic(false);
		return hdrFont;
	}
	
	if (orientation == Qt::Horizontal) {
		if (role == Qt::SizeHintRole) {
			int iconDim = ViewSettings::getIconDim(settings.myFont);
			return QSize(iconDim, iconDim);
		}
		
		if (role == Qt::DisplayRole) {
			if (section >= COL_NUM) return QVariant();
			return QString::number(section, 16).toUpper();
		}
		return QVariant();
	}
	
	if (orientation == Qt::Vertical) {
		if (role == Qt::SizeHintRole) {
			return settings.getVerticalSize();
		}
		if (role == Qt::DisplayRole) {
			int offset = startOff + (section * HEX_COL_NUM);
			if (isRelativeOffset() == false) {
				offset += this->contentOffset[myIndx];
			}
			const QString offsetStr = QString::number(offset, 16).toUpper();
			return offsetStr;
		}
		return QVariant();
	}
	return QVariant();
}

Qt::ItemFlags HexDiffModel::flags(const QModelIndex &index) const 
{
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

QVariant HexDiffModel::data(const QModelIndex &index, int role) const
{
	if (index.isValid() == false) return QVariant();

	if (index.column() == COL_NUM) {
		return QVariant();
	}

	int x = index.column();
	int y = index.row() * HEX_COL_NUM;
	size_t indx = (y + x) + startOff;

	if (role == Qt::FontRole) {
		return settings.myFont;
	}
	if (role == Qt::ForegroundRole) {
		return QVariant();
	}
	if (role == Qt::BackgroundColorRole) {
		ContentIndx otherIndx = (myIndx == LEFT) ? RIGHT : LEFT;
		bufsize_t minSize = (contentSize[LEFT] < contentSize[RIGHT]) ? contentSize[LEFT] : contentSize[RIGHT];
		
		if (indx >= minSize && indx < contentSize[myIndx])
			return limitColor;

		if (indx < minSize && indx < (this->startOff + this->pageSize)) {
			if (this->contentPtr[myIndx][indx] != this->contentPtr[otherIndx][indx])
				return diffColor;
		}
		return QVariant();
	}
	if (role == Qt::DisplayRole) {
		if (indx < contentSize[myIndx]) {
			if (showHex) {
#if QT_VERSION >= 0x050000
				return QString().asprintf("%02X", this->contentPtr[myIndx][indx]);
#else
				return QString().sprintf("%02X", this->contentPtr[myIndx][indx]);
#endif
			} else {
				QChar c = QChar(this->contentPtr[myIndx][indx]);
				
				if (c.isPrint() && !c.isSpace())
					return c;
				return QChar('.');
			}
		}
	}
	return QVariant();
}

```

`pe-bear/gui/HexDiffModel.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>
#include "../ViewSettings.h"

#define HEX_COL_NUM 16
#define COL_NUM (HEX_COL_NUM)
#define COL_WIDTH 20

enum ContentIndx { LEFT = 0, RIGHT = 1, CNTR = 2 };

class HexDiffModel : public QAbstractTableModel
{
	Q_OBJECT

public slots:
	void setRelativeOffset(bool flag) { relativeOffset = flag; reset(); } 
	void setContent(BYTE* contentPtr, int size, offset_t contentOffset, ContentIndx indx);
	void clearContent(ContentIndx indx);
	void setHexView(bool isSet) { showHex = isSet; reset();}
	void setStartingOffset(offset_t start) { startOff = start; reset(); }
	void setPage(const int page) { startOff = pageSize * page; reset(); }

	void onGoToPrevDiff();
	void onGoToNextDiff();

	void changeSettings(HexViewSettings &newSettings) 
	{
		settings = newSettings;
		reset();
	}
	
public:
	static int32_t getDiffStart(BYTE *content1Ptr, bufsize_t size1, BYTE *content2Ptr, bufsize_t size2);
	static int32_t getDiffEnd(BYTE *content1Ptr, bufsize_t size1, BYTE *content2Ptr, bufsize_t size2);
//------
	HexDiffModel(ContentIndx indx, QObject *parent = 0);

	bool isHexView() { return showHex; }
	bufsize_t getPageSize() { return pageSize; };
	bufsize_t getStartOff() { return startOff; }

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const;

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int) { return false; } //external modifications not allowed

	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;
	bool isRelativeOffset() const { return relativeOffset; }

protected:
	void reset()
	{
		//>
		this->beginResetModel();
		this->endResetModel();
		//<
	}

private:
	bool relativeOffset;
	offset_t contentOffset[CNTR];
	BYTE* contentPtr[CNTR];
	bufsize_t contentSize[CNTR];
	ContentIndx myIndx;

	QColor diffColor;
	QColor limitColor;
	//QColor activeColor;

	bool showHex;
	bufsize_t startOff;
	bufsize_t pageSize;
	
	HexViewSettings settings;
};

```

`pe-bear/gui/PackersTableModel.cpp`:

```cpp
#include "PackersTableModel.h"

using namespace sig_ma;

enum COLS {
	COL_OFFSET = 0,
	COL_NAME,
	COL_SECTION,
	MAX_COL
};

PackersTableModel::PackersTableModel(PeHandler *peHndl, QObject *parent)
	: PeTableModel(peHndl, parent)
{
	offsetFont.setCapitalization(QFont::AllUppercase);
}

QVariant PackersTableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	if (orientation == Qt::Horizontal) {
		switch (section) {
			case COL_OFFSET: return "Offset";
			case COL_NAME: return "Name";
			case COL_SECTION:  return "Section";
		}
	}
	return QVariant();
}

Qt::ItemFlags PackersTableModel::flags(const QModelIndex &index) const
{	
	if (!index.isValid())
		return 0;
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

int PackersTableModel::columnCount(const QModelIndex &parent) const 
{ 
	return MAX_COL; 
}

int PackersTableModel::rowCount(const QModelIndex &parent) const 
{ 
	return this->myPeHndl->packerAtOffset.size(); 
}

QVariant PackersTableModel::data(const QModelIndex &index, int role) const
{
	int row = index.row();
	int column = index.column();

	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (column == COL_OFFSET) {
		if (role == Qt::FontRole) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	int size = this->myPeHndl->packerAtOffset.size();
	if (size <= row) return QVariant();

	FoundPacker &found = this->myPeHndl->packerAtOffset[row];

	uint32_t offset = found.offset;
	PckrSign *sign = found.signaturePtr;

	SectionHdrWrapper *sec = m_PE->getSecHdrAtOffset(offset, Executable::RAW);
	switch (column) {
		case COL_OFFSET: return QString::number(offset, 16);
		case COL_NAME: return QString::fromStdString(sign->getName());
		case COL_SECTION: {
			if (sec) return sec->mappedName;
		}
	}
	return QVariant();
}

offset_t PackersTableModel::getFieldOffset(QModelIndex index) const
{
	if (!index.isValid()) return 0;
	int row = index.row();
	int size = this->myPeHndl->packerAtOffset.size();
	if (size <= row) return 0;

	FoundPacker &found = this->myPeHndl->packerAtOffset[row];
	return found.offset;
}

bufsize_t PackersTableModel::getFieldSize(QModelIndex index) const
{
	if (!index.isValid()) return 0;
	int row = index.row();
	int size = this->myPeHndl->packerAtOffset.size();
	if (size <= row) return 0;
	FoundPacker &found = this->myPeHndl->packerAtOffset[row];
	PckrSign *sign = found.signaturePtr;
	if (!sign) return 0;
	return sign->length();
}

```

`pe-bear/gui/PackersTableModel.h`:

```h
#pragma once

#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <map>
#include <set>

#include "../gui_base/FollowablePeTreeView.h"

class PackersTableModel : public PeTableModel
{
	Q_OBJECT

public:
	PackersTableModel(PeHandler *peHndl, QObject *parent = 0);
	
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;
	
	int columnCount(const QModelIndex &parent) const;
	int rowCount(const QModelIndex &parent) const;
	
	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int) { return false; } //external modifications not allowed

	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const { return createIndex(row, column); } //no index item pointer
	QModelIndex parent(const QModelIndex &index) const { return QModelIndex(); } // no parent

	offset_t getFieldOffset(QModelIndex index) const;
	bufsize_t getFieldSize(QModelIndex index) const;

protected:
	QFont offsetFont;
};

```

`pe-bear/gui/PeTreeModel.cpp`:

```cpp
#include "PeTreeModel.h"

#define COL_OFFSET 0

PeTreeItem::PeTreeItem(PeHandler *peHndl, int _fID, int _sID, PeTreeItem *parent)
	:  TreeItem(parent), PeViewItem(peHndl),
	fID(_fID), sID(_sID),
	errColor(ERR_COLOR)
{
	errColor.setAlpha(170);

	offsetFont.setCapitalization(QFont::AllUppercase);
	offsetFontColor.setRgb(100, 100, 100);
}

bool PeTreeItem::canFollow(int column, int row) const
{
	if (column == COL_OFFSET) return true;
	return false;
}

bool PeTreeItem::containsRVA(int column, int row) const
{
	if (column == COL_OFFSET) return false;
	return true;
}

QVariant PeTreeItem::toolTip(int column) const
{
	if (!m_PE) return QVariant();
	if (canFollow(column, 0)) return "Right click to follow";
	return data(column);
}

bool PeTreeItem::setData(int column, const QVariant &value, int role)
{
	if ((this->flags(column) & Qt::ItemIsEditable) == 0) {
		return false;
	}
	QVariant prevVal = this->data(column);
	if (prevVal == value) {
		return false;
	}
	const offset_t offset = this->getContentOffset();
	const offset_t size = this->getContentSize();
	if (!size){
		return false;
	}
	
	this->myPeHndl->backupModification(offset, size);
	if (setDataValue(column, value)) {
		this->myPeHndl->setBlockModified(offset, size);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

//--------------------------------------------------------------------------

size_t PeTreeModel::counter = 0;

PeTreeModel::PeTreeModel(PeHandler *peHndl, QObject *parent, bool isExpandable )
	: TreeModel(parent), PeViewItem(peHndl),
	m_isExpandable(isExpandable)
{
	PeTreeModel::counter++;
	
	offsetFont.setCapitalization(QFont::AllUppercase);
	offsetFontColor.setRgb(100, 100,100);
	errColor.setRgb(255, 0, 0);
	errColor.setAlpha(addrColors.flagsAlpha());
}

void PeTreeModel::connectSignals()
{
	if (!this->myPeHndl) {
		return;
	}
	connect(this->myPeHndl, SIGNAL(modified()), this, SLOT(onNeedReset()));
}

Executable::addr_type PeTreeModel::addrTypeAt(QModelIndex index) const
{
	if (!index.isValid() || !m_PE) return Executable::NOT_ADDR;
	if (index.column() == COL_OFFSET) return Executable::RAW;
	return Executable::NOT_ADDR;
}

QVariant PeTreeModel::addrColor(const QModelIndex &index) const
{
	Executable::addr_type aT = addrTypeAt(index);
	QColor col = addrColors.addrTypeToColor(aT);
	if (col != QColor()) return col;
	return QVariant();
}

QVariant PeTreeModel::toolTip(QModelIndex index) const
{
	if (!index.isValid()) return "";

	QString desc = "Right click to follow ";
	
	switch (addrTypeAt(index)) {
		case Executable::RAW: return desc + "[raw]";
		case Executable::RVA: return desc + "[RVA]";
		case Executable::VA: return desc + "[VA]";
	}
	return "";
}

offset_t PeTreeModel::getFieldOffset(QModelIndex index) const
{
	if (!index.isValid()) return 0;
	TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
	PeTreeItem *it = dynamic_cast<PeTreeItem*>(item);
	if (!it) {
		return 0;
	}
	return it->getContentOffset();
}

bufsize_t PeTreeModel::getFieldSize(QModelIndex index) const
{
	if (!index.isValid()) return 0;
	TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
	PeTreeItem *it = dynamic_cast<PeTreeItem*>(item);
	if (!it) {
		return 0;
	}
	return it->getContentSize();
}


```

`pe-bear/gui/PeTreeModel.h`:

```h
#pragma once

#include "TreeModel.h"
#include "../gui_base/PeGuiItem.h"

class PeTreeItem : public TreeItem, public PeViewItem
{
	Q_OBJECT

public:
	PeTreeItem(PeHandler *peHndl, int fID, int sID, PeTreeItem *parent = NULL);
	
	virtual QVariant data(int column) const = 0;

	virtual bool setData(int column, const QVariant &value, int role);
	virtual QVariant toolTip(int column) const;
	
	virtual bool canFollow(int column, int row) const;
	virtual bool containsRVA(int column, int row) const;

	virtual Qt::ItemFlags flags(int column) const
	{
		return Qt::NoItemFlags;
	}

	virtual int getFID() const { return this->fID; }
	virtual int getSID() const { return this->sID; }
	
protected:
	virtual bool setDataValue(int column, const QVariant &value)
	{
		return false;
	}

	int fID;
	int sID;

	QFont offsetFont;
	QColor offsetFontColor;
	QColor errColor;
};

//--------------------------------------------------------------------------

class PeTreeModel : public TreeModel, public PeViewItem
{
	Q_OBJECT

signals:
	void modelUpdated();

public slots:
	virtual void onNeedReset()
	{
		reset();
		emit modelUpdated();
	}

protected: 
	virtual void connectSignals();
	
	void reset()
	{
		//>
		this->beginResetModel();
		this->endResetModel();
		//<
	}

public :
	PeTreeModel(PeHandler *peHndl, QObject *parent, bool isExpandable = true);

	virtual ~PeTreeModel()
	{
		PeTreeModel::counter--;
	}

	virtual bool isExpandable() { return m_isExpandable; }
	virtual Executable::addr_type addrTypeAt(QModelIndex index) const;

	virtual QVariant addrColor(const QModelIndex &index) const;
	virtual QVariant toolTip(QModelIndex index) const;

	virtual offset_t getFieldOffset(QModelIndex index) const; // TODO: refactor it
	virtual bufsize_t getFieldSize(QModelIndex index) const; // TODO: refactor it

	QFont offsetFont;
	QColor offsetFontColor, errColor;
	
protected:
	bool m_isExpandable;
	static size_t counter;
};

//--------------------------------------------------------------------------

```

`pe-bear/gui/PeWrapperModel.cpp`:

```cpp
#include "PeWrapperModel.h"

bool PeWrapperModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fID = this->getFID(index);
	size_t sID = this->getSID(index);

	ExeElementWrapper* wrap = wrapperAt(index);
	if (!wrap) return false;

	ExeElementWrapper* mainWrapper = wrapper();
	if (!mainWrapper) return false;
	
	if (wrap != mainWrapper) { //it is subWrapper
		fID = sID;
		sID = FIELD_NONE;
	}

	QString text = value.toString();

	bool isOk = false;
	ULONGLONG number = text.toULongLong(&isOk, 16);
	if (!isOk) return false;
	
	offset_t offset = wrap->getFieldOffset(fID);
	if (offset == INVALID_ADDR) {
		return false;
	}
	bufsize_t fieldSize = wrap->getFieldSize(fID);

	this->myPeHndl->backupModification(offset, fieldSize);
	
	bool isModified = wrap->setNumValue(fID, sID, number);
	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

Qt::ItemFlags PeWrapperModel::flags(const QModelIndex &index) const
{	
	if (!index.isValid()) return Qt::NoItemFlags;
	Qt::ItemFlags f = Qt::ItemIsEnabled | Qt::ItemIsSelectable;

	if (this->containsOffset(index)) return f;
	if (this->containsValue(index)) return f | Qt::ItemIsEditable;
	return f;
}

QString PeWrapperModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (node == NULL) {
		return "-";
	}
	ExeNodeWrapper *childEntry = node->getEntryAt(upId);
	if (childEntry == NULL) {
		return "-";
	}
	QString name = childEntry->getName();
	uint32_t funcNum = childEntry->getEntriesCount();
	QString numDesc = funcNum == 1 ? " entry" : " entries";
	QString desc = name + "   [ " + QString::number(funcNum) + numDesc + " ]"; 
	return desc;
}

```

`pe-bear/gui/PeWrapperModel.h`:

```h
#pragma once

#include "PeTreeModel.h"
#include "../gui_base/WrapperInterface.h"

class PeWrapperModel : public PeTreeModel, public WrapperInterface
{
	Q_OBJECT

public slots:
	virtual void setParentId(size_t parentId)
	{
		/* only if the down table shows the details of the row from the up table */
	}

public:
	PeWrapperModel(PeHandler *peHndl, QObject *parent = 0) 
		: PeTreeModel(peHndl, parent), WrapperInterface()
	{
	}

	virtual ~PeWrapperModel()
	{
	}
	
	//---
	virtual Executable::addr_type addrTypeAt(QModelIndex index) const { return  WrapperInterface::addrTypeAt(index); }
	virtual offset_t getFieldOffset(QModelIndex index) const { return WrapperInterface::getFieldOffset(index); }
	virtual bufsize_t getFieldSize(QModelIndex index) const { return WrapperInterface::getFieldSize(index); }
	//---
	/* sets data value, do backup and notifies handler */
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual QString makeDockerTitle(uint32_t upId);
	
	virtual int getFID(const QModelIndex &index) const
	{
		if (!index.isValid()) {
			return FIELD_NONE;
		}
		PeTreeItem *item = static_cast<PeTreeItem*>(index.internalPointer());
		if (item) {
			return item->getFID();
		}
		return index.row();
	}
	
	virtual int getSID(const QModelIndex &index) const
	{
		if (!index.isValid()) {
			return FIELD_NONE;
		}
		PeTreeItem *item = static_cast<PeTreeItem*>(index.internalPointer());
		if (item) {
			return item->getSID();
		}
		return index.column();
	}
};

```

`pe-bear/gui/ResourceDirSplitter.cpp`:

```cpp
#include "ResourceDirSplitter.h"
#include <QDataStream>
#include <QtGlobal>

#include "../TempBuffer.h"

using namespace pe;

#pragma pack(push,1)
#pragma pack(2)
typedef struct icon_hdr
{
	DWORD bitmap_offset;
	DWORD img_width;
	DWORD img_height;
	WORD color_planes;
	WORD colors_in_palette;
	DWORD reserved1;
	DWORD unk1;
} t_icon_hdr;

typedef struct cursor_hdr
{
	DWORD unk;
	t_icon_hdr icons;
} t_cursor_hdr;

typedef struct bmp_hdr
{
	WORD bmp_magic;
	DWORD bmp_size;
	WORD reserved1;
	WORD reserved2;
	DWORD start_offset;
} t_bmp_hdr;
#pragma pack(pop)// revert to default

void dump_icon_hdr(t_icon_hdr &hdr)
{
	std::cout << "bitmap_offset: " << std::dec << hdr.bitmap_offset << std::endl;
	std::cout << "img_width: " << std::dec << hdr.img_width << std::endl;
	std::cout << "img_height: " << std::dec << hdr.img_height << std::endl;
	std::cout << "color_planes: " << std::dec << hdr.color_planes << std::endl;
	std::cout << "colors_in_palette: " << std::dec << hdr.colors_in_palette << std::endl;
	std::cout << "\n";
}

//----------------------------------

ResourcesDirSplitter::ResourcesDirSplitter(PeHandler *peHndl, WrapperTableModel *upModel, WrapperTableModel *downModel, QWidget *parent)
	: DataDirWrapperSplitter(peHndl, pe::DIR_RESOURCE, parent), contentTab(-1), 
	saveAction(NULL)
{
	this->init(upModel, downModel);
}

ResourcesDirSplitter::~ResourcesDirSplitter()
{
	this->dock.setParent(this); // detach from leafTab
}

void ResourcesDirSplitter::normalizeSelectedId(size_t parentRowId)
{
	if (parentRowId >= ResourceDirWrapper::FIELD_COUNTER) {
		parentRowId -= ResourceDirWrapper::FIELD_COUNTER;
	} else {
		parentRowId = 0;
	}
	emit parentIdSelected(parentRowId);
}

void ResourcesDirSplitter::childIdSelected(int childId)
{
	ResourceLeafModel* leafModel = dynamic_cast<ResourceLeafModel*> (downModel);
	if (leafModel == NULL) return;
	
	leafModel->setLeafId(childId);
}

void ResourcesDirSplitter::changeView(bool isPix)
{
	this->contentPixmap.setVisible(isPix);
	this->contentText.setVisible(!isPix);
}

void setPixMap(QPixmap &mpix, QTextEdit &contentPixmap)
{
	QImage image = mpix.toImage();
	QTextCursor cursor = contentPixmap.textCursor();
	cursor.insertImage(image);
}

bool ResourcesDirSplitter::displayBitmap(ResourceContentWrapper *resContent)
{
	QByteArray arr;
	arr.setRawData((const char*)resContent->getPtr(), resContent->getSize());
	QPixmap mpix;
	bool isOk = false;
	if (mpix.loadFromData(arr, 0, Qt::AutoColor)) {
		setPixMap(mpix, contentPixmap);
		isOk = true;
	}
	return isOk;
}

bool ResourcesDirSplitter::displayText(ResourceContentWrapper *resContent)
{
	const char *content = (const char*)(resContent->getPtr());
	const size_t contentSize = resContent->getSize();
	if (!content || !contentSize) return false;

	QByteArray arr;
	arr.setRawData(content, contentSize);
	
	QString text(arr);
	if (text.size() == 0) return false;
	
	this->contentText.setPlainText(text);
	this->leafTab.setToolTip("");
	return true;
}


bool ResourcesDirSplitter::displayIcon(ResourceContentWrapper *resContent, const pe::resource_type &restype)
{
	const char *contentPtr = (const char*)(resContent->getPtr());
	const size_t contentSize = resContent->getSize();
	char *content = (char*)contentPtr;

	TempBuffer tmp;
	size_t resOffset = 0;
	
	const size_t iconHdrSize = sizeof(t_icon_hdr);
	if (!content || contentSize <= iconHdrSize) {
		return false;
	}
	
	const t_icon_hdr *iconHdr = NULL;
	DWORD bitmapOffset = 0;
	if (restype == pe::RESTYPE_CURSOR) {
		const t_cursor_hdr *cursorHdr = (t_cursor_hdr *)content;
		iconHdr = &cursorHdr->icons;
		if (iconHdr) {
			resOffset = sizeof(DWORD);
			bitmapOffset = iconHdr->bitmap_offset + resOffset;
		}
	} else {
		iconHdr = (t_icon_hdr *)content;
		if (iconHdr) {
			bitmapOffset = iconHdr->bitmap_offset;
		}
	}
	if (!iconHdr) return false;

	if (bitmapOffset >= contentSize || resOffset >= contentSize) {
		return false;
	}

	size_t colors = iconHdr->colors_in_palette;
	switch (colors) {
		case 64:
		case 32:
		case 24:
		case 16:
		case 8:
		case 4:
		case 2:
		case 1:
			break;
		default:
			return false; // invalid color set
	}

	DWORD dimH = iconHdr->img_height;
	DWORD dimW = iconHdr->img_width;

	if (restype == pe::RESTYPE_ICON) {
		dimH = dimW;
		if (tmp.init((const BYTE*)contentPtr, contentSize)) {
			//replace pointer to the content by a temporay buffer:
			content = (char*)tmp.getContent();

			// overwrite the header in the temporary buffer:
			t_icon_hdr* iconHdr2 = (t_icon_hdr *)content;
			iconHdr2->img_height = dimH;
		}
	}

	QByteArray arr;
	bool isOk = false;
	if (colors == 32) {
		const char* bitmapPtr = (const char*)((ULONGLONG)content + bitmapOffset);
		const size_t bitmapSize = contentSize - bitmapOffset;
		
		arr.append(bitmapPtr, bitmapSize);

		QImage img = QImage((const uchar *)arr.constData(), dimW, dimH, QImage::Format_ARGB32);
		QPixmap mpix = QPixmap::fromImage(img.mirrored(false, true));
		setPixMap(mpix, contentPixmap);
		isOk = true;
	}
	else {
		const char* bitmapPtr = (const char*)((ULONGLONG)content + resOffset);
		const size_t bitmapSize = contentSize - resOffset;

		t_bmp_hdr hdr1 = { 0 };
		hdr1.bmp_magic = 0x4D42;
		hdr1.bmp_size = sizeof(t_bmp_hdr) + bitmapSize;
		hdr1.start_offset = bitmapOffset;

		arr.append((const char*)&hdr1, sizeof(t_bmp_hdr));
		arr.append(bitmapPtr, bitmapSize);

		QPixmap mpix;
		if (mpix.loadFromData(arr, 0, Qt::AutoColor)) {
			setPixMap(mpix, contentPixmap);
			isOk = true;
		}
	}
	if (!isOk) {
		return false;
	}
	QString info = "Dimensions: " + QString::number(dimW, 10) + " x " + QString::number(dimH, 10) 
		+ "\n" + "Colors: " + QString::number(colors, 10) + " bit";

	this->pixmapInfo.setText(info);
	this->pixmapInfo.setVisible(true);
	return true;
}

void ResourcesDirSplitter::clearContentDisplay()
{
	this->pixmapInfo.setVisible(false);
	this->contentPixmap.setVisible(false);
	this->contentPixmap.setText("");
	this->contentText.setVisible(false);
	this->contentText.setText("");
}

void ResourcesDirSplitter::refreshLeafContent()
{
	bool isOk = false;
	clearContentDisplay();
	
	ResourceLeafModel* leafModel = dynamic_cast<ResourceLeafModel*> (downModel);
	if (leafModel == NULL) return;

	size_t childId = leafModel->getLeafId();
	long x = leafModel->getParentId();

	ResourceEntryWrapper* eDir = dynamic_cast<ResourceEntryWrapper*> (myPeHndl->resourcesDirWrapper.getEntryAt(x));
	if (eDir == NULL) return; //should never happen!

	std::vector<ResourceLeafWrapper*> *vec = myPeHndl->resourcesAlbum.entriesAt(x);
	if (!vec || vec->size() <= childId) return;
	//----------------

	ResourceLeafWrapper* rsrc = vec->at(childId);
	if (!rsrc) return;
	
	ResourceContentWrapper *resContent = myPeHndl->resourcesAlbum.getContentWrapper(rsrc);
	if (!resContent) {
		return;
	}

	pe::resource_type dirType = resContent->getType();
	
	switch(dirType) {
		case 0:
		case RESTYPE_RCDATA:
		case RESTYPE_HTML :
		case RESTYPE_MANIFEST :
		{
			if (displayBitmap(resContent)) {
				isOk = true;
				changeView(true);
			} else {
				isOk = displayText(resContent);
				changeView(false);
			}
			break;
		}
		case RESTYPE_CURSOR:
		case RESTYPE_BITMAP:
		case RESTYPE_ICON: {
			if (displayBitmap(resContent)) {
				isOk = true;
				changeView(true);
			}
			else if (displayIcon(resContent, dirType)) {
				isOk = true;
				changeView(true);
			}
			if (isOk) {
				this->leafTab.setTabEnabled(this->contentTab, true);
				this->leafTab.setToolTip("Image Preview");
			}
			break;
		}
	}
	if (isOk) {
		this->leafTab.setTabEnabled(this->contentTab, true);
		return;
	}
	this->leafTab.setTabEnabled(this->contentTab, false);
	this->leafTab.setToolTip("Preview not implemented yet");
	this->contentText.setText("Error 501: Preview not implemented yet.");
}

void ResourcesDirSplitter::init(WrapperTableModel *upModel, WrapperTableModel *downModel)
{
	this->upModel = upModel;
	this->downModel = downModel;
	
	addWidget(&toolBar);
	initToolbar();

	if (upModel) {
		upTree.setModel(this->upModel);
		addWidget(&upTree);
		connect(&upTree, SIGNAL(parentIdSelected(size_t)), this, SLOT(normalizeSelectedId(size_t)));
		connect(this, SIGNAL(parentIdSelected(size_t)), this, SLOT(onUpIdSelected(size_t)));
		if (downModel) {
			connect(&upTree, SIGNAL(parentIdSelected(size_t)), this, SLOT(normalizeSelectedId(size_t)));
			connect(this, SIGNAL(parentIdSelected(size_t)), downModel, SLOT(setParentId(size_t)));
		}
	}
	//elementsList.setMaximumHeight(30);
	//elementsList.setMaxVisibleItems(5);
	this->addWidget(&elementsList);
	connect(&elementsList, SIGNAL(currentIndexChanged(int)), this, SLOT(childIdSelected(int)));
	connect(downModel, SIGNAL(modelUpdated()), this, SLOT(refreshLeafContent()));

	if (downModel) {
		int num = leafTab.addTab(&dock, "Table");
		this->contentTab = leafTab.addTab(&contentDock, "Content");
		dock.setFeatures(QDockWidget::NoDockWidgetFeatures);
		
		downTree.setModel(this->downModel);
		dock.setWidget(&this->downTree);
		dock.setWindowTitle("Resources");
		addWidget(&leafTab);
	}
	this->contentText.setReadOnly(true);
	this->contentPixmap.setReadOnly(true);
	this->contentDock.addWidget(&contentText);
	this->contentDock.addWidget(&contentPixmap);
	this->contentDock.addWidget(&pixmapInfo);
	refreshLeafContent();
}

void ResourcesDirSplitter::resizeComponents()
{
	const int iconDim = ViewSettings::getSmallIconDim(QApplication::font());
	QIcon saveIco = ViewSettings::makeScaledIcon(":/icons/save_black.ico", iconDim, iconDim);
	saveAction->setIcon(saveIco);

	const int MAX_HEIGHT = iconDim * 2;
	const int NUM_EDIT_HEIGHT = iconDim * 3;
	toolBar.setMaximumHeight(MAX_HEIGHT);
	elementsList.setMaximumHeight(NUM_EDIT_HEIGHT);
}

bool ResourcesDirSplitter::initToolbar()
{
	toolBar.clear();
	toolBar.setProperty("dataDir", true);
	saveAction = new QAction( QString("&Save entries"), this);
	connect(saveAction, SIGNAL(triggered()), this, SLOT(onSaveEntries()) );
	resizeComponents();
	toolBar.addAction(saveAction);
	return true;
}

void ResourcesDirSplitter::onSaveEntries()
{
	if (m_PE == NULL || myPeHndl == NULL) return;

	QString pathDir = chooseDumpOutDir();
	if (pathDir.length() == 0) return;
	
	size_t dumped = 0;
	size_t failed = 0;
	size_t invalid = 0;

	size_t dirsNum = myPeHndl->resourcesAlbum.dirsCount();

	for (int x = 0; x < dirsNum; x++) {
		std::vector<ResourceLeafWrapper*> *vec = myPeHndl->resourcesAlbum.entriesAt(x);
		if (!vec) break;
		size_t vecSize = vec->size();

		ResourceEntryWrapper* eDir = dynamic_cast<ResourceEntryWrapper*> (myPeHndl->resourcesDirWrapper.getEntryAt(x));
		if (eDir == NULL) continue; //should never happen!

		WORD dirType = eDir->getID();

		for (int y = 0; y < vecSize; y++) {
			ResourceLeafWrapper* rsrc = vec->at(y);
			if (rsrc == NULL) {
				invalid++;
				continue;
			}
			IMAGE_RESOURCE_DATA_ENTRY* entry = rsrc->leafEntryPtr();
			if (entry == NULL) {
				invalid++;
				continue;
			}
			offset_t dataRva = entry->OffsetToData;
			bufsize_t dataSize = entry->Size;
			Executable::addr_type aT = m_PE->detectAddrType(dataRva, Executable::RVA);

			offset_t dataOffset = m_PE->toRaw(dataRva, aT);
			if (dataOffset == INVALID_ADDR){
				invalid++;
				continue;
			}
#if QT_VERSION >= 0x050000
			QString fileName = QString::asprintf("_%x_%lx", x, dataRva);
#else
			QString fileName;
			fileName.sprintf("_%x_%lx", x, dataRva);
#endif
			QString path = pathDir + QDir::separator()
				+ ResourceEntryWrapper::translateType(dirType) 
				+ fileName;

			if (m_PE->dumpFragment(dataOffset, dataSize, path)) dumped++;
			else failed++;
		}
	}
	
	if (failed == 0) {
		QString infoStr = "Dumped " + QString::number(dumped) + " entries to: " + pathDir;
		if (invalid) infoStr += "\nUnable to dump entries: " + QString::number(invalid);
		QMessageBox::information(this,"Dumped", infoStr);
	} else {
		QMessageBox::warning(this, "Failed", "Failed to dump!");
	}
}

void ResourcesDirSplitter::onUpIdSelected(size_t upId)
{
	elementsList.clear();
	WrapperInterface *upInterface = dynamic_cast<WrapperInterface*>(upModel);
	if (upInterface == NULL) {
		return;
	}
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(upInterface->wrapper());
	if (node == NULL) {
		return;
	}
	ExeNodeWrapper *childEntry = node->getEntryAt(upId);
	if (childEntry == NULL) {
		this->dock.setWindowTitle("-");
		return;
	}

	QString desc = childEntry->getName(); 
	this->dock.setWindowTitle(desc);

	size_t num = myPeHndl->resourcesAlbum.entriesCountAt(upId);
	fillList(num);
}

void ResourcesDirSplitter::fillList(size_t num)
{
	elementsList.clear();
	for (size_t i = 0; i < num; i++) {
		elementsList.addItem("Entry number: " + QString::number(i));
	}
}

```

`pe-bear/gui/ResourceDirSplitter.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui/pe_models.h"
#include "WrapperTreeView.h"
#include "DataDirWrapperSplitter.h"

//-----------------------------

class ResourcesDirSplitter : public DataDirWrapperSplitter
{
	Q_OBJECT

protected slots:
	void normalizeSelectedId(size_t parentRowId);
	void onUpIdSelected(size_t);
	void childIdSelected(int childId);
	void refreshLeafContent();
	
signals:
	void parentIdSelected(size_t parentId);
	
public:
	ResourcesDirSplitter(PeHandler *peHndl, WrapperTableModel *upModel, WrapperTableModel *downModel, QWidget *parent);
	virtual ~ResourcesDirSplitter();

	virtual bool initToolbar();
	virtual void resizeComponents();

public slots:
	void onSaveEntries();

protected:
	void changeView(bool isPix);
	void clearContentDisplay();
	bool displayText(ResourceContentWrapper *resContent);
	bool displayBitmap(ResourceContentWrapper *resContent);
	bool displayIcon(ResourceContentWrapper *resContent, const pe::resource_type &type);
	virtual void init(WrapperTableModel *upModel, WrapperTableModel *downModel);
	void fillList(size_t num);

	QAction* saveAction;
	QComboBox elementsList;
	QTabWidget leafTab;

	QSplitter contentDock;
	QTextEdit contentText;
	QTextEdit contentPixmap;
	QLabel pixmapInfo;
	int contentTab;
};


```

`pe-bear/gui/TreeModel.cpp`:

```cpp
#include "TreeModel.h"
#include <iostream>

//class appendChild;
TreeItem::TreeItem(const QList<QVariant> &data, TreeItem *parent)
	: m_itemData(data), m_parentItem(parent), QObject(parent)
{
}

TreeItem::TreeItem(TreeItem *parent)
	: QObject(parent),
	m_parentItem(parent)
{
}

TreeItem::~TreeItem()
{
	qDeleteAll(m_childItems);
}

void TreeItem::appendChild(TreeItem *item)
{
	if (!item) {
		return;
	}
	if (item->parentItem()) {
		item->parentItem()->detachChild(item);
	}

	// connect the child to the parent:
	item->m_parentItem = this;
	item->setParent(this);

	// add the item to the children:
	this->m_childItems.append(item);
}

void TreeItem::detachChild(TreeItem *child)
{
	if (!child) {
		return;
	}
	int index = this->m_childItems.indexOf(child, 0);
	if (index == -1) {
		/* not attached */
		return;
	}

	// remove the item from children
	this->m_childItems.removeAt(index);

	// detach the child from the parent
	child->m_parentItem = NULL;
	child->setParent(NULL);
}

void TreeItem::removeAllChildren()
{
	QList<TreeItem*>::iterator chIter;
	for (chIter = m_childItems.begin(); chIter != m_childItems.end(); ++chIter) {
		TreeItem* child = *chIter;
		this->detachChild(child);
		delete child;
	}
}

TreeItem *TreeItem::child(int row)
{
	if (row < 0 || row >= m_childItems.size())
		return nullptr;
	return m_childItems.at(row);
}

int TreeItem::childCount() const
{
	return m_childItems.count();
}

int TreeItem::row() const
{
	if (m_parentItem)
		return m_parentItem->m_childItems.indexOf(const_cast<TreeItem*>(this));

	return 0;
}

int TreeItem::columnCount() const
{
	return m_itemData.count();
}

QVariant TreeItem::data(int column) const
{
	if (column < 0 || column >= m_itemData.size()) {
		return QVariant();
	}
	return "demo";
}

TreeItem *TreeItem::parentItem()
{
	return m_parentItem;
}

//----

TreeModel::TreeModel(QObject *parent)
	: QAbstractItemModel(parent), rootItem(nullptr)
{
}

TreeModel::~TreeModel()
{
	delete rootItem;
}

QModelIndex TreeModel::index(int row, int column, const QModelIndex &parent) const
{
	if (!rootItem || !hasIndex(row, column, parent)) {
		return QModelIndex();
	}
	TreeItem *parentItem = nullptr;

	if (!parent.isValid()) {
		parentItem = rootItem;
	}
	else {
		parentItem = static_cast<TreeItem*>(parent.internalPointer());
	}
	TreeItem *childItem = parentItem->child(row);
	if (childItem) {
		return createIndex(row, column, childItem);
	}
	return QModelIndex();
}

QModelIndex TreeModel::parent(const QModelIndex &index) const
{
	if (!rootItem || !index.isValid()) {
		return QModelIndex();
	}

	TreeItem *childItem = static_cast<TreeItem*>(index.internalPointer());
	TreeItem *parentItem = childItem->parentItem();

	if (parentItem == rootItem) {
		return QModelIndex();
	}
	return createIndex(parentItem->row(), 0, parentItem);
}

int TreeModel::rowCount(const QModelIndex &parent) const
{
	if (parent.column() > 0) {
		return 0;
	}
	TreeItem *parentItem;
	if (!parent.isValid()) {
		parentItem = rootItem;
	}
	else {
		parentItem = static_cast<TreeItem*>(parent.internalPointer());
	}
	if (!parentItem) {
		return 0;
	}
	const int childCount = parentItem->childCount();
	return childCount;
}

int TreeModel::columnCount(const QModelIndex &parent) const
{
	TreeItem *parentItem = nullptr;
	if (parent.isValid()) {
		parentItem = static_cast<TreeItem*>(parent.internalPointer());
	}
	else {
		parentItem = rootItem;
	}
	if (!parentItem) {
		return 0;
	}
	const int colCount = parentItem->columnCount();
	return colCount;
}

QVariant TreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) {
		return QVariant();
	}
	if (role != Qt::DisplayRole) {
		QVariant();
	}
	TreeItem *item = static_cast<TreeItem*>(index.internalPointer());
	if (!item) {
		return QVariant();
	}
	return item->data(index.column());
}

Qt::ItemFlags TreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}
	return QAbstractItemModel::flags(index);
}


QVariant TreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (!rootItem) {
		return QVariant();
	}
	if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
		return rootItem->data(section);
	}
	return QVariant();
}

```

`pe-bear/gui/TreeModel.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

//---

class TreeItem : public QObject
{
	Q_OBJECT
public:
	explicit TreeItem(TreeItem *parentItem = nullptr);
	explicit TreeItem(const QList<QVariant> &data, TreeItem *parentItem = nullptr);
	virtual ~TreeItem();

	TreeItem *child(int row);
	virtual int childCount() const;
	virtual int columnCount() const;
	virtual QVariant data(int column) const;
	virtual int row() const;
	TreeItem *parentItem();

	virtual void appendChild(TreeItem *child);
	virtual void detachChild(TreeItem *child);
	virtual void removeAllChildren();

protected:
	QList<TreeItem*> m_childItems;
	QList<QVariant> m_itemData;
	TreeItem *m_parentItem;
};

//---

class TreeModel : public QAbstractItemModel
{
	Q_OBJECT

public:
	explicit TreeModel(QObject *parent = nullptr);
	~TreeModel();

	virtual QVariant data(const QModelIndex &index, int role) const override;
	
	virtual Qt::ItemFlags flags(const QModelIndex &index) const override;

	virtual QVariant headerData(int section, Qt::Orientation orientation,
		int role = Qt::DisplayRole) const override;

	virtual QModelIndex index(int row, int column,
		const QModelIndex &parent = QModelIndex()) const override;

	virtual QModelIndex parent(const QModelIndex &index) const override;

	virtual int rowCount(const QModelIndex &parent = QModelIndex()) const override;

	virtual int columnCount(const QModelIndex &parent = QModelIndex()) const override;

protected:

	TreeItem *rootItem;
};

```

`pe-bear/gui/WrapperSplitter.cpp`:

```cpp
#include "WrapperSplitter.h"

//---------------------------------------------------------------------------

WrapperSplitter::WrapperSplitter(QWidget *parent)
	: QSplitter(Qt::Vertical, parent), 
	upModel(NULL), downModel(NULL),
	upTree(NULL), downTree(NULL),
	dock(NULL),
	toolBar(this), title(""),
	recordId(0)
{
	//empty
}

WrapperSplitter::WrapperSplitter(PeTreeModel *upModel, PeTreeModel *downModel, QWidget *parent)
	: QSplitter(Qt::Vertical, parent), 
	upModel(NULL), downModel(NULL),
	upTree(NULL), downTree(NULL),
	dock(NULL),
	toolBar(this), title(""),
	recordId(0)
{ 
	init(upModel, downModel); 
}

void WrapperSplitter::init(PeTreeModel *upModel, PeTreeModel *downModel)
{
	this->upModel = upModel;
	this->downModel = downModel;

	toolBar.setMaximumHeight(20);
	addWidget(&toolBar);
	initToolbar();
	
	if (upModel) {
		upTree.setModel(this->upModel);
		this->upModel->setParent(&this->upTree);
		this->upTree.expandAll();
		addWidget(&upTree);
		connect(&upTree, SIGNAL(parentIdSelected(size_t)), this, SLOT(setParentIdInDocker(size_t)));
	}

	if (downModel) {
		connect(&upTree, SIGNAL(parentIdSelected(size_t)), downModel, SLOT(setParentId(size_t)));
		connect(downModel, SIGNAL(modelUpdated()), this, SLOT(reloadDocketTitle()));
		
		downTree.setModel(this->downModel);
		this->downModel->setParent(&downTree);
		downTree.expandAll();
		this->dock.setFeatures(0);
		dock.setWidget(&this->downTree);
		reloadDocketTitle();
		addWidget(&dock);
	}
}

void WrapperSplitter::reloadDocketTitle()
{
	if (!upModel) {
		dock.setWindowTitle("");
		return;
	}
	WrapperInterface *wrapperI = dynamic_cast<WrapperInterface*>(upModel);
	if (wrapperI == NULL) {
		return;
	}
	QString desc = wrapperI->makeDockerTitle(this->recordId);
	this->dock.setWindowTitle(desc);
}

void WrapperSplitter::setParentIdInDocker(size_t upId)
{
	this->recordId = upId;
	reloadDocketTitle();
}

```

`pe-bear/gui/WrapperSplitter.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui/pe_models.h"
#include "WrapperTreeView.h"

class WrapperSplitter : public QSplitter
{
	Q_OBJECT

public slots:
	virtual void setParentIdInDocker(size_t);
	virtual void reloadDocketTitle();
	
public:
	WrapperSplitter(QWidget *parent);
	WrapperSplitter(PeTreeModel *upModel, PeTreeModel *downModel, QWidget *parent);

	virtual ~WrapperSplitter()
	{
		delete upModel;
		delete downModel;
	}

	virtual bool initToolbar() { return false; }
	
	QModelIndexList getUpperViewSelected()
	{
		return upTree.selectionModel()->selectedIndexes();
	}

	QToolBar toolBar;
	QDockWidget dock;
	QString title;

protected:
	virtual void init(PeTreeModel *upModel, PeTreeModel *downModel);
	
	PeTreeModel *upModel, *downModel;
	WrapperTreeView upTree;
	FollowablePeTreeView downTree;
	
	size_t recordId;
};

```

`pe-bear/gui/WrapperTreeView.cpp`:

```cpp
#include "WrapperTreeView.h"

//---------------------------------------------------------------------------
void  WrapperTreeView::selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel)
{
	FollowablePeTreeView::selectionChanged(newSel, prevSel);

	WrapperInterface *topModel = dynamic_cast<WrapperInterface*> (this->model());
	if (!topModel) return;

	ExeElementWrapper *mainWrapper = topModel->wrapper();
	if (mainWrapper == NULL) return;
	if (newSel.indexes().size() == 0) return;

	QModelIndex index = newSel.indexes().at(0);
	size_t parentId = (index.isValid()) ? index.row() : 0;
	emit parentIdSelected(parentId);
}

```

`pe-bear/gui/WrapperTreeView.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../gui_base/FollowablePeTreeView.h"
#include "../gui_base/WrapperTableModel.h"

class WrapperTreeView : public FollowablePeTreeView
{
	Q_OBJECT
signals:
	void parentIdSelected(size_t parentId);
public:
	WrapperTreeView(QWidget *parent) : FollowablePeTreeView(parent) {}
	void selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel);
};

```

`pe-bear/gui/pe_models.h`:

```h
#pragma once

#include "pe_models/BoundImpTreeModel.h"
#include "pe_models/DebugTreeModel.h"
#include "pe_models/DelayImpTreeModel.h"
#include "pe_models/ExceptionTreeModel.h"
#include "pe_models/ExportsTreeModel.h"
#include "pe_models/FileHdrTreeModel.h"
#include "pe_models/ImportsTreeModel.h"
#include "pe_models/LdConfigTreeModel.h"
#include "pe_models/OptionalHdrTreeModel.h"
#include "pe_models/RelocsTreeModel.h"
#include "pe_models/ResourcesTreeModel.h"
#include "pe_models/SecHdrsTreeModel.h"
#include "pe_models/SecurityTreeModel.h"
#include "pe_models/TLSTreeModel.h"
#include "pe_models/RichHdrTreeModel.h"
#include "pe_models/ClrHdrTreeModel.h"

```

`pe-bear/gui/pe_models/BoundImpTreeModel.cpp`:

```cpp
#include "BoundImpTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

int BoundImpTreeModel::columnCount(const QModelIndex &parent) const
{
	ExeNodeWrapper* impWrap = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (!impWrap) return 0;
	ExeNodeWrapper* entry = impWrap->getEntryAt(0);
	if (!entry) return 0;
	uint32_t cntr = entry->getFieldsCount() + ADDED_COLS_NUM;
	return cntr;
}


QVariant BoundImpTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
	}
	ExeNodeWrapper* impWrap = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int32_t fID = this->columnToFID(section);
	return impWrap->getSubfieldName(0, fID);
}

QVariant BoundImpTreeModel::data(const QModelIndex &index, int role) const
{
	BoundEntryWrapper* wrap = dynamic_cast<BoundEntryWrapper*>(wrapperAt(index));
	if (!wrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	int fId = getFID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getName();
	}
	return dataValue(index);
}

bool BoundImpTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fId = index.row();
	uint32_t sID = this->columnToFID(index.column());

	if (!wrapper()) return false;
	DelayImpEntryWrapper* entry =  dynamic_cast<DelayImpEntryWrapper*>(wrapperAt(index));
	//ExeElementWrapper *entry = wrapperAt(index);
	if (!entry) return false;

	QString text = value.toString();

	bool isModified = false;
	uint32_t offset = 0;
	uint32_t fieldSize = 0;

	if (index.column() == NAME) {
		char* textPtr = entry->getLibraryName();
		if (!textPtr) return false;

		offset = entry->getOffset(textPtr);
		fieldSize = text.size() + 2;

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);

	} else {
		
		bool isOk = false;
		ULONGLONG number = text.toLongLong(&isOk, 16);
		if (!isOk) return false;

		offset = entry->getFieldOffset(sID);
		fieldSize = entry->getFieldSize(sID);

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = entry->setNumValue(sID, index.column(), number);
	}

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}
//----------------------------------------------------------------------------

```

`pe-bear/gui/pe_models/BoundImpTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class BoundImpTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	BoundImpTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent)
	{
		connectSignals();
	}
	
	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	virtual bool containsValue(QModelIndex index) const { return (index.column() >= NAME); }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM;  }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	inline int32_t columnToFID(int column) const { return column - ADDED_COLS_NUM; }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->boundImpDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const { return myPeHndl->boundImpDirWrapper.getEntryAt(index.row()); }

	enum cols {
		OFFSET,
		NAME,
		ADDED_COLS_NUM
	};
};

```

`pe-bear/gui/pe_models/ClrHdrTreeModel.cpp`:

```cpp
#include "ClrHdrTreeModel.h"

enum COLS {
	COL_OFFSET = 0,
	COL_NAME,
	COL_VALUE,
	COL_MEANING,
	MAX_COL
};

ClrHdrTreeItem::ClrHdrTreeItem(PeHandler *peHndl, level_t level, ClrDirWrapper::FieldID role, ClrHdrTreeItem *parent)
	: PeTreeItem(peHndl, role, FIELD_NONE, parent), 
	clrDir(peHndl->clrDirWrapper)
{
	parentItem = parent;
	this->level = level;
	this->role = role;
	if (this->m_PE == NULL) {
		this->level = DESC;
		this->role = ClrDirWrapper::NONE;
		return;
	}
}

int ClrHdrTreeItem::columnCount() const
{
	return MAX_COL;
}

QVariant ClrHdrTreeItem::background(int column) const
{
	if (m_PE == NULL) return QVariant();
	if (level == DETAILS && column >= COL_VALUE && column < MAX_COL) {
		QColor flagsColorT = addrColors.flagsColor();
		flagsColorT.setAlpha(addrColors.flagsAlpha());
		return flagsColorT;
	}
	return QVariant();
}

QVariant ClrHdrTreeItem::foreground(int column) const
{
	if (column == COL_OFFSET) return this->offsetFontColor;
	return QVariant();
}

Qt::ItemFlags ClrHdrTreeItem::flags(int column) const
{
	Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (column != COL_VALUE || level == DETAILS) return fl;
	return fl| Qt::ItemIsEditable;
}

QVariant ClrHdrTreeItem::data(int column) const
{
	if (m_PE == NULL) return QVariant();

	if (this->level != DESC) return QVariant();
	switch (column) {
		case COL_OFFSET: return QString::number(getContentOffset(),16).toUpper();
		case COL_NAME: return clrDir.getFieldName(role);
		case COL_VALUE:
		{
			bool isOk = false;
			uint64_t val = clrDir.getNumValue(role, &isOk);
			if (!isOk) return QVariant();
			return QString::number(val, 16).toUpper();
		}
	}
	return QVariant();
}

bool ClrHdrTreeItem::setDataValue(int column, const QVariant &value)
{
	if (column != COL_VALUE) return false;

	QString text = value.toString();
	bool isOk = false;
	ULONGLONG number = text.toLongLong(&isOk, 16);
	if (!isOk) return false;

	isOk = clrDir.setNumValue(role, number);
	return isOk;
}

offset_t ClrHdrTreeItem::getContentOffset() const
{
	if (!m_PE) return 0;
	return clrDir.getFieldOffset(role);
}

bufsize_t ClrHdrTreeItem::getContentSize() const
{
	if (!m_PE) return 0;
	return clrDir.getFieldSize(role);
}

//-------------------

ClrFlagsTreeItem::ClrFlagsTreeItem(PeHandler* peHndl, level_t level, DWORD _flags, ClrHdrTreeItem *parent)
    : ClrHdrTreeItem(peHndl, level, role = ClrDirWrapper::FLAGS, parent),
	flags(_flags)
{
	loadChildren();
}

DWORD ClrFlagsTreeItem::getAllFlags() const
{
	bool isOk = false;
	DWORD allFlags = this->clrDir.getNumValue(role, &isOk);
	if (!isOk) return 0;
	return allFlags;
}

void ClrFlagsTreeItem::loadChildren()
{
	if (this->level != DESC) {
		return;
	}
	removeAllChildren();
	//create subrecords
	DWORD allFlags = getAllFlags();
	std::set<DWORD> flagsSet = ClrDirWrapper::getFlagsSet(allFlags);
	std::set<DWORD>::iterator chIter;
	for (chIter = flagsSet.begin(); chIter != flagsSet.end(); ++chIter) {
		DWORD splitedFlag = *chIter;
		this->appendChild(new ClrFlagsTreeItem(myPeHndl, DETAILS, splitedFlag, this));
	}
}

QVariant ClrFlagsTreeItem::data(int column) const
{
	if (m_PE == NULL) return QVariant();

	if (this->level == DESC) {
		DWORD flags = getAllFlags();
		switch (column) {
			case COL_OFFSET : return QString::number(getContentOffset(),16).toUpper();
			case COL_NAME: return ("Flags");
			case COL_VALUE: return QString::number(flags, 16).toUpper();
		}
		return QVariant();
	}
	//---
	switch (column) {
		case COL_VALUE: return QString::number(this->flags, 16).toUpper();
		case COL_MEANING: return ClrDirWrapper::translateFlag(this->flags);
	}
	return QVariant();
}
//-------------------

ClrTreeModel::ClrTreeModel(PeHandler *peHndl, QObject *parent) 
	: PeWrapperModel(peHndl, parent), flagsItem(nullptr)
{
	if (!m_PE) return;

	rootItem = new ClrHdrTreeItem(peHndl);
	const size_t fieldNum = ClrDirWrapper::FIELD_COUNTER;

	for (size_t i = 0; i < fieldNum; ++i) {
		const ClrDirWrapper::FieldID role = ClrDirWrapper::FieldID(i);

		if (role == ClrDirWrapper::FLAGS) {
			flagsItem = new ClrFlagsTreeItem(peHndl, ClrHdrTreeItem::DESC);
			rootItem->appendChild(flagsItem);
		} else {
			rootItem->appendChild(new ClrHdrTreeItem(myPeHndl, ClrHdrTreeItem::DESC, role));
		}
	}
	connect(peHndl, SIGNAL(modified()), this, SLOT(reload()));
}

void ClrTreeModel::reload()
{
	flagsItem->loadChildren();
	reset();
	emit modelUpdated();
}

int ClrTreeModel::columnCount(const QModelIndex &parent) const { return MAX_COL; }

bool ClrTreeModel::containsValue(QModelIndex index) const
{
	return (index.column()  == COL_VALUE);
}

QVariant ClrTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) return QVariant();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::ToolTipRole) return this->toolTip(index);

	ClrHdrTreeItem *item = static_cast<ClrHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return QVariant();

	if (role == Qt::BackgroundColorRole)
		return item->background(index.column());

	if (role == Qt::SizeHintRole) {
		return QVariant(); //get default
	}

	if (role == Qt::DisplayRole || role == Qt::EditRole) {
		return item->data(index.column());
	}
	return QVariant();
}

bool ClrTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid())
		return false;

	ClrHdrTreeItem *item = static_cast<ClrHdrTreeItem*>(index.internalPointer());
	if (!item) return false;

	return item->setData(index.column(), value, item->role);
}

QVariant ClrTreeModel::headerData(int section, Qt::Orientation /* orientation */, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case COL_OFFSET : return "Offset";
		case COL_NAME : return "Name";
		case COL_VALUE : return "Value";
		case COL_MEANING : return "Meaning";
	}
	return QVariant();
}

Qt::ItemFlags ClrTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;

	ClrHdrTreeItem *item = static_cast<ClrHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return 0;
	return item->flags(index.column());
}

QString ClrTreeModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (node == NULL) {
		return "";
	}
	ExeNodeWrapper *childEntry = node->getEntryAt(0);
	if (childEntry == NULL) {
		return "";
	}
	return childEntry->getName();
}

```

`pe-bear/gui/pe_models/ClrHdrTreeModel.h`:

```h
#pragma once
#include <QtGui>

#include <map>
#include <set>
#include "../../gui_base/PeTreeView.h"
#include "../../gui_base/WrapperTableModel.h"
#include "../../gui/PeTreeModel.h"
#include "../PeWrapperModel.h"


class ClrHdrTreeItem : public PeTreeItem
{
	Q_OBJECT

protected:
	enum ViewLevel { DESC = 0, DETAILS = 1 };
	typedef enum ViewLevel level_t;

	QList<ClrHdrTreeItem*> childItems;
	ClrHdrTreeItem *parentItem;
	level_t level;
	ClrDirWrapper::FieldID role;
	ClrDirWrapper &clrDir;

public:
	ClrHdrTreeItem(
		PeHandler *peHndl, 
		level_t level = DESC,
		ClrDirWrapper::FieldID role = ClrDirWrapper::NONE, 
		ClrHdrTreeItem *parent = NULL
	);

	int columnCount() const;

	virtual Qt::ItemFlags flags(int column) const;
	virtual QVariant data(int column) const;

	bool setDataValue(int column, const QVariant &value);
	virtual QVariant foreground(int column) const;
	virtual QVariant background(int column) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual bool isChildOk(TreeItem* child)
	{
		const ClrHdrTreeItem *ptr = dynamic_cast<ClrHdrTreeItem*>(child);
		return (ptr)? true : false;
	}

friend class ClrTreeModel;
};

//-------------------

class ClrFlagsTreeItem : public ClrHdrTreeItem
{
	Q_OBJECT

public:
	ClrFlagsTreeItem(PeHandler *peHndl, level_t level = DESC, DWORD flags = 0, ClrHdrTreeItem *parent = NULL);
	virtual QVariant data(int column) const;
	void loadChildren();

protected:

	DWORD getAllFlags() const;
	DWORD flags;
};

//-------------------

class ClrTreeModel : public PeWrapperModel
{
	Q_OBJECT

protected slots:
	void reload();

public:
	ClrTreeModel(PeHandler *peHndl, QObject *parent = 0);

	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual bool containsValue(QModelIndex index) const;
	QString makeDockerTitle(uint32_t upId);

protected:
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->clrDirWrapper; }

	ClrFlagsTreeItem* flagsItem;
};

```

`pe-bear/gui/pe_models/DebugTreeModel.cpp`:

```cpp
#include "DebugTreeModel.h"
#include "../../DateDisplay.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

QVariant DebugTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
		case VALUE2: return "Meaning";
	}
	return QVariant();
}

QVariant DebugTreeModel::data(const QModelIndex &index, int role) const
{
	DebugDirWrapper* wrap = dynamic_cast<DebugDirWrapper*>(wrapper());
	if (!wrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	int fId = getFID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getFieldName(fId);
		case VALUE2: 
		{
			bool isOk = false;
			int val = wrap->getNumValue(fId, &isOk);
			if (fId == DebugDirWrapper::TIMESTAMP) {
				if (!isOk) return "";
				return getDateString(val);
			}
			if (fId == DebugDirWrapper::TYPE) {
				if (!isOk) return "";
				return wrap->translateType(val);
			}
			return "";
		}
	}
	return dataValue(index);
}

QString DebugTreeModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (node == NULL) {
		return "";
	}
	ExeNodeWrapper *childEntry = node->getEntryAt(0);
	if (childEntry == NULL) {
		return "";
	}
	return childEntry->getName();
}

//-----------------------------------------------------------------------------------

int DebugRDSIEntryTreeModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	return wrapper()->getFieldsCount();
}

ExeElementWrapper* DebugRDSIEntryTreeModel::wrapper() const
{
	if (!myPeHndl) return NULL;
	
	ExeNodeWrapper* subWr = myPeHndl->debugDirWrapper.getEntryAt(0);
	return subWr;
}

ExeElementWrapper* DebugRDSIEntryTreeModel::wrapperAt(QModelIndex index) const
{
	return wrapper();
}

QVariant DebugRDSIEntryTreeModel::data(const QModelIndex &index, int role) const
{
	ExeElementWrapper *w = wrapperAt(index);
	DebugDirCVEntryWrapper* wrap = dynamic_cast<DebugDirCVEntryWrapper*>(w);
	if (!wrap) return QVariant();
	
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::ToolTipRole) return toolTip(index);

	int row = index.row();
	int column = index.column();
	int fId = this->getFID(index);
	
	if (role == Qt::FontRole && column == OFFSET) {
		return offsetFont;
	}
	if (role != Qt::DisplayRole && role != Qt::EditRole) {
		return QVariant();
	}
	switch (column) {
		case OFFSET: 
			return QString::number(getFieldOffset(index), 16);
		case NAME: {
			const QString name = wrap->getFieldName(fId);
			return name;
		}
		case VALUE: {
			if (fId == DebugDirCVEntryWrapper::F_CVDBG_GUID) {
				return wrap->getGuidString();
			}
			else if (fId == DebugDirCVEntryWrapper::F_CVDBG_SIGN){
				return wrap->getSignature();
			}
			else if (fId == DebugDirCVEntryWrapper::F_CVDBG_PDB) {
				//TODO: make some decent parsing here
				char *str_ptr = (char*)w->getFieldPtr(fId);
				if (!str_ptr) return QVariant();
				return QString(str_ptr);
			}
			bool isOk = false;
			uint64_t val = w->getNumValue(fId, &isOk);
			if (isOk) {
				return QString::number(val, 16);
			}
		}
	}
	return QVariant();
}

bool DebugRDSIEntryTreeModel::setTextData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	ExeElementWrapper *w = wrapperAt(index);
	if (!w) return false;
	
	size_t fId = this->getFID(index);
	
	size_t fieldSize = w->getFieldSize(fId);
	offset_t offset = w->getFieldOffset(fId);
	QString text = value.toString();
	
	char* textPtr = (char*) w->getFieldPtr(fId);
	if (!textPtr) return false;
	
	this->myPeHndl->backupModification(offset, fieldSize);
	bool isModified =  m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);
	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

bool DebugRDSIEntryTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	ExeElementWrapper *w = wrapperAt(index);
	DebugDirCVEntryWrapper* wrap = dynamic_cast<DebugDirCVEntryWrapper*>(w);
	if (!wrap) return false;
	
	int row = index.row();
	int column = index.column();
	int fId = this->getFID(index);
	
	if (fId == DebugDirCVEntryWrapper::F_CVDBG_GUID) {
		return false;
	}
	if (fId == DebugDirCVEntryWrapper::F_CVDBG_PDB) {
		return setTextData(index, value, role);
	}
	return WrapperTableModel::setData(index, value, role);
}

QVariant DebugRDSIEntryTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE: return "Value";
	}
	return QVariant();
}

Qt::ItemFlags DebugRDSIEntryTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid()) return Qt::NoItemFlags;

	int fId = this->getFID(index);
	if (fId == DebugDirCVEntryWrapper::F_CVDBG_GUID) {
		return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	}
	return WrapperTableModel::flags(index);
}

```

`pe-bear/gui/pe_models/DebugTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class DebugTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	DebugTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent) {}
	
	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE); }
	QString makeDockerTitle(uint32_t upId);
	
protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->debugDirWrapper; }

	enum cols {
		OFFSET,
		NAME,
		VALUE,
		VALUE2,
		COLS_NUM
	};
};

//-------------------------------------------------------------------------------------------

class DebugRDSIEntryTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	DebugRDSIEntryTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent) { }

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &index, const QVariant &value, int role);
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;
	
	virtual bool containsValue(QModelIndex index) const { return index.column() == VALUE; }

	virtual ExeElementWrapper* wrapper() const;
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

protected:
	bool setTextData(const QModelIndex &index, const QVariant &value, int role);
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column();  }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET = 0,
		NAME,
		VALUE,
		MAX_COL
	};
};

```

`pe-bear/gui/pe_models/DelayImpTreeModel.cpp`:

```cpp
#include "DelayImpTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

int DelayImpTreeModel::columnCount(const QModelIndex &parent) const
{
	ExeNodeWrapper* impWrap = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (!impWrap) return 0;
	ExeNodeWrapper* entry = impWrap->getEntryAt(0);
	if (!entry) return 0;
	uint32_t cntr = entry->getFieldsCount() + ADDED_COLS_NUM;
	return cntr;
}


QVariant DelayImpTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
	}
	ExeNodeWrapper* impWrap = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int32_t fID = this->columnToFID(section);
	return impWrap->getSubfieldName(0, fID);
}

QVariant DelayImpTreeModel::data(const QModelIndex &index, int role) const
{
	DelayImpEntryWrapper* wrap = dynamic_cast<DelayImpEntryWrapper*>(wrapperAt(index));
	if (!wrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	int fId = getFID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getName();
	}
	return dataValue(index);
}

bool DelayImpTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	uint32_t sID = this->columnToFID(index.column());

	if (!wrapper()) return false;
	DelayImpEntryWrapper* entry =  dynamic_cast<DelayImpEntryWrapper*>(wrapperAt(index));
	if (!entry) return false;

	QString text = value.toString();

	bool isModified = false;
	uint32_t offset = 0;
	uint32_t fieldSize = 0;

	if (index.column() == NAME) {
		char* textPtr = entry->getLibraryName();
		if (!textPtr) return false;

		offset = entry->getOffset(textPtr);
		fieldSize = text.size() + 2;

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);

	} else {
		
		bool isOk = false;
		ULONGLONG number = text.toLongLong(&isOk, 16);
		if (!isOk) return false;

		offset = entry->getFieldOffset(sID);
		fieldSize = entry->getFieldSize(sID);

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = entry->setNumValue(sID, index.column(), number);
	}

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

//----------------------------------------------------------------------------

DelayImpFuncModel::DelayImpFuncModel(PeHandler *peHndl, QObject *parent)
	:  WrapperTableModel(peHndl, parent), 
	libraryId(0)
{
	connect(peHndl, SIGNAL(modified()), this, SLOT(onNeedReset()));
}

ExeNodeWrapper* DelayImpFuncModel::wrapper() const
{
	if (!myPeHndl) return NULL;
	DelayImpDirWrapper& impWrap = myPeHndl->delayImpDirWrapper;
	ExeNodeWrapper *entryWrapp = impWrap.getEntryAt(this->libraryId);
	return entryWrapp;
}

ExeElementWrapper* DelayImpFuncModel::wrapperAt(QModelIndex index) const
{
	ExeNodeWrapper* wrapper = this->wrapper();
	if (!wrapper) return NULL;
	int sId = this->getSID(index);
	return wrapper->getEntryAt(sId);
}

int DelayImpFuncModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	uint32_t cntr = wrapper()->getEntriesCount();
	return cntr;
}

int DelayImpFuncModel::columnCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	uint32_t cntr = DelayImpFuncWrapper::FIELD_COUNTER + ADDED_COLS_NUM;
	return cntr;
}

QVariant DelayImpFuncModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	if (!wrapper()) return QVariant();
	size_t fId = columnToFID(section);
	ExeNodeWrapper* entry = wrapper()->getEntryAt(0);

	if (entry == NULL) return "";

	switch (section) {
		case OFFSET: return "Call via";
		case NAME: return "Name";
		case ORDINAL : return "Ordinal";
		case HINT: return "Hint";
	}
	return entry->getFieldName(fId);
}

Executable::addr_type DelayImpFuncModel::offsetAddrType() const
{
	DelayImpFuncWrapper* entry = dynamic_cast<DelayImpFuncWrapper*>(wrapperAt(QAbstractItemModel::createIndex(0,0)));
	if (!entry || !myPeHndl || !myPeHndl->getPe()) {
		return Executable::RVA;
	}
	return myPeHndl->getPe()->detectAddrType(entry->callVia(), Executable::RVA);
}

QVariant DelayImpFuncModel::data(const QModelIndex &index, int role) const
{
	if (!wrapper()) return QVariant();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	int row = index.row();
	int column = index.column();

	if (column != NAME && role == Qt::FontRole) return offsetFont;

	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	DelayImpFuncWrapper* entry =  dynamic_cast<DelayImpFuncWrapper*>(wrapperAt(index));
	if (!entry) return QVariant();
	
	switch (column) {
		case OFFSET:
			return QString::number(entry->callVia(), 16);
		case NAME:
		{
			char *name = entry->getFunctionName();
			if (!name) return NOT_FILLED;
			return name;
		}
		case ORDINAL:
			if (entry->isByOrdinal() == false) return NOT_FILLED;
			return QString::number(entry->getOrdinal(), 16);
		case HINT:
			return  QString::number(entry->getHint(), 16);
	}

	int32_t fID = getFID(index);
	if (!entry->getFieldPtr(fID, 0)) return "-";
	 
	bool isOk = true;
	uint64_t val = entry->getNumValue(fID, &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

bool DelayImpFuncModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;
	if (!wrapper()) return false;

	int row = index.row();
	int column = index.column();
	int32_t fID = columnToFID(column);

	DelayImpFuncWrapper* entry = dynamic_cast<DelayImpFuncWrapper*>(wrapperAt(index));
	if (!entry)  return false;

	bool byOrd = entry->isByOrdinal();
	
	bool isModified = false;
	offset_t offset = 0;
	uint32_t fieldSize = 0;

	QString text = value.toString();
	 
	switch (column) {
		case NAME:
		{
			char* textPtr = entry->getFunctionName();
			if (!textPtr) return false;

			offset = entry->getOffset(textPtr);
			fieldSize = text.size() + 2;
			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);
			break;
		}
		case ORDINAL:
			if (!entry->isByOrdinal()) return false;
			return false;
			//break;
		default:
		{
			bool isOk = false;
			ULONGLONG number = text.toLongLong(&isOk, 16);
			if (!isOk) return false;

			offset = entry->getFieldOffset(fID);
			fieldSize = entry->getFieldSize(fID);

			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = entry->setNumValue(fID, number);
		}
	}
	//---
	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

Qt::ItemFlags DelayImpFuncModel::flags(const QModelIndex &index) const
{ 
	if (!index.isValid())
		return Qt::NoItemFlags;

	QString myData = data(index, Qt::DisplayRole).toString();
	if (myData == NOT_FILLED) return Qt::NoItemFlags;

	static Qt::ItemFlags editable = Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;

	int column = index.column();
	if (column >= ADDED_COLS_NUM) return editable;
	
	DelayImpFuncWrapper* entry = dynamic_cast<DelayImpFuncWrapper*>(wrapperAt(index));
	if (!entry) return 0;
	
	const bool byOrd = entry->isByOrdinal();
	if (byOrd) {
		if (column == ORDINAL) return editable;
	} else {
		if (column == NAME) return editable;
	}
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

```

`pe-bear/gui/pe_models/DelayImpTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class DelayImpTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	DelayImpTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent) {}
	
	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	virtual bool containsValue(QModelIndex index) const { return (index.column() >= NAME); }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM;  }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	inline int32_t columnToFID(int column) const { return column - ADDED_COLS_NUM; }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->delayImpDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const { return myPeHndl->delayImpDirWrapper.getEntryAt(index.row()); }

	enum cols {
		OFFSET,
		NAME,
		ADDED_COLS_NUM
	};

friend class DelayImpTreeView;
};

//----------------------------------------------------------------------

class DelayImpFuncModel  : public WrapperTableModel
{
	Q_OBJECT

public slots:
	void setParentId(size_t libraryId) { this->libraryId = libraryId; reset(); }

public:
	DelayImpFuncModel(PeHandler *peHndl, QObject *parent = 0);

	virtual int columnCount(const QModelIndex &parent) const;
	virtual int rowCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;

	//virtual bool containsOffset(QModelIndex index) const { return false; } // Do not show offset!
	virtual Executable::addr_type offsetAddrType() const;
	virtual bool containsValue(QModelIndex index) const { return true; }

protected:
	virtual ExeNodeWrapper* wrapper() const;
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	virtual bool isComplexValue(const QModelIndex &index) const { return false; }

	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM; }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	inline int32_t columnToFID(int column) const { return (column - ADDED_COLS_NUM); }
	inline int32_t FIDtoColumn(int fId) const { return (fId + ADDED_COLS_NUM); }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET,
		NAME,
		ORDINAL,
		HINT,
		ADDED_COLS_NUM
	};
	uint32_t libraryId;
};

```

`pe-bear/gui/pe_models/ExceptionTreeModel.cpp`:

```cpp
#include "ExceptionTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

int ExceptionTreeModel::columnCount(const QModelIndex &parent) const
{
	ExceptionDirWrapper* wrap = dynamic_cast<ExceptionDirWrapper*>(wrapper());
	if (!wrap) return 0;
	ExeNodeWrapper* entry = wrap->getEntryAt(0);
	if (!entry) return 0;
	uint32_t cntr = entry->getFieldsCount() + ADDED_COLS_NUM;
	return cntr;
}

QVariant ExceptionTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET: return "Offset";
	}
	ExceptionDirWrapper* impWrap = dynamic_cast<ExceptionDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();
	int32_t fID = this->columnToFID(section);
	return impWrap->getFieldName(0, fID);
}

ExeElementWrapper* ExceptionTreeModel::wrapperAt(QModelIndex index) const
{
	ExceptionDirWrapper* wrap = dynamic_cast<ExceptionDirWrapper*>(wrapper());
	if (!wrap) return NULL;
	return wrap->getEntryAt(index.row());
}

QVariant ExceptionTreeModel::data(const QModelIndex &index, int role) const
{
	ExceptionDirWrapper* impWrap = dynamic_cast<ExceptionDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::FontRole) return offsetFont;
	if (role == Qt::ToolTipRole) return toolTip(index);

	ExceptionEntryWrapper* entry =  dynamic_cast<ExceptionEntryWrapper*>(wrapperAt(index));
	if (!entry) return QVariant();

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
	}
	bool isOk = false;
	uint64_t val = entry->getNumValue(getFID(index), &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

bool ExceptionTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fID = getFID(index);

	if (!wrapper()) return false;
	ExceptionEntryWrapper* entry =  dynamic_cast<ExceptionEntryWrapper*>(wrapperAt(index));
	if (!entry) return false;

	QString text = value.toString();

	bool isModified = false;
	uint32_t offset = 0;
	uint32_t fieldSize = 0;

	bool isOk = false;
	ULONGLONG number = text.toLongLong(&isOk, 16);
	if (!isOk) return false;

	offset = entry->getFieldOffset(fID);
	fieldSize = entry->getFieldSize(fID);

	this->myPeHndl->backupModification(offset, fieldSize);
	isModified = entry->setNumValue(fID, index.column(), number);

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

//----------------------------------------------------------------------------

void  ExceptionTreeView::selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel)
{
	FollowablePeTreeView::selectionChanged(newSel, prevSel);

	ExceptionTreeModel *impModel = dynamic_cast<ExceptionTreeModel*> (this->model());
	if (!impModel) return;
	if (!impModel->wrapper()) return;
	if (newSel.indexes().size() == 0) return;
	QModelIndex index = newSel.indexes().at(0);
	uint32_t libId = index.row();
	emit librarySelected(libId);
}
```

`pe-bear/gui/pe_models/ExceptionTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class ExceptionTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	ExceptionTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent) {}

	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	virtual bool containsValue(QModelIndex index) const { return true; }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM;  }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->exceptDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	inline int32_t columnToFID(int column) const { return column - ADDED_COLS_NUM; }
	inline int32_t FIDtoColumn(int fId) const { return (fId + ADDED_COLS_NUM); }

	virtual bool isComplexValue(const QModelIndex &index) const { if (index.column() >= ADDED_COLS_NUM) return true; return false; }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET,
		ADDED_COLS_NUM
	};
friend class ExceptionTreeView;
};


 class ExceptionTreeView : public FollowablePeTreeView
{
	Q_OBJECT
signals:
	void librarySelected(uint32_t libraryId);

public:
	ExceptionTreeView(QWidget *parent) : FollowablePeTreeView(parent) {}
	void selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel);


};

```

`pe-bear/gui/pe_models/ExportsTreeModel.cpp`:

```cpp
#include "ExportsTreeModel.h"
#include "../../DateDisplay.h"

//-----------------------------------------------------------------------------
QVariant ExportsTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
		case VALUE2: return "Meaning";
	}
	return QVariant();
}

QVariant ExportsTreeModel::data(const QModelIndex &index, int role) const
{
	ExeElementWrapper* wrap = wrapper();
	if (!wrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	int fId = getFID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getFieldName(fId);
		case VALUE2:
		{
			if (fId == ExportDirWrapper::TIMESTAMP) {
				bool isOk = false;
				int val = wrap->getNumValue(fId, &isOk);
				if (!isOk) return "";
				return getDateString(val);
			}
			if (fId == ExportDirWrapper::NAME_RVA) {
				ExportDirWrapper* expW = dynamic_cast<ExportDirWrapper*>(wrap);
				if (expW) {
					return expW->getLibraryName();
				}
				return wrap->getName();
			}
			return "";
		}
	}
	return dataValue(index);
}

QString ExportsTreeModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (node == NULL) {
		return "-";
	}
	bool isOk = false;
	int funcNum = node->getNumValue(ExportDirWrapper::FUNCTIONS_NUM, &isOk);
	if (!isOk) return "-";

	std::string name = "Exported Functions";
	QString numDesc = funcNum == 1 ? " entry" : " entries";
	QString desc = QString::fromStdString(name) + "   [ " + QString::number(funcNum) + numDesc + " ]"; 
	return desc;
}

//----------------------------------------------------------------------

int ExportedFuncTreeModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	ExeNodeWrapper *w = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (w == NULL) return 0;

	return w->getEntriesNum();
}

QVariant ExportedFuncTreeModel::data(const QModelIndex &index, int role) const
{
	int row = index.row();
	int column = index.column();

	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role == Qt::FontRole) {
		if (column >= NAME) return QVariant();
		return offsetFont;
	}

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	ExportEntryWrapper* w = dynamic_cast<ExportEntryWrapper*>(wrapperAt(index));
	if (w == NULL) return QVariant();

	int fId = this->getFID(index);

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case ORDINAL : return QString::number(w->getOrdinal(), 16);
		case NAME_RVA:
		{
			uint64_t nameRva = w->getFuncNameRva();
			if (nameRva == INVALID_ADDR) return "-";
			return QString::number(nameRva, 16);
		}
		case NAME:
		{
			char *name = w->getFuncName();
			if (name == NULL) return QVariant();
			return QString(name);
		}
		case FORWARDER:
		{
			char *name = w->getForwarder();
			if (name == NULL) return QVariant();
			return QString(name);
		}
	}
	bool isOk = false;
	uint64_t val = w->getNumValue(0, &isOk);
	if (!isOk) return "UNK"; 

	return QString::number(val, 16);
}

bool ExportedFuncTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (role != Qt::DisplayRole && role != Qt::EditRole) return false;

	ExportEntryWrapper* entry = dynamic_cast<ExportEntryWrapper*>(wrapperAt(index));
	if (!entry) return false;

	int fID = this->getFID(index);
	QString text = value.toString();
	int column = index.column();

	bool isModified = false;
	offset_t offset = INVALID_ADDR;
	size_t fieldSize = 0;
	
	switch (index.column()) {
		case ORDINAL:
			return false;
		case NAME:
		{
			char *textPtr = entry->getFuncName();
			if (!textPtr) return false;

			offset = entry->getOffset(textPtr);
			fieldSize = text.size() + 2;

			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);
			break;
		}
		default:
		{
			bool isOk = false;
			ULONGLONG number = text.toLongLong(&isOk, 16);
			if (!isOk) return false;

			offset = entry->getFieldOffset(fID);
			fieldSize = entry->getFieldSize(fID);

			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = entry->setNumValue(fID, number);
			break;
		}
	}

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}


QVariant ExportedFuncTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET : return "Offset";
		case ORDINAL : return "Ordinal";
		case VALUE : return "Function RVA";
		case NAME_RVA : return "Name RVA";
		case NAME : return "Name";
		case FORWARDER: return "Forwarder";
	}
	return QVariant();
}

Executable::addr_type ExportedFuncTreeModel::addrTypeAt(QModelIndex index) const
{
	if (index.column() == NAME_RVA) {
		ExportEntryWrapper* w = dynamic_cast<ExportEntryWrapper*>(wrapperAt(index));
		if (w == NULL) return Executable::NOT_ADDR;

		if ( w->getFuncNameRva() == INVALID_ADDR) {
			return Executable::NOT_ADDR;
		}
		return Executable::RVA;
	}
	return  WrapperInterface::addrTypeAt(index);
}


Qt::ItemFlags ExportedFuncTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;

	static Qt::ItemFlags editable = Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
	static const  Qt::ItemFlags selectable = Qt::ItemIsEnabled | Qt::ItemIsSelectable;

	const int column = index.column();
	if (column == ORDINAL) return selectable;
	if (column >= 0) return editable;

	return selectable;
}

```

`pe-bear/gui/pe_models/ExportsTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"

//----------------------------

class ExportsTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	ExportsTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent) {}
	
	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE); }
	QString makeDockerTitle(uint32_t id);
	
protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return myPeHndl ? &myPeHndl->exportDirWrapper : NULL; }

	enum cols {
		OFFSET,
		NAME,
		VALUE,
		VALUE2,
		COLS_NUM
	};
friend class LdConfigTreeView;
};

//----------------------------------------------------------------------

class ExportedFuncTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	ExportedFuncTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent) {}

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;

	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;
	
	virtual bool containsValue(QModelIndex index) const { return index.column() == VALUE; }
	virtual ExeElementWrapper* wrapper() const { return myPeHndl ? &myPeHndl->exportDirWrapper : NULL; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const { return myPeHndl->exportDirWrapper.getEntryAt(index.row()); }

	virtual Executable::addr_type addrTypeAt(QModelIndex index) const;// { return  WrapperInterface::addrTypeAt(index); }
protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - VALUE;  }
	virtual int getSID(const QModelIndex &index) const { return index.column();  }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET = 0,
		ORDINAL,
		VALUE,
		NAME_RVA,
		NAME,
		FORWARDER,
		MAX_COL
	};
};

```

`pe-bear/gui/pe_models/FileHdrTreeModel.cpp`:

```cpp
#include "FileHdrTreeModel.h"

#include "../../DateDisplay.h"

//#define MAX_COL 3
///------------------------
enum COLS {
	COL_OFFSET = 0,
	COL_NAME,
	COL_VALUE,
	COL_MEANING,
	MAX_COL
};

FileHdrTreeItem::FileHdrTreeItem(PeHandler *peHndl, level_t level, FileHdrWrapper::FieldID role, FileHdrTreeItem *parent)
	:  PeTreeItem(peHndl, role, FIELD_NONE, parent),
	fileHdr(peHndl->fileHdrWrapper)
{
	parentItem = parent;
	this->level = level;
	this->role = role;
	if (this->m_PE == NULL) {
		this->level = DESC;
		this->role = FileHdrWrapper::NONE;
		return;
	}
}

int FileHdrTreeItem::columnCount() const
{
	return MAX_COL;
}

QVariant FileHdrTreeItem::background(int column) const
{
	if (m_PE == NULL) return QVariant();
	if (level == DETAILS && column >= COL_VALUE && column < MAX_COL) {
		QColor flagsColorT = addrColors.flagsColor();
		flagsColorT.setAlpha(addrColors.flagsAlpha());
		return flagsColorT;
	}
	return QVariant();
}

QVariant FileHdrTreeItem::foreground(int column) const
{
	if (column == COL_OFFSET) return this->offsetFontColor;
	return QVariant();
}

Qt::ItemFlags FileHdrTreeItem::flags(int column) const
{
	Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (column != COL_VALUE || level == DETAILS) return fl;
	return fl| Qt::ItemIsEditable;
}

QVariant FileHdrTreeItem::data(int column) const
{
	if (m_PE == NULL) return QVariant();

	if (this->level != DESC) return QVariant();
	switch (column) {
		case COL_OFFSET: return QString::number(getContentOffset(),16).toUpper();
		case COL_NAME: return fileHdr.getFieldName(role);
		case COL_VALUE:
		{
			bool isOk = false;
			uint64_t val = fileHdr.getNumValue(role, &isOk);
			if (!isOk) return QVariant();
			return QString::number(val, 16);
		}
		case COL_MEANING:
		{
			bool isOk = false;
			uint64_t val = fileHdr.getNumValue(role, &isOk);
			if (!isOk) return QVariant();
			if (role == FileHdrWrapper::TIMESTAMP) {
				return getDateString(val);
			}
			if (role == FileHdrWrapper::MACHINE) {
				return FileHdrWrapper::translateMachine(val);
			}
			return QString::number(val);
		}
	}
	return QVariant();
}

bool FileHdrTreeItem::setDataValue(int column, const QVariant &value)
{
	if (column != COL_VALUE) return false;

	QString text = value.toString();
	bool isOk = false;
	ULONGLONG number = text.toLongLong(&isOk, 16);
	if (!isOk) return false;

	isOk = fileHdr.setNumValue(role, number);
	return isOk;
}

offset_t FileHdrTreeItem::getContentOffset() const
{
	if (!m_PE) return 0;
	return fileHdr.getFieldOffset(role);
}

bufsize_t FileHdrTreeItem::getContentSize() const
{
	if (!m_PE) return 0;
	return fileHdr.getFieldSize(role);
}

//-------------------
FileHdrCharactTreeItem::FileHdrCharactTreeItem(PeHandler* peHndl, level_t level, DWORD characteristics, FileHdrTreeItem *parent)
	: FileHdrTreeItem(peHndl, level, role = FileHdrWrapper::CHARACT, parent)
{
	if (!myPeHndl) return;

	this->characteristics = characteristics;
	if (this->level == DESC) {
		bool isOk = false;
		this->characteristics = myPeHndl->fileHdrWrapper.getNumValue(FileHdrWrapper::CHARACT, &isOk);
		if (!isOk) {
			return;
		}
		loadChildren();
	}
}

void FileHdrCharactTreeItem::loadChildren()
{
	//create subrecords
	auto charactSet = FileHdrWrapper::splitCharact(this->characteristics);
	for (auto chIter = charactSet.begin(); chIter != charactSet.end(); ++chIter) {
		DWORD splitedCharacter = *chIter;
		this->appendChild(new FileHdrCharactTreeItem(myPeHndl, DETAILS, splitedCharacter, this));
	}
	return;
}

QVariant FileHdrCharactTreeItem::data(int column) const
{
	if (this->level == DESC) {
		switch (column) {
			case COL_OFFSET : return QString::number(getContentOffset(),16).toUpper();
			case COL_NAME: return ("Characteristics");
			case COL_VALUE: return QString::number(this->characteristics, 16).toUpper();
		}
		return QVariant();
	}
	//---
	switch (column) {
		case COL_VALUE: return QString::number(this->characteristics, 16).toUpper();
		case COL_MEANING: 
			return FileHdrWrapper::translateCharacteristics(this->characteristics);
	}
	return QVariant();
}

//-----------------------------------------------------------------------------
FileHdrTreeModel::FileHdrTreeModel(PeHandler* peHndl, QObject *parent)
	: PeWrapperModel(peHndl, parent)
{
	if (!m_PE) return;

	rootItem = new FileHdrTreeItem(peHndl);
	size_t fieldNum = FileHdrWrapper::FIELD_COUNTER;

	for (size_t i = 0; i < fieldNum; i++) {
		FileHdrWrapper::FieldID role = FileHdrWrapper::FieldID(i);
		if (role == FileHdrWrapper::CHARACT) {
			charactItem = new FileHdrCharactTreeItem(peHndl, FileHdrTreeItem::DESC);
			rootItem->appendChild(charactItem);
		} else
			rootItem->appendChild(new FileHdrTreeItem(peHndl, FileHdrTreeItem::DESC, role));
	}
	connect(peHndl, SIGNAL(modified()), this, SLOT(reload()));
}

void FileHdrTreeModel::reload()
{
	this->rootItem->detachChild(charactItem);
	delete charactItem;
	charactItem = NULL;

	charactItem = new FileHdrCharactTreeItem(myPeHndl, FileHdrTreeItem::DESC);
	rootItem->appendChild(charactItem);
	reset();
	emit modelUpdated();
}


bool FileHdrTreeModel::containsValue(QModelIndex index) const
{
	return (index.column() == COL_VALUE);
}

QVariant FileHdrTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) return QVariant();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::ToolTipRole) return this->toolTip(index);

	FileHdrTreeItem *item = static_cast<FileHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return QVariant();

	if (role == Qt::BackgroundColorRole)
		return item->background(index.column());

	if (role == Qt::SizeHintRole) {
		return QVariant(); //get default
	}

	if (role == Qt::DisplayRole || role == Qt::EditRole)
		return item->data(index.column());

	return QVariant();
}

bool FileHdrTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid())
		return false;

	FileHdrTreeItem *item = static_cast<FileHdrTreeItem*>(index.internalPointer());
	if (!item) return false;

	return item->setData(index.column(), value, item->role);
}


QVariant FileHdrTreeModel::headerData(int section, Qt::Orientation /* orientation */, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case COL_OFFSET : return "Offset";
		case COL_NAME : return "Name";
		case COL_VALUE : return "Value";
		case COL_MEANING : return "Meaning";
	}
	return QVariant();
}

Qt::ItemFlags FileHdrTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;

	FileHdrTreeItem *item = static_cast<FileHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return Qt::NoItemFlags;
	return item->flags(index.column());
}

offset_t FileHdrTreeModel::getContentOffset() const
{
	if (!m_PE) return 0;
	return m_PE->peNtHdrOffset();
}

bufsize_t FileHdrTreeModel::getContentSize() const
{
	if (!m_PE) return 0;
	return m_PE->peNtHeadersSize();
}

```

`pe-bear/gui/pe_models/FileHdrTreeModel.h`:

```h
#pragma once
#include <QtGui>

#include <map>
#include <set>
#include "../../gui_base/PeTreeView.h"
#include "../PeWrapperModel.h"

class FileHdrTreeItem : public PeTreeItem
{
	Q_OBJECT

protected:
	enum ViewLevel { DESC = 0, DETAILS = 1 };
	typedef enum ViewLevel level_t;

	QList<FileHdrTreeItem*> childItems;
	FileHdrTreeItem *parentItem;
	level_t level;
	FileHdrWrapper::FieldID role;

public:
	FileHdrTreeItem(PeHandler *peHndl, level_t level = DESC, FileHdrWrapper::FieldID role = FileHdrWrapper::NONE, FileHdrTreeItem *parent = NULL);
	int columnCount() const;

	virtual Qt::ItemFlags flags(int column) const;
	virtual QVariant data(int column) const;

	bool setDataValue(int column, const QVariant &value);
	virtual QVariant foreground(int column) const;
	virtual QVariant background(int column) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual bool isChildOk(TreeItem* child) { FileHdrTreeItem *ptr = dynamic_cast<FileHdrTreeItem*>(child); return (child)? true : false; }

	FileHdrWrapper &fileHdr;

friend class FileHdrTreeModel;
};

//-------------------

class FileHdrCharactTreeItem : public FileHdrTreeItem
{
	Q_OBJECT
public:
	FileHdrCharactTreeItem(PeHandler *peHndl, level_t level = DESC, DWORD characteristics = 0, FileHdrTreeItem *parent = NULL);
	virtual QVariant data(int column) const;
	void loadChildren();

protected:
	DWORD characteristics;
};

//-------------------

class FileHdrTreeModel : public PeWrapperModel
{
	Q_OBJECT

protected slots:
	void reload();

public:
	FileHdrTreeModel(PeHandler *peHndl, QObject *parent = 0);
	virtual ~FileHdrTreeModel() { }

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual bool containsValue(QModelIndex index) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->fileHdrWrapper; }

private:
	FileHdrCharactTreeItem *charactItem;
};

```

`pe-bear/gui/pe_models/ImportsTreeModel.cpp`:

```cpp
#include "ImportsTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

int ImportsTreeModel::columnCount(const QModelIndex &parent) const
{
	ImportDirWrapper* impWrap = dynamic_cast<ImportDirWrapper*>(wrapper());
	if (!impWrap) return 0;
	ExeNodeWrapper* entry = impWrap->getEntryAt(0);
	if (!entry) return 0;
	uint32_t cntr = entry->getFieldsCount() + ADDED_COLS_NUM;
	return cntr;
}

QVariant ImportsTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case IS_BOUND : return "Bound?";
		case FUNC_NUM: return "Func. Count";
	}
	ImportDirWrapper* impWrap = dynamic_cast<ImportDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int32_t fID = this->columnToFID(section);
	return impWrap->getFieldName(0, fID);
}

ExeElementWrapper* ImportsTreeModel::wrapperAt(QModelIndex index) const
{
	ImportDirWrapper* impWrap = dynamic_cast<ImportDirWrapper*>(wrapper());
	if (!impWrap) return NULL;
	return impWrap->getEntryAt(index.row());
}

QVariant ImportsTreeModel::data(const QModelIndex &index, int role) const
{
	ImportDirWrapper* impWrap = dynamic_cast<ImportDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (column != NAME && role == Qt::FontRole) return offsetFont;
	if (role == Qt::ToolTipRole) return toolTip(index);

	ImportEntryWrapper* entry =  dynamic_cast<ImportEntryWrapper*>(wrapperAt(index));
	if (!entry) return QVariant();

	if (role == Qt::BackgroundColorRole && !entry->isValid()) return errColor;
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return entry->getName();
		case FUNC_NUM: return QString::number(entry->getEntriesCount());
		case IS_BOUND: return entry->isBound();
	}
	bool isOk = false;
	uint64_t val = entry->getNumValue(getFID(index), &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

bool ImportsTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fId = index.row();
	uint32_t sID = this->columnToFID(index.column());

	if (!wrapper()) return false;
	ImportEntryWrapper* entry =  dynamic_cast<ImportEntryWrapper*>(wrapperAt(index));
	if (!entry) return false;

	QString text = value.toString();

	bool isModified = false;
	offset_t offset = 0;
	bufsize_t fieldSize = 0;

	if (index.column() == NAME) {
		char* textPtr = entry->getLibraryName();
		if (!textPtr) return false;

		offset = entry->getOffset(textPtr);
		fieldSize = text.size() + 2;

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);

	} else {
		
		bool isOk = false;
		ULONGLONG number = text.toLongLong(&isOk, 16);
		if (!isOk) return false;

		offset = entry->getFieldOffset(sID);
		fieldSize = entry->getFieldSize(sID);

		this->myPeHndl->backupModification(offset, fieldSize);
		isModified = entry->setNumValue(sID, index.column(), number);
	}

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

Qt::ItemFlags ImportsTreeModel::flags(const QModelIndex &index) const
{ 
	if (!index.isValid())
		return Qt::NoItemFlags;
	int column = index.column();
	if (column == NAME || column >= ADDED_COLS_NUM) return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

//----------------------------------------------------------------------------
ImportedFuncModel::ImportedFuncModel(PeHandler *peHndl, QObject *parent)
	:  WrapperTableModel(peHndl, parent), 
	libraryId(0)
{
	connect(peHndl, SIGNAL(modified()), this, SLOT(onNeedReset()));
}

ImportEntryWrapper* ImportedFuncModel::wrapper() const
{
	if (!myPeHndl) return NULL;
	ImportDirWrapper& impWrap = myPeHndl->importDirWrapper;
	ImportEntryWrapper* entryWrapp = dynamic_cast<ImportEntryWrapper*>(impWrap.getEntryAt(this->libraryId));
	return entryWrapp;
}

ExeElementWrapper* ImportedFuncModel::wrapperAt(QModelIndex index) const
{
	ImportEntryWrapper* wrapper = this->wrapper();
	if (!wrapper) return NULL;
	int sId = this->getSID(index);
	return wrapper->getEntryAt(sId);
}

int ImportedFuncModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	uint32_t cntr = wrapper()->getEntriesCount();
	return cntr;
}

int ImportedFuncModel::columnCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	uint32_t cntr = ImportedFuncWrapper::FIELD_COUNTER + ADDED_COLS_NUM;
	return cntr;
}

QVariant ImportedFuncModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	if (!wrapper()) return QVariant();
	size_t fId = columnToFID(section);
	ExeNodeWrapper* entry = wrapper()->getEntryAt(0);

	if (entry == NULL) return "";

	switch (section) {
		case NAME: return "Name";
		case ORDINAL : return "Ordinal";
		case CALL_VIA: return "Call via";
	}
	return entry->getFieldName(fId);
}

QVariant ImportedFuncModel::data(const QModelIndex &index, int role) const
{
	if (!wrapper()) return QVariant();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	int row = index.row();
	int column = index.column();

	if (column != NAME && role == Qt::FontRole) return offsetFont;
	if (column == CALL_VIA && role == Qt::ForegroundRole) return offsetFontColor;

	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	ImportedFuncWrapper* entry =  dynamic_cast<ImportedFuncWrapper*>(wrapperAt(index));
	if (!entry) return QVariant();

	switch (column) {
		case NAME:
		{
			char *name = entry->getFunctionName();
			if (!name) return NOT_FILLED;
			return name;
		}
		case ORDINAL:
			if (!entry->isByOrdinal()) return NOT_FILLED;
			return QString::number(entry->getThunkValue(), 16);

		case CALL_VIA:
			uint64_t val = entry->getFieldRVA(ImportEntryWrapper::FIRST_THUNK);
			return QString::number(val, 16);
	}

	int32_t fID = columnToFID(column);
	if (!entry->getFieldPtr(fID)) return "-";
	 
	bool isOk = true;
	uint64_t val = entry->getNumValue(fID, &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

bool ImportedFuncModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;
	if (!wrapper()) return false;

	int row = index.row();
	int column = index.column();
	int32_t fID = columnToFID(column);

	ImportedFuncWrapper* entry =  dynamic_cast<ImportedFuncWrapper*>(wrapper()->getEntryAt(row));
	if (!entry)  return false;

	bool byOrd = entry->isByOrdinal();
	
	bool isModified = false;
	offset_t offset = INVALID_ADDR;
	bufsize_t fieldSize = 0;

	QString text = value.toString();
	 
	switch (column) {
		case NAME:
		{
			char* textPtr = entry->getFunctionName();
			if (!textPtr) return false;

			offset = entry->getOffset(textPtr, true);
			if (offset == INVALID_ADDR) return false;

			fieldSize = text.length() + 2;
			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = m_PE->setTextValue(textPtr, text.toStdString(), fieldSize);
			break;
		}
		case ORDINAL:
			if (!entry->isByOrdinal()) return false;
			return false;

		default:
		{
			bool isOk = false;
			ULONGLONG number = text.toLongLong(&isOk, 16);
			if (!isOk) return false;

			offset = entry->getFieldOffset(fID);
			fieldSize = entry->getFieldSize(fID);

			this->myPeHndl->backupModification(offset, fieldSize);
			isModified = entry->setNumValue(fID, number);
		}
	}
	//---
	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

Qt::ItemFlags ImportedFuncModel::flags(const QModelIndex &index) const
{ 
	if (!index.isValid())
		return Qt::NoItemFlags;

	QString myData = data(index, Qt::DisplayRole).toString();
	if (myData == NOT_FILLED) return Qt::NoItemFlags;

	static Qt::ItemFlags editable = Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;

	int column = index.column();
	if (column >= ADDED_COLS_NUM) return editable;

	ImportedFuncWrapper* entry =  dynamic_cast<ImportedFuncWrapper*>(this->wrapperAt(index));
	if (!entry) return Qt::NoItemFlags;
	
	bool byOrd = entry->isByOrdinal();
	if (byOrd) {
		if (column == ORDINAL) return editable;
	} else {
		if (column == NAME) return editable;
	}
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

```

`pe-bear/gui/pe_models/ImportsTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class ImportsTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	ImportsTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent)
	{
		this->connectSignals();
	}

	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual bool containsValue(QModelIndex index) const { return true; }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM;  }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->importDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	inline int32_t columnToFID(int column) const { return column - ADDED_COLS_NUM; }
	inline int32_t FIDtoColumn(int fId) const { return (fId + ADDED_COLS_NUM); }

	virtual bool isComplexValue(const QModelIndex &index) const { if (index.column() >= ADDED_COLS_NUM) return true; return false; }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET,
		NAME,
		FUNC_NUM,
		IS_BOUND,
		ADDED_COLS_NUM
	};
friend class ImportsTreeView;
};

//----------------------------------------------------------------------

class ImportedFuncModel  : public WrapperTableModel
{
	Q_OBJECT

public slots:
	void setParentId(size_t libraryId) { this->libraryId = libraryId; reset(); }

public:
	ImportedFuncModel(PeHandler *peHndl, QObject *parent = 0);

	virtual int columnCount(const QModelIndex &parent) const;
	virtual int rowCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual Executable::addr_type offsetAddrType() const { return Executable::RVA; }
	virtual bool containsValue(QModelIndex index) const { return true; }

protected:
	virtual ImportEntryWrapper* wrapper() const;
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	virtual bool isComplexValue(const QModelIndex &index) const { return false; }

	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM; }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	inline int32_t columnToFID(int column) const { return (column - ADDED_COLS_NUM); }
	inline int32_t FIDtoColumn(int fId) const { return (fId + ADDED_COLS_NUM); }

	enum FieldID {
		NONE = FIELD_NONE,
		CALL_VIA,
		NAME,
		ORDINAL,
		ADDED_COLS_NUM
	};
	uint32_t libraryId;
};

```

`pe-bear/gui/pe_models/LdConfigTreeModel.cpp`:

```cpp
#include "LdConfigTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"


QVariant LdConfigTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
		case MEANING: return "";
	}
	return QVariant();
}

QVariant LdConfigTreeModel::toolTip(QModelIndex index) const
{
	if (!index.isValid()) return "";

	const size_t fId = getFID(index);
	if (fId == LdConfigDirWrapper::GUARD_FLAGS) {
		LdConfigDirWrapper* wrap = dynamic_cast<LdConfigDirWrapper*>(wrapper());
		if (!wrap) return QVariant();
		return wrap->translateGuardFlagsContent("\n");
	}
	return PeTreeModel::toolTip(index);
}


QVariant LdConfigTreeModel::data(const QModelIndex &index, int role) const
{
	ExeElementWrapper* wrap = wrapper();
	if (!wrap) return QVariant();
	
	size_t fId = getFID(index);
	
	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (column == MEANING) {
		if (wrap->hasSubfieldWrapper(fId)) {
			if (role == Qt::DecorationRole) return ViewSettings::getScaledPixmap(":/icons/List.ico");
			if (role == Qt::ToolTipRole) return "List";
		}
		if (fId == LdConfigDirWrapper::GUARD_FLAGS) {
			if (role == Qt::DecorationRole) return ViewSettings::getScaledPixmap(":/icons/information.ico");
		}
	}
	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getFieldName(fId);
		case MEANING: 
		{
			return QVariant();
		}
	}
	return dataValue(index);
}

QString LdConfigTreeModel::makeDockerTitle(uint32_t upId)
{
	if (!wrapper()) return "";
	QString name = this->wrapper()->getFieldName(upId);

	LdConfigDirWrapper* node = dynamic_cast<LdConfigDirWrapper*>(wrapper());
	if (node == NULL) {
		return "";
	}
	if (!wrapper()->hasSubfieldWrapper(upId)) {
		return "";
	}
	uint32_t funcNum = node->getSubfieldWrapperCount(upId);
	QString numDesc = funcNum == 1 ? " entry" : " entries";
	QString desc = name + "   [ " + QString::number(funcNum) + numDesc + " ]";
	return desc;
}

//-----------------------------------------------------------------------------------

int LdEntryTreeModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;

	LdConfigDirWrapper *w = dynamic_cast<LdConfigDirWrapper*>(wrapper());
	if (w == NULL) return 0;
	
	// count wrappers in the parent directory
	return w->getSubfieldWrapperCount(parentId);
}

int LdEntryTreeModel::columnCount(const QModelIndex &parent) const
{
	LdConfigEntryWrapper *elW = getEntryWrapperAtID(0);
	if (elW == NULL) return 0;
	
	// count fields in child wrapper:
	return elW->getFieldsCount() + 1;
}

ExeElementWrapper* LdEntryTreeModel::wrapperAt(QModelIndex index) const
{
	if (!wrapper()) return NULL;

	LdConfigDirWrapper *w = dynamic_cast<LdConfigDirWrapper*>(wrapper());
	if (w == NULL) return NULL;
	// get wrapper from the parent directory
	return w->getSubfieldWrapper(parentId, this->getFID(index));
}

QVariant LdEntryTreeModel::data(const QModelIndex &index, int role) const
{
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role == Qt::FontRole) return offsetFont;

	int column = index.column();
	int sId = this->getSID(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	if (column == OFFSET) {
		return QString::number(getFieldOffset(index), 16);
	}
	LdConfigEntryWrapper *elW = dynamic_cast<LdConfigEntryWrapper*>(wrapperAt(index));
	if (elW == NULL) {
		return QVariant();
	}
	bool isOk = false;
	const uint64_t val = elW->getNumValue(sId, &isOk);
	if (!isOk) return QVariant();

	return QString::number(val, 16);
}

QVariant LdEntryTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	
	LdConfigEntryWrapper *elW = getEntryWrapperAtID(0);
	if (elW == NULL) return QVariant();
	if (section == OFFSET) {
		return "Offset";
	}
	return elW->getFieldName(section - 1);
}

```

`pe-bear/gui/pe_models/LdConfigTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>
#include <iostream>

#include "../../gui_base/WrapperTableModel.h"

class LdConfigTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	LdConfigTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent) {}
	
	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual QVariant toolTip(QModelIndex index) const;
	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE); }
	virtual QString makeDockerTitle(uint32_t upId);
	
protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->ldConfDirWrapper; }

	enum cols {
		OFFSET,
		NAME,
		VALUE,
		MEANING,
		COLS_NUM
	};
friend class LdConfigTreeView;
};

//-------------------------------------------------------------------------------------------

class LdEntryTreeModel : public WrapperTableModel
{
	Q_OBJECT

public slots:
	void setParentId(size_t parentId)
	{
		this->parentId = parentId;
		reset();
	}
	
public:
	LdEntryTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent), parentId(0){ }

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const;// { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;

	virtual Executable::addr_type addrTypeAt(QModelIndex index) const
	{
		switch(index.column()) {
			case OFFSET: return Executable::RAW;
			case ADDRESS: return Executable::RVA;
		}
		return Executable::NOT_ADDR;
	}
	
	virtual offset_t getFieldOffset(QModelIndex index) const
	{ 
		if (!index.isValid()) return 0;
		LdConfigEntryWrapper *elW = dynamic_cast<LdConfigEntryWrapper*>(wrapperAt(index));
		if (elW == NULL) {
			return 0;
		}
		return elW->getOffset();
	}
	
	virtual bufsize_t getFieldSize(QModelIndex index) const
	{ 
		if (!index.isValid()) return 0;
		LdConfigEntryWrapper *elW = dynamic_cast<LdConfigEntryWrapper*>(wrapperAt(index));
		if (elW == NULL) {
			return 0;
		}
		return elW->getSize();
	}

	virtual bool containsValue(QModelIndex index) const { return index.column() == ADDRESS; }
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->ldConfDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;
	
protected:
	LdConfigEntryWrapper *getEntryWrapperAtID(int id) const
	{
		LdConfigDirWrapper *w = dynamic_cast<LdConfigDirWrapper*>(wrapper());
		if (w == NULL) return NULL;
		
		LdConfigEntryWrapper *elW = dynamic_cast<LdConfigEntryWrapper*>(w->getSubfieldWrapper(parentId, id));
		if (elW == NULL) return 0;
		return elW;
	}
	
	virtual int getFID(const QModelIndex &index) const { return index.row(); }
	virtual int getSID(const QModelIndex &index) const
	{
		if (!index.isValid()) return 0;
		return index.column() - 1; 
	}

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET = 0,
		//VALUE,
		ADDRESS,
		MAX_COL
	};

	size_t parentId;
};

```

`pe-bear/gui/pe_models/OptionalHdrTreeModel.cpp`:

```cpp
#include "OptionalHdrTreeModel.h"


DataDirTreeItem::DataDirTreeItem(PeHandler *peHndl, level_t level, int recordNum, OptionalHdrTreeItem *parent)
    : OptionalHdrTreeItem(peHndl, level, OptHdrWrapper::DATA_DIR, parent)
{
	if (this->level == DESC) {
		this->recordNum = (-1);
		int size = pe::DIR_ENTRIES_COUNT;
		//create subitems:
		for (size_t childIndx = 0; childIndx < size; childIndx++) 
			this->appendChild(new DataDirTreeItem(myPeHndl, DETAILS, childIndx, this));

		return;
	}
	//---
	this->recordNum = recordNum;
	this->sID = recordNum;
}

QVariant DataDirTreeItem::background(int column) const
{
	DataDirWrapper *dDir = wrapper();
	if(!dDir) return QVariant();

	int fId = this->getFID(column);

	if (level == DESC && column > COL_NAME && column <= COL_VALUE2) {
		QColor dataDirNameCol = addrColors.dataDirNameColor();
		dataDirNameCol.setAlpha(addrColors.dataDirNameAlpha());
		return dataDirNameCol;
	}
	if (level != DETAILS) return QVariant();
	if (column == COL_NAME) {
		QColor dataDirNameCol = addrColors.dataDirNameColor();
		dataDirNameCol.setAlpha(addrColors.dataDirNameAlpha());
		return dataDirNameCol;
	}
	if (column == COL_VALUE2) {
		int sId =  this->getSID(column);

		bool isOk = false;
		offset_t addr = dDir->getNumValue(fId, DataDirWrapper::ADDRESS, &isOk);
		if (!isOk) return errColor;

		uint64_t size = dDir->getNumValue(fId, DataDirWrapper::SIZE, &isOk);
		if (!isOk) return errColor;

		Executable::addr_type aType = dDir->containsAddrType(fId, DataDirWrapper::ADDRESS);
		if (addr == INVALID_ADDR || (size && !m_PE->getContentAt(addr, aType, size, false))) {
			return errColor;
		}
	}
	if (column > COL_NAME && column <= COL_VALUE2) {
		//make color
		QColor ddirCol = addrColors.dataDirColor();
		
		if (column % 2) 
			ddirCol.setAlpha(200);
		else 
			ddirCol.setAlpha(100);

		return ddirCol;
	}
	return QVariant();
}

QVariant DataDirTreeItem::edit(int column) const
{
	if (this->level == DESC) return QVariant();
	return data(column);
}

Qt::ItemFlags DataDirTreeItem::flags(int column) const
{
	static Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (column == 0 || column > COL_VALUE2) return fl;

	if (level == DETAILS && column > COL_NAME && column <= COL_VALUE2)
		return fl | Qt::ItemIsEditable;
	return fl;
}

bool DataDirTreeItem::containsRVA(QModelIndex index) const
{
	if (index.column() != COL_VALUE) return false;
	if (this->recordNum == pe::DIR_SECURITY) return false;
	return true;
}

offset_t DataDirTreeItem::getContentOffset() const
{
	DataDirWrapper *dDir = wrapper();
	if(!dDir) return INVALID_ADDR;

	int fId = this->getFID();
	return dDir->getFieldOffset(fId);
}

bufsize_t DataDirTreeItem::getContentSize() const
{
	DataDirWrapper *dDir = wrapper();
	if(!dDir) return 0;

	int fId = this->getFID();
	return dDir->getFieldSize(fId, FIELD_NONE);
}

QVariant DataDirTreeItem::data(int column) const
{
	DataDirWrapper *dDir = wrapper();
	if(!dDir) return QVariant();

	int fId = this->getFID(column);
	
	if (this->level == DESC) {
		switch (column) {
			case COL_NAME : return dDir->getName();
		    case COL_VALUE : return ("Address");
		    case COL_VALUE2 : return ("Size");
		}
		return QVariant();
	}

	if (column == COL_OFFSET) {
		return QString::number(getContentOffset(), 16).toUpper();
	}

	if (column == COL_NAME) {
		return dDir->getFieldName(fId);
	}

	if (column == COL_VALUE || column == COL_VALUE2) {
		int sId =  this->getSID(column);

		bool isOk = false;
		uint64_t val = dDir->getNumValue(fId, sId, &isOk); //DataDirWrapper::ADDRESS , DataDirWrapper::SIZE
		if (!isOk) return "UNK";

		return QString::number((uint32_t) val, 16).toUpper();
	}
	return QVariant();
}

bool DataDirTreeItem::setDataValue(int column, const QVariant &value)
{
	bool isConv = false;
	DWORD number = value.toString().toInt(&isConv, 16);
	if (!isConv) return isConv;

	DataDirWrapper *dDir = wrapper();
	if(!dDir) return false;
	int fId = this->getFID(column);

	if (column == COL_VALUE || column == COL_VALUE2) {
		int sId =  this->getSID(column);
		return dDir->setNumValue(fId, sId, number);
	}
	return false;
}

QVariant DataDirTreeItem::toolTip(int column) const
{
	if (m_PE == NULL) return QVariant();

	if (this->level == DESC) return QVariant();

	if (column == COL_OFFSET) return "Right click to follow";
	IMAGE_DATA_DIRECTORY *dataDir = this->m_PE->getDataDirectory();

	DWORD va = dataDir[recordNum].VirtualAddress;
	DWORD size = dataDir[recordNum].Size;
	if (va == 0 && size == 0) return "<empty>";

	SectionHdrWrapper *sec = m_PE->getSecHdrAtOffset(va, Executable::RVA);
	if (sec == NULL)
		return "";
	return sec->mappedName;
}
//---

OptHdrDllCharactTreeItem::OptHdrDllCharactTreeItem(PeHandler *peHndl, level_t level, DWORD characteristics, OptionalHdrTreeItem *parent)
	: OptionalHdrTreeItem(peHndl, level, OptHdrWrapper::DLL_CHARACT, parent)
{
	this->characteristics = characteristics;
	if (this->level == DESC)
		init();
}

void OptHdrDllCharactTreeItem::init()
{
	if (!myPeHndl || this->level != DESC) return;

	bool isOk;
	this->characteristics = myPeHndl->optHdrWrapper.getNumValue(role, &isOk);
	if (!isOk) return;

	/* create subrecords */ 
	std::vector<DWORD> charactSet = OptHdrWrapper::splitDllCharact(this->characteristics);
	for (std::vector<DWORD>::const_iterator chIter = charactSet.begin(); chIter != charactSet.end(); ++chIter) {
		DWORD splitedCharacter = *chIter;
		this->appendChild(new OptHdrDllCharactTreeItem(myPeHndl, DETAILS, splitedCharacter, this));
	}
}

QVariant OptHdrDllCharactTreeItem::data(int column) const
{
	if (!m_PE) return QVariant();

	if (this->level == DESC) {
		switch (column) {
			case COL_OFFSET : return QString::number(getContentOffset(), 16).toUpper();
			case COL_NAME : return ("DLL Characteristics");
			case COL_VALUE : return QString::number(this->characteristics, 16).toUpper();
		}
		return QVariant();
	}

	switch (column) {
		case COL_VALUE : return QString::number(this->characteristics, 16).toUpper();
		case COL_VALUE2 : 
			return OptHdrWrapper::translateDllCharacteristics(this->characteristics);
	}
	return QVariant();
}

offset_t OptHdrDllCharactTreeItem::getContentOffset() const
{
	offset_t offset = this->m_PE->peOptHdrOffset();

	Executable::exe_bits mode = this->m_PE->getBitMode();
	if (mode != Executable::BITS_32 && mode != Executable::BITS_64) return 0;
	static IMAGE_OPTIONAL_HEADER32 h32;
	static IMAGE_OPTIONAL_HEADER64 h64;
	return offset + (mode == Executable::BITS_32 ? ((uint64_t)&h32.DllCharacteristics - (uint64_t) &h32) : ((uint64_t) &h64.DllCharacteristics - (uint64_t) &h64));
}
///------------------------

OptionalHdrTreeItem::OptionalHdrTreeItem(PeHandler *peHndl, level_t level, OptHdrWrapper::OptHdrFID role, OptionalHdrTreeItem *parent)
	: PeTreeItem(peHndl, role, FIELD_NONE, parent), 
	optHdr(peHndl->optHdrWrapper)
{
	this->setParent(parent);
	this->m_parentItem = parent;
	
	this->level = level;
	this->role = role;
	if (this->m_PE == NULL) {
		this->level = DESC;
		this->role = OptHdrWrapper::NONE;
		return;
	}
}

int OptionalHdrTreeItem::columnCount() const { 	return MAX_COL; }

QVariant OptionalHdrTreeItem::background(int column) const
{
	if (!m_PE) return QVariant();
	if (role == OptHdrWrapper::EP && column == COL_VALUE) {
		if (!m_PE->getContentAt(m_PE->getEntryPoint(Executable::RAW), 1)) {
			return errColor;
		}
	}
	if (role == OptHdrWrapper::CHECKSUM && column == COL_VALUE) {
		bool isOk;
		uint64_t checksum = myPeHndl->optHdrWrapper.getNumValue(OptHdrWrapper::CHECKSUM, &isOk);
		if (isOk) {
			if (this->myPeHndl->getCurrentChecksum() != QString::number(checksum, 16)) return errColor;
		}
	}
	if (level == DETAILS && (column >= COL_VALUE && column <= COL_VALUE2)) {
		QColor flagsColorT = addrColors.flagsColor();
		flagsColorT.setAlpha(addrColors.flagsAlpha());
		return flagsColorT;
	}
	return QVariant();
}

QVariant OptionalHdrTreeItem::foreground(int column) const
{
	if (column == COL_OFFSET) return this->offsetFontColor;
	return QVariant();
}

QVariant OptionalHdrTreeItem::toolTip(int column) const
{
	int fieldIndx = column;
	if (!myPeHndl || !m_PE) return QVariant();

	if (column == COL_OFFSET) return "Right click to follow";

	if (role == OptHdrWrapper::DLL_CHARACT) {
		bool isOk;
		DWORD val = myPeHndl->optHdrWrapper.getNumValue(OptHdrWrapper::DLL_CHARACT, &isOk);
		if (!isOk) return QVariant();

		std::vector<DWORD> charactSet = OptHdrWrapper::splitDllCharact(val);
		QString tip = "";
		for (std::vector<DWORD>::const_iterator iter = charactSet.begin(); iter != charactSet.end(); ++iter) {
			QString name = OptHdrWrapper::translateDllCharacteristics(*iter);
			if (name.length()) continue;
			if (tip.size() > 0) tip +="\n";
			tip += name;
		}
		return tip;
	}
	return data(column);
}

offset_t OptionalHdrTreeItem::getContentOffset() const
{
	if (!m_PE) return 0;
	return optHdr.getFieldOffset(role);
}

bufsize_t OptionalHdrTreeItem::getContentSize() const
{
	if (!m_PE) return 0;
	return optHdr.getFieldSize(role);
}

QVariant OptionalHdrTreeItem::font(int col) const
{
	if (col != COL_NAME && col != COL_VALUE2 && this->role < OptHdrWrapper::DATA_DIR) {
		return this->offsetFont;
	}
	return QVariant();
}

QVariant OptionalHdrTreeItem::data(int column) const
{
	if (m_PE == NULL) return QVariant();

	if (this->level != DESC) return QVariant();
	if (!optHdr.getFieldPtr(role)) return QVariant();

	switch (column) {
		case COL_OFFSET : return QString::number(getContentOffset(), 16).toUpper();
		case COL_NAME : return optHdr.getFieldName(role);
		case COL_VALUE2 : return dataValMeanings();
		case COL_VALUE : 
		{
			bool isOk = false;
			uint64_t val = optHdr.getNumValue(role, column, &isOk);

			if (!isOk) return QVariant(); /* other type? */
			return QString::number(val, 16);
		}
	}
	return QVariant();
}

Qt::ItemFlags OptionalHdrTreeItem::flags(int column) const
{
	static Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (!optHdr.getFieldPtr(role)) return 0;

	if (column != COL_VALUE || level == DETAILS) return fl;
	return fl | Qt::ItemIsEditable;
}

bool OptionalHdrTreeItem::setDataValue(int column, const QVariant &value)
{
	if (this->m_PE == NULL) return false;
	if (column != COL_VALUE) return false;

	QString text = value.toString();
	bool isOk = false;
	ULONGLONG number = text.toLongLong(&isOk, 16);
	if (!isOk) return false;
	isOk = optHdr.setNumValue(role, column, number);
	return isOk;
}

QVariant OptionalHdrTreeItem::dataValMeanings() const
{
	if (this->m_PE == NULL) return QVariant();
	bool isOk = false;

	switch (role) {
		case OptHdrWrapper::MAGIC:
		{
			DWORD val = (DWORD) optHdr.getNumValue(OptHdrWrapper::MAGIC, &isOk);
			if (!isOk) return QVariant();
			return OptHdrWrapper::translateOptMagic(val);
		}
		case OptHdrWrapper::OSVER_MAJOR:
		{
			uint16_t* major = (uint16_t*) optHdr.getFieldPtr(OptHdrWrapper::OSVER_MAJOR);
			uint16_t* minor = (uint16_t*) optHdr.getFieldPtr(OptHdrWrapper::OSVER_MINOR);
			if (!major || !minor) return QVariant();

			return OptHdrWrapper::translateOSVersion(*major, *minor);
		}
		case OptHdrWrapper::SUBSYS:
		{
			DWORD val = (DWORD)optHdr.getNumValue(OptHdrWrapper::SUBSYS, &isOk);
			if (!isOk) return QVariant();
			return OptHdrWrapper::translateSubsystem(val);
		}	
	}
	return QVariant();
}


//-----------------------------------------------------------------------------
OptionalHdrTreeModel::OptionalHdrTreeModel(PeHandler *peHndl, QObject *parent)
	:  PeWrapperModel(peHndl, parent)
{
	if (!m_PE) return;

	rootItem = new OptionalHdrTreeItem(peHndl);
	size_t fieldNum = OptHdrWrapper::FIELD_COUNTER;

	for (int i = 0; i < fieldNum; i++) {
	
		OptHdrWrapper::OptHdrFID role = OptHdrWrapper::OptHdrFID(i);

		if (role == OptHdrWrapper::DATA_DIR)
			rootItem->appendChild(new DataDirTreeItem(peHndl, OptionalHdrTreeItem::DESC));
		else if (role == OptHdrWrapper::DLL_CHARACT) {
			this->dllCharact = new OptHdrDllCharactTreeItem(peHndl, OptionalHdrTreeItem::DESC);
			rootItem->appendChild(dllCharact);
		} else
			rootItem->appendChild(new OptionalHdrTreeItem(peHndl, OptionalHdrTreeItem::DESC, role));
	}
	connect(peHndl, SIGNAL(modified()), this, SLOT(reload()));
}

void OptionalHdrTreeModel::reload()
{
	this->dllCharact->removeAllChildren();
	this->reset();
	this->dllCharact->init();
	this->reset();
	emit modelUpdated();
}

QVariant OptionalHdrTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) return QVariant();
	if (role == Qt::ForegroundRole) {
		int fId = getFID(index);
		return this->addrColor(index);
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	OptionalHdrTreeItem *item = static_cast<OptionalHdrTreeItem*> (index.internalPointer());
	if (item == NULL) return QVariant();

	switch (role) {
		case Qt::FontRole :
			return item->font(index.column());
		case Qt::BackgroundColorRole :
			return item->background(index.column());
		case Qt::ForegroundRole :
			return item->foreground(index.column());
		case Qt::DisplayRole : 
		case Qt::EditRole :
			return item->data(index.column());
	}
	return QVariant();
}


bool OptionalHdrTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid())
		return false;

	OptionalHdrTreeItem *item = static_cast<OptionalHdrTreeItem*>(index.internalPointer());
	if (!item) return false;
	return item->setData(index.column(), value, role);
}


QVariant OptionalHdrTreeModel::headerData(int section, Qt::Orientation orien, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case COL_OFFSET : return "Offset";
		case COL_NAME : return "Name";
		case COL_VALUE : return "Value";
		case COL_VALUE2 : return "Value";
	}
	return QVariant();
}

Qt::ItemFlags OptionalHdrTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;
	
	OptionalHdrTreeItem *item = static_cast<OptionalHdrTreeItem*>(index.internalPointer());
	if (!item)
		return Qt::NoItemFlags;
	
	return item->flags(index.column());
}

bool OptionalHdrTreeModel::containsValue(QModelIndex index) const
{
	OptionalHdrTreeItem *childItem = static_cast<OptionalHdrTreeItem*>(index.internalPointer());
	DataDirTreeItem *dataDirItem = dynamic_cast<DataDirTreeItem*>(childItem);

	if (dataDirItem) {
		if (dataDirItem->level != OptionalHdrTreeItem::DETAILS) return false;
		if (index.column() == COL_VALUE) return true;
	}
	if (index.column() == COL_VALUE) return true;
	return false;
}

int OptionalHdrTreeModel::getFID(const QModelIndex &index) const
{
	if (!index.isValid()) return -1;
	
	OptionalHdrTreeItem* item = static_cast<OptionalHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return -1;
	int fId = item->role;

	DataDirTreeItem *dataDirItem = dynamic_cast<DataDirTreeItem*>(item);
	if (dataDirItem) fId = dataDirItem->recordNum;
	return fId;
}

int OptionalHdrTreeModel::getSID(const QModelIndex &index) const
{
	return index.column() - COL_VALUE;
}

ExeElementWrapper* OptionalHdrTreeModel::wrapperAt(QModelIndex index) const
{
	if (!index.isValid()) return NULL;
	OptionalHdrTreeItem* item = static_cast<OptionalHdrTreeItem*>(index.internalPointer());
	if (item == NULL) return NULL;

	ExeElementWrapper *wrapper = this->wrapper();
	DataDirTreeItem *dataDirItem = dynamic_cast<DataDirTreeItem*>(item);
	if (dataDirItem) {
		return &this->myPeHndl->dataDirWrapper;
	}
	return wrapper;
}

```

`pe-bear/gui/pe_models/OptionalHdrTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/PeTreeView.h"
#include "../PeWrapperModel.h"

//---
class OptionalHdrTreeItem : public PeTreeItem
{
protected:
	enum ViewLevel { DESC = 0, DETAILS = 1 };
	typedef enum ViewLevel level_t;

	level_t level;
	OptHdrWrapper::OptHdrFID role;

public:
	OptionalHdrTreeItem(PeHandler *peHndl, level_t level = DESC, OptHdrWrapper::OptHdrFID role = OptHdrWrapper::NONE, OptionalHdrTreeItem *parent = NULL);
	virtual ~OptionalHdrTreeItem() { }

	int columnCount() const;

	virtual QVariant font(int column) const;
	virtual QVariant data(int column) const;
	virtual QVariant foreground(int column) const;
	virtual QVariant background(int column) const;
	virtual QVariant toolTip(int column) const;
	virtual Qt::ItemFlags flags(int column) const;

/* PeViewItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual bool isChildOk(TreeItem* child) { OptionalHdrTreeItem *ptr = dynamic_cast<OptionalHdrTreeItem*>(child); return (child)? true : false;}
	bool setDataValue(int column, const QVariant &value);

	OptHdrWrapper& optHdr;

	enum COLS {
		COL_OFFSET = 0,
		COL_NAME,
		COL_VALUE,
		COL_VALUE2,
		COL_SPACE,
		MAX_COL
	};

private:
	QVariant dataValMeanings() const;
	
friend class OptionalHdrTreeModel;
};

//---

class DataDirTreeItem : public OptionalHdrTreeItem
{
public:
	DataDirTreeItem(PeHandler *peHndl, level_t level = DESC, int recordNum = -1, OptionalHdrTreeItem *parent = NULL);
	virtual ~DataDirTreeItem() { }

	virtual QVariant data(int column) const;
	virtual bool setDataValue(int column, const QVariant &value);

	virtual QVariant background(int column) const;
	virtual QVariant toolTip(int column) const;

	virtual QVariant edit(int column) const;
	virtual Qt::ItemFlags flags(int column) const;
	virtual bool containsRVA(QModelIndex index) const;

/* PeViewItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	int getFID(int column = 0) const { return recordNum; }
	int getSID(int column) const { return column - COL_VALUE; }

	DataDirWrapper *wrapper() const { return (this->myPeHndl != NULL) ? &this->myPeHndl->dataDirWrapper : NULL; }
	int recordNum;

friend class  OptionalHdrTreeModel;
};

//---

class OptHdrDllCharactTreeItem : public OptionalHdrTreeItem
{
public:
	OptHdrDllCharactTreeItem(PeHandler *peHndl, level_t level = DESC, DWORD characteristics = 0, OptionalHdrTreeItem *parent = NULL);
	virtual ~OptHdrDllCharactTreeItem() { }

	void init();
	virtual QVariant data(int column) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;

protected:
	DWORD characteristics;
};

//---

class OptionalHdrTreeModel : public PeWrapperModel
{
	Q_OBJECT

protected slots:
	void reload();

public:
	OptionalHdrTreeModel(PeHandler *peHndl, QObject *parent = 0);
	virtual ~OptionalHdrTreeModel() { }

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual bool containsValue(QModelIndex index) const;

	virtual int getFID(const QModelIndex &index) const;
	virtual int getSID(const QModelIndex &index) const;

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->optHdrWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	enum COLS {
		COL_OFFSET = 0,
		COL_NAME,
		COL_VALUE,
		COL_VALUE2,
		COL_SPACE,
		MAX_COL
	};

private:
	OptHdrDllCharactTreeItem* dllCharact;
};

```

`pe-bear/gui/pe_models/RelocsTreeModel.cpp`:

```cpp
#include "RelocsTreeModel.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

int RelocsTreeModel::columnCount(const QModelIndex &parent) const
{
	RelocDirWrapper* impWrap = dynamic_cast<RelocDirWrapper*>(wrapper());
	if (!impWrap) return 0;
	ExeNodeWrapper* entry = impWrap->getEntryAt(0);
	if (!entry) return 0;

	uint32_t cntr = entry->getFieldsCount();
	return cntr + ADDED_COLS_NUM;
}

QVariant RelocsTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET: return "Offset";
	}
	RelocDirWrapper* impWrap = dynamic_cast<RelocDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();
	int32_t fID = this->columnToFID(section);
	if (fID == RelocBlockWrapper::ENTRIES_PTR) {
		return "Entries Count";
	}
	return impWrap->getFieldName(0, fID);
}

ExeElementWrapper* RelocsTreeModel::wrapperAt(QModelIndex index) const
{
	RelocDirWrapper* wrap = dynamic_cast<RelocDirWrapper*>(wrapper());
	if (!wrap) return NULL;
	return wrap->getEntryAt(index.row()); //RelocBlockWrapper
}

QVariant RelocsTreeModel::data(const QModelIndex &index, int role) const
{
	RelocDirWrapper* impWrap = dynamic_cast<RelocDirWrapper*>(wrapper());
	if (!impWrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::FontRole) return offsetFont;
	if (role == Qt::ToolTipRole) return toolTip(index);

	RelocBlockWrapper* block =  dynamic_cast<RelocBlockWrapper*>(wrapperAt(index));
	if (!block) return QVariant();

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
	}
	int fID = getFID(index);
	if (fID == RelocBlockWrapper::ENTRIES_PTR) {
		return QString::number(block->getEntriesNum(), 16); 
	}
	bool isOk = false;
	uint64_t val = block->getNumValue(fID, &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

bool RelocsTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fID = getFID(index);

	if (!wrapper()) return false;
	RelocBlockWrapper* entry =  dynamic_cast<RelocBlockWrapper*>(wrapperAt(index));
	if (!entry) return false;

	QString text = value.toString();

	bool isModified = false;
	offset_t offset = 0;
	bufsize_t fieldSize = 0;

	bool isOk = false;
	ULONGLONG number = text.toLongLong(&isOk, 16);
	if (!isOk) return false;

	offset = entry->getFieldOffset(fID);
	fieldSize = entry->getFieldSize(fID);

	this->myPeHndl->backupModification(offset, fieldSize);
	isModified = entry->setNumValue(fID, index.column(), number);

	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}
//----------------------------------------------------------------------------
int RelocEntriesModel::rowCount(const QModelIndex &parent) const
{
	if (!wrapper()) return 0;
	RelocBlockWrapper *w = dynamic_cast<RelocBlockWrapper*>(wrapper());
	if (w == NULL) return 0;

	return w->getEntriesNum();
}

QVariant RelocEntriesModel::data(const QModelIndex &index, int role) const
{
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::ToolTipRole) return toolTip(index);

	int column = index.column();

	if (role == Qt::FontRole) {
		if (column != TYPE) return offsetFont;
		return QVariant();
	}
	
	int fId = this->getFID(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	RelocEntryWrapper* w = dynamic_cast<RelocEntryWrapper*>(wrapperAt(index));
	if (!w) return QVariant(); // NO WRAPPER!

	bool isOk = false;
	uint64_t val = w->getNumValue(RelocEntryWrapper::RELOC_ENTRY_VAL, &isOk);
	if (!isOk) return "UNK"; // NO VALUE

	int type = RelocEntryWrapper::getType(val);

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case TYPE: return RelocEntryWrapper::translateType(type);
		case DELTA: return QString::number(RelocEntryWrapper::getDelta(val), 16);
		case RELOC_RVA: 
		{
			if (type == 0) return QVariant(); //Skip padding
			int delta = RelocEntryWrapper::getDelta(val);
			return QString::number(w->deltaToRVA(delta), 16);
		}
	}
	return QString::number(val, 16);
}

QVariant RelocEntriesModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET : return "Offset";
		case VALUE : return "Value";
		case TYPE: return "Type";
		case DELTA: return "Offset from Page";
		case RELOC_RVA: return "Reloc RVA";
	}
	return QVariant();
}

ExeElementWrapper* RelocEntriesModel::wrapperAt(QModelIndex index) const
{
	RelocBlockWrapper *topWrapper = dynamic_cast<RelocBlockWrapper*>(this->wrapper());
	if (topWrapper == NULL) return NULL;

	return topWrapper->getEntryAt(this->getFID(index));
}

Executable::addr_type RelocEntriesModel::addrTypeAt(QModelIndex index) const
{
	if (index.column() == RELOC_RVA) return Executable::RVA;
	return WrapperTableModel::addrTypeAt(index);
}

```

`pe-bear/gui/pe_models/RelocsTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"

class RelocsTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	RelocsTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent) {}

	virtual int columnCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);

	virtual bool containsValue(QModelIndex index) const { return (getFID(index) < RelocBlockWrapper::ENTRIES_PTR); }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.column() - ADDED_COLS_NUM;  }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->relocDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	inline int32_t columnToFID(int column) const { return column - ADDED_COLS_NUM; }
	inline int32_t FIDtoColumn(int fId) const { return (fId + ADDED_COLS_NUM); }

	virtual bool isComplexValue(const QModelIndex &index) const { if (index.column() >= ADDED_COLS_NUM) return true; return false; }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET,
		ADDED_COLS_NUM
	};
friend class RelocsTreeView;
};


class RelocEntriesModel : public WrapperTableModel
{
	Q_OBJECT

public slots:
	void setParentId(size_t parentId) { this->parentId = parentId; reset(); }

public:
	RelocEntriesModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent), parentId(0) {}

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	
	virtual bool containsValue(QModelIndex index) const { return index.column() == VALUE; }
	virtual ExeElementWrapper* wrapper() const { return myPeHndl->relocDirWrapper.getEntryAt(parentId);}
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;//

	Executable::addr_type addrTypeAt(QModelIndex index) const;

protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column();  }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET = 0,
		VALUE,
		TYPE,
		DELTA,
		RELOC_RVA,
		MAX_COL
	};

	size_t parentId;
};

```

`pe-bear/gui/pe_models/ResourcesTreeModel.cpp`:

```cpp
#include "ResourcesTreeModel.h"
#include "../../DateDisplay.h"

//-----------------------------------------------------------------------------

#define NOT_FILLED  "-"

Executable::addr_type ResourcesTreeModel::addrTypeAt(QModelIndex index) const
{
	int col = index.column();
	ExeElementWrapper *exeW = wrapper();

	if (exeW 
		&& index.row() >= getWrapperFieldsCount()
		&& col  >= MEANING && col  <= MEANING2) 
	{
		return Executable::RAW;
	}
	return  WrapperInterface::addrTypeAt(index);
}

int ResourcesTreeModel::rowCount(const QModelIndex &parent) const
{
	ExeNodeWrapper *w = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (w == NULL) return 0;

	size_t num = getWrapperFieldsCount() + w->getEntriesCount();
	return num;
}

QVariant ResourcesTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
		case VALUE2: return "Value";
		case MEANING: return "Meaning";
		case MEANING2: return "Meaning";
		case RES_NAME: return "Type";
		case ENTRIES_NUM: return "Entries Count";
	}
	return QVariant();
}

ExeElementWrapper* ResourcesTreeModel::wrapperAt(QModelIndex index) const
{
	int row = index.row();
	ExeElementWrapper *exeW = wrapper();
	if (!exeW) return NULL;

	size_t fieldsCount = getWrapperFieldsCount();
	if (row < fieldsCount) {
		return exeW;
	}
	ExeNodeWrapper *wrap = dynamic_cast<ExeNodeWrapper*>(exeW);
	int entryId = row - fieldsCount;
	return wrap->getEntryAt(entryId);
}

int ResourcesTreeModel::getFID(const QModelIndex &index) const
{
	int row = index.row();
	ExeNodeWrapper *exeW = dynamic_cast<ExeNodeWrapper*>(wrapperAt(index));
	if (exeW == NULL ||exeW == wrapper()) return row; // main or empty wrapper

	return index.column() - VALUE;
}

QVariant ResourcesTreeModel::subdirsData(const QModelIndex &index, int role) const
{

	ResourceEntryWrapper *subW = dynamic_cast<ResourceEntryWrapper*> (wrapperAt(index));
	if (subW == NULL) return QVariant();

	const int row = index.row();
	const int column = index.column();
	const int fId = getFID(index);

	switch (column) {
		case OFFSET:
		{
			return QString::number(getFieldOffset(index), 16);
		}
		case NAME: 
		{
			QString name = subW->getFieldName(ResourceEntryWrapper::NAME_ID_ADDR);
			name += "_" + QString::number(subW->getEntryId());
			return name;
		}
		case VALUE: 
		case VALUE2: 
		{
			bool isOk = false;
			uint64_t val = subW->getNumValue(fId, &isOk);
			if (isOk) {
				return QString::number(val, 16);
			}
			return QVariant();
		}
		case MEANING: 
		{
			uint64_t val = subW->getNameOffset();
			if (val != INVALID_ADDR) {
				return QString::number(val, 16);
			}
			return QVariant();
		}
		case MEANING2:
		{
			uint64_t val = subW->getChildAddress();
			if (val != INVALID_ADDR) return QString::number(val, 16);
			return "";
		}
		case RES_NAME:
		{
			QString name;
			IMAGE_RESOURCE_DIRECTORY_STRING* ptr = subW->getNameStr();
				if (ptr == NULL) {
				bool isOk = false;
				uint64_t val = subW->getNumValue(ResourceEntryWrapper::NAME_ID_ADDR, &isOk);
				return subW->translateType(val);
			}
			const ushort *str = (ushort*)ptr->NameString;
			name = QString::fromUtf16(str, ptr->Length);
			return name;
		}
		case ENTRIES_NUM: 
		{
			ResourcesAlbum *album = subW->getAlbumPtr();
			if (album == NULL) return QVariant();
			long topId = subW->getTopEntryID();
			int entries = album->entriesCountAt(topId);
			return QString::number(entries);
		}
	}
	return QVariant();
}

QVariant ResourcesTreeModel::data(const QModelIndex &index, int role) const
{
	ExeNodeWrapper *wrap = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (!wrap) return QVariant();

	const int row = index.row();
	const int column = index.column();
	const int fId = getFID(index);
	
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (column == MARKERS 
		&& fId >= this->getWrapperFieldsCount())
	{
		if (role == Qt::DecorationRole) return ViewSettings::getScaledPixmap(":/icons/List.ico");
		if (role == Qt::ToolTipRole) return "List";
	}
	
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	if (row >= getWrapperFieldsCount()) {
		return subdirsData(index, role);
	}

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return wrap->getFieldName(fId);
		case VALUE: return dataValue(index);
		case MEANING: 
		{
			if (row == ResourceDirWrapper::TIMESTAMP) {
				bool isOk = false;
				int val = wrap->getNumValue(fId, &isOk);
				return (isOk) ? getDateString(val) : QVariant();
			}
		}
	}
	return QVariant();
}

//----------------------------------------------------------------------------


QVariant ResourceLeafModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
	}
	return QVariant();
}

ExeElementWrapper* ResourceLeafModel::wrapper() const 
{
	return &myPeHndl->resourcesDirWrapper;
}

ExeElementWrapper* ResourceLeafModel::wrapperAt(QModelIndex index) const
{
	if (this->parentId >= myPeHndl->resourcesAlbum.dirsCount()) return NULL;
	std::vector<ResourceLeafWrapper*> *vec = myPeHndl->resourcesAlbum.entriesAt(parentId);
	if (!vec) return NULL;

	if (vec->size() <= leafId) return NULL;
	return vec->at(leafId);
}

QVariant ResourceLeafModel::data(const QModelIndex &index, int role) const
{
	ResourceLeafWrapper* wrap =  dynamic_cast<ResourceLeafWrapper*>(wrapperAt(index));
	if (!wrap) return QVariant();

	int row = index.row();
	int column = index.column();

	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) return offsetFont;
	}
	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	
	int sID = getSID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME : return (wrap->getFieldName(sID));
	}
	
	bool isOk = false;
	uint64_t val = wrap->getNumValue(sID, &isOk);
	if (!isOk) return "UNK"; /* other type? */

	return QString::number(val, 16);
}

Executable::addr_type ResourceLeafModel::addrTypeAt(QModelIndex index) const
{
	Executable::addr_type aType = Executable::NOT_ADDR;

	if (containsOffset(index)) {
		aType = offsetAddrType();
	} else {
		if (!containsValue(index)) return Executable::NOT_ADDR;

		ExeElementWrapper *wrapper = this->wrapperAt(index);
		if (wrapper == NULL) return Executable::NOT_ADDR;

		aType = wrapper->containsAddrType(getSID(index));
	}
	return aType;
}

offset_t ResourceLeafModel::getFieldOffset(QModelIndex index) const
{ 
	if (!index.isValid()) return 0;
	int fieldId = getSID(index);
	return wrapperAt(index) ? wrapperAt(index)->getFieldOffset(fieldId) : 0;
}

bufsize_t ResourceLeafModel::getFieldSize(QModelIndex index) const 
{
	if (!index.isValid()) return 0;
	int fieldId = getSID(index);
	return wrapperAt(index) ? wrapperAt(index)->getFieldSize(fieldId) : 0;
}

```

`pe-bear/gui/pe_models/ResourcesTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class ResourcesTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	ResourcesTreeModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent)
	{
		this->connectSignals();
	}
	
	virtual Executable::addr_type addrTypeAt(QModelIndex index) const;
	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }
	virtual int rowCount(const QModelIndex &parent) const;

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE || index.column()  == VALUE2); }

protected:
	QVariant subdirsData(const QModelIndex &index, int role) const;

	size_t getWrapperFieldsCount() const
	{
		ExeElementWrapper *exeW = wrapper();
		if (!exeW) return 0;

		const size_t fieldsCount = exeW->getFieldsCount();
		return fieldsCount;
	}
	
	virtual int getFID(const QModelIndex &index) const;
	virtual int getSID(const QModelIndex &index) const { return index.column() - VALUE; }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->resourcesDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const;

	enum cols {
		OFFSET,
		NAME,
		VALUE,
		VALUE2,
		MEANING,
		MEANING2,
		RES_NAME,
		ENTRIES_NUM,
		MARKERS,
		COLS_NUM
	};
};

//------------------------------------

class ResourceLeafModel : public WrapperTableModel
{
	Q_OBJECT

public slots:
	void setParentId(size_t parentId) { this->parentId = parentId; reset(); emit modelUpdated(); }
	void setLeafId(uint32_t leafId) { this->leafId = leafId; reset(); emit modelUpdated(); }

public:
	ResourceLeafModel(PeHandler *peHndl, QObject *parent = 0) 
		: WrapperTableModel(peHndl, parent), parentId(0), leafId(0)
	{
		this->connectSignals();
	}

	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }
	virtual int rowCount(const QModelIndex &parent) const { return ResourceLeafWrapper::FIELD_COUNTER; }

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;
	
	long getParentId() { return parentId; }
	long getLeafId() { return leafId; }

	Executable::addr_type addrTypeAt(QModelIndex index) const;
	offset_t getFieldOffset(QModelIndex index) const;
	bufsize_t getFieldSize(QModelIndex index) const;
	
protected:

	virtual int getFID(const QModelIndex &index) const { return leafId; }
	virtual int getSID(const QModelIndex &index) const { return index.row(); }

	virtual ExeElementWrapper* wrapper() const;// { return &myPeHndl->resourcesDirWrapper; }
	ExeElementWrapper* wrapperAt(QModelIndex index) const;
	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE); }
	
	enum cols {
		OFFSET,
		NAME,
		VALUE,
		COLS_NUM
	};

	long parentId;
	long leafId;
};

```

`pe-bear/gui/pe_models/RichHdrTreeModel.cpp`:

```cpp
#include "RichHdrTreeModel.h"

#include "../../DateDisplay.h"

//#define MAX_COL 3
///------------------------
enum COLS {
	COL_OFFSET = 0,
	COL_NAME,
	COL_VALUE,
	COL_CLEAN_VALUE,
	COL_MEANING,
	COL_CID_PROD,
	COL_CID_BUILD,
	COL_CID_COUNT,
	COL_CID_VSVER,
	MAX_COL
};

RichHdrTreeItem::RichHdrTreeItem(PeHandler *peHndl, RichHdrWrapper::FieldID role, RichHdrTreeItem *parent)
	: PeTreeItem(peHndl, role, FIELD_NONE, parent),
	approvedColor(APPROVED_COLOR)
{
	approvedColor.setAlpha(160);
	this->role = role;
	if (peHndl == NULL) {
		this->role = RichHdrWrapper::NONE;
		return;
	}
}

int RichHdrTreeItem::columnCount() const
{
	return MAX_COL;
}

QVariant RichHdrTreeItem::background(int column) const
{
	RichHdrWrapper *richHdr = this->getRichHdr();
	if (!richHdr) return QVariant();
	
	//mark mismatching checksum red
	const size_t cnt = richHdr->compIdCount() - 1;
	if (role == (RichHdrWrapper::CHECKSUM + (cnt))) {
		if (column == COL_VALUE) {
			bool isOk = false;
			DWORD val = richHdr->getNumValue(role, &isOk);
			if (richHdr->calcChecksum() != val) return QColor(ERR_COLOR);
		} else if (column == COL_MEANING) {
			return approvedColor;
		}
	}
	return QVariant();
}

QVariant RichHdrTreeItem::foreground(int column) const
{
	if (column == COL_OFFSET) return this->offsetFontColor;
	return QVariant();
}

Qt::ItemFlags RichHdrTreeItem::flags(int column) const
{
	Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (column != COL_VALUE) return fl;
	return fl| Qt::ItemIsEditable;
}

QVariant RichHdrTreeItem::data(int column) const
{
	RichHdrWrapper *richHdr = getRichHdr();
	if (!richHdr) return QVariant();

	switch (column) {
		case COL_OFFSET: return QString::number(getContentOffset(),16).toUpper();
		case COL_NAME: return (richHdr->getFieldName(role));
		case COL_VALUE:
		{
			bool isOk = false;
			uint64_t val = richHdr->getNumValue(role, &isOk);
			if (!isOk) return QVariant();
			return QString::number(val, 16);
		}
		case COL_CLEAN_VALUE:
		{
			const pe::RICH_COMP_ID compId = richHdr->getCompId(role);
			bool isOk = false;
			uint64_t val = richHdr->getNumValue(role, &isOk);
			if (!isOk) return QVariant();
			const size_t cnt = richHdr->compIdCount() - 1;
			uint64_t xor_val = richHdr->getNumValue(RichHdrWrapper::CHECKSUM + (cnt), &isOk);
			if (!isOk) return QVariant();
			if (role >= RichHdrWrapper::COMP_ID_1 && role <= RichHdrWrapper::COMP_ID_1 + cnt) {
				xor_val = xor_val << 32 | xor_val;
			} else if (role > RichHdrWrapper::COMP_ID_1 + cnt) {
				return QVariant();
			}
			return QString::number(val ^ xor_val, 16);
		}
		case COL_MEANING:
		{
			return richHdr->translateFieldContent(role);
		}
		case COL_CID_PROD:
		{
			const pe::RICH_COMP_ID compId = richHdr->getCompId(role);
			if (compId.count > 0) {
				return RichHdr_translateProdId(compId.prodId);
			}
		}
		case COL_CID_BUILD:
		{
			const pe::RICH_COMP_ID compId = richHdr->getCompId(role);
			if (compId.count > 0) {
				return  QString::number(compId.CV);
			}
		}
		case COL_CID_COUNT:
		{
			const pe::RICH_COMP_ID compId = richHdr->getCompId(role);
			if (compId.count > 0) {
				return QString::number(compId.count);
			}
		}
		case COL_CID_VSVER:
		{
			const pe::RICH_COMP_ID compId = richHdr->getCompId(role);
			if (compId.count > 0) {
				return RichHdr_ProdIdToVSversion(compId.prodId);
			}
		}
	}
	return QVariant();
}

bool RichHdrTreeItem::setDataValue(int column, const QVariant &value)
{
	RichHdrWrapper *richHdr = getRichHdr();
	if (!richHdr) return false;
	
	if (column != COL_VALUE) return false;

	QString text = value.toString();
	bool isOk = false;
	ULONGLONG number = text.toULongLong(&isOk, 16);
	if (!isOk) return false;

	isOk = richHdr->setNumValue(role, number);
	return isOk;
}

offset_t RichHdrTreeItem::getContentOffset() const
{
	RichHdrWrapper *richHdr = getRichHdr();
	if (!richHdr) return 0;
	return richHdr->getFieldOffset(role);
}

bufsize_t RichHdrTreeItem::getContentSize() const
{
	RichHdrWrapper *richHdr = getRichHdr();
	if (!richHdr) return 0;
	return richHdr->getFieldSize(role);
}

//-----------------------------------------------------------------------------

RichHdrTreeModel::RichHdrTreeModel(PeHandler* peHndl, QObject *parent)
	: WrapperTableModel(peHndl, parent)
{
	if (!peHndl) return;
	connect(peHndl, SIGNAL(modified()), this, SLOT(onNeedReset()));
}

void RichHdrTreeModel::onNeedReset()
{
	if (myPeHndl) {
		this->myPeHndl->richHdrWrapper.wrap();
	}
	reset();
	emit modelUpdated();
}

bool RichHdrTreeModel::containsValue(QModelIndex index) const
{
	return (index.column() == COL_VALUE);
}

int RichHdrTreeModel::columnCount(const QModelIndex &parent) const
{
	RichHdrWrapper* entry =  dynamic_cast<RichHdrWrapper*>(wrapper());
	if (!entry) return 0;
	
	return MAX_COL;
}

QVariant RichHdrTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) return QVariant();
	
	RichHdrTreeItem item(myPeHndl, RichHdrWrapper::FieldID(index.row()));
	
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::ToolTipRole) {
		RichHdrWrapper *richHdr = item.getRichHdr();
		if (!richHdr) return QVariant();
		size_t cnt = richHdr->compIdCount() - 1;
		if (index.row() == (RichHdrWrapper::CHECKSUM + cnt)) {
			if (index.column() == COL_MEANING) {
				return "Calculated checksum";
			}
		}
		return this->toolTip(index);
	}

	if (role == Qt::BackgroundColorRole)
		return item.background(index.column());

	if ( role == Qt::SizeHintRole) {
		if (index.column() == COL_OFFSET) return QSize(50, 16);
		if (index.column() == COL_NAME) return QSize(150, 16);
		return QVariant(); //get default
	}

	if (role == Qt::DisplayRole || role == Qt::EditRole)
		return item.data(index.column());

	return QVariant();
}

bool RichHdrTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid())
		return false;

	RichHdrTreeItem item(myPeHndl, RichHdrWrapper::FieldID(index.row()));
	return item.setData(index.column(), value, item.role);
}


QVariant RichHdrTreeModel::headerData(int section, Qt::Orientation /* orientation */, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case COL_OFFSET : return "Offset";
		case COL_NAME : return "Name";
		case COL_VALUE : return "Value";
		case COL_CLEAN_VALUE: return "Unmasked Value";
		case COL_MEANING : return "Meaning";
		case COL_CID_PROD : return "ProductId";
		case COL_CID_BUILD : return "BuildId";
		case COL_CID_COUNT : return "Count";
		case COL_CID_VSVER: return "VS version";
	}
	return QVariant();
}

Qt::ItemFlags RichHdrTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;
		
	RichHdrTreeItem item(myPeHndl, RichHdrWrapper::FieldID(index.row()));
	return item.flags(index.column());
}

offset_t RichHdrTreeModel::getContentOffset() const
{
	if (!m_PE) return 0;
	return m_PE->peNtHdrOffset();
}

bufsize_t RichHdrTreeModel::getContentSize() const
{
	if (!m_PE) return 0;
	return (DWORD) m_PE->peNtHeadersSize();
}

```

`pe-bear/gui/pe_models/RichHdrTreeModel.h`:

```h
#pragma once
#include <QtGui>

#include <map>
#include <set>
#include "../../gui_base/PeTreeView.h"
#include "../../gui_base/WrapperTableModel.h"
#include "../../gui/PeTreeModel.h"

class RichHdrTreeItem : public PeTreeItem
{
	Q_OBJECT

protected:
	RichHdrWrapper::FieldID role;

public:
	RichHdrTreeItem(PeHandler *peHndl, RichHdrWrapper::FieldID role = RichHdrWrapper::NONE, RichHdrTreeItem *parent = NULL);
	int columnCount() const;

	virtual Qt::ItemFlags flags(int column) const;
	virtual QVariant data(int column) const;

	bool setDataValue(int column, const QVariant &value);
	virtual QVariant foreground(int column) const;
	virtual QVariant background(int column) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual bool isChildOk(TreeItem* child) { RichHdrTreeItem *ptr = dynamic_cast<RichHdrTreeItem*>(child); return (child)? true : false; }

	RichHdrWrapper* getRichHdr() const
	{
		if (!myPeHndl) return NULL;
		return &myPeHndl->richHdrWrapper;
	}

	QColor approvedColor;

friend class RichHdrTreeModel;
};


class RichHdrTreeModel : public WrapperTableModel
{
	Q_OBJECT

protected slots:
	void onNeedReset();

public:
	RichHdrTreeModel(PeHandler *peHndl, QObject *parent = 0);
	virtual ~RichHdrTreeModel() { }
	
	virtual int columnCount(const QModelIndex &parent) const;

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual bool containsValue(QModelIndex index) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->richHdrWrapper; }
};

```

`pe-bear/gui/pe_models/SecHdrsTreeModel.cpp`:

```cpp
#include "SecHdrsTreeModel.h"

#include <iostream>

enum SecFieldId {
	SEC_NAME = 0,
	SEC_RPTR,
	SEC_RSIZE, 
	SEC_VPTR, 
	SEC_VSIZE, 
	SEC_CHARACT, 
	SEC_RELOC_PTR, 
	SEC_RELOC_NUM,
	SEC_LINENUM_NUM,
	SEC_FIELD_COUNTER
};


SecTreeItem::SecTreeItem(PeHandler* peHndl, int secIndx, int level, SecTreeItem *parent)
    : PeTreeItem(peHndl, secIndx, FIELD_NONE, parent)
{
	this->secIndx = secIndx;
	this->level = level;

	if (peHndl != NULL && secIndx != (-1) && level == 0) {
		//details about section:
		SecTreeItem* item = new SecTreeItem(peHndl, secIndx, 1, this);
		this->appendChild(item);
	}
}

void SecTreeItem::updateSectionsList()
{
	size_t oldNum = this->m_childItems.size();
	if (oldNum == this->m_PE->getSectionsCount()) {
		return;
	}
	int diff = 0;
	bool add = true;

	if (oldNum < this->m_PE->getSectionsCount()) {
		add = true;
		diff = this->m_PE->getSectionsCount() - oldNum;
	} else {
		add = false;
		diff = oldNum - this->m_PE->getSectionsCount();
	}

	for (int i = 0; i < diff; i++) {
		if (add) {
			SecTreeItem* sec = new SecTreeItem(this->myPeHndl, oldNum + i, 0, this);
			this->appendChild(sec);
		} else {
			TreeItem *child = this->child((oldNum - 1)- i);
			this->detachChild(child);
			delete child;
		}
	}
}

SectionHdrWrapper* SecTreeItem::getMySection() const
{
	if (!m_PE) return NULL;
	return m_PE->getSecHdr(secIndx);
}

int SecTreeItem::columnCount() const
{
	return SEC_FIELD_COUNTER;
}

QVariant SecTreeItem::background(int column) const
{
	int fieldIndx = column;
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return QVariant();

	QColor warningCol = Qt::yellow;
	QColor changeCol = Qt::cyan;

	warningCol.setAlpha(200);
	changeCol.setAlpha(50);

	if (fieldIndx == SEC_VSIZE || fieldIndx == SEC_VPTR) {
		bufsize_t mappedVSize = sec->getContentSize(Executable::RVA, true);
		bufsize_t secPtr = sec->getContentOffset(Executable::RVA, false);
		bufsize_t secEnd = sec->getContentEndOffset(Executable::RVA, true);

		if (fieldIndx == SEC_VSIZE || level == 1) {
			if (secEnd > m_PE->getImageSize()) return this->errColor;
		}
		if (fieldIndx == SEC_VSIZE) {
			if (sec->getContentSize(Executable::RVA, false) != mappedVSize) return changeCol;
			if (level == 0) return QVariant(); //Valid!
		}

		if (fieldIndx == SEC_VPTR) {
			if (secPtr > m_PE->getImageSize()) return this->errColor;
		}
		if (level == 0) return QVariant(); //Valid!
	}
	//----
	if (fieldIndx == SEC_RSIZE || fieldIndx == SEC_RPTR) {
		bufsize_t rSize = sec->getContentSize(Executable::RAW, false);
		bufsize_t secPtr = sec->getContentOffset(Executable::RAW, false);
		bufsize_t secEnd = sec->getContentEndOffset(Executable::RAW, false);

		if (fieldIndx == SEC_RSIZE || level == 1) {
			if (secEnd > m_PE->getRawSize()) return this->errColor;
		}
		if (fieldIndx == SEC_RSIZE) {
			if (sec->getContentSize(Executable::RAW, true) != rSize) return changeCol;
			if (level == 0) return QVariant(); //Valid!
		}

		if (fieldIndx == SEC_RPTR) {
			if (secPtr > m_PE->getRawSize()) this->errColor;
		}
		if (level == 0) return QVariant(); //Valid!
	}
	//----
	if (level == 1) {
		QColor flagsColorT = addrColors.flagsColor();
		flagsColorT.setAlpha(addrColors.flagsAlpha());
		return flagsColorT;
	}
	return QVariant();
}

QVariant SecTreeItem::foreground(int column) const
{
	int fieldIndx = column;
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return QVariant();

	size_t roundedSize = sec->getContentSize(Executable::RAW, true);
	if (roundedSize == 0) {
		switch (fieldIndx) {
			case SEC_RPTR : case SEC_RSIZE : case SEC_VPTR : case SEC_VSIZE : 
			{
				return QColor("gray");
			}
		}
	}
	return QVariant();
}

QStringList SecTreeItem::fetchSecHdrCharact(DWORD characteristics)
{
	std::vector<DWORD> secHdrCharact = SectionHdrWrapper::splitCharacteristics(characteristics);
	QStringList nameSet;
	std::vector<DWORD>::iterator iter;
	for (iter = secHdrCharact.begin(); iter != secHdrCharact.end(); ++iter) {
		DWORD currC = *iter;
		if (characteristics & currC) {
			QString info = QString::number(currC, 16).rightJustified(8, '0') + " : " + SectionHdrWrapper::translateCharacteristics(currC);
			nameSet << info;
		}
	}
	return nameSet;
}

QVariant SecTreeItem::toolTip(int column) const
{
	int fieldIndx = column;
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return QVariant();

	if (level == 0) {
		switch (fieldIndx) {

			case SEC_NAME :
			{
				int indx = m_PE->getSecIndex(sec);
				return "index:\t" + QString::number(indx)+"\n"+ sec->mappedName;
			}
			case SEC_CHARACT :
			{
				QStringList names = SecTreeItem::fetchSecHdrCharact(sec->getCharacteristics());
				return names.join("\n");;
			}
			case SEC_RSIZE:
			{
				bufsize_t rounded = sec->getContentSize(Executable::RAW, true);
				if (sec->getContentSize(Executable::RAW, false) != rounded) return "mapped:\n" + QString::number(rounded, 16);
				break;
			}
			case SEC_VSIZE:
			{
				bufsize_t rounded = sec->getContentSize(Executable::RVA, true);
				if (sec->getContentSize(Executable::RVA, false) != rounded) return "mapped:\n" + QString::number(rounded, 16);
				break;
			}
		}
	}
	return QVariant();
}

QVariant SecTreeItem::edit(int column) const
{
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return QVariant();

	return data(column);
}

QVariant SecTreeItem::data(int column) const
{
	int fieldIndx = column;
	SectionHdrWrapper *sec = getMySection();
	if (!sec || !m_PE) return QVariant();

	if (level == 0) {
		bool isOk = false;
		DWORD val = 0;

		switch (fieldIndx) {
			case SEC_NAME :
				return QString(sec->getName());
			case SEC_VSIZE :
				return QString::number(sec->getContentSize(Executable::RVA, false), 16).toUpper();
			case SEC_VPTR :
				val = sec->getNumValue(SectionHdrWrapper::VPTR, &isOk);
				break;
			case SEC_RSIZE :
				return QString::number(sec->getContentSize(Executable::RAW, false), 16).toUpper();
			case SEC_RPTR : 
				val = sec->getNumValue(SectionHdrWrapper::RPTR, &isOk);
				break;
			case SEC_CHARACT : 
				val = sec->getNumValue(SectionHdrWrapper::CHARACT, &isOk);
				break;
			case SEC_RELOC_PTR :
				val = sec->getNumValue(SectionHdrWrapper::RELOC_PTR, &isOk);
				break;
			case SEC_RELOC_NUM :
				val = sec->getNumValue(SectionHdrWrapper::RELOC_NUM, &isOk);
				break;
			case SEC_LINENUM_NUM :
				val = sec->getNumValue(SectionHdrWrapper::LINENUM_NUM, &isOk);
				break;
		}
		return isOk ? QString::number(val, 16).toUpper() : QVariant();
	} 
	if (level == 1) {
		switch (fieldIndx) {
			case SEC_NAME : 
				if (sec->mappedName != sec->getName())
					return sec->mappedName;
				else return ">";
			case SEC_VSIZE :
				if (sec->getContentSize(Executable::RVA, false) != sec->getContentSize(Executable::RVA, true))
					return "mapped: " + QString::number(sec->getContentSize(Executable::RVA, true), 16).toUpper();
				return "^";
				break;
			case SEC_VPTR :
				return QString::number(sec->getVirtualPtr() + sec->getContentSize(Executable::RVA, true), 16).toUpper();
			case SEC_RSIZE :
				if (sec->getContentSize(Executable::RAW, false) != sec->getContentSize(Executable::RAW, true))
					return "mapped: " + QString::number(sec->getContentSize(Executable::RAW, true), 16).toUpper();
				return "^";
				break;
			case SEC_RPTR : 
				return QString::number(sec->getRawPtr() + sec->getContentSize(Executable::RAW, true), 16).toUpper();
			case SEC_CHARACT : 
			{
				const QString rights = SectionHdrWrapper::getSecHdrAccessRightsDesc(sec->getCharacteristics());
				return rights;
			}
		}
	} 
	return QVariant();
}

bool SecTreeItem::setDataValue(int column, const QVariant &value)
{
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return false;

	QString text = value.toString();

	bool isConv = false;
	ulong num = text.toULong(&isConv, 16);
	if (column != SEC_NAME && !isConv) {
		return false;
	}
	switch (column) {
		case SEC_NAME:
			{
				char* name = (char*)sec->getFieldPtr(SectionHdrWrapper::NAME);
				if (!name) return false;
				if (m_PE->setTextValue(name, text.toStdString().c_str(), SectionHdrWrapper::SECNAME_LEN)) {
					sec->reloadName();
					return true;
				}
				break;
			}
		case SEC_VPTR:
			if (sec->setNumValue(SectionHdrWrapper::VPTR, num)) return true;
			break;
		case SEC_RPTR:
			if (sec->setNumValue(SectionHdrWrapper::RPTR, num)) return true;
			break;
		case SEC_VSIZE :
			if (sec->setNumValue(SectionHdrWrapper::VSIZE, num)) return true;
			break;
		case SEC_RSIZE :
			if (sec->setNumValue(SectionHdrWrapper::RSIZE, num)) return true;
			break;
		case SEC_CHARACT:
			if (sec->setNumValue(SectionHdrWrapper::CHARACT, num)) return true;
			break;
		case SEC_RELOC_PTR :
			if (sec->setNumValue(SectionHdrWrapper::RELOC_PTR, num)) return true;
			break;
		case SEC_RELOC_NUM :
			if (sec->setNumValue(SectionHdrWrapper::RELOC_NUM, num)) return true;
			break;
		case SEC_LINENUM_NUM :
			if (sec->setNumValue(SectionHdrWrapper::LINENUM_NUM, num)) return true;
			break;
	}
	return false;
}

Qt::ItemFlags SecTreeItem::flags(int column) const
{
	if (level == 0)
		return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

offset_t SecTreeItem::getContentOffset() const
{
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return 0;

	const offset_t hdrsOffset = this->m_PE->secHdrsOffset();
	const offset_t hdrsOffsetEnd = this->m_PE->secHdrsEndOffset();
	if (hdrsOffset == INVALID_ADDR || hdrsOffsetEnd == INVALID_ADDR) {
		return 0;
	}

	const bufsize_t SEC_HDRS_SIZE = sizeof(IMAGE_SECTION_HEADER);
	offset_t secOffset = hdrsOffset + (this->secIndx * SEC_HDRS_SIZE);
	return secOffset;
}

bufsize_t SecTreeItem::getContentSize() const
{
	SectionHdrWrapper *sec = getMySection();
	if (!sec) return 0;
	const size_t SEC_HDRS_SIZE = sizeof(IMAGE_SECTION_HEADER);
	return SEC_HDRS_SIZE;
}

//-----------------------------------------------------------------------------
SecHdrsTreeModel::SecHdrsTreeModel(PeHandler* peHndl, QObject *parent)
	: PeTreeModel(peHndl, parent)
{
	if (!peHndl) {
		std::cerr << "PE Handler is not set!\n";
		return;
	}
	if (!m_PE) {
		std::cerr << "PE is not set!\n";
		return;
	}
	rootItem = new SecTreeItem(peHndl);
	size_t secNum = m_PE->getSectionsCount();
	for (int i = 0; i < secNum; i++) {
		rootItem->appendChild(new SecTreeItem(peHndl, i));
	}
	connect(peHndl, SIGNAL(secHeadersModified()), this, SLOT(onSectionNumChanged()));
}

QVariant SecHdrsTreeModel::data(const QModelIndex &index, int role) const
{
	if (!index.isValid()) return QVariant();

	int row = index.row();
	int column = index.column();
	TreeItem* it = static_cast<TreeItem*>(index.internalPointer());
	SecTreeItem* item = dynamic_cast<SecTreeItem*>(it);
	if (!item) {
		return QVariant();
	}
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	//if (role == Qt::ToolTipRole) return toolTip(index);

	switch (role) {
		case Qt::BackgroundColorRole :
			return item->background(index.column());
		case Qt::ForegroundRole:
			return item->foreground(index.column());
		case Qt::SizeHintRole :
		{
			return QVariant(); //get default
		}
		case Qt::DisplayRole :
			return item->data(index.column());
		case Qt::EditRole :
			return item->edit(index.column());
		case Qt::ToolTipRole : // TODO
		{
			QVariant tip = item->toolTip(index.column());
			if (tip.isNull()) tip = toolTip(index);
			if (tip.isNull()) tip = "";
			return tip;
		}
	}
	return QVariant();
}

bool SecHdrsTreeModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid())
		return false;

	TreeItem* it = static_cast<TreeItem*>(index.internalPointer());
	SecTreeItem* item = dynamic_cast<SecTreeItem*>(it);
	if (!item) {
		return false;
	}
	bool isMod = item->setData(index.column(), value, role);
	return isMod;
}

QVariant SecHdrsTreeModel::headerData(int section, Qt::Orientation /* orientation */, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();

	if (section >= SEC_FIELD_COUNTER) return QVariant();
	switch (section)
	{
		case SEC_NAME: return "Name"; 
		case SEC_VSIZE: return "Virtual Size";
		case SEC_VPTR: return "Virtual Addr.";
		case SEC_RSIZE: return "Raw size";
		case SEC_RPTR: return "Raw Addr.";
		case SEC_CHARACT: return "Characteristics";
		case SEC_RELOC_PTR: return "Ptr to Reloc.";
		case SEC_RELOC_NUM: return "Num. of Reloc.";
		case SEC_LINENUM_NUM: return "Num. of Linenum.";
	}
	return QVariant();
}

Qt::ItemFlags SecHdrsTreeModel::flags(const QModelIndex &index) const
{
	if (!index.isValid())
		return Qt::NoItemFlags;
	
	SecTreeItem *item = static_cast<SecTreeItem*>(index.internalPointer());
	if (!item)
		return Qt::NoItemFlags;
	
	return item->flags(index.column());
}

Executable::addr_type SecHdrsTreeModel::addrTypeAt(QModelIndex index) const
{
	if (!index.isValid()) return Executable::NOT_ADDR;

	int col = index.column();
	if (col == SEC_RPTR) return Executable::RAW;
	if (col == SEC_VPTR) return Executable::RVA;

	return Executable::NOT_ADDR;
}

offset_t SecHdrsTreeModel::getContentOffset() const
{
	if (!m_PE) return 0;
	return m_PE->secHdrsOffset();
}

bufsize_t SecHdrsTreeModel::getContentSize() const
{
	if (!m_PE) return 0;
	return DWORD(m_PE->secHdrsEndOffset() - m_PE->secHdrsOffset());
}

void SecHdrsTreeModel::onSectionNumChanged()
{
	SecTreeItem* myRootItem = dynamic_cast<SecTreeItem*>(rootItem);
	if (!myRootItem) {
		return;
	}
	beginResetModel();
	myRootItem->updateSectionsList();
	endResetModel();
}

```

`pe-bear/gui/pe_models/SecHdrsTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/PeTreeView.h"
#include "../TreeModel.h"
#include "../PeTreeModel.h"

class SecHdrsTreeModel;
class SecTreeItem : public PeTreeItem
{
	Q_OBJECT

public:
	static QStringList fetchSecHdrCharact(DWORD characteristics);

//---
	SecTreeItem(PeHandler* peHndl, int secIndx = (-1), int level = 0, SecTreeItem *parent = NULL);

	int columnCount() const;

	QVariant foreground(int column) const;
	QVariant background(int column) const;
	QVariant toolTip(int column) const;

	QVariant edit(int column) const;
	Qt::ItemFlags flags(int column) const;
	QVariant data(int column) const;

public slots:
/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;

protected:
	void updateSectionsList();
	virtual bool isChildOk(TreeItem* child) { return (dynamic_cast<SecTreeItem*>(child) != 0); }
	virtual bool setDataValue(int column, const QVariant &value);

	inline SectionHdrWrapper* getMySection() const;

private:
	int secIndx;
	int level;

friend class SecHdrsTreeModel;
};


class SecHdrsTreeModel : public PeTreeModel
{
	Q_OBJECT

signals:
	void sectionHdrsModified(PEFile* m_PE);
	
public slots:
	void onSectionNumChanged();

public:
	SecHdrsTreeModel(PeHandler* peHndl, QObject *parent = 0);
	~SecHdrsTreeModel() { }

	virtual QVariant data(const QModelIndex &index, int role) const override;
	bool setData(const QModelIndex &index, const QVariant &value, int role);
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual Executable::addr_type addrTypeAt(QModelIndex index) const;

/* PEGuiItem interface */
	virtual offset_t getContentOffset() const;
	virtual bufsize_t getContentSize() const;
};

```

`pe-bear/gui/pe_models/SecurityTreeModel.cpp`:

```cpp
#include "SecurityTreeModel.h"

//-----------------------------------------------------------------------------

QVariant SecurityTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();

	switch (section) {
		case OFFSET: return "Offset";
		case NAME: return "Name";
		case VALUE : return "Value";
		case VALUE2: return "Meaning";
	}
	return QVariant();
}

QVariant SecurityTreeModel::data(const QModelIndex &index, int role) const
{
	SecurityDirWrapper* wrap = dynamic_cast<SecurityDirWrapper*>(wrapper());
	if (!wrap) return QVariant();

	int column = index.column();
	if (role == Qt::ForegroundRole) return this->addrColor(index);
	if (role == Qt::FontRole) {
		if (this->containsOffset(index) || this->containsValue(index)) {
			return offsetFont;
		}
		return QVariant();
	}
	if (role == Qt::ToolTipRole) return toolTip(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();
	int fId = getFID(index);
	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
		case NAME: return (wrap->getFieldName(fId));
		case VALUE2: return wrap->translateFieldContent(fId);
	}
	return dataValue(index);
}

//----------------------------------------------------------------------------

```

`pe-bear/gui/pe_models/SecurityTreeModel.h`:

```h
#pragma once

#include <QtGui>
#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"


class SecurityTreeModel  : public WrapperTableModel
{
	Q_OBJECT

public:
	SecurityTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent) {}

	virtual int columnCount(const QModelIndex &parent) const { return COLS_NUM; }

	virtual QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	virtual QVariant data(const QModelIndex &index, int role) const;

	virtual bool containsValue(QModelIndex index) const { return (index.column()  == VALUE); }

protected:
	virtual int getFID(QModelIndex index) const { return index.row();  }
	virtual int getSID(QModelIndex index) const { return index.column(); }

	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->securityDirWrapper; }

	enum cols {
		OFFSET,
		NAME,
		VALUE,
		VALUE2,
		COLS_NUM
	};
friend class SecurityTreeView;
};

```

`pe-bear/gui/pe_models/TLSTreeModel.cpp`:

```cpp
#include "TLSTreeModel.h"

///------------------------

QVariant TLSTreeModel::data(const QModelIndex &index, int role) const
{
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role == Qt::FontRole) {
		if (index.column() != COL_NAME) return offsetFont;
		return QVariant();
	}

	int row = index.row();
	int column = index.column();
	int fId = this->getFID(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	switch (column) {
		case COL_OFFSET: return QString::number(getFieldOffset(index), 16);
		case COL_NAME: return (wrapper()->getFieldName(fId));
	}
	bool isOk = false;
	uint64_t val = wrapper()->getNumValue(fId, &isOk);
	if (!isOk) return "UNK"; 

	return QString::number(val, 16);
}

QVariant TLSTreeModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case COL_OFFSET : return "Offset";
		case COL_NAME : return "Name";
		case COL_VALUE : return "Value";
	}
	return QVariant();
}

QString TLSTreeModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper *w = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (w == NULL) return "";
	size_t entriesNum = w->getEntriesNum();

	std::string name = "TLS Callbacks";
	QString numDesc = entriesNum == 1 ? " entry" : " entries";
	QString desc = QString::fromStdString(name) + "   [ " + QString::number(entriesNum) + numDesc + " ]"; 
	return desc;
}

//-----------------------------------------------------------------------------------

int TLSCallbacksModel::rowCount(const QModelIndex &parent) const
{
	ExeNodeWrapper *w = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (w == NULL) return 0;

	return w->getEntriesNum();
}

QVariant TLSCallbacksModel::data(const QModelIndex &index, int role) const
{
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	if (role == Qt::ToolTipRole) return toolTip(index);
	if (role == Qt::FontRole) return offsetFont;

	int row = index.row();
	int column = index.column();
	int fId = this->getFID(index);

	if (role != Qt::DisplayRole && role != Qt::EditRole) return QVariant();

	switch (column) {
		case OFFSET: return QString::number(getFieldOffset(index), 16);
	}
	bool isOk = false;
	uint64_t val = wrapperAt(index)->getNumValue(0, &isOk);
	if (!isOk) return "UNK"; 

	return QString::number(val, 16);
}

QVariant TLSCallbacksModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if(role != Qt::DisplayRole) return QVariant();
	switch (section) {
		case OFFSET : return "Offset";
		case VALUE : return "Callback";
	}
	return QVariant();
}

```

`pe-bear/gui/pe_models/TLSTreeModel.h`:

```h
#pragma once
#include <QtGui>

#include <map>
#include <set>

#include "../../gui_base/WrapperTableModel.h"

class TLSTreeModel : public WrapperTableModel
{
	Q_OBJECT

public:
	TLSTreeModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent)
	{
		connectSignals();
	}

	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;

	virtual bool containsValue(QModelIndex index) const { return index.column() == COL_VALUE; }
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->tlsDirWrapper; }

	virtual QString makeDockerTitle(uint32_t upId);

protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column();  }

	enum FieldID {
		NONE = FIELD_NONE,
		COL_OFFSET = 0,
		COL_NAME,
		COL_VALUE,
		MAX_COL
	};
};

//-------------------------------------------------------------------------------------------

class TLSCallbacksModel : public WrapperTableModel
{
	Q_OBJECT

public:
	TLSCallbacksModel(PeHandler *peHndl, QObject *parent = 0)
		: WrapperTableModel(peHndl, parent)
	{
		connectSignals();
	}

	int rowCount(const QModelIndex &parent) const;
	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	
	QVariant data(const QModelIndex &index, int role) const;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	
	virtual bool containsValue(QModelIndex index) const { return index.column() == VALUE; }
	virtual ExeElementWrapper* wrapper() const { return &myPeHndl->tlsDirWrapper; }
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const { return myPeHndl->tlsDirWrapper.getEntryAt(getFID(index)); }

protected:
	virtual int getFID(const QModelIndex &index) const { return index.row();  }
	virtual int getSID(const QModelIndex &index) const { return index.column();  }

	enum FieldID {
		NONE = FIELD_NONE,
		OFFSET = 0,
		VALUE,
		MAX_COL
	};
};
```

`pe-bear/gui/windows/DiffWindow.cpp`:

```cpp
#include "DiffWindow.h"
#include <QtGlobal>
#include <bearparser/Util.h>

//------------------------------------------------------------------------------------


DiffWindow::DiffWindow(PeHandlersManager &peMngr, QWidget *parent)
    : QMainWindow(parent), peManger(peMngr),
    hexDumpModelL(LEFT), hexDumpModelR(RIGHT)
{
	createFormatChanger(LEFT, &this->toolBars[LEFT]);
	createFormatChanger(RIGHT, &this->toolBars[RIGHT]);
	
	createActions();

	this->setWindowTitle("Compare...");
	this->setMinimumSize( QSize(880, 600) );
	this->mainSplitter.setOrientation(Qt::Horizontal);

	this->setCentralWidget(&this->mainSplitter);
	mainSplitter.setAutoFillBackground(true);
	
	mainSplitter.addWidget(&this->leftSplitter);
	mainSplitter.addWidget(&this->rightSplitter);

	leftSplitter.addWidget(&this->fileCombo[LEFT]);
	leftSplitter.addWidget(&this->treeView[LEFT]);

	leftSplitter.addWidget(&this->toolBars[LEFT]);
	leftSplitter.addWidget(&this->fileView[LEFT]);
	leftSplitter.addWidget(&this->numEdit[LEFT]);

	for (int viewIndx = 0; viewIndx < CNTR; viewIndx++) {
		this->toolBars[viewIndx].addAction(setHexView);
		this->toolBars[viewIndx].addAction(nextDiff);
		this->numEdit[viewIndx].setReadOnly(true);
	}

	this->treeView[LEFT].setHeaderHidden(true);
	this->treeView[RIGHT].setHeaderHidden(true);
	
	rightSplitter.addWidget(&this->fileCombo[RIGHT]);
	rightSplitter.addWidget(&this->treeView[RIGHT]);

	rightSplitter.addWidget(&this->toolBars[RIGHT]);
	rightSplitter.addWidget(&this->fileView[RIGHT]);
	rightSplitter.addWidget(&this->numEdit[RIGHT]);

	leftSplitter.setOrientation(Qt::Vertical);
	rightSplitter.setOrientation(Qt::Vertical);
	
// init models:
	fileView[LEFT].setModel(&hexDumpModelL);
	fileView[RIGHT].setModel(&hexDumpModelR);

	connect(&fileScrollBar[LEFT], SIGNAL(sliderMoved(int)), this, SLOT(onSliderMoved(int)) );
	connect(&fileScrollBar[RIGHT], SIGNAL(sliderMoved(int)), this, SLOT(onSliderMoved(int)) );

	this->setStatusBar(&this->statusBar);

	connect( &this->fileCombo[LEFT], SIGNAL(activated(const QString &)),
		this, SLOT(file1Selected(const QString &)) );
	connect( &this->fileCombo[RIGHT], SIGNAL(activated(const QString &)),
		this, SLOT(file2Selected(const QString &)) );

	connect( this, SIGNAL(contentChanged(BYTE*, int, offset_t, ContentIndx)),
		&hexDumpModelL, SLOT(setContent(BYTE*, int, offset_t, ContentIndx)) );
		
	connect( this, SIGNAL(contentChanged(BYTE*, int, offset_t, ContentIndx)),
		&hexDumpModelR, SLOT(setContent(BYTE*, int, offset_t, ContentIndx)) );

	connect( this, SIGNAL(contentCleared(ContentIndx)), 
		&hexDumpModelL, SLOT(clearContent(ContentIndx)) );
		
	connect( this, SIGNAL(contentCleared(ContentIndx)), 
		&hexDumpModelR, SLOT(clearContent(ContentIndx)) );

	connect(&this->peManger, SIGNAL(PeListUpdated()), this, SLOT(refresh()));
	//-----
	QPalette p = this->fileView[LEFT].palette();
	QColor bgColor = QColor(HEXDIFF_BG);
	bgColor.setAlpha(160);
	QColor bgAltColor = QColor(HEXDIFF_ALTBG);
	bgAltColor.setAlpha(160);
	p.setColor(QPalette::Base, bgColor); 
	p.setColor(QPalette::AlternateBase, bgAltColor);
	p.setColor(QPalette::WindowText, Qt::black);

	this->fileView[LEFT].setPalette(p);
	this->fileView[RIGHT].setPalette(p);
	this->fileView[LEFT].setAutoFillBackground(true);
	this->fileView[RIGHT].setAutoFillBackground(true);
	
	resizeComponents();
}

void DiffWindow::resizeComponents()
{
	const int iconDim = ViewSettings::getIconDim(QApplication::font());
	const int NUM_EDIT_HEIGHT = iconDim * 3;
	const int MAX_HEIGHT = iconDim * 2;

	for (int viewIndx = 0; viewIndx < CNTR; viewIndx++) {
		this->fileCombo[viewIndx].setMaximumHeight(MAX_HEIGHT);
		this->toolBars[viewIndx].setMaximumHeight(MAX_HEIGHT);
		this->numEdit[viewIndx].setFixedHeight(NUM_EDIT_HEIGHT);
	}
}

bool DiffWindow::createFormatChanger(ContentIndx indx, QToolBar* parent)
{
	if (indx >= CNTR) return false;
	if (!parent) return false;
	
	QStringList commands;
	commands << "Raw" << "Relative ($+)";
	addrFmtBox[indx].addItems(commands);
	connect(&addrFmtBox[indx], SIGNAL(currentIndexChanged(int)), this, SLOT(onAddrFormatSelected(int)) );
	
	parent->addWidget(&addrFmtBox[indx]);
	return true;
}

void DiffWindow::onSliderMoved(int val)
{
	fileScrollBar[LEFT].setSliderPosition(val);
	fileScrollBar[RIGHT].setSliderPosition(val);
}

void DiffWindow::hexSelectedL()
{
	hexSelected(LEFT);
}

void DiffWindow::hexSelectedR()
{
	hexSelected(RIGHT);
}

void DiffWindow::hexSelected(ContentIndx contentIndx)
{
	QItemSelectionModel *model = this->fileView[contentIndx].selectionModel();
	QModelIndexList list = model->selectedIndexes();
	int row = -1;
	int col = -1;
	int size = list.size();

	if (size > (64 / 8)) {
		this->numEdit[contentIndx].setText("");
		return;
	}
	
	int64_t lEndianNum = 0;

	size = size > 8 ? 8 : size;

	for (int i = 0; i < size; i++) {
		QModelIndex index = list.at(i);

		bool isOk;
		uint8_t tempNum = index.data().toString().toInt(&isOk, 16);
		if (!isOk) break;

		lEndianNum <<= 8;
		lEndianNum ^= tempNum;
	}

	int64_t bEndianNum = 0;

	for (int i = (size - 1); i >= 0; i--) {
		QModelIndex index = list.at(i);
		if (!index.isValid()) continue;
		bool isOk;
		uint8_t tempNum = index.data().toString().toInt(&isOk, 16);
		if (!isOk) break;

		bEndianNum <<= 8;
		bEndianNum ^= tempNum;
	}

	//static char buff[0x100] = { 0 };
	QString temp;
	QString str;
	if (size > sizeof(uint32_t)) {
		str.append("QWORD\n");
#if QT_VERSION >= 0x050000
		temp = QString::asprintf("%lld = %llu = %016llX", (long long)lEndianNum, (unsigned long long)lEndianNum, (unsigned long long)lEndianNum);
#else
		temp.sprintf("%lld = %llu = %016llX", (long long)lEndianNum, (unsigned long long)lEndianNum, (unsigned long long)lEndianNum);
#endif
		str.append("LEndian : " + temp + "\n");
#if QT_VERSION >= 0x050000
		temp = QString::asprintf("%lld = %llu = %016llX", (long long)bEndianNum, (unsigned long long)bEndianNum, (unsigned long long)bEndianNum);
#else
		temp.sprintf("%lld = %llu = %016llX", (long long)bEndianNum, (unsigned long long)bEndianNum, (unsigned long long)bEndianNum);
#endif
		str.append("BEndian : " + temp + "\n");

	} else if (size > sizeof(uint16_t)) {
		str.append("DWORD\n");
#if QT_VERSION >= 0x050000
		temp = QString::asprintf("%d = %u = %08X", (int32_t) lEndianNum, (uint32_t) lEndianNum, (uint32_t) lEndianNum);
#else
		temp.sprintf("%d = %u = %08X", (int32_t) lEndianNum, (uint32_t) lEndianNum, (uint32_t) lEndianNum);
#endif
		str.append("LEndian : " + temp + "\n");
#if QT_VERSION >= 0x050000
		temp = QString::asprintf("%d = %u = %08X", (int32_t) bEndianNum, (uint32_t) bEndianNum, (uint32_t) bEndianNum);
#else
		temp.sprintf("%d = %u = %08X", (int32_t) bEndianNum, (uint32_t) bEndianNum, (uint32_t) bEndianNum);
#endif
		str.append("BEndian : " + temp + "\n");

	} else if (size > sizeof(uint8_t)) {
		str.append("WORD\n");
#if QT_VERSION >= 0x050000
		temp = QString::asprintf("%d = %u = %04X", (int16_t) lEndianNum, (uint16_t) lEndianNum, (uint16_t) lEndianNum);
#else
		temp.sprintf("%d = %u = %04X", (int16_t) lEndianNum, (uint16_t) lEndianNum, (uint16_t) lEndianNum);
#endif
		str.append("LEndian : " + temp + "\n");

#if QT_VERSION >= 0x050000
		temp = QString::asprintf( "%d = %u = %04X", (int16_t) bEndianNum, (uint16_t) bEndianNum, (uint16_t) bEndianNum);
#else
		temp.sprintf( "%d = %u = %04X", (int16_t) bEndianNum, (uint16_t) bEndianNum, (uint16_t) bEndianNum);
#endif
		str.append("BEndian : " + temp + "\n");
	} else {
		str.append("BYTE\n");
		temp = QString::number((int8_t) lEndianNum, 10) + " = " + QString::number((uint8_t) lEndianNum, 10) + " = " + QString::number((uint8_t) lEndianNum, 16).toUpper();
		str.append("LEndian : " + temp + "\n");
		
		temp = QString::number((int8_t) bEndianNum, 10) + " = " + QString::number((uint8_t) bEndianNum, 10) + " = " + QString::number((uint8_t) bEndianNum, 16).toUpper();
		str.append("BEndian : " + temp + "\n");
	}
	this->numEdit[contentIndx].setText(str);
}

void DiffWindow::onAddrFormatSelected(int val)
{
	if (val == 0) {
		hexDumpModelL.setRelativeOffset(false);
		hexDumpModelR.setRelativeOffset(false);
	} else {
		hexDumpModelL.setRelativeOffset(true);
		hexDumpModelR.setRelativeOffset(true);
	}
	for (int i = 0; i < CNTR; i++) {
		if (addrFmtBox[i].currentIndex() != val) {
			addrFmtBox[i].setCurrentIndex(val);
		}
	}
}

void DiffWindow::createActions()
{
	setHexView = new QAction("Hex View", this);
	setHexView->setCheckable(true);
	setHexView->setChecked(hexDumpModelL.isHexView());
	connect(setHexView, SIGNAL(triggered(bool)), &hexDumpModelL, SLOT(setHexView(bool)) );
	connect(setHexView, SIGNAL(triggered(bool)), &hexDumpModelR, SLOT(setHexView(bool)) );

	this->nextDiff = new QAction("Next Diff", this);
	connect(this->nextDiff, SIGNAL(triggered()), &hexDumpModelL, SLOT(onGoToNextDiff()) );
	connect(this->nextDiff, SIGNAL(triggered()), &hexDumpModelR, SLOT(onGoToNextDiff()) );
}

void DiffWindow::destroyActions()
{
	delete setHexView;
	setHexView = NULL;

	delete nextDiff;
	nextDiff = NULL;
}

bool DiffWindow::reselectPrevious(QList<QString> &stringsList, ContentIndx contentIndx)
{
	if (contentIndx == CNTR) return false;
	if (stringsList.size() == 0) return false;

	QString prevName = currName[contentIndx];
	bool isContained = false;

	if (stringsList.contains(prevName)) {
		int foundIndx = stringsList.indexOf(prevName, 0);
		fileCombo[contentIndx].setCurrentIndex(foundIndx);
		isContained = true;
	} else {
		prevName = stringsList[0];
	}

	if (contentIndx == LEFT) {
		file1Selected(prevName);
	}
	else {
		file2Selected(prevName);
	}

	return isContained;
}

void DiffWindow::refresh()
{
	emit contentCleared(CNTR);

	for (int viewIndx = 0; viewIndx < CNTR; viewIndx++) {
		treeView[viewIndx].setModel(NULL);

		fileCombo[viewIndx].clear();
		contentPtr[viewIndx] = NULL;
		contentSize[viewIndx] = 0;
		contentOffset[viewIndx] = 0;
	}

	removeUnusedTreeModels();

	QList<QString> stringsList;
	std::map<PEFile*, PeHandler*> hndlMap = this->peManger.getHandlersMap();
	std::map<PEFile*, PeHandler*>::iterator peItr;
	for (peItr = hndlMap.begin(); peItr != hndlMap.end(); ++peItr) {
		QString name = peItr->second->getFullName();
		stringsList.append(name);
	}

	fileCombo[LEFT].addItems(stringsList);
	fileCombo[RIGHT].addItems(stringsList);
	
	reselectPrevious(stringsList, LEFT);
	reselectPrevious(stringsList, RIGHT);
}

void DiffWindow::file2Selected(const QString &text)
{
	setTreeModel(treeView[RIGHT], text);
	setPEContent(text, 0, RIGHT);

	connect(treeView[RIGHT].selectionModel(), SIGNAL(currentChanged(const QModelIndex &, const QModelIndex &)), 
		this, SLOT( item2Marked(const QModelIndex &, const QModelIndex &) ) );

	connect(this->fileView[RIGHT].selectionModel(), SIGNAL(selectionChanged(const QItemSelection &, const QItemSelection &)),
		this, SLOT(hexSelectedR()) );
}

void DiffWindow::file1Selected(const QString &text)
{
	setTreeModel(treeView[LEFT], text);
	setPEContent(text, 0, LEFT);

	connect(treeView[LEFT].selectionModel(), SIGNAL(currentChanged(const QModelIndex &, const QModelIndex &)),
		this, SLOT( item1Marked(const QModelIndex &, const QModelIndex &) ) );

	connect(this->fileView[LEFT].selectionModel(), SIGNAL(selectionChanged(const QItemSelection &, const QItemSelection &)),
		this, SLOT(hexSelectedL()) );
}

void DiffWindow::removeUnusedTreeModels()
{
	std::map<QString, PEFile*>::iterator loadedIter;
	std::map<QString, PEFileTreeModel*>::iterator peIter;
	std::set<QString> toErase;

	for (peIter = peModels.begin(); peIter != peModels.end(); ++peIter) {
		const QString &name = peIter->first;

		if (!this->peManger.getByName(name)) {
			toErase.insert(name);
			continue;
		}
	}
	std::set<QString>::iterator eraseIter;
	for (eraseIter = toErase.begin(); eraseIter != toErase.end(); ++eraseIter) {
		const QString name = *eraseIter;
		PEFileTreeModel* model = peModels[name];
		peModels.erase(name);
		delete model;
	}
}

void DiffWindow::setPEContent(const QString &name, int offset, ContentIndx contentIndx)
{
	if (name.size() == 0) return;

	PeHandler* hndl = this->peManger.getByName(name);
	if (hndl == NULL) {
		return;
	}
	currName[contentIndx] = name;
	PEFile *pe = hndl->getPe();
	if (pe == NULL) {
		return;
	}
	BYTE* content = pe->getContent();
	int size = pe->getRawSize();
	if (content == NULL)
		emit contentChanged(NULL, 0, 0, contentIndx);
	else
		emit contentChanged(content + offset, size - offset, offset, contentIndx);
}

void DiffWindow::setTreeModel(QTreeView &treeView, const QString &name)
{
	if (name.size() == 0) {
		return;
	}
	PeHandler* hndl = this->peManger.getByName(name);
	if (!hndl) {
		return;
	}
	PEFile *pe = hndl->getPe();
	if (pe == NULL) {
		return;
	}

	PEFileTreeModel *model = peModels[name];
	if (model == NULL) {
		model = new PEFileTreeModel(&treeView);
		model->addHandler(hndl);
//		model->addPE(hndl);
		peModels[name] = model;
	}

	treeView.setModel(model);
	treeView.expandAll();
}

void DiffWindow::item1Marked(const QModelIndex & current, const QModelIndex & previous)
{
	itemMarked(current, previous, treeView[LEFT], LEFT);
	emit contentChanged(contentPtr[LEFT], contentSize[LEFT], contentOffset[LEFT], LEFT);

}

void DiffWindow::item2Marked(const QModelIndex & current, const QModelIndex & previous)
{
	itemMarked(current, previous, treeView[RIGHT], RIGHT);
	emit contentChanged(contentPtr[RIGHT], contentSize[RIGHT], contentOffset[RIGHT], RIGHT);
}

void DiffWindow::itemMarked(const QModelIndex & current, const QModelIndex & previous, QTreeView &treeView, ContentIndx contentIndx)
{
	if (contentIndx >= CNTR) return;

	QVariant what = (QVariant) treeView.model()->data(current, Qt::WhatsThisRole);

	PEFileTreeItem *item = static_cast<PEFileTreeItem*>(current.internalPointer());

	if (item->getContent() == NULL) return;

	BYTE* newContent = item->getContent();
	size_t newSize = item->getContentSize();

	if (contentPtr[contentIndx] ==  newContent && contentSize[contentIndx] == newSize ) {
		return; // no changes
	}
	contentPtr[contentIndx] = newContent;
	contentSize[contentIndx] = newSize;
	contentOffset[contentIndx] = item->getContentOffset();
	/*
	QList<QString> stringsList;
	for (int pagePtr  = 0; pagePtr < contentSize[contentIndx]; pagePtr += PREVIEW_SIZE) {
		stringsList.append(QString::number(pagePtr, 16));
	}
	scopeCombo[contentIndx].clear();
	scopeCombo[contentIndx].addItems(stringsList);
	*/
	uint32_t diff = HexDiffModel::getDiffStart(contentPtr[LEFT], contentSize[LEFT], contentPtr[RIGHT], contentSize[RIGHT]);
	if (diff == (-1)) {
		if (contentSize[LEFT] != contentSize[RIGHT]) {
			if (contentSize[LEFT] > contentSize[RIGHT])
				this->statusBar.showMessage("LEFT == RIGHT, till: 0x" + QString::number(contentSize[RIGHT], 16).toUpper() + "; LEFT longer.");
			else
				this->statusBar.showMessage("LEFT == RIGHT, till: 0x" + QString::number(contentSize[LEFT], 16).toUpper() + "; RIGHT longer.");
		} else
			this->statusBar.showMessage("LEFT == RIGHT");
	} else
		this->statusBar.showMessage("First difference at: 0x" + QString::number(diff, 16).toUpper());
}


```

`pe-bear/gui/windows/DiffWindow.h`:

```h
#pragma once

#include <QtGui>
#include <bearparser/bearparser.h>

#include "../../PEFileTreeModel.h"
#include "../../gui/HexDiffModel.h"
#include "../../gui_base/ExtTableView.h"

#include "../../HexCompareView.h"

//----------------------------------------------------

class DiffWindow : public QMainWindow
{
    Q_OBJECT

public:
	DiffWindow(PeHandlersManager &peManager, QWidget *parent);

signals:
	void contentChanged(BYTE* contentPtr, int size, offset_t startOffset,  ContentIndx indx);
	void contentCleared(ContentIndx indx);
	void addrFormatChanged(int fmt);

public slots:
	void refresh();
	void file1Selected(const QString &text);
	void file2Selected(const QString &text);
	void item1Marked(const QModelIndex & current, const QModelIndex & previous);
	void item2Marked(const QModelIndex & current, const QModelIndex & previous);

	void hexSelectedL();
	void hexSelectedR();
	void hexSelected(ContentIndx contentIndx);

	void changeHexViewSettings(HexViewSettings &_settings)
	{
		hexDumpModelL.changeSettings(_settings);
		hexDumpModelR.changeSettings(_settings);
	}

	void onGlobalFontChanged()
	{
		resizeComponents();
	}

private slots:
	void onSliderMoved(int val);
	void onAddrFormatSelected(int val);

protected:
	void resizeComponents();
	bool createFormatChanger(ContentIndx indx, QToolBar* parent);
	bool reselectPrevious(QList<QString> &stringsList, ContentIndx contentIndx);
	void createActions();
	void destroyActions();

	void removeUnusedTreeModels();
	void setTreeModel(QTreeView &treeView, const QString &text);
	void setPEContent(const QString &fileName, int offset, ContentIndx contentIndx);
	void itemMarked(const QModelIndex & current, const QModelIndex &previous, QTreeView &treeView, ContentIndx contentIndx);

	PeHandlersManager &peManger;
	std::map<QString, PEFileTreeModel*> peModels;
	
	QSplitter mainSplitter;
	QSplitter leftSplitter, rightSplitter;
	QTreeView PEsTree1, PEsTree2;

	QComboBox fileCombo[CNTR];
	QTreeView treeView[CNTR];

	HexDiffModel hexDumpModelL, hexDumpModelR;
	HexCompareView fileView[CNTR];
	QScrollBar fileScrollBar[CNTR];

	QTextEdit numEdit[CNTR];

	offset_t contentOffset[CNTR];
	BYTE* contentPtr[CNTR];
	size_t contentSize[CNTR];

	QToolBar toolBars[CNTR];
	QComboBox addrFmtBox[CNTR];
	QStatusBar statusBar;

	QAction *setHexView;
	QAction *nextDiff;

	QString currName[CNTR];
};


```

`pe-bear/gui/windows/MainWindow.cpp`:

```cpp
#include "MainWindow.h"
#include <QtGlobal>
#include <bearparser/bearparser.h>

#include "../../HexView.h"
#include "../../base/RegKeyManager.h"

#ifdef _DEBUG
	#include <iostream>
#endif

#define PE_TREE_WIDTH 220
#define MIN_HEIGHT 600
#define SIG_FILE "SIG.txt"

#define CHANGE_CHECK_INTERVAL 1000

using namespace std;
using namespace sig_ma;
//-----------------------------------------------------------


MainWindow::MainWindow(QWidget *parent) 
	: QMainWindow(parent), 
	m_PeHndl(NULL), m_Timer(this),
	diffWindow(this->m_PEHandlers, this), secAddWindow(this), userConfigWindow(this),
	sectionsTree(this), sectionMenu(mainSettings, this),
	peFileModel(NULL),
	rightPanel(this), 
	signWindow(&vSign, this),
	currentVer(V_MAJOR, V_MINOR, V_PATCH, V_PATCH_SUB, V_DESC),
	guiSettings()
{
	// load the saved settings:
	this->mainSettings.readPersistent();
	MainSettingsHolder::setMainSettings(&this->mainSettings);
	userConfigWindow.setMainSettings(&this->mainSettings);

	winDesc = QString(TITLE) + " v" + currentVer.toString();
	setWindowTitle(winDesc);

	setAcceptDrops(true);
	setMinimumHeight(MIN_HEIGHT);

	setStatusBar(&statusBar);
	statusBar.addPermanentWidget(&urlLabel);

	setupWidgets();
	setupLayout();

	createActions();
	createMenus();
	connectSignals();

	vSign.loadSignatures(SIG_FILE);
	guiSettings.readPersistent();
	selectCurrentStyle();
	startTimer();
}

void MainWindow::connectSignals()
{
	connect(&m_PEHandlers, SIGNAL(exeHandlerAdded(PeHandler *)), 
		this, SLOT(onExeHandlerAdded(PeHandler *)), Qt::UniqueConnection);

	connect(&sectionsTree, SIGNAL(handlerSelected(PeHandler *)),
		this, SLOT(onHandlerSelected(PeHandler*)), Qt::UniqueConnection);

	connect(this, SIGNAL(addSectionRequested(PeHandler*)),
		&secAddWindow, SLOT(onAddSectionToPe(PeHandler*)) );

	connect(&signWindow, SIGNAL(signaturesUpdated()),
		&m_PEHandlers, SLOT(checkAllSignatures()));
		
	connect(&m_PEHandlers, SIGNAL(matchedSignatures()),
		&sectionsTree, SLOT(onNeedReset()));

	connect(&guiSettings, SIGNAL(globalFontChanged()),
		&rightPanel, SLOT(onGlobalFontChanged()) );

	connect(&guiSettings, SIGNAL(globalFontChanged()),
		&diffWindow, SLOT(onGlobalFontChanged()) );

	connect(&guiSettings, SIGNAL(hexViewSettingsChanged(HexViewSettings&)),
		&rightPanel, SLOT(changeHexViewSettings(HexViewSettings&)) );
		
	connect(&guiSettings, SIGNAL(hexViewSettingsChanged(HexViewSettings&)),
		&diffWindow, SLOT(changeHexViewSettings(HexViewSettings&)) );

	connect(&guiSettings, SIGNAL(disasmViewSettingsChanged(DisasmViewSettings&)),
		&rightPanel, SLOT(changeDisasmViewSettings(DisasmViewSettings&)) );
}

void MainWindow::reloadFile(const QString &path, const bool isDeleted)
{
	PeHandler* hndl = this->m_PEHandlers.getByName(path);
	if (!hndl) {
		return;
	}
	_reload(hndl, isDeleted);
	if (!isDeleted) {
		this->statusBar.showMessage("File reloaded: "+ path);
	}
}

bool MainWindow::checkFileChanges(const QString &path)
{
	PeHandler* hndl = this->m_PEHandlers.getByName(path);
	if (!hndl) return false;
	
	if (!hndl->updateFileModifTime()) {
		return false;
	}
	QFileInfo fileInfo(path);
	const bool isFileDeleted = fileInfo.exists() ? false : true;

	if (isFileDeleted) {
		this->statusBar.showMessage("File deleted: "+ path);
	} else {
		this->statusBar.showMessage("File changed: "+ path);
	}
	
	const t_reload_mode rMode = this->mainSettings.isReloadOnFileChange();
	if (rMode == RELOAD_IGNORE) {
		// ignore the changes...
		return false;
	}
	bool shouldReload = (rMode == RELOAD_AUTO);
	if (!shouldReload || isFileDeleted) {
		const QString wndTitle = (!isFileDeleted) ? "File changed!" : "File deleted!";
		const QString wndInfo = (!isFileDeleted) 
			? "The file:\n" + path + "\n- has changed.\n\nDo you want to reload?" 
			: "The file:\n" + path + "\n- has been deleted.\n\nDo you want to unload?";

		QMessageBox msgbox(this);

		msgbox.setWindowTitle(wndTitle);
		msgbox.setText(wndInfo);
		msgbox.setIcon(QMessageBox::Question);
		msgbox.addButton(QMessageBox::Yes);
		msgbox.addButton(QMessageBox::No);
		msgbox.setDefaultButton(QMessageBox::Yes);		
#if QT_VERSION >= 0x050000
		QCheckBox cb("Remember the answer", &msgbox);
		cb.setToolTip("Can be changed in: [Settings] -> [Configure...]");
		cb.setChecked(false);
		msgbox.setCheckBox(&cb);
#endif
		const int reply = msgbox.exec();
		if (reply == QMessageBox::Yes) {
			shouldReload = true;
		} else {
			shouldReload = false;
		}
		
		t_reload_mode rMode = RELOAD_ASK;
#if QT_VERSION >= 0x050000
		const bool setAuto = cb.isChecked();
#else
		const bool setAuto = false;
#endif
		if (setAuto) {
			if (shouldReload) {
				rMode = RELOAD_AUTO;
			}
			else {
				rMode = RELOAD_IGNORE;
			}
		}
		this->mainSettings.setReloadOnFileChange(rMode);
	}
	if (shouldReload) {
		reloadFile(path, isFileDeleted);
	}
	return true;
}

bool MainWindow::readPersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	restoreGeometry(settings.value("geometry").toByteArray());
	restoreState(settings.value("windowState").toByteArray());

	if (settings.status() != QSettings::NoError ) {
		return false;
	}
	return true;
}

bool MainWindow::writePersistent()
{
	QSettings settings(COMPANY_NAME, APP_NAME);
	settings.setValue("geometry", saveGeometry());
	settings.setValue("windowState", saveState());

	if (settings.status() != QSettings::NoError ) {
		return false;
	}
	return true;
}

void MainWindow::setupLayout()
{
	setCentralWidget(&mainSplitter);
	mainSplitter.setAutoFillBackground(true);
	mainSplitter.insertWidget(0, &this->sectionsTree);
	mainSplitter.insertWidget(1, &this->rightPanel);
	
	mainSplitter.setStretchFactor(0, 0);
	mainSplitter.setStretchFactor(1, 1);
}

void MainWindow::setupWidgets()
{
	peFileModel = new PEFileTreeModel(&sectionsTree);
	connect(&m_PEHandlers, SIGNAL(exeHandlerAdded(PeHandler*)), peFileModel, SLOT(addHandler(PeHandler *)) );
	connect(&m_PEHandlers, SIGNAL(exeHandlerRemoved(PeHandler*)), peFileModel, SLOT(deleteHandler(PeHandler *)) );

	sectionsTree.setModel(peFileModel);

	sectionsTree.setSelectionMode(QAbstractItemView::SingleSelection);
	sectionsTree.setSelectionBehavior( QAbstractItemView::SelectRows);
	urlLabel.setProperty("hasUrl",true);
	urlLabel.setText("<a href=\"" + QString(PEBEAR_LINK) + "\">Check for updates</a>");
	urlLabel.setTextFormat(Qt::RichText);
	urlLabel.setTextInteractionFlags(Qt::TextBrowserInteraction);
	urlLabel.setOpenExternalLinks(true);
	urlLabel.setToolTip("Check if new version is available or\nwrite a comment about your user experience!");
}

void MainWindow::createTreeActions()
{
	QIcon packerIco(":/icons/Locked.ico");
	searchSigAction = new ExeDependentAction(packerIco, "Search for signatures", this);
	connect(searchSigAction, SIGNAL(triggered(PeHandler*)), this, SLOT(sigSearch(PeHandler*)) );

	dumpAllSecAction =  new ExeDependentAction(QIcon(":/icons/dump.ico"), "Dump all sections to...", this);
	connect(this->dumpAllSecAction, SIGNAL(triggered(PeHandler*)), this, SLOT(dumpAllSections(PeHandler*)));

	QIcon addIco(":/icons/add_entry.ico");
	addSecAction =  new ExeDependentAction(addIco, "Add a new section", this);
	connect(this->addSecAction, SIGNAL(triggered(PeHandler*)), this, SLOT(addSection(PeHandler*)));

	QIcon saveIco(":/icons/Save.ico");
	this->saveAction = new ExeDependentAction(saveIco, "&Save the executable as...", this);
	connect(this->saveAction, SIGNAL(triggered(PeHandler*)), this, SLOT(savePE(PeHandler*)));

	reloadAction = new ExeDependentAction(QIcon(":/icons/reload.ico"), "&Reload", this);
	connect(reloadAction, SIGNAL(triggered(PeHandler*)), this, SLOT(reload(PeHandler*)) );

	unloadAction = new ExeDependentAction(QIcon(":/icons/Delete.ico"), "&Unload", this);
	connect(unloadAction, SIGNAL(triggered(PeHandler*)), this, SLOT(closePE(PeHandler*)));

	sectionsTree.setMenu(&sectionsTreeMenu);
	connect(&sectionsTree, SIGNAL(handlerSelected(PeHandler*)), &sectionsTreeMenu, SLOT(onExeChanged(PeHandler*)) );

	sectionsTree.enableMenu(true);

	sectionMenu.setTitle("Edit the section\n");
	sectionsTreeMenu.addMenu(&sectionMenu);
	sectionsTreeMenu.addSeparator();
	
	sectionsTreeMenu.addAction(this->searchSigAction);
	sectionsTreeMenu.addAction(this->addSecAction);
	sectionsTreeMenu.addAction(this->dumpAllSecAction);
	sectionsTreeMenu.addAction(this->saveAction);
	sectionsTreeMenu.addSeparator();
	sectionsTreeMenu.addAction(this->reloadAction);
	sectionsTreeMenu.addAction(this->unloadAction);
}

void MainWindow::createActions()
{
	createTreeActions();

	//Actions
	newInstance = new QAction(QIcon(":/icons/add_entry.ico"), "&New Instance", this);
	newInstance->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_N));
	newInstance->setShortcutContext(Qt::ApplicationShortcut);
	connect(this->newInstance, SIGNAL(triggered()), this, SLOT(runNewInstance()));

	openAction = new QAction(QIcon(":/icons/Add.ico"), "&Load PEs", this);
	openAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_O));
	openAction->setShortcutContext(Qt::ApplicationShortcut);
	connect(this->openAction, SIGNAL(triggered()), this, SLOT(open()));
	
	unloadAllAction = new QAction(QIcon(":/icons/DeleteAll.ico"), "&Unload All", this);
	connect(this->unloadAllAction, SIGNAL(triggered()), this, SLOT(unloadAllPEs()));

	setRegKeyAction = new QAction("Add to Explorer", this);
	this->setRegKeyAction->setCheckable(true);
	this->setRegKeyAction->setChecked(isRegKey());
	connect(this->setRegKeyAction, SIGNAL(triggered(bool)), this, SLOT(setRegistryKey(bool)));

	viewSignAction = new QAction(QIcon(":/icons/List.ico"), "&List", this);
	connect(this->viewSignAction, SIGNAL(triggered()), this, SLOT(viewSignatures()));
	openSignAction = new QAction("&Load", this);
	connect(this->openSignAction, SIGNAL(triggered()), this, SLOT(openSignatures()));

	infoAction = new QAction("&Info", this);
	connect(this->infoAction, SIGNAL(triggered()), this, SLOT(info()));

	openDiffWindowAction = new QAction("Compare", this);
	connect(this->openDiffWindowAction, SIGNAL(triggered()), this, SLOT(openDiffWindow()) );
	
	hexViewFontAction = new QAction("HexView Font", this);
	connect(this->hexViewFontAction, SIGNAL(triggered()), this, SLOT(changeHexFont()) );
	
	disasmViewFontAction = new QAction("DisasmView Font", this);
	connect(this->disasmViewFontAction, SIGNAL(triggered()), this, SLOT(changeDisasmFont()) );
	
	globalFontAction = new QAction("Global Font", this);
	connect(this->globalFontAction, SIGNAL(triggered()), this, SLOT(changeGlobalFont()) );

	defaultFontsAction = new QAction("Reset to defaults", this);
	connect(this->defaultFontsAction, SIGNAL(triggered()), this, SLOT(setDefaultFonts()));

	zoomInAction = new QAction("Zoom In", this);
	zoomInAction->setShortcut(QKeySequence::ZoomIn);
	zoomInAction->setShortcutContext(Qt::ApplicationShortcut);
	connect(this->zoomInAction, SIGNAL(triggered()), this, SLOT(zoomInFonts()));
	
	zoomOutAction = new QAction("Zoom Out", this);
	zoomOutAction->setShortcut(QKeySequence::ZoomOut);
	zoomOutAction->setShortcutContext(Qt::ApplicationShortcut);
	connect(this->zoomOutAction, SIGNAL(triggered()), this, SLOT(zoomOutFonts()));
	
	zoomDefault = new QAction("Default size", this);
	zoomDefault->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_0));
	zoomDefault->setShortcutContext(Qt::ApplicationShortcut);
	connect(this->zoomDefault, SIGNAL(triggered()), this, SLOT(setDefaultZoom()));
}

void MainWindow::createMenus()
{
	//Create toolbar menus:
	this->fileMenu = menuBar()->addMenu("&File");
	this->settingsMenu = menuBar()->addMenu("&Settings");
	this->viewMenu = menuBar()->addMenu("&View");

	QMenu *zoomMenu = this->viewMenu->addMenu("Zoom");
	zoomMenu->addAction(zoomInAction);
	zoomMenu->addAction(zoomOutAction);
	zoomMenu->addAction(zoomDefault);
	zoomMenu->insertSeparator(zoomDefault);
	
	QMenu *fontMenu = this->viewMenu->addMenu("Fon&t");
	fontMenu->addAction(globalFontAction);
	fontMenu->addAction(hexViewFontAction);
	fontMenu->addAction(disasmViewFontAction);
	fontMenu->addAction(defaultFontsAction);
	fontMenu->insertSeparator(defaultFontsAction);

	this->stylesGroup = new QActionGroup(this);
	stylesGroup->setExclusive(true);
	QMenu *styleMenu = this->viewMenu->addMenu("Style");
	QList<QString> myStyles = this->guiSettings.getStyles();
	QList<QString>::iterator itr;
	for (itr = myStyles.begin(); itr != myStyles.end(); ++itr) {
		const QString style = *itr;
		QAction *action = new QAction(styleMenu);
		if (!action) continue; // should never happen
		action->setText(style);
		action->setCheckable(true);
		styleMenu->addAction(action);
		stylesGroup->addAction(action);
	}
	connect(styleMenu, SIGNAL(triggered(QAction*)), this, SLOT(setSelectedStyle(QAction*)));

	this->signaturesMenu = this->settingsMenu->addMenu("Si&gnatures");

	menuBar()->addAction(this->openDiffWindowAction);
	menuBar()->addAction(this->infoAction);

	//asociate with actions:
	this->fileMenu->addAction(this->newInstance);
	this->fileMenu->addSeparator();
	this->fileMenu->addAction(this->openAction);
	this->fileMenu->addAction(this->unloadAllAction);

#ifdef _WINDOWS
	this->settingsMenu->addAction(this->setRegKeyAction);
#endif
	
	this->settingsMenu->addSeparator();
	QAction* appearanceAction = new QAction("Configure...", this);
	this->settingsMenu->addAction(appearanceAction);
	connect(appearanceAction, SIGNAL(triggered()), this, SLOT(editAppearance()));
	//---
	this->signaturesMenu->addAction(this->viewSignAction);
	this->signaturesMenu->addAction(this->openSignAction);
}

void MainWindow::startTimer()
{
	m_Timer.setInterval(CHANGE_CHECK_INTERVAL);
	connect(&m_Timer, SIGNAL(timeout()), this, SLOT(onTimeout()));
	m_Timer.start(CHANGE_CHECK_INTERVAL);
}

void MainWindow::stopTimer()
{
	m_Timer.stop();
}

void MainWindow::onTimeout()
{
	if (!this->m_PeHndl) return;

	const QString path = m_PeHndl->getFullName();
	checkFileChanges(path);
}

void MainWindow::onHandlerSelected(PeHandler* peHndl)
{
	if (peHndl && this->checkFileChanges(peHndl->getFullName())) {
		return;
	}
	PEFile* pePtr = (!peHndl) ? NULL : peHndl->getPe();
	const bool isPe = (!pePtr) ? false : true;
	const bool isChanged = (m_PeHndl != peHndl) ? true : false;
	
	this->m_PeHndl = peHndl;
	this->unloadAction->setEnabled(isPe);

	SectionHdrWrapper* sec = NULL;
	const bool selected = (peHndl != NULL);
	if (selected) {
		offset_t offset = peHndl->getDisplayedOffset();
		sec = pePtr->getSecHdrAtOffset(offset, Executable::RAW);
		if (sec) {
			searchSigAction->setEnabled(true);
			searchSigAction->setText("Search for signatures in: ["+ sec->mappedName +"] from: " + QString::number(offset, 16).toUpper());
		} else {
			searchSigAction->setText("Search for signatures");
			searchSigAction->setEnabled(false);
		}
	}
	this->sectionMenu.sectionSelected(peHndl, sec);

	if (!isPe) {
		this->setWindowTitle(this->winDesc);
		return;
	}

	if (isChanged) {
		QString fName = " [" + peHndl->getFullName() + "]";
		this->setWindowTitle(this->winDesc + fName);
	}

	PEDockedWidget *p = rightPanel.getPeDockWidget(peHndl);
	if (!p) return;

	p->show();
	p->raise();
}

void MainWindow::onExeHandlerAdded(PeHandler* hndl)
{
	if (hndl == NULL) return;
	this->statusBar.showMessage("Loaded: "+ hndl->getFullName());
	this->loadTagsForPe(hndl);
}

int MainWindow::openMultiplePEs(QStringList fNames)
{
	PeHandler* lastHndl = NULL;
	int cntr = 0;
	QStringList::Iterator urlItr;
	const bool showAlert = fNames.size() > 1 ? false : true;
	
	for (urlItr = fNames.begin() ; urlItr != fNames.end(); urlItr++) {
		//QString fName = urlItr->toLocalFile();
		QString fName = *urlItr;
		PeHandler *loaded = loadPE(fName, showAlert);
		if (loaded) {
			cntr++;
			lastHndl = loaded;
		}
	}
	//set the last one as active:
	if (lastHndl) {
		this->sectionsTree.selectHandler(lastHndl);
	}
	return cntr;
}

void MainWindow::dropEvent(QDropEvent* ev) 
{ 
	QList<QUrl> urls = ev->mimeData()->urls();
	QList<QUrl>::Iterator urlItr;
	QCursor cur = this->cursor();
	this->setCursor(Qt::BusyCursor);
	
	QStringList fNames;
	for (urlItr = urls.begin() ; urlItr != urls.end(); urlItr++) {
		QString fName = urlItr->toLocalFile();
		fNames << fName;
	}

	const int cntr = openMultiplePEs(fNames);
	const int failed = fNames.size() - cntr;

	this->setCursor(cur);
	
	if (cntr > 1) {
		this->statusBar.showMessage("Loaded :"+ QString::number(cntr));
		QString loadedStr = "Loaded "+ QString::number(cntr);
		QString failedStr = "\nFailed to load: " + QString::number(failed);
		if (failed) loadedStr += failedStr;
		QMessageBox::information(this, "Done!", loadedStr);
	}
}

void MainWindow::setRegistryKey(bool enable)
{
	QString path = QApplication::applicationFilePath();
	for (int i = 0; i < path.size(); i++) {
		if (path[i] == '/') path[i] = '\\';
	}
	path = "\""+ path + "\"";
	
	QString accessErrInfo = "In order to do it you must run " + QString(TITLE) + " as administrator";

	bool isSet = false;
	const size_t extensionsCount = 4;
	std::string extensions[extensionsCount] = { "exe", "dll", "sys", "scr" }; 

	if (enable) {
		for (size_t i = 0; i < extensionsCount; i++) {
			isSet = RegKeyManager::addRegPath(extensions[i], TITLE, path.toStdString());
			if (!isSet) break;
		}
		if (!isSet) QMessageBox::warning(this, "Cannot set!", accessErrInfo);

	} else {
		for (size_t i = 0; i < extensionsCount; i++) {
			isSet = RegKeyManager::removeRegPath(extensions[i], TITLE);
			if (!isSet) break;
		}
		if (!isSet) QMessageBox::warning(this, "Cannot remove!", accessErrInfo);
	}

	this->setRegKeyAction->setChecked(isRegKey());
	if (isSet) {
		QMessageBox::information(this, "OK", "Done!");
	}
}

bool MainWindow::selectCurrentStyle()
{
	if (!this->stylesGroup) return false;
	
	QList<QAction *>actions = this->stylesGroup->actions();
	QList<QAction *>::iterator itr;
	for (itr = actions.begin(); itr != actions.end(); ++itr) {
		QAction *a = *itr;
		QString style = a->text();
		if (style == this->guiSettings.currentStyleName()) {
			a->setChecked(true);
			return true;
		}
	}
	return false;
}

bool MainWindow::isRegKey()
{
	bool isSet = false;
#ifdef _WINDOWS
	isSet = RegKeyManager::isKeySet("exe", TITLE);
#endif
	return isSet;
}

void MainWindow::autoSaveAllTags()
{
	if (this->mainSettings.isAutoSaveTags() == false) return;

	std::map<PEFile*, PeHandler*> &handlers = m_PEHandlers.getHandlersMap();
	std::map<PEFile*, PeHandler*>::iterator iter;
	for (iter = handlers.begin(); iter != handlers.end(); ++iter) {
		autoSaveTags(iter->second);
	}
}

void MainWindow::unloadAllPEs()
{
	std::map<PEFile*, PeHandler*> &handlers = m_PEHandlers.getHandlersMap();
	std::map<PEFile*, PeHandler*>::iterator iter;
	for (iter = handlers.begin(); iter != handlers.end();) {
		PeHandler *oldHndl = iter->second;
		++iter;
		closePE(oldHndl);
	}
	m_PEHandlers.clear();
}

void MainWindow::_reload(PeHandler* hndl, const bool isDeleted)
{
	if (!hndl) return;

	const QString path = hndl->getFullName();
	this->closePE(hndl);
	if (!isDeleted) {
		this->openPE(path);
	}
}

void MainWindow::reload(PeHandler* hndl)
{
	this->_reload(hndl,false);
}

void MainWindow::closePE(PeHandler* hndl)
{
	if (hndl == NULL) return;

	PEFile *oldPE = hndl->getPe();
	if (this->mainSettings.isAutoSaveTags()) {
		autoSaveTags(hndl);
	}
	this->rightPanel.removePeDockWidget(hndl);
	this->m_PEHandlers.removePe(oldPE);
	//---
	this->sectionsTree.expandAll();
}

void MainWindow::showEvent(QShowEvent * event)
{
	this->readPersistent();
	QMainWindow::showEvent(event);
}

void MainWindow::closeEvent(QCloseEvent *event)
{
	this->mainSettings.writePersistent();
	this->guiSettings.writePersistent();
	this->writePersistent();
	this->autoSaveAllTags();

	/* close all windows */
	diffWindow.close();
	secAddWindow.close();
	userConfigWindow.close();

	unloadAllPEs();
}

void MainWindow::info()
{
	QPixmap p(":/main_ico.ico");
	QString msg = "<b>" + QString::fromLatin1(TITLE) + " - Portable Executable reversing tool</b>";
	msg += "<br/>";
	msg += "version: " + currentVer.toString() + "\n";
	msg += "<br/>";
	msg += "built on: " + QString(__DATE__) + "\n";
	msg += "<br/>";
#ifdef COMMIT_HASH
	QString hash = QString(COMMIT_HASH);
	if (hash.length() > 0) {
		msg += "commit hash: " + QString(COMMIT_HASH) + "<br/>";
	}
#endif
	msg += "author: Hasherezade (<a href='" + QString(MY_SITE_LINK) + "'>homepage</a>)<br/>";
	msg += "Source code & more info: <a href='" + QString(SOURCE_LINK) + "'>here</a><br/>";
	msg += "<br/>";
	msg += "<i>using:</i><br/>";
#if QT_VERSION < 0x050000
	msg += "Qt 4";
#else
	msg += "Qt " + QString::number(QT_VERSION_MAJOR, 10) + "." + QString::number(QT_VERSION_MINOR, 10) + "." + QString::number(QT_VERSION_PATCH, 10);
#endif
	msg += "<br/>";
	msg += "bearparser";
	msg += " (<a href='" + QString(BEARPARSER_LICENSE) + "'>LICENSE</a>)<br/>";

#ifdef BUILD_WITH_UDIS86
	msg += "Udis86\n";
#else
	msg += "Capstone Engine";
	msg += " (<a href='" + QString(CAPSTONE_LICENSE) + "'>LICENSE</a>)";

	msg += "<br/><br/>";
#endif
	msg += "\nThis software is provided by the copyright holders and contributors \"as is\", without any warranty.";
	msg += "<br/>";

#if QT_VERSION < 0x050000
	msg += "\nWARNING: this is a legacy build with Qt4. The builds with Qt5 are recommened for the best user experience.";
#endif

	QMessageBox msgBox(this);
	msgBox.setProperty("hasUrl", true);

	msgBox.setWindowTitle("Info");
	msgBox.setTextFormat(Qt::RichText);

	msgBox.setText(msg);
	msgBox.setAutoFillBackground(true);
	msgBox.setIconPixmap(p);

	msgBox.setStandardButtons(QMessageBox::Ok);
	msgBox.exec();
}

void MainWindow::zoomFonts(bool zoomIn)
{
	guiSettings.zoomAllFonts(zoomIn);
}

void MainWindow::changeHexFont()
{
	bool ok = false;
	QFont font = QFontDialog::getFont( &ok, guiSettings.getHexViewFont(), this, tr("Pick a HexView font") );
	if (!ok) {
		return;
	}
	guiSettings.setHexViewFont(font);
}

void MainWindow::changeDisasmFont()
{
	bool ok = false;
	QFont font = QFontDialog::getFont( &ok, guiSettings.getDisasmViewFont(), this, tr("Pick a DisasmView font") );
	if (!ok) {
		return;
	}
	guiSettings.setDisasmViewFont(font);
}

void MainWindow::changeGlobalFont()
{
	bool ok = false;
	QFont font = QFontDialog::getFont( &ok, QApplication::font(), this, tr("Pick a Global font") );
	if (!ok) {
		return;
	}
	guiSettings.setGlobalFont(font);
}

void MainWindow::setDefaultFonts()
{
	this->guiSettings.resetFontsToDefaults();
}

void MainWindow::setDefaultZoom()
{
	this->guiSettings.resetSizesToDefaults();
}

void MainWindow::setSelectedStyle(QAction* pAction)
{
	Q_ASSERT(pAction);
	QString actionName = pAction->text();
	this->guiSettings.setStyleByName(actionName);
	if (actionName == this->guiSettings.currentStyleName()) {
		pAction->setChecked(true);
	}
}

void MainWindow::runNewInstance()
{
	const QString currentPath = QCoreApplication::instance()->applicationFilePath();
	QProcess::startDetached(currentPath);
}

void MainWindow::open()
{
	QString filter = "All Files (*);;Applications (*.exe);;Libraries (*.dll);;Drivers (*.sys);;Screensavers (*.scr)";
	QFileDialog dialog(NULL, "Open", QDir::homePath(), filter);
	dialog.setFileMode(QFileDialog::ExistingFiles);
	QStringList fNames = dialog.getOpenFileNames(NULL, "Open", this->mainSettings.lastExePath(), filter);

	if (fNames.size() == 0) {
		this->statusBar.showMessage("No file chosen");
		return;
	}
	openMultiplePEs(fNames);
}

bool MainWindow::openPE(QString fName)
{
	PeHandler* hndl = loadPE(fName, true);
	if (hndl) {
		this->sectionsTree.selectHandler(hndl);
		return true;
	}
	return false;
}

void MainWindow::onSigSearchResult(int foundCount, int reqType)
{
	if (reqType == 0) return;
	if (foundCount > 0) {
		QMessageBox::information(this, "Done!", "Found: " + QString::number(foundCount));
	} else {
		QMessageBox::information(this, "Done!", "Not found!");
	}
}

bool MainWindow::loadTagsForPe(PeHandler *hndl, QString name)
{
	if (!hndl) return false;
	
	if (name.length() == 0) {
		name = hndl->getFullName() + ".tag";
	}
	if (hndl->comments.loadFromFile(name)) {
		//printf("Tags loaded from file directory\n");
		return true;
	}
	name = this->mainSettings.userDataDir() + QDir::separator() + hndl->getShortName() + ".tag";
	if (hndl->comments.loadFromFile(name)) {
		//printf("Tags loaded from UDD\n");
		return true;
	}
	return true;
}

bool MainWindow::autoSaveTags(PeHandler *hndl)
{
	if (hndl == NULL) return false;

	QString name = hndl->getFullName() + ".tag";
	if (this->mainSettings.userDataDir().size() > 0) {
		name = this->mainSettings.userDataDir() + QDir::separator() + hndl->getShortName() + ".tag";
	}
	if (hndl->comments.saveToFile(name)) {
		//printf("Autosaved file");
	}
	return true;
}

ExeFactory::exe_type MainWindow::recognizeFileType(QString fName, const bool showAlert)
{
	if (!QFile::exists(fName)) {
		if (showAlert) QMessageBox::warning(this, "Open error!", "File does not exist:\n" + fName);
		return ExeFactory::NONE;
	}

	const bufsize_t mapSize = 0x1000; // no need to map full, first page is enough to recognize the type
	FileView* fileView = NULL;
	QString msg;
	try {
		fileView = new FileView(fName, mapSize);
	}
	catch (BufferException &e1) {
		msg = e1.getInfo();
		fileView = NULL;
	}
	if (!fileView) {
		if (showAlert) QMessageBox::warning(this, "Open error!", "Failed loading the file:\n" + fName + "\n" + msg);
		return ExeFactory::NONE;
	}

	ExeFactory::exe_type type = ExeFactory::findMatching(fileView);
	if (!this->m_PEHandlers.isSupportedType(type)) {
		QString msg = "Not supported filetype!";

		if (type != ExeFactory::NONE) {
			//if the type is recognized but not supported, show it:
			msg = "Not supported filetype: "
				+ ExeFactory::getTypeName(type);
		}
		this->statusBar.showMessage(msg + " [" + fName + "]");
		if (showAlert) QMessageBox::warning(this, "Cannot load!", "Cannot load:\n" + fName + "\n" + msg);
		type = ExeFactory::NONE;
	}
	delete fileView; fileView = NULL;
	return type;
}

PeHandler* MainWindow::loadPE(QString fName, const bool showAlert)
{
	QString link = QFile::symLinkTarget(fName);
	if (link.length() > 0) fName = link;

	if (this->m_PEHandlers.getByName(fName)) {
		this->statusBar.showMessage("File: [" + fName + "] is already loaded!");
		if (showAlert) QMessageBox::warning(this, tr(TITLE), "This file is already loaded!", QMessageBox::Ok);
		return NULL;
	}

	if (!QFile::exists(fName)) {
		if (showAlert) QMessageBox::warning(this, "Open error!", "Invalid path or access rights:\n" + fName);
		return NULL;
	}
	const ExeFactory::exe_type type = recognizeFileType(fName, showAlert);
	if (type == ExeFactory::NONE) {
		return NULL;
	}
	PeHandler *hndl = NULL;
	if (this->m_PEHandlers.openExe(fName, type, true)) {
		hndl = this->m_PEHandlers.getByName(fName);
		if (hndl) {
			this->statusBar.showMessage("File: " + fName);
			this->mainSettings.setLastExePath(fName);
			hndl->setPackerSignFinder(&this->vSign);
			connect(hndl, SIGNAL(foundSignatures(int, int)), this, SLOT(onSigSearchResult(int, int)));
		}
	}
	if (!hndl) {
		QString msg = "Error occured during loading the file: " + fName + "\nType: " + ExeFactory::getTypeName(type);
		this->statusBar.showMessage(msg + " [" + fName + "]");
		if (showAlert) QMessageBox::warning(this, "Cannot load!", msg);
		return NULL;
	}
	if (hndl->getPe()->isTruncated()) {
		QString alert = "The file: \n " + fName + "\n is too big and was loaded truncated!";
		QMessageBox::StandardButton res = QMessageBox::warning(this, "Too big file!", alert, QMessageBox::Ok);
	}
	return hndl; 
}

void MainWindow::openSignatures()
{
	QString filter = "Text Files (*.txt);;All Files (*)";
	QString fName= QFileDialog::getOpenFileName(NULL, "Open file with signatures", NULL, filter);
	std::string filename = fName.toStdString();

	if (filename.length() > 0) {
		int i = vSign.loadSignatures(filename);
		QMessageBox msgBox;
		msgBox.setText("Added new signatures: " + QString::number(i));
		msgBox.exec();
	}//
	this->m_PEHandlers.checkAllSignatures();

}
//----
void MainWindow::savePE(PeHandler* selectedPeHndl)
{
	if (!selectedPeHndl) return;

	PEFile *pe = selectedPeHndl->getPe();
	if (!pe) return;

	QString filter = "All Files (*);;Applications (*.exe);;Libraries (*.dll);;Drivers (*.sys);;Screensavers (*.scr)";
	QString filename = QFileDialog::getSaveFileName(NULL, "Save as...", selectedPeHndl->getDirPath(), filter);
	if (filename.size() == 0) return;

	bufsize_t dSize = FileBuffer::dump(filename, *pe);
	if (dSize) {
		QMessageBox::information(this,"Success","Dumped PE to: " + filename);
	} else {
		QMessageBox::warning(this,"Failed", "Dumping failed!");
	}
}

QString MainWindow::chooseDumpOutDir(PeHandler *selectedPeHndl)
{
	const QString EMPTY_STR = "";
	if (!selectedPeHndl) return EMPTY_STR;
	//---
	QFileDialog dialog;
	dialog.setFileMode(QFileDialog::Directory);
	dialog.setOption(QFileDialog::ShowDirsOnly, true);

	QString dirPathStr = this->mainSettings.dirDump;
	QString currentPeDir = selectedPeHndl->getDirPath();

	if (dirPathStr == "") dirPathStr = currentPeDir;
	dialog.setDirectory(dirPathStr);
	int ret = dialog.exec();

	if((QDialog::DialogCode) ret != QDialog::Accepted) return EMPTY_STR;
	//---
	QDir dir = dialog.directory();
	QString fName = dir.absolutePath();
	if (fName.length() > 0) {
		dirPathStr = fName;
		if (dirPathStr != currentPeDir) this->mainSettings.dirDump = dirPathStr;
	}
	return dirPathStr;
}

void MainWindow::dumpAllSections(PeHandler* selectedPeHndl)
{
	if (!selectedPeHndl) return;
	PEFile *pe = selectedPeHndl->getPe();
	if (!pe) return;

	QString dirPath = chooseDumpOutDir(selectedPeHndl);
	if (dirPath.length() == 0) return;

	size_t dumped = 0;
	size_t count = pe->getSectionsCount();
	for (size_t i = 0; i < count; ++i) {
		SectionHdrWrapper *sec = pe->getSecHdr(i);
		if (!sec) continue;

		QString secName = sec->mappedName;
		QString fileName = dirPath + QDir::separator() + selectedPeHndl->getShortName() + "[" + secName + "]";
		if (pe->dumpSection(sec, fileName)) dumped++;
	}
	if (dumped > 0) {
		QMessageBox::information(this, "Done!", "Dumped: " + QString::number(dumped)
			+ " out of " + QString::number(count) + " sections into:\n" + dirPath);
	}
	else {
		QMessageBox::warning(this, "Error", "Dumping sections failed!");
	}
}

void MainWindow::addSection(PeHandler* selectedPeHndl)
{
	if (!selectedPeHndl) return;
	emit addSectionRequested(selectedPeHndl);
	return;
}

void MainWindow::sigSearch(PeHandler* selectedPeHndl)
{
	if (!selectedPeHndl) return;

	offset_t offset = selectedPeHndl->getDisplayedOffset();
	SectionHdrWrapper *sec = selectedPeHndl->getPe()->getSecHdrAtOffset(offset, Executable::RAW, false);
	if (sec == NULL) {
		QMessageBox::warning(this, "Cannot search!", "No section selected");
		return;
	}
	offset_t secBgn = sec->getContentOffset(Executable::RAW, true);
	bufsize_t size = sec->getContentSize(Executable::RAW, true);
	if (secBgn == INVALID_ADDR || offset < secBgn) {
		return;
	}
	size = size - (offset - secBgn);
	selectedPeHndl->findPackerInArea(offset, size, sig_ma::FRONT_TO_BACK);
}

```

`pe-bear/gui/windows/MainWindow.h`:

```h
#pragma once

#ifdef WITH_QT5
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>
#include <sig_finder.h>

#include "../../base/BearVers.h"

#include "DiffWindow.h"
#include "SectionAddWindow.h"
#include "SignaturesBrowseWindow.h"
#include "UserConfigWindow.h"

#include "../../SectionsDiagram.h"
#include "../../PEFileTreeModel.h"
#include "../../HexView.h"
#include "../../DisasmView.h"
#include "../../PEDockedWidget.h"

#include "../../gui_base/PEViewsManager.h"
#include "../../base/MainSettings.h"

#include "../../ViewSettings.h"

//----------------------------------------------

class MainWindow : public QMainWindow
{
	Q_OBJECT

public:
	MainWindow(QWidget *parent = 0);
	~MainWindow() { stopTimer(); }

	bool openPE(QString name);
	int openMultiplePEs(QStringList fNames);
	
signals:
	void addSectionRequested(PeHandler *peHndl);

public slots:
	void onSigSearchResult(int foundCount, int reqType);
	void runNewInstance();
	void unloadAllPEs();
	void open();
	void closePE(PeHandler*);
	void reload(PeHandler*);
	void savePE(PeHandler* selectedPeHndl);
	void dumpAllSections(PeHandler* );
	void addSection(PeHandler* );
	void sigSearch(PeHandler* );

	void openSignatures();

	void viewSignatures()
	{
		signWindow.show();
		signWindow.raise();
	}

	void info();

	void openDiffWindow()
	{
		this->diffWindow.show();
		this->diffWindow.raise(); 
	}

	// zooming:
	void zoomFonts(bool zoomIn);
	void zoomInFonts() { zoomFonts(true); }
	void zoomOutFonts() { zoomFonts(false); }

	// font switching:
	void changeHexFont();
	void changeDisasmFont();
	void changeGlobalFont();
	void setDefaultFonts();
	void setDefaultZoom();

	// style switching:
	void setSelectedStyle(QAction* a);

protected slots:
	void onExeHandlerAdded(PeHandler*);
	void onHandlerSelected(PeHandler*);
	
	void onTimeout();

	void setRegistryKey(bool enable);
	void editAppearance()
	{
		userConfigWindow.show();
		userConfigWindow.raise(); 
	}

protected:
	void _reload(PeHandler*, const bool isDeleted);

	/* events */
	
	virtual void wheelEvent(QWheelEvent* event)
	{
		if (QApplication::keyboardModifiers() & Qt::ControlModifier ) {
			if(event->delta() > 0) {
				zoomFonts(true);
			} else {
				zoomFonts(false);
			}
			return;
		}
		return QMainWindow::wheelEvent(event);
	}

	void dragEnterEvent(QDragEnterEvent* event) { event->accept(); }
	void dropEvent(QDropEvent* event);
	void showEvent(QShowEvent * event);
	void closeEvent(QCloseEvent *event);

	PeHandler* loadPE(QString name, const bool showAlert);

	bool loadTagsForPe(PeHandler *hndl, QString name = "");
	void autoSaveAllTags();
	bool autoSaveTags(PeHandler *hndl);
	bool isRegKey();
	bool selectCurrentStyle();

	QString chooseDumpOutDir(PeHandler *);
	void reloadFile(const QString &path, const bool isDeleted);
	bool checkFileChanges(const QString &path);

private:

	ExeFactory::exe_type recognizeFileType(QString name, const bool showAlert);
	bool readPersistent();
	bool writePersistent();

	void connectSignals();
	void setupLayout();
	void setupWidgets();
	
	void createActions();
	void createTreeActions();
	void createMenus();
	
	void startTimer();
	void stopTimer();
	
//---
	pe_bear::BearVers currentVer;

	PeHandler *m_PeHndl;
	QTimer m_Timer;

	sig_ma::SigFinder vSign;
	MainSettings mainSettings;
	GuiSettings guiSettings;

	QString winDesc;

	QSplitter mainSplitter;
	PEViewsManager rightPanel;
	PeHandlersManager m_PEHandlers;

	DiffWindow diffWindow;
	SectionAddWindow secAddWindow;

	QStatusBar statusBar;
	QGridLayout cntntLayout;

	PEStructureView sectionsTree;
	ExeDependentMenu sectionsTreeMenu;
	SectionMenu sectionMenu;

	PEFileTreeModel* peFileModel;

	//-------------------------
	QLabel urlLabel;

	QMenu *fileMenu, 
		*settingsMenu,
		*viewMenu,
		*signaturesMenu;

	QActionGroup *stylesGroup;

	QAction *openDiffWindowAction,
		*newInstance,
		*openAction,
		*unloadAllAction,
		*openSignAction,
		*viewSignAction,
		*infoAction,
		*setRegKeyAction,
		*hexViewFontAction,
		*disasmViewFontAction,
		*globalFontAction,
		*defaultFontsAction,
		*zoomInAction, *zoomOutAction, *zoomDefault,
		*darkStyle, *defaultStyle;

	ExeDependentAction *dumpAllSecAction,
		*addSecAction,
		*saveAction,
		*searchSigAction,
		*unloadAction,
		*reloadAction;

	SignaturesBrowseWindow signWindow;
	UserConfigWindow userConfigWindow;
};

```

`pe-bear/gui/windows/OffsetsBrowseWindow.cpp`:

```cpp
#include "OffsetsBrowseWindow.h"
#include <bearparser/Util.h>

//-------------------------

QVariant OffsetsBrowseModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	if (orientation == Qt::Horizontal) {
		switch (section) {
			case COL_OFFSET : return "RVA";
			case COL_ID : return "ID";
			case COL_NAME : return "Comment";
		}
	}
	return QVariant();
}

Qt::ItemFlags OffsetsBrowseModel::flags(const QModelIndex &index) const
{	
	if (!index.isValid()) return Qt::NoItemFlags;
	Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	if (index.column() == COL_NAME) return fl | Qt::ItemIsEditable;
	return fl;
}

int OffsetsBrowseModel::rowCount(const QModelIndex &parent) const 
{
	CommentHandler &cHndl = myPeHndl->comments;
	size_t num = cHndl.commentsVec.size();
	return num;
}

QVariant OffsetsBrowseModel::data(const QModelIndex &index, int role) const
{
	if (myPeHndl == NULL) return QVariant();
	if (role == Qt::ForegroundRole) return this->addrColor(index);

	int row = index.row();
	int column = index.column();
	
	CommentHandler &cHndl = myPeHndl->comments;
	if (row >= cHndl.commentsVec.size()) return QVariant();

	Comment *cmnt = cHndl.commentsVec[row];
	if (cmnt == NULL) return QVariant();

	if (role == Qt::BackgroundColorRole && column == COL_OFFSET) {
		Executable::addr_type aT = addrTypeAt(index);
		if (m_PE->toRaw(cmnt->offset, aT) == INVALID_ADDR) return this->errColor;
	}
	if (role != Qt::DisplayRole && role != Qt::EditRole && role != Qt::ToolTipRole) return QVariant();

	switch (column) {
			case COL_OFFSET :
				return QString::number(cmnt->offset, 16);
			case COL_ID : 
				return cmnt->id;
			case COL_NAME : 
				return cmnt->content;
	}
	return QVariant();
}

bool OffsetsBrowseModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (myPeHndl == NULL) return false;

	int row = index.row();
	int column = index.column();
	if (column != COL_NAME) return false;

	Comment *cmnt = myPeHndl->comments.commentsVec[row];
	if (cmnt == NULL) return false;

	myPeHndl->comments.setComment(cmnt->offset, value.toString());
	return true;
}

offset_t OffsetsBrowseModel::getFieldOffset(QModelIndex index) const
{
	if (myPeHndl == NULL) return INVALID_ADDR;

	CommentHandler &cHndl = myPeHndl->comments;
	Comment *cmnt = cHndl.commentsVec[index.row()];
	if (cmnt == NULL) return INVALID_ADDR;

	return m_PE->toRaw(cmnt->offset, Executable::RVA);
}

bufsize_t OffsetsBrowseModel::getFieldSize(QModelIndex index) const
{
	return 1;
}
//------------------------------------------------------------------------------------

OffsetsBrowseWindow::OffsetsBrowseWindow(PeHandler *peHndlr, QWidget *parent)
    : QMainWindow(parent), tagsTree(this), commentsView(NULL), tagModel(NULL)
{
	if (peHndlr == NULL) return;
	this->commentsView = new CommentView(peHndlr, this);

	setAcceptDrops(true);

	QPixmap tagIco(":/icons/star.ico");
	setWindowIcon(tagIco);
	setWindowTitle("Tags of ["+ peHndlr->getFullName()+"]");

	createMenu();
	this->tagModel = new OffsetsBrowseModel(peHndlr, this);
	tagsTree.setModel(tagModel);
	//tagsTree.setSortingEnabled(true);
	setCentralWidget(&tagsTree);

	CommentHandler &cHndl = peHndlr->comments;
	connect(&cHndl, SIGNAL(commentsUpdated()), tagModel, SLOT(onNeedReset()));
}

OffsetsBrowseWindow::~OffsetsBrowseWindow()
{
	delete this->tagModel;
	delete this->commentsView;
}

void OffsetsBrowseWindow::createMenu()
{
	// tag menu
	QMenu* tagSubmenu = menuBar()->addMenu("File");

	QAction* loadCommentAction = new QAction("Load", tagSubmenu);
	connect(loadCommentAction, SIGNAL(triggered()), this, SLOT(onLoadComment()));
	tagSubmenu->addAction(loadCommentAction);
	
	QAction* saveCommentAction = new QAction("Save", tagSubmenu);
	connect(saveCommentAction, SIGNAL(triggered()), this, SLOT(onSaveComment()));
	tagSubmenu->addAction(saveCommentAction);
}

void OffsetsBrowseWindow::dropEvent(QDropEvent* ev) 
{
	if (!commentsView) return;

    QList<QUrl> urls = ev->mimeData()->urls();
	QList<QUrl>::Iterator urlItr;
	QCursor cur = this->cursor();
	this->setCursor(Qt::BusyCursor);

	bool loaded = false;
	//try to load any from tre list, till the first success
	for (urlItr = urls.begin() ; urlItr != urls.end(); urlItr++) {
        QString fName = urlItr->toLocalFile();
		if (commentsView->loadComments(fName) == true) {
			loaded = true;
			break;
		}
    }
	this->setCursor(cur);

	if (loaded == false) {
		QMessageBox::warning(this, "Failed", "Loading failed!", QMessageBox::Ok);
	}
}

```

`pe-bear/gui/windows/OffsetsBrowseWindow.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>

#include "../../base/PeHandlersManager.h"
#include "../../gui_base/FollowablePeTreeView.h"
#include "../../gui_base/OffsetDependentAction.h"
#include "../../gui/CommentView.h"

//----------------------------------------------------

class OffsetsBrowseModel : public PeTableModel
{
	Q_OBJECT

public:
	OffsetsBrowseModel(PeHandler *peHndl, QObject *parent = 0)
		: PeTableModel(peHndl, parent) {}

	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;

	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	int rowCount(const QModelIndex &parent) const;

	virtual Executable::addr_type addrTypeAt(QModelIndex index) const 
	{
		return (index.column() == COL_OFFSET) ? Executable::RVA : Executable::NOT_ADDR;
	}

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int);

	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const
	{
		return createIndex(row, column); //no index item pointer
	}
	
	QModelIndex parent(const QModelIndex &index) const
	{
		return QModelIndex();
	}

	offset_t getFieldOffset(QModelIndex index) const;
	bufsize_t getFieldSize(QModelIndex index) const;

	enum COLS {
		COL_OFFSET = 0,
		COL_ID,
		COL_NAME,
		MAX_COL
	};

};

//----------------------------------------------------

class OffsetsBrowseWindow : public QMainWindow
{
    Q_OBJECT

protected slots:
	void onSaveComment()
	{
		if (this->commentsView) this->commentsView->onSaveComments();
	}

	void onLoadComment()
	{
		if (this->commentsView) this->commentsView->onLoadComments();
	}

public:
	OffsetsBrowseWindow(PeHandler *peHndlr, QWidget *parent);
	virtual ~OffsetsBrowseWindow();

protected:
	/* events */
	void dragEnterEvent(QDragEnterEvent* ev) { ev->accept(); }
    void dropEvent(QDropEvent* event);

private:
	void createMenu();
	FollowablePeTreeView tagsTree;
	CommentView *commentsView;
	OffsetsBrowseModel *tagModel;

};

```

`pe-bear/gui/windows/SectionAddWindow.cpp`:

```cpp
#include "SectionAddWindow.h"

#define EMPTY_FILE_TXT "Load from file"


SectionAddWindow::SectionAddWindow(QWidget *parent)
	: QDialog(0, Qt::Dialog),
	currPeHndl(NULL)
{
	//setWindowFlags(Qt::Dialog);
	setModal(true);
	
	secVsizeEdit.setMaximum(0);
	secRsizeEdit.setMaximum(0);

	this->fileButton.setText("Choose a file");
	connect(&fileButton, SIGNAL(clicked()), this, SLOT(onFileChose()));
	this->fileCBox.setText(EMPTY_FILE_TXT);
	this->fileCBox.setChecked(false);

	QHBoxLayout *fLayout = new QHBoxLayout();
	fLayout->addWidget(&fileCBox);
	fLayout->addWidget(&fileButton);
	topLayout.addLayout(fLayout);

	secNameLabel.setText(tr("Section name:"));
	secNameLabel.setBuddy(&secNameEdit);
	secPropertyLayout3.addWidget(&secNameLabel);
	secPropertyLayout3.addWidget(&secNameEdit);
	topLayout.addLayout(&secPropertyLayout3);

	secRsizeLabel.setText(tr("Raw size:"));
	secRsizeLabel.setBuddy(&secRsizeEdit);
	secPropertyLayout.addWidget(&secRsizeLabel);
	secPropertyLayout.addWidget(&secRsizeEdit);
	topLayout.addLayout(&secPropertyLayout);

	secVsizeLabel.setText(tr("Virtual size:"));
	secVsizeLabel.setBuddy(&secVsizeEdit);
	secPropertyLayout2.addWidget(&secVsizeLabel);
	secPropertyLayout2.addWidget(&secVsizeEdit);
	topLayout.addLayout(&secPropertyLayout2);
	
	okButton.setText(tr("OK"));
	okButton.setDefault(true);
	cancelButton.setText(tr("Cancel"));

	//READ = 0, WRITE, EXEC
	rightsCBox[READ].setText("read");
	rightsCBox[WRITE].setText("write");
	rightsCBox[EXEC].setText("execute");

	QHBoxLayout *rightsLayout = new QHBoxLayout();
	topLayout.addLayout(rightsLayout);
	for (int i = 0; i < ACCESS_NUM ; i++) {
		rightsLayout->addWidget(&rightsCBox[i]);
	}
	buttonLayout.addWidget(&okButton);
	buttonLayout.addWidget(&cancelButton);
	topLayout.addLayout(&buttonLayout);

	topLayout.addStretch();
	setLayout(&topLayout);
	setWindowTitle(tr("Add a new section"));

	connect(&okButton, SIGNAL(clicked()),this, SLOT(onOkClicked() ));
	connect(&cancelButton, SIGNAL(clicked()),this, SLOT(close()));
}

void SectionAddWindow::onAddSectionToPe(PeHandler *peHndl)
{
	if (!peHndl) return;
	PEFile *pe = peHndl->getPe();
	if (!pe) return;

	currPeHndl = peHndl;
	int max = INT_MAX;
	secRsizeEdit.setMaximum(max);
	secVsizeEdit.setMaximum(max);
	this->show();
}

void SectionAddWindow::onFileChose()
{
	QString path = QFileDialog::getOpenFileName(NULL, "Open section file", NULL, NULL);
	if (path.length() == 0) {
		this->fileCBox.setText(EMPTY_FILE_TXT);
		return;
	}

	QFile file(path);
	if (file.open(QFile::ReadOnly) == false) {
		QMessageBox::warning(this, "Error", "Cannot read this file");
		this->fileCBox.setText(EMPTY_FILE_TXT);
		return;
	}
	long fSize = FileBuffer::getReadableSize(file);
	file.close();

	this->filePath = path;
	if (fSize < 0) fSize = 0; //invalid size!

	this->fileCBox.setText(this->filePath);
	this->fileCBox.setChecked(true);

	this->secRsizeEdit.setValue(fSize);
	this->secVsizeEdit.setValue(fSize);
	
	return;
}

void SectionAddWindow::onOkClicked()
{
	uint32_t rVal = this->secRsizeEdit.value();
	uint32_t vVal = this->secVsizeEdit.value();
	QString name = this->secNameEdit.text();
	if (!currPeHndl) return;
	
	uint64_t loadedSize = 0;

	DWORD accessRights = 0;
	if (rightsCBox[READ].checkState() == Qt::Checked) accessRights |= SCN_MEM_READ;
	if (rightsCBox[WRITE].checkState() == Qt::Checked) accessRights |= SCN_MEM_WRITE;
	if (rightsCBox[EXEC].checkState() == Qt::Checked) accessRights |= SCN_MEM_EXECUTE;

	SectionHdrWrapper* sec = NULL;
	try {
		sec = currPeHndl->addSection(name, rVal, vVal);
		if (!sec) throw CustomException("Cannot add a new section");

		sec->setNumValue(SectionHdrWrapper::CHARACT, accessRights);

		if (this->filePath.length() && this->fileCBox.isChecked()) {

			QFile file(this->filePath);
			if (file.open(QFile::ReadOnly) == false) {
				QMessageBox::warning(this, "Error", "Cannot read this file");
				this->fileCBox.setText(EMPTY_FILE_TXT);
				return;
			}
			loadedSize = currPeHndl->loadSectionContent(sec, file, true);
			file.close();
			sec = NULL;// after reloading PEFile, pointer is no longer valid
		}
	} catch (CustomException e) {
		QMessageBox::critical(this, "Error", e.what());
		return;
	}

	QMessageBox::information(this, "Success!", "Section "+ name +" added!");
	this->hide();
}
```

`pe-bear/gui/windows/SectionAddWindow.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../../base/PeHandlersManager.h"
#include "../../gui_base/HexSpinBox.h"

class SectionAddWindow : public QDialog
{
	Q_OBJECT

public:
	SectionAddWindow(QWidget *parent);
	~SectionAddWindow() { }

public slots:
	void onAddSectionToPe(PeHandler *peHndl);
	void onOkClicked();
	void onFileChose();

protected:
	QVBoxLayout topLayout;
	QHBoxLayout secPropertyLayout;
	QHBoxLayout secPropertyLayout2;
	QHBoxLayout secPropertyLayout3;
	QHBoxLayout buttonLayout;

	QLabel secRsizeLabel;
	HexSpinBox secRsizeEdit;

	QLabel secVsizeLabel;
	HexSpinBox secVsizeEdit;
	
	QLabel secNameLabel;
	QLineEdit secNameEdit;

	enum access { READ = 0, WRITE, EXEC, ACCESS_NUM };
	QCheckBox fileCBox;
	QCheckBox rightsCBox[ACCESS_NUM];

	QPushButton fileButton, okButton, cancelButton;
	PeHandler *currPeHndl;
	QString filePath;
};

```

`pe-bear/gui/windows/SignaturesBrowseWindow.cpp`:

```cpp
#include "SignaturesBrowseWindow.h"

#include <bearparser/Util.h>

using namespace std;


SignaturesBrowseModel::SignaturesBrowseModel(sig_ma::SigFinder *signs, QObject *parent)
	: QAbstractTableModel(parent)
{
	this->signs = signs;
}

QVariant SignaturesBrowseModel::headerData(int section, Qt::Orientation orientation, int role) const
{
	if (role != Qt::DisplayRole) return QVariant();
	if (orientation == Qt::Horizontal) {
		switch (section) {
			case COL_ID: return "ID";
			case COL_NAME : return "Name";
			case COL_SIZE: return "Size";
			case COL_PREVIEW: return "Signature Content Preview";
		}
	}
	return QVariant();
}

Qt::ItemFlags SignaturesBrowseModel::flags(const QModelIndex &index) const
{	
	if (!index.isValid()) return Qt::NoItemFlags;
	Qt::ItemFlags fl = Qt::ItemIsEnabled | Qt::ItemIsSelectable;
	return fl;
}

int SignaturesBrowseModel::rowCount(const QModelIndex &parent) const 
{
	if (!signs) return 0;
	size_t sigCount = this->signs->signaturesVec().size();
	return sigCount;
}

QVariant SignaturesBrowseModel::data(const QModelIndex &index, int role) const
{
	int row = index.row();
	int column = index.column();
	
	if (role != Qt::DisplayRole && role != Qt::EditRole && role != Qt::ToolTipRole) return QVariant();

	std::vector<sig_ma::PckrSign*> &vec = this->signs->signaturesVec();

	if ((size_t)row >= vec.size()) return QVariant();

	sig_ma::PckrSign* sign = vec[row];
	if (sign == NULL) return QVariant();

	switch (column) {
		case COL_ID:
			return row;
		case COL_NAME : 
			return QString::fromStdString(sign->getName());
		case COL_SIZE: 
			return  (qulonglong)sign->length();
		case COL_PREVIEW:
			return QString::fromStdString(sign->getContent());
	}
	return QVariant();
}

//------------------------------------------------------------------------------------

SignaturesBrowseWindow::SignaturesBrowseWindow(sig_ma::SigFinder* vSign, QWidget *parent)
	: QMainWindow(parent), signsTree(this), vSign(NULL)
{
	if (vSign == NULL) return;
	this->vSign = vSign;
	//---
	SignaturesBrowseModel *sigModel = new SignaturesBrowseModel(vSign, this);
	signsTree.setModel(sigModel);
	signsTree.setItemsExpandable(false);
	signsTree.setRootIsDecorated(false);
	setCentralWidget(&signsTree);
	//---
	createMenu();
	connect(sigModel, SIGNAL(modelUpdated()), &signsTree, SLOT(reset()));
	connect(this, SIGNAL(signaturesUpdated()), sigModel, SLOT(onNeedReset()));
}

void SignaturesBrowseWindow::createMenu()
{
	QMenu* fileSubmenu = menuBar()->addMenu("File");
	QAction* loadAction = new QAction("Load", fileSubmenu);
	connect(loadAction, SIGNAL(triggered()), this, SLOT(openSignatures()));
	fileSubmenu->addAction(loadAction);
}

void SignaturesBrowseWindow::openSignatures()
{
	QString filter = "Text Files (*.txt);;All Files (*)";
	QString fName= QFileDialog::getOpenFileName(NULL, "Open file with signatures", NULL, filter);
	std::string filename = fName.toStdString();

	if (filename.length() > 0) {
		int i = vSign->loadSignatures(filename);
		emit signaturesUpdated();
		//---
		QMessageBox msgBox;
		msgBox.setText("Added new signatures: " + QString::number(i));
		msgBox.exec();
	}
	//todo: emit -> signatures loaded
}

```

`pe-bear/gui/windows/SignaturesBrowseWindow.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>

#include "../../base/PeHandlersManager.h"
#include "../../gui_base/FollowablePeTreeView.h"
#include "../../gui_base/OffsetDependentAction.h"
#include "../../gui/CommentView.h"

//----------------------------------------------------

class SignaturesBrowseModel : public QAbstractTableModel
{
	Q_OBJECT

signals:
	void modelUpdated();

protected slots:
	virtual void onNeedReset() { reset(); emit modelUpdated(); }

public:
	SignaturesBrowseModel(sig_ma::SigFinder *signs, QObject *parent = 0);
	
	QVariant headerData(int section, Qt::Orientation orientation, int role) const;
	Qt::ItemFlags flags(const QModelIndex &index) const;
	
	int columnCount(const QModelIndex &parent) const { return MAX_COL; }
	int rowCount(const QModelIndex &parent) const;//{ return INFO_COUNTER; }

	QVariant data(const QModelIndex &index, int role) const;
	bool setData(const QModelIndex &, const QVariant &, int) { return false; }

	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const { return createIndex(row, column); } //no index item pointer
	QModelIndex parent(const QModelIndex &index) const { return QModelIndex(); } // no parent

	enum COLS {
		COL_ID = 0,
		COL_NAME,
		COL_SIZE,
		COL_PREVIEW,
		MAX_COL
	};

protected:
	void reset()
	{
		//>
		this->beginResetModel();
		this->endResetModel();
		//<
	}

	sig_ma::SigFinder *signs;
};

//----------------------------------------------------

class SignaturesBrowseWindow : public QMainWindow
{
    Q_OBJECT

signals:
	void signaturesUpdated();

public slots:
	void openSignatures();

public:
	SignaturesBrowseWindow(sig_ma::SigFinder *vSign, QWidget *parent);

private:
	void createMenu();

	QTreeView signsTree;
	sig_ma::SigFinder* vSign;
};


```

`pe-bear/gui/windows/UserConfigWindow.cpp`:

```cpp
#include "UserConfigWindow.h"
#include <bearparser/Util.h>
#include <QtGlobal>

DirEdit::DirEdit(QWidget* parent)
	: QLineEdit(parent)
{
	connect(this, SIGNAL(textChanged(const QString &)), this, SLOT(validateDir(const QString &)) );
}

void DirEdit::validateDir(const QString &input)
{
	QDir dir(input);
	if (dir.exists() == false) {
		this->setStyleSheet("border: 2px solid red;");
	} else {
		this->setStyleSheet("");
	}
}
//-----------------------------------------------------------------------------------

UserConfigWindow::UserConfigWindow(QWidget *parent)
    : QDialog(parent), settings(NULL)
{
	setWindowTitle(tr("Configure..."));
	setMinimumWidth(270);
	setLayout(&topLayout);

	dirButton.setText("Open");
	connect(&dirButton, SIGNAL(clicked()), this, SLOT(onDirChose()));
	
	QHBoxLayout *fLayout1 = new QHBoxLayout();
	QHBoxLayout *fLayout2 = new QHBoxLayout();
	uddDirLabel.setText("User Data Directory: ");
	topLayout.addWidget(&uddDirLabel);
	fLayout1->addWidget(&uddDirEdit);
	fLayout1->addWidget(&dirButton);

	reloadFileLabel.setText("Reload file on change? ");
	reloadFileStates.addItem("Ignore  ", RELOAD_IGNORE);
	reloadFileStates.addItem("Ask     ", RELOAD_ASK);
	reloadFileStates.addItem("Reload  ", RELOAD_AUTO);
	
	fLayout2->addWidget(&reloadFileLabel);
	fLayout2->addWidget(&reloadFileStates);
	fLayout2->setSizeConstraint(QLayout::SetMaximumSize);
	
	autoSaveTagsCBox.setText("Auto-save tags");
	QHBoxLayout *buttonLayout = new QHBoxLayout();
	okButton.setText("Save");
	connect(&okButton, SIGNAL(clicked()), this, SLOT(onOkClicked()));

	cancelButton.setDefault(true);
	cancelButton.setText("Cancel");
	connect(&cancelButton, SIGNAL(clicked()), this, SLOT(hide()));

	buttonLayout->addWidget(&okButton);
	//buttonLayout->addStretch();
	buttonLayout->addWidget(&cancelButton);

	topLayout.addLayout(fLayout1);
	topLayout.addWidget(&autoSaveTagsCBox);
	topLayout.addLayout(fLayout2);
	topLayout.addStretch();
	topLayout.addLayout(buttonLayout);

	uddDirEdit.setAutoFillBackground(true);
	setAutoFillBackground(true);
}

void UserConfigWindow::setMainSettings(MainSettings *settings)
{
	this->settings = settings;
	if (this->isVisible()) {
		refrehSettingsView();
	}
}

void UserConfigWindow::setReloadMode(const t_reload_mode rMode)
{
	int index = reloadFileStates.findData(rMode, Qt::UserRole);
	if ( index != -1 ) { // -1 for not found
	   reloadFileStates.setCurrentIndex(index);
	}
}

t_reload_mode UserConfigWindow::getReloadMode()
{
	t_reload_mode rMode = RELOAD_ASK;
#if QT_VERSION >= 0x050000
	rMode = intToReloadMode(reloadFileStates.currentData(Qt::UserRole).toInt());
	return rMode;
#else
	int index = intToReloadMode(reloadFileStates.currentIndex());
	rMode = intToReloadMode(reloadFileStates.itemData(index,Qt::UserRole).toInt());
#endif
	return rMode;
}

void UserConfigWindow::refrehSettingsView()
{
	if (settings == NULL) return;
	uddDirEdit.setText(settings->userDataDir());
	autoSaveTagsCBox.setChecked(settings->isAutoSaveTags());
	
	setReloadMode(settings->isReloadOnFileChange());
}

void UserConfigWindow::onOkClicked()
{
	QString fName = uddDirEdit.text();
	this->settings->setUserDataDir(fName);
	this->settings->setAutoSaveTags(autoSaveTagsCBox.isChecked());

	const t_reload_mode rMode = getReloadMode();
	this->settings->setReloadOnFileChange(rMode);
	this->settings->writePersistent();
	this->hide();
}

void UserConfigWindow::onDirChose()
{
	QFileDialog dialog;
	dialog.setFileMode(QFileDialog::Directory);
	dialog.setOption(QFileDialog::ShowDirsOnly, true);
	dialog.setDirectory(settings->userDataDir());
	if (dialog.exec()) {
		QDir dir = dialog.directory();
		QString fName = dir.absolutePath();
		if (fName.length() > 0) {
			uddDirEdit.setText(fName);
		}
	}
}

```

`pe-bear/gui/windows/UserConfigWindow.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "../../base/MainSettings.h"

//----------------------------------------------------

class DirEdit : public QLineEdit
{
	Q_OBJECT
public:
	DirEdit(QWidget* parent = 0);

protected slots:
	void validateDir(const QString &path);
};

//----------------------------------------------------

class UserConfigWindow : public QDialog
{
    Q_OBJECT

public:
	UserConfigWindow(QWidget *parent = 0);
	void setMainSettings(MainSettings *settings);

	t_reload_mode getReloadMode();
	void setReloadMode(const t_reload_mode rMode);

protected slots:
	void refrehSettingsView();
	void onDirChose();

private slots:
	void onOkClicked();

protected:
	void showEvent(QShowEvent * ev) { refrehSettingsView(); QDialog::showEvent(ev); }

private:
	QVBoxLayout topLayout;
	QPushButton dirButton, okButton, cancelButton;
	QLabel uddDirLabel;
	DirEdit uddDirEdit;
	
	QLabel reloadFileLabel;
	QComboBox reloadFileStates;
	QCheckBox autoSaveTagsCBox;

	MainSettings *settings;
};


```

`pe-bear/gui_base/AddressInputDialog.cpp`:

```cpp
#include "AddressInputDialog.h"
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif
//-----------

AddressInputDialog::AddressInputDialog(Executable *exe, bool isRaw, ColorSettings &_addrColors, QWidget *parent)
	: HexInputDialog("Go to address", "Address (hex):", parent),
	myExe(exe), isRawAddr(isRaw),
	addrColors(_addrColors),
	cbox_isRva(NULL), otherCaptionLabel(NULL), otherEdit(NULL)
{
	this->setMinimumSize( QSize(250, 150) );
	cbox_isRva = new QCheckBox("+ ImageBase (RVA -> VA)");
	if (!isRawAddr) {
		layout_middleBox->addWidget(cbox_isRva);
	}
	
	const QString otherLabel = (isRawAddr) ? "= Virtual:" : "= Raw:";
	this->otherCaptionLabel = new QLabel(otherLabel);
	layout_middleBox->addWidget(this->otherCaptionLabel);

	otherEdit = new QLineEdit(this);
	layout_middleBox->addWidget(otherEdit);
	otherEdit->setReadOnly(true);
	if (isRawAddr) {
		layout_middleBox->addWidget(cbox_isRva);
	}

	setDescriptions();

	connect(le, SIGNAL(textChanged(const QString &)), this, SLOT(onAddrChanged()) );
	if (cbox_isRva) {
		connect(cbox_isRva, SIGNAL(stateChanged(int)), this, SLOT(onAddrTypeChanged()));
	}
}

Executable::addr_type AddressInputDialog::getAddrType()
{
	if (this->isRawAddr) {
		return Executable::RAW;
	}
	if (cbox_isRva) {
		if (cbox_isRva->isChecked()) return Executable::VA;
	}
	return Executable::RVA;
}

void AddressInputDialog::onAddrChanged()
{
	validateAddr();
}

offset_t AddressInputDialog::convertToOther(offset_t val, Executable::addr_type aT)
{
	if (!myExe) return INVALID_ADDR;
	
	if (!this->isRawAddr) {
		return myExe->toRaw(val, aT);
	}
	Executable::addr_type otherType = (cbox_isRva->isChecked()) ? Executable::VA : Executable::RVA;
	offset_t number = INVALID_ADDR;
	try {
		number = myExe->rawToRva(val);
		if (otherType == Executable::VA) {
			number = myExe->rvaToVa(number);
		}
	} catch (CustomException e) {
		number = INVALID_ADDR;
	}
	return number;
}

void AddressInputDialog::validateAddr()
{
	bool isAccepted = false;

	if (myExe) {
		Executable::addr_type aT = getAddrType();

		bool isValid = false;
		qulonglong val = getNumValue(&isValid);
		const offset_t otherFmt = convertToOther(val, aT);
		
		if (isValid && myExe->toRaw(val, aT) != INVALID_ADDR) {
			isAccepted = true;
		}
		if (otherFmt != INVALID_ADDR) {
			otherEdit->setText(QString::number(otherFmt, 16).toUpper());
		} else {
			otherEdit->setText("<invalid>");
		}
	}

	if (isAccepted == false) {
		this->le->setStyleSheet("border: 2px solid red;");
	} else {
		this->le->setStyleSheet("");
	}

	setTextColor();
}

void AddressInputDialog::setTextColor()
{
	Executable::addr_type aT = getAddrType();
	Executable::addr_type otherType = Executable::RAW;
	
	if (aT == Executable::RAW) {
		otherType = (cbox_isRva->isChecked()) ? Executable::VA : Executable::RVA;
	}

	//set primary color:
	QColor addrColor = addrColors.addrTypeToColor(aT);

	//set secondary color:
	QColor otherColor = addrColors.addrTypeToColor(otherType);

	QPalette palette;
	palette.setColor(QPalette::Text, addrColor);
	le->setPalette(palette);
	le->setStyleSheet(le->styleSheet() + "color : " + addrColor.name() + ";");

	QPalette otherPalette;
	otherPalette.setColor(QPalette::Text, otherColor);
	this->otherEdit->setPalette(otherPalette);
	otherEdit->setStyleSheet(otherEdit->styleSheet() + "color : " + otherColor.name() + ";");
}

void AddressInputDialog::setDescriptions()
{
	Executable::addr_type aT = getAddrType();
	QString desc = "Raw";
	QString winDesc = (aT == Executable::RAW) ? "Raw Address" : "Virtual Address";
	if (aT == Executable::RVA) desc = "RVA";
	if (aT == Executable::VA) desc = "VA";
	
	this->setWindowTitle("Go to " + winDesc);
	this->captionLabel->setText("Go to " + desc + " (hex):");
}

void AddressInputDialog::onAddrTypeChanged()
{
	setDescriptions();

	if (!myExe) return;
	
	const Executable::addr_type aT = getAddrType();
	const offset_t val = getNumValue();
	if (isRawAddr) {
		//change the secondary field
		const offset_t otherAddr = this->convertToOther(val, aT);
		otherEdit->setText(QString::number(otherAddr, 16).toUpper());
	} else {
		//change the primary field:
		const offset_t newVal = (aT == Executable::RVA) ? this->myExe->VaToRva(val, false) : myExe->rvaToVa(val);
		this->setDefaultValue(newVal);
	}
	validateAddr();
}

```

`pe-bear/gui_base/AddressInputDialog.h`:

```h
#pragma once

#include <QtGui>

#include "HexInputDialog.h" 
#include <bearparser/Executable.h>

#include "../base/MainSettings.h"

class AddressInputDialog : public HexInputDialog
{
	Q_OBJECT
protected slots:
	void onAddrTypeChanged();
	void onAddrChanged();

public:
	AddressInputDialog(Executable *exe, bool isRaw, ColorSettings &addrColors, QWidget *parent);
	~AddressInputDialog()
	{
		delete otherEdit;
		delete otherCaptionLabel;
		delete cbox_isRva;
	}

	Executable::addr_type getAddrType();

protected:
	offset_t convertToOther(offset_t val, Executable::addr_type aT);
	void validateAddr();
	void setTextColor();
	void setDescriptions();

	Executable *myExe;
	ColorSettings &addrColors;
	
	QCheckBox *cbox_isRva;
	QLabel *otherCaptionLabel;
	QLineEdit *otherEdit;
	
	bool isRawAddr;
};


```

`pe-bear/gui_base/ClipboardUtil.cpp`:

```cpp
#include "ClipboardUtil.h"

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

int ClipboardUtil::byteArrayToBuffer(QByteArray bytes, uchar *buf, int bufSize)
{
	int size = bytes.size();

	int clipIndx = 0;
	for (; clipIndx < size && clipIndx < bufSize; clipIndx++) {
		uchar b = bytes.at(clipIndx);
		if (buf) buf[clipIndx] = b;
	}
	return clipIndx;
}

QByteArray ClipboardUtil::getTextClip()
{
	QString text = QApplication::clipboard()->text();
#if QT_VERSION >= 0x050000
	return text.toLatin1();
#else
	return text.toAscii();
#endif
}

QByteArray ClipboardUtil::getHexClip()
{
	QString text = QApplication::clipboard()->text();
	return parseBytesString(text, " ");
}

QByteArray ClipboardUtil::getOctetStreamClip()
{
	const QMimeData *mimeData = QApplication::clipboard()->mimeData();
	return mimeData->data("application/octet-stream");
}

int ClipboardUtil::getFromClipboard(uchar *buf, int bufSize)
{
	QByteArray bytes = getOctetStreamClip();
	if (bytes.size() == 0 ) { //no octet stream provided, try to parse text...
		bytes = getHexClip();
		if (bytes.size() == 0) bytes = getTextClip();
	}
	if (bytes.size() == 0) return 0;
	return byteArrayToBuffer(bytes, buf, bufSize);
}

int ClipboardUtil::getFromClipboard(bool isHex, uchar *buf, int bufSize)
{
	QByteArray bytes = getOctetStreamClip();
	if (bytes.size() == 0 ) { //no octet stream provided, try to parse text...
		bytes = (isHex) ? getHexClip() : getTextClip();
	}
	if (bytes.size() == 0) return 0;
	return byteArrayToBuffer(bytes, buf, bufSize);
}

QByteArray ClipboardUtil::parseBytesString(QString text, QString separator)
{
	QByteArray emptyArr;
	if (text.length() == 0) return emptyArr;

	QStringList chunks = text.split(separator, QString::SkipEmptyParts);
	int size = chunks.size();
	
	QByteArray bytes;
	//validate
	for (int i = 0; i < size; i++ ) {
		QString chunk = chunks[i];
		if (chunk.size() != 2) {
			return emptyArr; // validation failed
		}

#if QT_VERSION >= 0x050000
		char c = chunk[0].toLatin1();
#else
		char c = chunk[0].toAscii();
#endif
		if (!pe_util::isHexChar(c)) {
			return emptyArr; // validation failed
		}
		//validateion ok!
		bool isOk;
		uchar b = chunks[i].toShort(&isOk, 16);
		if (!isOk) return emptyArr; 
		bytes.append(b);
	}
	return bytes;
}


```

`pe-bear/gui_base/ClipboardUtil.h`:

```h
#pragma once

#include <QtGlobal>
#include <QtCore>
#include <QClipboard>

#if QT_VERSION >= 0x050000
	#include <QApplication>
#endif

#include <bearparser/bearparser.h>

class ClipboardUtil 
{
public: 
	/* Fills given buffer; in: allocated buffer of size bufSize; out: filledSize */
	static int byteArrayToBuffer(QByteArray inArr, uchar *outBuf, int outBufSize);

	static int getFromClipboard(uchar *buf, int bufSize);
	static int getFromClipboard(bool isHex, uchar *buf, int bufSize);

	static inline QByteArray getTextClip();
	static inline QByteArray getHexClip();
	static inline QByteArray getOctetStreamClip();

	static QByteArray parseBytesString(QString string, QString separator);
//----
};

```

`pe-bear/gui_base/ExtTableView.cpp`:

```cpp
#include "ExtTableView.h"
#include <QtGlobal>

ExtTableView::ExtTableView(QWidget *parent)
	: QTableView(parent), 
	defaultMenu(this), myMenu(&defaultMenu)
{
	init();
	connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(customMenuEvent(QPoint)) );
	enableMenu(false);
}

void ExtTableView::init()
{
	QHeaderView *verticalHdr = this->verticalHeader();
	if (verticalHdr) {
#if QT_VERSION >= 0x050000
		verticalHdr->setSectionResizeMode(QHeaderView::ResizeToContents);
#else
		verticalHdr->setResizeMode(QHeaderView::ResizeToContents);
#endif
	}
	QHeaderView *horizontalHdr = this->horizontalHeader();
	if (horizontalHdr) {
#if QT_VERSION >= 0x050000
		horizontalHdr->setSectionResizeMode(QHeaderView::ResizeToContents);
#else
		horizontalHdr->setResizeMode(QHeaderView::ResizeToContents);
#endif
	}
	this->setWordWrap(false);
}

void ExtTableView::enableMenu(bool enable)
{
	if (enable) this->setContextMenuPolicy(Qt::CustomContextMenu);
	else this->setContextMenuPolicy(Qt::DefaultContextMenu);
}

void ExtTableView::customMenuEvent(QPoint p)
{
	if (myMenu == NULL) return;
	QPoint p2 = this->mapToGlobal(p); 
	this->myMenu->exec(p2);
}

void ExtTableView::setMenu(QMenu *menu)
{
	myMenu = menu;
}

void ExtTableView::removeAllActions()
{
	if (myMenu != NULL) {
		QList<QAction*> actList = myMenu->actions();
		for (int i = 0; i < actList.size(); i++) {
			myMenu->removeAction(actList[i]);
		}
	}
}

void ExtTableView::keyPressEvent(QKeyEvent *kEvent)
{
	//the default table copy operation copy only one selected index
	if (kEvent->matches(QKeySequence::Copy)) {
		copySelected();
		return;
	} else if (kEvent->matches(QKeySequence::Paste)) {
		pasteToSelected();
		return;
	}
	QTableView::keyPressEvent(kEvent);
}

QString ExtTableView::getSelectedText(QString hSeparator, QString vSeperator)
{
	QItemSelectionModel *model = this->selectionModel();
	if (!model) return "";

	QModelIndexList list = model->selectedIndexes();
	std::sort(list.begin(), list.end());

	int prevRow = -1;
	int prevCol = -1;

	const int size = list.size();
	QStringList strings;
	
	for (int i = 0; i < size; i++) {

		QModelIndex index = list.at(i);

		if (prevRow != (-1) && index.row() != prevRow) {
			strings << vSeperator;
		} else if (prevCol != (-1)) {
			strings << hSeparator;
		}
		strings << index.data().toString();

		prevRow = index.row();
		prevCol = index.column();
	}
	return strings.join("");
}

void ExtTableView::copyText(QString hSeparator, QString vSeperator)
{
	QApplication::clipboard()->clear();
	QApplication::clipboard()->setText(getSelectedText(hSeparator, vSeperator));
}

```

`pe-bear/gui_base/ExtTableView.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

class ExtTableView : public QTableView
{
	Q_OBJECT

public:
	ExtTableView(QWidget *parent = 0);

	void setMenu(QMenu *menu);
	QMenu* getMenu() { return myMenu; }
	void setDefaultMenu() { myMenu = &defaultMenu; }
	void enableMenu(bool enable);
	void removeAllActions();

protected slots:
	virtual void copySelected() { return copyText("", "\n"); }
	virtual void pasteToSelected() { /* not supported */ }

	virtual void copyText(QString hSeparator, QString vSeperator);
	virtual QString getSelectedText(QString hSeparator, QString vSeperator);
	virtual void customMenuEvent(QPoint p);
	QString errorString() { return lastErrorString; }

protected:
	void init();
	void keyPressEvent(QKeyEvent *kEvent);

	QMenu *myMenu;
	QMenu defaultMenu;
	QString lastErrorString;
};

```

`pe-bear/gui_base/FollowablePeTreeView.cpp`:

```cpp
#include "FollowablePeTreeView.h"

#define COL_OFFSET 0

//---------------------------------------------------------
FollowablePeTreeView::FollowablePeTreeView(QWidget *parent)
	: MainSettingsHolder(), PeTreeView(parent),
	selectedOffset(INVALID_ADDR)
{
	enableMenu(true);

	setSelectionBehavior(QAbstractItemView::SelectItems);
	setSelectionMode(QAbstractItemView::SingleSelection);
	setAlternatingRowColors(true);

	followOffsetAction = new QAction("Follow offset", this);
	this->defaultMenu.addAction(followOffsetAction);
	connect(followOffsetAction, SIGNAL(triggered()), this, SLOT(followOffset()));
	
	onClick = new QAction("Follow on click", this);
	onClick->setCheckable(true);
	MainSettings* set =  getSettings();
	if (set) {
		onClick->setChecked(set->isFollowOnClick());
		connect(set, SIGNAL(settingsChanged()), this, SLOT(onSettingsChanged()) );
	}
	
	this->defaultMenu.addAction(onClick);
	connect(onClick, SIGNAL(triggered(bool)), this, SLOT(setFollowOnClick(bool)));
}

void FollowablePeTreeView::onSettingsChanged()
{
	MainSettings* set =  getSettings();
	if (set) {
		onClick->setChecked(set->isFollowOnClick());
	}
}

void FollowablePeTreeView::setFollowOnClick(bool isEnabled)
{
	MainSettings* set =  getSettings();
	if (set == NULL) {
		printf("Settings == NULL\n");
		return;
	}
	if (set->isFollowOnClick() == isEnabled) return; //nothing changed
	set->setFollowOnClick(isEnabled);
	onClick->setChecked(set->isFollowOnClick());
}

void FollowablePeTreeView::mousePressEvent(QMouseEvent *event)
{
	if (!myModel) return;
	PeTreeView::mousePressEvent(event);
	QModelIndex index = this->indexAt(event->pos());
	this->addrType = myModel->addrTypeAt(index);

	if (addrType == Executable::NOT_ADDR) {
		this->selectedOffset = INVALID_ADDR;
		followOffsetAction->setEnabled(false);
		onClick->setEnabled(false);
		return;
	}
	QVariant data = index.data();
	bool isOk = false;
	offset_t offset = data.toString().toLongLong(&isOk, 16);
	if (!isOk) {
		offset = INVALID_ADDR;
		addrType = Executable::NOT_ADDR;
	}
	this->selectedOffset = offset;
	followOffsetAction->setEnabled(isOk);
	onClick->setEnabled(isOk);
	MainSettings* set =  getSettings();
	if (isOk && set != NULL && set->isFollowOnClick() == true) {
		followOffset();
	}
}

void FollowablePeTreeView::mouseMoveEvent(QMouseEvent *event)
{
	if (!myModel) return;
	PeTreeView::mouseMoveEvent(event);
	QModelIndex index = this->indexAt(event->pos());
	this->addrType = myModel->addrTypeAt(index);

	if (this->addrType == Executable::NOT_ADDR) {
		this->setCursor(Qt::ArrowCursor);
		return;
	}
	this->setCursor(Qt::PointingHandCursor);
}

bool FollowablePeTreeView::hasAnyActionEnabled()
{
	QList<QAction*> actions = defaultMenu.actions();
	QList<QAction*>::Iterator itr;
	for (itr = actions.begin(); itr != actions.end(); ++itr) {
		if ( (*itr)->isEnabled() == true) return true;
	}
	return false;
}

void FollowablePeTreeView::customMenuEvent(QPoint p)
{
	if (!pe()) return;
	
	bool canFollow = this->addrType != Executable::NOT_ADDR;
	followOffsetAction->setEnabled(canFollow);
	if (!canFollow) {
		if (hasAnyActionEnabled() == false) {
			return;
		}
	}
	QString type;
	switch (this->addrType) {
	case Executable::RAW : 
		type = "raw"; 
		break;
	case Executable::RVA : 
		type = "RVA"; 
		break;
	case Executable::VA : 
		type = "VA"; 
		break;
	}
	followOffsetAction->setText("Follow " + type + ": " + QString::number(this->selectedOffset, 16).toUpper());
	QPoint p2 = this->mapToGlobal(p); 
	this->defaultMenu.exec(p2);
}

void FollowablePeTreeView::followOffset()
{
	if (selectedOffset == INVALID_ADDR) return;
	if (this->addrType == Executable::NOT_ADDR) return;
	if (!pe() || !peHndl()) return;

	try {
		offset_t raw = pe()->toRaw(this->selectedOffset, this->addrType, true);
		if (raw == INVALID_ADDR) {
			QMessageBox::warning(this, "Failed!", "Cannot follow - invalid address!");
			return;
		}
		peHndl()->setDisplayed(false, raw);

	} catch (CustomException &e) {
		QMessageBox::warning(this, "Cannot follow!", e.getInfo());
	}
}

```

`pe-bear/gui_base/FollowablePeTreeView.h`:

```h
#pragma once

#include <QtGui>

#include "PeTreeView.h"

//--------------------------------------------------------------------------

class FollowablePeTreeView : public PeTreeView, public MainSettingsHolder
{
	Q_OBJECT

public:
	FollowablePeTreeView(QWidget *parent);
	virtual ~FollowablePeTreeView() { }

public slots:
	void mousePressEvent(QMouseEvent *event);
	void mouseMoveEvent(QMouseEvent *event);
	void setFollowOnClick(bool isEnabled);

protected slots:
	void onSettingsChanged();
	virtual void customMenuEvent(QPoint p);
	void followOffset();

protected:
	bool hasAnyActionEnabled();

	QAction *followOffsetAction, *onClick;

	offset_t selectedOffset;
	Executable::addr_type addrType;
};

```

`pe-bear/gui_base/HexInputDialog.cpp`:

```cpp
#include "HexInputDialog.h"
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

HexInputDialog::HexInputDialog(QString title, QString caption, QWidget *parent)
	: QDialog(parent), le(NULL)
{
	this->setModal(false);
	this->setWindowTitle(title);

	layout_middleBox = new QVBoxLayout();

	vbox = new QVBoxLayout();
	this->captionLabel = new QLabel(caption);
	layout_middleBox->addWidget(this->captionLabel);

	le = new QLineEdit(this);
	layout_middleBox->addWidget(le);

	validator = new QRegExpValidator(QRegExp("[0-9A-Fa-f]{1,}"));
	le->setValidator(validator);
	vbox->addLayout(layout_middleBox);

	QDialogButtonBox * buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
	vbox->addWidget(buttonBox);
	this->setLayout(vbox);

	connect(buttonBox, SIGNAL(accepted()), this, SLOT(accepted()));
	connect(buttonBox, SIGNAL(rejected()), this, SLOT(rejected()));
}

qulonglong HexInputDialog::getNumValue(bool *isValid)
{
	bool is_converted = false;
	QString textVal = le->text();
	qulonglong value = textVal.toULongLong(&is_converted, 16);

	if (isValid != nullptr) {
		(*isValid) = is_converted;
	}
	return value;
}

void HexInputDialog::setDefaultValue(qulonglong number)
{
	le->setText(QString::number(number, 16).toUpper());
}

void HexInputDialog::accepted()
{
	bool isValid = false;
	getNumValue(&isValid);
	
	if (isValid == false) {
		QMessageBox::warning(this, "Warning!", "Wrong number format supplied!");
		return;
	}
	QDialog::accept();
}

void HexInputDialog::rejected()
{
	QDialog::reject();
}

```

`pe-bear/gui_base/HexInputDialog.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

class HexInputDialog : public QDialog
{
    Q_OBJECT

public:
	HexInputDialog(QString title, QString caption, QWidget *parent = 0);

	~HexInputDialog()
	{
		delete validator;
		delete le;
		delete captionLabel;
		delete layout_middleBox;
		delete vbox;
	}

	qulonglong getNumValue(bool *isValid = NULL);
	void setDefaultValue(qulonglong number);

	void setRegex(const QRegExp &regex) { validator->setRegExp(regex); }
	void setMaxLength(int len) { le->setMaxLength(len); }

public slots:
	void rejected();
	void accepted();

protected:

	QVBoxLayout *vbox, *layout_middleBox;
	QLabel *captionLabel;
	QLineEdit *le;
	QRegExpValidator *validator;
};

```

`pe-bear/gui_base/HexMimeSource.cpp`:

```cpp
#include "HexMimeSource.h"


HexMimeSource::HexMimeSource(BYTE *buf, uint64_t bufSize)
{
	this->buf = buf;
	this->bufSize = bufSize;
}

bool HexMimeSource::provides(const char* typeName) const
{
	if (strstr(typeName,"application/octet-stream")) {
		return true;
	}
	if (strstr(typeName,"text/plain")) {
		return true;
	}
	return false;
}

QByteArray HexMimeSource::encodedData(const char* typeName) const
{
	QByteArray arr;
	if (this->buf == NULL || this->bufSize == 0) return arr;

	if (strstr(typeName,"application/octet-stream")) {
		for (int i = 0; i < bufSize; i++) {
			arr.append(buf[i]);
		}
		return arr;
	}
	if (strstr(typeName,"text/plain")) {
		for (int i = 0; i < bufSize; i++) {
			static char charVal[4];
			memset(charVal,0,sizeof(charVal));
			snprintf(charVal, sizeof(charVal) - 1, "%02X", buf[i]);
			arr.append(charVal);
			if (i < (bufSize - 1)) arr.append(' ');
		}
		return arr;
	}
	return arr;
}

const char* HexMimeSource::format(int n) const
{
	if (n == 0) return "application/octet-stream";
	if (n == 1) return "text/plain";
	return NULL;
}

//--------------------------------------------------------------------
/*
HexConverter::HexConverter(QObject *parent)
    : QObject(parent)
{
	validator = new QRegExpValidator(QRegExp("[0-9A-Fa-f]{1,8}"), this);
}

QString HexConverter::textFromValue(int value) const
{
	return QString::number(value, 16).toUpper();
}

int HexConverter::valueFromText(const QString &text) const
{
	bool ok;
	int val = text.toInt(&ok, 16);
	if (ok) return val;
	return 0;
}

bool HexConverter::validate(QString &text, int pos) const
{
	QValidator::State state = validator->validate(text, pos);
	//Invalid, Intermediate,Acceptable
	if (state == QValidator::Acceptable) return true;
	return false;
}
*/
//--------------------------------------------------------------------
```

`pe-bear/gui_base/HexMimeSource.h`:

```h
#pragma once

#include <QtGui>
#include "../Util.h"

class HexMimeSource : public QMimeSource
{
public:
	HexMimeSource(BYTE *buf, uint64_t bufSize);

	virtual const char* format(int n = 0) const;
	virtual bool provides(const char*) const;
	virtual QByteArray encodedData(const char*) const;

protected:
	BYTE *buf;
	uint64_t bufSize;
};

//--------------------------------------------------------------------
/*class HexConverter: public QObject
{
	Q_OBJECT
public:
	HexConverter(QObject *parent = 0);

	bool validate(QString &text, int pos = 0) const;
	int valueFromText(const QString &text) const;
	QString textFromValue(int value) const;

private:
	QRegExpValidator *validator;
};
*/
//--------------------------------------------------------------------

```

`pe-bear/gui_base/HexSpinBox.cpp`:

```cpp
#include "HexSpinBox.h"

HexSpinBox::HexSpinBox(QWidget *parent)
    : QSpinBox(parent)
{
	validator = new QRegExpValidator(QRegExp("[0-9A-Fa-f]{1,8}"), this);
}

QString HexSpinBox::textFromValue(int value) const
{
	return QString::number(value, 16).toUpper();
}

int HexSpinBox::valueFromText(const QString &text) const
{
	bool ok;
	int val = text.toInt(&ok, 16);
	if (ok) return val;
	return 0;
}

QValidator::State HexSpinBox::validate(QString &text, int &pos) const
{
	return validator->validate(text, pos);
}

```

`pe-bear/gui_base/HexSpinBox.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

class HexSpinBox : public QSpinBox
{
	Q_OBJECT
public:
	HexSpinBox(QWidget *parent = 0);

protected:
	QValidator::State validate(QString &text, int &pos) const;
	int valueFromText(const QString &text) const;
	QString textFromValue(int value) const;

private:
	QRegExpValidator *validator;
};

```

`pe-bear/gui_base/OffsetDependentAction.cpp`:

```cpp
#include "OffsetDependentAction.h"


OffsetDependentAction::OffsetDependentAction(const Executable::addr_type addrT, const QString &text, QObject* parent) 
		: QAction(text, parent), 
		addrType(addrT), title(text), offset(INVALID_ADDR) 
{ 
	onOffsetChanged(offset); 
	connect(this, SIGNAL(triggered()), this, SLOT(onTriggered()));
}

void OffsetDependentAction::onOffsetChanged(offset_t offset)
{
	this->offset = offset;
	if (offset == INVALID_ADDR) {
		this->setEnabled(false);
		this->setVisible(false);
		this->setText("-");
		return;
	}
	this->setEnabled(true);
	this->setVisible(true);
	QString text = title + " "+ QString::number(offset, 16).toUpper();
	this->setText(text); 
}

void OffsetDependentAction::onOffsetChanged(offset_t offset, Executable::addr_type addrT)
{
	this->addrType = addrT;
	onOffsetChanged(offset);
}

//----------------------------------------------

void OffsetDependentMenu::addAction(QAction *action)
{
	if (!action) return;

	OffsetDependentAction *offAction = dynamic_cast <OffsetDependentAction*> (action);
	if (offAction) {
		connect(this, SIGNAL(offsetUpdated(offset_t, Executable::addr_type)), action, SLOT(onOffsetChanged(offset_t, Executable::addr_type)) );
	}
	QMenu::addAction(action);
}

void OffsetDependentMenu::removeAction(QAction *action)
{
	if (!action) return;

	OffsetDependentAction *offAction = dynamic_cast <OffsetDependentAction*> (action);
	if (offAction) {
		disconnect(this, SIGNAL(offsetUpdated(offset_t, Executable::addr_type)), action, SLOT(onOffsetChanged(offset_t, Executable::addr_type)) );
	}
	QMenu::removeAction(action);
}

void OffsetDependentMenu::onOffsetChanged(offset_t offset, Executable::addr_type addrType)
{
	if (this->offset == offset && this->addrType == addrType) {
		return; //no changes
	}
	emit offsetUpdated(offset, addrType);

	this->addrType = addrType;
	this->offset = offset;

	if (offset == INVALID_ADDR) {
		this->setEnabled(false);
		//this->setVisible(false);
		this->setTitle("-");
		return;
	}
	this->setEnabled(true);
	QString text = title + " "+ QString::number(offset, 16).toUpper();
	this->setTitle(text); 
}

```

`pe-bear/gui_base/OffsetDependentAction.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif
#include <bearparser/bearparser.h>

class OffsetDependentAction : public QAction
{
	Q_OBJECT
public:
	OffsetDependentAction(const Executable::addr_type addrType, const QString &title, QObject* parent);

	void setTitle(const QString &title) { this->title = title; }

	offset_t getOffset() { return offset; }
	Executable::addr_type getAddrType() { return addrType; }

public slots:
	void onOffsetChanged(offset_t offset);
	void onOffsetChanged(offset_t offset, Executable::addr_type addrType);

signals:
	void triggered(offset_t offset, Executable::addr_type addrType);

private slots:
	void onTriggered() { emit triggered(offset, addrType); }

protected:
	Executable::addr_type addrType;
	offset_t offset;
	QString title;

friend class OffsetDependentMenu;
};

class OffsetDependentMenu : public QMenu
{
	Q_OBJECT

public:
	OffsetDependentMenu (const Executable::addr_type addrT, const QString &text, QWidget *parent)
		: QMenu(text, parent), 
		addrType(addrT), offset(INVALID_ADDR), title(text)
	{
		onOffsetChanged(offset);
	}

	void addAction(QAction *action);
	void removeAction(QAction *action);

public slots:
	void onOffsetChanged(offset_t offset) { onOffsetChanged(offset, this->addrType); }
	void onOffsetChanged(offset_t offset, Executable::addr_type addrType);

signals:
	void offsetUpdated(offset_t, Executable::addr_type);

protected:
	Executable::addr_type addrType;
	offset_t offset;
	QString title;
};

```

`pe-bear/gui_base/PEViewsManager.cpp`:

```cpp
#include "PEViewsManager.h"

PEDockedWidget* PEViewsManager::getPeDockWidget(PeHandler* peHndl)
{
	if (!peHndl) return NULL;
	std::map<PeHandler*, PEDockedWidget*>::iterator found = this->PeViews.find(peHndl);
	if (found != this->PeViews.end()) {
		return found->second;
	}

	PEDockedWidget* p = new PEDockedWidget(peHndl, this);
	if (!p) return NULL; //should not happen
	
	p->hide();
	connect(this, SIGNAL(signalChangeHexViewSettings(HexViewSettings &)), p, SLOT(changeHexViewSettings(HexViewSettings &)) );
	connect(this, SIGNAL(signalChangeDisasmViewSettings(DisasmViewSettings &)), p, SLOT(changeDisasmViewSettings(DisasmViewSettings &)) );
	connect(this, SIGNAL(globalFontChanged()), p, SLOT(refreshFonts()) );
	
	p->changeHexViewSettings(this->hexSettings);
	p->changeDisasmViewSettings(this->disasmSettings);

	p->setAllowedAreas(Qt::AllDockWidgetAreas);// Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
	p->setFloating(false);
	p->setFeatures( QDockWidget::DockWidgetMovable
	   | QDockWidget::DockWidgetClosable
	   | QDockWidget::DockWidgetFloatable 
	   | QDockWidget::DockWidgetVerticalTitleBar
	);
	this->addDockWidget(Qt::RightDockWidgetArea, p, Qt::Vertical);
	if (lastDock.size()) {
		this->tabifyDockWidget(lastDock.back(), p);
		p->setTabOrder(p, lastDock.back());
	}
	lastDock.push_back(p);
	PeViews[peHndl] = p;
	p->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
	p->goToEntryPoint();
	return p;
}

bool PEViewsManager::removePeDockWidget(PeHandler* peHndl)
{
	std::map<PeHandler*, PEDockedWidget*>::iterator found = this->PeViews.find(peHndl);
	if (found == this->PeViews.end()) return false;

	PEDockedWidget* peDock = found->second;
	if (peDock) peDock->close();
	this->PeViews.erase(found);

	std::vector<PEDockedWidget*>::iterator itr;
	for (itr = lastDock.begin(); itr != lastDock.end(); ++itr) {
		if (*itr == peDock) {
			lastDock.erase(itr);
			break;
		}
	}
	delete peDock;
	return true;
}

void PEViewsManager::clear()
{
	std::map<PeHandler*, PEDockedWidget*>::iterator vItr;
	for (vItr = this->PeViews.begin(); vItr != this->PeViews.end(); ++vItr) {
		PeHandler* hndl = vItr->first;
		PEDockedWidget *peDock = vItr->second;
		if (peDock) peDock->close();
		delete peDock;
	}
	this->PeViews.clear();
}

PEViewsManager::~PEViewsManager()
{
	clear();
}

```

`pe-bear/gui_base/PEViewsManager.h`:

```h
#pragma once

#include <QtGui>
#include "../PEDockedWidget.h"

class PEViewsManager : public QMainWindow
{
	Q_OBJECT
	
signals:
	void signalChangeHexViewSettings(HexViewSettings &);
	void signalChangeDisasmViewSettings(DisasmViewSettings &);
	void globalFontChanged();

public:
	PEViewsManager(QWidget* parent)
		: QMainWindow(parent)
	{
	}
	
	PEDockedWidget* getPeDockWidget(PeHandler* pe);
	bool removePeDockWidget(PeHandler* pe);
	void clear();

	~PEViewsManager();
	
public slots:

	void changeHexViewSettings(HexViewSettings &_settings)
	{
		hexSettings = _settings;
		emit signalChangeHexViewSettings(_settings);
	}
	
	void changeDisasmViewSettings(DisasmViewSettings &_settings)
	{
		disasmSettings = _settings;
		emit signalChangeDisasmViewSettings(_settings);
	}

	void onGlobalFontChanged()
	{
		emit globalFontChanged();
	}

protected:
	std::map<PeHandler*, PEDockedWidget*> PeViews;
	std::vector<PEDockedWidget*> lastDock;
	
	HexViewSettings hexSettings;
	DisasmViewSettings disasmSettings;
};

```

`pe-bear/gui_base/PeGuiItem.cpp`:

```cpp
#include "PeGuiItem.h"

#define DBG_LVL 0

uint64_t PeGuiItem::counter = 0;

PeGuiItem::PeGuiItem(PeHandler *peHndl)
	: m_PE(NULL), myPeHndl(NULL)
{
	//if (!peHndl || !peHndl->getPe()) throw CustomException("Invalid initialization: PE Handler is NULL!");
	if (peHndl) {
		peHndl->incRefCntr();
		m_PE = peHndl->getPe();
	}
	myPeHndl = peHndl;
	PeGuiItem::counter++;
}

PeGuiItem::~PeGuiItem()
{
	if (myPeHndl) {
		myPeHndl->release();
	}
	myPeHndl = NULL;
	m_PE = NULL;
	PeGuiItem::counter--;
}

//---------------------------------------------------------------------

MainSettings* MainSettingsHolder::mainSettings = NULL;

MainSettings* MainSettingsHolder::getSettings()
{
	if (MainSettingsHolder::mainSettings != NULL) {
		return MainSettingsHolder::mainSettings;
	}
	if (this->mySettings == NULL) {
		mySettings = new MainSettings();
	}
	return mySettings;
}

```

`pe-bear/gui_base/PeGuiItem.h`:

```h
#pragma once

#include <QtCore>
#include <bearparser/bearparser.h>

#include "../base/MainSettings.h"
#include "../base/PeHandlersManager.h"

#include "../ViewSettings.h"

class PeGuiItem
{
public:
	/*throws Exception if PeHandler or PeFile is NULL! */
	PeGuiItem(PeHandler *peHndl);
	virtual ~PeGuiItem();

	virtual PeHandler* getPeHandler() const { return myPeHndl; }
	virtual PEFile* getPE() const { if (!myPeHndl) return NULL; return myPeHndl->getPe(); }
	
	ColorSettings addrColors;
	
protected:
	static uint64_t counter;
	PeHandler* myPeHndl;
	PEFile* m_PE;
};

//----

class PeViewItem : public PeGuiItem
{
public:
	PeViewItem(PeHandler *peHndl) : PeGuiItem(peHndl) {}
	virtual ~PeViewItem() {}

	virtual offset_t getContentOffset() const { return 0; }
	virtual bufsize_t getContentSize() const { return (m_PE) ? m_PE->getRawSize() : 0; }
};

class MainSettingsHolder 
{
public:
	static void setMainSettings(MainSettings* settings) { MainSettingsHolder::mainSettings = settings; }

	MainSettingsHolder() : mySettings(NULL) {}
	virtual ~MainSettingsHolder() { delete mySettings; }

protected:
	MainSettings* getSettings();
	static MainSettings* mainSettings;
	//---
	MainSettings* mySettings;
};

```

`pe-bear/gui_base/PeTableModel.cpp`:

```cpp
#include "PeTableModel.h"

#define COL_OFFSET 0

//---------------------------------------

PeTableModel::PeTableModel(PeHandler *peHndl, QObject *parent)
	: PeTreeModel(peHndl, parent, false)
{
}

Executable::addr_type PeTableModel::addrTypeAt(QModelIndex index) const
{
	if (!index.isValid() || !m_PE) return Executable::NOT_ADDR;
	if (index.column() == COL_OFFSET) return Executable::RAW;
	return Executable::NOT_ADDR;
}

```

`pe-bear/gui_base/PeTableModel.h`:

```h
#pragma once
#include <QtGlobal>
#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include <bearparser/bearparser.h>
#include "PeGuiItem.h"
#include "TreeCpView.h"
#include "../gui/PeTreeModel.h"

//--------------------------------------------------------------------------

class PeTableModel : public PeTreeModel
{
	Q_OBJECT

public:
	PeTableModel(PeHandler *peHndl, QObject *parent);

	virtual ~PeTableModel()
	{
	}

	QModelIndex index(int row, int column, const QModelIndex &parent) const
	{
		return createIndex(row, column);
	}

	virtual Executable::addr_type addrTypeAt(QModelIndex index) const;

	virtual offset_t getFieldOffset(QModelIndex index) const { return 0; }
	virtual bufsize_t getFieldSize(QModelIndex index) const { return 0; }

friend class PeTreeView;
};

```

`pe-bear/gui_base/PeTreeView.cpp`:

```cpp
#include "PeTreeView.h"

//---------------------------------------

PeTreeView::PeTreeView(QWidget *parent) 
	: TreeCpView(parent), 
	myModel(NULL), autoExpand(true)
{
	setMouseTracking(true);

	setSelectionBehavior(QAbstractItemView::SelectItems);
	setSelectionMode(SingleSelection);
	setAutoFillBackground(true);
	setAlternatingRowColors(true);

	if (header()) {
#if QT_VERSION >= 0x050000
		header()->setSectionResizeMode(QHeaderView::Interactive);
#else
		header()->setResizeMode(QHeaderView::Interactive);
//		header()->setResizeMode(0, QHeaderView::Fixed);  
		header()->setMovable(false);
#endif
	}
}

void PeTreeView::setModel(PeTreeModel *model)
{
	if (this->myModel) {
		disconnect(this->myModel, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()) );
	}

	this->myModel = model;
	TreeCpView::setModel(model);
	if (!model) return;

	bool expandable = model->isExpandable();
	setItemsExpandable(expandable);
	setRootIsDecorated(expandable);
	this->setColumnWidth(0, 80);
	this->setContentsMargins(5, 5, 2, 2);
	connect(model, SIGNAL(modelUpdated()), this, SLOT(onModelUpdated()) );
}

void PeTreeView::selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel)
{
	if (!myModel || !(myModel->getPeHandler())) return;

	if (newSel.indexes().size() == 0) return;

	QModelIndex index = newSel.indexes().at(0);
	hoverIndex(index);
}

void PeTreeView::mousePressEvent(QMouseEvent *event)
{
	if (!myModel || !(myModel->getPeHandler())) return;
	QModelIndex index = this->indexAt(event->pos());
	hoverIndex(index);
	TreeCpView::mousePressEvent(event);
}

void PeTreeView::keyPressEvent(QKeyEvent *keyEv)
{
	switch (keyEv->key()){
		case Qt::Key_Plus :
			this->expandAll();
			return;
		case Qt::Key_Minus :
			this->collapseAll();
			return;
	}
	TreeCpView::keyPressEvent(keyEv);
}

void PeTreeView::hoverIndex(QModelIndex index)
{
	if (!index.isValid()) return;
	if (!myModel || !myModel->getPeHandler()) return;
	
	offset_t offset = this->myModel->getFieldOffset(index);
	offset_t size = this->myModel->getFieldSize(index);
	
	if (!size) {
		offset = this->myModel->getContentOffset();
		size = this->myModel->getContentSize();
	}
	myModel->getPeHandler()->setHovered(false, offset, size);
}

//---------------------------------------
```

`pe-bear/gui_base/PeTreeView.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "TreeCpView.h"
#include "PeTableModel.h"

//--------------------------------------------------------------------------

class PeTreeView : public TreeCpView
{
	Q_OBJECT

protected slots:
	void onModelUpdated()
	{
		if (this->itemsExpandable() && autoExpand) {
			this->expandAll();
		}
	};

public :
	PeTreeView(QWidget *parent);
	
	virtual ~PeTreeView()
	{
	}

	void setModel(PeTreeModel *model);
	bool autoExpand;

public slots:
	void expandAll()
	{
		if (itemsExpandable()) {
			TreeCpView::expandAll();
		}
	}
	
	void collapseAll()
	{
		if (itemsExpandable()) {
			TreeCpView::collapseAll();
		}
	}

protected:
	void selectionChanged(const QItemSelection &newSel, const QItemSelection &prevSel);
	void mousePressEvent(QMouseEvent *event);
	void keyPressEvent(QKeyEvent *key);
	void hoverIndex(QModelIndex index);

	PeTreeModel *myModel;
	
	PeHandler* peHndl()
	{
		return (myModel) ? myModel->getPeHandler() : NULL;
	}
	
	PEFile* pe()
	{
		return (myModel) ? myModel->getPE() : NULL;
	}
};

//-----------------------------------------------------

```

`pe-bear/gui_base/TreeCpView.cpp`:

```cpp
#include "TreeCpView.h"


TreeCpView::TreeCpView(QWidget *parent)
	: QTreeView(parent), defaultMenu(this),
	myMenu(&defaultMenu)
{
	connect(this, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(customMenuEvent(QPoint)) );
	enableMenu(false);
}

void TreeCpView::resizeColsToContent()
{
	QAbstractItemModel *model = this->model();
	if (!model) return;

	int count = model->columnCount(QModelIndex());
	for (int i = 0; i < count; i++) {
		resizeColumnToContents(i);
	}
}

void TreeCpView::enableMenu(bool enable)
{
	if (enable) this->setContextMenuPolicy(Qt::CustomContextMenu);
	else this->setContextMenuPolicy(Qt::DefaultContextMenu);
}

void TreeCpView::customMenuEvent(QPoint p)
{
	if (myMenu == NULL) return;
	QPoint p2 = this->mapToGlobal(p); 
	this->myMenu->exec(p2);
}

void TreeCpView::keyPressEvent(QKeyEvent *keyEv)
{
	if (keyEv->matches(QKeySequence::Copy)) {
		copySelected();
		return;
	}
	QTreeView::keyPressEvent(keyEv);
}

void TreeCpView::setMenu(QMenu *menu)
{
	myMenu = menu;
}

void TreeCpView::removeAllActions()
{
	if (myMenu != NULL) {
		QList<QAction*> actList = myMenu->actions();
		for (int i = 0; i < actList.size(); i++) {
			myMenu->removeAction(actList[i]);
		}
	}
}

void TreeCpView::copySelected()
{
	QItemSelectionModel *model = this->selectionModel();
	QModelIndexList list = model->selectedIndexes();
	std::sort(list.begin(), list.end());
	int row = -1;
	int col = -1;
	QString separator = " ";
	const int size = list.size();
	QStringList strings;
	
	for (int i = 0; i < size; i++) {
		QModelIndex index = list.at(i);
		if (index.row() != row && row != (-1))
			strings << "\n";
		else if (col != -1) strings << separator;

		strings << index.data().toString();
		row = index.row();
		col = index.column();
	}
	QApplication::clipboard()->clear();
	QApplication::clipboard()->setText(strings.join(""));
}
```

`pe-bear/gui_base/TreeCpView.h`:

```h
#pragma once
#include <QtGlobal>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

class TreeCpView : public QTreeView
{
	Q_OBJECT

public:
	TreeCpView(QWidget *parent);
	virtual ~TreeCpView() {}

	void resizeColsToContent();

	void keyPressEvent(QKeyEvent *key);
	void setMenu(QMenu *menu);

	QMenu* getMenu() { return myMenu; }
	void setDefaultMenu() { myMenu = &defaultMenu; }
	void enableMenu(bool enable);
	void removeAllActions();

public slots:
	virtual void copySelected();
	virtual void customMenuEvent(QPoint p);
	
protected:
	QMenu *myMenu;
	QMenu defaultMenu;
};

```

`pe-bear/gui_base/WrapperInterface.cpp`:

```cpp
#include "WrapperInterface.h"

#define COL_OFFSET 0

//---------------------------------------
WrapperInterface::WrapperInterface()
{
}

bool WrapperInterface::containsOffset(QModelIndex index) const
{
	if (index.column() == COL_OFFSET) {
		return true;
	}
	return false;
}

QVariant WrapperInterface::dataValue(const QModelIndex &index) const
{
	ExeElementWrapper *wrapper = this->wrapperAt(index);
	if (!wrapper) return false;

	if (isComplexValue(index)) return complexValue(index);

	bool isOk = false;
	uint64_t val = wrapper->getNumValue(getFID(index), getSID(index), &isOk);
	if (isOk) return QString::number(val, 16);

	return complexValue(index);
}

QVariant WrapperInterface::complexValue(const QModelIndex &index) const
{
	if (!index.isValid()) return QVariant();
	ExeElementWrapper *wrapper = this->wrapperAt(index);
	if (!wrapper) return false;

	int fId = getFID(index);
	int sId = getSID(index);

	uint32_t fieldSize = wrapper->getFieldSize(fId, sId);
	WORD* ptr = (WORD*) wrapper->getFieldPtr(fId, sId);
	if (ptr == NULL || fieldSize == 0) return "INVALID";

	int cntr = fieldSize / sizeof(WORD);
	const int CNTR_MAX = 50;
	QStringList strL;
	for (int i = 0; i < cntr && i < CNTR_MAX; i++) {
		strL.append(QString::number(ptr[i], 16));
	}
	if (cntr > CNTR_MAX) strL.append("...");
	return strL.join(", ");
}

Executable::addr_type WrapperInterface::addrTypeAt(QModelIndex index) const
{
	if (containsOffset(index)) {
		return offsetAddrType();
	}
	if (!containsValue(index)) return Executable::NOT_ADDR;

	ExeElementWrapper *wrapper = this->wrapperAt(index);
	if (!wrapper) return Executable::NOT_ADDR;

	Executable::addr_type aType = Executable::NOT_ADDR;
	aType = wrapper->containsAddrType(getFID(index), getSID(index));
	return aType;
}

DWORD WrapperInterface::getFieldOffset(QModelIndex index) const
{ 
	if (!index.isValid()) return 0;
	int fieldId = getFID(index);
	return wrapperAt(index) ? wrapperAt(index)->getFieldOffset(fieldId) : 0;
}

DWORD WrapperInterface::getFieldSize(QModelIndex index) const 
{
	if (!index.isValid()) return 0;
	int fieldId = getFID(index);
	return wrapperAt(index) ? wrapperAt(index)->getFieldSize(fieldId) : 0;
}


```

`pe-bear/gui_base/WrapperInterface.h`:

```h
#pragma once

#include <QtGui>

#include "PeGuiItem.h"


class WrapperInterface
{
public:
	WrapperInterface();
	virtual ~WrapperInterface() {}

	Executable::addr_type addrTypeAt(QModelIndex index) const;

	DWORD getFieldOffset(QModelIndex index) const;
	DWORD getFieldSize(QModelIndex index) const;
	
	virtual bool containsValue(QModelIndex index) const = 0;
	virtual bool containsOffset(QModelIndex index) const;
	virtual Executable::addr_type offsetAddrType() const { return Executable::RAW; }

	virtual ExeElementWrapper* wrapper() const = 0;
	virtual ExeElementWrapper* wrapperAt(QModelIndex index) const { return wrapper(); }

	virtual QString makeDockerTitle(uint32_t upId) { return ""; }
	
protected:
	virtual int getFID(const QModelIndex &index) const { return index.row(); }
	virtual int getSID(const QModelIndex &index) const { return index.column(); }

	virtual QVariant dataValue(const QModelIndex &index) const;
	virtual bool isComplexValue(const QModelIndex &index) const { return false; }
	virtual QVariant complexValue(const QModelIndex &index) const;// TODO
	virtual bool setComplexValue(const QModelIndex &index, const QVariant &value, int role)  { return false; }
};

```

`pe-bear/gui_base/WrapperTableModel.cpp`:

```cpp
#include "WrapperTableModel.h"

#define COL_OFFSET 0

//-------------------------------------------

int64_t WrapperTableModel::counter = 0;

bool WrapperTableModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
	if (!index.isValid()) return false;

	size_t fID = this->getFID(index);
	size_t sID = this->getSID(index);

	ExeElementWrapper* wrap = wrapperAt(index);
	if (!wrap) return false;

	ExeElementWrapper* mainWrapper = wrapper();
	if (!mainWrapper) return false;
	
	if (wrap != mainWrapper) { //it is subWrapper
		fID = sID;
		sID = FIELD_NONE;
	}

	QString text = value.toString();

	bool isOk = false;
	ULONGLONG number = text.toULongLong(&isOk, 16);
	if (!isOk) return false;
	
	offset_t offset = wrap->getFieldOffset(fID);
	if (offset == INVALID_ADDR) {
		return false;
	}
	bufsize_t fieldSize = wrap->getFieldSize(fID);

	this->myPeHndl->backupModification(offset, fieldSize);
	
	bool isModified = wrap->setNumValue(fID, sID, number);
	if (isModified) {
		this->myPeHndl->setBlockModified(offset, fieldSize);
		return true;
	}
	this->myPeHndl->unbackupLastModification();
	return false;
}

Qt::ItemFlags WrapperTableModel::flags(const QModelIndex &index) const
{	
	if (!index.isValid()) return 0;
	Qt::ItemFlags f = Qt::ItemIsEnabled | Qt::ItemIsSelectable;

	if (this->containsOffset(index)) return f;
	if (this->containsValue(index)) return f | Qt::ItemIsEditable;
	return f;
}

QString WrapperTableModel::makeDockerTitle(uint32_t upId)
{
	ExeNodeWrapper* node = dynamic_cast<ExeNodeWrapper*>(wrapper());
	if (node == NULL) {
		return "-";
	}
	ExeNodeWrapper *childEntry = node->getEntryAt(upId);
	if (childEntry == NULL) {
		return "-";
	}
	QString name = childEntry->getName();
	uint32_t funcNum = childEntry->getEntriesCount();
	QString numDesc = funcNum == 1 ? " entry" : " entries";
	QString desc = name + "   [ " + QString::number(funcNum) + numDesc + " ]"; 
	return desc;
}

```

`pe-bear/gui_base/WrapperTableModel.h`:

```h
#pragma once

#include <QtGui>

#include "FollowablePeTreeView.h"
#include "WrapperInterface.h"


//---
class WrapperTableModel : public PeTableModel, public WrapperInterface
{
	Q_OBJECT

public slots:
	virtual void setParentId(size_t parentId)
	{
		/* only if the down table shows the details of the row from the up table */
	}

public:
	WrapperTableModel(PeHandler *peHndl, QObject *parent = 0) 
		: PeTableModel(peHndl, parent), WrapperInterface() { WrapperTableModel::counter++; }

	virtual ~WrapperTableModel() { WrapperTableModel::counter--; }
	//---
	virtual Executable::addr_type addrTypeAt(QModelIndex index) const { return  WrapperInterface::addrTypeAt(index); }
	virtual offset_t getFieldOffset(QModelIndex index) const { return WrapperInterface::getFieldOffset(index); }
	virtual bufsize_t getFieldSize(QModelIndex index) const { return WrapperInterface::getFieldSize(index); }
	//---
	/* sets data value, do backup and notifies handler */
	virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
	virtual Qt::ItemFlags flags(const QModelIndex &index) const;

	virtual int rowCount(const QModelIndex &parent) const { return wrapper() ? wrapper()->getFieldsCount() : 0; }
	
	virtual QString makeDockerTitle(uint32_t upId);
	
protected:
	static int64_t counter;
};
//------------

```

`pe-bear/main.cpp`:

```cpp
#include <iostream>
#include <QtGlobal>
#include <QtCore>

#if QT_VERSION >= 0x050000
	#include <QtWidgets>
#else
	#include <QtGui>
#endif

#include "gui/windows/MainWindow.h"

QStringList collectSuppliedFiles(int argc, char *argv[])
{
	QStringList fNames;
	if (argc <= 1) {
		return fNames;
	}
	for (int i = 1; i < argc; i++) {
		QString fileName = argv[i];
		fNames << fileName;
	}
	return fNames;
}

int main(int argc, char *argv[])
{
	Q_INIT_RESOURCE(application);

#if QT_VERSION >= 0x050000
	QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif

	QApplication app(argc, argv);

	// workaround for a bug in Qt (not setting default font properly)
	QApplication::setFont(QApplication::font("QMessageBox"));

	app.setApplicationName(TITLE);
	app.setWindowIcon(QIcon(":/main_ico.ico"));
	app.setQuitOnLastWindowClosed(true);

	MainWindow mainWin;
	mainWin.setIconSize(QSize(48, 48));
	mainWin.resize(950, 650);

	if (argc > 1) {
		QStringList fileNames = collectSuppliedFiles(argc, argv);
		mainWin.openMultiplePEs(fileNames);
	}
	mainWin.show();
	int ret = app.exec();
	return ret;
}


```

`pe-bear/resources.h`:

```h
#pragma once

#define IDI_ICON1                       101

```

`pe-bear/resources.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resources.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resources.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "main_ico.ico"
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`sig_finder/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)
project (sig_finder)

# Offer the user the choice of overriding the installation directories
set(INSTALL_LIB_DIR lib CACHE PATH "Installation directory for libraries")
set(INSTALL_BIN_DIR bin CACHE PATH "Installation directory for executables")

set (sig_srcs
	sig_finder/SigNode.cpp
	sig_finder/PckrSign.cpp
	sig_finder/SigTree.cpp
	sig_finder/SigFinder.cpp
)

set (sig_hdrs
	sig_finder/SigNode.h
	sig_finder/PckrSign.h
	sig_finder/SigTree.h
	sig_finder/SigFinder.h
	sig_finder.h
)
add_library(${PROJECT_NAME} STATIC ${sig_srcs} ${sig_hdrs})


```

`sig_finder/sig_finder.h`:

```h
#pragma once

#include "sig_finder/SigFinder.h"
#include "sig_finder/PckrSign.h"

```

`sig_finder/sig_finder/PckrSign.cpp`:

```cpp
#include "PckrSign.h"

#include <iomanip>
#include <sstream>


namespace sig_ma {
	namespace util {

		std::string to_hex(const uint8_t val)
		{
			std::stringstream ss;
			ss << std::setw(2) << std::setfill('0') << std::hex << (unsigned int)(val);
			return ss.str();
		}

	};
};

bool sig_ma::PckrSign::addNode(uint8_t val, sig_type type)
{
	nodes.push_back(SigNode(val, type));

	const size_t kMaxPreview = 255;
	if (nodes.size() < kMaxPreview) {
		// add to the content preview:
		if (type == IMM) {
			signContent += util::to_hex(val) + " ";
		}
		else if (type == WILDC) {
			signContent += "?? ";
		}
	}
	else if (nodes.size() == kMaxPreview) {
		signContent += "...";
	}
	return true;
}

```

`sig_finder/sig_finder/PckrSign.h`:

```h
/*
 * Copyright (c) 2013 hasherezade
*/

#pragma once

#include <stdio.h>
#include <set>
#include <vector>
#include <string>
#include <string.h>
#include <stdlib.h>

#include "SigNode.h"

namespace sig_ma {
//------------------

class PckrSign
{
public:
	PckrSign(std::string name1)
		: name(name1)
	{
	}

	size_t length() const
	{
		return nodes.size();
	}

	std::string getName() const { return name; }

	bool addNode(unsigned char val, sig_type type);

	std::string getContent()
	{
		return signContent;
	}

protected:
	std::string name;
	std::vector<SigNode> nodes;
	std::string signContent;

friend class SigTree;
};

}; /* namespace sig_ma */

```

`sig_finder/sig_finder/SigFinder.cpp`:

```cpp
#include "SigFinder.h"

#include <iostream>
#include <fstream>

using namespace sig_ma;

//----------------------------------------------------

/* read file with signatures */
size_t SigFinder::loadSignatures(const std::string &fname)
{
	std::ifstream input;
	input.open(fname);
	if (!input.is_open()) {
		return 0;
	}
	size_t num = tree.loadFromFile(input);
	input.close();
	return num;
}


PckrSign* SigFinder::getFirstMatch(uint8_t *buf, long buf_size, long start_offset, match_direction md)
{
	matched mtchd = getMatching(buf, buf_size, start_offset, md);
	if (mtchd.signs.size() == 0) return NULL;

	PckrSign* sign = *mtchd.signs.begin();
	return sign;
}

matched SigFinder::getMatching(uint8_t *buf, long buf_size, long start_offset, match_direction md)
{
	long srch_size = buf_size - start_offset;
	uint8_t* srch_bgn = buf + start_offset;
	size_t min_sig_len = tree.getMinLen();
	
	matched matched;
	matched.match_offset = 0;

	bool skipNOPs = (md == FIXED)? true : false;

	if (md == FIXED) {
		matched = tree.getMatching(srch_bgn, srch_size, skipNOPs);
		matched.match_offset += srch_bgn - (buf + start_offset);
		return matched; 
	}

	if (md == FRONT_TO_BACK) {
		while (srch_size > min_sig_len) {
			matched = tree.getMatching(srch_bgn, srch_size, skipNOPs);

			if (matched.signs.size() > 0) {
				matched.match_offset += srch_bgn - (buf + start_offset);
				return matched;
			}
			srch_size--;
			srch_bgn++;
		}

	} else if (md == BACK_TO_FRONT) {
		while (srch_size > min_sig_len && srch_size <= buf_size) {
			matched = tree.getMatching(srch_bgn, srch_size, skipNOPs);
			if (matched.signs.size() > 0) {
				matched.match_offset += (buf + start_offset) - srch_bgn;
				return matched;
			}
			srch_size++;
			srch_bgn--;
		}
	}
	return matched; /* empty set */
}

```

`sig_finder/sig_finder/SigFinder.h`:

```h
#pragma once

#include <set>
#include "SigTree.h"

namespace sig_ma {
//------------------

class FoundPacker {

public:
	FoundPacker(uint64_t offs, sig_ma::PckrSign* sig) : offset(offs), signaturePtr(sig) { }

	uint64_t offset;
	sig_ma::PckrSign* signaturePtr; // do not delete it - belongs to SignFinder

	bool operator== (const FoundPacker& f2) { return (this->offset == f2.offset && this->signaturePtr == f2.signaturePtr);}
};

enum match_direction {
	FIXED,
	FRONT_TO_BACK,
	BACK_TO_FRONT
};


class SigFinder
{
public:
	SigFinder(void) {}
	~SigFinder(void){}

	PckrSign* getFirstMatch(uint8_t *buf, long buf_size, long start_offset = 0, match_direction md = FIXED);

	matched getMatching(uint8_t *buf, long buf_size, long start_offset, match_direction md = FIXED);

	size_t loadSignatures(const std::string &fname);

	std::set<PckrSign*>& signatures() { return tree.all_signatures; };
	std::vector<PckrSign*>& signaturesVec() { return tree.signaturesVec; }

protected:
	SigTree tree;
};
//---
}; //namespace sig_ma
//------------------
```

`sig_finder/sig_finder/SigNode.cpp`:

```cpp
/* 
* Copyright (c) 2013 hasherezade
*/

#include "SigNode.h"
using namespace sig_ma;

//--------------------------------------

bool SigNode::sig_compare::operator() (const SigNode* el1, const SigNode* el2 ) const
{
	return (*el1) < (*el2); 
}

SigNode::SigNode(uint8_t val, sig_type type)
{
	this->v =val;
	this->type = type;
}

SigNode::~SigNode()
{
	std::set<SigNode*, sig_compare>::iterator itr;
	
	for (itr = childs.begin(); itr != childs.end();) {
		SigNode* node = *itr;
		++itr;
		delete node;
	}

	for (itr = wildcards.begin(); itr != wildcards.end(); ) {
		SigNode* node = *itr;
		++itr;
		delete node;
	}
}

SigNode* SigNode::getWildc()
{
	/* TODO: value masking */
	SigNode srchd(WILD_ONE, WILDC);
	std::set<SigNode*, sig_compare>::iterator found = wildcards.find(&srchd);
	if (found == wildcards.end()) return NULL;
	return (*found);
}

SigNode* SigNode::getChild(uint8_t val)
{
	SigNode srchd(val, IMM);
	std::set<SigNode*, sig_compare>::iterator found = childs.find(&srchd);
	if (found == childs.end()) return NULL;
	return (*found);
}

//-----------------------------------------

SigNode* SigNode::putChild(uint8_t val)
{
	SigNode* f_node = NULL;
	SigNode* srchd = new SigNode(val, IMM);
	
	std::set<SigNode*, sig_compare>::iterator found = childs.find(srchd);
	if (found == childs.end()) {
		f_node = srchd;
		childs.insert(f_node);
		//if (DBG_LVL > 1) printf("[+] %02X %c\n", val, val);

	} else {
		f_node = *found;
		delete srchd; //already exists, no need for the new one
		//if (DBG_LVL > 1) printf("[#] %02X %c\n", val, val);
	}
	return f_node;
}

SigNode* SigNode::putWildcard(uint8_t val)
{
	SigNode* f_node = NULL;
	SigNode *srchd = new SigNode(val, WILDC);

	std::set<SigNode*, sig_compare>::iterator found = wildcards.find(srchd);
	if (found == wildcards.end()) {
		f_node = srchd;
		wildcards.insert(f_node);
		//if (DBG_LVL > 1) printf("[+W] %02X %c\n", val, val);
		
	} else {
		f_node = *found;
		delete srchd; //already exists, no need for the new one
		//if (DBG_LVL > 1) printf("[#W] %02X %c\n", val, val);

	}
	return f_node;
}

```

`sig_finder/sig_finder/SigNode.h`:

```h
/*
 * Copyright (c) 2013 hasherezade
*/

#pragma once

#include <stdio.h>
#include <set>
#include <vector>
#include <string>
#include <string.h>
#include <stdlib.h>
#include "../win_types.h"

#define OP_NOP 0x90


namespace sig_ma {
//------------------
enum sig_wildc {
	WILD_NONE = 0,
	WILD_ONE = '?'
};

enum sig_type {
    ROOT = 0,
    IMM,
    WILDC,
    MATCH
};

bool inline is_hex(char c) {
	if ((c >= '0' && c <='9') || (c >='a' && c <='f') || (c >='A' && c <='F')) return true;
	return false;
};

class SigNode
{
public:
	struct sig_compare {
		bool operator()(const SigNode* el1, const SigNode* el2 ) const;
	};

	SigNode(uint8_t val, sig_type type = IMM);
	~SigNode();

	SigNode* getWildc();
	SigNode* getChild(uint8_t val);

	SigNode* putChild(uint8_t val);
	SigNode* putWildcard(uint8_t val);

	bool operator==(const SigNode &el) const { return el.v == this->v; }
	bool operator!=(const SigNode &el) const { return el.v != this->v; }
	bool operator<(const SigNode &el) const { return el.v < this->v; }

private:
	uint8_t v;
	sig_type type;
	std::set<SigNode*, sig_compare> childs;
	std::set<SigNode*, sig_compare> wildcards;

friend class SigTree;
};

}; /* namespace sig_ma */

```

`sig_finder/sig_finder/SigTree.cpp`:

```cpp
/* 
* Copyright (c) 2013 hasherezade
*/

#include "SigTree.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

//--------------------------------------
/* Util*/
#include <ctype.h>

namespace util {

    std::string& ltrim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
    {
        str.erase(0, str.find_first_not_of(chars));
        return str;
    }

    std::string& rtrim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
    {
        str.erase(str.find_last_not_of(chars) + 1);
        return str;
    }

    std::string& trim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
    {
        return ltrim(rtrim(str, chars), chars);
    }
}

//--------------------------------------

using namespace sig_ma;

void SigTree::clear()
{
	nodeToSign.clear();

	std::set<PckrSign*>::iterator sigItr;
	for (sigItr = this->all_signatures.begin(); sigItr != this->all_signatures.end(); ++sigItr ) {
		PckrSign* sign = (*sigItr);
		delete sign;
	}
	this->all_signatures.clear();
	signaturesVec.clear();
}


bool SigTree::addPckrSign(PckrSign *sign)
{
	if (!sign) return false;

	SigNode* currNode = &root;

	for (int indx = 0; indx < sign->nodes.size(); indx++) {
		char value = sign->nodes[indx].v;
		SigNode* nextNode = NULL;

		if (sign->nodes[indx].type == WILDC) {
			nextNode = currNode->putWildcard(value);
		} else {
			nextNode = currNode->putChild(value);
		}
		if (nextNode == NULL) {
			printf("Error in signature adding!\n");
			return false;
		}
		currNode = nextNode;
	}

	if (nodeToSign[currNode] == NULL) {
		nodeToSign[currNode] = sign;
		insertPckrSign(sign);
		return true;
	}
	return false;
}

void SigTree::insertPckrSign(PckrSign* sign)
{
	if (!sign) return;
	size_t signCount = all_signatures.size();
	all_signatures.insert(sign);

	if (all_signatures.size() > signCount) {
		signaturesVec.push_back(sign);
	}

	size_t len = sign->length();
	if (this->min_siglen == 0 || this->min_siglen > len) 
		this->min_siglen = len;
	
	if (this->max_siglen == 0 || this->max_siglen < len) 
		this->max_siglen = len;
}


matched SigTree::getMatching(uint8_t *buf, size_t buf_len, bool skipNOPs)
{
	matched matchedSet;
	matchedSet.match_offset = 0;

	if (buf == NULL) return matchedSet; /* Empty */

	std::vector<SigNode*> level;
	level.push_back(&root);

	long checked = 0;
	long skipped = 0;
	for (int indx = 0; indx < buf_len; indx++) {
		uint8_t b = buf[indx];

		std::vector<SigNode*> level2;
		std::vector<SigNode*>::iterator lvlI;
		
		for (lvlI = level.begin(); lvlI != level.end(); ++lvlI) {
			std::vector<SigNode*>::iterator curr = lvlI;

			//TODO: allow for alternate sig search paths: with wildcards AND with exact matches
			SigNode *nextC = (*curr)->getChild(b);
			if (!nextC) {
				nextC = (*curr)->getWildc();
			}

			if (nextC) {
				PckrSign *sig = this->nodeToSign[nextC];
				if (sig) {
					matchedSet.signs.insert(sig);
				}
				level2.push_back(nextC);
			}
		}
		//-----
		if (level2.size() == 0) {
			if (buf[indx] == OP_NOP && skipNOPs) { //skip NOPs
				if (checked == 0) {
					matchedSet.match_offset++;
				}
				skipped++;
				continue;
			}
			break;
		}
		checked++;
		level = level2;
	}
	return matchedSet;
}

size_t SigTree::loadFromFile(std::ifstream& input)
{
	if (!input.is_open()) return 0;

	sig_type type = ROOT;
	size_t loadedNum = 0;

	while (!input.eof()) {
		std::string line;

		// read signature name
		if (!std::getline(input, line)) break;
		std::string name = util::trim(line);

		// read signature size
		if (!std::getline(input, line)) break;
		int signSize = 0;
		std::stringstream iss1;
		iss1 << std::dec << line;
		iss1 >> signSize; //read the expected size
		if (signSize == 0) continue;

		PckrSign *sign = new PckrSign(name); // <- new signature created

		bool isFin = false;
		// read signature chunks:
		while ( !input.eof() && (sign->length() < signSize) ){

			// parse all chunks from the line
			char chunk[3] = { 0, 0, 0 };
			input >> chunk[0];
			input >> chunk[1];

			unsigned int val = 0;
			if (is_hex(chunk[0]) && is_hex(chunk[1])) {
				type = IMM;
				sscanf(chunk, "%2X", &val);
			}
			else if (chunk[0] == WILD_ONE) {
				type = WILDC;
				val = chunk[0];
			}
			else break;

			sign->addNode(val, type);
		}

		// check if the signature is valid:
		if (sign->length() == signSize) {
			if (this->addPckrSign(sign)) { // <- new signature stored
				loadedNum++;
				continue; // success
			}
		}
		//failure:
		delete sign;
		sign = NULL;
	}

	return loadedNum;
}

```

`sig_finder/sig_finder/SigTree.h`:

```h
/*
 * Copyright (c) 2013 hasherezade
*/

#pragma once
#include <map>

#include <stdio.h>
#include <string>
#include <string.h>
#include <stdlib.h>

#include <iostream>
#include <fstream>

#include "SigNode.h"
#include "PckrSign.h"

namespace sig_ma {
//------------------

struct matched {
	std::set<PckrSign*> signs;
	uint64_t match_offset;
};
//------------------

class SigTree
{
public:
	SigTree() : root(0, ROOT),  min_siglen(0), max_siglen(0) {}
	~SigTree() { clear(); }

	bool addPckrSign(PckrSign *sign);
	size_t loadFromFile(std::ifstream& input);

	matched getMatching(uint8_t *buf, size_t buf_len, bool skipNOPs);

	size_t getMinLen() { return min_siglen; }
	size_t getMaxLen() { return max_siglen; }

protected:
	void insertPckrSign(PckrSign* sign);

	//---
	std::map<SigNode*, PckrSign*> nodeToSign;
	std::set<PckrSign*> all_signatures;
	std::vector<PckrSign*> signaturesVec;
	SigNode root;
	
	size_t min_siglen;
	size_t max_siglen;

private:
	void clear(); //destroys all the signatures!

friend class SigFinder;
};
//-----------------------
}; // namespace sig_ma

```

`sig_finder/win_types.h`:

```h
#ifndef USE_WINNT

#ifndef __WIN_TYPES__
#define __WIN_TYPES__

#if _MSC_VER
    #define snprintf _snprintf
    #define snscanf _snscanf
#endif

#ifdef _MSC_VER
    typedef signed char        int8_t;
    typedef short              int16_t;
    typedef int                int32_t;
    typedef long long          int64_t;
    typedef unsigned char      uint8_t;
    typedef unsigned short     uint16_t;
    typedef unsigned int       uint32_t;
    typedef unsigned long long uint64_t;
#else
# include <inttypes.h>
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef BOOLEAN
   typedef BYTE BOOLEAN;
#endif

#ifndef BOOL
   typedef BYTE BOOL; 
#endif

#ifndef WORD
   typedef uint16_t WORD; 
#endif

#ifndef DWORD
   typedef uint32_t DWORD; 
#endif

#ifndef ULONGLONG
   typedef uint64_t ULONGLONG;
#endif

#ifndef CHAR
    typedef char CHAR;
#endif

#ifndef WCHAR
    typedef wchar_t WCHAR;
#endif

#ifndef VOID
    #define VOID void
    typedef char CHAR;
    typedef uint16_t SHORT;
    typedef uint32_t LONG;

    #if !defined(MIDL_PASS)
	typedef int INT;
    #endif
#endif //VOID

#endif /* __WIN_TYPES__*/
#endif /* #ifndef USE_WINNT */

```