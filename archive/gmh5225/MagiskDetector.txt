Project Path: arc_gmh5225_MagiskDetector_9ct454jg

Source Tree:

```txt
arc_gmh5225_MagiskDetector_9ct454jg
├── LICENSE
├── README.md
├── README_ZH.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── aidl
│           │   └── io
│           │       └── github
│           │           └── vvb2060
│           │               └── magiskdetector
│           │                   └── IRemoteService.aidl
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── vvb2060
│           │               └── magiskdetector
│           │                   ├── AppZygote.java
│           │                   ├── MainActivity.java
│           │                   ├── Native.java
│           │                   └── RemoteService.java
│           ├── jni
│           │   ├── Android.mk
│           │   ├── Application.mk
│           │   ├── cpp.cpp
│           │   ├── linux_syscall_support.h
│           │   ├── logging.h
│           │   └── vvb2060.c
│           └── res
│               ├── layout
│               │   └── activity_main.xml
│               ├── menu
│               │   └── menu.xml
│               ├── values
│               │   └── strings.xml
│               ├── values-zh-rCN
│               │   └── strings.xml
│               └── values-zh-rTW
│                   └── strings.xml
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
Magisk Detector
==============================

[细节（中文）](README_ZH.md)

It's time to end the game.

是时候结束游戏了。


Getting Started
---------------

To build this project, use the `gradlew aR` command or use "Import Project" in Android Studio.

构建此项目，请使用`gradlew aR`命令，或在Android Studio中导入项目。

License
-------

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`README_ZH.md`:

```md
Magisk Detector
==============================

反Magisk Hide
-------------
Magisk Hide的核心是挂载命名空间，magiskd等待zygote子进程的挂载命名空间与父进程分离后，对子进程卸载所有Magisk挂载的内容。由于挂载命名空间的特性，卸载操作会影响这个子进程的子进程，但不会影响zygote。zygote是所有应用程序进程的父进程，如果zygote被Magisk Hide处理，所有应用都会丢失root。
zygote启动新进程时有一个`MountMode`参数，当它是`Zygote.MOUNT_EXTERNAL_NONE`时，新进程不挂载存储空间，也就没有挂载命名空间分离步骤。

符合的情况有两种，一个是应用appops的读取存储空间op为忽略，一个是该进程为隔离进程。前者应用本身无法操作，后者自Android4.1开始支持。
另外，隔离进程还有一个有趣的特性，就是随机UID，它每次运行时的UID都不一样。这个有趣的特性导致了在检测挂载命名空间之前，Magisk Hide就跳过了这个进程，不会处理它。

检测Magisk模块
-------------
Magisk模块虽然能在文件系统上隐藏，但修改内容已经载入进程内存，检查进程的maps就能发现。maps显示的数据包含载入文件所在的设备。Magisk模块会导致某些文件的路径在system分区或vendor分区，但显示的设备位置却是data分区。

检测MagiskSU
------------
正常情况下，应用不能连接不是自己建立的socket，但Magisk修改了SELinux。所有应用都能连接magisk域的socket。每个Magisk的su进程都会建立一个socket，尝试连接所有socket，没有被SELinux拒绝的socket数量，就是su进程的数量。此检测方法可靠程度完全取决于SELinux规则的严格程度，Android版本太低或太高都会出问题。

测试SELinux政策
--------------
SU软件在修改SELinux政策时一定要注意以下原则，否则会留下安全漏洞和被检测的途径。
- 来源域和目标域，有一方是su程序自定义域，添加规则是安全的；
- 双方都是非应用程序域的，需要有合理且必要的原因；
- 有一方是应用域，添加规则非常危险。如果是来源域，应该拒绝添加。

检测init.rc修改
--------------
随机只有在无法遍历的情况下才有效。如果可以遍历，使用统计方法即可准确找出每次都不一样的东西。

```

`app/build.gradle`:

```gradle
plugins {
    id 'com.android.application'
}

android {
    compileSdkVersion 30
    buildToolsVersion '30.0.2'
    ndkVersion '21.3.6528147'
    defaultConfig {
        applicationId 'io.github.vvb2060.magiskdetector'
        minSdkVersion 23
        targetSdkVersion 30
        versionCode 6
        versionName '2.3'
    }

    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            signingConfig signingConfigs.debug
            proguardFiles 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildFeatures {
        buildConfig false
        viewBinding true
        prefab true
    }

    externalNativeBuild {
        ndkBuild.path 'src/main/jni/Android.mk'
    }

    packagingOptions {
        exclude '/META-INF/**'
        exclude '/*.properties'
    }

    dependenciesInfo.includeInApk false
}

dependencies {
    //noinspection GradleDependency
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.security:security-crypto:1.1.0-alpha02'
    implementation 'androidx.cardview:cardview:1.0.0'

    implementation 'io.github.vvb2060.ndk:xposeddetector:1.0'
    implementation 'io.github.vvb2060.ndk:boringssl:1.0'
}

```

`app/proguard-rules.pro`:

```pro
-repackageclasses
-allowaccessmodification
-keepclasseswithmembernames class * {
    native <methods>;
}
-keepclassmembers,allowoptimization class io.github.vvb2060.magiskdetector.Native {
    <methods>;
}

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="io.github.vvb2060.magiskdetector">

    <application
        android:allowBackup="false"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@android:style/Theme.DeviceDefault"
        android:zygotePreloadName="io.github.vvb2060.magiskdetector.AppZygote"
        tools:ignore="AllowBackup,MissingApplicationIcon"
        tools:targetApi="q">

        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".RemoteService"
            android:isolatedProcess="true"
            android:useAppZygote="true" />

    </application>

</manifest>

```

`app/src/main/aidl/io/github/vvb2060/magiskdetector/IRemoteService.aidl`:

```aidl
package io.github.vvb2060.magiskdetector;

interface IRemoteService {
    boolean haveSu();
}

```

`app/src/main/java/io/github/vvb2060/magiskdetector/AppZygote.java`:

```java
package io.github.vvb2060.magiskdetector;

import android.annotation.TargetApi;
import android.content.pm.ApplicationInfo;
import android.os.Build;

import androidx.annotation.NonNull;

@TargetApi(Build.VERSION_CODES.Q)
public class AppZygote implements android.app.ZygotePreload {

    @Override
    public void doPreload(@NonNull ApplicationInfo appInfo) {
        System.loadLibrary("vvb2060");
    }
}

```

`app/src/main/java/io/github/vvb2060/magiskdetector/MainActivity.java`:

```java
package io.github.vvb2060.magiskdetector;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.os.SystemClock;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;

import androidx.security.crypto.EncryptedSharedPreferences;
import androidx.security.crypto.MasterKey;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;

import io.github.vvb2060.magiskdetector.databinding.ActivityMainBinding;

public class MainActivity extends Activity {

    private static final String TAG = "MagiskDetector";
    private ActivityMainBinding binding;
    private final ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            IRemoteService service = IRemoteService.Stub.asInterface(binder);
            try {
                setCard1(service.haveSu());
            } catch (RemoteException e) {
                Log.e(TAG, "RemoteException", e);
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            binding.textView.setText(R.string.error);
        }

        @Override
        public void onNullBinding(ComponentName name) {
            setError();
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());
    }

    @Override
    protected void onStart() {
        super.onStart();
        Intent intent = new Intent(getApplicationContext(), RemoteService.class);
        if (!bindService(intent, connection, BIND_AUTO_CREATE)) setError();
        setCard2(Native.haveMagicMount());
        setCard3(Native.findMagiskdSocket());
        setCard4(Native.haveSu() == 0);
        setCard5(Native.testIoctl());
        setCard6(props());
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.logcat) {
            Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT)
                    .addCategory(Intent.CATEGORY_OPENABLE)
                    .setType("text/plain")
                    .putExtra(Intent.EXTRA_TITLE, TAG);
            startActivityForResult(intent, 42);
            return true;
        } else return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_OK) {
            if (requestCode == 42 && data.getData() != null) {
                try {
                    OutputStream outputStream = getContentResolver().openOutputStream(data.getData());
                    InputStream inputStream = Runtime.getRuntime().exec("/system/bin/logcat -d -v long").getInputStream();
                    assert outputStream != null;
                    byte[] buffer = new byte[8 * 1024];
                    int bytes;
                    while ((bytes = inputStream.read(buffer)) >= 0)
                        outputStream.write(buffer, 0, bytes);
                } catch (IOException e) {
                    Log.e(TAG, "Unable to save log.", e);
                }
            }
        } else super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected void onStop() {
        super.onStop();
        unbindService(connection);
    }

    private int props() {
        SharedPreferences sp;
        try {
            MasterKey masterKey = new MasterKey.Builder(this)
                    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                    .build();
            sp = EncryptedSharedPreferences.create(
                    this,
                    getPackageName(),
                    masterKey,
                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            );
        } catch (GeneralSecurityException | IOException e) {
            Log.e(TAG, "Unable to open SharedPreferences.", e);
            return -1;
        }

        String spFingerprint = sp.getString("fingerprint", "");
        String fingerprint = Build.FINGERPRINT;
        Log.i(TAG, "spFingerprint=" + spFingerprint + " \n  fingerprint=" + fingerprint);
        String spBootId = sp.getString("boot_id", "");
        String bootId = getBootId();
        Log.i(TAG, "spBootId=" + spBootId + " \n  bootId=" + bootId);
        String spPropsHash = sp.getString("props_hash", "");
        if (spFingerprint.equals(fingerprint) && spBootId.length() > 0 && spPropsHash.length() > 0) {
            if (!spBootId.equals(bootId)) {
                return spPropsHash.equals(Native.getPropsHash()) ? 0 : 1;
            } else return 2;
        } else {
            SharedPreferences.Editor editor = sp.edit();
            editor.putString("fingerprint", fingerprint);
            editor.putString("boot_id", bootId);
            editor.putString("props_hash", Native.getPropsHash());
            editor.apply();
            return 2;
        }
    }

    private String getBootId() {
        String bootId = "";
        try (InputStream is = new FileInputStream("/proc/sys/kernel/random/boot_id")) {
            Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8);
            bootId = new BufferedReader(reader).readLine().trim();
        } catch (IOException e) {
            Log.w(TAG, "Can't read boot_id.", e);
        }
        if (bootId.length() == 0) {
            bootId = String.valueOf((System.currentTimeMillis() - SystemClock.elapsedRealtime()) / 10);
        }
        return bootId;
    }

    private void setCard1(boolean havesu) {
        String text;
        if (havesu) {
            text = getString(R.string.test1_t);
            binding.cardView4.setVisibility(View.VISIBLE);
        } else {
            text = getString(R.string.test1_f);
            binding.cardView4.setVisibility(View.GONE);
        }
        binding.textView.setText(getString(R.string.display, getString(R.string.test1), text));
    }

    private void setCard2(int haveMagicMount) {
        String text;
        switch (haveMagicMount) {
            case 0:
                text = getString(R.string.test2_0);
                break;
            case 1:
                text = getString(R.string.test2_1);
                break;
            default:
                text = getString(R.string.test2_d);
        }
        binding.textView2.setText(getString(R.string.display, getString(R.string.test2), text));
    }

    private void setCard3(int magiskdSocket) {
        String text;
        switch (magiskdSocket) {
            case 0:
                text = getString(R.string.test3_0);
                break;
            case -1:
                text = getString(R.string.test3_1);
                break;
            case -2:
                text = getString(R.string.test3_2);
                break;
            case -3:
                text = getString(R.string.test3_3);
                break;
            default:
                text = getString(R.string.test3_d, magiskdSocket);
        }
        binding.textView3.setText(getString(R.string.display, getString(R.string.test3), text));
    }

    private void setCard4(boolean havesu) {
        String text = havesu ? getString(R.string.test4_t) : getString(R.string.test4_f);
        binding.textView4.setText(getString(R.string.display, getString(R.string.test4), text));
    }

    private void setCard5(int testIoctl) {
        String text;
        switch (testIoctl) {
            case -1:
            default:
                text = getString(R.string.test5_01);
                break;
            case 0:
                text = getString(R.string.test5_0);
                break;
            case 1:
                text = getString(R.string.test5_1);
                break;
            case 2:
                text = getString(R.string.test5_2);
                break;
        }
        binding.textView5.setText(getString(R.string.display, getString(R.string.test5), text));
    }

    private void setCard6(int props) {
        String text;
        switch (props) {
            case -1:
            default:
                text = getString(R.string.test6_01);
                break;
            case 0:
                text = getString(R.string.test6_0);
                break;
            case 1:
                text = getString(R.string.test6_1);
                break;
            case 2:
                text = getString(R.string.test6_2);
                break;
        }
        binding.textView6.setText(getString(R.string.display, getString(R.string.test6), text));
    }

    private void setError() {
        binding.textView.setText(R.string.error);
        binding.cardView2.setVisibility(View.GONE);
        binding.cardView3.setVisibility(View.GONE);
        binding.cardView4.setVisibility(View.GONE);
    }
}

```

`app/src/main/java/io/github/vvb2060/magiskdetector/Native.java`:

```java
package io.github.vvb2060.magiskdetector;

public class Native {
    static {
        System.loadLibrary("vvb2060");
    }

    static native int haveSu();

    static native int haveMagicMount();

    static native int findMagiskdSocket();

    static native int testIoctl();

    static native String getPropsHash();
}

```

`app/src/main/java/io/github/vvb2060/magiskdetector/RemoteService.java`:

```java
package io.github.vvb2060.magiskdetector;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.system.Os;

public class RemoteService extends Service {
    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
        @Override
        public boolean haveSu() {
            return Native.haveSu() == 0;
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        int appId = Os.getuid() % 100000;
        if (appId >= 90000) return mBinder;
        else return null;
    }

}

```

`app/src/main/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE           := vvb2060
LOCAL_CFLAGS           := -Oz
LOCAL_SRC_FILES        := vvb2060.c cpp.cpp
LOCAL_LDLIBS           := -llog
LOCAL_STATIC_LIBRARIES := xposed_detector crypto_static
include $(BUILD_SHARED_LIBRARY)

$(call import-module,prefab/xposeddetector)
$(call import-module,prefab/boringssl)

```

`app/src/main/jni/Application.mk`:

```mk
APP_CFLAGS     := -Wall -Wextra -Wshadow -Werror -fvisibility=hidden
APP_CONLYFLAGS := -std=c18
APP_STL        := c++_static

```

`app/src/main/jni/cpp.cpp`:

```cpp
// Add a cpp file to fix NDK bug

```

`app/src/main/jni/linux_syscall_support.h`:

```h
/* Copyright (c) 2005-2011, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 * Author: Markus Gutschke
 */

/* This file includes Linux-specific support functions common to the
 * coredumper and the thread lister; primarily, this is a collection
 * of direct system calls, and a couple of symbols missing from
 * standard header files.
 * There are a few options that the including file can set to control
 * the behavior of this file:
 *
 * SYS_CPLUSPLUS:
 *   The entire header file will normally be wrapped in 'extern "C" { }",
 *   making it suitable for compilation as both C and C++ source. If you
 *   do not want to do this, you can set the SYS_CPLUSPLUS macro to inhibit
 *   the wrapping. N.B. doing so will suppress inclusion of all prerequisite
 *   system header files, too. It is the caller's responsibility to provide
 *   the necessary definitions.
 *
 * SYS_ERRNO:
 *   All system calls will update "errno" unless overriden by setting the
 *   SYS_ERRNO macro prior to including this file. SYS_ERRNO should be
 *   an l-value.
 *
 * SYS_INLINE:
 *   New symbols will be defined "static inline", unless overridden by
 *   the SYS_INLINE macro.
 *
 * SYS_LINUX_SYSCALL_SUPPORT_H
 *   This macro is used to avoid multiple inclusions of this header file.
 *   If you need to include this file more than once, make sure to
 *   unset SYS_LINUX_SYSCALL_SUPPORT_H before each inclusion.
 *
 * SYS_PREFIX:
 *   New system calls will have a prefix of "sys_" unless overridden by
 *   the SYS_PREFIX macro. Valid values for this macro are [0..9] which
 *   results in prefixes "sys[0..9]_". It is also possible to set this
 *   macro to -1, which avoids all prefixes.
 *
 * SYS_SYSCALL_ENTRYPOINT:
 *   Some applications (such as sandboxes that filter system calls), need
 *   to be able to run custom-code each time a system call is made. If this
 *   macro is defined, it expands to the name of a "common" symbol. If
 *   this symbol is assigned a non-NULL pointer value, it is used as the
 *   address of the system call entrypoint.
 *   A pointer to this symbol can be obtained by calling
 *   get_syscall_entrypoint()
 *
 * This file defines a few internal symbols that all start with "LSS_".
 * Do not access these symbols from outside this file. They are not part
 * of the supported API.
 */
#ifndef SYS_LINUX_SYSCALL_SUPPORT_H
#define SYS_LINUX_SYSCALL_SUPPORT_H

/* We currently only support x86-32, x86-64, ARM, MIPS, PPC, s390 and s390x
 * on Linux.
 * Porting to other related platforms should not be difficult.
 */
#if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) ||   \
     defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__) || \
     defined(__aarch64__) || defined(__s390__)) \
  && (defined(__linux) || defined(__ANDROID__))

#ifndef SYS_CPLUSPLUS
#ifdef __cplusplus
/* Some system header files in older versions of gcc neglect to properly
 * handle being included from C++. As it appears to be harmless to have
 * multiple nested 'extern "C"' blocks, just add another one here.
 */
extern "C" {
#endif

#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <linux/unistd.h>
#include <endian.h>

#ifdef __mips__
/* Include definitions of the ABI currently in use.                          */
#ifdef __ANDROID__
/* Android doesn't have sgidefs.h, but does have asm/sgidefs.h,
 * which has the definitions we need.
 */
#include <asm/sgidefs.h>
#else
#include <sgidefs.h>
#endif
#endif
#endif

/* Some libcs, for example Android NDK and musl, #define these
 * macros as aliases to their non-64 counterparts. To avoid naming
 * conflict, remove them.
 *
 * These are restored by the corresponding #pragma pop_macro near
 * the end of this file.
 */
#pragma push_macro("stat64")
#pragma push_macro("fstat64")
#pragma push_macro("lstat64")
#pragma push_macro("pread64")
#pragma push_macro("pwrite64")
#pragma push_macro("getdents64")
#undef stat64
#undef fstat64
#undef lstat64
#undef pread64
#undef pwrite64
#undef getdents64

#if defined(__ANDROID__) && defined(__x86_64__)
// A number of x86_64 syscalls are blocked by seccomp on recent Android;
// undefine them so that modern alternatives will be used instead where
// possible.
// The alternative syscalls have been sanity checked against linux-3.4+;
// older versions might not work.
# undef __NR_getdents
# undef __NR_dup2
# undef __NR_fork
# undef __NR_getpgrp
# undef __NR_open
# undef __NR_poll
# undef __NR_readlink
# undef __NR_stat
# undef __NR_unlink
# undef __NR_pipe
#endif

#if defined(__ANDROID__)
// waitpid is blocked by seccomp on all architectures on recent Android.
# undef __NR_waitpid
#endif

/* As glibc often provides subtly incompatible data structures (and implicit
 * wrapper functions that convert them), we provide our own kernel data
 * structures for use by the system calls.
 * These structures have been developed by using Linux 2.6.23 headers for
 * reference. Note though, we do not care about exact API compatibility
 * with the kernel, and in fact the kernel often does not have a single
 * API that works across architectures. Instead, we try to mimic the glibc
 * API where reasonable, and only guarantee ABI compatibility with the
 * kernel headers.
 * Most notably, here are a few changes that were made to the structures
 * defined by kernel headers:
 *
 * - we only define structures, but not symbolic names for kernel data
 *   types. For the latter, we directly use the native C datatype
 *   (i.e. "unsigned" instead of "mode_t").
 * - in a few cases, it is possible to define identical structures for
 *   both 32bit (e.g. i386) and 64bit (e.g. x86-64) platforms by
 *   standardizing on the 64bit version of the data types. In particular,
 *   this means that we use "unsigned" where the 32bit headers say
 *   "unsigned long".
 * - overall, we try to minimize the number of cases where we need to
 *   conditionally define different structures.
 * - the "struct kernel_sigaction" class of structures have been
 *   modified to more closely mimic glibc's API by introducing an
 *   anonymous union for the function pointer.
 * - a small number of field names had to have an underscore appended to
 *   them, because glibc defines a global macro by the same name.
 */

/* include/linux/dirent.h                                                    */
struct kernel_dirent64 {
  unsigned long long d_ino;
  long long          d_off;
  unsigned short     d_reclen;
  unsigned char      d_type;
  char               d_name[256];
};

/* include/linux/dirent.h                                                    */
#if !defined(__NR_getdents)
// when getdents is not available, getdents64 is used for both.
#define kernel_dirent kernel_dirent64
#else
struct kernel_dirent {
  long               d_ino;
  long               d_off;
  unsigned short     d_reclen;
  char               d_name[256];
};
#endif

/* include/linux/uio.h                                                       */
struct kernel_iovec {
  void               *iov_base;
  unsigned long      iov_len;
};

/* include/linux/socket.h                                                    */
struct kernel_msghdr {
  void               *msg_name;
  int                msg_namelen;
  struct kernel_iovec*msg_iov;
  unsigned long      msg_iovlen;
  void               *msg_control;
  unsigned long      msg_controllen;
  unsigned           msg_flags;
};

/* include/asm-generic/poll.h                                                */
struct kernel_pollfd {
  int                fd;
  short              events;
  short              revents;
};

/* include/linux/resource.h                                                  */
struct kernel_rlimit {
  unsigned long      rlim_cur;
  unsigned long      rlim_max;
};

/* include/linux/time.h                                                      */
struct kernel_timespec {
  long               tv_sec;
  long               tv_nsec;
};

/* include/linux/time.h                                                      */
struct kernel_timeval {
  long               tv_sec;
  long               tv_usec;
};

/* include/linux/resource.h                                                  */
struct kernel_rusage {
  struct kernel_timeval ru_utime;
  struct kernel_timeval ru_stime;
  long               ru_maxrss;
  long               ru_ixrss;
  long               ru_idrss;
  long               ru_isrss;
  long               ru_minflt;
  long               ru_majflt;
  long               ru_nswap;
  long               ru_inblock;
  long               ru_oublock;
  long               ru_msgsnd;
  long               ru_msgrcv;
  long               ru_nsignals;
  long               ru_nvcsw;
  long               ru_nivcsw;
};

#if defined(__i386__) || defined(__ARM_EABI__) || defined(__ARM_ARCH_3__) \
  || defined(__PPC__) || (defined(__s390__) && !defined(__s390x__))

/* include/asm-{arm,i386,mips,ppc}/signal.h                                  */
struct kernel_old_sigaction {
  union {
    void             (*sa_handler_)(int);
    void             (*sa_sigaction_)(int, siginfo_t *, void *);
  };
  unsigned long      sa_mask;
  unsigned long      sa_flags;
  void               (*sa_restorer)(void);
} __attribute__((packed,aligned(4)));
#elif (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
  #define kernel_old_sigaction kernel_sigaction
#elif defined(__aarch64__)
  // No kernel_old_sigaction defined for arm64.
#endif

/* Some kernel functions (e.g. sigaction() in 2.6.23) require that the
 * exactly match the size of the signal set, even though the API was
 * intended to be extensible. We define our own KERNEL_NSIG to deal with
 * this.
 * Please note that glibc provides signals [1.._NSIG-1], whereas the
 * kernel (and this header) provides the range [1..KERNEL_NSIG]. The
 * actual number of signals is obviously the same, but the constants
 * differ by one.
 */
#ifdef __mips__
#define KERNEL_NSIG 128
#else
#define KERNEL_NSIG  64
#endif

/* include/asm-{arm,aarch64,i386,mips,x86_64}/signal.h                       */
struct kernel_sigset_t {
  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)/
                    (8*sizeof(unsigned long))];
};

/* include/asm-{arm,i386,mips,x86_64,ppc}/signal.h                           */
struct kernel_sigaction {
#ifdef __mips__
  unsigned long      sa_flags;
  union {
    void             (*sa_handler_)(int);
    void             (*sa_sigaction_)(int, siginfo_t *, void *);
  };
  struct kernel_sigset_t sa_mask;
#else
  union {
    void             (*sa_handler_)(int);
    void             (*sa_sigaction_)(int, siginfo_t *, void *);
  };
  unsigned long      sa_flags;
  void               (*sa_restorer)(void);
  struct kernel_sigset_t sa_mask;
#endif
};

/* include/linux/socket.h                                                    */
struct kernel_sockaddr {
  unsigned short     sa_family;
  char               sa_data[14];
};

/* include/asm-{arm,aarch64,i386,mips,ppc,s390}/stat.h                       */
#ifdef __mips__
#if _MIPS_SIM == _MIPS_SIM_ABI64
struct kernel_stat {
#else
struct kernel_stat64 {
#endif
  unsigned           st_dev;
  unsigned           __pad0[3];
  unsigned long long st_ino;
  unsigned           st_mode;
  unsigned           st_nlink;
  unsigned           st_uid;
  unsigned           st_gid;
  unsigned           st_rdev;
  unsigned           __pad1[3];
  long long          st_size;
  unsigned           st_atime_;
  unsigned           st_atime_nsec_;
  unsigned           st_mtime_;
  unsigned           st_mtime_nsec_;
  unsigned           st_ctime_;
  unsigned           st_ctime_nsec_;
  unsigned           st_blksize;
  unsigned           __pad2;
  unsigned long long st_blocks;
};
#elif defined __PPC__
struct kernel_stat64 {
  unsigned long long st_dev;
  unsigned long long st_ino;
  unsigned           st_mode;
  unsigned           st_nlink;
  unsigned           st_uid;
  unsigned           st_gid;
  unsigned long long st_rdev;
  unsigned short int __pad2;
  long long          st_size;
  long               st_blksize;
  long long          st_blocks;
  long               st_atime_;
  unsigned long      st_atime_nsec_;
  long               st_mtime_;
  unsigned long      st_mtime_nsec_;
  long               st_ctime_;
  unsigned long      st_ctime_nsec_;
  unsigned long      __unused4;
  unsigned long      __unused5;
};
#else
struct kernel_stat64 {
  unsigned long long st_dev;
  unsigned char      __pad0[4];
  unsigned           __st_ino;
  unsigned           st_mode;
  unsigned           st_nlink;
  unsigned           st_uid;
  unsigned           st_gid;
  unsigned long long st_rdev;
  unsigned char      __pad3[4];
  long long          st_size;
  unsigned           st_blksize;
  unsigned long long st_blocks;
  unsigned           st_atime_;
  unsigned           st_atime_nsec_;
  unsigned           st_mtime_;
  unsigned           st_mtime_nsec_;
  unsigned           st_ctime_;
  unsigned           st_ctime_nsec_;
  unsigned long long st_ino;
};
#endif

/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc,s390}/stat.h                */
#if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
struct kernel_stat {
  /* The kernel headers suggest that st_dev and st_rdev should be 32bit
   * quantities encoding 12bit major and 20bit minor numbers in an interleaved
   * format. In reality, we do not see useful data in the top bits. So,
   * we'll leave the padding in here, until we find a better solution.
   */
  unsigned short     st_dev;
  short              pad1;
  unsigned           st_ino;
  unsigned short     st_mode;
  unsigned short     st_nlink;
  unsigned short     st_uid;
  unsigned short     st_gid;
  unsigned short     st_rdev;
  short              pad2;
  unsigned           st_size;
  unsigned           st_blksize;
  unsigned           st_blocks;
  unsigned           st_atime_;
  unsigned           st_atime_nsec_;
  unsigned           st_mtime_;
  unsigned           st_mtime_nsec_;
  unsigned           st_ctime_;
  unsigned           st_ctime_nsec_;
  unsigned           __unused4;
  unsigned           __unused5;
};
#elif defined(__x86_64__)
struct kernel_stat {
  uint64_t           st_dev;
  uint64_t           st_ino;
  uint64_t           st_nlink;
  unsigned           st_mode;
  unsigned           st_uid;
  unsigned           st_gid;
  unsigned           __pad0;
  uint64_t           st_rdev;
  int64_t            st_size;
  int64_t            st_blksize;
  int64_t            st_blocks;
  uint64_t           st_atime_;
  uint64_t           st_atime_nsec_;
  uint64_t           st_mtime_;
  uint64_t           st_mtime_nsec_;
  uint64_t           st_ctime_;
  uint64_t           st_ctime_nsec_;
  int64_t            __unused4[3];
};
#elif defined(__PPC__)
struct kernel_stat {
  unsigned           st_dev;
  unsigned long      st_ino;      // ino_t
  unsigned long      st_mode;     // mode_t
  unsigned short     st_nlink;    // nlink_t
  unsigned           st_uid;      // uid_t
  unsigned           st_gid;      // gid_t
  unsigned           st_rdev;
  long               st_size;     // off_t
  unsigned long      st_blksize;
  unsigned long      st_blocks;
  unsigned long      st_atime_;
  unsigned long      st_atime_nsec_;
  unsigned long      st_mtime_;
  unsigned long      st_mtime_nsec_;
  unsigned long      st_ctime_;
  unsigned long      st_ctime_nsec_;
  unsigned long      __unused4;
  unsigned long      __unused5;
};
#elif (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64)
struct kernel_stat {
  unsigned           st_dev;
  int                st_pad1[3];
  unsigned           st_ino;
  unsigned           st_mode;
  unsigned           st_nlink;
  unsigned           st_uid;
  unsigned           st_gid;
  unsigned           st_rdev;
  int                st_pad2[2];
  long               st_size;
  int                st_pad3;
  long               st_atime_;
  long               st_atime_nsec_;
  long               st_mtime_;
  long               st_mtime_nsec_;
  long               st_ctime_;
  long               st_ctime_nsec_;
  int                st_blksize;
  int                st_blocks;
  int                st_pad4[14];
};
#elif defined(__aarch64__)
struct kernel_stat {
  unsigned long      st_dev;
  unsigned long      st_ino;
  unsigned int       st_mode;
  unsigned int       st_nlink;
  unsigned int       st_uid;
  unsigned int       st_gid;
  unsigned long      st_rdev;
  unsigned long      __pad1;
  long               st_size;
  int                st_blksize;
  int                __pad2;
  long               st_blocks;
  long               st_atime_;
  unsigned long      st_atime_nsec_;
  long               st_mtime_;
  unsigned long      st_mtime_nsec_;
  long               st_ctime_;
  unsigned long      st_ctime_nsec_;
  unsigned int       __unused4;
  unsigned int       __unused5;
};
#elif defined(__s390x__)
struct kernel_stat {
  unsigned long      st_dev;
  unsigned long      st_ino;
  unsigned long      st_nlink;
  unsigned int       st_mode;
  unsigned int       st_uid;
  unsigned int       st_gid;
  unsigned int       __pad1;
  unsigned long      st_rdev;
  unsigned long      st_size;
  unsigned long      st_atime_;
  unsigned long      st_atime_nsec_;
  unsigned long      st_mtime_;
  unsigned long      st_mtime_nsec_;
  unsigned long      st_ctime_;
  unsigned long      st_ctime_nsec_;
  unsigned long      st_blksize;
  long               st_blocks;
  unsigned long      __unused[3];
};
#elif defined(__s390__)
struct kernel_stat {
  unsigned short     st_dev;
  unsigned short     __pad1;
  unsigned long      st_ino;
  unsigned short     st_mode;
  unsigned short     st_nlink;
  unsigned short     st_uid;
  unsigned short     st_gid;
  unsigned short     st_rdev;
  unsigned short     __pad2;
  unsigned long      st_size;
  unsigned long      st_blksize;
  unsigned long      st_blocks;
  unsigned long      st_atime_;
  unsigned long      st_atime_nsec_;
  unsigned long      st_mtime_;
  unsigned long      st_mtime_nsec_;
  unsigned long      st_ctime_;
  unsigned long      st_ctime_nsec_;
  unsigned long      __unused4;
  unsigned long      __unused5;
};
#endif

/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc,s390}/statfs.h              */
#ifdef __mips__
#if _MIPS_SIM != _MIPS_SIM_ABI64
struct kernel_statfs64 {
  unsigned long      f_type;
  unsigned long      f_bsize;
  unsigned long      f_frsize;
  unsigned long      __pad;
  unsigned long long f_blocks;
  unsigned long long f_bfree;
  unsigned long long f_files;
  unsigned long long f_ffree;
  unsigned long long f_bavail;
  struct { int val[2]; } f_fsid;
  unsigned long      f_namelen;
  unsigned long      f_spare[6];
};
#endif
#elif defined(__s390__)
/* See also arch/s390/include/asm/compat.h                                   */
struct kernel_statfs64 {
  unsigned int       f_type;
  unsigned int       f_bsize;
  unsigned long long f_blocks;
  unsigned long long f_bfree;
  unsigned long long f_bavail;
  unsigned long long f_files;
  unsigned long long f_ffree;
  struct { int val[2]; } f_fsid;
  unsigned int       f_namelen;
  unsigned int       f_frsize;
  unsigned int       f_flags;
  unsigned int       f_spare[4];
};
#elif !defined(__x86_64__)
struct kernel_statfs64 {
  unsigned long      f_type;
  unsigned long      f_bsize;
  unsigned long long f_blocks;
  unsigned long long f_bfree;
  unsigned long long f_bavail;
  unsigned long long f_files;
  unsigned long long f_ffree;
  struct { int val[2]; } f_fsid;
  unsigned long      f_namelen;
  unsigned long      f_frsize;
  unsigned long      f_spare[5];
};
#endif

/* include/asm-{arm,i386,mips,x86_64,ppc,generic,s390}/statfs.h              */
#ifdef __mips__
struct kernel_statfs {
  long               f_type;
  long               f_bsize;
  long               f_frsize;
  long               f_blocks;
  long               f_bfree;
  long               f_files;
  long               f_ffree;
  long               f_bavail;
  struct { int val[2]; } f_fsid;
  long               f_namelen;
  long               f_spare[6];
};
#elif defined(__x86_64__)
struct kernel_statfs {
  /* x86_64 actually defines all these fields as signed, whereas all other  */
  /* platforms define them as unsigned. Leaving them at unsigned should not */
  /* cause any problems. Make sure these are 64-bit even on x32.            */
  uint64_t           f_type;
  uint64_t           f_bsize;
  uint64_t           f_blocks;
  uint64_t           f_bfree;
  uint64_t           f_bavail;
  uint64_t           f_files;
  uint64_t           f_ffree;
  struct { int val[2]; } f_fsid;
  uint64_t           f_namelen;
  uint64_t           f_frsize;
  uint64_t           f_spare[5];
};
#elif defined(__s390__)
struct kernel_statfs {
  unsigned int       f_type;
  unsigned int       f_bsize;
  unsigned long      f_blocks;
  unsigned long      f_bfree;
  unsigned long      f_bavail;
  unsigned long      f_files;
  unsigned long      f_ffree;
  struct { int val[2]; } f_fsid;
  unsigned int       f_namelen;
  unsigned int       f_frsize;
  unsigned int       f_flags;
  unsigned int       f_spare[4];
};
#else
struct kernel_statfs {
  unsigned long      f_type;
  unsigned long      f_bsize;
  unsigned long      f_blocks;
  unsigned long      f_bfree;
  unsigned long      f_bavail;
  unsigned long      f_files;
  unsigned long      f_ffree;
  struct { int val[2]; } f_fsid;
  unsigned long      f_namelen;
  unsigned long      f_frsize;
  unsigned long      f_spare[5];
};
#endif


/* Definitions missing from the standard header files                        */
#ifndef O_DIRECTORY
#if defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || defined(__aarch64__)
#define O_DIRECTORY             0040000
#else
#define O_DIRECTORY             0200000
#endif
#endif
#ifndef NT_PRXFPREG
#define NT_PRXFPREG             0x46e62b7f
#endif
#ifndef PTRACE_GETFPXREGS
#define PTRACE_GETFPXREGS       ((enum __ptrace_request)18)
#endif
#ifndef PR_GET_DUMPABLE
#define PR_GET_DUMPABLE         3
#endif
#ifndef PR_SET_DUMPABLE
#define PR_SET_DUMPABLE         4
#endif
#ifndef PR_GET_SECCOMP
#define PR_GET_SECCOMP          21
#endif
#ifndef PR_SET_SECCOMP
#define PR_SET_SECCOMP          22
#endif
#ifndef AT_FDCWD
#define AT_FDCWD                (-100)
#endif
#ifndef AT_SYMLINK_NOFOLLOW
#define AT_SYMLINK_NOFOLLOW     0x100
#endif
#ifndef AT_REMOVEDIR
#define AT_REMOVEDIR            0x200
#endif
#ifndef MREMAP_FIXED
#define MREMAP_FIXED            2
#endif
#ifndef SA_RESTORER
#define SA_RESTORER             0x04000000
#endif
#ifndef CPUCLOCK_PROF
#define CPUCLOCK_PROF           0
#endif
#ifndef CPUCLOCK_VIRT
#define CPUCLOCK_VIRT           1
#endif
#ifndef CPUCLOCK_SCHED
#define CPUCLOCK_SCHED          2
#endif
#ifndef CPUCLOCK_PERTHREAD_MASK
#define CPUCLOCK_PERTHREAD_MASK 4
#endif
#ifndef MAKE_PROCESS_CPUCLOCK
#define MAKE_PROCESS_CPUCLOCK(pid, clock)                                     \
        ((int)(~(unsigned)(pid) << 3) | (int)(clock))
#endif
#ifndef MAKE_THREAD_CPUCLOCK
#define MAKE_THREAD_CPUCLOCK(tid, clock)                                      \
        ((int)(~(unsigned)(tid) << 3) |                                       \
         (int)((clock) | CPUCLOCK_PERTHREAD_MASK))
#endif

#ifndef FUTEX_WAIT
#define FUTEX_WAIT                0
#endif
#ifndef FUTEX_WAKE
#define FUTEX_WAKE                1
#endif
#ifndef FUTEX_FD
#define FUTEX_FD                  2
#endif
#ifndef FUTEX_REQUEUE
#define FUTEX_REQUEUE             3
#endif
#ifndef FUTEX_CMP_REQUEUE
#define FUTEX_CMP_REQUEUE         4
#endif
#ifndef FUTEX_WAKE_OP
#define FUTEX_WAKE_OP             5
#endif
#ifndef FUTEX_LOCK_PI
#define FUTEX_LOCK_PI             6
#endif
#ifndef FUTEX_UNLOCK_PI
#define FUTEX_UNLOCK_PI           7
#endif
#ifndef FUTEX_TRYLOCK_PI
#define FUTEX_TRYLOCK_PI          8
#endif
#ifndef FUTEX_PRIVATE_FLAG
#define FUTEX_PRIVATE_FLAG        128
#endif
#ifndef FUTEX_CMD_MASK
#define FUTEX_CMD_MASK            ~FUTEX_PRIVATE_FLAG
#endif
#ifndef FUTEX_WAIT_PRIVATE
#define FUTEX_WAIT_PRIVATE        (FUTEX_WAIT | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_WAKE_PRIVATE
#define FUTEX_WAKE_PRIVATE        (FUTEX_WAKE | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_REQUEUE_PRIVATE
#define FUTEX_REQUEUE_PRIVATE     (FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_CMP_REQUEUE_PRIVATE
#define FUTEX_CMP_REQUEUE_PRIVATE (FUTEX_CMP_REQUEUE | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_WAKE_OP_PRIVATE
#define FUTEX_WAKE_OP_PRIVATE     (FUTEX_WAKE_OP | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_LOCK_PI_PRIVATE
#define FUTEX_LOCK_PI_PRIVATE     (FUTEX_LOCK_PI | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_UNLOCK_PI_PRIVATE
#define FUTEX_UNLOCK_PI_PRIVATE   (FUTEX_UNLOCK_PI | FUTEX_PRIVATE_FLAG)
#endif
#ifndef FUTEX_TRYLOCK_PI_PRIVATE
#define FUTEX_TRYLOCK_PI_PRIVATE  (FUTEX_TRYLOCK_PI | FUTEX_PRIVATE_FLAG)
#endif


#if defined(__x86_64__)
#ifndef ARCH_SET_GS
#define ARCH_SET_GS             0x1001
#endif
#ifndef ARCH_GET_GS
#define ARCH_GET_GS             0x1004
#endif
#endif

#if defined(__i386__)
#ifndef __NR_quotactl
#define __NR_quotactl           131
#endif
#ifndef __NR_setresuid
#define __NR_setresuid          164
#define __NR_getresuid          165
#define __NR_setresgid          170
#define __NR_getresgid          171
#endif
#ifndef __NR_rt_sigaction
#define __NR_rt_sigreturn       173
#define __NR_rt_sigaction       174
#define __NR_rt_sigprocmask     175
#define __NR_rt_sigpending      176
#define __NR_rt_sigsuspend      179
#endif
#ifndef __NR_pread64
#define __NR_pread64            180
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           181
#endif
#ifndef __NR_ugetrlimit
#define __NR_ugetrlimit         191
#endif
#ifndef __NR_stat64
#define __NR_stat64             195
#endif
#ifndef __NR_fstat64
#define __NR_fstat64            197
#endif
#ifndef __NR_setresuid32
#define __NR_setresuid32        208
#define __NR_getresuid32        209
#define __NR_setresgid32        210
#define __NR_getresgid32        211
#endif
#ifndef __NR_setfsuid32
#define __NR_setfsuid32         215
#define __NR_setfsgid32         216
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         220
#endif
#ifndef __NR_gettid
#define __NR_gettid             224
#endif
#ifndef __NR_readahead
#define __NR_readahead          225
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           226
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          227
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           229
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          230
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          232
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         233
#endif
#ifndef __NR_tkill
#define __NR_tkill              238
#endif
#ifndef __NR_futex
#define __NR_futex              240
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  241
#define __NR_sched_getaffinity  242
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    258
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      265
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       266
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           268
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          269
#endif
#ifndef __NR_fadvise64_64
#define __NR_fadvise64_64       272
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         289
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         290
#endif
#ifndef __NR_openat
#define __NR_openat             295
#endif
#ifndef __NR_fstatat64
#define __NR_fstatat64          300
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           301
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         317
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             318
#endif
#ifndef __NR_fallocate
#define __NR_fallocate          324
#endif
#ifndef __NR_getrandom
#define __NR_getrandom          355
#endif
/* End of i386 definitions                                                   */
#elif defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
#ifndef __NR_setresuid
#define __NR_setresuid          (__NR_SYSCALL_BASE + 164)
#define __NR_getresuid          (__NR_SYSCALL_BASE + 165)
#define __NR_setresgid          (__NR_SYSCALL_BASE + 170)
#define __NR_getresgid          (__NR_SYSCALL_BASE + 171)
#endif
#ifndef __NR_rt_sigaction
#define __NR_rt_sigreturn       (__NR_SYSCALL_BASE + 173)
#define __NR_rt_sigaction       (__NR_SYSCALL_BASE + 174)
#define __NR_rt_sigprocmask     (__NR_SYSCALL_BASE + 175)
#define __NR_rt_sigpending      (__NR_SYSCALL_BASE + 176)
#define __NR_rt_sigsuspend      (__NR_SYSCALL_BASE + 179)
#endif
#ifndef __NR_pread64
#define __NR_pread64            (__NR_SYSCALL_BASE + 180)
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           (__NR_SYSCALL_BASE + 181)
#endif
#ifndef __NR_ugetrlimit
#define __NR_ugetrlimit         (__NR_SYSCALL_BASE + 191)
#endif
#ifndef __NR_stat64
#define __NR_stat64             (__NR_SYSCALL_BASE + 195)
#endif
#ifndef __NR_fstat64
#define __NR_fstat64            (__NR_SYSCALL_BASE + 197)
#endif
#ifndef __NR_setresuid32
#define __NR_setresuid32        (__NR_SYSCALL_BASE + 208)
#define __NR_getresuid32        (__NR_SYSCALL_BASE + 209)
#define __NR_setresgid32        (__NR_SYSCALL_BASE + 210)
#define __NR_getresgid32        (__NR_SYSCALL_BASE + 211)
#endif
#ifndef __NR_setfsuid32
#define __NR_setfsuid32         (__NR_SYSCALL_BASE + 215)
#define __NR_setfsgid32         (__NR_SYSCALL_BASE + 216)
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         (__NR_SYSCALL_BASE + 217)
#endif
#ifndef __NR_gettid
#define __NR_gettid             (__NR_SYSCALL_BASE + 224)
#endif
#ifndef __NR_readahead
#define __NR_readahead          (__NR_SYSCALL_BASE + 225)
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           (__NR_SYSCALL_BASE + 226)
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          (__NR_SYSCALL_BASE + 227)
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           (__NR_SYSCALL_BASE + 229)
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          (__NR_SYSCALL_BASE + 230)
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          (__NR_SYSCALL_BASE + 232)
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         (__NR_SYSCALL_BASE + 233)
#endif
#ifndef __NR_tkill
#define __NR_tkill              (__NR_SYSCALL_BASE + 238)
#endif
#ifndef __NR_futex
#define __NR_futex              (__NR_SYSCALL_BASE + 240)
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  (__NR_SYSCALL_BASE + 241)
#define __NR_sched_getaffinity  (__NR_SYSCALL_BASE + 242)
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    (__NR_SYSCALL_BASE + 256)
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      (__NR_SYSCALL_BASE + 263)
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       (__NR_SYSCALL_BASE + 264)
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           (__NR_SYSCALL_BASE + 266)
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          (__NR_SYSCALL_BASE + 267)
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         (__NR_SYSCALL_BASE + 314)
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         (__NR_SYSCALL_BASE + 315)
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         (__NR_SYSCALL_BASE + 344)
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             (__NR_SYSCALL_BASE + 345)
#endif
#ifndef __NR_getrandom
#define __NR_getrandom          (__NR_SYSCALL_BASE + 384)
#endif
/* End of ARM 3/EABI definitions                                             */
#elif defined(__aarch64__)
#ifndef __NR_setxattr
#define __NR_setxattr             5
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr            6
#endif
#ifndef __NR_getxattr
#define __NR_getxattr             8
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr            9
#endif
#ifndef __NR_listxattr
#define __NR_listxattr           11
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr          12
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set          30
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get          31
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat            35
#endif
#ifndef __NR_fallocate
#define __NR_fallocate           47
#endif
#ifndef __NR_openat
#define __NR_openat              56
#endif
#ifndef __NR_quotactl
#define __NR_quotactl            60
#endif
#ifndef __NR_getdents64
#define __NR_getdents64          61
#endif
#ifndef __NR_getdents
// when getdents is not available, getdents64 is used for both.
#define __NR_getdents            __NR_getdents64
#endif
#ifndef __NR_pread64
#define __NR_pread64             67
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64            68
#endif
#ifndef __NR_ppoll
#define __NR_ppoll               73
#endif
#ifndef __NR_readlinkat
#define __NR_readlinkat          78
#endif
#ifndef __NR_newfstatat
#define __NR_newfstatat          79
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address     96
#endif
#ifndef __NR_futex
#define __NR_futex               98
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      113
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       114
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  122
#define __NR_sched_getaffinity  123
#endif
#ifndef __NR_tkill
#define __NR_tkill              130
#endif
#ifndef __NR_setresuid
#define __NR_setresuid          147
#define __NR_getresuid          148
#define __NR_setresgid          149
#define __NR_getresgid          150
#endif
#ifndef __NR_gettid
#define __NR_gettid             178
#endif
#ifndef __NR_readahead
#define __NR_readahead          213
#endif
#ifndef __NR_fadvise64
#define __NR_fadvise64          223
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         239
#endif
#ifndef __NR_getrandom
#define __NR_getrandom          278
#endif
/* End of aarch64 definitions                                                */
#elif defined(__x86_64__)
#ifndef __NR_pread64
#define __NR_pread64             17
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64            18
#endif
#ifndef __NR_setresuid
#define __NR_setresuid          117
#define __NR_getresuid          118
#define __NR_setresgid          119
#define __NR_getresgid          120
#endif
#ifndef __NR_quotactl
#define __NR_quotactl           179
#endif
#ifndef __NR_gettid
#define __NR_gettid             186
#endif
#ifndef __NR_readahead
#define __NR_readahead          187
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           188
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          189
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           191
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          192
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          194
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         195
#endif
#ifndef __NR_tkill
#define __NR_tkill              200
#endif
#ifndef __NR_futex
#define __NR_futex              202
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  203
#define __NR_sched_getaffinity  204
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         217
#endif
#ifndef __NR_getdents
// when getdents is not available, getdents64 is used for both.
#define __NR_getdents           __NR_getdents64
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    218
#endif
#ifndef __NR_fadvise64
#define __NR_fadvise64          221
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      228
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       229
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         251
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         252
#endif
#ifndef __NR_openat
#define __NR_openat             257
#endif
#ifndef __NR_newfstatat
#define __NR_newfstatat         262
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           263
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         279
#endif
#ifndef __NR_fallocate
#define __NR_fallocate          285
#endif
#ifndef __NR_getrandom
#define __NR_getrandom          318
#endif
/* End of x86-64 definitions                                                 */
#elif defined(__mips__)
#if _MIPS_SIM == _MIPS_SIM_ABI32
#ifndef __NR_setresuid
#define __NR_setresuid          (__NR_Linux + 185)
#define __NR_getresuid          (__NR_Linux + 186)
#define __NR_setresgid          (__NR_Linux + 190)
#define __NR_getresgid          (__NR_Linux + 191)
#endif
#ifndef __NR_rt_sigaction
#define __NR_rt_sigreturn       (__NR_Linux + 193)
#define __NR_rt_sigaction       (__NR_Linux + 194)
#define __NR_rt_sigprocmask     (__NR_Linux + 195)
#define __NR_rt_sigpending      (__NR_Linux + 196)
#define __NR_rt_sigsuspend      (__NR_Linux + 199)
#endif
#ifndef __NR_pread64
#define __NR_pread64            (__NR_Linux + 200)
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           (__NR_Linux + 201)
#endif
#ifndef __NR_stat64
#define __NR_stat64             (__NR_Linux + 213)
#endif
#ifndef __NR_fstat64
#define __NR_fstat64            (__NR_Linux + 215)
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         (__NR_Linux + 219)
#endif
#ifndef __NR_gettid
#define __NR_gettid             (__NR_Linux + 222)
#endif
#ifndef __NR_readahead
#define __NR_readahead          (__NR_Linux + 223)
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           (__NR_Linux + 224)
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          (__NR_Linux + 225)
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           (__NR_Linux + 227)
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          (__NR_Linux + 228)
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          (__NR_Linux + 230)
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         (__NR_Linux + 231)
#endif
#ifndef __NR_tkill
#define __NR_tkill              (__NR_Linux + 236)
#endif
#ifndef __NR_futex
#define __NR_futex              (__NR_Linux + 238)
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  (__NR_Linux + 239)
#define __NR_sched_getaffinity  (__NR_Linux + 240)
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    (__NR_Linux + 252)
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           (__NR_Linux + 255)
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          (__NR_Linux + 256)
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      (__NR_Linux + 263)
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       (__NR_Linux + 264)
#endif
#ifndef __NR_openat
#define __NR_openat             (__NR_Linux + 288)
#endif
#ifndef __NR_fstatat
#define __NR_fstatat            (__NR_Linux + 293)
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           (__NR_Linux + 294)
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         (__NR_Linux + 308)
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             (__NR_Linux + 312)
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         (__NR_Linux + 314)
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         (__NR_Linux + 315)
#endif
#ifndef __NR_getrandom
#define __NR_getrandom          (__NR_Linux + 353)
#endif
/* End of MIPS (old 32bit API) definitions */
#elif  _MIPS_SIM == _MIPS_SIM_ABI64
#ifndef __NR_pread64
#define __NR_pread64            (__NR_Linux +  16)
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           (__NR_Linux +  17)
#endif
#ifndef __NR_setresuid
#define __NR_setresuid          (__NR_Linux + 115)
#define __NR_getresuid          (__NR_Linux + 116)
#define __NR_setresgid          (__NR_Linux + 117)
#define __NR_getresgid          (__NR_Linux + 118)
#endif
#ifndef __NR_gettid
#define __NR_gettid             (__NR_Linux + 178)
#endif
#ifndef __NR_readahead
#define __NR_readahead          (__NR_Linux + 179)
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           (__NR_Linux + 180)
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          (__NR_Linux + 181)
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           (__NR_Linux + 183)
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          (__NR_Linux + 184)
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          (__NR_Linux + 186)
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         (__NR_Linux + 187)
#endif
#ifndef __NR_tkill
#define __NR_tkill              (__NR_Linux + 192)
#endif
#ifndef __NR_futex
#define __NR_futex              (__NR_Linux + 194)
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  (__NR_Linux + 195)
#define __NR_sched_getaffinity  (__NR_Linux + 196)
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    (__NR_Linux + 212)
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      (__NR_Linux + 222)
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       (__NR_Linux + 223)
#endif
#ifndef __NR_openat
#define __NR_openat             (__NR_Linux + 247)
#endif
#ifndef __NR_fstatat
#define __NR_fstatat            (__NR_Linux + 252)
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           (__NR_Linux + 253)
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         (__NR_Linux + 267)
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             (__NR_Linux + 271)
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         (__NR_Linux + 273)
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         (__NR_Linux + 274)
#endif
#ifndef __NT_getrandom
#define                         (__NR_Linux + 313)
#endif
/* End of MIPS (64bit API) definitions */
#else
#ifndef __NR_setresuid
#define __NR_setresuid          (__NR_Linux + 115)
#define __NR_getresuid          (__NR_Linux + 116)
#define __NR_setresgid          (__NR_Linux + 117)
#define __NR_getresgid          (__NR_Linux + 118)
#endif
#ifndef __NR_gettid
#define __NR_gettid             (__NR_Linux + 178)
#endif
#ifndef __NR_readahead
#define __NR_readahead          (__NR_Linux + 179)
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           (__NR_Linux + 180)
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          (__NR_Linux + 181)
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           (__NR_Linux + 183)
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          (__NR_Linux + 184)
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          (__NR_Linux + 186)
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         (__NR_Linux + 187)
#endif
#ifndef __NR_tkill
#define __NR_tkill              (__NR_Linux + 192)
#endif
#ifndef __NR_futex
#define __NR_futex              (__NR_Linux + 194)
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  (__NR_Linux + 195)
#define __NR_sched_getaffinity  (__NR_Linux + 196)
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    (__NR_Linux + 213)
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           (__NR_Linux + 217)
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          (__NR_Linux + 218)
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      (__NR_Linux + 226)
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       (__NR_Linux + 227)
#endif
#ifndef __NR_openat
#define __NR_openat             (__NR_Linux + 251)
#endif
#ifndef __NR_fstatat
#define __NR_fstatat            (__NR_Linux + 256)
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           (__NR_Linux + 257)
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         (__NR_Linux + 271)
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             (__NR_Linux + 275)
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         (__NR_Linux + 277)
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         (__NR_Linux + 278)
#endif
/* End of MIPS (new 32bit API) definitions                                   */
#endif
/* End of MIPS definitions                                                   */
#elif defined(__PPC__)
#ifndef __NR_setfsuid
#define __NR_setfsuid           138
#define __NR_setfsgid           139
#endif
#ifndef __NR_setresuid
#define __NR_setresuid          164
#define __NR_getresuid          165
#define __NR_setresgid          169
#define __NR_getresgid          170
#endif
#ifndef __NR_rt_sigaction
#define __NR_rt_sigreturn       172
#define __NR_rt_sigaction       173
#define __NR_rt_sigprocmask     174
#define __NR_rt_sigpending      175
#define __NR_rt_sigsuspend      178
#endif
#ifndef __NR_pread64
#define __NR_pread64            179
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           180
#endif
#ifndef __NR_ugetrlimit
#define __NR_ugetrlimit         190
#endif
#ifndef __NR_readahead
#define __NR_readahead          191
#endif
#ifndef __NR_stat64
#define __NR_stat64             195
#endif
#ifndef __NR_fstat64
#define __NR_fstat64            197
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         202
#endif
#ifndef __NR_gettid
#define __NR_gettid             207
#endif
#ifndef __NR_tkill
#define __NR_tkill              208
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           209
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          210
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           212
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          213
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          215
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         216
#endif
#ifndef __NR_futex
#define __NR_futex              221
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  222
#define __NR_sched_getaffinity  223
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    232
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      246
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       247
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           252
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          253
#endif
#ifndef __NR_fadvise64_64
#define __NR_fadvise64_64       254
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         273
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         274
#endif
#ifndef __NR_openat
#define __NR_openat             286
#endif
#ifndef __NR_fstatat64
#define __NR_fstatat64          291
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           292
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         301
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             302
#endif
/* End of powerpc defininitions                                              */
#elif defined(__s390__)
#ifndef __NR_quotactl
#define __NR_quotactl           131
#endif
#ifndef __NR_rt_sigreturn
#define __NR_rt_sigreturn       173
#endif
#ifndef __NR_rt_sigaction
#define __NR_rt_sigaction       174
#endif
#ifndef __NR_rt_sigprocmask
#define __NR_rt_sigprocmask     175
#endif
#ifndef __NR_rt_sigpending
#define __NR_rt_sigpending      176
#endif
#ifndef __NR_rt_sigsuspend
#define __NR_rt_sigsuspend      179
#endif
#ifndef __NR_pread64
#define __NR_pread64            180
#endif
#ifndef __NR_pwrite64
#define __NR_pwrite64           181
#endif
#ifndef __NR_getdents64
#define __NR_getdents64         220
#endif
#ifndef __NR_readahead
#define __NR_readahead          222
#endif
#ifndef __NR_setxattr
#define __NR_setxattr           224
#endif
#ifndef __NR_lsetxattr
#define __NR_lsetxattr          225
#endif
#ifndef __NR_getxattr
#define __NR_getxattr           227
#endif
#ifndef __NR_lgetxattr
#define __NR_lgetxattr          228
#endif
#ifndef __NR_listxattr
#define __NR_listxattr          230
#endif
#ifndef __NR_llistxattr
#define __NR_llistxattr         231
#endif
#ifndef __NR_gettid
#define __NR_gettid             236
#endif
#ifndef __NR_tkill
#define __NR_tkill              237
#endif
#ifndef __NR_futex
#define __NR_futex              238
#endif
#ifndef __NR_sched_setaffinity
#define __NR_sched_setaffinity  239
#endif
#ifndef __NR_sched_getaffinity
#define __NR_sched_getaffinity  240
#endif
#ifndef __NR_set_tid_address
#define __NR_set_tid_address    252
#endif
#ifndef __NR_clock_gettime
#define __NR_clock_gettime      260
#endif
#ifndef __NR_clock_getres
#define __NR_clock_getres       261
#endif
#ifndef __NR_statfs64
#define __NR_statfs64           265
#endif
#ifndef __NR_fstatfs64
#define __NR_fstatfs64          266
#endif
#ifndef __NR_ioprio_set
#define __NR_ioprio_set         282
#endif
#ifndef __NR_ioprio_get
#define __NR_ioprio_get         283
#endif
#ifndef __NR_openat
#define __NR_openat             288
#endif
#ifndef __NR_unlinkat
#define __NR_unlinkat           294
#endif
#ifndef __NR_move_pages
#define __NR_move_pages         310
#endif
#ifndef __NR_getcpu
#define __NR_getcpu             311
#endif
#ifndef __NR_fallocate
#define __NR_fallocate          314
#endif
/* Some syscalls are named/numbered differently between s390 and s390x. */
#ifdef __s390x__
# ifndef __NR_getrlimit
# define __NR_getrlimit          191
# endif
# ifndef __NR_setresuid
# define __NR_setresuid          208
# endif
# ifndef __NR_getresuid
# define __NR_getresuid          209
# endif
# ifndef __NR_setresgid
# define __NR_setresgid          210
# endif
# ifndef __NR_getresgid
# define __NR_getresgid          211
# endif
# ifndef __NR_setfsuid
# define __NR_setfsuid           215
# endif
# ifndef __NR_setfsgid
# define __NR_setfsgid           216
# endif
# ifndef __NR_fadvise64
# define __NR_fadvise64          253
# endif
# ifndef __NR_newfstatat
# define __NR_newfstatat         293
# endif
#else /* __s390x__ */
# ifndef __NR_getrlimit
# define __NR_getrlimit          76
# endif
# ifndef __NR_setfsuid
# define __NR_setfsuid           138
# endif
# ifndef __NR_setfsgid
# define __NR_setfsgid           139
# endif
# ifndef __NR_setresuid
# define __NR_setresuid          164
# endif
# ifndef __NR_getresuid
# define __NR_getresuid          165
# endif
# ifndef __NR_setresgid
# define __NR_setresgid          170
# endif
# ifndef __NR_getresgid
# define __NR_getresgid          171
# endif
# ifndef __NR_ugetrlimit
# define __NR_ugetrlimit         191
# endif
# ifndef __NR_mmap2
# define __NR_mmap2              192
# endif
# ifndef __NR_setresuid32
# define __NR_setresuid32        208
# endif
# ifndef __NR_getresuid32
# define __NR_getresuid32        209
# endif
# ifndef __NR_setresgid32
# define __NR_setresgid32        210
# endif
# ifndef __NR_getresgid32
# define __NR_getresgid32        211
# endif
# ifndef __NR_setfsuid32
# define __NR_setfsuid32         215
# endif
# ifndef __NR_setfsgid32
# define __NR_setfsgid32         216
# endif
# ifndef __NR_fadvise64_64
# define __NR_fadvise64_64       264
# endif
# ifndef __NR_fstatat64
# define __NR_fstatat64          293
# endif
#endif /* __s390__ */
/* End of s390/s390x definitions                                             */
#endif


/* After forking, we must make sure to only call system calls.               */
#if defined(__BOUNDED_POINTERS__)
  #error "Need to port invocations of syscalls for bounded ptrs"
#else
  /* The core dumper and the thread lister get executed after threads
   * have been suspended. As a consequence, we cannot call any functions
   * that acquire locks. Unfortunately, libc wraps most system calls
   * (e.g. in order to implement pthread_atfork, and to make calls
   * cancellable), which means we cannot call these functions. Instead,
   * we have to call syscall() directly.
   */
  #undef LSS_ERRNO
  #ifdef SYS_ERRNO
    /* Allow the including file to override the location of errno. This can
     * be useful when using clone() with the CLONE_VM option.
     */
    #define LSS_ERRNO SYS_ERRNO
  #else
    #define LSS_ERRNO errno
  #endif

  #undef LSS_INLINE
  #ifdef SYS_INLINE
    #define LSS_INLINE SYS_INLINE
  #else
    #define LSS_INLINE static inline
  #endif

  /* Allow the including file to override the prefix used for all new
   * system calls. By default, it will be set to "sys_".
   */
  #undef LSS_NAME
  #ifndef SYS_PREFIX
    #define LSS_NAME(name) sys_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX < 0
    #define LSS_NAME(name) name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 0
    #define LSS_NAME(name) sys0_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 1
    #define LSS_NAME(name) sys1_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 2
    #define LSS_NAME(name) sys2_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 3
    #define LSS_NAME(name) sys3_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 4
    #define LSS_NAME(name) sys4_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 5
    #define LSS_NAME(name) sys5_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 6
    #define LSS_NAME(name) sys6_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 7
    #define LSS_NAME(name) sys7_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 8
    #define LSS_NAME(name) sys8_##name
  #elif defined(SYS_PREFIX) && SYS_PREFIX == 9
    #define LSS_NAME(name) sys9_##name
  #endif

  #undef  LSS_RETURN
  #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) \
       || defined(__ARM_EABI__) || defined(__aarch64__) || defined(__s390__))
  /* Failing system calls return a negative result in the range of
   * -1..-4095. These are "errno" values with the sign inverted.
   */
  #define LSS_RETURN(type, res)                                               \
    do {                                                                      \
      if ((unsigned long)(res) >= (unsigned long)(-4095)) {                   \
        LSS_ERRNO = -(res);                                                   \
        res = -1;                                                             \
      }                                                                       \
      return (type) (res);                                                    \
    } while (0)
  #elif defined(__mips__)
  /* On MIPS, failing system calls return -1, and set errno in a
   * separate CPU register.
   */
  #define LSS_RETURN(type, res, err)                                          \
    do {                                                                      \
      if (err) {                                                              \
        unsigned long __errnovalue = (res);                                   \
        LSS_ERRNO = __errnovalue;                                             \
        res = -1;                                                             \
      }                                                                       \
      return (type) (res);                                                    \
    } while (0)
  #elif defined(__PPC__)
  /* On PPC, failing system calls return -1, and set errno in a
   * separate CPU register. See linux/unistd.h.
   */
  #define LSS_RETURN(type, res, err)                                          \
   do {                                                                       \
     if (err & 0x10000000 ) {                                                 \
       LSS_ERRNO = (res);                                                     \
       res = -1;                                                              \
     }                                                                        \
     return (type) (res);                                                     \
   } while (0)
  #endif
  #if defined(__i386__)
    /* In PIC mode (e.g. when building shared libraries), gcc for i386
     * reserves ebx. Unfortunately, most distribution ship with implementations
     * of _syscallX() which clobber ebx.
     * Also, most definitions of _syscallX() neglect to mark "memory" as being
     * clobbered. This causes problems with compilers, that do a better job
     * at optimizing across __asm__ calls.
     * So, we just have to redefine all of the _syscallX() macros.
     */
    #undef LSS_ENTRYPOINT
    #ifdef SYS_SYSCALL_ENTRYPOINT
    static inline void (**LSS_NAME(get_syscall_entrypoint)(void))(void) {
      void (**entrypoint)(void);
      asm volatile(".bss\n"
                   ".align 8\n"
                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
                   ".previous\n"
                   /* This logically does 'lea "SYS_SYSCALL_ENTRYPOINT", %0' */
                   "call 0f\n"
                 "0:pop  %0\n"
                   "add  $_GLOBAL_OFFSET_TABLE_+[.-0b], %0\n"
                   "mov  " SYS_SYSCALL_ENTRYPOINT "@GOT(%0), %0\n"
                   : "=r"(entrypoint));
      return entrypoint;
    }

    #define LSS_ENTRYPOINT ".bss\n"                                           \
                           ".align 8\n"                                       \
                           ".globl " SYS_SYSCALL_ENTRYPOINT "\n"              \
                           ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"         \
                           ".previous\n"                                      \
                           /* Check the SYS_SYSCALL_ENTRYPOINT vector      */ \
                           "push %%eax\n"                                     \
                           "call 10000f\n"                                    \
                     "10000:pop  %%eax\n"                                     \
                           "add  $_GLOBAL_OFFSET_TABLE_+[.-10000b], %%eax\n"  \
                           "mov  " SYS_SYSCALL_ENTRYPOINT                     \
                                 "@GOT(%%eax), %%eax\n"                       \
                           "mov  0(%%eax), %%eax\n"                           \
                           "test %%eax, %%eax\n"                              \
                           "jz   10002f\n"                                    \
                           "push %%eax\n"                                     \
                           "call 10001f\n"                                    \
                     "10001:pop  %%eax\n"                                     \
                           "add  $(10003f-10001b), %%eax\n"                   \
                           "xchg 4(%%esp), %%eax\n"                           \
                           "ret\n"                                            \
                     "10002:pop  %%eax\n"                                     \
                           "int $0x80\n"                                      \
                     "10003:\n"
    #else
    #define LSS_ENTRYPOINT "int $0x80\n"
    #endif
    #undef  LSS_BODY
    #define LSS_BODY(type,args...)                                            \
      long __res;                                                             \
      __asm__ __volatile__("push %%ebx\n"                                     \
                           "movl %2,%%ebx\n"                                  \
                           LSS_ENTRYPOINT                                     \
                           "pop %%ebx"                                        \
                           args                                               \
                           : "memory");                                       \
      LSS_RETURN(type,__res)
    #undef  _syscall0
    #define _syscall0(type,name)                                              \
      type LSS_NAME(name)(void) {                                             \
        long __res;                                                           \
        __asm__ volatile(LSS_ENTRYPOINT                                       \
                         : "=a" (__res)                                       \
                         : "0" (__NR_##name)                                  \
                         : "memory");                                         \
        LSS_RETURN(type,__res);                                               \
      }
    #undef  _syscall1
    #define _syscall1(type,name,type1,arg1)                                   \
      type LSS_NAME(name)(type1 arg1) {                                       \
        LSS_BODY(type,                                                        \
             : "=a" (__res)                                                   \
             : "0" (__NR_##name), "ri" ((long)(arg1)));                       \
      }
    #undef  _syscall2
    #define _syscall2(type,name,type1,arg1,type2,arg2)                        \
      type LSS_NAME(name)(type1 arg1,type2 arg2) {                            \
        LSS_BODY(type,                                                        \
             : "=a" (__res)                                                   \
             : "0" (__NR_##name),"ri" ((long)(arg1)), "c" ((long)(arg2)));    \
      }
    #undef  _syscall3
    #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)             \
      type LSS_NAME(name)(type1 arg1,type2 arg2,type3 arg3) {                 \
        LSS_BODY(type,                                                        \
             : "=a" (__res)                                                   \
             : "0" (__NR_##name), "ri" ((long)(arg1)), "c" ((long)(arg2)),    \
               "d" ((long)(arg3)));                                           \
      }
    #undef  _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_BODY(type,                                                        \
             : "=a" (__res)                                                   \
             : "0" (__NR_##name), "ri" ((long)(arg1)), "c" ((long)(arg2)),    \
               "d" ((long)(arg3)),"S" ((long)(arg4)));                        \
      }
    #undef  _syscall5
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        long __res;                                                           \
        __asm__ __volatile__("push %%ebx\n"                                   \
                             "movl %2,%%ebx\n"                                \
                             "movl %1,%%eax\n"                                \
                             LSS_ENTRYPOINT                                   \
                             "pop  %%ebx"                                     \
                             : "=a" (__res)                                   \
                             : "i" (__NR_##name), "ri" ((long)(arg1)),        \
                               "c" ((long)(arg2)), "d" ((long)(arg3)),        \
                               "S" ((long)(arg4)), "D" ((long)(arg5))         \
                             : "memory");                                     \
        LSS_RETURN(type,__res);                                               \
      }
    #undef  _syscall6
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        long __res;                                                           \
        struct { long __a1; long __a6; } __s = { (long)arg1, (long) arg6 };   \
        __asm__ __volatile__("push %%ebp\n"                                   \
                             "push %%ebx\n"                                   \
                             "movl 4(%2),%%ebp\n"                             \
                             "movl 0(%2), %%ebx\n"                            \
                             "movl %1,%%eax\n"                                \
                             LSS_ENTRYPOINT                                   \
                             "pop  %%ebx\n"                                   \
                             "pop  %%ebp"                                     \
                             : "=a" (__res)                                   \
                             : "i" (__NR_##name),  "0" ((long)(&__s)),        \
                               "c" ((long)(arg2)), "d" ((long)(arg3)),        \
                               "S" ((long)(arg4)), "D" ((long)(arg5))         \
                             : "memory");                                     \
        LSS_RETURN(type,__res);                                               \
      }
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long __res;
      __asm__ __volatile__(/* if (fn == NULL)
                            *   return -EINVAL;
                            */
                           "movl   %3,%%ecx\n"
                           "jecxz  1f\n"

                           /* if (child_stack == NULL)
                            *   return -EINVAL;
                            */
                           "movl   %4,%%ecx\n"
                           "jecxz  1f\n"

                           /* Set up alignment of the child stack:
                            * child_stack = (child_stack & ~0xF) - 20;
                            */
                           "andl   $-16,%%ecx\n"
                           "subl   $20,%%ecx\n"

                           /* Push "arg" and "fn" onto the stack that will be
                            * used by the child.
                            */
                           "movl   %6,%%eax\n"
                           "movl   %%eax,4(%%ecx)\n"
                           "movl   %3,%%eax\n"
                           "movl   %%eax,(%%ecx)\n"

                           /* %eax = syscall(%eax = __NR_clone,
                            *                %ebx = flags,
                            *                %ecx = child_stack,
                            *                %edx = parent_tidptr,
                            *                %esi = newtls,
                            *                %edi = child_tidptr)
                            * Also, make sure that %ebx gets preserved as it is
                            * used in PIC mode.
                            */
                           "movl   %8,%%esi\n"
                           "movl   %7,%%edx\n"
                           "movl   %5,%%eax\n"
                           "movl   %9,%%edi\n"
                           "pushl  %%ebx\n"
                           "movl   %%eax,%%ebx\n"
                           "movl   %2,%%eax\n"
                           LSS_ENTRYPOINT

                           /* In the parent: restore %ebx
                            * In the child:  move "fn" into %ebx
                            */
                           "popl   %%ebx\n"

                           /* if (%eax != 0)
                            *   return %eax;
                            */
                           "test   %%eax,%%eax\n"
                           "jnz    1f\n"

                           /* In the child, now. Terminate frame pointer chain.
                            */
                           "movl   $0,%%ebp\n"

                           /* Call "fn". "arg" is already on the stack.
                            */
                           "call   *%%ebx\n"

                           /* Call _exit(%ebx). Unfortunately older versions
                            * of gcc restrict the number of arguments that can
                            * be passed to asm(). So, we need to hard-code the
                            * system call number.
                            */
                           "movl   %%eax,%%ebx\n"
                           "movl   $1,%%eax\n"
                           LSS_ENTRYPOINT

                           /* Return to parent.
                            */
                         "1:\n"
                           : "=a" (__res)
                           : "0"(-EINVAL), "i"(__NR_clone),
                             "m"(fn), "m"(child_stack), "m"(flags), "m"(arg),
                             "m"(parent_tidptr), "m"(newtls), "m"(child_tidptr)
                           : "memory", "ecx", "edx", "esi", "edi");
      LSS_RETURN(int, __res);
    }

    LSS_INLINE _syscall1(int, set_thread_area, void *, u)
    LSS_INLINE _syscall1(int, get_thread_area, void *, u)

    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {
      /* On i386, the kernel does not know how to return from a signal
       * handler. Instead, it relies on user space to provide a
       * restorer function that calls the {rt_,}sigreturn() system call.
       * Unfortunately, we cannot just reference the glibc version of this
       * function, as glibc goes out of its way to make it inaccessible.
       */
      void (*res)(void);
      __asm__ __volatile__("call   2f\n"
                         "0:.align 16\n"
                         "1:movl   %1,%%eax\n"
                           LSS_ENTRYPOINT
                         "2:popl   %0\n"
                           "addl   $(1b-0b),%0\n"
                           : "=a" (res)
                           : "i"  (__NR_rt_sigreturn));
      return res;
    }
    LSS_INLINE void (*LSS_NAME(restore)(void))(void) {
      /* On i386, the kernel does not know how to return from a signal
       * handler. Instead, it relies on user space to provide a
       * restorer function that calls the {rt_,}sigreturn() system call.
       * Unfortunately, we cannot just reference the glibc version of this
       * function, as glibc goes out of its way to make it inaccessible.
       */
      void (*res)(void);
      __asm__ __volatile__("call   2f\n"
                         "0:.align 16\n"
                         "1:pop    %%eax\n"
                           "movl   %1,%%eax\n"
                           LSS_ENTRYPOINT
                         "2:popl   %0\n"
                           "addl   $(1b-0b),%0\n"
                           : "=a" (res)
                           : "i"  (__NR_sigreturn));
      return res;
    }
  #elif defined(__x86_64__)
    /* There are no known problems with any of the _syscallX() macros
     * currently shipping for x86_64, but we still need to be able to define
     * our own version so that we can override the location of the errno
     * location (e.g. when using the clone() system call with the CLONE_VM
     * option).
     */
    #undef LSS_ENTRYPOINT
    #ifdef SYS_SYSCALL_ENTRYPOINT
    static inline void (**LSS_NAME(get_syscall_entrypoint)(void))(void) {
      void (**entrypoint)(void);
      asm volatile(".bss\n"
                   ".align 8\n"
                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
                   ".previous\n"
                   "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %0\n"
                   : "=r"(entrypoint));
      return entrypoint;
    }

    #define LSS_ENTRYPOINT                                                    \
              ".bss\n"                                                        \
              ".align 8\n"                                                    \
              ".globl " SYS_SYSCALL_ENTRYPOINT "\n"                           \
              ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"                      \
              ".previous\n"                                                   \
              "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %%rcx\n"       \
              "mov  0(%%rcx), %%rcx\n"                                        \
              "test %%rcx, %%rcx\n"                                           \
              "jz   10001f\n"                                                 \
              "call *%%rcx\n"                                                 \
              "jmp  10002f\n"                                                 \
        "10001:syscall\n"                                                     \
        "10002:\n"

    #else
    #define LSS_ENTRYPOINT "syscall\n"
    #endif

    /* The x32 ABI has 32 bit longs, but the syscall interface is 64 bit.
     * We need to explicitly cast to an unsigned 64 bit type to avoid implicit
     * sign extension.  We can't cast pointers directly because those are
     * 32 bits, and gcc will dump ugly warnings about casting from a pointer
     * to an integer of a different size.
     */
    #undef  LSS_SYSCALL_ARG
    #define LSS_SYSCALL_ARG(a) ((uint64_t)(uintptr_t)(a))
    #undef  _LSS_RETURN
    #define _LSS_RETURN(type, res, cast)                                      \
      do {                                                                    \
        if ((uint64_t)(res) >= (uint64_t)(-4095)) {                           \
          LSS_ERRNO = -(res);                                                 \
          res = -1;                                                           \
        }                                                                     \
        return (type)(cast)(res);                                             \
      } while (0)
    #undef  LSS_RETURN
    #define LSS_RETURN(type, res) _LSS_RETURN(type, res, uintptr_t)

    #undef  _LSS_BODY
    #define _LSS_BODY(nr, type, name, cast, ...)                              \
          long long __res;                                                    \
          __asm__ __volatile__(LSS_BODY_ASM##nr LSS_ENTRYPOINT                \
            : "=a" (__res)                                                    \
            : "0" (__NR_##name) LSS_BODY_ARG##nr(__VA_ARGS__)                 \
            : LSS_BODY_CLOBBER##nr "r11", "rcx", "memory");                   \
          _LSS_RETURN(type, __res, cast)
    #undef  LSS_BODY
    #define LSS_BODY(nr, type, name, args...) \
      _LSS_BODY(nr, type, name, uintptr_t, ## args)

    #undef  LSS_BODY_ASM0
    #undef  LSS_BODY_ASM1
    #undef  LSS_BODY_ASM2
    #undef  LSS_BODY_ASM3
    #undef  LSS_BODY_ASM4
    #undef  LSS_BODY_ASM5
    #undef  LSS_BODY_ASM6
    #define LSS_BODY_ASM0
    #define LSS_BODY_ASM1 LSS_BODY_ASM0
    #define LSS_BODY_ASM2 LSS_BODY_ASM1
    #define LSS_BODY_ASM3 LSS_BODY_ASM2
    #define LSS_BODY_ASM4 LSS_BODY_ASM3 "movq %5,%%r10;"
    #define LSS_BODY_ASM5 LSS_BODY_ASM4 "movq %6,%%r8;"
    #define LSS_BODY_ASM6 LSS_BODY_ASM5 "movq %7,%%r9;"

    #undef  LSS_BODY_CLOBBER0
    #undef  LSS_BODY_CLOBBER1
    #undef  LSS_BODY_CLOBBER2
    #undef  LSS_BODY_CLOBBER3
    #undef  LSS_BODY_CLOBBER4
    #undef  LSS_BODY_CLOBBER5
    #undef  LSS_BODY_CLOBBER6
    #define LSS_BODY_CLOBBER0
    #define LSS_BODY_CLOBBER1 LSS_BODY_CLOBBER0
    #define LSS_BODY_CLOBBER2 LSS_BODY_CLOBBER1
    #define LSS_BODY_CLOBBER3 LSS_BODY_CLOBBER2
    #define LSS_BODY_CLOBBER4 LSS_BODY_CLOBBER3 "r10",
    #define LSS_BODY_CLOBBER5 LSS_BODY_CLOBBER4 "r8",
    #define LSS_BODY_CLOBBER6 LSS_BODY_CLOBBER5 "r9",

    #undef  LSS_BODY_ARG0
    #undef  LSS_BODY_ARG1
    #undef  LSS_BODY_ARG2
    #undef  LSS_BODY_ARG3
    #undef  LSS_BODY_ARG4
    #undef  LSS_BODY_ARG5
    #undef  LSS_BODY_ARG6
    #define LSS_BODY_ARG0()
    #define LSS_BODY_ARG1(arg1) \
      LSS_BODY_ARG0(), "D" (arg1)
    #define LSS_BODY_ARG2(arg1, arg2) \
      LSS_BODY_ARG1(arg1), "S" (arg2)
    #define LSS_BODY_ARG3(arg1, arg2, arg3) \
      LSS_BODY_ARG2(arg1, arg2), "d" (arg3)
    #define LSS_BODY_ARG4(arg1, arg2, arg3, arg4) \
      LSS_BODY_ARG3(arg1, arg2, arg3), "r" (arg4)
    #define LSS_BODY_ARG5(arg1, arg2, arg3, arg4, arg5) \
      LSS_BODY_ARG4(arg1, arg2, arg3, arg4), "r" (arg5)
    #define LSS_BODY_ARG6(arg1, arg2, arg3, arg4, arg5, arg6) \
      LSS_BODY_ARG5(arg1, arg2, arg3, arg4, arg5), "r" (arg6)

    #undef _syscall0
    #define _syscall0(type,name)                                              \
      type LSS_NAME(name)(void) {                                             \
        LSS_BODY(0, type, name);                                              \
      }
    #undef _syscall1
    #define _syscall1(type,name,type1,arg1)                                   \
      type LSS_NAME(name)(type1 arg1) {                                       \
        LSS_BODY(1, type, name, LSS_SYSCALL_ARG(arg1));                       \
      }
    #undef _syscall2
    #define _syscall2(type,name,type1,arg1,type2,arg2)                        \
      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
        LSS_BODY(2, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2));\
      }
    #undef _syscall3
    #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
        LSS_BODY(3, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
                                LSS_SYSCALL_ARG(arg3));                       \
      }
    #undef _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_BODY(4, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4));\
      }
    #undef _syscall5
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_BODY(5, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4), \
                                LSS_SYSCALL_ARG(arg5));                       \
      }
    #undef _syscall6
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        LSS_BODY(6, type, name, LSS_SYSCALL_ARG(arg1), LSS_SYSCALL_ARG(arg2), \
                                LSS_SYSCALL_ARG(arg3), LSS_SYSCALL_ARG(arg4), \
                                LSS_SYSCALL_ARG(arg5), LSS_SYSCALL_ARG(arg6));\
      }
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long long __res;
      {
        __asm__ __volatile__(/* if (fn == NULL)
                              *   return -EINVAL;
                              */
                             "testq  %4,%4\n"
                             "jz     1f\n"

                             /* if (child_stack == NULL)
                              *   return -EINVAL;
                              */
                             "testq  %5,%5\n"
                             "jz     1f\n"

                             /* childstack -= 2*sizeof(void *);
                              */
                             "subq   $16,%5\n"

                             /* Push "arg" and "fn" onto the stack that will be
                              * used by the child.
                              */
                             "movq   %7,8(%5)\n"
                             "movq   %4,0(%5)\n"

                             /* %rax = syscall(%rax = __NR_clone,
                              *                %rdi = flags,
                              *                %rsi = child_stack,
                              *                %rdx = parent_tidptr,
                              *                %r8  = new_tls,
                              *                %r10 = child_tidptr)
                              */
                             "movq   %2,%%rax\n"
                             "movq   %9,%%r8\n"
                             "movq   %10,%%r10\n"
                             LSS_ENTRYPOINT

                             /* if (%rax != 0)
                              *   return;
                              */
                             "testq  %%rax,%%rax\n"
                             "jnz    1f\n"

                             /* In the child. Terminate frame pointer chain.
                              */
                             "xorq   %%rbp,%%rbp\n"

                             /* Call "fn(arg)".
                              */
                             "popq   %%rax\n"
                             "popq   %%rdi\n"
                             "call   *%%rax\n"

                             /* Call _exit(%ebx).
                              */
                             "movq   %%rax,%%rdi\n"
                             "movq   %3,%%rax\n"
                             LSS_ENTRYPOINT

                             /* Return to parent.
                              */
                           "1:\n"
                             : "=a" (__res)
                             : "0"(-EINVAL), "i"(__NR_clone), "i"(__NR_exit),
                               "r"(LSS_SYSCALL_ARG(fn)),
                               "S"(LSS_SYSCALL_ARG(child_stack)),
                               "D"(LSS_SYSCALL_ARG(flags)),
                               "r"(LSS_SYSCALL_ARG(arg)),
                               "d"(LSS_SYSCALL_ARG(parent_tidptr)),
                               "r"(LSS_SYSCALL_ARG(newtls)),
                               "r"(LSS_SYSCALL_ARG(child_tidptr))
                             : "memory", "r8", "r10", "r11", "rcx");
      }
      LSS_RETURN(int, __res);
    }
    LSS_INLINE _syscall2(int, arch_prctl, int, c, void *, a)

    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {
      /* On x86-64, the kernel does not know how to return from
       * a signal handler. Instead, it relies on user space to provide a
       * restorer function that calls the rt_sigreturn() system call.
       * Unfortunately, we cannot just reference the glibc version of this
       * function, as glibc goes out of its way to make it inaccessible.
       */
      long long res;
      __asm__ __volatile__("jmp    2f\n"
                           ".align 16\n"
                         "1:movq   %1,%%rax\n"
                           LSS_ENTRYPOINT
                         "2:leaq   1b(%%rip),%0\n"
                           : "=r" (res)
                           : "i"  (__NR_rt_sigreturn));
      return (void (*)(void))(uintptr_t)res;
    }
  #elif defined(__ARM_ARCH_3__)
    /* Most definitions of _syscallX() neglect to mark "memory" as being
     * clobbered. This causes problems with compilers, that do a better job
     * at optimizing across __asm__ calls.
     * So, we just have to redefine all of the _syscallX() macros.
     */
    #undef LSS_REG
    #define LSS_REG(r,a) register long __r##r __asm__("r"#r) = (long)a
    #undef  LSS_BODY
    #define LSS_BODY(type,name,args...)                                       \
          register long __res_r0 __asm__("r0");                               \
          long __res;                                                         \
          __asm__ __volatile__ (__syscall(name)                               \
                                : "=r"(__res_r0) : args : "lr", "memory");    \
          __res = __res_r0;                                                   \
          LSS_RETURN(type, __res)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
      type LSS_NAME(name)(void) {                                             \
        LSS_BODY(type, name);                                                 \
      }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
      type LSS_NAME(name)(type1 arg1) {                                       \
        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
      }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
      }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
      }
    #undef _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4);                                                     \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
      }
    #undef _syscall5
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4));                                      \
      }
    #undef _syscall6
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4), "r"(__r5));                           \
      }
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long __res;
      {
        register int   __flags __asm__("r0") = flags;
        register void *__stack __asm__("r1") = child_stack;
        register void *__ptid  __asm__("r2") = parent_tidptr;
        register void *__tls   __asm__("r3") = newtls;
        register int  *__ctid  __asm__("r4") = child_tidptr;
        __asm__ __volatile__(/* if (fn == NULL || child_stack == NULL)
                              *   return -EINVAL;
                              */
                             "cmp   %2,#0\n"
                             "cmpne %3,#0\n"
                             "moveq %0,%1\n"
                             "beq   1f\n"

                             /* Push "arg" and "fn" onto the stack that will be
                              * used by the child.
                              */
                             "str   %5,[%3,#-4]!\n"
                             "str   %2,[%3,#-4]!\n"

                             /* %r0 = syscall(%r0 = flags,
                              *               %r1 = child_stack,
                              *               %r2 = parent_tidptr,
                              *               %r3 = newtls,
                              *               %r4 = child_tidptr)
                              */
                             __syscall(clone)"\n"

                             /* if (%r0 != 0)
                              *   return %r0;
                              */
                             "movs  %0,r0\n"
                             "bne   1f\n"

                             /* In the child, now. Call "fn(arg)".
                              */
                             "ldr   r0,[sp, #4]\n"
                             "mov   lr,pc\n"
                             "ldr   pc,[sp]\n"

                             /* Call _exit(%r0).
                              */
                             __syscall(exit)"\n"
                           "1:\n"
                             : "=r" (__res)
                             : "i"(-EINVAL),
                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
                               "r"(__ptid), "r"(__tls), "r"(__ctid)
                             : "cc", "lr", "memory");
      }
      LSS_RETURN(int, __res);
    }
  #elif defined(__ARM_EABI__)
    /* Most definitions of _syscallX() neglect to mark "memory" as being
     * clobbered. This causes problems with compilers, that do a better job
     * at optimizing across __asm__ calls.
     * So, we just have to redefine all fo the _syscallX() macros.
     */
    #undef LSS_REG
    #define LSS_REG(r,a) register long __r##r __asm__("r"#r) = (long)a
    #undef  LSS_BODY
    #define LSS_BODY(type,name,args...)                                       \
          register long __res_r0 __asm__("r0");                               \
          long __res;                                                         \
          __asm__ __volatile__ ("push {r7}\n"                                 \
                                "mov r7, %1\n"                                \
                                "swi 0x0\n"                                   \
                                "pop {r7}\n"                                  \
                                : "=r"(__res_r0)                              \
                                : "i"(__NR_##name) , ## args                  \
                                : "lr", "memory");                            \
          __res = __res_r0;                                                   \
          LSS_RETURN(type, __res)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
      type LSS_NAME(name)(void) {                                             \
        LSS_BODY(type, name);                                                 \
      }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
      type LSS_NAME(name)(type1 arg1) {                                       \
        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
      }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
      }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
      }
    #undef _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4);                                                     \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
      }
    #undef _syscall5
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4));                                      \
      }
    #undef _syscall6
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4), "r"(__r5));                           \
      }
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long __res;
      if (fn == NULL || child_stack == NULL) {
        __res = -EINVAL;
        LSS_RETURN(int, __res);
      }

      /* Push "arg" and "fn" onto the stack that will be
       * used by the child.
       */
      {
        uintptr_t* cstack = (uintptr_t*)child_stack - 2;
        cstack[0] = (uintptr_t)fn;
        cstack[1] = (uintptr_t)arg;
        child_stack = cstack;
      }
      {
        register int   __flags __asm__("r0") = flags;
        register void *__stack __asm__("r1") = child_stack;
        register void *__ptid  __asm__("r2") = parent_tidptr;
        register void *__tls   __asm__("r3") = newtls;
        register int  *__ctid  __asm__("r4") = child_tidptr;
        __asm__ __volatile__(
#ifdef __thumb2__
            "push {r7}\n"
#endif
            /* %r0 = syscall(%r0 = flags,
             *               %r1 = child_stack,
             *               %r2 = parent_tidptr,
             *               %r3 = newtls,
             *               %r4 = child_tidptr)
             */
            "mov r7, %6\n"
            "swi 0x0\n"

            /* if (%r0 != 0)
             *   return %r0;
             */
            "cmp   r0, #0\n"
            "bne   1f\n"

            /* In the child, now. Call "fn(arg)".
             */
            "ldr   r0,[sp, #4]\n"

            "ldr   lr,[sp]\n"
            "blx   lr\n"

            /* Call _exit(%r0).
             */
            "mov r7, %7\n"
            "swi 0x0\n"
            /* Unreachable */
            "bkpt #0\n"
         "1:\n"
#ifdef __thumb2__
            "pop {r7}\n"
#endif
            "movs  %0,r0\n"
            : "=r"(__res)
            : "r"(__stack), "r"(__flags), "r"(__ptid), "r"(__tls), "r"(__ctid),
              "i"(__NR_clone), "i"(__NR_exit)
            : "cc", "lr", "memory"
#ifndef __thumb2__
            , "r7"
#endif
            );
      }
      LSS_RETURN(int, __res);
    }
  #elif defined(__aarch64__)
    /* Most definitions of _syscallX() neglect to mark "memory" as being
     * clobbered. This causes problems with compilers, that do a better job
     * at optimizing across __asm__ calls.
     * So, we just have to redefine all of the _syscallX() macros.
     */
    #undef LSS_REG
    #define LSS_REG(r,a) register int64_t __r##r __asm__("x"#r) = (int64_t)a
    #undef  LSS_BODY
    #define LSS_BODY(type,name,args...)                                       \
          register int64_t __res_x0 __asm__("x0");                            \
          int64_t __res;                                                      \
          __asm__ __volatile__ ("mov x8, %1\n"                                \
                                "svc 0x0\n"                                   \
                                : "=r"(__res_x0)                              \
                                : "i"(__NR_##name) , ## args                  \
                                : "x8", "memory");                            \
          __res = __res_x0;                                                   \
          LSS_RETURN(type, __res)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
      type LSS_NAME(name)(void) {                                             \
        LSS_BODY(type, name);                                                 \
      }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
      type LSS_NAME(name)(type1 arg1) {                                       \
        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
      }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
      }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
      }
    #undef _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4);                                                     \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
      }
    #undef _syscall5
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4));                                      \
      }
    #undef _syscall6
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
                             "r"(__r4), "r"(__r5));                           \
      }

    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      int64_t __res;
      {
        register uint64_t __flags __asm__("x0") = flags;
        register void *__stack __asm__("x1") = child_stack;
        register void *__ptid  __asm__("x2") = parent_tidptr;
        register void *__tls   __asm__("x3") = newtls;
        register int  *__ctid  __asm__("x4") = child_tidptr;
        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
                              * used by the child.
                              */
                             "stp     %1, %4, [%2, #-16]!\n"

                             /* %x0 = syscall(%x0 = flags,
                              *               %x1 = child_stack,
                              *               %x2 = parent_tidptr,
                              *               %x3 = newtls,
                              *               %x4 = child_tidptr)
                              */
                             "mov     x8, %8\n"
                             "svc     0x0\n"

                             /* if (%r0 != 0)
                              *   return %r0;
                              */
                             "mov     %0, x0\n"
                             "cbnz    x0, 1f\n"

                             /* In the child, now. Call "fn(arg)".
                              */
                             "ldp     x1, x0, [sp], #16\n"
                             "blr     x1\n"

                             /* Call _exit(%r0).
                              */
                             "mov     x8, %9\n"
                             "svc     0x0\n"
                           "1:\n"
                             : "=r" (__res)
                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
                               "r"(__ptid), "r"(__tls), "r"(__ctid),
                               "i"(__NR_clone), "i"(__NR_exit)
                             : "cc", "x8", "memory");
      }
      LSS_RETURN(int, __res);
    }
  #elif defined(__mips__)
    #undef LSS_REG
    #define LSS_REG(r,a) register unsigned long __r##r __asm__("$"#r) =       \
                                 (unsigned long)(a)
    #undef  LSS_BODY
    #undef LSS_SYSCALL_CLOBBERS
    #if _MIPS_SIM == _MIPS_SIM_ABI32
    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$8", "$9", "$10",               \
                                 "$11", "$12", "$13", "$14", "$15",           \
                                 "$24", "$25", "hi", "lo", "memory"
    #else
    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$10", "$11", "$12",             \
                                 "$13", "$14", "$15", "$24", "$25",           \
                                 "hi", "lo", "memory"
    #endif
    #define LSS_BODY(type,name,r7,...)                                        \
          register unsigned long __v0 __asm__("$2") = __NR_##name;            \
          __asm__ __volatile__ ("syscall\n"                                   \
                                : "=r"(__v0), r7 (__r7)                       \
                                : "0"(__v0), ##__VA_ARGS__                    \
                                : LSS_SYSCALL_CLOBBERS);                      \
          LSS_RETURN(type, __v0, __r7)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
      type LSS_NAME(name)(void) {                                             \
        register unsigned long __r7 __asm__("$7");                            \
        LSS_BODY(type, name, "=r");                                           \
      }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
      type LSS_NAME(name)(type1 arg1) {                                       \
        register unsigned long __r7 __asm__("$7");                            \
        LSS_REG(4, arg1); LSS_BODY(type, name, "=r", "r"(__r4));              \
      }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
        register unsigned long __r7 __asm__("$7");                            \
        LSS_REG(4, arg1); LSS_REG(5, arg2);                                   \
        LSS_BODY(type, name, "=r", "r"(__r4), "r"(__r5));                     \
      }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
        register unsigned long __r7 __asm__("$7");                            \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_BODY(type, name, "=r", "r"(__r4), "r"(__r5), "r"(__r6));          \
      }
    #undef _syscall4
    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_REG(7, arg4);                                                     \
        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6));          \
      }
    #undef _syscall5
    #if _MIPS_SIM == _MIPS_SIM_ABI32
    /* The old 32bit MIPS system call API passes the fifth and sixth argument
     * on the stack, whereas the new APIs use registers "r8" and "r9".
     */
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_REG(7, arg4);                                                     \
        register unsigned long __v0 __asm__("$2") = __NR_##name;              \
        __asm__ __volatile__ (".set noreorder\n"                              \
                              "subu  $29, 32\n"                               \
                              "sw    %5, 16($29)\n"                           \
                              "syscall\n"                                     \
                              "addiu $29, 32\n"                               \
                              ".set reorder\n"                                \
                              : "+r"(__v0), "+r" (__r7)                       \
                              : "r"(__r4), "r"(__r5),                         \
                                "r"(__r6), "r" ((unsigned long)arg5)          \
                              : "$8", "$9", "$10", "$11", "$12",              \
                                "$13", "$14", "$15", "$24", "$25",            \
                                "memory");                                    \
        LSS_RETURN(type, __v0, __r7);                                         \
      }
    #else
    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5)                                             \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5) {                                       \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_REG(7, arg4); LSS_REG(8, arg5);                                   \
        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6),           \
                 "r"(__r8));                                                  \
      }
    #endif
    #undef _syscall6
    #if _MIPS_SIM == _MIPS_SIM_ABI32
    /* The old 32bit MIPS system call API passes the fifth and sixth argument
     * on the stack, whereas the new APIs use registers "r8" and "r9".
     */
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5, type6 arg6) {                           \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_REG(7, arg4);                                                     \
        register unsigned long __v0 __asm__("$2") = __NR_##name;              \
        __asm__ __volatile__ (".set noreorder\n"                              \
                              "subu  $29, 32\n"                               \
                              "sw    %5, 16($29)\n"                           \
                              "sw    %6, 20($29)\n"                           \
                              "syscall\n"                                     \
                              "addiu $29, 32\n"                               \
                              ".set reorder\n"                                \
                              : "+r"(__v0), "+r" (__r7)                       \
                              : "r"(__r4), "r"(__r5),                         \
                                "r"(__r6), "r" ((unsigned long)arg5),         \
                                "r" ((unsigned long)arg6)                     \
                              : "$8", "$9", "$10", "$11", "$12",              \
                                "$13", "$14", "$15", "$24", "$25",            \
                                "memory");                                    \
        LSS_RETURN(type, __v0, __r7);                                         \
      }
    #else
    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
                      type5,arg5,type6,arg6)                                  \
      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
                          type5 arg5,type6 arg6) {                            \
        LSS_REG(4, arg1); LSS_REG(5, arg2); LSS_REG(6, arg3);                 \
        LSS_REG(7, arg4); LSS_REG(8, arg5); LSS_REG(9, arg6);                 \
        LSS_BODY(type, name, "+r", "r"(__r4), "r"(__r5), "r"(__r6),           \
                 "r"(__r8), "r"(__r9));                                       \
      }
    #endif
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      register unsigned long __v0 __asm__("$2") = -EINVAL;
      register unsigned long __r7 __asm__("$7") = (unsigned long)newtls;
      {
        register int   __flags __asm__("$4") = flags;
        register void *__stack __asm__("$5") = child_stack;
        register void *__ptid  __asm__("$6") = parent_tidptr;
        register int  *__ctid  __asm__("$8") = child_tidptr;
        __asm__ __volatile__(
          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
                             "subu  $29,24\n"
          #elif _MIPS_SIM == _MIPS_SIM_NABI32
                             "sub   $29,16\n"
          #else
                             "dsubu $29,16\n"
          #endif

                             /* if (fn == NULL || child_stack == NULL)
                              *   return -EINVAL;
                              */
                             "beqz  %4,1f\n"
                             "beqz  %5,1f\n"

                             /* Push "arg" and "fn" onto the stack that will be
                              * used by the child.
                              */
          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
                             "subu  %5,32\n"
                             "sw    %4,0(%5)\n"
                             "sw    %7,4(%5)\n"
          #elif _MIPS_SIM == _MIPS_SIM_NABI32
                             "sub   %5,32\n"
                             "sw    %4,0(%5)\n"
                             "sw    %7,8(%5)\n"
          #else
                             "dsubu %5,32\n"
                             "sd    %4,0(%5)\n"
                             "sd    %7,8(%5)\n"
          #endif

                             /* $7 = syscall($4 = flags,
                              *              $5 = child_stack,
                              *              $6 = parent_tidptr,
                              *              $7 = newtls,
                              *              $8 = child_tidptr)
                              */
                             "li    $2,%2\n"
                             "syscall\n"

                             /* if ($7 != 0)
                              *   return $2;
                              */
                             "bnez  $7,1f\n"
                             "bnez  $2,1f\n"

                             /* In the child, now. Call "fn(arg)".
                              */
          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
                            "lw    $25,0($29)\n"
                            "lw    $4,4($29)\n"
          #elif _MIPS_SIM == _MIPS_SIM_NABI32
                            "lw    $25,0($29)\n"
                            "lw    $4,8($29)\n"
          #else
                            "ld    $25,0($29)\n"
                            "ld    $4,8($29)\n"
          #endif
                            "jalr  $25\n"

                             /* Call _exit($2)
                              */
                            "move  $4,$2\n"
                            "li    $2,%3\n"
                            "syscall\n"

                           "1:\n"
          #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
                             "addu  $29, 24\n"
          #elif _MIPS_SIM == _MIPS_SIM_NABI32
                             "add   $29, 16\n"
          #else
                             "daddu $29,16\n"
          #endif
                             : "+r" (__v0), "+r" (__r7)
                             : "i"(__NR_clone), "i"(__NR_exit), "r"(fn),
                               "r"(__stack), "r"(__flags), "r"(arg),
                               "r"(__ptid), "r"(__ctid)
                             : "$9", "$10", "$11", "$12", "$13", "$14", "$15",
                               "$24", "$25", "memory");
      }
      LSS_RETURN(int, __v0, __r7);
    }
  #elif defined (__PPC__)
    #undef  LSS_LOADARGS_0
    #define LSS_LOADARGS_0(name, dummy...)                                    \
        __sc_0 = __NR_##name
    #undef  LSS_LOADARGS_1
    #define LSS_LOADARGS_1(name, arg1)                                        \
            LSS_LOADARGS_0(name);                                             \
            __sc_3 = (unsigned long) (arg1)
    #undef  LSS_LOADARGS_2
    #define LSS_LOADARGS_2(name, arg1, arg2)                                  \
            LSS_LOADARGS_1(name, arg1);                                       \
            __sc_4 = (unsigned long) (arg2)
    #undef  LSS_LOADARGS_3
    #define LSS_LOADARGS_3(name, arg1, arg2, arg3)                            \
            LSS_LOADARGS_2(name, arg1, arg2);                                 \
            __sc_5 = (unsigned long) (arg3)
    #undef  LSS_LOADARGS_4
    #define LSS_LOADARGS_4(name, arg1, arg2, arg3, arg4)                      \
            LSS_LOADARGS_3(name, arg1, arg2, arg3);                           \
            __sc_6 = (unsigned long) (arg4)
    #undef  LSS_LOADARGS_5
    #define LSS_LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5)                \
            LSS_LOADARGS_4(name, arg1, arg2, arg3, arg4);                     \
            __sc_7 = (unsigned long) (arg5)
    #undef  LSS_LOADARGS_6
    #define LSS_LOADARGS_6(name, arg1, arg2, arg3, arg4, arg5, arg6)          \
            LSS_LOADARGS_5(name, arg1, arg2, arg3, arg4, arg5);               \
            __sc_8 = (unsigned long) (arg6)
    #undef  LSS_ASMINPUT_0
    #define LSS_ASMINPUT_0 "0" (__sc_0)
    #undef  LSS_ASMINPUT_1
    #define LSS_ASMINPUT_1 LSS_ASMINPUT_0, "1" (__sc_3)
    #undef  LSS_ASMINPUT_2
    #define LSS_ASMINPUT_2 LSS_ASMINPUT_1, "2" (__sc_4)
    #undef  LSS_ASMINPUT_3
    #define LSS_ASMINPUT_3 LSS_ASMINPUT_2, "3" (__sc_5)
    #undef  LSS_ASMINPUT_4
    #define LSS_ASMINPUT_4 LSS_ASMINPUT_3, "4" (__sc_6)
    #undef  LSS_ASMINPUT_5
    #define LSS_ASMINPUT_5 LSS_ASMINPUT_4, "5" (__sc_7)
    #undef  LSS_ASMINPUT_6
    #define LSS_ASMINPUT_6 LSS_ASMINPUT_5, "6" (__sc_8)
    #undef  LSS_BODY
    #define LSS_BODY(nr, type, name, args...)                                 \
        long __sc_ret, __sc_err;                                              \
        {                                                                     \
                        register unsigned long __sc_0 __asm__ ("r0");         \
                        register unsigned long __sc_3 __asm__ ("r3");         \
                        register unsigned long __sc_4 __asm__ ("r4");         \
                        register unsigned long __sc_5 __asm__ ("r5");         \
                        register unsigned long __sc_6 __asm__ ("r6");         \
                        register unsigned long __sc_7 __asm__ ("r7");         \
                        register unsigned long __sc_8 __asm__ ("r8");         \
                                                                              \
            LSS_LOADARGS_##nr(name, args);                                    \
            __asm__ __volatile__                                              \
                ("sc\n\t"                                                     \
                 "mfcr %0"                                                    \
                 : "=&r" (__sc_0),                                            \
                   "=&r" (__sc_3), "=&r" (__sc_4),                            \
                   "=&r" (__sc_5), "=&r" (__sc_6),                            \
                   "=&r" (__sc_7), "=&r" (__sc_8)                             \
                 : LSS_ASMINPUT_##nr                                          \
                 : "cr0", "ctr", "memory",                                    \
                   "r9", "r10", "r11", "r12");                                \
            __sc_ret = __sc_3;                                                \
            __sc_err = __sc_0;                                                \
        }                                                                     \
        LSS_RETURN(type, __sc_ret, __sc_err)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
       type LSS_NAME(name)(void) {                                            \
          LSS_BODY(0, type, name);                                            \
       }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
       type LSS_NAME(name)(type1 arg1) {                                      \
          LSS_BODY(1, type, name, arg1);                                      \
       }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
       type LSS_NAME(name)(type1 arg1, type2 arg2) {                          \
          LSS_BODY(2, type, name, arg1, arg2);                                \
       }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {              \
          LSS_BODY(3, type, name, arg1, arg2, arg3);                          \
       }
    #undef _syscall4
    #define _syscall4(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4)                                \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {  \
          LSS_BODY(4, type, name, arg1, arg2, arg3, arg4);                    \
       }
    #undef _syscall5
    #define _syscall5(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4, type5, arg5)                   \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,    \
                                               type5 arg5) {                  \
          LSS_BODY(5, type, name, arg1, arg2, arg3, arg4, arg5);              \
       }
    #undef _syscall6
    #define _syscall6(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4, type5, arg5, type6, arg6)      \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,    \
                                               type5 arg5, type6 arg6) {      \
          LSS_BODY(6, type, name, arg1, arg2, arg3, arg4, arg5, arg6);        \
       }
    /* clone function adapted from glibc 2.3.6 clone.S                       */
    /* TODO(csilvers): consider wrapping some args up in a struct, like we
     * do for i386's _syscall6, so we can compile successfully on gcc 2.95
     */
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long __ret, __err;
      {
        register int (*__fn)(void *)    __asm__ ("r8")  = fn;
        register void *__cstack                 __asm__ ("r4")  = child_stack;
        register int __flags                    __asm__ ("r3")  = flags;
        register void * __arg                   __asm__ ("r9")  = arg;
        register int * __ptidptr                __asm__ ("r5")  = parent_tidptr;
        register void * __newtls                __asm__ ("r6")  = newtls;
        register int * __ctidptr                __asm__ ("r7")  = child_tidptr;
        __asm__ __volatile__(
            /* check for fn == NULL
             * and child_stack == NULL
             */
            "cmpwi cr0, %6, 0\n\t"
            "cmpwi cr1, %7, 0\n\t"
            "cror cr0*4+eq, cr1*4+eq, cr0*4+eq\n\t"
            "beq- cr0, 1f\n\t"

            /* set up stack frame for child                                  */
            "clrrwi %7, %7, 4\n\t"
            "li 0, 0\n\t"
            "stwu 0, -16(%7)\n\t"

            /* fn, arg, child_stack are saved across the syscall: r28-30     */
            "mr 28, %6\n\t"
            "mr 29, %7\n\t"
            "mr 27, %9\n\t"

            /* syscall                                                       */
            "li 0, %4\n\t"
            /* flags already in r3
             * child_stack already in r4
             * ptidptr already in r5
             * newtls already in r6
             * ctidptr already in r7
             */
            "sc\n\t"

            /* Test if syscall was successful                                */
            "cmpwi cr1, 3, 0\n\t"
            "crandc cr1*4+eq, cr1*4+eq, cr0*4+so\n\t"
            "bne- cr1, 1f\n\t"

            /* Do the function call                                          */
            "mtctr 28\n\t"
            "mr 3, 27\n\t"
            "bctrl\n\t"

            /* Call _exit(r3)                                                */
            "li 0, %5\n\t"
            "sc\n\t"

            /* Return to parent                                              */
            "1:\n"
            "mfcr %1\n\t"
            "mr %0, 3\n\t"
              : "=r" (__ret), "=r" (__err)
              : "0" (-1), "1" (EINVAL),
                "i" (__NR_clone), "i" (__NR_exit),
                "r" (__fn), "r" (__cstack), "r" (__flags),
                "r" (__arg), "r" (__ptidptr), "r" (__newtls),
                "r" (__ctidptr)
              : "cr0", "cr1", "memory", "ctr",
                "r0", "r29", "r27", "r28");
      }
      LSS_RETURN(int, __ret, __err);
    }
  #elif defined(__s390__)
    #undef  LSS_REG
    #define LSS_REG(r, a) register unsigned long __r##r __asm__("r"#r) = (unsigned long) a
    #undef  LSS_BODY
    #define LSS_BODY(type, name, args...)                                     \
        register unsigned long __nr __asm__("r1")                             \
            = (unsigned long)(__NR_##name);                                   \
        register long __res_r2 __asm__("r2");                                 \
        long __res;                                                           \
        __asm__ __volatile__                                                  \
            ("svc 0\n\t"                                                      \
             : "=d"(__res_r2)                                                 \
             : "d"(__nr), ## args                                             \
             : "memory");                                                     \
        __res = __res_r2;                                                     \
        LSS_RETURN(type, __res)
    #undef _syscall0
    #define _syscall0(type, name)                                             \
       type LSS_NAME(name)(void) {                                            \
          LSS_BODY(type, name);                                               \
       }
    #undef _syscall1
    #define _syscall1(type, name, type1, arg1)                                \
       type LSS_NAME(name)(type1 arg1) {                                      \
          LSS_REG(2, arg1);                                                   \
          LSS_BODY(type, name, "0"(__r2));                                    \
       }
    #undef _syscall2
    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
       type LSS_NAME(name)(type1 arg1, type2 arg2) {                          \
          LSS_REG(2, arg1); LSS_REG(3, arg2);                                 \
          LSS_BODY(type, name, "0"(__r2), "d"(__r3));                         \
       }
    #undef _syscall3
    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {              \
          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4));              \
       }
    #undef _syscall4
    #define _syscall4(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4)                                \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
                           type4 arg4) {                                      \
          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
          LSS_REG(5, arg4);                                                   \
          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
                               "d"(__r5));                                    \
       }
    #undef _syscall5
    #define _syscall5(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4, type5, arg5)                   \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
                           type4 arg4, type5 arg5) {                          \
          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
          LSS_REG(5, arg4); LSS_REG(6, arg5);                                 \
          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
                               "d"(__r5), "d"(__r6));                         \
       }
    #undef _syscall6
    #define _syscall6(type, name, type1, arg1, type2, arg2, type3, arg3,      \
                                  type4, arg4, type5, arg5, type6, arg6)      \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
                           type4 arg4, type5 arg5, type6 arg6) {              \
          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
          LSS_REG(5, arg4); LSS_REG(6, arg5); LSS_REG(7, arg6);               \
          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
                               "d"(__r5), "d"(__r6), "d"(__r7));              \
       }
    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                   int flags, void *arg, int *parent_tidptr,
                                   void *newtls, int *child_tidptr) {
      long __ret;
      {
        register int  (*__fn)(void *)    __asm__ ("r1")  = fn;
        register void  *__cstack         __asm__ ("r2")  = child_stack;
        register int    __flags          __asm__ ("r3")  = flags;
        register void  *__arg            __asm__ ("r0")  = arg;
        register int   *__ptidptr        __asm__ ("r4")  = parent_tidptr;
        register void  *__newtls         __asm__ ("r6")  = newtls;
        register int   *__ctidptr        __asm__ ("r5")  = child_tidptr;
        __asm__ __volatile__ (
    #ifndef __s390x__
                                  /* arg already in r0 */
          "ltr %4, %4\n\t"        /* check fn, which is already in r1 */
          "jz 1f\n\t"             /* NULL function pointer, return -EINVAL */
          "ltr %5, %5\n\t"        /* check child_stack, which is already in r2 */
          "jz 1f\n\t"             /* NULL stack pointer, return -EINVAL */
                                  /* flags already in r3 */
                                  /* parent_tidptr already in r4 */
                                  /* child_tidptr already in r5 */
                                  /* newtls already in r6 */
          "svc %2\n\t"            /* invoke clone syscall */
          "ltr %0,%%r2\n\t"       /* load return code into __ret and test */
          "jnz 1f\n\t"            /* return to parent if non-zero */
                                  /* start child thread */
          "lr %%r2, %7\n\t"       /* set first parameter to void *arg */
          "ahi %%r15, -96\n\t"    /* make room on the stack for the save area */
          "xc 0(4,%%r15), 0(%%r15)\n\t"
          "basr %%r14, %4\n\t"    /* jump to fn */
          "svc %3\n"              /* invoke exit syscall */
          "1:\n"
    #else
                                  /* arg already in r0 */
          "ltgr %4, %4\n\t"       /* check fn, which is already in r1 */
          "jz 1f\n\t"             /* NULL function pointer, return -EINVAL */
          "ltgr %5, %5\n\t"       /* check child_stack, which is already in r2 */
          "jz 1f\n\t"             /* NULL stack pointer, return -EINVAL */
                                  /* flags already in r3 */
                                  /* parent_tidptr already in r4 */
                                  /* child_tidptr already in r5 */
                                  /* newtls already in r6 */
          "svc %2\n\t"            /* invoke clone syscall */
          "ltgr %0, %%r2\n\t"     /* load return code into __ret and test */
          "jnz 1f\n\t"            /* return to parent if non-zero */
                                  /* start child thread */
          "lgr %%r2, %7\n\t"      /* set first parameter to void *arg */
          "aghi %%r15, -160\n\t"  /* make room on the stack for the save area */
          "xc 0(8,%%r15), 0(%%r15)\n\t"
          "basr %%r14, %4\n\t"    /* jump to fn */
          "svc %3\n"              /* invoke exit syscall */
          "1:\n"
    #endif
          : "=r" (__ret)
          : "0" (-EINVAL), "i" (__NR_clone), "i" (__NR_exit),
            "d" (__fn), "d" (__cstack), "d" (__flags), "d" (__arg),
            "d" (__ptidptr), "d" (__newtls), "d" (__ctidptr)
          : "cc", "r14", "memory"
        );
      }
      LSS_RETURN(int, __ret);
    }
  #endif
  #define __NR__exit   __NR_exit
  #define __NR__gettid __NR_gettid
  #define __NR__mremap __NR_mremap
  LSS_INLINE _syscall1(void *,  brk,             void *,      e)
  LSS_INLINE _syscall1(int,     chdir,           const char *,p)
  LSS_INLINE _syscall1(int,     close,           int,         f)
  LSS_INLINE _syscall2(int,     clock_getres,    int,         c,
                       struct kernel_timespec*, t)
  LSS_INLINE _syscall2(int,     clock_gettime,   int,         c,
                       struct kernel_timespec*, t)
  LSS_INLINE _syscall1(int,     dup,             int,         f)
  #if defined(__NR_dup2)
    // dup2 is polyfilled below when not available.
    LSS_INLINE _syscall2(int,     dup2,            int,         s,
                         int,            d)
  #endif
  #if defined(__NR_dup3)
    LSS_INLINE _syscall3(int, dup3,  int, s, int, d, int, f)
  #endif
  LSS_INLINE _syscall3(int,     execve,          const char*, f,
                       const char*const*,a,const char*const*, e)
  LSS_INLINE _syscall1(int,     _exit,           int,         e)
  LSS_INLINE _syscall1(int,     exit_group,      int,         e)
  LSS_INLINE _syscall3(int,     fcntl,           int,         f,
                       int,            c, long,   a)
  #if defined(__NR_fork)
    // fork is polyfilled below when not available.
    LSS_INLINE _syscall0(pid_t,   fork)
  #endif
  LSS_INLINE _syscall2(int,     fstat,           int,         f,
                      struct kernel_stat*,   b)
  LSS_INLINE _syscall2(int,     fstatfs,         int,         f,
                      struct kernel_statfs*, b)
  #if defined(__x86_64__)
    /* Need to make sure off_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE int LSS_NAME(ftruncate)(int f, off_t l) {
      LSS_BODY(2, int, ftruncate, LSS_SYSCALL_ARG(f), (uint64_t)(l));
    }
  #else
    LSS_INLINE _syscall2(int, ftruncate,           int,         f,
                         off_t,          l)
  #endif
  LSS_INLINE _syscall6(int,     futex,          int*,        u,
                       int,     o,              int,         v,
                       struct kernel_timespec*, t,
                       int*,    u2,             int,         v2)
  LSS_INLINE _syscall3(int,     getdents,        int,         f,
                       struct kernel_dirent*, d, int,    c)
  LSS_INLINE _syscall3(int,     getdents64,      int,         f,
                      struct kernel_dirent64*, d, int,    c)
  LSS_INLINE _syscall0(gid_t,   getegid)
  LSS_INLINE _syscall0(uid_t,   geteuid)
  #if defined(__NR_getpgrp)
    LSS_INLINE _syscall0(pid_t,   getpgrp)
  #endif
  LSS_INLINE _syscall0(pid_t,   getpid)
  LSS_INLINE _syscall0(pid_t,   getppid)
  LSS_INLINE _syscall2(int,     getpriority,     int,         a,
                       int,            b)
  LSS_INLINE _syscall3(int,     getresgid,       gid_t *,     r,
                       gid_t *,         e,       gid_t *,     s)
  LSS_INLINE _syscall3(int,     getresuid,       uid_t *,     r,
                       uid_t *,         e,       uid_t *,     s)
#if !defined(__ARM_EABI__)
  LSS_INLINE _syscall2(int,     getrlimit,       int,         r,
                      struct kernel_rlimit*, l)
#endif
  LSS_INLINE _syscall1(pid_t,   getsid,          pid_t,       p)
  LSS_INLINE _syscall0(pid_t,   _gettid)
  LSS_INLINE _syscall2(pid_t,   gettimeofday,    struct kernel_timeval*, t,
                       void*, tz)
  LSS_INLINE _syscall5(int,     setxattr,        const char *,p,
                       const char *,   n,        const void *,v,
                       size_t,         s,        int,         f)
  LSS_INLINE _syscall5(int,     lsetxattr,       const char *,p,
                       const char *,   n,        const void *,v,
                       size_t,         s,        int,         f)
  LSS_INLINE _syscall4(ssize_t, getxattr,        const char *,p,
                       const char *,   n,        void *,      v, size_t, s)
  LSS_INLINE _syscall4(ssize_t, lgetxattr,       const char *,p,
                       const char *,   n,        void *,      v, size_t, s)
  LSS_INLINE _syscall3(ssize_t, listxattr,       const char *,p,
                       char *,   l,              size_t,      s)
  LSS_INLINE _syscall3(ssize_t, llistxattr,      const char *,p,
                       char *,   l,              size_t,      s)
  LSS_INLINE _syscall3(int,     ioctl,           int,         d,
                       int,     r,               void *,      a)
  LSS_INLINE _syscall2(int,     ioprio_get,      int,         which,
                       int,     who)
  LSS_INLINE _syscall3(int,     ioprio_set,      int,         which,
                       int,     who,             int,         ioprio)
  LSS_INLINE _syscall2(int,     kill,            pid_t,       p,
                       int,            s)
  #if defined(__x86_64__)
    /* Need to make sure off_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE off_t LSS_NAME(lseek)(int f, off_t o, int w) {
      _LSS_BODY(3, off_t, lseek, off_t, LSS_SYSCALL_ARG(f), (uint64_t)(o),
                                        LSS_SYSCALL_ARG(w));
    }
  #else
    LSS_INLINE _syscall3(off_t,   lseek,           int,         f,
                         off_t,          o, int,    w)
  #endif
  LSS_INLINE _syscall2(int,     munmap,          void*,       s,
                       size_t,         l)
  LSS_INLINE _syscall6(long,    move_pages,      pid_t,       p,
                       unsigned long,  n, void **,g, int *,   d,
                       int *,          s, int,    f)
  LSS_INLINE _syscall3(int,     mprotect,        const void *,a,
                       size_t,         l,        int,         p)
  LSS_INLINE _syscall5(void*,   _mremap,         void*,       o,
                       size_t,         os,       size_t,      ns,
                       unsigned long,  f, void *, a)
  #if defined(__NR_open)
    // open is polyfilled below when not available.
    LSS_INLINE _syscall3(int,     open,            const char*, p,
                         int,            f, int,    m)
  #endif
  #if defined(__NR_poll)
    // poll is polyfilled below when not available.
    LSS_INLINE _syscall3(int,     poll,           struct kernel_pollfd*, u,
                         unsigned int,   n, int,    t)
  #endif
  #if defined(__NR_ppoll)
    LSS_INLINE _syscall5(int, ppoll, struct kernel_pollfd *, u,
                         unsigned int, n, const struct kernel_timespec *, t,
                         const struct kernel_sigset_t *, sigmask, size_t, s)
  #endif
  LSS_INLINE _syscall5(int,     prctl,           int,         option,
                       unsigned long,  arg2,
                       unsigned long,  arg3,
                       unsigned long,  arg4,
                       unsigned long,  arg5)
  LSS_INLINE _syscall4(long,    ptrace,          int,         r,
                       pid_t,          p, void *, a, void *, d)
  #if defined(__NR_quotactl)
    // Defined on x86_64 / i386 only
    LSS_INLINE _syscall4(int,  quotactl,  int,  cmd,  const char *, special,
                         int, id, caddr_t, addr)
  #endif
  LSS_INLINE _syscall3(ssize_t, read,            int,         f,
                       void *,         b, size_t, c)
  #if defined(__NR_readlink)
    // readlink is polyfilled below when not available.
    LSS_INLINE _syscall3(int,     readlink,        const char*, p,
                         char*,          b, size_t, s)
  #endif
  #if defined(__NR_readlinkat)
    LSS_INLINE _syscall4(int, readlinkat, int, d, const char *, p, char *, b,
                         size_t, s)
  #endif
  LSS_INLINE _syscall4(int,     rt_sigaction,    int,         s,
                       const struct kernel_sigaction*, a,
                       struct kernel_sigaction*, o, size_t,   c)
  LSS_INLINE _syscall2(int, rt_sigpending, struct kernel_sigset_t *, s,
                       size_t,         c)
  LSS_INLINE _syscall4(int, rt_sigprocmask,      int,         h,
                       const struct kernel_sigset_t*,  s,
                       struct kernel_sigset_t*,        o, size_t, c)
  LSS_INLINE _syscall2(int, rt_sigsuspend,
                       const struct kernel_sigset_t*, s,  size_t, c)
  LSS_INLINE _syscall4(int, rt_sigtimedwait, const struct kernel_sigset_t*, s,
                       siginfo_t*, i, const struct timespec*, t, size_t, c)
  LSS_INLINE _syscall3(int,     sched_getaffinity,pid_t,      p,
                       unsigned int,   l, unsigned long *, m)
  LSS_INLINE _syscall3(int,     sched_setaffinity,pid_t,      p,
                       unsigned int,   l, unsigned long *, m)
  LSS_INLINE _syscall0(int,     sched_yield)
  LSS_INLINE _syscall1(long,    set_tid_address, int *,       t)
  LSS_INLINE _syscall1(int,     setfsgid,        gid_t,       g)
  LSS_INLINE _syscall1(int,     setfsuid,        uid_t,       u)
  LSS_INLINE _syscall1(int,     setuid,          uid_t,       u)
  LSS_INLINE _syscall1(int,     setgid,          gid_t,       g)
  LSS_INLINE _syscall2(int,     setpgid,         pid_t,       p,
                       pid_t,          g)
  LSS_INLINE _syscall3(int,     setpriority,     int,         a,
                       int,            b, int,    p)
  LSS_INLINE _syscall3(int,     setresgid,       gid_t,       r,
                       gid_t,          e, gid_t,  s)
  LSS_INLINE _syscall3(int,     setresuid,       uid_t,       r,
                       uid_t,          e, uid_t,  s)
  LSS_INLINE _syscall2(int,     setrlimit,       int,         r,
                       const struct kernel_rlimit*, l)
  LSS_INLINE _syscall0(pid_t,    setsid)
  LSS_INLINE _syscall2(int,     sigaltstack,     const stack_t*, s,
                       const stack_t*, o)
  #if defined(__NR_sigreturn)
    LSS_INLINE _syscall1(int,     sigreturn,       unsigned long, u)
  #endif
  #if defined(__NR_stat)
    // stat is polyfilled below when not available.
    LSS_INLINE _syscall2(int,     stat,            const char*, f,
                        struct kernel_stat*,   b)
  #endif
  LSS_INLINE _syscall2(int,     statfs,          const char*, f,
                      struct kernel_statfs*, b)
  LSS_INLINE _syscall3(int,     tgkill,          pid_t,       p,
                       pid_t,          t, int,            s)
  LSS_INLINE _syscall2(int,     tkill,           pid_t,       p,
                       int,            s)
  #if defined(__NR_unlink)
    // unlink is polyfilled below when not available.
    LSS_INLINE _syscall1(int,     unlink,           const char*, f)
  #endif
  LSS_INLINE _syscall3(ssize_t, write,            int,        f,
                       const void *,   b, size_t, c)
  LSS_INLINE _syscall3(ssize_t, writev,           int,        f,
                       const struct kernel_iovec*, v, size_t, c)
  #if defined(__NR_getcpu)
    LSS_INLINE _syscall3(long, getcpu, unsigned *, cpu,
                         unsigned *, node, void *, unused)
  #endif
  #if defined(__x86_64__) ||                                                  \
     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI32)
    LSS_INLINE _syscall3(int, recvmsg,            int,   s,
                        struct kernel_msghdr*,     m, int, f)
    LSS_INLINE _syscall3(int, sendmsg,            int,   s,
                         const struct kernel_msghdr*, m, int, f)
    LSS_INLINE _syscall6(int, sendto,             int,   s,
                         const void*,             m, size_t, l,
                         int,                     f,
                         const struct kernel_sockaddr*, a, int, t)
    LSS_INLINE _syscall2(int, shutdown,           int,   s,
                         int,                     h)
    LSS_INLINE _syscall3(int, socket,             int,   d,
                         int,                     t, int,       p)
    LSS_INLINE _syscall4(int, socketpair,         int,   d,
                         int,                     t, int,       p, int*, s)
  #endif
  #if defined(__NR_fadvise64)
    #if defined(__x86_64__)
    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset, loff_t len,
                                       int advice) {
      LSS_BODY(4, int, fadvise64, LSS_SYSCALL_ARG(fd), (uint64_t)(offset),
                                  (uint64_t)(len), LSS_SYSCALL_ARG(advice));
    }
    #else
    LSS_INLINE _syscall4(int, fadvise64,
                         int, fd, loff_t, offset, loff_t, len, int, advice)
    #endif
  #elif defined(__i386__)
    #define __NR__fadvise64_64 __NR_fadvise64_64
    LSS_INLINE _syscall6(int, _fadvise64_64, int, fd,
                         unsigned, offset_lo, unsigned, offset_hi,
                         unsigned, len_lo, unsigned, len_hi,
                         int, advice)

    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
                                       loff_t len, int advice) {
      return LSS_NAME(_fadvise64_64)(fd,
                                     (unsigned)offset, (unsigned)(offset >>32),
                                     (unsigned)len, (unsigned)(len >> 32),
                                     advice);
    }

  #elif defined(__s390__) && !defined(__s390x__)
    #define __NR__fadvise64_64 __NR_fadvise64_64
    struct kernel_fadvise64_64_args {
      int fd;
      long long offset;
      long long len;
      int advice;
    };

    LSS_INLINE _syscall1(int, _fadvise64_64,
                         struct kernel_fadvise64_64_args *args)

    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
                                       loff_t len, int advice) {
      struct kernel_fadvise64_64_args args = { fd, offset, len, advice };
      return LSS_NAME(_fadvise64_64)(&args);
    }
  #endif
  #if defined(__NR_fallocate)
    #if defined(__x86_64__)
    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE int LSS_NAME(fallocate)(int f, int mode, loff_t offset,
                                       loff_t len) {
      LSS_BODY(4, int, fallocate, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(mode),
                                  (uint64_t)(offset), (uint64_t)(len));
    }
    #elif (defined(__i386__) || (defined(__s390__) && !defined(__s390x__)) \
           || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) \
           || (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) \
           || defined(__PPC__))
    #define __NR__fallocate __NR_fallocate
    LSS_INLINE _syscall6(int, _fallocate, int, fd,
                         int, mode,
                         unsigned, offset_lo, unsigned, offset_hi,
                         unsigned, len_lo, unsigned, len_hi)

    LSS_INLINE int LSS_NAME(fallocate)(int fd, int mode,
                                       loff_t offset, loff_t len) {
      union { loff_t off; unsigned w[2]; } o = { offset }, l = { len };
      return LSS_NAME(_fallocate)(fd, mode, o.w[0], o.w[1], l.w[0], l.w[1]);
    }
    #else
    LSS_INLINE _syscall4(int, fallocate,
                         int, f, int, mode, loff_t, offset, loff_t, len)
    #endif
  #endif
  #if defined(__NR_getrandom)
    LSS_INLINE _syscall3(ssize_t, getrandom, void*, buffer, size_t, length,
                         unsigned int, flags)
  #endif
  #if defined(__NR_newfstatat)
    LSS_INLINE _syscall4(int, newfstatat,         int,   d,
                         const char *,            p,
                         struct kernel_stat*,     b, int, f)
  #endif
  #if defined(__x86_64__) || defined(__s390x__)
    LSS_INLINE int LSS_NAME(getresgid32)(gid_t *rgid,
                                         gid_t *egid,
                                         gid_t *sgid) {
      return LSS_NAME(getresgid)(rgid, egid, sgid);
    }

    LSS_INLINE int LSS_NAME(getresuid32)(uid_t *ruid,
                                         uid_t *euid,
                                         uid_t *suid) {
      return LSS_NAME(getresuid)(ruid, euid, suid);
    }

    LSS_INLINE int LSS_NAME(setfsgid32)(gid_t gid) {
      return LSS_NAME(setfsgid)(gid);
    }

    LSS_INLINE int LSS_NAME(setfsuid32)(uid_t uid) {
      return LSS_NAME(setfsuid)(uid);
    }

    LSS_INLINE int LSS_NAME(setresgid32)(gid_t rgid, gid_t egid, gid_t sgid) {
      return LSS_NAME(setresgid)(rgid, egid, sgid);
    }

    LSS_INLINE int LSS_NAME(setresuid32)(uid_t ruid, uid_t euid, uid_t suid) {
      return LSS_NAME(setresuid)(ruid, euid, suid);
    }

    LSS_INLINE int LSS_NAME(sigaction)(int signum,
                                       const struct kernel_sigaction *act,
                                       struct kernel_sigaction *oldact) {
      #if defined(__x86_64__)
      /* On x86_64, the kernel requires us to always set our own
       * SA_RESTORER in order to be able to return from a signal handler.
       * This function must have a "magic" signature that the "gdb"
       * (and maybe the kernel?) can recognize.
       */
      if (act != NULL && !(act->sa_flags & SA_RESTORER)) {
        struct kernel_sigaction a = *act;
        a.sa_flags   |= SA_RESTORER;
        a.sa_restorer = LSS_NAME(restore_rt)();
        return LSS_NAME(rt_sigaction)(signum, &a, oldact,
                                      (KERNEL_NSIG+7)/8);
      } else
      #endif
        return LSS_NAME(rt_sigaction)(signum, act, oldact,
                                      (KERNEL_NSIG+7)/8);
    }

    LSS_INLINE int LSS_NAME(sigpending)(struct kernel_sigset_t *set) {
      return LSS_NAME(rt_sigpending)(set, (KERNEL_NSIG+7)/8);
    }

    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
      return LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
    }
  #endif
  #if defined(__NR_rt_sigprocmask)
    LSS_INLINE int LSS_NAME(sigprocmask)(int how,
                                         const struct kernel_sigset_t *set,
                                         struct kernel_sigset_t *oldset) {
      return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
    }
  #endif
  #if defined(__NR_rt_sigtimedwait)
    LSS_INLINE int LSS_NAME(sigtimedwait)(const struct kernel_sigset_t *set,
                                          siginfo_t *info,
                                          const struct timespec *timeout) {
      return LSS_NAME(rt_sigtimedwait)(set, info, timeout, (KERNEL_NSIG+7)/8);
    }
  #endif
  #if defined(__NR_wait4)
    LSS_INLINE _syscall4(pid_t, wait4,            pid_t, p,
                         int*,                    s, int,       o,
                        struct kernel_rusage*,     r)
  #endif
  #if defined(__NR_openat)
    LSS_INLINE _syscall4(int, openat, int, d, const char *, p, int, f, int, m)
  #endif
  #if defined(__NR_unlinkat)
    LSS_INLINE _syscall3(int, unlinkat, int, d, const char *, p, int, f)
  #endif
  #if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || \
      (defined(__s390__) && !defined(__s390x__))
    #define __NR__getresgid32 __NR_getresgid32
    #define __NR__getresuid32 __NR_getresuid32
    #define __NR__setfsgid32  __NR_setfsgid32
    #define __NR__setfsuid32  __NR_setfsuid32
    #define __NR__setresgid32 __NR_setresgid32
    #define __NR__setresuid32 __NR_setresuid32
#if defined(__ARM_EABI__)
    LSS_INLINE _syscall2(int,   ugetrlimit,        int,          r,
                        struct kernel_rlimit*, l)
#endif
    LSS_INLINE _syscall3(int,     _getresgid32,    gid_t *,      r,
                         gid_t *,            e,    gid_t *,      s)
    LSS_INLINE _syscall3(int,     _getresuid32,    uid_t *,      r,
                         uid_t *,            e,    uid_t *,      s)
    LSS_INLINE _syscall1(int,     _setfsgid32,     gid_t,        f)
    LSS_INLINE _syscall1(int,     _setfsuid32,     uid_t,        f)
    LSS_INLINE _syscall3(int,     _setresgid32,    gid_t,        r,
                         gid_t,              e,    gid_t,        s)
    LSS_INLINE _syscall3(int,     _setresuid32,    uid_t,        r,
                         uid_t,              e,    uid_t,        s)

    LSS_INLINE int LSS_NAME(getresgid32)(gid_t *rgid,
                                         gid_t *egid,
                                         gid_t *sgid) {
      int rc;
      if ((rc = LSS_NAME(_getresgid32)(rgid, egid, sgid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((rgid == NULL) || (egid == NULL) || (sgid == NULL)) {
          return EFAULT;
        }
        // Clear the high bits first, since getresgid only sets 16 bits
        *rgid = *egid = *sgid = 0;
        rc = LSS_NAME(getresgid)(rgid, egid, sgid);
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(getresuid32)(uid_t *ruid,
                                         uid_t *euid,
                                         uid_t *suid) {
      int rc;
      if ((rc = LSS_NAME(_getresuid32)(ruid, euid, suid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((ruid == NULL) || (euid == NULL) || (suid == NULL)) {
          return EFAULT;
        }
        // Clear the high bits first, since getresuid only sets 16 bits
        *ruid = *euid = *suid = 0;
        rc = LSS_NAME(getresuid)(ruid, euid, suid);
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(setfsgid32)(gid_t gid) {
      int rc;
      if ((rc = LSS_NAME(_setfsgid32)(gid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((unsigned int)gid & ~0xFFFFu) {
          rc = EINVAL;
        } else {
          rc = LSS_NAME(setfsgid)(gid);
        }
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(setfsuid32)(uid_t uid) {
      int rc;
      if ((rc = LSS_NAME(_setfsuid32)(uid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((unsigned int)uid & ~0xFFFFu) {
          rc = EINVAL;
        } else {
          rc = LSS_NAME(setfsuid)(uid);
        }
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(setresgid32)(gid_t rgid, gid_t egid, gid_t sgid) {
      int rc;
      if ((rc = LSS_NAME(_setresgid32)(rgid, egid, sgid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((unsigned int)rgid & ~0xFFFFu ||
            (unsigned int)egid & ~0xFFFFu ||
            (unsigned int)sgid & ~0xFFFFu) {
          rc = EINVAL;
        } else {
          rc = LSS_NAME(setresgid)(rgid, egid, sgid);
        }
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(setresuid32)(uid_t ruid, uid_t euid, uid_t suid) {
      int rc;
      if ((rc = LSS_NAME(_setresuid32)(ruid, euid, suid)) < 0 &&
          LSS_ERRNO == ENOSYS) {
        if ((unsigned int)ruid & ~0xFFFFu ||
            (unsigned int)euid & ~0xFFFFu ||
            (unsigned int)suid & ~0xFFFFu) {
          rc = EINVAL;
        } else {
          rc = LSS_NAME(setresuid)(ruid, euid, suid);
        }
      }
      return rc;
    }
  #endif
  LSS_INLINE int LSS_NAME(sigemptyset)(struct kernel_sigset_t *set) {
    memset(&set->sig, 0, sizeof(set->sig));
    return 0;
  }

  LSS_INLINE int LSS_NAME(sigfillset)(struct kernel_sigset_t *set) {
    memset(&set->sig, -1, sizeof(set->sig));
    return 0;
  }

  LSS_INLINE int LSS_NAME(sigaddset)(struct kernel_sigset_t *set,
                                     int signum) {
    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
      LSS_ERRNO = EINVAL;
      return -1;
    } else {
      set->sig[(signum - 1)/(8*sizeof(set->sig[0]))]
          |= 1UL << ((signum - 1) % (8*sizeof(set->sig[0])));
      return 0;
    }
  }

  LSS_INLINE int LSS_NAME(sigdelset)(struct kernel_sigset_t *set,
                                        int signum) {
    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
      LSS_ERRNO = EINVAL;
      return -1;
    } else {
      set->sig[(signum - 1)/(8*sizeof(set->sig[0]))]
          &= ~(1UL << ((signum - 1) % (8*sizeof(set->sig[0]))));
      return 0;
    }
  }

  LSS_INLINE int LSS_NAME(sigismember)(struct kernel_sigset_t *set,
                                          int signum) {
    if (signum < 1 || signum > (int)(8*sizeof(set->sig))) {
      LSS_ERRNO = EINVAL;
      return -1;
    } else {
      return !!(set->sig[(signum - 1)/(8*sizeof(set->sig[0]))] &
                (1UL << ((signum - 1) % (8*sizeof(set->sig[0])))));
    }
  }
  #if defined(__i386__) ||                                                    \
      defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
      defined(__PPC__) ||                                                     \
     (defined(__s390__) && !defined(__s390x__))
    #define __NR__sigaction   __NR_sigaction
    #define __NR__sigpending  __NR_sigpending
    #define __NR__sigsuspend  __NR_sigsuspend
    #define __NR__socketcall  __NR_socketcall
    LSS_INLINE _syscall2(int, fstat64,             int, f,
                         struct kernel_stat64 *, b)
    LSS_INLINE _syscall5(int, _llseek,     uint, fd,
                         unsigned long, hi, unsigned long, lo,
                         loff_t *, res, uint, wh)
#if defined(__s390__) && !defined(__s390x__)
    /* On s390, mmap2() arguments are passed in memory. */
    LSS_INLINE void* LSS_NAME(_mmap2)(void *s, size_t l, int p, int f, int d,
                                      off_t o) {
      unsigned long buf[6] = { (unsigned long) s, (unsigned long) l,
                               (unsigned long) p, (unsigned long) f,
                               (unsigned long) d, (unsigned long) o };
      LSS_REG(2, buf);
      LSS_BODY(void*, mmap2, "0"(__r2));
    }
#else
    #define __NR__mmap2 __NR_mmap2
    LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                         size_t,                   l, int,               p,
                         int,                      f, int,               d,
                         off_t,                    o)
#endif
    LSS_INLINE _syscall3(int,   _sigaction,        int,   s,
                         const struct kernel_old_sigaction*,  a,
                         struct kernel_old_sigaction*,        o)
    LSS_INLINE _syscall1(int,   _sigpending, unsigned long*, s)
    #ifdef __PPC__
    LSS_INLINE _syscall1(int, _sigsuspend,         unsigned long, s)
    #else
    LSS_INLINE _syscall3(int, _sigsuspend,         const void*, a,
                         int,                      b,
                         unsigned long,            s)
    #endif
    LSS_INLINE _syscall2(int, stat64,              const char *, p,
                         struct kernel_stat64 *, b)

    LSS_INLINE int LSS_NAME(sigaction)(int signum,
                                       const struct kernel_sigaction *act,
                                       struct kernel_sigaction *oldact) {
      int old_errno = LSS_ERRNO;
      int rc;
      struct kernel_sigaction a;
      if (act != NULL) {
        a             = *act;
        #ifdef __i386__
        /* On i386, the kernel requires us to always set our own
         * SA_RESTORER when using realtime signals. Otherwise, it does not
         * know how to return from a signal handler. This function must have
         * a "magic" signature that the "gdb" (and maybe the kernel?) can
         * recognize.
         * Apparently, a SA_RESTORER is implicitly set by the kernel, when
         * using non-realtime signals.
         *
         * TODO: Test whether ARM needs a restorer
         */
        if (!(a.sa_flags & SA_RESTORER)) {
          a.sa_flags   |= SA_RESTORER;
          a.sa_restorer = (a.sa_flags & SA_SIGINFO)
                          ? LSS_NAME(restore_rt)() : LSS_NAME(restore)();
        }
        #endif
      }
      rc = LSS_NAME(rt_sigaction)(signum, act ? &a : act, oldact,
                                  (KERNEL_NSIG+7)/8);
      if (rc < 0 && LSS_ERRNO == ENOSYS) {
        struct kernel_old_sigaction oa, ooa, *ptr_a = &oa, *ptr_oa = &ooa;
        if (!act) {
          ptr_a            = NULL;
        } else {
          oa.sa_handler_   = act->sa_handler_;
          memcpy(&oa.sa_mask, &act->sa_mask, sizeof(oa.sa_mask));
          #ifndef __mips__
          oa.sa_restorer   = act->sa_restorer;
          #endif
          oa.sa_flags      = act->sa_flags;
        }
        if (!oldact) {
          ptr_oa           = NULL;
        }
        LSS_ERRNO = old_errno;
        rc = LSS_NAME(_sigaction)(signum, ptr_a, ptr_oa);
        if (rc == 0 && oldact) {
          if (act) {
            memcpy(oldact, act, sizeof(*act));
          } else {
            memset(oldact, 0, sizeof(*oldact));
          }
          oldact->sa_handler_    = ptr_oa->sa_handler_;
          oldact->sa_flags       = ptr_oa->sa_flags;
          memcpy(&oldact->sa_mask, &ptr_oa->sa_mask, sizeof(ptr_oa->sa_mask));
          #ifndef __mips__
          oldact->sa_restorer    = ptr_oa->sa_restorer;
          #endif
        }
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(sigpending)(struct kernel_sigset_t *set) {
      int old_errno = LSS_ERRNO;
      int rc = LSS_NAME(rt_sigpending)(set, (KERNEL_NSIG+7)/8);
      if (rc < 0 && LSS_ERRNO == ENOSYS) {
        LSS_ERRNO = old_errno;
        LSS_NAME(sigemptyset)(set);
        rc = LSS_NAME(_sigpending)(&set->sig[0]);
      }
      return rc;
    }

    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
      int olderrno = LSS_ERRNO;
      int rc = LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
      if (rc < 0 && LSS_ERRNO == ENOSYS) {
        LSS_ERRNO = olderrno;
        rc = LSS_NAME(_sigsuspend)(
        #ifndef __PPC__
                                   set, 0,
        #endif
                                   set->sig[0]);
      }
      return rc;
    }
  #endif
  #if defined(__i386__) ||                                                    \
      defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
      defined(__PPC__) ||                                                     \
     (defined(__s390__) && !defined(__s390x__))
    /* On these architectures, implement mmap() with mmap2(). */
    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
                                    int64_t o) {
      if (o % 4096) {
        LSS_ERRNO = EINVAL;
        return (void *) -1;
      }
      return LSS_NAME(_mmap2)(s, l, p, f, d, (o / 4096));
    }
  #elif defined(__s390x__)
    /* On s390x, mmap() arguments are passed in memory. */
    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
                                    int64_t o) {
      unsigned long buf[6] = { (unsigned long) s, (unsigned long) l,
                               (unsigned long) p, (unsigned long) f,
                               (unsigned long) d, (unsigned long) o };
      LSS_REG(2, buf);
      LSS_BODY(void*, mmap, "0"(__r2));
    }
  #elif defined(__x86_64__)
    /* Need to make sure __off64_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
                                    int64_t o) {
      LSS_BODY(6, void*, mmap, LSS_SYSCALL_ARG(s), LSS_SYSCALL_ARG(l),
                               LSS_SYSCALL_ARG(p), LSS_SYSCALL_ARG(f),
                               LSS_SYSCALL_ARG(d), (uint64_t)(o));
    }
  #else
    /* Remaining 64-bit architectures. */
    LSS_INLINE _syscall6(void*, mmap, void*, addr, size_t, length, int, prot,
                         int, flags, int, fd, int64_t, offset)
  #endif
  #if defined(__PPC__)
    #undef LSS_SC_LOADARGS_0
    #define LSS_SC_LOADARGS_0(dummy...)
    #undef LSS_SC_LOADARGS_1
    #define LSS_SC_LOADARGS_1(arg1)                                           \
        __sc_4  = (unsigned long) (arg1)
    #undef LSS_SC_LOADARGS_2
    #define LSS_SC_LOADARGS_2(arg1, arg2)                                     \
        LSS_SC_LOADARGS_1(arg1);                                              \
        __sc_5  = (unsigned long) (arg2)
    #undef LSS_SC_LOADARGS_3
    #define LSS_SC_LOADARGS_3(arg1, arg2, arg3)                               \
        LSS_SC_LOADARGS_2(arg1, arg2);                                        \
        __sc_6  = (unsigned long) (arg3)
    #undef LSS_SC_LOADARGS_4
    #define LSS_SC_LOADARGS_4(arg1, arg2, arg3, arg4)                         \
        LSS_SC_LOADARGS_3(arg1, arg2, arg3);                                  \
        __sc_7  = (unsigned long) (arg4)
    #undef LSS_SC_LOADARGS_5
    #define LSS_SC_LOADARGS_5(arg1, arg2, arg3, arg4, arg5)                   \
        LSS_SC_LOADARGS_4(arg1, arg2, arg3, arg4);                            \
        __sc_8  = (unsigned long) (arg5)
    #undef LSS_SC_BODY
    #define LSS_SC_BODY(nr, type, opt, args...)                               \
        long __sc_ret, __sc_err;                                              \
        {                                                                     \
          register unsigned long __sc_0 __asm__ ("r0") = __NR_socketcall;     \
          register unsigned long __sc_3 __asm__ ("r3") = opt;                 \
          register unsigned long __sc_4 __asm__ ("r4");                       \
          register unsigned long __sc_5 __asm__ ("r5");                       \
          register unsigned long __sc_6 __asm__ ("r6");                       \
          register unsigned long __sc_7 __asm__ ("r7");                       \
          register unsigned long __sc_8 __asm__ ("r8");                       \
          LSS_SC_LOADARGS_##nr(args);                                         \
          __asm__ __volatile__                                                \
              ("stwu 1, -48(1)\n\t"                                           \
               "stw 4, 20(1)\n\t"                                             \
               "stw 5, 24(1)\n\t"                                             \
               "stw 6, 28(1)\n\t"                                             \
               "stw 7, 32(1)\n\t"                                             \
               "stw 8, 36(1)\n\t"                                             \
               "addi 4, 1, 20\n\t"                                            \
               "sc\n\t"                                                       \
               "mfcr %0"                                                      \
                 : "=&r" (__sc_0),                                            \
                   "=&r" (__sc_3), "=&r" (__sc_4),                            \
                   "=&r" (__sc_5), "=&r" (__sc_6),                            \
                   "=&r" (__sc_7), "=&r" (__sc_8)                             \
                 : LSS_ASMINPUT_##nr                                          \
                 : "cr0", "ctr", "memory");                                   \
          __sc_ret = __sc_3;                                                  \
          __sc_err = __sc_0;                                                  \
        }                                                                     \
        LSS_RETURN(type, __sc_ret, __sc_err)

    LSS_INLINE ssize_t LSS_NAME(recvmsg)(int s,struct kernel_msghdr *msg,
                                         int flags){
      LSS_SC_BODY(3, ssize_t, 17, s, msg, flags);
    }

    LSS_INLINE ssize_t LSS_NAME(sendmsg)(int s,
                                         const struct kernel_msghdr *msg,
                                         int flags) {
      LSS_SC_BODY(3, ssize_t, 16, s, msg, flags);
    }

    // TODO(csilvers): why is this ifdef'ed out?
#if 0
    LSS_INLINE ssize_t LSS_NAME(sendto)(int s, const void *buf, size_t len,
                                        int flags,
                                        const struct kernel_sockaddr *to,
                                        unsigned int tolen) {
      LSS_BODY(6, ssize_t, 11, s, buf, len, flags, to, tolen);
    }
#endif

    LSS_INLINE int LSS_NAME(shutdown)(int s, int how) {
      LSS_SC_BODY(2, int, 13, s, how);
    }

    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {
      LSS_SC_BODY(3, int, 1, domain, type, protocol);
    }

    LSS_INLINE int LSS_NAME(socketpair)(int d, int type, int protocol,
                                        int sv[2]) {
      LSS_SC_BODY(4, int, 8, d, type, protocol, sv);
    }
  #endif
  #if defined(__ARM_EABI__) || defined (__aarch64__)
    LSS_INLINE _syscall3(ssize_t, recvmsg, int, s, struct kernel_msghdr*, msg,
                         int, flags)
    LSS_INLINE _syscall3(ssize_t, sendmsg, int, s, const struct kernel_msghdr*,
                         msg, int, flags)
    LSS_INLINE _syscall6(ssize_t, sendto, int, s, const void*, buf, size_t,len,
                         int, flags, const struct kernel_sockaddr*, to,
                         unsigned int, tolen)
    LSS_INLINE _syscall2(int, shutdown, int, s, int, how)
    LSS_INLINE _syscall3(int, socket, int, domain, int, type, int, protocol)
    LSS_INLINE _syscall4(int, socketpair, int, d, int, type, int, protocol,
                         int*, sv)
  #endif
  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                  \
      defined(__s390__)
    #define __NR__socketcall  __NR_socketcall
    LSS_INLINE _syscall2(int,      _socketcall,    int,   c,
                         va_list,                  a)
    LSS_INLINE int LSS_NAME(socketcall)(int op, ...) {
      int rc;
      va_list ap;
      va_start(ap, op);
      rc = LSS_NAME(_socketcall)(op, ap);
      va_end(ap);
      return rc;
    }

    LSS_INLINE ssize_t LSS_NAME(recvmsg)(int s,struct kernel_msghdr *msg,
                                         int flags){
      return (ssize_t)LSS_NAME(socketcall)(17, s, msg, flags);
    }

    LSS_INLINE ssize_t LSS_NAME(sendmsg)(int s,
                                         const struct kernel_msghdr *msg,
                                         int flags) {
      return (ssize_t)LSS_NAME(socketcall)(16, s, msg, flags);
    }

    LSS_INLINE ssize_t LSS_NAME(sendto)(int s, const void *buf, size_t len,
                                        int flags,
                                        const struct kernel_sockaddr *to,
                                        unsigned int tolen) {
      return (ssize_t)LSS_NAME(socketcall)(11, s, buf, len, flags, to, tolen);
    }

    LSS_INLINE int LSS_NAME(shutdown)(int s, int how) {
      return LSS_NAME(socketcall)(13, s, how);
    }

    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {
      return LSS_NAME(socketcall)(1, domain, type, protocol);
    }

    LSS_INLINE int LSS_NAME(socketpair)(int d, int type, int protocol,
                                        int sv[2]) {
      return LSS_NAME(socketcall)(8, d, type, protocol, sv);
    }
  #endif
  #if defined(__NR_fstatat64)
    LSS_INLINE _syscall4(int,   fstatat64,        int,   d,
                         const char *,      p,
                         struct kernel_stat64 *,   b,    int,   f)
  #endif
  #if defined(__NR_waitpid)
    // waitpid is polyfilled below when not available.
    LSS_INLINE _syscall3(pid_t, waitpid,          pid_t, p,
                         int*,              s,    int,   o)
  #endif
  #if defined(__mips__)
    /* sys_pipe() on MIPS has non-standard calling conventions, as it returns
     * both file handles through CPU registers.
     */
    LSS_INLINE int LSS_NAME(pipe)(int *p) {
      register unsigned long __v0 __asm__("$2") = __NR_pipe;
      register unsigned long __v1 __asm__("$3");
      register unsigned long __r7 __asm__("$7");
      __asm__ __volatile__ ("syscall\n"
                            : "=r"(__v0), "=r"(__v1), "=r" (__r7)
                            : "0"(__v0)
                            : "$8", "$9", "$10", "$11", "$12",
                              "$13", "$14", "$15", "$24", "$25", "memory");
      if (__r7) {
        unsigned long __errnovalue = __v0;
        LSS_ERRNO = __errnovalue;
        return -1;
      } else {
        p[0] = __v0;
        p[1] = __v1;
        return 0;
      }
    }
  #elif defined(__NR_pipe)
    // pipe is polyfilled below when not available.
    LSS_INLINE _syscall1(int,     pipe,           int *, p)
  #endif
  #if defined(__NR_pipe2)
    LSS_INLINE _syscall2(int, pipe2, int *, pipefd, int, flags)
  #endif
  /* TODO(csilvers): see if ppc can/should support this as well              */
  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
      defined(__ARM_EABI__) ||                                                \
     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64) ||                   \
     (defined(__s390__) && !defined(__s390x__))
    #define __NR__statfs64  __NR_statfs64
    #define __NR__fstatfs64 __NR_fstatfs64
    LSS_INLINE _syscall3(int, _statfs64,     const char*, p,
                         size_t, s,struct kernel_statfs64*, b)
    LSS_INLINE _syscall3(int, _fstatfs64,          int,   f,
                         size_t, s,struct kernel_statfs64*, b)
    LSS_INLINE int LSS_NAME(statfs64)(const char *p,
                                     struct kernel_statfs64 *b) {
      return LSS_NAME(_statfs64)(p, sizeof(*b), b);
    }
    LSS_INLINE int LSS_NAME(fstatfs64)(int f,struct kernel_statfs64 *b) {
      return LSS_NAME(_fstatfs64)(f, sizeof(*b), b);
    }
  #endif

  LSS_INLINE int LSS_NAME(execv)(const char *path, const char *const argv[]) {
    extern char **environ;
    return LSS_NAME(execve)(path, argv, (const char *const *)environ);
  }

  LSS_INLINE pid_t LSS_NAME(gettid)(void) {
    pid_t tid = LSS_NAME(_gettid)();
    if (tid != -1) {
      return tid;
    }
    return LSS_NAME(getpid)();
  }

  LSS_INLINE void *LSS_NAME(mremap)(void *old_address, size_t old_size,
                                    size_t new_size, int flags, ...) {
    va_list ap;
    void *new_address, *rc;
    va_start(ap, flags);
    new_address = va_arg(ap, void *);
    rc = LSS_NAME(_mremap)(old_address, old_size, new_size,
                           flags, new_address);
    va_end(ap);
    return rc;
  }

  LSS_INLINE int LSS_NAME(ptrace_detach)(pid_t pid) {
    /* PTRACE_DETACH can sometimes forget to wake up the tracee and it
     * then sends job control signals to the real parent, rather than to
     * the tracer. We reduce the risk of this happening by starting a
     * whole new time slice, and then quickly sending a SIGCONT signal
     * right after detaching from the tracee.
     *
     * We use tkill to ensure that we only issue a wakeup for the thread being
     * detached.  Large multi threaded apps can take a long time in the kernel
     * processing SIGCONT.
     */
    int rc, err;
    LSS_NAME(sched_yield)();
    rc = LSS_NAME(ptrace)(PTRACE_DETACH, pid, (void *)0, (void *)0);
    err = LSS_ERRNO;
    LSS_NAME(tkill)(pid, SIGCONT);
    /* Old systems don't have tkill */
    if (LSS_ERRNO == ENOSYS)
      LSS_NAME(kill)(pid, SIGCONT);
    LSS_ERRNO = err;
    return rc;
  }

  LSS_INLINE int LSS_NAME(raise)(int sig) {
    return LSS_NAME(kill)(LSS_NAME(getpid)(), sig);
  }

  LSS_INLINE int LSS_NAME(setpgrp)(void) {
    return LSS_NAME(setpgid)(0, 0);
  }

  #if defined(__x86_64__)
    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
    LSS_INLINE ssize_t LSS_NAME(pread64)(int f, void *b, size_t c, loff_t o) {
      LSS_BODY(4, ssize_t, pread64, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(b),
                                    LSS_SYSCALL_ARG(c), (uint64_t)(o));
    }

    LSS_INLINE ssize_t LSS_NAME(pwrite64)(int f, const void *b, size_t c,
                                          loff_t o) {
      LSS_BODY(4, ssize_t, pwrite64, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(b),
                                     LSS_SYSCALL_ARG(c), (uint64_t)(o));
    }

    LSS_INLINE int LSS_NAME(readahead)(int f, loff_t o, unsigned c) {
      LSS_BODY(3, int, readahead, LSS_SYSCALL_ARG(f), (uint64_t)(o),
                                  LSS_SYSCALL_ARG(c));
    }
  #elif defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI64
    LSS_INLINE _syscall4(ssize_t, pread64,        int,         f,
                         void *,         b, size_t,   c,
                         loff_t,         o)
    LSS_INLINE _syscall4(ssize_t, pwrite64,       int,         f,
                         const void *,   b, size_t,   c,
                         loff_t,         o)
    LSS_INLINE _syscall3(int,     readahead,      int,         f,
                         loff_t,         o, unsigned, c)
  #else
    #define __NR__pread64   __NR_pread64
    #define __NR__pwrite64  __NR_pwrite64
    #define __NR__readahead __NR_readahead
    #if defined(__ARM_EABI__) || defined(__mips__)
      /* On ARM and MIPS, a 64-bit parameter has to be in an even-odd register
       * pair. Hence these calls ignore their fourth argument (r3) so that their
       * fifth and sixth make such a pair (r4,r5).
       */
      #define LSS_LLARG_PAD 0,
      LSS_INLINE _syscall6(ssize_t, _pread64,        int,         f,
                           void *,         b, size_t, c,
                           unsigned, skip, unsigned, o1, unsigned, o2)
      LSS_INLINE _syscall6(ssize_t, _pwrite64,       int,         f,
                           const void *,   b, size_t, c,
                           unsigned, skip, unsigned, o1, unsigned, o2)
      LSS_INLINE _syscall5(int, _readahead,          int,         f,
                           unsigned,     skip,
                           unsigned,       o1, unsigned, o2, size_t, c)
    #else
      #define LSS_LLARG_PAD
      LSS_INLINE _syscall5(ssize_t, _pread64,        int,         f,
                           void *,         b, size_t, c, unsigned, o1,
                           unsigned, o2)
      LSS_INLINE _syscall5(ssize_t, _pwrite64,       int,         f,
                           const void *,   b, size_t, c, unsigned, o1,
                           long, o2)
      LSS_INLINE _syscall4(int, _readahead,          int,         f,
                           unsigned,       o1, unsigned, o2, size_t, c)
    #endif
    /* We force 64bit-wide parameters onto the stack, then access each
     * 32-bit component individually. This guarantees that we build the
     * correct parameters independent of the native byte-order of the
     * underlying architecture.
     */
    LSS_INLINE ssize_t LSS_NAME(pread64)(int fd, void *buf, size_t count,
                                         loff_t off) {
      union { loff_t off; unsigned arg[2]; } o = { off };
      return LSS_NAME(_pread64)(fd, buf, count,
                                LSS_LLARG_PAD o.arg[0], o.arg[1]);
    }
    LSS_INLINE ssize_t LSS_NAME(pwrite64)(int fd, const void *buf,
                                          size_t count, loff_t off) {
      union { loff_t off; unsigned arg[2]; } o = { off };
      return LSS_NAME(_pwrite64)(fd, buf, count,
                                 LSS_LLARG_PAD o.arg[0], o.arg[1]);
    }
    LSS_INLINE int LSS_NAME(readahead)(int fd, loff_t off, int len) {
      union { loff_t off; unsigned arg[2]; } o = { off };
      return LSS_NAME(_readahead)(fd, LSS_LLARG_PAD o.arg[0], o.arg[1], len);
    }
  #endif
#endif

/*
 * Polyfills for deprecated syscalls.
 */

#if !defined(__NR_dup2)
  LSS_INLINE int LSS_NAME(dup2)(int s, int d) {
    return LSS_NAME(dup3)(s, d, 0);
  }
#endif

#if !defined(__NR_open)
  LSS_INLINE int LSS_NAME(open)(const char *pathname, int flags, int mode) {
    return LSS_NAME(openat)(AT_FDCWD, pathname, flags, mode);
  }
#endif

#if !defined(__NR_unlink)
  LSS_INLINE int LSS_NAME(unlink)(const char *pathname) {
    return LSS_NAME(unlinkat)(AT_FDCWD, pathname, 0);
  }
#endif

#if !defined(__NR_readlink)
  LSS_INLINE int LSS_NAME(readlink)(const char *pathname, char *buffer,
                                    size_t size) {
    return LSS_NAME(readlinkat)(AT_FDCWD, pathname, buffer, size);
  }
#endif

#if !defined(__NR_pipe)
  LSS_INLINE int LSS_NAME(pipe)(int *pipefd) {
    return LSS_NAME(pipe2)(pipefd, 0);
  }
#endif

#if !defined(__NR_poll)
  LSS_INLINE int LSS_NAME(poll)(struct kernel_pollfd *fds, unsigned int nfds,
                                int timeout) {
   struct kernel_timespec timeout_ts;
   struct kernel_timespec *timeout_ts_p = NULL;

    if (timeout >= 0) {
      timeout_ts.tv_sec = timeout / 1000;
      timeout_ts.tv_nsec = (timeout % 1000) * 1000000;
      timeout_ts_p = &timeout_ts;
    }
    return LSS_NAME(ppoll)(fds, nfds, timeout_ts_p, NULL, 0);
  }
#endif

#if !defined(__NR_stat)
  LSS_INLINE int LSS_NAME(stat)(const char *pathname,
                                struct kernel_stat *buf) {
    return LSS_NAME(newfstatat)(AT_FDCWD, pathname, buf, 0);
  }
#endif

#if !defined(__NR_waitpid)
  LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options) {
    return LSS_NAME(wait4)(pid, status, options, 0);
  }
#endif

#if !defined(__NR_fork)
// TODO: define this in an arch-independant way instead of inlining the clone
//       syscall body.

# if defined(__aarch64__)
  LSS_INLINE pid_t LSS_NAME(fork)(void) {
    // No fork syscall on aarch64 - implement by means of the clone syscall.
    // Note that this does not reset glibc's cached view of the PID/TID, so
    // some glibc interfaces might go wrong in the forked subprocess.
    int flags = SIGCHLD;
    void *child_stack = NULL;
    void *parent_tidptr = NULL;
    void *newtls = NULL;
    void *child_tidptr = NULL;

    LSS_REG(0, flags);
    LSS_REG(1, child_stack);
    LSS_REG(2, parent_tidptr);
    LSS_REG(3, newtls);
    LSS_REG(4, child_tidptr);
    LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
             "r"(__r4));
  }
# elif defined(__x86_64__)
  LSS_INLINE pid_t LSS_NAME(fork)(void) {
    // Android disallows the fork syscall on x86_64 - implement by means of the
    // clone syscall as above for aarch64.
    int flags = SIGCHLD;
    void *child_stack = NULL;
    void *parent_tidptr = NULL;
    void *newtls = NULL;
    void *child_tidptr = NULL;

    LSS_BODY(5, pid_t, clone, LSS_SYSCALL_ARG(flags),
             LSS_SYSCALL_ARG(child_stack), LSS_SYSCALL_ARG(parent_tidptr),
             LSS_SYSCALL_ARG(newtls), LSS_SYSCALL_ARG(child_tidptr));
  }
# else
#  error missing fork polyfill for this architecture
# endif
#endif

/* These restore the original values of these macros saved by the
 * corresponding #pragma push_macro near the top of this file. */
#pragma pop_macro("stat64")
#pragma pop_macro("fstat64")
#pragma pop_macro("lstat64")
#pragma pop_macro("pread64")
#pragma pop_macro("pwrite64")
#pragma pop_macro("getdents64")

#if defined(__cplusplus) && !defined(SYS_CPLUSPLUS)
}
#endif

#endif
#endif

```

`app/src/main/jni/logging.h`:

```h
#pragma once

#include <android/log.h>

#define LOGV(...) (__android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__))
#define LOGI(...) (__android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__))
#define LOGW(...) (__android_log_print(ANDROID_LOG_WARN, TAG, __VA_ARGS__))
#define LOGE(...) (__android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__))

#ifdef NDEBUG
#define LOGD(...)
#else
#define LOGD(...) (__android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__))
#endif

```

`app/src/main/jni/vvb2060.c`:

```c
#include <jni.h>
#include <stdlib.h>
#include <pty.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <sys/system_properties.h>

#include "logging.h"
#include "linux_syscall_support.h"
#include "xposed-detector.h"
#include "openssl/sha.h"

#define TAG "MagiskDetector"

static int major = -1;
static int minor = -1;

static inline void sscanfx(const char *restrict s, const char *restrict fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vsscanf(s, fmt, ap);
    va_end(ap);
}

static inline void scan_mountinfo() {
    FILE *fp = NULL;
    char line[PATH_MAX];
    char mountinfo[] = "/proc/self/mountinfo";
    int fd = sys_open(mountinfo, O_RDONLY, 0);
    if (fd < 0) {
        LOGE("cannot open %s", mountinfo);
        return;
    }
    fp = fdopen(fd, "r");
    if (fp == NULL) {
        LOGE("cannot open %s", mountinfo);
        close(fd);
        return;
    }
    while (fgets(line, PATH_MAX - 1, fp) != NULL) {
        if (strstr(line, "/ /data ") != NULL) {
            sscanfx(line, "%*d %*d %d:%d", &major, &minor);
        }
    }
    fclose(fp);
    close(fd);
}

static inline int scan_maps() {
    FILE *fp = NULL;
    char line[PATH_MAX];
    char maps[] = "/proc/self/maps";
    int fd = sys_open(maps, O_RDONLY, 0);
    if (fd < 0) {
        LOGE("cannot open %s", maps);
        return -1;
    }
    fp = fdopen(fd, "r");
    if (fp == NULL) {
        LOGE("cannot open %s", maps);
        close(fd);
        return -1;
    }
    while (fgets(line, PATH_MAX - 1, fp) != NULL) {
        if (strchr(line, '/') == NULL) continue;
        if (strstr(line, " /system/") != NULL ||
            strstr(line, " /vendor/") != NULL ||
            strstr(line, " /product/") != NULL ||
            strstr(line, " /system_ext/") != NULL) {
            int f;
            int s;
            char p[PATH_MAX];
            sscanfx(line, "%*s %*s %*s %x:%x %*s %s", &f, &s, p);
            if (f == major && s == minor) {
                LOGW("Magisk module file %x:%x %s", f, s, p);
                return 1;
            }
        }
    }
    fclose(fp);
    close(fd);
    return 0;
}

#define ABS_SOCKET_LEN(sun) (sizeof(sa_family_t) + strlen((sun)->sun_path + 1) + 1)

static inline socklen_t setup_sockaddr(struct sockaddr_un *sun, const char *name) {
    memset(sun, 0, sizeof(*sun));
    sun->sun_family = AF_LOCAL;
    strcpy(sun->sun_path + 1, name);
    return ABS_SOCKET_LEN(sun);
}

static inline void rstrip(char *line) {
    char *path = line;
    if (line != NULL) {
        while (*path && *path != '\r' && *path != '\n') ++path;
        if (*path) *path = '\0';
    }
}

static inline int scan_unix() {
    FILE *fp = NULL;
    char line[PATH_MAX];
    char net[] = "/proc/net/unix";
    int fd = sys_open(net, O_RDONLY, 0);
    if (fd < 0) {
        LOGE("cannot open %s", net);
        if (android_get_device_api_level() >= __ANDROID_API_Q__) return -3;
        else return -1;
    }
    fp = fdopen(fd, "r");
    if (fp == NULL) {
        LOGE("cannot open %s", net);
        close(fd);
        return -1;
    }
    int count = 0;
    char last[PATH_MAX];
    struct sockaddr_un sun;
    while (fgets(line, PATH_MAX - 1, fp) != NULL) {
        if (strchr(line, '@') == NULL ||
            strchr(line, '.') != NULL ||
            strchr(line, '-') != NULL ||
            strchr(line, '_') != NULL) {
            continue;
        }
        char *name = line;
        while (*name != '@') name++;
        name++;
        rstrip(name);
        if (strchr(name, ':') != NULL) continue;
        if (strlen(name) > 32) continue;
        socklen_t len = setup_sockaddr(&sun, name);
        int fds = sys_socket(AF_LOCAL, SOCK_STREAM, 0);
        if (connect(fds, (struct sockaddr *) &sun, len) == 0) {
            close(fds);
            LOGW("%s connected", name);
            if (count >= 1 && strcmp(name, last) != 0) return -2;
            strcpy(last, name);
            count++;
        }
    }
    fclose(fp);
    close(fd);
    return count;
}

static inline int pts_open(char *slave_name, size_t slave_name_size) {
    int fd = sys_open("/dev/ptmx", O_RDWR, 0);
    if (fd == -1) goto error;
    if (ptsname_r(fd, slave_name, slave_name_size - 1)) goto error;
    slave_name[slave_name_size - 1] = '\0';
    if (grantpt(fd) == -1 || unlockpt(fd) == -1) goto error;
    return fd;
    error:
    close(fd);
    return -1;
}

static inline int test_ioctl() {
    char pts_slave[PATH_MAX];
    int fd = pts_open(pts_slave, sizeof(pts_slave));
    if (fd == -1) return -1;

    int re = -1;
    int fdm = sys_open(pts_slave, O_RDWR, 0);
    if (fdm != -1) {
        re = sys_ioctl(fdm, TIOCSTI, "vvb2060") == -1 ? errno : 0;
        close(fdm);
    }
    close(fd);
    LOGI("ioctl errno is %d", re);
    return re;
}

// NOLINTNEXTLINE
void __system_property_read_callback(const prop_info *pi,
                                     void (*callback)(void *cookie, const char *name,
                                                      const char *value, uint32_t serial),
                                     void *cookie) __attribute__((weak));

static void hash(uint8_t buffer[SHA512_DIGEST_LENGTH], const char *name, const char *value) {
    if (strncmp(name, "init.svc.", strlen("init.svc.")) == 0) {
        if (strcmp(value, "stopped") != 0 && strcmp(value, "running") != 0) return;
        LOGI("svc name %s", name);
        uint8_t out[SHA512_DIGEST_LENGTH];
        SHA512_CTX ctx;
        SHA512_Init(&ctx);
        SHA512_Update(&ctx, name, strlen(name));
        SHA512_Final(out, &ctx);
        for (int i = 0; i < SHA512_DIGEST_LENGTH; i++) {
            buffer[i] ^= out[i];
        }
    }
}

static void read_callback(void *cookie, const char *name, const char *value,
                          uint32_t serial __unused) {
    hash(cookie, name, value);
}

static void callback(const prop_info *info, void *cookie) {
    if (&__system_property_read_callback) {
        __system_property_read_callback(info, &read_callback, cookie);
    } else {
        char name[PROP_NAME_MAX];
        char value[PROP_VALUE_MAX];
        __system_property_read(info, name, value);
        hash(cookie, name, value);
    }
}

static jint su = -1;

__attribute__((__constructor__, __used__))
static void before_load() {
    char *path = getenv("PATH");
    char *p = strtok(path, ":");
    char supath[PATH_MAX];
    do {
        sprintf(supath, "%s/su", p);
        if (access(supath, F_OK) == 0) {
            LOGW("Found su at %s", supath);
            su = 0;
        }
    } while ((p = strtok(NULL, ":")) != NULL);
    scan_mountinfo();
}

static jint haveSu(JNIEnv *env __unused, jclass clazz __unused) {
    return su;
}

static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) {
    if (minor == -1 || major == -1) return -1;
    return scan_maps();
}

static jint findMagiskdSocket(JNIEnv *env __unused, jclass clazz __unused) {
    return scan_unix();
}

static jint testIoctl(JNIEnv *env __unused, jclass clazz __unused) {
    int re = test_ioctl();
    if (re > 0) {
        if (re == EACCES) return 1;
        else if (android_get_device_api_level() >= __ANDROID_API_O__) return 2;
        else return 0;
    }
    return re;
}

static jstring getPropsHash(JNIEnv *env, jclass clazz __unused) {
    uint8_t hash[SHA512_DIGEST_LENGTH] = {0};
    __system_property_foreach(&callback, &hash);
    char string[SHA512_CBLOCK + 1];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(string + (i * 2), "%02hhx", hash[i]);
    }
    string[SHA512_CBLOCK] = 0;
    return (*env)->NewStringUTF(env, string);
}

jint JNI_OnLoad(JavaVM *jvm, void *v __unused) {
    JNIEnv *env;
    jclass clazz;

    if ((*jvm)->GetEnv(jvm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }

    get_xposed_status(env, android_get_device_api_level());

    if ((clazz = (*env)->FindClass(env, "io/github/vvb2060/magiskdetector/Native")) == NULL) {
        return JNI_ERR;
    }

    JNINativeMethod methods[] = {
            {"haveSu",            "()I",                  haveSu},
            {"haveMagicMount",    "()I",                  haveMagicMount},
            {"findMagiskdSocket", "()I",                  findMagiskdSocket},
            {"testIoctl",         "()I",                  testIoctl},
            {"getPropsHash",      "()Ljava/lang/String;", getPropsHash},
    };

    if ((*env)->RegisterNatives(env, clazz, methods, 5) < 0) {
        return JNI_ERR;
    }

    return JNI_VERSION_1_6;
}

```

`app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tool="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent">

            <TextView
                android:id="@+id/textView"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />

        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView2"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cardView">

            <TextView
                android:id="@+id/textView2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView3"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cardView2">

            <TextView
                android:id="@+id/textView3"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView5"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cardView3">

            <TextView
                android:id="@+id/textView5"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView6"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cardView5">

            <TextView
                android:id="@+id/textView6"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cardView4"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginTop="16dp"
            android:layout_marginEnd="16dp"
            android:layout_marginBottom="16dp"
            android:visibility="gone"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cardView6"
            tool:visibility="visible">

            <TextView
                android:id="@+id/textView4"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_margin="8dp" />
        </androidx.cardview.widget.CardView>

    </androidx.constraintlayout.widget.ConstraintLayout>

</ScrollView>

```

`app/src/main/res/menu/menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/logcat"
        android:showAsAction="never"
        android:title="@string/save_log" />
</menu>

```

`app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<resources>
    <string name="app_name">Magisk检测应用</string>

    <string name="test1">检测PATH中是否存在su</string>
    <string name="test1_t">PATH中存在su</string>
    <string name="test1_f">PATH中不存在su</string>

    <string name="test2">检测是否有系统文件被Magisk模块修改</string>
    <string name="test2_0">未发现被Magisk模块修改的系统文件</string>
    <string name="test2_1">至少一个系统文件被Magisk模块修改</string>
    <string name="test2_d">检测出现意外</string>

    <string name="test3">检测Magisk的su进程数量</string>
    <string name="test3_0">未发现正在运行的su进程</string>
    <string name="test3_1">检测出现意外</string>
    <string name="test3_2">SELinux错误，请忽略此检测结果</string>
    <string name="test3_3">此检测方式不支持Android10及以上系统</string>
    <string name="test3_d">发现 %1$d 个正在运行的su进程</string>

    <string name="test4">检测Magisk Hide工作状态</string>
    <string name="test4_t">Magisk Hide未工作</string>
    <string name="test4_f">Magisk Hide工作正常</string>

    <string name="test5">检测SELinux政策是否被Magisk修改</string>
    <string name="test5_01">检测出现意外</string>
    <string name="test5_0">系统不支持此检测方式</string>
    <string name="test5_1">未发现修改痕迹</string>
    <string name="test5_2">SELinux政策已被修改</string>

    <string name="test6">检测init.rc是否被Magisk修改</string>
    <string name="test6_01">检测出现意外</string>
    <string name="test6_0">未发现修改痕迹</string>
    <string name="test6_1">init.rc已被Magisk修改</string>
    <string name="test6_2">需要重启才能完成检测</string>

    <string name="display">%1$s\n检测结果：%2$s</string>
    <string name="error">运行环境异常，系统被Root或app被修改</string>

    <string name="save_log">保存日志</string>
</resources>

```

`app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<resources>
    <string name="app_name">Magisk 檢查器</string>

    <string name="test1">檢查 PATH 中是否存在 su</string>
    <string name="test1_t">PATH 中存在 su</string>
    <string name="test1_f">PATH 中不存在 su</string>

    <string name="test2">檢查是否有系統檔案被 Magisk 模組修改</string>
    <string name="test2_0">未發現被 Magisk 模組修改的系统檔案</string>
    <string name="test2_1">至少一个系統檔案被 Magisk 模組修改</string>
    <string name="test2_d">檢查過程出現異常</string>

    <string name="test3">檢查 Magisk 的 su 進程數量</string>
    <string name="test3_0">未發現在運作的 su 進程</string>
    <string name="test3_1">檢查過程出現異常</string>
    <string name="test3_2">SELinux 錯誤，請忽略此結果</string>
    <string name="test3_3">此檢查方式不支援 Android10 及以上系统</string>
    <string name="test3_d">發現 %1$d 個正在運作的 su 進程</string>

    <string name="test4">檢查 Magisk Hide 執行狀態</string>
    <string name="test4_t">Magisk Hide 未執行</string>
    <string name="test4_f">Magisk Hide 執行正常</string>

    <string name="test5">檢查 SELinux 政策是否被 Magisk 修改</string>
    <string name="test5_01">檢查過程出現異常</string>
    <string name="test5_0">系统不支援此檢查方式</string>
    <string name="test5_1">未發現修改痕迹</string>
    <string name="test5_2">SELinux 政策已被修改</string>

    <string name="test6">檢查 init.rc 是否被 Magisk 修改</string>
    <string name="test6_01">檢查過程出現異常</string>
    <string name="test6_0">未發現修改痕迹</string>
    <string name="test6_1">init.rc 已被 Magisk 修改</string>
    <string name="test6_2">需要重啟才能完成檢查</string>

    <string name="display">%1$s\n檢查结果：%2$s</string>
    <string name="error">執行環境異常，系統被Root或應用程式被修改</string>

    <string name="save_log">儲存日誌</string>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">Magisk Detector</string>

    <string name="test1">Check if su file exists in PATH</string>
    <string name="test1_t">su file exists in PATH</string>
    <string name="test1_f">su file does not exist in PATH</string>

    <string name="test2">Check if the system file is modified by Magisk module</string>
    <string name="test2_0">No system file modified by Magisk module</string>
    <string name="test2_1">Magisk module modified at least one system file</string>
    <string name="test2_d">Unexpected</string>

    <string name="test3">Detect the number of Magisk su processes</string>
    <string name="test3_0">No running su process found</string>
    <string name="test3_1">Unexpected</string>
    <string name="test3_2">SElinux wrong, please ignore this result</string>
    <string name="test3_3">This detection method does not support Android10+</string>
    <string name="test3_d">Found %1$d running su processes</string>

    <string name="test4">Check Magisk Hide working status</string>
    <string name="test4_t">Magisk Hide is not working</string>
    <string name="test4_f">Magisk Hide works fine</string>

    <string name="test5">Check if SELinux policy is modified by Magisk</string>
    <string name="test5_01">Unexpected</string>
    <string name="test5_0">System does not support this detection method</string>
    <string name="test5_1">No trace of modification found</string>
    <string name="test5_2">SELinux policy has been modified</string>

    <string name="test6">Check if init.rc is modified by Magisk</string>
    <string name="test6_01">Unexpected</string>
    <string name="test6_0">No trace of modification found</string>
    <string name="test6_1">init.rc has been modified by Magisk</string>
    <string name="test6_2">Need to restart to complete detection</string>

    <string name="display">%1$s\nTest results: %2$s</string>
    <string name="error">App been hacked</string>

    <string name="save_log">Save log</string>
</resources>

```

`build.gradle`:

```gradle
buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.0-alpha11'
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https://services.gradle.org/distributions/gradle-6.6.1-bin.zip

```

`gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
include ':app'
rootProject.name = "Magisk Detector"

```