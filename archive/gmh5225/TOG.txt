Project Path: arc_gmh5225_TOG_04v8acxd

Source Tree:

```txt
arc_gmh5225_TOG_04v8acxd
├── LICENSE.txt
├── Preview.png
├── README.md
├── TOG.App
│   ├── Definitions
│   │   ├── NamespaceDefinition.cs
│   │   └── OffsetDefinition.cs
│   ├── Definitions.cs
│   ├── Models
│   │   ├── ConsistencyInfo.cs
│   │   └── ConsistencyInfoEntry.cs
│   ├── Program.cs
│   ├── TOG.App.csproj
│   ├── Templates
│   │   └── CppTemplate.cs
│   ├── Unispect
│   │   ├── Classes
│   │   │   ├── BasicMemory.cs
│   │   │   ├── BoolToVisConverter.cs
│   │   │   ├── BooleanToVisibilityConverter.cs
│   │   │   ├── CacheStore.cs
│   │   │   ├── Inspector.cs
│   │   │   ├── Log.cs
│   │   │   ├── MemoryProxy.cs
│   │   │   ├── ModuleProxy.cs
│   │   │   ├── Serializer.cs
│   │   │   ├── Settings.cs
│   │   │   ├── Structs
│   │   │   │   ├── FieldDefinition.cs
│   │   │   │   ├── Generics.cs
│   │   │   │   ├── InternalHashTable.cs
│   │   │   │   ├── MonoType.cs
│   │   │   │   └── TypeDefinition.cs
│   │   │   ├── UnispectPluginAttribute.cs
│   │   │   ├── Utilities.cs
│   │   │   └── Wrappers
│   │   │       ├── FieldDefWrapper.cs
│   │   │       └── TypeDefWrapper.cs
│   │   └── Enums
│   │       ├── Offsets.cs
│   │       ├── TypeEnum.cs
│   │       └── UnknownPrefix.cs
│   └── Usings.cs
├── TOG.Common
│   ├── Exceptions
│   │   └── LastWin32Exception.cs
│   ├── Helpers
│   │   ├── Logger.cs
│   │   └── ProcessHelper.cs
│   ├── TOG.Common.csproj
│   ├── Templates
│   │   └── BaseTemplate.cs
│   ├── Tools.cs
│   └── Usings.cs
└── TOG.sln

```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img src="Preview.png" style="height:350px;"/>
</p>

# TOG : Tarkov Offsets Generator
(Very) simple Escape From Tarkov offsets generator using Unispect and made with .NET 6.
Just an old project I decided to publish here on GitHub, nothing special you are warned :)

# How to compile
Use Visual Studio 2022, select "Release" and compile. Compiled files goes in root `bin` directory.

# How to use
Simply run the game without the anticheat (battleyent does the trick but shouldn't be required), then run the application.
Ouput files goes in the root `Output` directory.

# Output exemple
```
#pragma once
#include "stdafx.h"

/*
	Generated using Deathstroke's TGO (https://github.com/patrickcjk/tog)
	At 12/09/2022 21:46:46
	Game version 0.12.12.31.19428
*/

namespace offsets
{
	// [Class] EFT.GameWorld
	namespace game_world
	{
		constexpr auto size = 0x188;
		constexpr auto max_use_size = 0x110; // 0x108 + sizeof(-.GClass0621<Int32, Throwable>) = 0x108 + 0x8

		constexpr auto loot_list = 0x70; // [70] LootList : System.Collections.Generic.List<GInterface1586>
		constexpr auto registered_players = 0x90; // [90] RegisteredPlayers : System.Collections.Generic.List<Player>
		constexpr auto exfil_controller = 0x18; // [18] gClass0C21_0x18 : -.GClass0C21
		constexpr auto grenades = 0x108; // [108] Grenades : -.GClass0621<Int32, Throwable>
	}

	// [Class] EFT.Player
	namespace player
	{
		constexpr auto size = 0x808;
		constexpr auto max_use_size = 0x808; // 0x807 + sizeof(Boolean) = 0x807 + 0x1

		constexpr auto action = 0x18; // [18] action_0x18 : System.Action<Single, Single, Int32>
		constexpr auto movement_context = 0x40; // [40] gClass10BD_0x40 : -.GClass10BD
		constexpr auto profile = 0x4F0; // [4F0] profile_0x4F0 : EFT.Profile
		constexpr auto pwa = 0x198; // [198] proceduralWeaponAnimation_0x198 : EFT.Animations.ProceduralWeaponAnimation
		constexpr auto body = 0xA8; // [A8] _playerBody : EFT.PlayerBody
		constexpr auto health_controller = 0x528; // [528] _healthController : -.GInterface80F7
		constexpr auto physical = 0x500; // [500] Physical : -.GClass05B8
		constexpr auto is_local_player = 0x807; // [807] boolean_0x807 : Boolean
		constexpr auto hands_controller = 0x540; // [540] _handsController : -.Player.AbstractHandsController
		constexpr auto PlayerBones = 0x588; // [588] PlayerBones : -.PlayerBones

		// [Class] -.PlayerBones
		namespace _player_bones
		{
			constexpr auto size = 0x208;
			constexpr auto max_use_size = 0x150; // 0x148 + sizeof(EFT.BifacialTransform) = 0x148 + 0x8

			constexpr auto fireport = 0x148; // [148] Fireport : EFT.BifacialTransform
		}

		// [Class] -.GClass05B8
		namespace _physical
		{
			constexpr auto size = 0x120;
			constexpr auto max_use_size = 0x40; // 0x38 + sizeof(-.GClass05B6) = 0x38 + 0x8

			constexpr auto stamina = 0x38; // [38] Stamina : -.GClass05B6

			// [Class] -.GClass05B6
			namespace _stamina
			{
				constexpr auto size = 0x60;
				constexpr auto max_use_size = 0x4C; // 0x48 + sizeof(Single) = 0x48 + 0x4

				constexpr auto current = 0x48; // [48] Current : Single
			}
		}

		// [Class] -.AIFirearmController
		namespace _hands_controller
		{
			constexpr auto size = 0x170;
			constexpr auto max_use_size = 0xD0; // 0xC8 + sizeof(EFT.BifacialTransform) = 0xC8 + 0x8

			constexpr auto fireport = 0xC8; // [C8] Fireport : EFT.BifacialTransform

			// [Class] EFT.BifacialTransform
			namespace _fireport
			{
				constexpr auto size = 0xC8;
				constexpr auto max_use_size = 0x18; // 0x10 + sizeof(UnityEngine.Transform) = 0x10 + 0x8

				constexpr auto Original = 0x10; // [10] Original : UnityEngine.Transform
			}
		}
	}

	// [Class] EFT.Interactive.LootItem
	namespace loot_item
	{
		constexpr auto size = 0xF0;
		constexpr auto max_use_size = 0xB8; // 0xB0 + sizeof(EFT.InventoryLogic.Item) = 0xB0 + 0x8

		constexpr auto Name = 0x50; // [50] Name : String
		constexpr auto InventoryLogicItem = 0xB0; // [B0] item_0xB0 : EFT.InventoryLogic.Item
		constexpr auto _renderers = 0x88; // [88] _renderers : System.Collections.Generic.List<Renderer>

		// [Class] EFT.InventoryLogic.Item
		namespace _InventoryLogicItem
		{
			constexpr auto size = 0x70;
			constexpr auto max_use_size = 0x68; // 0x64 + sizeof(Int32) = 0x64 + 0x4

			constexpr auto StackObjectsCount = 0x64; // [64] StackObjectsCount : Int32
		}
	}

	// [Class] EFT.Animations.ProceduralWeaponAnimation
	namespace pwa
	{
		constexpr auto size = 0x368;
		constexpr auto max_use_size = 0x1B0; // 0x1AC + sizeof(Single) = 0x1AC + 0x4

		constexpr auto mask = 0x100; // [100] Mask : System.Int32
		constexpr auto breath_effector = 0x28; // [28] Breath : EFT.Animations.BreathEffector
		constexpr auto shot_effector = 0x48; // [48] Shootingg : -.ShotEffector
		constexpr auto Walk = 0x30; // [30] Walk : -.WalkEffector
		constexpr auto MotionReact = 0x38; // [38] MotionReact : -.MotionEffector
		constexpr auto ForceReact = 0x40; // [40] ForceReact : -.ForceEffector
		constexpr auto _fovCompensatoryDistance = 0x1AC; // [1AC] _fovCompensatoryDistance : Single
		constexpr auto CameraSmoothTime = 0x144; // [144] CameraSmoothTime : Single

		// [Class] EFT.Animations.BreathEffector
		namespace breath
		{
			constexpr auto size = 0xF0;
			constexpr auto max_use_size = 0xA8; // 0xA4 + sizeof(Single) = 0xA4 + 0x4

			constexpr auto intensity = 0xA4; // [A4] Intensity : Single
		}
    
    // ...
}

```

```

`TOG.App/Definitions.cs`:

```cs
using TOG.App.Definitions;

namespace TOG.App;

public static partial class Program
{
    public static NamespaceDefinition[] _definitions = new NamespaceDefinition[]
    {
        // [Class] EFT.GameWorld
        new NamespaceDefinition("game_world", new()
        {
            new OffsetDefinition("loot_list").WithFieldName("LootList"),
            new OffsetDefinition("registered_players").WithFieldName("RegisteredPlayers"),
            new OffsetDefinition("exfil_controller").WithUnknownType().WithFieldFilter(c => c.First()),
            new OffsetDefinition("grenades").WithFieldName("Grenades")
        }).WithNamespace("EFT").WithClass("GameWorld"),

        // [Class] -.GClass0B5E
        new NamespaceDefinition("exfil_controller", new()
        {
            new OffsetDefinition("points").WithType("EFT.Interactive.ExfiltrationPoint[]"),
            new OffsetDefinition("scav_points").WithType("EFT.Interactive.ScavExfiltrationPoint[]"),
        }, new()
        {
            new NamespaceDefinition("_point", new()
            {
                new OffsetDefinition("Requirements").WithFieldName("Requirements"),
                new OffsetDefinition("_status").WithFieldName("_status"),
                new OffsetDefinition("ExfiltrationStartTime").WithFieldName("ExfiltrationStartTime"),
                new OffsetDefinition("Reusable").WithFieldName("Reusable")
            }, new()
            {
                new NamespaceDefinition("_requirement", new()
                {
                    new OffsetDefinition("Id").WithFieldName("Id"),
                    new OffsetDefinition("RequirementTip").WithFieldName("RequirementTip"),
                    new OffsetDefinition("Requirement").WithFieldName("Requirement"),
                    new OffsetDefinition("Count").WithFieldName("Count"),
                    new OffsetDefinition("RequiredSlot").WithFieldName("RequiredSlot"),
                }).WithNamespace("EFT.Interactive").WithClass("ExfiltrationRequirement")
            }).WithNamespace("EFT.Interactive").WithClass("ExfiltrationPoint")
        }).FromPreviousFoundField("game_world::exfil_controller"),

        // [Class] EFT.Player
        new NamespaceDefinition("player", new()
        {
            new OffsetDefinition("action").WithType("System.Action<Single, Single, Int32>").WithFieldFilter(c => c.First()),
            new OffsetDefinition("movement_context").WithUnknownFieldName().WithUnknownType().WithFieldFilter(c => c.First()),
            new OffsetDefinition("profile").WithType("EFT.Profile"),
            new OffsetDefinition("pwa").WithType("EFT.Animations.ProceduralWeaponAnimation"),
            new OffsetDefinition("body").WithType("EFT.PlayerBody"),
            new OffsetDefinition("health_controller").WithFieldName("_healthController"),
            new OffsetDefinition("physical").WithFieldName("Physical"),
            new OffsetDefinition("is_local_player").WithType("Boolean").WithFieldFilter(c => c.Last()),
            new OffsetDefinition("hands_controller").WithFieldName("_handsController"),
            // [Class] -.PlayerBones : MonoBehaviour
            new OffsetDefinition("PlayerBones").WithFieldName("PlayerBones")
        }, new List<NamespaceDefinition>()
        {
            new NamespaceDefinition("_player_bones", new() {
                //[140] Fireport : EFT.BifacialTransform
                new OffsetDefinition("fireport").WithFieldName("Fireport")
            }).FromPreviousFoundField("player::PlayerBones"),

            new NamespaceDefinition("_physical", new()
            {
                new OffsetDefinition("stamina").WithFieldName("Stamina")
            }, new ()
            {
                new NamespaceDefinition("_stamina", new()
                {
                    new OffsetDefinition("current").WithFieldName("Current")
                }).FromPreviousFoundField("_physical::stamina")
            }).FromPreviousFoundField("player::physical"),

            new NamespaceDefinition("_health_controller", new()
            {
                new OffsetDefinition("bodyPartStateDictionary").WithType("System.Collections.Generic.Dictionary<Int32, BodyPartState<Var>>")
            }, new()
            {
                new NamespaceDefinition("_bodyPartStateDictionary", new()
                {
                    new OffsetDefinition("Health").WithFieldName("Health"),
                    new OffsetDefinition("IsDestroyed").WithFieldName("IsDestroyed"),
                }, new()
                {
                    new NamespaceDefinition("_health", new ()
                    {
                        new OffsetDefinition("Value").WithFieldName("Value")
                    }).WithNamespace("EFT.HealthSystem").WithClass("HealthValue")
                }).WithClass("BodyPartState")
            }).FromPreviousFoundField("player::health_controller"),

            new NamespaceDefinition("_movement_context", new()
            {
                new OffsetDefinition("position").WithType("UnityEngine.RaycastHit").WithFieldFilter(c => c.First()),
                new OffsetDefinition("view_angle").WithType("UnityEngine.Vector2").WithFieldFilter(c => c.Skip(2).First())
            }).FromPreviousFoundField("player::movement_context"),

            new NamespaceDefinition("_player_body", new()
            {
                new OffsetDefinition("SlotViews").WithFieldName("SlotViews"),
                new OffsetDefinition("SkeletonRootJoint").WithFieldName("SkeletonRootJoint"),
                new OffsetDefinition("BodySkins").WithFieldName("BodySkins")
            }, new()
            {
                new NamespaceDefinition("Skeleton", new()
                {
                    new OffsetDefinition("_values").WithFieldName("_values")
                }).WithNamespace("Diz.Skinning").WithClass("Skeleton")
            }).FromPreviousFoundField("player::body"),

            // [Class] -.AIFirearmController : FirearmController
            new NamespaceDefinition("_hands_controller", new()
            {
                new OffsetDefinition("fireport").WithFieldName("Fireport"),
            }, new ()
            {
                new NamespaceDefinition("_fireport", new()
                {
                    new OffsetDefinition("Original").WithFieldName("Original")
                }).WithNamespace("EFT").WithClass("BifacialTransform")
            }).WithClass("AIFirearmController")
        }).WithNamespace("EFT").WithClass("Player"),

        // [Class] EFT.Profile
        new NamespaceDefinition("profile", new()
        {
            new OffsetDefinition("info").WithFieldName("Info").WithUnknownType(),
            new OffsetDefinition("skills").WithFieldName("Skills").WithUnknownType()
        }, new List<NamespaceDefinition>()
        {
            new NamespaceDefinition("_info", new()
            {
                new OffsetDefinition("Nickname").WithFieldName("Nickname"),
                new OffsetDefinition("GroupId").WithFieldName("GroupId"),
                new OffsetDefinition("Settings").WithFieldName("Settings"),
                new OffsetDefinition("Side").WithFieldName("Side"),
                new OffsetDefinition("RegistrationDate").WithFieldName("RegistrationDate"),
            }, new()
            {
                new NamespaceDefinition("_Settings", new() {
                    new OffsetDefinition("Role").WithFieldName("Role"),
                    new OffsetDefinition("Experience").WithFieldName("Experience")
                }).FromPreviousFoundField("_info::Settings")
            }).FromPreviousFoundField("profile::info"),

            new NamespaceDefinition("_skills", new()
            {
                new OffsetDefinition("SearchBuffSpeed").WithFieldName("SearchBuffSpeed"),
                new OffsetDefinition("SearchDouble").WithFieldName("SearchDouble")
            }).FromPreviousFoundField("profile::skills")
        }).WithNamespace("EFT").WithClass("Profile"),

        // [Class] EFT.Interactive.LootItem
        new NamespaceDefinition("loot_item", new()
        {
            new OffsetDefinition("Name").WithFieldName("Name").WithType("String"),
            new OffsetDefinition("InventoryLogicItem").WithType("EFT.InventoryLogic.Item"),
            new OffsetDefinition("_renderers").WithFieldName("_renderers")
        }, new()
        {
            // [Class] EFT.InventoryLogic.Item
            new NamespaceDefinition("_InventoryLogicItem", new()
            {
                new OffsetDefinition("StackObjectsCount").WithFieldName("StackObjectsCount")
            }).WithNamespace("EFT.InventoryLogic").WithClass("Item")
        }).WithNamespace("EFT.Interactive").WithClass("LootItem"),

        // [Class] EFT.Animations.ProceduralWeaponAnimation
        new NamespaceDefinition("pwa", new()
        {
            new OffsetDefinition("mask").WithFieldName("Mask"),
            new OffsetDefinition("breath_effector").WithFieldName("Breath").WithType("EFT.Animations.BreathEffector"),
            new OffsetDefinition("shot_effector").WithFieldName("Shootingg").WithType("-.ShotEffector"),
            new OffsetDefinition("Walk").WithFieldName("Walk"),
            new OffsetDefinition("MotionReact").WithFieldName("MotionReact"),
            new OffsetDefinition("ForceReact").WithFieldName("ForceReact"),
            new OffsetDefinition("_fovCompensatoryDistance").WithFieldName("_fovCompensatoryDistance"),
            new OffsetDefinition("CameraSmoothTime").WithFieldName("CameraSmoothTime")
        }, new()
        {
            // [Class] EFT.Animations.BreathEffector
            new NamespaceDefinition("breath", new()
            {
                new OffsetDefinition("intensity").WithFieldName("Intensity"),
            }).WithNamespace("EFT.Animations").WithClass("BreathEffector"),

            // [Class] -.ShotEffector
            new NamespaceDefinition("recoil", new()
            {
                new OffsetDefinition("itensity").WithFieldName("Intensity")
            }).WithNamespace("-").WithClass("ShotEffector"),

            // [Class] -.WalkEffector : Object, IEffector
            new NamespaceDefinition("_walk", new()
            {
                new OffsetDefinition("itensity").WithFieldName("Intensity")
            }).FromPreviousFoundField("pwa::Walk"),

            // [Class] -.MotionEffector : Object, IEffector
            new NamespaceDefinition("_motion", new()
            {
                new OffsetDefinition("itensity").WithFieldName("Intensity")
            }).FromPreviousFoundField("pwa::MotionReact"),

            // [Class] -.ForceEffector : Object, IEffector
            new NamespaceDefinition("_force", new()
            {
                new OffsetDefinition("itensity").WithFieldName("Intensity")
            }).FromPreviousFoundField("pwa::ForceReact"),

        }).WithNamespace("EFT.Animations").WithClass("ProceduralWeaponAnimation"),

        new NamespaceDefinition("hard_settings", new()
        {
            new OffsetDefinition("LOOT_RAYCAST_DISTANCE").WithFieldName("LOOT_RAYCAST_DISTANCE"),
            new OffsetDefinition("DOOR_RAYCAST_DISTANCE").WithFieldName("DOOR_RAYCAST_DISTANCE"),

        }).WithNamespace("-").WithClass("EFTHardSettings"),

        // [Class] BSG.CameraEffects.NightVision : MonoBehaviour, GInterface325A
        new NamespaceDefinition("night_vision", new()
        {
            new OffsetDefinition("on").WithFieldName("_on")
        }).WithNamespace("BSG.CameraEffects").WithClass("NightVision"),

        // [Class] -.VisorEffect : MonoBehaviour
        new NamespaceDefinition("visor_effect", new()
        {
            new OffsetDefinition("Intensity").WithFieldName("Intensity")
        }).WithNamespace("-").WithClass("VisorEffect"),

        // [Class] -.ThermalVision : MonoBehaviour, GInterface325A
        new NamespaceDefinition("thermal_vision", new()
        {
            new OffsetDefinition("On").WithFieldName("On")
        }).WithNamespace("-").WithClass("ThermalVision")
    };

}

```

`TOG.App/Definitions/NamespaceDefinition.cs`:

```cs
using Unispect;

namespace TOG.App.Definitions;

public class NamespaceDefinition
{
    public string DumpNamespaceName { get; set; }

    public string? NamespaceName { get; set; }

    public string? ClassName { get; set; }

    public string? PreviousFoundField { get; set; }

    public List<OffsetDefinition> OffsetDefinitions { get; set; } = new();

    public List<NamespaceDefinition> NamespaceDefinitions { get; set; } = new();

    public TypeDefWrapper FoundType { get; set; }

    public NamespaceDefinition(string dumpNamespaceName)
    {
        DumpNamespaceName = dumpNamespaceName;
    }

    public NamespaceDefinition(string dumpNamespaceName, List<OffsetDefinition> offsetDefinitions) : this(dumpNamespaceName)
    {
        OffsetDefinitions = offsetDefinitions;
    }

    public NamespaceDefinition(string dumpNamespaceName, List<OffsetDefinition> offsetDefinitions, List<NamespaceDefinition> namespaceDefinitions)
        : this(dumpNamespaceName, offsetDefinitions)
    {
        NamespaceDefinitions = namespaceDefinitions;
    }

    public NamespaceDefinition WithNamespace(string namespaceName)
    {
        NamespaceName = namespaceName;
        return this;
    }

    public NamespaceDefinition WithClass(string className)
    {
        ClassName = className;
        return this;
    }

    public NamespaceDefinition FromPreviousFoundField(string previousFoundField)
    {
        PreviousFoundField = previousFoundField;
        return this;
    }
}

```

`TOG.App/Definitions/OffsetDefinition.cs`:

```cs
using Unispect;

namespace TOG.App.Definitions;

public class OffsetDefinition
{
    public string OffsetName { get; set; }

    public string? TypeName { get; set; }

    public string? FieldName { get; set; }

    public bool IsUnknownType { get; set; } = false;

    public bool IsUnknownFieldName { get; set; } = false;

    public string? ParentType { get; set; }

    public Func<List<FieldDefWrapper>, FieldDefWrapper?> FieldFilterExpression { get; private set; }

    //public FieldInfo FoundField { get; set; }

    public FieldDefWrapper FoundField { get; set; }

    public OffsetDefinition(string offsetName)
    {
        OffsetName = offsetName;
    }

    public OffsetDefinition WithFieldName(string fieldName)
    {
        FieldName = fieldName;
        return this;
    }

    public OffsetDefinition WithType(string typeName)
    {
        TypeName = typeName;
        return this;
    }

    public OffsetDefinition WithFieldFilter(Func<List<FieldDefWrapper>, FieldDefWrapper?> expression)
    {
        FieldFilterExpression = expression;
        return this;
    }

    public OffsetDefinition WithUnknownFieldName()
    {
        IsUnknownFieldName = true;
        return this;
    }

    public OffsetDefinition WithUnknownType()
    {
        IsUnknownType = true;
        return this;
    }

    public OffsetDefinition FromParentType(string parentType)
    {
        ParentType = parentType;
        return this;
    }
}

```

`TOG.App/Models/ConsistencyInfo.cs`:

```cs
namespace TOG.App.Models;

public class ConsistencyInfo
{
    public string? Version { get; set; }

    public List<ConsistencyInfoEntry>? Entries { get; set; }
}

```

`TOG.App/Models/ConsistencyInfoEntry.cs`:

```cs
namespace TOG.App.Models;

public class ConsistencyInfoEntry
{
    public string? Path { get; set; }

    public string? Hash { get; set; }

    public int? Size { get; set; }
}

```

`TOG.App/Program.cs`:

```cs
using TOG.App.Definitions;
using TOG.App.Models;
using TOG.App.Templates;
using TOG.Common;
using TOG.Common.Helpers;
using Unispect;

namespace TOG.App;

public static partial class Program
{
    private const string PROCESS_NAME = "EscapeFromTarkov";
    private const string OUTPUT_DIRECTORY = @"..\..\..\Output";
    private const string INSTALL_PATH_NAME = PROCESS_NAME;

    private static readonly Logger _logger = new Logger();
    private static readonly Inspector _inspector = new Inspector();

    /// <summary>
    /// Entry point
    /// </summary>
    public async static Task Main(string[] args)
    {
        try
        {
            _logger.Log(LogType.Info, $"Written by Deathstroke");

            EnsureOutputDirectoryExists();

            var consistencyInfo = GetConsistencyInfo();

            // Get running game processes
            var runningProcesses = Process.GetProcessesByName(PROCESS_NAME);

            // If the game is not running
            if (runningProcesses.Length == 0)
            {
                _logger.Log(LogType.Info, $"Game is not running, starting it...");

                // This will not work properly. Consider starting the game before running the generator or fix this part.
                throw new NotImplementedException("This app cannot run the game, please run it before starting this app...");

                // Get game install directory
                var gameDirectory = Tools.GetInstallationPath(INSTALL_PATH_NAME);

                // Get game executable path
                var gamePath = Path.Combine(gameDirectory, PROCESS_NAME + ".exe");
                if (!File.Exists(gamePath))
                    throw new Exception("Unable to find game executable");

                // Run the game
                var processInfo = ProcessHelper.CreateProcess(gamePath);
                _logger.Log(LogType.Info, $"Game was started (pid: {processInfo.dwProcessId})");

                await Task.Delay(3 * 1000);
            }
            else if (runningProcesses.Length == 1)
            {
                var runningProcess = runningProcesses.First();

                _logger.Log(LogType.Info, $"Game is already running (pid: {runningProcess.Id})");
            }
            else
            {
                throw new Exception($"Unexpected running process count {runningProcesses.Length}");
            }

            // Dump types
            _inspector.DumpTypes(Path.Combine(OUTPUT_DIRECTORY, "dump.txt"), typeof(BasicMemory), processHandle: PROCESS_NAME);

            // And finally generate offsets
            GenerateOffsets();

            // Generate output file
            GenerateOutputFile(consistencyInfo);

            // OK
            _logger.Log(LogType.Success, $"Done");
        }
        catch (Exception ex)
        {
            _logger.Log(LogType.Error, $"An exception occured: {ex.Message}");
        }
        finally
        {
            Console.ReadKey();
        }   
    }

    private static ConsistencyInfo GetConsistencyInfo(string? gameDirectory = null)
    {
        if (gameDirectory == null)
            gameDirectory = Tools.GetInstallationPath(INSTALL_PATH_NAME);

        if (!Directory.Exists(gameDirectory))
            throw new Exception($"Game directory doesn't exist '{gameDirectory}'");
        
        var consistencyInfoFilePath = Path.Combine(Tools.GetInstallationPath(INSTALL_PATH_NAME), "ConsistencyInfo");
        if (!File.Exists(consistencyInfoFilePath))
            throw new Exception($"Unable to find consistency info file does not exist '{consistencyInfoFilePath}'");

        var fileContent = File.ReadAllText(consistencyInfoFilePath);
        if (string.IsNullOrEmpty(fileContent))
            throw new Exception($"Invalid consistency info content");

        var consistencyInfo = JsonConvert.DeserializeObject<ConsistencyInfo?>(fileContent);
        if (consistencyInfo == null)
            throw new Exception("Consistency Info couldn't be deserialized");

        return consistencyInfo;
    }

    /// <summary>
    /// Start generating offsets
    /// </summary>
    private static void GenerateOffsets()
    {
        foreach (var namespaceDefinition in _definitions)
            IterateNamespaceDefinition(namespaceDefinition);
    }

    private static List<NamespaceDefinition> GetAllNamespaceDefinitionsRecursive(NamespaceDefinition parentNamespace)
    {
        var result = new List<NamespaceDefinition>();
        result.Add(parentNamespace);

        foreach (var childNamespace in parentNamespace.NamespaceDefinitions)
        {
            result.AddRange(GetAllNamespaceDefinitionsRecursive(childNamespace));
        }

        return result;
    }

    private static List<NamespaceDefinition> GetAllNamespaceDefinitions()
    {
        var result = new List<NamespaceDefinition>();

        foreach (var namespaceDefinition in _definitions)
            result.AddRange(GetAllNamespaceDefinitionsRecursive(namespaceDefinition));

        return result;
    }

    private static TypeDefWrapper? LookupTypeFromPreviousFoundType(NamespaceDefinition parentNamespace)
    {
        _logger.Log(LogType.Info, $"Finding type for {parentNamespace.DumpNamespaceName} from a previous found type {parentNamespace.PreviousFoundField}");

        var parts = parentNamespace.PreviousFoundField.Split("::");
        var _namespace = parts[0];
        var _field = parts[1];


        var allNamespaces = GetAllNamespaceDefinitions();

        //var x = _definitions.Where(def => def.DumpNamespaceName.Equals(_namespace));

        var x = allNamespaces.Where(def => def.DumpNamespaceName.Equals(_namespace));

        var b = x.First().OffsetDefinitions.ToList();

        var y = b.Where(off => off.FoundField != null && off.OffsetName.Equals(_field)).First();

        var field = y.FoundField;

        var dick = _inspector.TypeDefinitions.Where(c => c.FullName == field.FieldType).First();

        // In case the type is an interface with 0 fields, find a class which implements it
        if (dick.ClassType == "Interface" && dick.Fields.Count == 0)
        {
            var test = _inspector.TypeDefinitions.Where(c => c.ClassType == "Class" && c.Interfaces.Any(b => b.Name == dick.Name)).First();

            return test;
        }

        return dick;
    }

    private static TypeDefWrapper? FindTypeFromParentNamespaceDefinition(NamespaceDefinition parentNamespace)
    {
        // If the type uses a previous found one
        if (parentNamespace.PreviousFoundField != null)
            return LookupTypeFromPreviousFoundType(parentNamespace);

        // Get all classes
        var types = _inspector.TypeDefinitions.Where(c => c.ClassType.Equals("Class")).ToList();

        // Filter by namespace name
        if (parentNamespace.NamespaceName != null)
            types = types.Where(c => c.Namespace.Equals(parentNamespace.NamespaceName)).ToList();

        // Filter by class name
        if (parentNamespace.ClassName != null)
            types = types.Where(c => c.Name.Equals(parentNamespace.ClassName)).ToList();

        // Get the found class
        var foundClass = types.FirstOrDefault();

        return foundClass;
    }

    private static FieldDefWrapper? FindFieldFromOffsetDefinition(TypeDefWrapper type, OffsetDefinition offsetDefinition)
    {
        // Now find the field
        var fields = type.Fields.ToList();

        // Type name
        if (offsetDefinition.IsUnknownType)
            fields = fields.Where(c => c.FieldType.StartsWith("-.GClass")).ToList();
        else if (offsetDefinition.TypeName != null)
            fields = fields.Where(c => c.FieldType.Equals(offsetDefinition.TypeName)).ToList();

        // Field name
        if (offsetDefinition.IsUnknownFieldName)
            fields = fields.Where(c => c.Name.StartsWith("gClass")).ToList();
        else if (offsetDefinition.FieldName != null)
            fields = fields.Where(c => c.Name.Equals(offsetDefinition.FieldName)).ToList();

        FieldDefWrapper? foundField = null;

        if (offsetDefinition.FieldFilterExpression != null)
            foundField = offsetDefinition.FieldFilterExpression(fields);
        else
            foundField = fields.First();

        return foundField;
    }

    /// <summary>
    /// Handles an offset definition
    /// </summary>
    /// <param name="parentNamespace">The parent namespace</param>
    /// <param name="offsetDefinition">The child offset definition of the given parent namespace</param>
    private static void HandleOffsetDefinition(NamespaceDefinition parentNamespace, OffsetDefinition offsetDefinition)
    {
        // Get the found class
        var type = FindTypeFromParentNamespaceDefinition(parentNamespace);

        // Now find the field
        var field = FindFieldFromOffsetDefinition(type, offsetDefinition);

        // Make sure field was found
        if (field == null)
        {
            _logger.Log(LogType.Error, $"{parentNamespace.DumpNamespaceName}::{offsetDefinition.OffsetName} was not found");
            return;
        }

        // Set found field
        //offsetDefinition.FoundField = new FieldInfo(type, field);
        parentNamespace.FoundType = type;
        offsetDefinition.FoundField = field;

        // Log
        _logger.Log(LogType.Success, $"{parentNamespace.DumpNamespaceName}::{offsetDefinition.OffsetName} = 0x{field.Offset:X};");
    }

    /// <summary>
    /// Handles a namespace definition
    /// </summary>
    /// <param name="namespaceDefinition">The namespace definition to handle</param>
    private static void IterateNamespaceDefinition(NamespaceDefinition namespaceDefinition)
    {
        foreach (var offsetDefinition in namespaceDefinition.OffsetDefinitions)
            HandleOffsetDefinition(namespaceDefinition, offsetDefinition);
        
        foreach (var _namespaceDefinition in namespaceDefinition.NamespaceDefinitions)
            IterateNamespaceDefinition(_namespaceDefinition);
    }

    /// <summary>
    /// Generates the output file
    /// </summary>
    private static void GenerateOutputFile(ConsistencyInfo consistencyInfo)
    {
        var template = new CppTemplate();

        template.AddInstruction("#pragma once", 0);
        template.AddInstruction("#include \"stdafx.h\"", 0);
        template.SkipLine();

        template.AddHeader(consistencyInfo.Version);
        template.SkipLine();

        template.AddInstruction("namespace offsets", 0);
        template.AddInstruction("{", 0);

        foreach (var namespaceDefinition in _definitions)
        {
            template.HandleNamespace(namespaceDefinition, 1, namespaceDefinition == _definitions.Last());
        }

        template.AddInstruction("}", 0);
        template.Build(Path.Combine(OUTPUT_DIRECTORY, "offsets.h"));
    }

    private static void EnsureOutputDirectoryExists()
    {
        if (!Directory.Exists(OUTPUT_DIRECTORY))
            Directory.CreateDirectory(OUTPUT_DIRECTORY);
    }
}
```

`TOG.App/TOG.App.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <StartupObject></StartupObject>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <BaseOutputPath>..\bin</BaseOutputPath>
  </PropertyGroup>

  <ItemGroup>
    <Folder Include="Output\" />
    <Folder Include="Unispect\Classes\" />
    <Folder Include="Unispect\Enums\" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
    <PackageReference Include="PInvoke.Kernel32" Version="0.7.104" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TOG.Common\TOG.Common.csproj" />
  </ItemGroup>

</Project>

```

`TOG.App/Templates/CppTemplate.cs`:

```cs
using TOG.Common.Templates;
using TOG.Common.Helpers;
using TOG.App.Definitions;

namespace TOG.App.Templates;

public class CppTemplate : BaseTemplate
{
    private static Dictionary<string, int> typeSizeMap = new () 
    {
        { "Boolean", 1 }, // Real size 1 but padded 4
        { "Single", 4 }, // Float
        //{ "EFT.HealthSystem.ValueStruct", 0xF }, // ???
        { "UnityEngine.RaycastHit", 3 * sizeof(float) }, // Vector 3
        { "UnityEngine.Vector2", 2 * sizeof(float) }, // Vector 2
        { "Int32", 4 }
    };

    private void GenerateOffset(OffsetDefinition offsetDefinition, int indent)
    {
        string comment = $"{offsetDefinition.FoundField.OffsetHex} {offsetDefinition.FoundField.Name} : {offsetDefinition.FoundField.FieldType}";
        AddInstruction($"constexpr auto {offsetDefinition.OffsetName} = 0x{offsetDefinition.FoundField.Offset:X}; // {comment}", indent);
    }

    private void GenerateSizes(NamespaceDefinition namespaceDefinition, int indent)
    {
        AddInstruction($"constexpr auto size = 0x{namespaceDefinition.FoundType.InnerDefinition.InstanceSize:X};", indent);

        // Find the last offset in the list
        var lastOffset = namespaceDefinition.OffsetDefinitions.OrderByDescending(c => c.FoundField.Offset).First();

        var lastOffsetValue = lastOffset.FoundField.Offset;

        // Find the last offset size
        var lastOffsetSize = 0x8;
        if (typeSizeMap.TryGetValue(lastOffset.FoundField.FieldType, out var size))
            lastOffsetSize = size;

        // Calculate the "max use size"
        var safeSize = lastOffsetValue + lastOffsetSize;

        // Create the comment
        string comment = $"0x{lastOffsetValue:X} + sizeof({lastOffset.FoundField.FieldType}) = 0x{lastOffsetValue:X} + 0x{lastOffsetSize:X}";

        // Prind
        AddInstruction($"constexpr auto max_use_size = 0x{safeSize:X}; // {comment}", indent);
        SkipLine();
    }

    private void GenerateNamespace(NamespaceDefinition namespaceDefinition, int indent, bool isLast = false)
    {
        _logger.Log(LogType.Info, $"Generating namespace {namespaceDefinition.DumpNamespaceName}");

        AddInstruction($"// [{namespaceDefinition.FoundType.ClassType}] {namespaceDefinition.FoundType.FullName}", indent);
        AddInstruction($"namespace {namespaceDefinition.DumpNamespaceName}", indent);
        AddInstruction("{", indent);

        // Size
        GenerateSizes(namespaceDefinition, indent + 1);

        // Generate offsets
        foreach (var offsetDefinition in namespaceDefinition.OffsetDefinitions)
            GenerateOffset(offsetDefinition, indent + 1);

        // Generate child namespaces (if so)
        if (namespaceDefinition.NamespaceDefinitions.Count > 0)
        {
            SkipLine();

            foreach (var _namespaceDefinition in namespaceDefinition.NamespaceDefinitions)
                GenerateNamespace(_namespaceDefinition, indent + 1, _namespaceDefinition == namespaceDefinition.NamespaceDefinitions.Last());
        }

        AddInstruction("}", indent);

        if (!isLast)
            SkipLine();
    }

    public void HandleNamespace(NamespaceDefinition namespaceDefinition, int indent, bool isLast)
    {
        GenerateNamespace(namespaceDefinition, indent, isLast);
    }
}

```

`TOG.App/Unispect/Classes/BasicMemory.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;

namespace Unispect
{
    [UnispectPlugin]
    public sealed class BasicMemory : MemoryProxy
    {
        #region DllImports

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool ReadProcessMemory(IntPtr hProcess, ulong lpAddress, byte[] buffer, int size, ref int lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool CloseHandle(IntPtr hHandle);
        #endregion

        #region Constants

        private const int ProcessVmAll = ProcessVmOperation | ProcessVmRead | ProcessVmWrite;
        private const int ProcessVmOperation = 0x0008;
        private const int ProcessVmRead = 0x0010;
        private const int ProcessVmWrite = 0x0020;

        #endregion

        public Process ManagedProcessHandle;
        public IntPtr NativeProcessHandle;

        public override ModuleProxy GetModule(string moduleName)
        {
            if (ManagedProcessHandle == null) throw new Exception("Not currently attached to a process.");

            ProcessModule resultModule = null;
            foreach (ProcessModule pm in ManagedProcessHandle.Modules.AsParallel())
            {
                if (pm.ModuleName.EndsWith(moduleName))
                {
                    resultModule = pm;
                    break;
                }
            }

            if (resultModule == null)
                return null;

            return new ModuleProxy(resultModule.ModuleName, (ulong)resultModule.BaseAddress.ToInt64(),
                resultModule.ModuleMemorySize);
        }

        public override bool AttachToProcess(string handle)
        {
            var procName = (string)handle;
            var procList = Process.GetProcessesByName(procName);

            if (procList.Length == 0)
                throw new Exception("Process not found.");

            ManagedProcessHandle = procList[0];
            NativeProcessHandle = OpenProcess(ProcessVmAll, false, ManagedProcessHandle.Id);

            return true;
        }

        public override byte[] Read(ulong address, int length)
        {
            return ReadMemory(address, length);
        }

        public byte[] ReadMemory(ulong address, int length)
        {
            var bytesRead = 0;
            var buffer = new byte[length];
            var success = ReadProcessMemory(NativeProcessHandle, address, buffer, length, ref bytesRead);

            if (success && bytesRead > 0)
            {
                return buffer;
            }

            return null;
        }

        public override void Dispose()
        {
            // Cleanup
            CloseHandle(NativeProcessHandle);
        }
    }
}
```

`TOG.App/Unispect/Classes/BoolToVisConverter.cs`:

```cs
//using System;
//using System.Globalization;
//using System.Windows;
//using System.Windows.Data;

//namespace Unispect
//{
//    public class BoolToVisConverter : IValueConverter
//    {

//        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
//        {
//            return (value is bool && (bool)value) ? Visibility.Visible : Visibility.Collapsed;
//        }

//        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
//        {
//            return value is Visibility && (Visibility)value == Visibility.Visible;
//        }
//    }
//}
```

`TOG.App/Unispect/Classes/BooleanToVisibilityConverter.cs`:

```cs
//using System;
//using System.Globalization;
//using System.Windows;
//using System.Windows.Data;

//namespace Unispect
//{
//    public class BooleanToVisibilityConverter : IValueConverter
//    {
//        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
//        {
//            var invert = false;

//            if (parameter != null)
//                invert = bool.Parse(parameter.ToString());

//            var booleanValue = value != null && (bool)value;

//            return ((booleanValue && !invert) || (!booleanValue && invert))
//                ? Visibility.Visible : Visibility.Collapsed;
//        }

//        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
//        {
//            throw new NotImplementedException();
//        }
//    }
//}
```

`TOG.App/Unispect/Classes/CacheStore.cs`:

```cs
using System.Collections.Concurrent;

namespace Unispect
{
    public static class CacheStore
    {
        public static ConcurrentDictionary<ulong, string> FieldNameCache = new ConcurrentDictionary<ulong, string>();
        public static ConcurrentDictionary<ulong, string> ClassNameCache = new ConcurrentDictionary<ulong, string>();
        public static ConcurrentDictionary<ulong, string> ClassNamespaceCache = new ConcurrentDictionary<ulong, string>();

        public static void Clear()
        {
            FieldNameCache.Clear();
            ClassNameCache.Clear();
            ClassNamespaceCache.Clear();
        }
    }
}
```

`TOG.App/Unispect/Classes/Inspector.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unispect
{
    // Todo add support for il2cpp ?
    [Serializable]
    public sealed class Inspector : Progress<float>, IDisposable
    {
        private MemoryProxy _memory;
        private float _progressTotal;
        private float ProgressTotal
        {
            get => _progressTotal;
            set
            {
                _progressTotal = value;
                OnReport(_progressTotal);
            }
        }

        private ConcurrentDictionary<ulong, TypeDefinition> _typeDefinitions
            = new ConcurrentDictionary<ulong, TypeDefinition>();

        public List<TypeDefWrapper> TypeDefinitions { get; private set; } = new List<TypeDefWrapper>();

        // If you add any progress lengths, you should increase this.
        // Every progress task represents 1 length
        private const int TotalProgressLength = 9;

        protected override void OnReport(float value)
        {
            value /= TotalProgressLength;
            base.OnReport(value);
        }

        public void DumpTypes(string fileName, Type memoryProxyType,
            bool verbose = true,
            string processHandle = "SomeGame",
            //string monoModuleName = "mono-2.0-bdwgc.dll",
            string moduleToDump = "Assembly-CSharp")
        {
            Log.Add($"Initializing memory proxy of type '{memoryProxyType.Name}'");
            _memory = (MemoryProxy)Activator.CreateInstance(memoryProxyType);

            ProgressTotal += 0.16f;

            Log.Add($"Attaching to process '{processHandle}'");
            var success = _memory.AttachToProcess(processHandle);

            if (!success)
                throw new Exception("Could not attach to the remote process.");

            ProgressTotal += 0.16f;

            //Log.Add($"Obtaining {monoModuleName} module details");
            var monoModule = GetMonoModule(out var monoModuleName);
            if (monoModule == null)
            {
                throw new NotSupportedException();
            }

            Log.Add($"Module {monoModule.Name} loaded. " +
                    $"(BaseAddress: 0x{monoModule.BaseAddress:X16})");

            ProgressTotal += 0.16f;

            Log.Add($"Copying {monoModuleName} module to local memory {(monoModule.Size / (float)0x100000):###,###.00}MB");
            var monoDump = _memory.Read(monoModule.BaseAddress, monoModule.Size);

            ProgressTotal += 0.16f;

            Log.Add($"Traversing PE of {monoModuleName}");
            var rdfa = GetRootDomainFunctionAddress(monoDump, monoModule);

            ProgressTotal += 0.16f;

            Log.Add($"Getting MonoImage address for {moduleToDump}");
            var monoImage = GetAssemblyImageAddress(rdfa, moduleToDump); // _MonoImage of moduleToDump (Assembly-CSharp)

            ProgressTotal += 0.16f;

            _typeDefinitions = GetRemoteTypeDefinitions(monoImage);

            Log.Add("Propogating types and fields");
            PropogateTypes();

            // If this is true, then the user does not want to save to file
            if (!string.IsNullOrWhiteSpace(fileName))
            {
                DumpToFile(fileName, verbose, false);
                ProgressTotal += 0.15f;
                SaveTypeDefDb(processHandle, moduleToDump);
            }

            OnReport(TotalProgressLength); // Set to 100%

            Log.Add("Operation completed successfully.");
        }

        public void SaveTypeDefDb(string processHandle, string moduleToDump)
        {
            Log.Add("Saving Type Definition database");
            //Log.Add("Compressing Type Definition database");

            if (!System.IO.Directory.Exists("TypeDbs"))
                System.IO.Directory.CreateDirectory("TypeDbs");

            // Todo if we plan on storing multiple, perhaps make it a cyclic storage system.
            //var fileName = $"{processHandle} {moduleToDump} ({DateTime.Now.ToFileTime():X8}).gz";
            //var fileName = $"{processHandle} {moduleToDump}.gz";
            var fileName = $"{processHandle} {moduleToDump}.utd";
            //Serializer.SaveCompressed($"TypeDbs\\{fileName.SanitizeFileName().ToLower()}", TypeDefinitions);
            Serializer.Save($"TypeDbs\\{fileName.SanitizeFileName().ToLower()}", TypeDefinitions);
        }

        private ModuleProxy GetMonoModule(out string moduleName)
        {
            //Log.Add("Looking for the mono module (mono, mono-2.0-bdwgc)");
            Log.Add("Looking for the mono module (mono-2.0-bdwgc)");
            var module = _memory.GetModule("mono-2.0-bdwgc.dll");
            if (module != null)
            {
                moduleName = "Found mono-2.0-bdwgc.dll";
                return module;
            }

            // Currently unsupported.
            // todo: return to this when dynamic structures are implemented and consider adding support
            //module = _memory.GetModule("mono.dll");
            //if (module != null)
            //{
            //    moduleName = "mono.dll";
            //    return module;
            //}

            moduleName = "";
            return null;
        }

        private void PropogateTypes()
        {
            var typeDefWrappers = new List<TypeDefWrapper>();
            var progressIncrement = 1f / _typeDefinitions.Count * 3f;
            foreach (var t in _typeDefinitions.AsParallel())
            {
                ProgressTotal += progressIncrement;

                var typeDef = t.Value;
                typeDefWrappers.Add(new TypeDefWrapper(typeDef));
            }

            Log.Add("Sorting type definitions by path");

            TypeDefinitions = new List<TypeDefWrapper>(typeDefWrappers.OrderBy(wrapper => wrapper.FullName));
        }

        public void DumpToFile(string fileName, bool verbose = true, List<TypeDefWrapper> tdlToDump = null)
        {
            DumpToFile(fileName, verbose, true, tdlToDump);
        }

        private void DumpToFile(string fileName, bool verbose, bool adjustProgressIncr, List<TypeDefWrapper> tdlToDump = null)
        {
            // ****************** Formatting below
            Log.Add("Formatting dump");
            var sb = new StringBuilder();

            if (tdlToDump == null)
                tdlToDump = TypeDefinitions;

            var progressIncrement = 1f / tdlToDump.Count * (adjustProgressIncr
                                        ? TotalProgressLength
                                        : 2);

            sb.AppendLine($"Generated by Unispect v{Utilities.CurrentVersion} - by Razchek {Utilities.GithubLink}");
            sb.AppendLine();
            sb.AppendLine("S = Static");
            sb.AppendLine("C = Constant");
            sb.AppendLine();

            foreach (var typeDef in tdlToDump)
            {
                // Progress 1 
                ProgressTotal += progressIncrement;

                if (verbose)
                    sb.Append($"[{typeDef.ClassType}] ");
                sb.Append(typeDef.FullName);
                if (verbose)
                {
                    //sb.AppendLine($" [{typeDef.GetClassType()}]");
                    var parent = typeDef.Parent;
                    if (parent != null)
                    {
                        sb.Append($" : {parent.Name}");
                        var interfaceList = typeDef.Interfaces;
                        if (interfaceList.Count > 0)
                        {
                            foreach (var iface in interfaceList)
                            {
                                sb.Append($", {iface.Name}");
                            }
                        }
                    }
                }

                sb.AppendLine();

                var fields = typeDef.Fields;
                if (fields == null)
                    continue;

                foreach (var field in fields)
                {
                    if (field.Offset > 0x2000)
                        continue;

                    var fieldName = field.Name;
                    var fieldType = field.FieldType;
                    sb.AppendLine(field.HasValue
                        ? $"    [{field.Offset:X2}][{field.ConstantValueTypeShort}] {fieldName} : {fieldType}"
                        : $"    [{field.Offset:X2}] {fieldName} : {fieldType}");
                }
            }

            System.IO.File.WriteAllText(fileName, sb.ToString());

            Log.Add($"Your definitions and offsets dump was saved to: {fileName}");
        }

        private ConcurrentDictionary<ulong, TypeDefinition> GetRemoteTypeDefinitions(ulong monoImageAddress)
        {
            var classCache = _memory.Read<InternalHashTable>(monoImageAddress + Offsets.ImageClassCache);
            var typeDefs = new Dictionary<ulong, TypeDefinition>();

            Log.Add($"Processing {classCache.Size} classes. This may take some time.");

            // Multiplying this by two will make it use two progress lengths.
            // Since it does a lot of the hard work, I think it fits nicely.
            var progressIncrement = 1f / classCache.Size * 2;


            for (var i = 0u; i < classCache.Size; i++)
            {
                // Progress 0
                ProgressTotal += progressIncrement;

                for (var d = _memory.Read<ulong>(classCache.Table + i * 8);
                    d != 0;
                    d = _memory.Read<ulong>(d + Offsets.ClassNextClassCache))
                {
                    var typeDef = _memory.Read<TypeDefinition>(d);
                    typeDefs.Add(d, typeDef);
                }
            }

            return new ConcurrentDictionary<ulong, TypeDefinition>(typeDefs);
        }

        private ulong GetAssemblyImageAddress(ulong rootDomainFunctionAddress, string name = "Assembly-CSharp")
        {
            var relativeOffset = _memory.Read<uint>(rootDomainFunctionAddress + 3);      // mov rax, 0x004671B9
            var domainAddress = relativeOffset + rootDomainFunctionAddress + 7;     // rdfa + 0x4671C0 // RootDomain (Unity Root Domain)

            var domain = _memory.Read<ulong>(domainAddress);

            var assemblyArrayAddress = _memory.Read<ulong>(domain + Offsets.DomainDomainAssemblies);
            for (var assemblyAddress = assemblyArrayAddress;
                assemblyAddress != 0;
                assemblyAddress = _memory.Read<ulong>(assemblyAddress + 0x8))
            {
                var assembly = _memory.Read<ulong>(assemblyAddress);
                var assemblyNameAddress = _memory.Read<ulong>(assembly + 0x10);
                var assemblyName = _memory.Read(assemblyNameAddress, 1024).ToAsciiString();
                if (assemblyName != name)
                    continue;

                return _memory.Read<ulong>(assembly + Offsets.AssemblyImage);
            }

            throw new InvalidOperationException($"Unable to find assembly '{name}'");
        }

        private static ulong GetRootDomainFunctionAddress(byte[] moduleDump, ModuleProxy monoModuleInfo)
        {
            // Traverse the PE header to get mono_get_root_domain
            var startIndex = moduleDump.ToInt32(Offsets.ImageDosHeaderELfanew);

            var exportDirectoryIndex = startIndex + Offsets.ImageNtHeadersExportDirectoryAddress;
            var exportDirectory = moduleDump.ToInt32(exportDirectoryIndex);

            var numberOfFunctions = moduleDump.ToInt32(exportDirectory + Offsets.ImageExportDirectoryNumberOfFunctions);
            var functionAddressArrayIndex = moduleDump.ToInt32(exportDirectory + Offsets.ImageExportDirectoryAddressOfFunctions);
            var functionNameArrayIndex = moduleDump.ToInt32(exportDirectory + Offsets.ImageExportDirectoryAddressOfNames);

            Log.Add($"e_lfanew: 0x{startIndex:X4}, Export Directory Entry: 0x{exportDirectory:X4}");
            Log.Add("Searching exports for 'mono_get_root_domain'");
            var rootDomainFunctionAddress = 0ul;

            Parallel.ForEach(Utilities.Step(0, numberOfFunctions * 4, 4), (functionIndex, state) =>
            {
                var functionNameIndex = moduleDump.ToInt32(functionNameArrayIndex + functionIndex);
                var functionName = moduleDump.ToAsciiString(functionNameIndex);

                if (functionName != "mono_get_root_domain")
                    return;

                //var realIndex = functionIndex / 4;
                var rva = moduleDump.ToInt32(functionAddressArrayIndex + functionIndex);
                rootDomainFunctionAddress = monoModuleInfo.BaseAddress + (ulong)rva;

                state.Stop();
            }
            );

            if (rootDomainFunctionAddress == 0)
            {
                throw new InvalidOperationException("Failed to find mono_get_root_domain function.");
            }
            Log.Add($"Function 'mono_get_root_domain' found. (Address: {rootDomainFunctionAddress:X16})");
            return rootDomainFunctionAddress;
        }

        public void Dispose()
        {
            _memory?.Dispose();
        }
    }
}
```

`TOG.App/Unispect/Classes/Log.cs`:

```cs
using System;

namespace Unispect
{
    public static class Log
    {
        public static string LogText { get; private set; }

        public enum MessageType
        {
            None,
            Information,
            Warning,
            Error,
            Exception
        }

        public class MessageAddedEventArgs : EventArgs
        {
            public string Message { get; }
            public MessageType Type { get; }

            public MessageAddedEventArgs(string text, MessageType messageType)
            {
                Message = text;
                Type = messageType;
            }
        }

        public static event EventHandler<MessageAddedEventArgs> LogMessageAdded;

        public static void Add(string text)
        {
            AppendLine(text);
        }

        public static void Info(string text)
        {
            AppendLine(text, MessageType.Information);
        }

        public static void Warn(string text)
        {
            AppendLine(text, MessageType.Warning);
        }

        public static void Error(string text)
        {
            AppendLine(text, MessageType.Error);
        }

        public static void Exception(string text, Exception ex)
        {
            var msg = !string.IsNullOrEmpty(text)
                ? $"{text}{Environment.NewLine}{ex.Message}"
                : ex.Message;

            AppendLine(msg, MessageType.Exception);
        }

        public static void AppendLine(string text, MessageType type = MessageType.None)
        {
            LogText +=
                $"[{DateTime.Now:HH:mm:ss.ff}] " +
                $"{(type == MessageType.None ? "" : $"[{Enum.GetName(typeof(MessageType), type)}]")} " +
                $"{text}" + Environment.NewLine;

            LogMessageAdded?.Invoke(null, new MessageAddedEventArgs(text, type));
        }

    }
}
```

`TOG.App/Unispect/Classes/MemoryProxy.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace Unispect
{
    public abstract class MemoryProxy : IDisposable
    {
        public static MemoryProxy Instance { get; set; }

        protected MemoryProxy()
        {
            Instance = this;
        }

        public abstract ModuleProxy GetModule(string moduleName);

        public abstract bool AttachToProcess(string handle);

        public abstract byte[] Read(ulong address, int length);

        internal T Read<T>(ulong address, int length = 0)
        {
            // This can be sped up dramatically by using unsafe code and a memory pool.
            // I might do that at a later date.

            if (length == 0)
                length = Marshal.SizeOf<T>();

            var bytes = Read(address, length);

            if (bytes == null)
            {
                return default;
                //throw new AccessViolationException($"Unable to read memory at [0x{address:X16}]");
            }

            var handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            try
            {
                return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject());
            }
            finally
            {
                handle.Free();
            }
        }

        public virtual void Dispose()
        {
        }
    }
}
```

`TOG.App/Unispect/Classes/ModuleProxy.cs`:

```cs
namespace Unispect
{
    public class ModuleProxy
    {
        public string Name { get; }
        public ulong BaseAddress { get; }
        public int Size { get; } 

        public ModuleProxy(string name, ulong baseAddress, int size)
        {
            Name = name;
            BaseAddress = baseAddress;
            Size = size;
        }

    }
}
```

`TOG.App/Unispect/Classes/Serializer.cs`:

```cs
using System;
using System.IO;
using System.IO.Compression;
using System.Runtime.Serialization.Formatters.Binary;

namespace Unispect
{
    public static class Serializer
    {
        public static void Save(string filePath, object objectToSerialize)
        {
            try
            {
                using (Stream stream = File.Open(filePath, FileMode.Create))
                {
                    var bin = new BinaryFormatter();
                    bin.Serialize(stream, objectToSerialize);
                }
            }
            catch (IOException)
            {
            }
        }

        public static void SaveCompressed(string filePath, object objectToSerialize)
        {
            // Todo: maybe implement a progress indicator by wrapping the stream
            try
            {
                using (Stream fileStream = File.Open(filePath, FileMode.Create))
                using (var compressedStream = new GZipStream(fileStream, CompressionMode.Compress))
                {
                    var bin = new BinaryFormatter();
                    bin.Serialize(compressedStream, objectToSerialize);
                }
            }
            catch (IOException)
            {
            }
        }

        public static T Load<T>(string filePath) where T : new()
        {
            var result = new T();

            try
            {
                using (Stream stream = File.Open(filePath, FileMode.Open))
                {
                    var bin = new BinaryFormatter();
                    result = (T)bin.Deserialize(stream);
                }
            }
            catch (IOException)
            {
            }

            return result;
        }
        public static T LoadCompressed<T>(string filePath) where T : new()
        {
            var result = new T();

            try
            {
                using (Stream fileStream = File.Open(filePath, FileMode.Open)) 
                using (var decompressStream = new GZipStream(fileStream, CompressionMode.Decompress))
                {
                    var bin = new BinaryFormatter();
                    result = (T)bin.Deserialize(decompressStream);
                }
            }
            catch (IOException)
            {
            }

            return result;
        }
    }
}
```

`TOG.App/Unispect/Classes/Settings.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Unispect
{
    [Serializable]
    public class Settings
    {
        public bool AreEmpty => _internalSettings == null;
        // Just in case I decide I want to add more control over the settings.
        public Settings()
        {
            _internalSettings = new Dictionary<string, string>();
        }
        private Dictionary<string, string> _internalSettings;//= new Dictionary<string, string>();

        public void AddOrUpdate(string key, string value)
        {
            if (_internalSettings.ContainsKey(key))
                _internalSettings[key] = value;
            else
                _internalSettings.Add(key, value);
        }

        public string Get(string key) => _internalSettings[key];
        public void Remove(string key) => _internalSettings.Remove(key);
        public void Update(string key, string value) => _internalSettings[key] = value;
        public bool TryGetValue(string key, out string value) => _internalSettings.TryGetValue(key, out value);
        public string this[string key]
        {
            get => _internalSettings[key];
            set => _internalSettings[key] = value;
        }
    }
}
```

`TOG.App/Unispect/Classes/Structs/FieldDefinition.cs`:

```cs
using System;
using System.Runtime.InteropServices;
//using MahApps.Metro.Converters;

namespace Unispect
{
    [Serializable]
    [StructLayout(LayoutKind.Sequential, Size = 32)]
    public struct FieldDefinition
    {
        public ulong Type;
        public ulong NamePtr;
        public ulong Parent;
        public int Offset;
        private int pad0; // align(8)

        public string Name
        {
            get
            {
                if (CacheStore.FieldNameCache.ContainsKey(NamePtr + Type))
                    return CacheStore.FieldNameCache[NamePtr + Type];

                var name = GetName();
                CacheStore.FieldNameCache.AddOrUpdate(NamePtr, name, (arg1, s) => s);
                return name;
            }
        }

        private string GetName()
        {
            if (NamePtr < 0x10000000 || Offset > 0x2000)
                return "<ErrorReadingField>";

            var b = Memory.Read(NamePtr, 1024);

            if (b == null)
                return "<ErrorReadingField>";

            var code = b[0];
            if (code < 32 || code > 126) // If non-printable Ascii
            {
                var fieldType = GetFieldTypeString();
                if (fieldType == null)
                    return "<ErrorReadingField>";

                var dotIndex = fieldType.LastIndexOf('.') + 1;
                var subType = dotIndex >= 0
                    ? fieldType.Substring(dotIndex)
                    : fieldType;

                return $"{subType.LowerChar().FormatFieldText()}" +
                       $"_0x{Offset:X2}";
            }

            var str = b.ToAsciiString();
            return str;
        }

        public override string ToString()
        {
            return Name;
        }

        public bool HasValue(out string valueType)
        {
            var monoType = Memory.Read<MonoType>(Type);

            if (monoType.HasValue)
            {
                if (monoType.IsConstant) valueType = "Constant";
                else if (monoType.IsStatic) valueType = "Static";
                else valueType = "Unknown";

                return true;
            }

            valueType = "";
            return false;
        }

        public TypeEnum TypeCode
        {
            get
            {
                var monoType = Memory.Read<MonoType>(Type);
                var typeCode = monoType.TypeCode;
                return typeCode;
            }
        } 

        public string GetFieldTypeString()
        {
            var monoType = Memory.Read<MonoType>(Type);

            var typeCode = monoType.TypeCode;
            switch (typeCode)
            {
                case TypeEnum.Class:
                case TypeEnum.SzArray:
                case TypeEnum.GenericInst:
                case TypeEnum.ValueType:
                    var typeDef = Memory.Read<TypeDefinition>(Memory.Read<ulong>(monoType.Data));
                    var name = typeDef.GetFullName();

                    // Potential bug, not all genericinst are valid? Needs further investigation.
                    // Temporary fix by using a stack overflow protection counter
                    if (typeCode == TypeEnum.GenericInst)
                    {
                        // If the field type is a generic instance, grab the generic parameters
                        var stackProtectionCounter = 0;
                        name = GetGenericParams(name, monoType, ref stackProtectionCounter);
                    }

                    if (typeCode == TypeEnum.SzArray)
                    {
                        name += "[]";
                    }

                    return name;

                default:
                    return Enum.GetName(typeof(TypeEnum), typeCode);
            }
        }

        private string GetGenericParams(string name, MonoType monoType, ref int stackProtectionCounter)
        {
            if (stackProtectionCounter++ > 30) 
                return "StackOverflow";

            var genericIndexOf = name.IndexOf('`');
            if (genericIndexOf >= 0)
            {
                // Remove the generic disclaimer
                name = name.Replace(name.Substring(genericIndexOf), "");
            }

            var genericParams = "";

            var monoGenericClass = Memory.Read<MonoGenericClass>(monoType.Data);
            var monoGenericInst =
                Memory.Read<MonoGenericInstance>(monoGenericClass.Context.ClassInstance);

            var paramCount = monoGenericInst.BitField & 0x003fffff; // (1 << 22) - 1;

            for (uint i = 0; i < paramCount && i < MonoGenericInstance.MaxParams; i++)
            {
                var subType = MemoryProxy.Instance.Read<MonoType>(monoGenericInst.MonoTypes[i]);
                var subTypeCode = subType.TypeCode;

                switch (subTypeCode)
                {
                    case TypeEnum.Class:
                    case TypeEnum.SzArray:
                    case TypeEnum.GenericInst:
                    case TypeEnum.ValueType:
                        var subTypeDef = Memory.Read<TypeDefinition>(Memory.Read<ulong>(subType.Data));
                        var subName = subTypeDef.Name;
                        if (subTypeCode == TypeEnum.GenericInst)
                            genericParams += GetGenericParams(subName, subType, ref stackProtectionCounter); // Recursive to determine nested types
                        else
                            genericParams += $"{subName}, ";
                        break;
                    default:
                        genericParams += $"{Enum.GetName(typeof(TypeEnum), subTypeCode)}, ";
                        break;
                }

            }

            genericParams = genericParams.TrimEnd(',', ' ');
            name += $"<{genericParams}>";

            return name;
        }

        public TypeDefinition? GetFieldType()
        {
            var monoType = Memory.Read<MonoType>(Type);

            var typeCode = monoType.TypeCode;
            switch (typeCode)
            {
                case TypeEnum.Class:
                case TypeEnum.SzArray:
                case TypeEnum.GenericInst: // todo check generic types
                case TypeEnum.ValueType:
                    var typeDef = Memory.Read<TypeDefinition>(Memory.Read<ulong>(monoType.Data));
                    return typeDef;
            }

            return null;
        }

        public static MemoryProxy Memory => MemoryProxy.Instance;
    }
}
```

`TOG.App/Unispect/Classes/Structs/Generics.cs`:

```cs
using System.Runtime.InteropServices;

namespace Unispect
{
    // For more detail see: https://github.com/Unity-Technologies/mono/blob/unity-2018.4-mbe/mono/metadata/class-internals.h 
    public struct MonoGenericClass
    {
        public ulong ContainerClass; // MonoClass 0x0
        public MonoGenericContext Context;
    }

    public struct MonoGenericContext
    {
        public ulong ClassInstance; // MonoGenericInstance
        public ulong MethodInstance;
    }

    public struct MonoGenericInstance
    {
        public const int MaxParams = 10;
        public int Id;
        public int BitField;

        // If there are instances where the params go over 10, probably want to investigate it manually...
        // Because Something<t1,t2,t3,t4,t5,t6,t7,t8,t9,t10> seems pretty nuts.
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = MaxParams)]
        public ulong[] MonoTypes;
    }
}
```

`TOG.App/Unispect/Classes/Structs/InternalHashTable.cs`:

```cs
namespace Unispect
{
    public struct InternalHashTable //MonoInternalHashTable
    {
        public ulong HashFunc;      // GHashFunc*
        public ulong KeyExtract;    // MonoInternalHashKeyExtractFunc*
        public ulong NextValue;     // MonoInternalHashNextValueFunc*
        public int Size;            // gint
        public int NumEntries;      // gint
        public ulong Table;         // gpointer*
    }
}
```

`TOG.App/Unispect/Classes/Structs/MonoType.cs`:

```cs
using System;

namespace Unispect
{
    [Serializable]
    public struct MonoType // MonoType
    {
        public ulong Data;
        public int Attributes;
        public int Modifiers;

        public bool IsStatic => (Attributes & 0x10) == 0x10;

        public bool IsConstant => (Attributes & 0x40) == 0x40;

        public bool HasValue => IsConstant || IsStatic;

        public TypeEnum TypeCode => (TypeEnum)(0xFF & (Attributes >> 16));
    }
}

//struct _MonoType
//{
//    union {
//        MonoClass* klass; /* for VALUETYPE and CLASS */
//        MonoType* type;   /* for PTR */
//        MonoArrayType* array; /* for ARRAY */
//        MonoMethodSignature* method;
//        MonoGenericParam* generic_param; /* for VAR and MVAR */
//        MonoGenericClass* generic_class; /* for GENERICINST */
//    }
//    data;
//    unsigned int attrs    : 16; /* param attributes or field flags */
//    MonoTypeEnum type     : 8;
//    unsigned int num_mods : 6;  /* max 64 modifiers follow at the end */
//    unsigned int byref    : 1;
//    unsigned int pinned   : 1;  /* valid when included in a local var signature */
//    MonoCustomMod modifiers[MONO_ZERO_LEN_ARRAY]; /* this may grow */
//};
```

`TOG.App/Unispect/Classes/Structs/TypeDefinition.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace Unispect
{
    [Serializable]
    [StructLayout(LayoutKind.Explicit)]
    public struct TypeDefinition // _MonoClassDef
    {
        #region Fields

        // For more information, see: https://github.com/Unity-Technologies/mono/blob/unity-2018.4-mbe/mono/metadata/class-internals.h
        [FieldOffset(0x0)] public ulong ElementClass; // MonoClass* element class for arrays and enum basetype for enums
        [FieldOffset(0x8)] public ulong CastClass; // MonoClass* used for subtype checks
        [FieldOffset(0x10)] public ulong SuperTypes; // MonoClass** for fast subtype checks
        [FieldOffset(0x18)] public ushort IDepth;
        [FieldOffset(0x1A)] public byte Rank; // array dimension

        //[FieldOffset(0x1B)] public byte undefined;
        [FieldOffset(0x1C)] public int InstanceSize; 

        // I won't implement a bitfield here, but I'll use the first byte for bit operations anyway
        [FieldOffset(0x20)] public byte BitByte;
        [FieldOffset(0x20)] public uint BitFields0; // Type storage bitfield
        [FieldOffset(0x24)] public uint BitFields1;
        [FieldOffset(0x28)] public uint BitFields2;
        [FieldOffset(0x2C)] public uint BitFields3;

        [FieldOffset(0x30)] public ulong Parent; // monoClass*
        [FieldOffset(0x38)] public ulong NestedIn; // monoClass*

        [FieldOffset(0x40)] public ulong Image; // monoImage*

        [FieldOffset(0x48)] public ulong NamePtr; // const char *name
        [FieldOffset(0x50)] public ulong NamespacePtr; // const char *name_space

        [FieldOffset(0x58)] public uint TypeToken;
        [FieldOffset(0x5C)] public int VTableSize;

        [FieldOffset(0x60)] public ushort InterfaceCount;
        [FieldOffset(0x64)] public uint InterfaceId;
        [FieldOffset(0x68)] public uint MaxInterfaceId;

        [FieldOffset(0x6c)] public ushort InterfaceOffsetsCount;

        [FieldOffset(0x70)] public ulong InterfacesPacked; // MonoClass**
        [FieldOffset(0x78)] public ulong InterfaceOffsetsPacked; //guint16*
        [FieldOffset(0x80)] public ulong InterfaceBitmap; //guint8*
        [FieldOffset(0x88)] public ulong Interfaces; // MonoClass**
        [FieldOffset(0x90)] public int Sizes; // union{ class_size, element_size, generic_param_token}

        [FieldOffset(0x98)] public ulong Fields; // MonoClassField*

        [FieldOffset(0xA0)] public ulong Methods; // MonoMethod**

        // Used as the type of the this argument and when passing the arg by value
        [FieldOffset(0xA8)] public MonoType ThisArg;
        [FieldOffset(0xB8)] public MonoType ByValArg;

        [FieldOffset(0xC8)] public ulong GcDesc; // MonoGCDescriptor  
        [FieldOffset(0xd0)] public ulong RuntimeInfo; // MonoClassRuntimeInfo  

        [FieldOffset(0xd8)] public ulong VTable; // MonoMethod**

        [FieldOffset(0xe0)] public ulong InfrequentData; //MonoPropertyBag  

        [FieldOffset(0xe8)] public ulong UnityUserData; // void*

        [FieldOffset(0xF0)] public int Flags;
        [FieldOffset(0xF4)] public int FirstMethodIdx;
        [FieldOffset(0xF8)] public int FirstFieldIdx;
        [FieldOffset(0xFC)] public int MethodCount;
        [FieldOffset(0x100)] public int FieldCount;

        [FieldOffset(0x108)] public ulong NextClassCache;

        #endregion

        public string Name
        {
            get
            {
                var cacheHash = NamePtr + NestedIn * (uint)ClassType;
                if (CacheStore.ClassNameCache.ContainsKey(cacheHash))
                    return CacheStore.ClassNameCache[cacheHash];

                var name = GetName();
                CacheStore.ClassNameCache.AddOrUpdate(cacheHash, name, (arg1, s) => s);
                return name;
            }
        }

        public string Namespace
        {
            get
            {
                if (CacheStore.ClassNamespaceCache.ContainsKey(NamePtr))
                    return CacheStore.ClassNamespaceCache[NamePtr];

                var name = GetNamespace();
                CacheStore.ClassNamespaceCache.AddOrUpdate(NamePtr, name, (arg1, s) => s);
                return name;
            }
        }



        public bool IsValueType => ((BitByte >> 2) & 1) == 0x1;
        public bool IsEnum => ((BitByte >> 3) & 1) == 0x1; // todo get enum values
        public bool IsInterface => ((BitByte >> 4) & 1) == 0x1; // blittable

        public UnknownPrefix ClassType
        {
            get
            {
                if (IsEnum) return UnknownPrefix.GEnum;
                if (IsValueType) return UnknownPrefix.GStruct;
                if (IsInterface) return UnknownPrefix.GInterface;
                return UnknownPrefix.GClass;
            }
        }

        public List<TypeDefinition> GetInterfaces()
        {
            var interfaces = new List<TypeDefinition>();
            if (Interfaces != 0 && InterfaceCount > 0)
            {
                for (uint i = 0; i < InterfaceCount; i++)
                {
                    var iface = Memory.Read<ulong>(Interfaces + i * 8);
                    var ifaceDef = Memory.Read<TypeDefinition>(iface);
                    interfaces.Add(ifaceDef);
                }
            }

            return interfaces;
        }

        public TypeDefinition? GetParent()
        {
            if (Parent == 0) return null;
            return Memory.Read<TypeDefinition>(Parent);
        }

        public List<TypeDefinition> GetSuperTypes()
        {
            //var parent = Memory.Read<TypeDefinition>(Parent);
            var superTypes = new List<TypeDefinition>();
            for (uint i = 0; i < IDepth; i++)
            {
                var super = Memory.Read<ulong>(SuperTypes + i * 8);
                var superDef = Memory.Read<TypeDefinition>(super);
                superTypes.Add(superDef);
            }

            return superTypes;
        }

        public string GetClassType()
        {
            if (IsEnum)
                return "Enum";

            if (IsValueType)
                return "Struct";

            if (IsInterface)
                return "Interface";

            return "Class";
        }

        public string GetFullName()
        {
            var nestedIn = NestedIn;
            var sb = new StringBuilder();

            var nestHierarchy = new List<string>();
            while (nestedIn != 0)
            {
                var nType = Memory.Read<TypeDefinition>(nestedIn);

                nestHierarchy.Add(nType.Name);

                nestedIn = nType.NestedIn;
            }

            nestHierarchy.Reverse();
            foreach (var nhName in nestHierarchy)
            {
                sb.Append(nhName + ".");
            }

            return $"{Namespace}.{(sb.Length > 0 ? sb.ToString().TrimEnd('.') + "." : "")}{Name}";
        }

        private string GetName()
        {
            if (NamePtr == 0)
                return "<NoName>";

            var b = Memory.Read(NamePtr, 1024);
            var code = b[0];
            if (code >= 0xE0)
            {
                var prefix = UnknownPrefix.GClass;

                if (IsEnum)
                    prefix = UnknownPrefix.GEnum;
                else if (IsValueType)
                    prefix = UnknownPrefix.GStruct;
                else if (IsInterface)
                    prefix = UnknownPrefix.GInterface;

                var unkTypeStr = b.ToUnknownClassString(prefix, TypeToken);
                return unkTypeStr;
                // Todo: add support for more general obfuscated names
                //Valid Names Match = @"^[a-zA-Z_<{$][a-zA-Z_0-9<>{}$.`-]*$"
            }

            var str = b.ToAsciiString();
            return str;
        }


        private string GetNamespace()
        {
            if (NamespacePtr == 0)
                return "<NoNamespace>";

            var b = Memory.Read(NamespacePtr, 1024);

            if (b[0] == 0)
                return "-";

            var str = b.ToAsciiString();

            return str;
        }

        public override string ToString()
        {
            return GetFullName();
        }

        public List<FieldDefinition> GetFields()
        {
            var fields = new List<FieldDefinition>();
            var fieldArrayBase = Fields;
            if (fieldArrayBase == 0)
            {
                if (Parent == 0) return null;
                goto checkParents;
            }

            for (var fIndex = 0u; fIndex < FieldCount; fIndex++)
            {
                // 0x20 == Marshal.SizeOf<FieldDefinition>();
                var field = Memory.Read<FieldDefinition>(fieldArrayBase + fIndex * 0x20);
                if (field.Type == 0)
                    break;

                fields.Add(field);
            }

        checkParents:
            if (Parent != 0)
            {
                // recursive
                var parent = Memory.Read<TypeDefinition>(Parent);
                var parentFields = parent.GetFields();
                if (parentFields != null)
                    fields.AddRange(parentFields);
            }

            var ret = fields.OrderBy(field => field.Offset).ToList();

            return ret;
        }

        public static MemoryProxy Memory => MemoryProxy.Instance;
    }
}
```

`TOG.App/Unispect/Classes/UnispectPluginAttribute.cs`:

```cs
using System;

namespace Unispect
{
    [AttributeUsage(AttributeTargets.Class)]
    public class UnispectPluginAttribute : Attribute
    {
        public UnispectPluginAttribute()
        {
        }

        public UnispectPluginAttribute(string description)
        {
            Description = description;
        }

        public string Description { get; set; }
    }
}
```

`TOG.App/Unispect/Classes/Utilities.cs`:

```cs
//using MahApps.Metro.Controls;
//using MahApps.Metro.Controls.Dialogs;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
//using System.Windows.Media.Animation;

namespace Unispect
{
    public static class Utilities
    {
        private static readonly Dictionary<ulong, string> UnknownClassNameCache = new Dictionary<ulong, string>();

        private static Dictionary<string, int> _prefixIndexer;

        private static Dictionary<string, int> PrefixIndexer
        {
            get
            {
                if (_prefixIndexer != null)
                    return _prefixIndexer;

                _prefixIndexer = new Dictionary<string, int>();
                foreach (var e in Enum.GetNames(typeof(UnknownPrefix)))
                    _prefixIndexer.Add(e, 0);

                return _prefixIndexer;
            }
        }

        public static string ToUnknownClassString(this byte[] _, UnknownPrefix prefix, uint token)
        {
            var hash = (token - 0x2000000) * (uint)prefix;
            if (UnknownClassNameCache.ContainsKey(hash))
                return UnknownClassNameCache[hash];

            var prefixName = Enum.GetName(typeof(UnknownPrefix), prefix);
            //var str = $"{prefixName}{PrefixIndexer[prefixName ?? throw new InvalidOperationException()]++:0000}";
            var str = $"{prefixName}{hash:X4}";
            UnknownClassNameCache.Add(hash, str);

            return str;
        }

        public static string GetSimpleTypeKeyword(this string text)
        {
            var ret = text.Replace("System.", "");
            switch (ret)
            {
                case "Void": return "void";
                case "Object": return "object";
                case "String": return "string";

                case "Boolean": return "bool";

                case "Single": return "float";
                case "Double": return "double";

                case "Byte": return "byte";

                case "SByte": return "sbyte";

                case "Int16": return "short";
                case "Int32": return "int";
                case "Int64": return "long";

                case "UInt16": return "ushort";
                case "UInt32": return "uint";
                case "UInt64": return "ulong";
            }

            return ret;
        }

        public static IEnumerable<int> Step(int fromInclusive, int toExclusive, int step)
        {
            for (var i = fromInclusive; i < toExclusive; i += step)
            {
                yield return i;
            }
        }

        public static string ToAsciiString(this byte[] buffer, int start = 0)
        {
            var length = 0;
            for (var i = start; i < buffer.Length; i++)
            {
                if (buffer[i] != 0) continue;

                length = i - start;
                break;
            }

            return Encoding.ASCII.GetString(buffer, start, length);
        }

        public static string LowerChar(this string str, int index = 0)
        {
            if (index < str.Length && index > -1) // instead of casting from uint, just check if it's zero or greater
            {
                if (index == 0)
                    return char.ToLower(str[index]) + str.Substring(index + 1);

                return str.Substring(0, index - 1) + char.ToLower(str[index]) + str.Substring(index + 1);
            }

            return str;
        }

        public static string FormatFieldText(this string text)
        {
            var ret = text.Replace("[]", "Array");
            var lessThanIndex = ret.IndexOf('<');
            if (lessThanIndex > -1)
            {
                // The type name _should_ always end at the following index, so we don't need to splice.
                //var greaterThanIndex = ret.IndexOf('>'); 
                ret = ret.Substring(0, lessThanIndex);
            }

            return ret;
        }

        public static string SanitizeFileName(this string fileName)
        {
            var invalidChars = Path.GetInvalidFileNameChars();
            var pattern = invalidChars.Aggregate("[", (current, c) => current + $"\\{c}") + "]";
            var ret = Regex.Replace(fileName, pattern, "_");

            return ret;
        }

        public static int ToInt32(this byte[] buffer, int start = 0) => BitConverter.ToInt32(buffer, start);

        public static string CurrentVersion
        {
            get
            {
                var assembly = Assembly.GetExecutingAssembly();
                var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);
                return fileVersionInfo.ProductVersion;
            }
        }

        public static string GithubLink => "http://www.github.com/Razchek/Unispect";

        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wp, IntPtr lp);

        [DllImport("user32.dll")]
        private static extern IntPtr GetSystemMenu(IntPtr hWnd, bool bRevert);

        [DllImport("user32.dll")]
        private static extern int TrackPopupMenu(IntPtr hMenu, uint uFlags, int x, int y,
            int nReserved, IntPtr hWnd, IntPtr prcRect);

        [DllImport("user32.dll")]
        private static extern bool GetWindowRect(IntPtr hWnd, out IntRect rect);

        public struct IntRect
        {
            public int Left, Top, Right, Bottom;
        }

        //public static void ShowSystemMenu(Window window)
        //{
        //    var hWnd = new System.Windows.Interop.WindowInteropHelper(window).Handle;
        //    GetWindowRect(hWnd, out var pos);
        //    var hMenu = GetSystemMenu(hWnd, false);
        //    var cmd = TrackPopupMenu(hMenu, 0x100, pos.Left + 20, pos.Top + 20, 0, hWnd, IntPtr.Zero);
        //    if (cmd > 0) SendMessage(hWnd, 0x112, (IntPtr)cmd, IntPtr.Zero);
        //}


        //public static async void LaunchUrl(string url)
        //{
        //    try
        //    {
        //        Mouse.OverrideCursor = Cursors.AppStarting;
        //        Process.Start(url);
        //    }
        //    catch (Exception ex)
        //    {
        //        Mouse.OverrideCursor = null;
        //        var nl = Environment.NewLine;
        //        await MessageBox(
        //            $"Couldn't open: {url}.{nl}{nl}Exception:{nl}{ex.Message}");
        //    }
        //    finally
        //    {
        //        Mouse.OverrideCursor = null;
        //    }

        //}

        //public static async Task<MessageDialogResult> MessageBox(string msg, string title = "",
        //    MessageDialogStyle messageDialogStyle = MessageDialogStyle.Affirmative,
        //    MetroDialogSettings metroDialogSettings = null)
        //{
        //    if (string.IsNullOrEmpty(title))
        //        title = Application.Current.MainWindow?.Title;

        //    var mw = (Application.Current.MainWindow as MetroWindow);
        //    return await mw.ShowMessageAsync(title, msg, messageDialogStyle, metroDialogSettings);
        //}

        //public static void FadeFromTo(this UIElement uiElement, double fromOpacity, double toOpacity,
        //    int durationInMilliseconds, bool showOnStart, bool collapseOnFinish)
        //{
        //    var timeSpan = TimeSpan.FromMilliseconds(durationInMilliseconds);
        //    var doubleAnimation =
        //        new DoubleAnimation(fromOpacity, toOpacity,
        //            new Duration(timeSpan));

        //    uiElement.BeginAnimation(UIElement.OpacityProperty, doubleAnimation);
        //    if (showOnStart)
        //    {
        //        uiElement.ApplyAnimationClock(UIElement.VisibilityProperty, null);
        //        uiElement.Visibility = Visibility.Visible;
        //    }
        //    if (collapseOnFinish)
        //    {
        //        var keyAnimation = new ObjectAnimationUsingKeyFrames { Duration = new Duration(timeSpan) };
        //        keyAnimation.KeyFrames.Add(new DiscreteObjectKeyFrame(Visibility.Collapsed, KeyTime.FromTimeSpan(timeSpan)));
        //        uiElement.BeginAnimation(UIElement.VisibilityProperty, keyAnimation);
        //    }
        //}

        //public static void FadeIn(this UIElement uiElement, int durationInMilliseconds = 100)
        //{
        //    uiElement.FadeFromTo(0, 1, durationInMilliseconds, true, false);
        //}

        //public static void FadeOut(this UIElement uiElement, int durationInMilliseconds = 100)
        //{
        //    uiElement.FadeFromTo(1, 0, durationInMilliseconds, false, true);
        //}

        //public static void ResizeFromTo(this FrameworkElement uiElement, Size fromSize, Size toSize, int durationInMilliseconds)
        //{
        //    var timeSpan = TimeSpan.FromMilliseconds(durationInMilliseconds);

        //    //var sizeAnimationWidth = new DoubleAnimation(fromSize.Width, toSize.Width, new Duration(timeSpan));
        //    var sizeAnimationHeight = new DoubleAnimation(fromSize.Height, toSize.Height, new Duration(timeSpan));

        //    //uiElement.BeginAnimation(FrameworkElement.WidthProperty, sizeAnimationWidth);
        //    uiElement.BeginAnimation(FrameworkElement.HeightProperty, sizeAnimationHeight);
        //}
    }
}
```

`TOG.App/Unispect/Classes/Wrappers/FieldDefWrapper.cs`:

```cs
using System;
using System.Linq;

namespace Unispect
{
    [Serializable]
    public class FieldDefWrapper
    {
        public FieldDefinition InnerDefinition;

        public FieldDefWrapper(FieldDefinition fieldDef/*, bool getFieldTypeDef = true*/)
        {
            InnerDefinition = fieldDef;

            Name = InnerDefinition.Name;

            FieldType = InnerDefinition.GetFieldTypeString();

            // Todo: if 'FieldTypeDefinition' gets used elsewhere, consider re-implementing the following:
            //if (getFieldTypeDef)
            //{
            //    var fdType = InnerDefinition.GetFieldType();
            //    if (fdType.HasValue)
            //        FieldTypeDefinition = new TypeDefWrapper(fdType.Value, getSubField: false);
            //}

            Offset = InnerDefinition.Offset;

            var typeCode = InnerDefinition.TypeCode;
            
            var isPointer = false;
            switch (typeCode)
            {
                case TypeEnum.Class:
                case TypeEnum.SzArray:
                case TypeEnum.GenericInst:
                    isPointer = true;
                    break;
            }

            IsPointer = isPointer;
            IsValueType = typeCode == TypeEnum.ValueType;

            HasValue = InnerDefinition.HasValue(out var valType);
            ConstantValueType = HasValue ? $" [{valType}]": "";

        }

        public string Name { get; }

        public string FieldType { get; }
        
        public bool HasValue { get; }
        public string ConstantValueType { get; }
        public string ConstantValueTypeShort => HasValue ? $"{ConstantValueType[2]}" : "";

        public bool IsValueType { get; }
        public bool IsPointer { get; }

        public TypeDefWrapper FieldTypeDefinition { get; }

        public TypeDefWrapper Parent { get; set; }

        public int Offset { get; set; }

        public string OffsetHex => $"[{Offset:X2}]";

        public static implicit operator FieldDefWrapper(FieldDefinition fieldDef)
        {
            return new FieldDefWrapper(fieldDef);
        }

        public override string ToString()
        {
            return $"[{Offset:X2}]{ConstantValueTypeShort} {Name} : {FieldType}";
        }

        public int GetValue()
        {
            // Todo solve and implement 
            throw new NotImplementedException();
            var type = System.Type.GetType(FieldType);
            var fieldType = MemoryProxy.Instance.Read<MonoType>(InnerDefinition.Type);
            
            var vTable = MemoryProxy.Instance.Read<ulong>(Parent.InnerDefinition.RuntimeInfo+8);

            var staticFieldsOffset = (uint)Parent.InnerDefinition.VTableSize * 8 + 0x40;

            if (MemoryProxy.Instance.Read<ulong>(vTable+staticFieldsOffset) > 0)
            {
                return 1;
            }

            return 0 ;
            if (type != null)
            {
                var mem = typeof(BasicMemory);
                var method = mem.GetMethods().First(m => m.IsGenericMethod);
                var castedMethod = method.MakeGenericMethod(type);
                var x = castedMethod.Invoke(MemoryProxy.Instance, new object[] { Parent.InnerDefinition.VTable + 0x18, 0 });

            }
            return 0;
        }
    }
}
```

`TOG.App/Unispect/Classes/Wrappers/TypeDefWrapper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Unispect
{
    [Serializable]
    public class TypeDefWrapper
    {
        public TypeDefinition InnerDefinition;

        private string ReplaceGenericDefs(string name)
        {
            // Todo find generic params for monoclass defs
            throw new NotImplementedException();
            // We're doing this in the wrapper because we don't want to affect field data
            var genericIndexOf = name.IndexOf('`');
            if (genericIndexOf < 0) return name;

            if (int.TryParse(name.Substring(genericIndexOf + 1, 1), out var paramCount))
            {
                var ret = "T";
                if (paramCount > 1)
                {
                    for (var i = 1; i < paramCount; i++)
                        ret += $", T{i}";
                }

                return $"{name.Replace($"`{paramCount}", $"<{ret }")}>";
            }

            return name;
        }

        public TypeDefWrapper(TypeDefinition typeDef, bool isExtended = false/*, bool getSubField = true*/)
        {
            InnerDefinition = typeDef;

            FullName = InnerDefinition.GetFullName();

            Name = InnerDefinition.Name;
            Namespace = InnerDefinition.Namespace;
            ClassType = InnerDefinition.GetClassType();

            var parent = InnerDefinition.GetParent();
            if (parent.HasValue)
            {
                Parent = new TypeDefWrapper(parent.Value, true);
                ParentName = Parent.Name;
            }

            if (isExtended)
                return;

            var fields = InnerDefinition.GetFields();
            // Todo: if 'FieldTypeDefinition' gets used elsewhere, consider re-implementing the following:
            //if (fields != null)
            //{
            //    foreach (var field in fields)
            //    {
            //        var fdw = new FieldDefWrapper(field, getSubField);
            //        if (fdw.Name == "<ErrorReadingField>") continue;
            //        Fields.Add(fdw);
            //    }
            //}
            if (fields != null)
                Fields.AddRange(fields.Select(field => (FieldDefWrapper)field)
                    .Where(w => w.Name != "<ErrorReadingField>"));
            // bug Skipping invalid fields until I solve the issue

            var interfaces = InnerDefinition.GetInterfaces();
            if (interfaces != null)
            {
                foreach (var iface in interfaces)
                {
                    Interfaces.Add(new TypeDefWrapper(iface, true));
                }
            }
            InterfacesText = Interfaces.Aggregate("", (current, iface) => current + $", {iface.Name}");

            foreach (var f in Fields)
            {
                f.Parent = this;

                // If the type is ValueType and the field is not static, then we need to shift the offset back by 0x10.
                // I'm not sure why, but in all my tests this has been validated.
                if (InnerDefinition.IsValueType)
                {
                    if (!f.HasValue)
                    {
                        f.Offset -= 0x10;
                    }
                }

                //if (f.HasValue)
                //{
                //    //if (f.ValueTypeShort == "S") f.GetValue();
                //}
            }
        }

        public string ClassType { get; }

        public string Namespace { get; }

        public string Name { get; }

        public string FullName { get; }
        public TypeDefWrapper Parent { get; }
        public string ParentName { get; }

        public List<FieldDefWrapper> Fields { get; } = new List<FieldDefWrapper>();
        public List<TypeDefWrapper> Interfaces { get; } = new List<TypeDefWrapper>();

        public string InterfacesText { get; }

        public static implicit operator TypeDefWrapper(TypeDefinition typeDef)
        {
            return new TypeDefWrapper(typeDef);
        }

        #region Formatters
        public string ToTreeString(bool skipValueTypes = true)
        {
            var sb = new StringBuilder();
            sb.Append($"[{ClassType}] ");
            sb.Append(FullName);

            var parent = Parent;
            if (parent != null)
            {
                sb.Append($" : {parent.Name}");
                var interfaceList = Interfaces;
                if (interfaceList.Count > 0)
                {
                    foreach (var iface in interfaceList)
                    {
                        sb.Append($", {iface.Name}");
                    }
                }
            }

            sb.AppendLine();

            foreach (var field in Fields)
            {
                if (skipValueTypes && field.HasValue)
                    continue;

                var fieldName = field.Name;
                var fieldType = field.FieldType;
                sb.AppendLine(field.HasValue
                    ? $"    [{field.Offset:X2}][{field.ConstantValueTypeShort}] {fieldName} : {fieldType}"
                    : $"    [{field.Offset:X2}] {fieldName} : {fieldType}");
            }

            return sb.ToString();
        }

        public string ToCSharpString(string ptrName = "ulong", bool skipValueTypes = true)
        {
            var sb = new StringBuilder();

            sb.Append($"public struct {Name}");

            var parent = Parent;
            if (parent != null)
            {
                sb.Append($" // {FullName} : {parent.Name}");
                var interfaceList = Interfaces;
                if (interfaceList.Count > 0)
                {
                    foreach (var iface in interfaceList)
                    {
                        sb.Append($", {iface.Name}");
                    }
                }
            }

            sb.AppendLine();
            sb.AppendLine("{");

            foreach (var field in Fields)
            {
                if (skipValueTypes && field.HasValue)
                    continue;

                var fieldName = field.Name;
                var fieldType = field.FieldType;

                var isPointer = field.IsPointer || fieldType == "String";

                sb.AppendLine(isPointer
                    ? $"    [FieldOffset(0x{field.Offset:X2})] public {ptrName} {fieldName}; // {fieldType.GetSimpleTypeKeyword()}"
                    : $"    [FieldOffset(0x{field.Offset:X2})] public {fieldType.GetSimpleTypeKeyword()} {fieldName};");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }
        #endregion
    }
}
```

`TOG.App/Unispect/Enums/Offsets.cs`:

```cs
// -ReSharper disable UnusedMember.Global
// todo: move all structs into their own class files maybe
namespace Unispect
{
    // Structures and offsets created manually with references to the module memory, IDA disassembly with pdb and:
    // https://github.com/Unity-Technologies/mono/blob/unity-2018.4-mbe

    internal static class Offsets
    {
        public const int ImageDosHeaderELfanew = 0x3c; // PtrToPEHeader -> e_lfanew
        //public const int ImageNtHeadersSignature = 0x0;
        //public const int ImageNtHeadersMachine = 0x4;
        public const int ImageNtHeadersExportDirectoryAddress = 0x88;
        public const int ImageExportDirectoryNumberOfFunctions = 0x14;
        public const int ImageExportDirectoryAddressOfFunctions = 0x1c;
        public const int ImageExportDirectoryAddressOfNames = 0x20;

        // These could be a part of structs, but for convenience I'll leave them here.
        public const int ImageClassCache = 0x4C0;       // MonoImage.ClassCache
        public const int DomainDomainAssemblies = 0xC8; // MonoDomain.DomainAssemblies
        public const int AssemblyImage = 0x60;          // MonoAssembly.MonoImage
        public const int ClassNextClassCache = 0x108;   // MonoClassDef.NextClassCache
    }
}
```

`TOG.App/Unispect/Enums/TypeEnum.cs`:

```cs
namespace Unispect
{
    /// <summary>
    /// Represents the type of an object in managed memory.
    /// See: MonoTypeEnum in https://github.com/Unity-Technologies/mono/blob/unity-master/mono/metadata/blob.h.
    /// </summary>
    public enum TypeEnum // MonoTypeEnum
    {
        End = 0x00, // End of list

        Void = 0x01,

        Boolean = 0x02,
        Char = 0x03,
        Byte = 0x04,
        SByte = 0x05,

        Int16 = 0x06,
        UInt16 = 0x07,

        Int32 = 0x08,
        UInt32 = 0x09,

        Int64 = 0x0A,
        UInt64 = 0x0B,

        Single = 0x0C,
        Double = 0x0d,

        String = 0x0e,

        Ptr = 0x0f,         /* arg: <type> token */
        ByRef = 0x10,       /* arg: <type> token */
        ValueType = 0x11,   /* arg: <type> token */
        Class = 0x12,       /* arg: <type> token */
        Var = 0x13,         /* number */
        Array = 0x14,       /* type, rank, boundsCount, bound1, loCount, lo1 */
        GenericInst = 0x15, /* <type> <type-arg-count> <type-1> \x{2026} <type-n> */
        TypedByRef = 0x16,

        IntPtr = 0x18,
        UIntPtr = 0x19,

        FnPtr = 0x1b,       /* arg: full method signature */

        Object = 0x1c,

        SzArray = 0x1d,     /* 0-based one-dim-array */
        MVar = 0x1e,        /* number */

        CModReqd = 0x1f,   /* arg: typedef or typeref token */
        CModOpt = 0x20,    /* optional arg: typedef or typref token */
        Internal = 0x21,    /* CLR internal type */
        Modifier = 0x40,    /* Or with the following types */
        Sentinel = 0x41,    /* Sentinel for varargs method signature */
        Pinned = 0x45,      /* Local var that points to pinned object */
        Enum = 0x55         /* an enumeration */

        /* Taken from IDA (I had issues, seems they were all valid anyway ..)
             ; enum MonoTypeEnum,
             MONO_TYPE_END    = 0
             MONO_TYPE_VOID   = 1
             MONO_TYPE_BOOLEAN  = 2
             MONO_TYPE_CHAR   = 3
             MONO_TYPE_I1     = 4
             MONO_TYPE_U1     = 5
             MONO_TYPE_I2     = 6
             MONO_TYPE_U2     = 7
             MONO_TYPE_I4     = 8
             MONO_TYPE_U4     = 9
             MONO_TYPE_I8     = 0Ah
             MONO_TYPE_U8     = 0Bh
             MONO_TYPE_R4     = 0Ch
             MONO_TYPE_R8     = 0Dh
             MONO_TYPE_STRING  = 0Eh
             MONO_TYPE_PTR    = 0Fh
             MONO_TYPE_BYREF  = 10h
             MONO_TYPE_VALUETYPE  = 11h
             MONO_TYPE_CLASS  = 12h
             MONO_TYPE_VAR    = 13h
             MONO_TYPE_ARRAY  = 14h
             MONO_TYPE_GENERICINST  = 15h
             MONO_TYPE_TYPEDBYREF  = 16h
             MONO_TYPE_I      = 18h
             MONO_TYPE_U      = 19h
             MONO_TYPE_FNPTR  = 1Bh
             MONO_TYPE_OBJECT  = 1Ch
             MONO_TYPE_SZARRAY  = 1Dh
             MONO_TYPE_MVAR   = 1Eh
             MONO_TYPE_CMOD_REQD  = 1Fh
             MONO_TYPE_CMOD_OPT  = 20h
             MONO_TYPE_INTERNAL  = 21h
             MONO_TYPE_MODIFIER  = 40h
             MONO_TYPE_SENTINEL  = 41h
             MONO_TYPE_PINNED  = 45h
             MONO_TYPE_ENUM   = 55h
        */
    }
}
```

`TOG.App/Unispect/Enums/UnknownPrefix.cs`:

```cs
namespace Unispect
{
    public enum UnknownPrefix
    {
        GClass = 1,
        GStruct = 2,
        GEnum = 3,
        GAttribute = 4,
        GInterface = 5,
    }
}
```

`TOG.App/Usings.cs`:

```cs
global using Newtonsoft.Json;
global using System.Diagnostics;
```

`TOG.Common/Exceptions/LastWin32Exception.cs`:

```cs
namespace TOG.Common.Exceptions;

public class LastWin32Exception : Exception
{
    public LastWin32Exception(string methodName) : base($"calling {methodName}: {Marshal.GetLastWin32Error()}")
    {
    }
}

```

`TOG.Common/Helpers/Logger.cs`:

```cs
namespace TOG.Common.Helpers;

public enum LogType
{
    None,
    Error,
    Info,
    Warning,
    Success
}

/// <summary>
/// TODO: Use Serilog
/// </summary>
public class Logger
{
    private string GetDateTimeFormatted()
        => DateTime.Now.ToString("g");

    private static List<LogInfo> logInfoList = new List<LogInfo>()
    {
        new LogInfo(LogType.Error, ConsoleColor.Red, "Error  "),
        new LogInfo(LogType.Info, ConsoleColor.Blue, "Info   "),
        new LogInfo(LogType.Warning, ConsoleColor.Yellow, "Warn   "),
        new LogInfo(LogType.Success, ConsoleColor.Green, "Success")
    };

    public void Log(LogType logType, string message)
    {
        var logInfo = logInfoList.Where(x => x.Type.Equals(logType)).First();

        Console.ForegroundColor = ConsoleColor.White;
        Console.Write($"[{GetDateTimeFormatted()}] [");

        Console.ForegroundColor = logInfo.Color;
        Console.Write(logInfo.Prefix);

        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine($"] {message}");
    }

    private class LogInfo
    {
        public LogType Type { get; set; }

        public ConsoleColor Color { get; set; }

        public string Prefix { get; set; }

        public LogInfo(LogType type, ConsoleColor color, string prefix)
        {
            Type = type;
            Color = color;
            Prefix = prefix;
        }
    }

}

```

`TOG.Common/Helpers/ProcessHelper.cs`:

```cs
using PInvoke;
using TOG.Common.Exceptions;

namespace TOG.Common.Helpers;

public static class ProcessHelper
{
    public static Kernel32.PROCESS_INFORMATION CreateProcess(string path)
    {
        var lpStartupInfo = new Kernel32.STARTUPINFO();

        if (!Kernel32.CreateProcess(
            path,
            null,
            IntPtr.Zero,
            IntPtr.Zero,
            false,
            Kernel32.CreateProcessFlags.NORMAL_PRIORITY_CLASS,
            IntPtr.Zero,
            null,
            ref lpStartupInfo,
            out var pi)
        )
            throw new LastWin32Exception("CreateProcess");

        return pi;
    }

    public static Kernel32.SafeObjectHandle OpenProcess(int processId)
    {
        return Kernel32.OpenProcess(Kernel32.ACCESS_MASK.GenericRight.GENERIC_ALL, false, processId);
    }
}

```

`TOG.Common/TOG.Common.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <PlatformTarget>x64</PlatformTarget>
    <BaseOutputPath>..\bin</BaseOutputPath>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="Memory\**" />
    <EmbeddedResource Remove="Memory\**" />
    <None Remove="Memory\**" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="PInvoke.Kernel32" Version="0.7.104" />
  </ItemGroup>

</Project>

```

`TOG.Common/Templates/BaseTemplate.cs`:

```cs
using System.Text;
using TOG.Common.Helpers;

namespace TOG.Common.Templates;

public class BaseTemplate
{
    protected const char Space = '	';
    protected readonly StringBuilder _sb = new();
    protected static readonly Logger _logger = new Logger();

    public BaseTemplate() { }

    public void AddInstruction(string instruction, int intend = 2)
        => _sb.AppendLine($"{new string(Space, intend)}{instruction}");

    public void AddHeader(string? gameVersion)
    {
        AddInstruction("/*", 0);
        AddInstruction($"Generated using Deathstroke's TOG (https://github.com/patrickcjk/tog)", 1);
        AddInstruction($"At {DateTime.Now}", 1);
        AddInstruction(string.IsNullOrEmpty(gameVersion) ? "Unknown game version" : $"Game version {gameVersion}", 1);
        AddInstruction("*/", 0);
    }

    public void Build(string path)
        => File.WriteAllText(path, Build());

    public string Build()
        => _sb.ToString();

    public void SkipLine()
        => _sb.AppendLine();
}

```

`TOG.Common/Tools.cs`:

```cs
using Microsoft.Win32;

namespace TOG.Common;

public static class Tools
{
    public static string GetInstallationPath(string applicationName)
    {
        using var key = Registry.LocalMachine.OpenSubKey(@$"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{applicationName}");

        if (key == null)
            throw new Exception("install registry key not found");

        var directory = (string?)key!.GetValue("InstallLocation");

        if (string.IsNullOrEmpty(directory))
            throw new Exception("Empty install location");

        if (!Directory.Exists(directory))
            throw new Exception("install path not found");

        return directory;
    }
}

```

`TOG.Common/Usings.cs`:

```cs
global using System.Runtime.InteropServices;



```

`TOG.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32328.378
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TOG.App", "TOG.App\TOG.App.csproj", "{EDD54712-E13A-46F5-9C70-13A5FD0F5864}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TOG.Common", "TOG.Common\TOG.Common.csproj", "{2F810D6C-8660-4D36-80EB-78F34F9264EB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|x64.Build.0 = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Debug|x86.Build.0 = Debug|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|Any CPU.Build.0 = Release|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|x64.ActiveCfg = Release|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|x64.Build.0 = Release|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|x86.ActiveCfg = Release|Any CPU
		{EDD54712-E13A-46F5-9C70-13A5FD0F5864}.Release|x86.Build.0 = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|x64.Build.0 = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Debug|x86.Build.0 = Debug|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|Any CPU.Build.0 = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|x64.ActiveCfg = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|x64.Build.0 = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|x86.ActiveCfg = Release|Any CPU
		{2F810D6C-8660-4D36-80EB-78F34F9264EB}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {15E425B9-C0DB-441B-9E11-99192C9A489B}
	EndGlobalSection
EndGlobal

```