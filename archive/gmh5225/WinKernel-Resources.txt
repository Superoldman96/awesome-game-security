Project Path: arc_gmh5225_WinKernel-Resources_qut__ool

Source Tree:

```txt
arc_gmh5225_WinKernel-Resources_qut__ool
├── Drivers
│   ├── Driver-SRC
│   │   ├── DriverCommunication
│   │   │   ├── DriverCommunication
│   │   │   │   ├── DriverCommunication.inf
│   │   │   │   ├── DriverCommunication.vcxproj
│   │   │   │   ├── DriverCommunication.vcxproj.filters
│   │   │   │   └── Main.c
│   │   │   └── DriverCommunication.sln
│   │   ├── DriverHookIRP_TCP
│   │   │   ├── DriverHookIRP_TCP
│   │   │   │   ├── DriverHookIRP_TCP.inf
│   │   │   │   ├── DriverHookIRP_TCP.vcxproj
│   │   │   │   ├── DriverHookIRP_TCP.vcxproj.filters
│   │   │   │   └── hook_irp_tcp.c
│   │   │   └── DriverHookIRP_TCP.sln
│   │   ├── DriverHookSysenter
│   │   │   ├── DriverHookSysenter
│   │   │   │   ├── DriverHookSysenter.inf
│   │   │   │   ├── DriverHookSysenter.vcxproj
│   │   │   │   ├── DriverHookSysenter.vcxproj.filters
│   │   │   │   └── hook_sysenter.c
│   │   │   └── DriverHookSysenter.sln
│   │   ├── README.md
│   │   ├── elam
│   │   │   ├── README.md
│   │   │   ├── elam.sln
│   │   │   ├── elamsample.c
│   │   │   ├── elamsample.h
│   │   │   ├── elamsample.rc
│   │   │   ├── elamsample.vcxproj
│   │   │   └── elamsample.vcxproj.Filters
│   │   ├── setup
│   │   │   └── devcon
│   │   │       ├── README.md
│   │   │       ├── cmds.cpp
│   │   │       ├── devcon.cpp
│   │   │       ├── devcon.h
│   │   │       ├── devcon.rc
│   │   │       ├── devcon.sln
│   │   │       ├── devcon.vcxproj
│   │   │       ├── devcon.vcxproj.Filters
│   │   │       ├── dump.cpp
│   │   │       ├── msg.mc
│   │   │       └── rc_ids.h
│   │   ├── shellcode
│   │   │   ├── Kernel_shellcode
│   │   │   │   ├── Kernel_shellcode.vcxproj
│   │   │   │   ├── Kernel_shellcode.vcxproj.filters
│   │   │   │   ├── kernel_shellcode.c
│   │   │   │   └── pe.h
│   │   │   ├── Kernel_shellcode.sln
│   │   │   ├── Kernel_shellcode_loader
│   │   │   │   ├── Kernel_shellcode_loader.vcxproj
│   │   │   │   ├── Kernel_shellcode_loader.vcxproj.filters
│   │   │   │   └── kernel_shellcode_loader.cpp
│   │   │   ├── NameHasher
│   │   │   │   ├── NameHasher.cpp
│   │   │   │   ├── NameHasher.vcxproj
│   │   │   │   └── NameHasher.vcxproj.filters
│   │   │   └── README.md
│   │   └── wmi
│   │       ├── wmiacpi
│   │       │   ├── README.md
│   │       │   ├── acpimof.def
│   │       │   ├── acpimof.mof
│   │       │   ├── acpimof.rc
│   │       │   ├── acpimof.vcxproj
│   │       │   ├── acpimof.vcxproj.Filters
│   │       │   ├── device.asl
│   │       │   ├── wmi-acpi.htm
│   │       │   └── wmiacpi.sln
│   │       └── wmisamp
│   │           ├── README.md
│   │           ├── WmiHandler.c
│   │           ├── WmiSamp.rc
│   │           ├── WmiSamp.vcxproj
│   │           ├── WmiSamp.vcxproj.Filters
│   │           ├── wmisamp.c
│   │           ├── wmisamp.h
│   │           ├── wmisamp.inx
│   │           ├── wmisamp.mof
│   │           └── wmisamp.sln
│   └── README.md
├── LICENSE
└── README.md

```

`Drivers/Driver-SRC/DriverCommunication/DriverCommunication.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.421
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverCommunication", "DriverCommunication\DriverCommunication.vcxproj", "{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM.ActiveCfg = Debug|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM.Build.0 = Debug|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM.Deploy.0 = Debug|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM64.Build.0 = Debug|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x64.ActiveCfg = Debug|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x64.Build.0 = Debug|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x64.Deploy.0 = Debug|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x86.ActiveCfg = Debug|Win32
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x86.Build.0 = Debug|Win32
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Debug|x86.Deploy.0 = Debug|Win32
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM.ActiveCfg = Release|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM.Build.0 = Release|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM.Deploy.0 = Release|ARM
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM64.ActiveCfg = Release|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM64.Build.0 = Release|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|ARM64.Deploy.0 = Release|ARM64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x64.ActiveCfg = Release|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x64.Build.0 = Release|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x64.Deploy.0 = Release|x64
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x86.ActiveCfg = Release|Win32
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x86.Build.0 = Release|Win32
		{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A86A462D-68B9-4E0C-B546-C96341BA9885}
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/DriverCommunication/DriverCommunication/DriverCommunication.inf`:

```inf
;
; DriverCommunication.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=DriverCommunication.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="DriverCommunication Source Disk"

```

`Drivers/Driver-SRC/DriverCommunication/DriverCommunication/DriverCommunication.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{42EEF494-1888-4AF1-BF92-1F3B7DAC969F}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DriverCommunication</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="DriverCommunication.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/DriverCommunication/DriverCommunication/DriverCommunication.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DriverCommunication.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/DriverCommunication/DriverCommunication/Main.c`:

```c
#include <ntddk.h>

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
VOID Unload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

/***
*	Functions to handle different IRPs
*/
NTSTATUS MyOpen(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS MyClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS MyRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS MyWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS MyIOControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
// Driver entry point
DRIVER_INITIALIZE DriverEntry;

/*
*	Possible functions in case we want to
*	implement functionalities of open, reading,
*	writing or closing of drivers
*/

NTSTATUS MyOpen(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	DbgPrint("%s\n", "Called IRP for Open (example CreateFile of driver)");
	
	return STATUS_SUCCESS; // always return a status!!!
}

NTSTATUS MyClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	DbgPrint("%s\n", "Called IRP for close (example CloseHandle of driver)");
	
	return STATUS_SUCCESS;
}

NTSTATUS MyRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	DbgPrint("%s\n", "Called IRP for read (example ReadFile of driver)");

	return STATUS_SUCCESS;
}

NTSTATUS MyWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	DbgPrint("%s\n", "Called IRP for write (example WriteFile of driver");

	return STATUS_SUCCESS;

}

NTSTATUS MyIOControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PIO_STACK_LOCATION	IrpSp;
	ULONG				FunctionCode = 0;
	NTSTATUS			statusF = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(DeviceObject);

	// get stack of IRP to get the parameters
	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	/*
	*	From the parameters of the stack, we get the one of DeviceIoControl
	*	as it will be the function we are going to manage from MyIOControl. 
	*	Then from these we will take the IoControlCode
	*/
	FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

	switch (FunctionCode)
	{
		/*
		* Depending on function code from IoControl 
		* do different things
		*/
	case 0xDEADBEEF:
		DbgPrint("%s\n", "DEADBEEF");
		statusF = STATUS_SUCCESS;
		break;
	case 0xCAFECAFE:
		DbgPrint("%s\n", "CAFECAFE");
		statusF = STATUS_SUCCESS;
		break;
	default:
		statusF = STATUS_NOT_IMPLEMENTED;
		break;
	}

	Irp->IoStatus.Status = statusF;
	
	// set the IoCompleteRequest
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return statusF;
}

// global variables
const WCHAR deviceNameBuffer[] = L"\\Device\\Example"; // name to access from user space to the driver
const WCHAR deviceLinkBuffer[] = L"\\DosDevices\\Alias"; // alias of the driver

PDEVICE_OBJECT g_rootkitdevice; // global pointer to our device object

/*
*	Generic function for IRP 
*/
NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);
	DbgPrint("%s\n", "Driver unloaded.");
	return;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	NTSTATUS		ntStatus;
	UNICODE_STRING	deviceNameUnicodeString;
	UNICODE_STRING	deviceLinkUnicodeString;
	size_t			i;

	UNREFERENCED_PARAMETER(RegistryPath);

	// get name and symbolic link in unicode
	RtlInitUnicodeString(&deviceNameUnicodeString, deviceNameBuffer);
	RtlInitUnicodeString(&deviceLinkUnicodeString, deviceLinkBuffer);

	// create the device
	ntStatus = IoCreateDevice(DriverObject,
		0,							// for driver extention
		&deviceNameUnicodeString,	// device name
		0x00001234,					// device type
		0,							// characteristics
		TRUE,						// Exclusive
		&g_rootkitdevice			// pointer to device object
	);

	if (NT_SUCCESS(ntStatus))
	{
		// set symbolic name
		ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString, &deviceNameUnicodeString);
	}

	// set unload function
	DriverObject->DriverUnload = Unload;

	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		// set Major functions
		// set all of them to OnStubDispatch and then
		// we will set the others
		DriverObject->MajorFunction[i] = OnStubDispatch;
	}

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= MyIOControl;
	DriverObject->MajorFunction[IRP_MJ_READ]			= MyRead;
	DriverObject->MajorFunction[IRP_MJ_WRITE]			= MyWrite;
	DriverObject->MajorFunction[IRP_MJ_CREATE]			= MyOpen;
	DriverObject->MajorFunction[IRP_MJ_CLOSE]			= MyClose;

	return STATUS_SUCCESS;
}
```

`Drivers/Driver-SRC/DriverHookIRP_TCP/DriverHookIRP_TCP.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.421
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverHookIRP_TCP", "DriverHookIRP_TCP\DriverHookIRP_TCP.vcxproj", "{44561AA2-5FAC-475E-A2D2-B4BB80A24260}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM.ActiveCfg = Debug|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM.Build.0 = Debug|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM.Deploy.0 = Debug|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM64.Build.0 = Debug|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x64.ActiveCfg = Debug|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x64.Build.0 = Debug|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x64.Deploy.0 = Debug|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x86.ActiveCfg = Debug|Win32
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x86.Build.0 = Debug|Win32
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Debug|x86.Deploy.0 = Debug|Win32
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM.ActiveCfg = Release|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM.Build.0 = Release|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM.Deploy.0 = Release|ARM
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM64.ActiveCfg = Release|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM64.Build.0 = Release|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|ARM64.Deploy.0 = Release|ARM64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x64.ActiveCfg = Release|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x64.Build.0 = Release|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x64.Deploy.0 = Release|x64
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x86.ActiveCfg = Release|Win32
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x86.Build.0 = Release|Win32
		{44561AA2-5FAC-475E-A2D2-B4BB80A24260}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F7050607-C765-47B4-85ED-D39577CF32D6}
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/DriverHookIRP_TCP/DriverHookIRP_TCP/DriverHookIRP_TCP.inf`:

```inf
;
; DriverHookIRP_TCP.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=DriverHookIRP_TCP.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="DriverHookIRP_TCP Source Disk"

```

`Drivers/Driver-SRC/DriverHookIRP_TCP/DriverHookIRP_TCP/DriverHookIRP_TCP.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{44561AA2-5FAC-475E-A2D2-B4BB80A24260}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DriverHookIRP_TCP</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="DriverHookIRP_TCP.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hook_irp_tcp.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/DriverHookIRP_TCP/DriverHookIRP_TCP/DriverHookIRP_TCP.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DriverHookIRP_TCP.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hook_irp_tcp.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/DriverHookIRP_TCP/DriverHookIRP_TCP/hook_irp_tcp.c`:

```c
#include <ntddk.h>
#include <stdio.h>
#include <stdlib.h>

#include <windef.h>

/*
*	Code to modify IRPs from one driver table already present
*	in the system, so it is possible to manage the requests
*	from some programs to those drivers. 
*	On this case we will hook the use of TCP driver, used 
*	by some programs to use TCP connections.
*/

PFILE_OBJECT	pFile_tcp;
PDEVICE_OBJECT	pDev_tcp;
PDRIVER_OBJECT	pDrv_tcpip;

// TDIObjectID TCP 
#define CO_TL_ENTITY					0x400
// TDIObjectID UDP
#define CL_TL_ENTITY					0x401
// IoControlCode value for the IRP
#define IOCTL_TCP_QUERY_INFORMATION_EX	0x00120003

#define CONNINFO101_k					0x101
#define CONNINFO102_k					0x102
#define CONNINFO110_k					0x110

#define HTTP_PORT						80

// Function to get a PORT
#define HTONS(a) ( ((0xFF & a) << 8) + ((0xFF & a) >> 8))


// structure of an entity ID
typedef struct _TDIEntityID
{
	ULONG			tei_entity;
	ULONG			tei_instance;
} TDIEntityID, *PTDIEntityID;

typedef struct  _TDIObjectID
{
	TDIEntityID		toi_entity;
	ULONG			toi_class;
	ULONG			toi_type;
	ULONG			toi_id;
} TDIObjectID, *PTDIObjectID;

/*
*	Define of the mmethod to hook,it will be a function
*	to manage an IRP request  to DeviceIoControl, so
*	as parameters we will have a DEVICE_OBJECT and a
*	pointer to IRP
*/
typedef NTSTATUS(*OLDIRPMJDEVICECONTROL) (
	IN PDEVICE_OBJECT,
	IN PIRP
	);

/*
*	Buffer structures for TCP information returned by TCP.SYS
*	depends of the flag of ntstat
*/
typedef struct _CONNINFO101
{
	ULONG	status;
	ULONG	src_addr;
	USHORT	src_port;
	USHORT	unk1;
	ULONG	dst_addr;
	USHORT	dst_port;
	USHORT	unk2;
} CONNINFO101, *PCONNINFO101;

typedef struct _CONNINFO102
{
	ULONG	status;
	ULONG	src_addr;
	USHORT	src_port;
	USHORT	unk1;
	ULONG	dst_addr;
	USHORT	dst_port;
	USHORT	unk2;
	ULONG	pid;
} CONNINFO102, *PCONNINFO102;

typedef struct _CONNINFO110
{
	ULONG	size;
	ULONG	status;
	ULONG	src_addr;
	USHORT	src_port;
	USHORT	unk1;
	ULONG	dst_addr;
	USHORT	dst_port;
	USHORT	unk2;
	ULONG	pid;
	PVOID	unk3[35];
} CONNINFO110, *PCONNINFO110;

/*
*	Parameters we will give to the function to complete the IRP
*	we will have a pointer to the previous function.
*/
typedef	struct _REQINFO
{
	PIO_COMPLETION_ROUTINE	OldCompletion;
	ULONG					ReqType;
} REQINFO, *PREQINFO;


// to save the previous pointer/handler
OLDIRPMJDEVICECONTROL OldIrpMjDeviceControl;

// Functions
NTSTATUS HookedDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS InstallTCPDriverHook();
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS IoCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS Unload(IN PDRIVER_OBJECT DriverObject);

DRIVER_INITIALIZE DriverEntry;

/*
*	Method to install a HOOK in a Driver IRP
*/
NTSTATUS InstallTCPDriverHook()
{
	NTSTATUS ntStatus;
	UNICODE_STRING deviceTCPUnicodeString; // It is necessary to use UNICODE_STRING to use
										   // the functions which will give us driver handle
	WCHAR deviceTCPNameBuffer[] = L"\\Device\\Tcp"; // driver object name
	// start global variables
	pFile_tcp	= NULL;
	pDev_tcp	= NULL;
	pDrv_tcpip	= NULL;

	// Init String UNICODE
	RtlInitUnicodeString(&deviceTCPUnicodeString, deviceTCPNameBuffer);

	/*
	*	IoGetDeviceObjectPointer give us a handler for the given name
	*	driver, with this we will be able to modify the IRP handler.
	*/
	ntStatus = IoGetDeviceObjectPointer(&deviceTCPUnicodeString, FILE_READ_DATA, &pFile_tcp, &pDev_tcp);

	if (!NT_SUCCESS(ntStatus))
		return ntStatus;

	// get driver object, from the device object
	pDrv_tcpip = pDev_tcp->DriverObject;

	/*
	*	Once we have the driver object, we can access
	*	to its IRP handlers, we save the old dispatcher
	*	from the IRP IRP_MJ_DEVICE_CONTROL
	*/
	OldIrpMjDeviceControl = pDrv_tcpip->MajorFunction[IRP_MJ_DEVICE_CONTROL];

	/*
	*	If everything was correct, we use InterlockedExchange to modify
	*	this IRP handler in an atomic way
	*/
	if (OldIrpMjDeviceControl)
	{
		InterlockedExchange((PLONG)&pDrv_tcpip->MajorFunction[IRP_MJ_DEVICE_CONTROL], (LONG)HookedDeviceControl);
	}

	return STATUS_SUCCESS;
}

/*
*	Hook for the IRP, we will filtrate the necessary calls
*	and finally we will return the control to the next
*	IRP Stack handler
*/
NTSTATUS HookedDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PIO_STACK_LOCATION				irpStack; // it is necessary to know where the IRP Stack is
											  // here is where we will find the function codes
											  // for the major and minor IRPs
	ULONG							ioTransferType;
	PTDIObjectID					inputBuffer;
	DWORD							context;

	// get a pointer to current IRP Stack location,
	// here we will find the function codes and the
	// parameters
	irpStack = IoGetCurrentIrpStackLocation(Irp);

	switch (irpStack->MajorFunction)
	{
	case IRP_MJ_DEVICE_CONTROL:
		// get the control code from DeviceIoControl parameters
		ioTransferType = irpStack->Parameters.DeviceIoControl.IoControlCode;
		if (ioTransferType & METHOD_NEITHER) // to check method Type3 (METHOD_NEITHER)
		{
			inputBuffer = (PTDIObjectID)irpStack->Parameters.DeviceIoControl.Type3InputBuffer;

			/*
			*	CO_TL_ENTITY ====> TCP
			*	CL_TL_ENTITY ====> UDP
			*
			*	We will look for TCP
			*/
			if (inputBuffer->toi_entity.tei_entity == CO_TL_ENTITY)
			{
				if (
					(inputBuffer->toi_id == CONNINFO101_k) ||
					(inputBuffer->toi_id == CONNINFO102_k) ||
					(inputBuffer->toi_id == CONNINFO110_k)
					)
				{
					/*
					*	Call our completion routine if the IRP went well
					*	to do this, just change control flag from the IRP
					*/
					irpStack->Control &= 0;
					irpStack->Control |= SL_INVOKE_ON_SUCCESS;

					// Allocate memory for the context parameter of the
					// completion routine for the IRP
					irpStack->Context = (PIO_COMPLETION_ROUTINE)ExAllocatePool(NonPagedPool, sizeof(REQINFO));
					// Save the current completion routine as OldCompletion
					((PREQINFO)irpStack->Context)->OldCompletion = irpStack->CompletionRoutine;
					((PREQINFO)irpStack->Context)->ReqType = inputBuffer->toi_id;
					/*
					*	Set new function to be called after finishing the IRP
					*/
					irpStack->CompletionRoutine = (PIO_COMPLETION_ROUTINE)IoCompletionRoutine;
				}
			}
		}
	default:
		break;
	}

	return OldIrpMjDeviceControl(DeviceObject, Irp);
}

/*
*	Function to finish the management of the IRP.
*/
NTSTATUS IoCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
	PVOID OutputBuffer;
	DWORD NumOutputBuffers;
	PIO_COMPLETION_ROUTINE p_compRoutine;
	SIZE_T i;

	/*
	*	Connection status values:
	*
	* 0 = Invisible
	* 1 = CLOSED
	* 2 = LISTENING
	* 3 = SYN_SENT
	* 4 = SYN_RECEIVED
	* 5 = ESTABLISHED
	* 6 = FIN_WAIT_1
	* 7 = FIN_WAIT_2
	* 8 = CLOSE_WAIT
	* 9 = CLOSING
	* ...
	*/
	OutputBuffer = Irp->UserBuffer;
	p_compRoutine = ((PREQINFO)Context)->OldCompletion;

	// Now send to hell all connection to port 80
	if (((PREQINFO)Context)->ReqType == CONNINFO101_k)
	{
		// get the number of CONNINFO101 structs
		NumOutputBuffers = Irp->IoStatus.Information / sizeof(CONNINFO101);

		for (i = 0; i < NumOutputBuffers; i++)
		{
			// hide all the http connections
			if (HTONS(((PCONNINFO101)OutputBuffer)[i].dst_port) == HTTP_PORT)
				((PCONNINFO101)OutputBuffer)[i].status = NULL;
		}
	}

	else if (((PREQINFO)Context)->ReqType == CONNINFO102_k)
	{
		NumOutputBuffers = Irp->IoStatus.Information / sizeof(CONNINFO102);

		for (i = 0; i < NumOutputBuffers; i++)
		{
			// hide all the http connections
			if (HTONS(((PCONNINFO102)OutputBuffer)[i].dst_port) == 80)
				((PCONNINFO102)OutputBuffer)[i].status = NULL;
		}
	}

	else if (((PREQINFO)Context)->ReqType == CONNINFO110_k)
	{
		NumOutputBuffers = Irp->IoStatus.Information / sizeof(CONNINFO102);

		for (i = 0; i < NumOutputBuffers; i++)
		{
			// hide all the http connections
			if (HTONS(((PCONNINFO110)OutputBuffer)[i].dst_port) == 80)
				((PCONNINFO110)OutputBuffer)[i].status = NULL;
		}
	}

	// Free context memory
	ExFreePool(Context);

	if ((Irp->StackCount > (ULONG)1) && (p_compRoutine != NULL))
	{
		return (p_compRoutine)(DeviceObject, Irp, NULL);
	}
	else
	{
		return Irp->IoStatus.Status;
	}
}

NTSTATUS Unload(IN PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);

	if (OldIrpMjDeviceControl)
		InterlockedExchange((PLONG)&pDrv_tcpip->MajorFunction[IRP_MJ_DEVICE_CONTROL], (LONG)OldIrpMjDeviceControl);
	if (pFile_tcp != NULL)
		ObDereferenceObject(pFile_tcp);

	pFile_tcp = NULL;

	DbgPrint("\n%s\n", "Unloading Driver...");
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
)
{
	NTSTATUS			ntStatus;

	UNREFERENCED_PARAMETER(RegistryPath);
	DbgPrint("\n%s\n", "Started Driver...");

	OldIrpMjDeviceControl = NULL;

	DriverObject->DriverUnload = Unload;

	ntStatus = InstallTCPDriverHook();
	if (!NT_SUCCESS(ntStatus))
		return ntStatus;

	return STATUS_SUCCESS;
}


```

`Drivers/Driver-SRC/DriverHookSysenter/DriverHookSysenter.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.421
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DriverHookSysenter", "DriverHookSysenter\DriverHookSysenter.vcxproj", "{E92BD0BF-3989-4391-9F16-8536939FB195}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM.ActiveCfg = Debug|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM.Build.0 = Debug|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM.Deploy.0 = Debug|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM64.Build.0 = Debug|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x64.ActiveCfg = Debug|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x64.Build.0 = Debug|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x64.Deploy.0 = Debug|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x86.ActiveCfg = Debug|Win32
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x86.Build.0 = Debug|Win32
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Debug|x86.Deploy.0 = Debug|Win32
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM.ActiveCfg = Release|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM.Build.0 = Release|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM.Deploy.0 = Release|ARM
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM64.ActiveCfg = Release|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM64.Build.0 = Release|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|ARM64.Deploy.0 = Release|ARM64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x64.ActiveCfg = Release|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x64.Build.0 = Release|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x64.Deploy.0 = Release|x64
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x86.ActiveCfg = Release|Win32
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x86.Build.0 = Release|Win32
		{E92BD0BF-3989-4391-9F16-8536939FB195}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4986C0E2-9A5F-4054-B83F-F8619F06BA9A}
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/DriverHookSysenter/DriverHookSysenter/DriverHookSysenter.inf`:

```inf
;
; DriverHookSysenter.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=DriverHookSysenter.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="DriverHookSysenter Source Disk"

```

`Drivers/Driver-SRC/DriverHookSysenter/DriverHookSysenter/DriverHookSysenter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E92BD0BF-3989-4391-9F16-8536939FB195}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DriverHookSysenter</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="DriverHookSysenter.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hook_sysenter.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/DriverHookSysenter/DriverHookSysenter/DriverHookSysenter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DriverHookSysenter.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hook_sysenter.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/DriverHookSysenter/DriverHookSysenter/hook_sysenter.c`:

```c
#include <ntddk.h>
#include <stdio.h>
#include <stdlib.h>

/*
*	Hook based on the instruction SYSENTER instead of INT 2E
*	this is the instruction which replaced int 2e for a fast call
*	method. Ntdll loads in EAX register the syscall to use, and
*	saves in EDX a pointer to the stack with the parameters.
*	The call to SYSENTER gives the control to the address specified
*	in one of the model specific registers (MSRs). Specifically
*	to the one called IA32_SYSENTER_EIP. It is possible to read
*	or write from/to that register from Ring 0.
*/

// specific to the register
#define IA32_SYSENTER_EIP	0x176
// structure representing the MSR
typedef struct _MSR
{
	ULONG loValue;
	ULONG hiValue;
} MSR, *PMSR;

// Original value of ntoskrnl!KiFastCallEntry
MSR d_origKiFastCallEntry;

/*
*	Function declared as Hook,
*	it is declared as naked to
*	avoid any instructions more
*	than those inside of the function.
*
*	When this function is called we will
*	have in EAX the syscall, and in EDX
*	the pointer to the parameters in
*	the stack.
*/
__declspec(naked) MyKiFastCallEntry()
{
	__asm
	{
		jmp[d_origKiFastCallEntry.loValue];
	}
}

// functions that we will use
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
VOID Unload(IN PDRIVER_OBJECT DriverObject);
VOID SetMSRValue(ULONG regAddress, MSR msr);
VOID GetMSRValue(ULONG regAddress, PMSR msr);

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	MSR	own_msr;

	UNREFERENCED_PARAMETER(RegistryPath);

	DriverObject->DriverUnload = Unload;

	own_msr.hiValue = (ULONG)0;
	own_msr.loValue = (ULONG)MyKiFastCallEntry;

	GetMSRValue(IA32_SYSENTER_EIP, &d_origKiFastCallEntry);
	SetMSRValue(IA32_SYSENTER_EIP, own_msr);
	
	return STATUS_SUCCESS;
}

VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);

	SetMSRValue(IA32_SYSENTER_EIP, d_origKiFastCallEntry);
}

VOID SetMSRValue(ULONG regAddress, MSR msr)
{
	ULONG loValue = msr.loValue;
	ULONG hiValue = msr.hiValue;

	__asm
	{
		mov ecx, regAddress;		// set in ecx the entry of the MSR
		mov edx, hiValue;			// set the high value
		mov eax, loValue;			// set the low value
		wrmsr;						// write the new MSR
	}
}

VOID GetMSRValue(ULONG regAddress, PMSR msr)
{
	ULONG loValue;
	ULONG hiValue;

	__asm
	{
		mov ecx, regAddress;		// set in ecx the entry of the MSR
		rdmsr;						// read the MSR
		mov hiValue, edx;			// get the high value
		mov loValue, eax;			// get the low value
	}

	msr->loValue = loValue;
	msr->hiValue = hiValue;
}


```

`Drivers/Driver-SRC/README.md`:

```md
## Driver Source and More

Collection of source code, binaries, and other useful examples.

```

`Drivers/Driver-SRC/elam/README.md`:

```md
---
page_type: sample
description: "Demonstrates how to receive notifications about the initialization of regular boot start drivers in an Early Launch Anti-Malware driver."
languages:
- cpp
products:
- windows
- windows-wdk
---

# Early Launch Anti-Malware Driver

This sample demonstrates how to use the [**IoRegisterBootDriverCallback**](https://docs.microsoft.com/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-ioregisterbootdrivercallback) and [**IoUnRegisterBootDriverCallback**](https://docs.microsoft.com/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-iounregisterbootdrivercallback) DDIs from an Early Launch Anti-Malware driver, to receive notifications about the initialization of regular boot start drivers.

This sample driver is a minimal driver meant to demonstrate the usage of the APIs mentioned above. It is not intended for use in a production environment.

## Signing the sample

Early Launch drivers are required to be signed with a code-signing certificate that also contains the Early Launch EKU "1.3.6.1.4.1.311.61.4.1". In a production environment, Early Launch drivers are signed by Microsoft for qualifying Anti-Malware vendors with a WHQL certificate that contains this EKU. The makecert.exe tool can be used to generate a self-signed test certificate that contains both the Early Launch EKU and the "1.3.6.1.5.5.7.3.3" Code Signing EKU. Once a certificate of this form has been created, signtool.exe can be used to sign elamsample.sys.

## Run the sample

### Installing the sample

1. Copy the signed elamsample.sys file to the %WINDIR%\\System32\\Drivers directory on your test machine.

1. Use the sc.exe tool present in Windows to install the driver:

    `sc create ElamSample binpath=%windir%\\system32\\drivers\\elamsample.sys type=kernel start=boot error=critical group=Early-Launch`

1. Enable test signing:

    `bcdedit /set testsigning on`

## Code tour

**DriverEntry:** Creates a framework driver object and calls IoRegisterBootDriverCallback to register to boot driver status callbacks.

**ElamSampleEvtDriverUnload:** Calls IoUnregisterBootDriverCallback to unregister for callbacks when elamsample.sys is about to be unloaded.

**ElamSampleBootDriverCallback**: Dispatches to other functions to process the specific callback types.

**ElamSampleProcessStatusUpdate:** Displays callback BdCbStatusUpdate information, such as when dependencies and drivers are about to be initialized, or when the ELAM driver is about to be unload.

**ElamSampleProcessInitializeImage:** Displays callback BdCbInitializeImage information, such as the driver image name and the name of the entity that signed the driver.

**ElamSamplePrintHex:** A utility function to display a buffer in hexadecimal form.

## Testing

After installing the driver, attach the Kernel Debugger and reboot your test machine. If ELAMSAMPLE\_TRACE\_LEVEL is set to DPFLTR\_ERROR\_LEVEL, traces will be output to the debugger automatically. For example:

```cmd
ElamSample is being initialized.

ElamSample reports the following dependency is about to be initialized: ElamSample:

Image name "\\FileSystem\\RAW"

ElamSample: Not signed.

ElamSample reports that Boot Start driver dependencies are being initialized.

ElamSample reports the following dependency is about to be initialized:

ElamSample: Image name "\\SystemRoot\\system32\\PSHED.dll"

ElamSample: Image hash algorithm = 0x0000800c.

ElamSample: Image hash:

ElamSample: 21 29 88 ca 88 ab dc 0f c3 f1 c0 74 df e0 29 58

ElamSample: 2e cd 41 5e 56 bd 77 53 39 9b d9 d7 f4 47 65 d8

ElamSample: Image is signed by "Microsoft Windows".

ElamSample: Certificate issued by "MSIT Test CodeSign CA 3".

ElamSample: Certificate thumb print algorithm = 0x0000800c.

ElamSample: Certificate thumb print:

ElamSample: 93 29 d5 f2 e2 7a c9 79 41 b2 6d c0 78 35 2a d3

ElamSample: da 2d 7e 72 f0 05 5f 8b 63 8c 7b a2 6b 37 5c 4f

ElamSample reports that Boot Start drivers are about to be initialized.

ElamSample reports the following Boot Start driver is about to be initialized:

ElamSample: Image name "\\SystemRoot\\System32\\drivers\\rdyboost.sys"

ElamSample: Registry path "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\rdyboost"

ElamSample: Image hash algorithm = 0x0000800c.

ElamSample: Image hash:

ElamSample: 9e 91 b2 e1 29 97 af e9 ac 6c 48 24 01 43 c8 b4

ElamSample: f6 81 bf 57 df 80 0b 05 4d 58 bb e6 d9 83 a9 08

ElamSample: Image is signed by "Microsoft Windows".

ElamSample: Certificate issued by "MSIT Test CodeSign CA 3".

ElamSample: Certificate thumb print algorithm = 0x0000800c.

ElamSample: Certificate thumb print:

ElamSample: 93 29 d5 f2 e2 7a c9 79 41 b2 6d c0 78 35 2a d3

ElamSample: da 2d 7e 72 f0 05 5f 8b 63 8c 7b a2 6b 37 5c 4f

ElamSample reports that all Boot Start drivers have been initialized and that ElamSample is about to be unloaded ElamSample is being unloaded.
```

```

`Drivers/Driver-SRC/elam/elam.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0
MinimumVisualStudioVersion = 12.0
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "elamsample", "elamsample.vcxproj", "{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Debug|Win32.ActiveCfg = Debug|Win32
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Debug|Win32.Build.0 = Debug|Win32
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Release|Win32.ActiveCfg = Release|Win32
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Release|Win32.Build.0 = Release|Win32
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Debug|x64.ActiveCfg = Debug|x64
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Debug|x64.Build.0 = Debug|x64
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Release|x64.ActiveCfg = Release|x64
		{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/elam/elamsample.c`:

```c
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved
//
// Module Name:
//
//     elamsample.c
//
// Abstract:
//
//     This driver demonstrates how to use the Boot Driver Callback APIs
//     IoRegisterBootDriverCallback and IoUnRegisterBootDriverCallback and
//     the callback type PBOOT_DRIVER_CALLBACK_FUNCTION.
//
// Environment:
//
//     Kernel mode only.
//

#include "elamsample.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA

//
// Trace level to use for kernel debugger DbgPrintEx output.
//

#define ELAMSAMPLE_TRACE_LEVEL DPFLTR_TRACE_LEVEL

//
// Callback handle returned by IoRegisterBootDriverCallback.
//

static PVOID g_IoRegisterBootDriverCallbackHandle = NULL;

//
// Current status update type from the callback.
//

static BDCB_STATUS_UPDATE_TYPE g_CurrentBcdCallbackContextType =
                                    BdCbStatusPrepareForDependencyLoad;

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called by the Operating System to initialize the driver.

    It creates the device object, fills in the dispatch entry points and
    completes the initialization.

Arguments:

    DriverObject - Supplies a pointer to the object that represents this device
         driver.

    RegistryPath - Supplies a pointer to the Services key in the registry.

Return Value:

    STATUS_SUCCESS if initialized successfully.

    Error status if the driver could not be initialized.

--*/
{
    WDF_OBJECT_ATTRIBUTES Attributes;
    WDF_DRIVER_CONFIG Config;
    WDFDRIVER Driver;
    NTSTATUS Status;

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               ELAMSAMPLE_TRACE_LEVEL,
               "ElamSample is being initialized.\r\n");

    //
    // Initialize a non-PnP driver with the framework.
    //

    WDF_DRIVER_CONFIG_INIT(&Config, WDF_NO_EVENT_CALLBACK);

    Config.DriverInitFlags |= WdfDriverInitNonPnpDriver;

    //
    // Non-PnP drivers must register an unload routine.
    //

    Config.EvtDriverUnload = ElamSampleEvtDriverUnload;

    //
    // Create a framework driver object.
    //

    WDF_OBJECT_ATTRIBUTES_INIT(&Attributes);

    Status = WdfDriverCreate(DriverObject,
                             RegistryPath,
                             &Attributes,
                             &Config,
                             &Driver);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Register for the boot driver callback.
    //

    g_IoRegisterBootDriverCallbackHandle = IoRegisterBootDriverCallback(
                                                ElamSampleBootDriverCallback,
                                                NULL);

    if (g_IoRegisterBootDriverCallbackHandle == NULL)
    {
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

VOID
ElamSampleEvtDriverUnload(
    _In_ WDFDRIVER Driver
    )
/*++

Routine Description:

    This routine is called by the I/O subsystem before unloading the driver.

    It creates the device object, fills in the dispatch entry points and
    completes the initialization.

Arguments:

    Driver - Supplies a handle to a framework driver object.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Driver);

    if (g_IoRegisterBootDriverCallbackHandle != NULL)
    {
        IoUnregisterBootDriverCallback(g_IoRegisterBootDriverCallbackHandle);
        g_IoRegisterBootDriverCallbackHandle = NULL;
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               ELAMSAMPLE_TRACE_LEVEL,
               "ElamSample is being unloaded.\r\n");
}

VOID
ElamSampleBootDriverCallback(
    _In_opt_ PVOID CallbackContext,
    _In_ BDCB_CALLBACK_TYPE Classification,
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    )
/*++

Routine Description:

    This routine is called by the Operating System when boot start drivers are
    being initialized.

Arguments:

    CallbackContext - Supplies the opaque context specified during callback
         registration.

    Classification - Supplies the type of the callback, including status update
         or image initialized.

    ImageInformation - Supplies a pointer to information about the next boot
         driver that is about to be initialized.

Return Value:

    None.

--*/
{
    PBDCB_STATUS_UPDATE_CONTEXT StatusUpdate;

    //
    // IoRegisterBootDriverCallback was called with a null context. Ensure that
    // is passed here.
    //

    if (CallbackContext != NULL)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample has been passed an unexpected callback context.\r\n");
    }

    switch (Classification)
    {
    case BdCbStatusUpdate:
        StatusUpdate = (PBDCB_STATUS_UPDATE_CONTEXT)ImageInformation;

        ElamSampleProcessStatusUpdate(StatusUpdate->StatusType);
        break;

    case BdCbInitializeImage:
        ElamSampleProcessInitializeImage(ImageInformation);
        break;

    default:
        //
        // Do nothing. If new classifications are supported we should just
        // ignore them.
        //
        break;
    }
}

VOID
ElamSampleProcessStatusUpdate(
    _In_ BDCB_STATUS_UPDATE_TYPE StatusType
    )
/*++

Routine Description:

    This routine processes the BdCbStatusUpdate callback type.

Arguments:

    StatusType - Supplies the type of status that is being reported.

Return Value:

    None.

--*/
{
    switch (StatusType)
    {
    case BdCbStatusPrepareForDependencyLoad:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports that Boot Start driver dependencies are being initialized.\r\n\r\n");
        break;

    case BdCbStatusPrepareForDriverLoad:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports that Boot Start drivers are about to be initialized.\r\n\r\n");
        break;

    case BdCbStatusPrepareForUnload:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports that all Boot Start drivers have been initialized "
                   "and that ElamSample is about to be unloaded\r\n\r\n");
        break;

    default:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports an unknown status type.\r\n\r\n");
        break;
    }

    g_CurrentBcdCallbackContextType = StatusType;
}

VOID
ElamSampleProcessInitializeImage(
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    )
/*++

Routine Description:

    This routine processes the BdCbInitializeImage callback type.

Arguments:

    ImageInformation - Supplies a pointer to information about the next boot
         driver that is about to be initialized.

Return Value:

    None.

--*/
{
    //
    // Is this a dependency or a boot start driver?
    //

    if (g_CurrentBcdCallbackContextType == BdCbStatusPrepareForDependencyLoad)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports the following dependency is about to be initialized:\r\n");
    }
    else if (g_CurrentBcdCallbackContextType == BdCbStatusPrepareForDriverLoad)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports the following Boot Start driver is about to be initialized:\r\n");
    }
    else
    {
        NT_ASSERT(g_CurrentBcdCallbackContextType == BdCbStatusPrepareForDependencyLoad ||
                  g_CurrentBcdCallbackContextType == BdCbStatusPrepareForDriverLoad);

        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample reports an invalid status type for image initialization:\r\n");
    }

    //
    // Display the image name and any associated registry path.
    //

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               ELAMSAMPLE_TRACE_LEVEL,
               "ElamSample:    Image name \"%wZ\"\r\n",
               &ImageInformation->ImageName);

    if (ImageInformation->RegistryPath.Buffer != NULL)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    Registry path \"%wZ\"\r\n",
                   &ImageInformation->RegistryPath);
    }

    //
    // Did this image fail Code Integrity checks?
    //

    if ((ImageInformation->ImageFlags & BDCB_IMAGEFLAGS_FAILED_CODE_INTEGRITY) != 0)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    FAILED Code Integrity checks but boot policy allowed it to be loaded.\r\n");
    }

    //
    // Display the image's hash.
    //

    if (ImageInformation->ImageHash != NULL &&
        ImageInformation->ImageHashLength != 0)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    Image hash algorithm = 0x%08x.\r\n",
                   ImageInformation->ImageHashAlgorithm);

        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    Image hash:");

        ElamSamplePrintHex(ImageInformation->ImageHash,
                           ImageInformation->ImageHashLength);
    }

    //
    // Display who signed the image (if at all).
    //

    if (ImageInformation->CertificatePublisher.Buffer != NULL)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    Image is signed by \"%wZ\".\r\n",
                   &ImageInformation->CertificatePublisher);

        if (ImageInformation->CertificateIssuer.Buffer != NULL)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       ELAMSAMPLE_TRACE_LEVEL,
                       "ElamSample:    Certificate issued by \"%wZ\".\r\n",
                       &ImageInformation->CertificateIssuer);
        }

        if (ImageInformation->CertificateThumbprint != NULL &&
            ImageInformation->CertificateThumbprintLength != 0)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       ELAMSAMPLE_TRACE_LEVEL,
                       "ElamSample:    Certificate thumb print algorithm = 0x%08x.\r\n",
                       ImageInformation->ThumbprintHashAlgorithm);

            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       ELAMSAMPLE_TRACE_LEVEL,
                       "ElamSample:    Certificate thumb print:");

            ElamSamplePrintHex(ImageInformation->CertificateThumbprint,
                               ImageInformation->CertificateThumbprintLength);
        }
    }
    else
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "ElamSample:    Not signed.\r\n");
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, ELAMSAMPLE_TRACE_LEVEL, "\r\n");

    //
    // Report that we don't know the authenticity of this image.
    //

    ImageInformation->Classification = BdCbClassificationUnknownImage;
}

VOID
ElamSamplePrintHex(
    _In_reads_bytes_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    )
/*++

Routine Description:

    This routine prints out the supplied data in hexadecimal form.

Arguments:

    Data - Supplies a pointer to the data to be printed.

    DataSize - Supplies the length in bytes of the data to be printed.

Return Value:

    None.

--*/
{
    PCUCHAR Bytes;
    ULONG Index;

    for (Bytes = (PCUCHAR)Data, Index = 0; Index < DataSize; Index++)
    {
        if ((Index & 15) == 0)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       ELAMSAMPLE_TRACE_LEVEL,
                       "\r\nElamSample:    ");
        }

        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   ELAMSAMPLE_TRACE_LEVEL,
                   "%02x ",
                   Bytes[Index]);
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, ELAMSAMPLE_TRACE_LEVEL, "\r\n");
}

```

`Drivers/Driver-SRC/elam/elamsample.h`:

```h
/*++

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.

  Copyright (c) Microsoft Corporation. All rights reserved

Module Name:

    elamsample.h

Abstract:

    Contains function prototypes and includes other neccessary header files.

Environment:

    Kernel mode only.

--*/

//
// ------------------------------------------------------------------- Includes
//

#include <ntddk.h>
#include <wdf.h>

//
// -------------------------------------------------------- Function Prototypes
//

DRIVER_INITIALIZE
DriverEntry;
/*++

Routine Description:

    This routine is called by the Operating System to initialize the driver.

    It creates the device object, fills in the dispatch entry points and
    completes the initialization.

Arguments:

    DriverObject - Supplies a pointer to the object that represents this device
         driver.

    RegistryPath - Supplies a pointer to the Services key in the registry.

Return Value:

    STATUS_SUCCESS if initialized successfully.

    Error status if the driver could not be initialized.

--*/

EVT_WDF_DRIVER_UNLOAD
ElamSampleEvtDriverUnload;
/*++

Routine Description:

    This routine is called by the I/O subsystem before unloading the driver.

    It creates the device object, fills in the dispatch entry points and
    completes the initialization.

Arguments:

    Driver - Supplies a handle to a framework driver object.

Return Value:

    None.

--*/

VOID
ElamSampleBootDriverCallback(
    _In_opt_ PVOID CallbackContext,
    _In_ BDCB_CALLBACK_TYPE Classification,
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    );
/*++

Routine Description:

    This routine is called by the Operating System when boot start drivers are
    being initialized.

Arguments:

    CallbackContext - Supplies the opaque context specified during callback
         registration.

    Classification - Supplies the type of the callback, including status update
         or image initialized.

    ImageInformation - Supplies a pointer to information about the next boot
         driver that is about to be initialized.

Return Value:

    None.

--*/

VOID
ElamSampleProcessStatusUpdate(
    _In_ BDCB_STATUS_UPDATE_TYPE StatusType
    );
/*++

Routine Description:

    This routine processes the BdCbStatusUpdate callback type.

Arguments:

    StatusType - Supplies the type of status that is being reported.

Return Value:

    None.

--*/

VOID
ElamSampleProcessInitializeImage(
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    );
/*++

Routine Description:

    This routine processes the BdCbInitializeImage callback type.

Arguments:

    ImageInformation - Supplies a pointer to information about the next boot
         driver that is about to be initialized.

Return Value:

    None.

--*/

VOID
ElamSamplePrintHex(
    _In_reads_bytes_(DataSize) PVOID Data,
    _In_ ULONG DataSize
    );
/*++

Routine Description:

    This routine prints out the supplied data in hexadecimal form.

Arguments:

    Data - Supplies a pointer to the data to be printed.

    DataSize - Supplies the length in bytes of the data to be printed.

Return Value:

    None.

--*/

```

`Drivers/Driver-SRC/elam/elamsample.rc`:

```rc
#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE             VFT_DRV
#define VER_FILESUBTYPE          VFT2_DRV_SYSTEM
#define VER_FILEDESCRIPTION_STR  "Sample Early Launch Anti-Malware Driver using WDF"
#define VER_INTERNALNAME_STR     "elamsample.sys"

#include "common.ver"

```

`Drivers/Driver-SRC/elam/elamsample.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D246CB84-E7A9-4CCF-A32C-EEB23910D7BD}</ProjectGuid>
    <RootNamespace>$(MSBuildProjectName)</RootNamespace>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <SampleGuid>{015D536C-9F60-4228-AD44-42A90A1AD014}</SampleGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(IntDir)</OutDir>
  </PropertyGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ItemGroup Label="WrappedTaskItems" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>elamsample</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>elamsample</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>elamsample</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>elamsample</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="elamsample.c" />
    <ResourceCompile Include="elamsample.rc" />
  </ItemGroup>
  <ItemGroup>
    <Inf Exclude="@(Inf)" Include="*.inf" />
    <FilesToPackage Include="$(TargetPath)" Condition="'$(ConfigurationType)'=='Driver' or '$(ConfigurationType)'=='DynamicLibrary'" />
  </ItemGroup>
  <ItemGroup>
    <None Exclude="@(None)" Include="*.txt;*.htm;*.html" />
    <None Exclude="@(None)" Include="*.ico;*.cur;*.bmp;*.dlg;*.rct;*.gif;*.jpg;*.jpeg;*.wav;*.jpe;*.tiff;*.tif;*.png;*.rc2" />
    <None Exclude="@(None)" Include="*.def;*.bat;*.hpj;*.asmx" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Exclude="@(ClInclude)" Include="*.h;*.hpp;*.hxx;*.hm;*.inl;*.xsd" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`Drivers/Driver-SRC/elam/elamsample.vcxproj.Filters`:

```Filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx;*</Extensions>
      <UniqueIdentifier>{00E51A05-37B6-4ADF-8287-9A1E383D471E}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
      <UniqueIdentifier>{60767E85-74A5-45F0-8193-CE3A252910F0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms;man;xml</Extensions>
      <UniqueIdentifier>{84579BC5-14A3-4B25-870C-590B67752AFC}</UniqueIdentifier>
    </Filter>
    <Filter Include="Driver Files">
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
      <UniqueIdentifier>{0ACF3248-3C68-463F-8976-4323BC0957D6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="elamsample.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="elamsample.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/setup/devcon/README.md`:

```md
---
page_type: sample
description: "DevCon enables, disables, installs, configures, and removes devices on the local computer and displays detailed information about devices on local and remote computers."
languages:
- cpp
products:
- windows
- windows-wdk
---

# Device Console (DevCon) Tool

[DevCon](https://docs.microsoft.com/windows-hardware/drivers/devtest/devcon) is a command-line tool that displays detailed information about devices, and lets you search for and manipulate devices from the command line. DevCon enables, disables, installs, configures, and removes devices on the local computer and displays detailed information about devices on local and remote computers. DevCon is included in the WDK.

This document explains the DevCon design, and how to use the SetupAPI and device installation functions to enumerate devices and perform device operations in a console application. For a complete description of DevCon features and instructions for using them, see the DevCon help file included with the WDK documentation in Driver Development Tools/Tools for Testing Drivers/DevCon.

DevCon is provided in ready-to-run form in tools\\devcon. For usage, refer to the document provided with devcon.exe. DevCon is a command line utility with built-in documentation available by typing "devcon help".

## Build the sample

You can build the sample in two ways: using the Visual Studio Integrated Development Environment (IDE) or from the command line using the Visual Studio Command Prompt window and the Microsoft Build Engine (MSBuild.exe).

### Building the sample using Visual Studio

1. Open Visual Studio. From the **File** menu, select **Open Project/Solution**. Navigate to the DevCon sample folder and open the devcon.sln project file.

1. Right-click the solution in the **Solution Explorer** and select **Configuration Manager**.

1. From the **Configuration Manager**, select the **Active Solution Configuration** (for example, Debug or Release) and the **Active Solution Platform** (for example, Win32) that correspond to the type of build you are interested in.

1. From the **Build** menu, click **Build Solution** (Ctrl+Shift+B).

Previous versions of the WDK used the Windows Build utility (Build.exe) and provided separate build environment windows for each of the supported build configurations. You can use the Visual Studio Command Prompt window for all build configurations.

### Building the sample using the command line (MSBuild)

1. Open a Visual Studio Command Prompt window. Click **Start** and search for **Developer Command Prompt**. If your project is under %PROGRAMFILES%, you need to open the command prompt window using elevated permissions (**Run as administrator**). From this window you can use MsBuild.exe to build any Visual Studio project by specifying the project (.VcxProj) or solutions (.Sln) file.

1. Navigate to the project directory and enter the **MSbuild** command for your target. For example, to perform a clean build of a Visual Studio driver project called devcon.vcxproj, navigate to the project directory and enter the following MSBuild command: `msbuild /t:clean /t:build .\devcon.vcxproj`.

1. If the build succeeds, you will find the tools (devcon.exe) in the binary output directory corresponding to the target platform, for example samples\\setup\\devcon\\Debug.

## Run the sample

Type `devcon find *` to list device instances of all present devices on the local machine.

Type `devcon status @root\rdp\_mou\0000` to list status of the terminal server mouse driver.

Type `devcon status *PNP05*` to list status of all COM ports.

### How DevCon works

Running `devcon help` will provide a list of commands along with short descriptions of what each command does. `devcon help <command>` will give more detailed help on that command. The interpretation of each command is done via a dispatch table "DispatchTable" that is at the bottom of "cmds.cpp". Some of the commands make use of a generic device enumerator "EnumerateDevices". A few of these commands will work when given a remote target computer, and will also work if using the 32-bit devcon on Wow64.

A description of some of the more interesting functions and the APIs they use follows:

cmdClasses  

- This command demonstrates the use of [**SetupDiBuildClassInfoListEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuildclassinfolistexa) to enumerate all device class GUIDs. The function [**SetupDiClassNameFromGuidEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassnamefromguidexa) and [**SetupDiGetClassDescriptionEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdescriptionexa) are used to obtain more information about each device class.

cmdListClass  

- This command demonstrates the use of [**SetupDiClassGuidsFromNameEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassguidsfromnameexa) to enumerate one or more class GUIDs that match the class name. This command also demonstrates the use of [**SetupDiGetClassDevsEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsexa) to list all the devices for each class GUID.

cmdFind cmdFindAll cmdStatus  

- A simple use of *EnumerateDevices* (explained below) to list devices and display different levels of information about each device. Note that all but *cmdFindAll* use DIGCF\_PRESENT to only list information about devices that are currently present. The main functionality for these and related devices is done inside *FindCallback.*

cmdEnable cmdDisable cmdRestart

- These commands show how to issue DIF\_PROPERTYCHANGE to enable a device, disable a device, or restart a device. The main functionality for each of these commands is done inside *ControlCallback*. These operations cannot be done on a remote machine or in the context of Wow64. CFGMGR32 API's should not be used as they skip class and co-installers.

cmdUpdate  

- This command shows how to use [**UpdateDriverForPlugAndPlayDevices**](https://docs.microsoft.com/windows/win32/api/newdev/nf-newdev-updatedriverforplugandplaydevicesa) to update the driver for all devices to a specific driver. Normally INSTALLFLAG\_FORCE would not be specified allowing **UpdateDriverForPlugAndPlayDevices** to determine if there is a better match already known. It's specified in DevCon to allow DevCon to be used more effectively as a debugging/testing tool. This cannot be done on a remote machine or in the context of Wow64.

cmdInstall  

- A variation of *cmdUpdate* to install a driver when there is no associated hardware. It creates a new root-enumerated device instance and associates it with a made up hardware ID specified on the command line (which should correspond to a hardware ID in the INF). This cannot be done on a remote machine or in the context of Wow64.

cmdRemove  

- A command to remove devices. Plug & Play devices that are removed will reappear in response to *cmdRescan*. The main functionality of this command is in *RemoveCallback* that demonstrates the use of DIF\_REMOVE. This cannot be done on a remote machine or in the context of Wow64. CFGMGR32 API's should not be used as they skip class and co-installers.

cmdRescan  

- This command shows the correct way to rescan for all Plug & Play devices that may have previously been removed, or that otherwise require a rescan to detect them.

cmdDPAdd  

- This command allows you to add a Driver Package to the machine. The main functionality of this command demonstrates the use of [**SetupCopyOEMInf**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcopyoeminfa). Adding a Driver Package to the machine doesn't mean the drivers are installed on devices, it simply means the drivers are available automatically when a new device is plugged in or a existing device is updated.

cmdDPDelete  

- This command allows you to uninstall a Driver Package from the machine. The main functionality of this command demonstrates the use of [**SetupUninstallOEMInf**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupuninstalloeminfa). Removing a Driver Package from the machine does not uninstall the drivers associated with a device. If you want to accomplish both then use *cmdRemove* on all the devices using a given Driver Package and then *cmdDPDelete* to remove the Driver Package itself from the machine.

cmdDPEnum  

- This command allows you to enumerate all of the 3rd party Driver Packages currently installed on the machine and also shows you how to get some common properties from a Driver Package (Provider, Class description, DriverVer date and version).

Reboot  

- This function shows how to correctly reboot the machine from a hardware install program. In particular it passes flags to **ExitWindowsEx** that cause the reboot to be associated with hardware installation. You should never reboot the machine unnecessarily.

EnumerateDevices  

- Demonstrates the use of [**SetupDiGetClassDevsEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsexa) to enumerate all devices or all present devices, either globally or limited to a specific setup class. Demonstrates the use of [**SetupDiCreateDeviceInfoListEx**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexa) to create a blank list associated with a class or not (for most cases, a blank list need not be associated with a class). Demonstrates the use of [**SetupDiOpenDeviceInfo**](hhttps://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinfoa) to add a device instance into a device info list. These last two API's are ideal to obtain a [SP\_DEVINFO\_DATA](https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_devinfo_data) structure from a device instance and machine name when mixing CFGMGR32 API's with SETUPAPI API's. [**SetupDiGetDeviceInfoListDetail**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila) is called to obtain a remote machine handle that may be passed into CFGMGR32 API's. [**SetupDiEnumDeviceInfo**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdeviceinfo) is called to enumerate each and every device that is in the device info list (either explicitly added, or determined by the call to **SetupDiGetClassDevsEx**). The instance ID is obtained by calling [**CM\_Get\_Device\_ID\_Ex**](https://docs.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_exw), using information in devInfo (obtained from **SetupDiEnumerateDeviceInfo**) and devInfoListDetail (obtained from **SetupDiGetDeviceInfoListDetail**). *GetHwIds* is called to obtain a list of hardware and compatible ID's (explained below). Once an interesting device has been determined (typically by checking hardware ID's) then the callback is called to operate on that individual device.

GetHwIds  

- Shows how to get the complete list of hardware ID's or compatible ID's for a device using [**SetupDiGetDeviceRegistryProperty**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya).

GetDeviceDescription  

- Shows how to obtain descriptive information about a device. The friendly name is used if it exists, otherwise the device description is used.

DumpDeviceWithInfo  

- Shows how to obtain an instance ID (or use any CFGMGR32 API) given HDEVINFO (device info list) and [PSP\_DEVINFO\_DATA](https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_devinfo_data) (device info data).

DumpDeviceStatus  

- Shows how to interpret the information returned by [**CM\_Get\_DevNode\_Status\_Ex**](https://docs.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex). Refer to *cfg.h* for information returned by this API.

DumpDeviceResources  

- Shows how to obtain information about resources used by a device.

DumpDeviceDriverFiles  

- Provided as a debugging aid, obtains information about the files apparently being used for a device. It uses [**SetupDiBuildDriverInfoList**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuilddriverinfolist) to obtain information about the driver being used for the specified device. The driver list associated with a device may be enumerated by calling [**SetupDiEnumDriverInfo**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdriverinfoa). In this case, there will be no more than one driver listed. This function proceeds to obtain a list of files that would normally be copied for this driver using DIF\_INSTALLDEVICEFILES. [**SetupScanFileQueue**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupscanfilequeuea) is used to enumerate the file queue to display the list of files that are associated with the driver.

DumpDeviceDriverNodes  

- Provided as a debugging aid, this function determines the list of compatible drivers for a device. It uses [**SetupDiBuildDriverInfoList**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuilddriverinfolist) to obtain the list of compatible drivers. In this case, all drivers are enumerated, however typically DIF\_SELECTBESTCOMPATDRV and [**SetupDiGetSelectedDriver**](https://docs.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddrivera) would be used together to find which driver the OS would consider to be the best.

DumpDeviceStack  

- This function determines class and device upper and lower filters.

```

`Drivers/Driver-SRC/setup/devcon/cmds.cpp`:

```cpp
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

--*/

#include "devcon.h"

struct GenericContext {
    DWORD count;
    DWORD control;
    BOOL  reboot;
    LPCTSTR strSuccess;
    LPCTSTR strReboot;
    LPCTSTR strFail;
};

#define FIND_DEVICE         0x00000001 // display device
#define FIND_STATUS         0x00000002 // display status of device
#define FIND_RESOURCES      0x00000004 // display resources of device
#define FIND_DRIVERFILES    0x00000008 // display drivers used by device
#define FIND_HWIDS          0x00000010 // display hw/compat id's used by device
#define FIND_DRIVERNODES    0x00000020 // display driver nodes for a device.
#define FIND_CLASS          0x00000040 // display device's setup class
#define FIND_STACK          0x00000080 // display device's driver-stack

struct SetHwidContext {
    int argc_right;
    LPTSTR * argv_right;
    DWORD prop;
    int skipped;
    int modified;
};

int cmdHelp(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    HELP command
    allow HELP or HELP <command>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine (ignored)
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    DWORD helptext = 0;
    int dispIndex;
    LPCTSTR cmd = NULL;
    BOOL unknown = FALSE;

    UNREFERENCED_PARAMETER(Machine);
    UNREFERENCED_PARAMETER(Flags);

    if(argc) {
        //
        // user passed in a command for help on... long help
        //
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(_tcsicmp(argv[0],DispatchTable[dispIndex].cmd)==0) {
                cmd = DispatchTable[dispIndex].cmd;
                helptext = DispatchTable[dispIndex].longHelp;
                break;
            }
        }
        if(!cmd) {
            unknown = TRUE;
            cmd = argv[0];
        }
    }

    if(helptext) {
        //
        // long help
        //
        FormatToStream(stdout,helptext,BaseName,cmd);
    } else {
        //
        // help help
        //
        FormatToStream(stdout,unknown ? MSG_HELP_OTHER : MSG_HELP_LONG,BaseName,cmd);
        //
        // enumerate through each command and display short help for each
        //
        _fputts(TEXT("\n"), stdout);
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(DispatchTable[dispIndex].shortHelp) {
                FormatToStream(stdout,DispatchTable[dispIndex].shortHelp,DispatchTable[dispIndex].cmd);
            }
        }
    }
    return EXIT_OK;
}

int cmdClasses(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    CLASSES command
    lists classes on (optionally) specified machine
    format as <name>: <destination>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    DWORD reqGuids = 128;
    DWORD numGuids;
    LPGUID guids = NULL;
    DWORD index;
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }
    if(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL)) {
        do {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        } while(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL));
    }
    FormatToStream(stdout,Machine?MSG_CLASSES_HEADER:MSG_CLASSES_HEADER_LOCAL,numGuids,Machine);
    for(index=0;index<numGuids;index++) {
        TCHAR className[MAX_CLASS_NAME_LEN];
        TCHAR classDesc[LINE_LEN];
        if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
            if (FAILED(StringCchCopy(className,MAX_CLASS_NAME_LEN,TEXT("?")))) {
                goto final;
            }
        }
        if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
            if (FAILED(StringCchCopy(classDesc,LINE_LEN,className))) {
                goto final;
            }
        }
        _tprintf(TEXT("%-20s: %s\n"),className,classDesc);
    }

    failcode = EXIT_OK;

final:

    if(guids) {
        delete [] guids;
    }
    return failcode;
}

int cmdListClass(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    LISTCLASS <name>....
    lists all devices for each specified class
    there can be more than one physical class for a class name (shouldn't be
    though) in such cases, list each class
    if machine given, list devices for that machine

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - list of class names

Return Value:

    EXIT_xxxx

--*/
{
    DWORD reqGuids = 16;
    int argIndex;
    int failcode = EXIT_FAIL;
    LPGUID guids = NULL;
    HDEVINFO devs = INVALID_HANDLE_VALUE;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }

    for(argIndex = 0;argIndex<argc;argIndex++) {
        DWORD numGuids;
        DWORD index;

        if(!(argv[argIndex] && argv[argIndex][0])) {
            continue;
        }

        //
        // there could be one to many name to GUID mapping
        //
        while(!SetupDiClassGuidsFromNameEx(argv[argIndex],guids,reqGuids,&numGuids,Machine,NULL)) {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        }
        if(numGuids == 0) {
            FormatToStream(stdout,Machine?MSG_LISTCLASS_NOCLASS:MSG_LISTCLASS_NOCLASS_LOCAL,argv[argIndex],Machine);
            continue;
        }
        for(index = 0;index<numGuids;index++) {
            TCHAR className[MAX_CLASS_NAME_LEN];
            TCHAR classDesc[LINE_LEN];
            DWORD devCount = 0;
            SP_DEVINFO_DATA devInfo;
            DWORD devIndex;

            devs = SetupDiGetClassDevsEx(&guids[index],NULL,NULL,DIGCF_PRESENT,NULL,Machine,NULL);
            if(devs != INVALID_HANDLE_VALUE) {
                //
                // count number of devices
                //
                devInfo.cbSize = sizeof(devInfo);
                while(SetupDiEnumDeviceInfo(devs,devCount,&devInfo)) {
                    devCount++;
                }
            }

            if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
                if (FAILED(StringCchCopy(className,MAX_CLASS_NAME_LEN,TEXT("?")))) {
                    goto final;
                }
            }
            if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
                if (FAILED(StringCchCopy(classDesc,LINE_LEN,className))) {
                    goto final;
                }
            }

            //
            // how many devices?
            //
            if (!devCount) {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER_NONE:MSG_LISTCLASS_HEADER_NONE_LOCAL,className,classDesc,Machine);
            } else {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER:MSG_LISTCLASS_HEADER_LOCAL,devCount,className,classDesc,Machine);
                for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {
                    DumpDevice(devs,&devInfo);
                }
            }
            if(devs != INVALID_HANDLE_VALUE) {
                SetupDiDestroyDeviceInfoList(devs);
                devs = INVALID_HANDLE_VALUE;
            }
        }
    }

    failcode = 0;

final:

    if(guids) {
        delete [] guids;
    }

    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }

    return failcode;
}

int FindCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by Find/FindAll
    just simply display the device

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext *pFindContext = (GenericContext*)Context;

    UNREFERENCED_PARAMETER(Index);

    if(!pFindContext->control) {
        DumpDevice(Devs,DevInfo);
        pFindContext->count++;
        return EXIT_OK;
    }
    if(!DumpDeviceWithInfo(Devs,DevInfo,NULL)) {
        return EXIT_OK;
    }
    if(pFindContext->control&FIND_DEVICE) {
        DumpDeviceDescr(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_CLASS) {
        DumpDeviceClass(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STATUS) {
        DumpDeviceStatus(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_RESOURCES) {
        DumpDeviceResources(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_DRIVERFILES) {
        DumpDeviceDriverFiles(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STACK) {
        DumpDeviceStack(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_HWIDS) {
        DumpDeviceHwIds(Devs,DevInfo);
    }
    if (pFindContext->control&FIND_DRIVERNODES) {
        DumpDeviceDriverNodes(Devs,DevInfo);
    }
    pFindContext->count++;
    return EXIT_OK;
}

int cmdFind(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    FIND <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdFindAll(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    FINDALL <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    like find, but also show not-present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,0,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStatus(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump status to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_STATUS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdResources(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    RESOURCES <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump resources to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_RESOURCES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdDriverFiles(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump driver files to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERFILES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERFILES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdDriverNodes(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump drivernodes to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERNODES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERNODES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdHwIds(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    HWIDS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump hw/compat id's to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_HWIDS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStack(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    STACK <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump device class and stack to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_CLASS | FIND_STACK;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}




int ControlCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by Enable/Disable/Restart
    Invokes DIF_PROPERTYCHANGE with correct parameters
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

    In Enable case, we try global first, and if still disabled, enable local

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_PROPCHANGE_PARAMS pcp;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;

    UNREFERENCED_PARAMETER(Index);

    switch(pControlContext->control) {
        case DICS_ENABLE:
            //
            // enable both on global and config-specific profile
            // do global first and see if that succeeded in enabling the device
            // (global enable doesn't mark reboot required if device is still
            // disabled on current config whereas vice-versa isn't true)
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_GLOBAL;
            pcp.HwProfile = 0;
            //
            // don't worry if this fails, we'll get an error when we try config-
            // specific.
            if(SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp))) {
               SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo);
            }
            //
            // now enable on config-specific
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

        default:
            //
            // operate on config-specific profile
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

    }

    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strFail);
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
                DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strReboot);
                pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strSuccess);
        }
        pControlContext->count++;
    }
    return EXIT_OK;
}

int cmdEnable(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    ENABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to enable global, and if needed, config specific

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strEnable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_ENABLED,strEnable,ARRAYSIZE(strEnable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_ENABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strEnable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_FIND_TAIL_NONE_LOCAL);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_ENABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_ENABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdDisable(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    DISABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to disable global

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strDisable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_DISABLED,strDisable,ARRAYSIZE(strDisable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_DISABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strDisable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_FIND_TAIL_NONE_LOCAL);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_DISABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_DISABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRestart(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    RESTART <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to restart by issueing a PROPCHANGE

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strRestarted[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_RESTARTED,strRestarted,ARRAYSIZE(strRestarted))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REQUIRES_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_RESTART_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_PROPCHANGE;
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRestarted;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_FIND_TAIL_NONE_LOCAL);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_RESTART_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_RESTART_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdReboot(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    REBOOT
    reboot local machine

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    FormatToStream(stdout,MSG_REBOOT);
    return Reboot() ? EXIT_OK : EXIT_FAIL;
}


int cmdUpdate(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    UPDATE
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HMODULE newdevMod = NULL;
    int failcode = EXIT_FAIL;
    UpdateDriverForPlugAndPlayDevicesProto UpdateFn;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    DWORD res;
    TCHAR InfPath[MAX_PATH];

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }
    //
    // Inf must be a full pathname
    //
    res = GetFullPathName(inf,MAX_PATH,InfPath,NULL);
    if((res >= MAX_PATH) || (res == 0)) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }
    if(GetFileAttributes(InfPath)==(DWORD)(-1)) {
        //
        // inf doesn't exist
        //
        return EXIT_FAIL;
    }
    inf = InfPath;
    flags |= INSTALLFLAG_FORCE;

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if(!newdevMod) {
        goto final;
    }
    UpdateFn = (UpdateDriverForPlugAndPlayDevicesProto)GetProcAddress(newdevMod,UPDATEDRIVERFORPLUGANDPLAYDEVICES);
    if(!UpdateFn)
    {
        goto final;
    }

    FormatToStream(stdout,inf ? MSG_UPDATE_INF : MSG_UPDATE,hwid,inf);

    if(!UpdateFn(NULL,hwid,inf,flags,&reboot)) {
        goto final;
    }

    FormatToStream(stdout,MSG_UPDATE_OK);

    failcode = reboot ? EXIT_REBOOT : EXIT_OK;

final:

    if(newdevMod) {
        FreeLibrary(newdevMod);
    }

    return failcode;
}

int cmdInstall(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    CREATE
    Creates a root enumerated devnode and installs drivers on it

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO DeviceInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    GUID ClassGUID;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    TCHAR hwIdList[LINE_LEN+4];
    TCHAR InfPath[MAX_PATH];
    int failcode = EXIT_FAIL;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }

    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(inf,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }

    //
    // List of hardware ID's must be double zero-terminated
    //
    ZeroMemory(hwIdList,sizeof(hwIdList));
    if (FAILED(StringCchCopy(hwIdList,LINE_LEN,hwid))) {
        goto final;
    }

    //
    // Use the INF File to extract the Class GUID.
    //
    if (!SetupDiGetINFClass(InfPath,&ClassGUID,ClassName,sizeof(ClassName)/sizeof(ClassName[0]),0))
    {
        goto final;
    }

    //
    // Create the container for the to-be-created Device Information Element.
    //
    DeviceInfoSet = SetupDiCreateDeviceInfoList(&ClassGUID,0);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        goto final;
    }

    //
    // Now create the element.
    // Use the Class GUID and Name from the INF file.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
        ClassName,
        &ClassGUID,
        NULL,
        0,
        DICD_GENERATE_ID,
        &DeviceInfoData))
    {
        goto final;
    }

    //
    // Add the HardwareID to the Device's HardwareID property.
    //
    if(!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
        &DeviceInfoData,
        SPDRP_HARDWAREID,
        (LPBYTE)hwIdList,
        ((DWORD)_tcslen(hwIdList)+1+1)*sizeof(TCHAR)))
    {
        goto final;
    }

    //
    // Transform the registry element into an actual devnode
    // in the PnP HW tree.
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
        DeviceInfoSet,
        &DeviceInfoData))
    {
        goto final;
    }

    FormatToStream(stdout,MSG_INSTALL_UPDATE);
    //
    // update the driver for the device we just created
    //
    failcode = cmdUpdate(BaseName,Machine,Flags,argc,argv);

final:

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }

    return failcode;
}

int cmdUpdateNI(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    UPDATE (non interactive version)
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    //
    // turn off interactive mode while doing the update
    //
    HMODULE setupapiMod = NULL;
    SetupSetNonInteractiveModeProto SetNIFn;
    int res;
    BOOL prev;

    setupapiMod = LoadLibrary(TEXT("setupapi.dll"));
    if(!setupapiMod) {
        return cmdUpdate(BaseName,Machine,Flags,argc,argv);
    }
    SetNIFn = (SetupSetNonInteractiveModeProto)GetProcAddress(setupapiMod,SETUPSETNONINTERACTIVEMODE);
    if(!SetNIFn)
    {
        FreeLibrary(setupapiMod);
        return cmdUpdate(BaseName,Machine,Flags,argc,argv);
    }
    prev = SetNIFn(TRUE);
    res = cmdUpdate(BaseName,Machine,Flags,argc,argv);
    SetNIFn(prev);
    FreeLibrary(setupapiMod);
    return res;
}

int RemoveCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by Remove
    Invokes DIF_REMOVE
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;
    LPCTSTR action = NULL;
    //
    // need hardware ID before trying to remove, as we wont have it after
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    UNREFERENCED_PARAMETER(Index);

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return EXIT_OK;
    }

    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&rmdParams.ClassInstallHeader,sizeof(rmdParams)) ||
       !SetupDiCallClassInstaller(DIF_REMOVE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_REMOVE
        //
        action = pControlContext->strFail;
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
            //
            // reboot required
            //
            action = pControlContext->strReboot;
            pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            action = pControlContext->strSuccess;
        }
        pControlContext->count++;
    }
    _tprintf(TEXT("%-60s: %s\n"),devID,action);

    return EXIT_OK;
}

int cmdRemove(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    REMOVE
    remove devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    TCHAR strRemove[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_REMOVED,strRemove,ARRAYSIZE(strRemove))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRemove;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,RemoveCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_REMOVE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_REMOVE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_REMOVE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRemoveAll(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

REMOVEALL
remove devices
like remove, but also remove not-present devices

Arguments:

BaseName  - name of executable
Machine   - machine name, must be NULL
argc/argv - remaining parameters

Return Value:

EXIT_xxxx

--*/
{
    GenericContext context;
    TCHAR strRemove[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if (!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if (Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if (!LoadString(NULL, IDS_REMOVED, strRemove, ARRAYSIZE(strRemove))) {
        return EXIT_FAIL;
    }
    if (!LoadString(NULL, IDS_REMOVED_REBOOT, strReboot, ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if (!LoadString(NULL, IDS_REMOVE_FAILED, strFail, ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRemove;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName, Machine, 0, argc, argv, RemoveCallback, &context);

    if (failcode == EXIT_OK) {

        if (!context.count) {
            FormatToStream(stdout, MSG_REMOVE_TAIL_NONE);
        } else if (!context.reboot) {
            FormatToStream(stdout, MSG_REMOVE_TAIL, context.count);
        } else {
            FormatToStream(stdout, MSG_REMOVE_TAIL_REBOOT, context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRescan(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    RESCAN
    rescan for new devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{

    //
    // reenumerate from the root of the devnode tree
    // totally CM based
    //
    int failcode = EXIT_FAIL;
    HMACHINE machineHandle = NULL;
    DEVINST devRoot;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    if(Machine) {
        if(CM_Connect_Machine(Machine,&machineHandle) != CR_SUCCESS) {
            return failcode;
        }
    }

    if(CM_Locate_DevNode_Ex(&devRoot,NULL,CM_LOCATE_DEVNODE_NORMAL,machineHandle) != CR_SUCCESS) {
        goto final;
    }

    FormatToStream(stdout,Machine ? MSG_RESCAN : MSG_RESCAN_LOCAL);

    if(CM_Reenumerate_DevNode_Ex(devRoot, 0, machineHandle) != CR_SUCCESS) {
        goto final;
    }

    FormatToStream(stdout,MSG_RESCAN_OK);

    failcode = EXIT_OK;

final:
    if(machineHandle) {
        CM_Disconnect_Machine(machineHandle);
    }

    return failcode;
}

int cmdClassFilter(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    CLASSFILTER <name> <type> <subcmds>
    Allows tweaking of class filters
    Useful for filter driver development and for Product Support

    <subcmds> is a list of the following:
    @service - sets 'after' to the first match of service after 'after'
               (reset to -1 after any other command)
    !service - deletes first match of 'service' after 'after'
    -service - insert new service directly prior to 'after', or at start
    +service - insert new service directly after 'after', or at end

    if no <subcmds> given, list the services

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - list of class names

Return Value:

    EXIT_xxxx

--*/
{
    int failcode = EXIT_FAIL;
    int argIndex;
    DWORD numGuids = 0;
    GUID guid;
    LPTSTR regval = NULL;
    HKEY hk = (HKEY)INVALID_HANDLE_VALUE;
    LPTSTR * multiVal = NULL;
    int after;
    bool modified = false;
    int span;
    SC_HANDLE SCMHandle = NULL;
    SC_HANDLE ServHandle = NULL;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Flags);

    if((argc<2) || !argv[0][0]) {
        return EXIT_USAGE;
    }

    //
    // just take the first guid for the name
    //
    if(!SetupDiClassGuidsFromNameEx(argv[0],&guid,1,&numGuids,Machine,NULL)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
    }
    if(numGuids == 0) {
        goto final;
    }
    if(_tcsicmp(argv[1],TEXT("upper"))==0) {
        regval = REGSTR_VAL_UPPERFILTERS;
    } else if(_tcsicmp(argv[1],TEXT("lower"))==0) {
        regval = REGSTR_VAL_LOWERFILTERS;
    } else {
        failcode = EXIT_USAGE;
        goto final;
    }

    hk = SetupDiOpenClassRegKeyEx(&guid,
                                  KEY_READ | (argc>2 ? KEY_WRITE : 0),
                                  DIOCR_INSTALLER,
                                  Machine,
                                  NULL
                                 );
    if(hk == INVALID_HANDLE_VALUE) {
        goto final;
    }
    multiVal = GetRegMultiSz(hk,regval);

    if(argc<=2) {
        //
        // just display
        //
        FormatToStream(stdout,MSG_CLASSFILTER_UNCHANGED);
        DumpArray(1,multiVal);
        failcode = EXIT_OK;
        goto final;
    }
    after = -1; // for the @service expressions
    span =  1;

    if(!multiVal) {
        multiVal = CopyMultiSz(NULL);
        if(!multiVal) {
            goto final;
        }
    }

    for(argIndex=2;argIndex<argc;argIndex++) {
        if((argv[argIndex] == NULL) ||
           (!argv[argIndex])) {
            failcode = EXIT_USAGE;
            break;
        }

        int op = argv[argIndex][0];
        LPTSTR serv = argv[argIndex]+1;
        int mark = 0;
        int cnt;
        int ent;
        LPTSTR * tmpArray;

        if(op == TEXT('=')) {
            after = -1;
            span = 1;
            op = serv[0];
            if(!op) {
                continue;
            }
            serv++;
        }

        if(!serv[0]) {
            failcode = EXIT_USAGE;
            goto final;
        }

        if((op == TEXT('@')) || (op == TEXT('!'))) {
            //
            // need to find specified service in list
            //
            for(after+=span;multiVal[after];after++) {
                if(_tcsicmp(multiVal[after],serv)==0) {
                    break;
                }
            }
            if(!multiVal[after]) {
                goto final;
            }
            if(op == TEXT('@')) {
                //
                // all we needed to do for '@'
                //
                span = 1; // span of 1
                continue;
            }
            //
            // we're modifying
            //
            int c;
            for(c = after;multiVal[c];c++) {
                multiVal[c] = multiVal[c+1];
            }
            LPTSTR * newArray = CopyMultiSz(multiVal);
            if(!newArray) {
                goto final;
            }
            DelMultiSz(multiVal);
            multiVal = newArray;
            span = 0; // span of 0 (deleted)
            modified = true;
            continue;
        }

        if(op == '+') {
            //
            // insert after
            //
            if(after<0) {
                int c;
                for(c = 0;multiVal[c];c++) {
                    // nothing
                }
                mark = c;
            }
            else {
                mark = after+span;
            }
        } else if(op == '-') {
            //
            // insert before
            //
            if(after<0) {
                mark = 0;
            } else {
                mark = after;
            }
        } else {
            //
            // not valid
            //
            failcode = EXIT_USAGE;
            goto final;
        }
        //
        // sanity - see if service exists
        //
        SCMHandle = OpenSCManager(Machine, NULL, GENERIC_READ);
        if(!SCMHandle) {
            goto final;
        }
        ServHandle = OpenService(SCMHandle,serv,GENERIC_READ);
        if(ServHandle) {
            CloseServiceHandle(ServHandle);
        }
        CloseServiceHandle(SCMHandle);
        if(!ServHandle) {
            goto final;
        }

        //
        // need an array a little bigger
        //
        for(cnt = 0;multiVal[cnt];cnt++) {
            // nothing
        }

        tmpArray = new LPTSTR[cnt+2];
        if(!tmpArray) {
            goto final;
        }
        _Analysis_assume_(mark < cnt);
        for(ent=0;ent<mark;ent++) {
            tmpArray[ent] = multiVal[ent];
        }
        tmpArray[ent] = serv;
        for(;ent<cnt;ent++) {
            tmpArray[ent+1] = multiVal[ent];
        }
        tmpArray[ent+1] = NULL;
        LPTSTR * newArray = CopyMultiSz(tmpArray);
        delete [] tmpArray;
        if(!newArray) {
            goto final;
        }
        DelMultiSz(multiVal);
        multiVal = newArray;
        modified = true;
        span = 1;
        after = mark;
    }

    if(modified) {
        if(multiVal[0]) {
            size_t len = 0;
            LPTSTR multiSz = multiVal[-1];
            LPTSTR p = multiSz;
            while(*p) {
                p+=_tcslen(p)+1;
            }
            p++; // skip past null
            len = (p-multiSz)*sizeof(TCHAR);
            if(len > DWORD_MAX) {
                goto final;
            }
            LONG err = RegSetValueEx(hk,regval,0,REG_MULTI_SZ,(LPBYTE)multiSz,(DWORD)len);
            if(err==NO_ERROR) {
                FormatToStream(stdout,MSG_CLASSFILTER_CHANGED);
                DumpArray(1,multiVal);
                failcode = EXIT_REBOOT;
            }
        } else {
            LONG err = RegDeleteValue(hk,regval);
            if((err == NO_ERROR) || (err == ERROR_FILE_NOT_FOUND)) {
                FormatToStream(stdout,MSG_CLASSFILTER_CHANGED);
                failcode = EXIT_REBOOT;
            }
        }
    } else {
        FormatToStream(stdout,MSG_CLASSFILTER_UNCHANGED);
        DumpArray(1,multiVal);
        failcode = EXIT_OK;
    }

final:

    if(multiVal) {
        DelMultiSz(multiVal);
    }
    if(hk != (HKEY)INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    return failcode;
}

int SetHwidCallback(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context)
/*++

Routine Description:

    Callback for use by SetHwid

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - SetHwidContext

Return Value:

    EXIT_xxxx

--*/
{
    SetHwidContext *pControlContext = (SetHwidContext*)Context;
    ULONG status;
    ULONG problem;
    LPTSTR * hwlist = NULL;
    bool modified = false;
    int result = EXIT_FAIL;

    //
    // processes the sub-commands on each callback
    // not most efficient way of doing things, but perf isn't important
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    UNREFERENCED_PARAMETER(Index);

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return EXIT_OK;
    }
    //
    // this is how to verify it's root enumerated
    //
    if(!(status & DN_ROOT_ENUMERATED)) {
        _tprintf(TEXT("%-60s: "),devID);
        FormatToStream(stdout,MSG_SETHWID_NOTROOT);
        pControlContext->skipped++;
        return EXIT_OK;
    }
    hwlist = GetDevMultiSz(Devs,DevInfo,pControlContext->prop);
    if(hwlist == NULL) {
        hwlist = CopyMultiSz(NULL);
        if(hwlist == NULL) {
            return EXIT_FAIL;
        }
    }

    //
    // modify hwid list (only relevent for root-enumerated devices)
    //
    int i;
    int mark = -1;

    for(i=0;i<pControlContext->argc_right;i++) {
        LPTSTR op = pControlContext->argv_right[i];
        if(op[0] == TEXT('=')) {
            //
            // clear the hwid list first
            //
            hwlist[0] = NULL;
            mark = 0;
            op++;
        } else if(op[0] == TEXT('+')) {
            //
            // insert as better match
            //
            mark = 0;
            op++;
        } else if(op[0] == TEXT('-')) {
            //
            // insert as worse match
            //
            mark = -1;
            op++;
        } else if(op[0] == TEXT('!')) {
            //
            // delete
            //
            mark = -2;
            op++;
        } else {
            //
            // treat as a hardware id
            //
        }
        if(!*op) {
            result = EXIT_USAGE;
            goto final;
        }
        int cnt;
        for(cnt = 0;hwlist[cnt];cnt++) {
            // nothing
        }
        if((mark == -1) || (mark>cnt)) {
            mark = cnt;
        }
        LPTSTR * tmpArray = new LPTSTR[cnt+2];
        if(!tmpArray) {
            goto final;
        }
        int dst = 0;
        int ent;
        for(ent=0;ent<mark;ent++) {
            if(_tcsicmp(hwlist[ent],op)==0) {
                continue;
            }
            tmpArray[dst++] = hwlist[ent];
        }
        if(mark>=0) {
            tmpArray[dst++] = op;
        }
        for(;ent<cnt;ent++) {
            if(_tcsicmp(hwlist[ent],op)==0) {
                continue;
            }
            tmpArray[dst++] = hwlist[ent];
        }
        tmpArray[dst] = NULL;
        LPTSTR * newArray = CopyMultiSz(tmpArray);
        delete [] tmpArray;
        if(!newArray) {
            goto final;
        }
        DelMultiSz(hwlist);
        hwlist = newArray;
        modified = true;
        mark++;
    }

    //
    // re-set the hwid list
    //
    if(modified) {
        if(hwlist[0]) {
            size_t len = 0;
            LPTSTR multiSz = hwlist[-1];
            LPTSTR p = multiSz;
            while(*p) {
                p+=_tcslen(p)+1;
            }
            p++; // skip past final null
            len = (p-multiSz)*sizeof(TCHAR);
            if(len > DWORD_MAX) {
                result = EXIT_FAIL;
                goto final;
            }
            if(!SetupDiSetDeviceRegistryProperty(Devs,
                                                 DevInfo,
                                                 pControlContext->prop,
                                                 (LPBYTE)multiSz,
                                                 (DWORD)len)) {
                result = EXIT_FAIL;
                goto final;
            }
        } else {
            //
            // delete list
            //
            if(!SetupDiSetDeviceRegistryProperty(Devs,
                                                 DevInfo,
                                                 pControlContext->prop,
                                                 NULL,
                                                 0)) {
                result = EXIT_FAIL;
                goto final;
            }
        }
    }
    result = EXIT_OK;
    pControlContext->modified++;
    _tprintf(TEXT("%-60s: "),devID);
    for(mark=0;hwlist[mark];mark++) {
        if(mark > 0) {
            _tprintf(TEXT(","));
        }
        _tprintf(TEXT("%s"),hwlist[mark]);
    }
    _tprintf(TEXT("\n"));

    //
    // cleanup
    //

  final:

    if(hwlist) {
        DelMultiSz(hwlist);
    }

    return result;
}

int cmdSetHwid(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:

    SETHWID
    changes the hardware ID's of the listed root-enumerated devices
    This demonstrates how to differentiate between root-enumerated and
    non root-enumerated devices.
    It also demonstrates how to get/set hardware ID's of root-enumerated
    devices.

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    SetHwidContext context;
    int failcode = EXIT_FAIL;

    UNREFERENCED_PARAMETER(Flags);

    if(!SplitCommandLine(argc,argv,context.argc_right,context.argv_right)
       || (argc == 0)
       || (context.argc_right == 0)) {
        //
        // arguments required both left and right of ':='
        //
        return EXIT_USAGE;
    }
    context.skipped = 0;
    context.modified = 0;
    context.prop = SPDRP_HARDWAREID;

    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,SetHwidCallback,&context);

    if(failcode == EXIT_OK) {

        if(context.skipped) {
            FormatToStream(stdout,MSG_SETHWID_TAIL_SKIPPED,context.skipped,context.modified);
        } else if(context.modified) {
            FormatToStream(stdout,MSG_SETHWID_TAIL_MODIFIED,context.modified);
        } else {
            FormatToStream(stdout,MSG_SETHWID_TAIL_NONE);
        }
    }
    return failcode;
}

int cmdDPAdd(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    dp_add
    Add a driver package to the machine.

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    int failcode = EXIT_FAIL;
    DWORD res;
    TCHAR SourceInfFileName[MAX_PATH];
    TCHAR DestinationInfFileName[MAX_PATH];
    PTSTR DestinationInfFileNameComponent = NULL;
    PTSTR FilePart = NULL;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Machine);
    UNREFERENCED_PARAMETER(Flags);

    if(!argc) {
        return EXIT_USAGE;
    }

    res = GetFullPathName(argv[0],
                          ARRAYSIZE(SourceInfFileName),
                          SourceInfFileName,
                          &FilePart);
    if ((!res) || (res >= ARRAYSIZE(SourceInfFileName))) {
        FormatToStream(stdout,MSG_DPADD_INVALID_INF);
        goto final;
    }

    if (!SetupCopyOEMInf(SourceInfFileName,
                         NULL,
                         SPOST_PATH,
                         0,
                         DestinationInfFileName,
                         ARRAYSIZE(DestinationInfFileName),
                         NULL,
                         &DestinationInfFileNameComponent)) {
        FormatToStream(stdout,MSG_DPADD_FAILED);
        goto final;
    }

    //
    // Successfully added the driver package to the machine.
    //
    FormatToStream(stdout,MSG_DPADD_SUCCESS,DestinationInfFileNameComponent);
    failcode = EXIT_OK;

final:

    return failcode;
}

int cmdDPDelete(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    dp_delete
    Deletes a driver package to the machine.

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    int failcode = EXIT_FAIL;
    DWORD res;
    TCHAR InfFileName[MAX_PATH];
    PTSTR FilePart = NULL;
    HMODULE setupapiMod = NULL;
    SetupUninstallOEMInfProto SUOIFn;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Machine);

    if(!argc) {
        return EXIT_USAGE;
    }

    res = GetFullPathName(argv[0],
                          ARRAYSIZE(InfFileName),
                          InfFileName,
                          &FilePart);
    if ((!res) || (!FilePart)) {
        FormatToStream(stdout,MSG_DPADD_INVALID_INF);
        goto final;
    }

    setupapiMod = LoadLibrary(TEXT("setupapi.dll"));
    if(!setupapiMod) {
        goto final;
    }
    SUOIFn = (SetupUninstallOEMInfProto)GetProcAddress(setupapiMod,SETUPUNINSTALLOEMINF);
    if(!SUOIFn)
    {
        goto final;
    }

    if (!SUOIFn(FilePart,
                ((Flags & DEVCON_FLAG_FORCE) ? 1 : 0),
                NULL)) {
        if (GetLastError() == ERROR_INF_IN_USE_BY_DEVICES) {
            FormatToStream(stdout,MSG_DPDELETE_FAILED_IN_USE);
        } else if (GetLastError() == ERROR_NOT_AN_INSTALLED_OEM_INF) {
            FormatToStream(stdout,MSG_DPDELETE_FAILED_NOT_OEM_INF);
        } else {
            FormatToStream(stdout,MSG_DPDELETE_FAILED);
        }
        goto final;
    }

    //
    // Successfully added the driver package to the machine.
    //
    FormatToStream(stdout,MSG_DPDELETE_SUCCESS,FilePart);
    failcode = EXIT_OK;

final:
    if (setupapiMod) {
        FreeLibrary(setupapiMod);
    }

    return failcode;
}

int cmdDPEnumLegacy(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PTSTR argv[])
/*++

Routine Description:
    dp_enumLegacy
    Enumerates installed Driver Packages on the machine pre Windows Longhorn

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    int failcode = EXIT_FAIL;
    TCHAR FindName[MAX_PATH];
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;

    UNREFERENCED_PARAMETER(BaseName);
    UNREFERENCED_PARAMETER(Machine);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(argv);

    if(argc) {
        return EXIT_USAGE;
    }

    if (!GetWindowsDirectory(FindName, ARRAYSIZE(FindName)) ||
        FAILED(StringCchCat(FindName, ARRAYSIZE(FindName), TEXT("\\INF\\OEM*.INF")))) {
        goto final;
    }

    hFind = FindFirstFile(FindName, &wfd);
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // No OEM driver packages on this machine.
        //
        FormatToStream(stdout,MSG_DPENUM_NO_OEM_INF);
        failcode = EXIT_OK;
        goto final;
    }

    FormatToStream(stdout,MSG_DPENUM_LIST_HEADER);

    do {
        FormatToStream(stdout,MSG_DPENUM_LIST_ENTRY,wfd.cFileName);
        DumpDriverPackageData(wfd.cFileName);
    } while (FindNextFile(hFind, &wfd));

    FindClose(hFind);

    failcode = EXIT_OK;

final:

    return failcode;
}


DispatchEntry DispatchTable[] = {
    { TEXT("classfilter"),  cmdClassFilter, MSG_CLASSFILTER_SHORT, MSG_CLASSFILTER_LONG },
    { TEXT("classes"),      cmdClasses,     MSG_CLASSES_SHORT,     MSG_CLASSES_LONG },
    { TEXT("disable"),      cmdDisable,     MSG_DISABLE_SHORT,     MSG_DISABLE_LONG },
    { TEXT("driverfiles"),  cmdDriverFiles, MSG_DRIVERFILES_SHORT, MSG_DRIVERFILES_LONG },
    { TEXT("drivernodes"),  cmdDriverNodes, MSG_DRIVERNODES_SHORT, MSG_DRIVERNODES_LONG },
    { TEXT("enable"),       cmdEnable,      MSG_ENABLE_SHORT,      MSG_ENABLE_LONG },
    { TEXT("find"),         cmdFind,        MSG_FIND_SHORT,        MSG_FIND_LONG },
    { TEXT("findall"),      cmdFindAll,     MSG_FINDALL_SHORT,     MSG_FINDALL_LONG },
    { TEXT("help"),         cmdHelp,        MSG_HELP_SHORT,        0 },
    { TEXT("hwids"),        cmdHwIds,       MSG_HWIDS_SHORT,       MSG_HWIDS_LONG },
    { TEXT("install"),      cmdInstall,     MSG_INSTALL_SHORT,     MSG_INSTALL_LONG },
    { TEXT("listclass"),    cmdListClass,   MSG_LISTCLASS_SHORT,   MSG_LISTCLASS_LONG },
    { TEXT("reboot"),       cmdReboot,      MSG_REBOOT_SHORT,      MSG_REBOOT_LONG },
    { TEXT("remove"),       cmdRemove,      MSG_REMOVE_SHORT,      MSG_REMOVE_LONG },
    { TEXT("removeall"),    cmdRemoveAll,   MSG_REMOVEALL_SHORT,   MSG_REMOVEALL_LONG },
    { TEXT("rescan"),       cmdRescan,      MSG_RESCAN_SHORT,      MSG_RESCAN_LONG },
    { TEXT("resources"),    cmdResources,   MSG_RESOURCES_SHORT,   MSG_RESOURCES_LONG },
    { TEXT("restart"),      cmdRestart,     MSG_RESTART_SHORT,     MSG_RESTART_LONG },
    { TEXT("sethwid"),      cmdSetHwid,     MSG_SETHWID_SHORT,     MSG_SETHWID_LONG },
    { TEXT("stack"),        cmdStack,       MSG_STACK_SHORT,       MSG_STACK_LONG },
    { TEXT("status"),       cmdStatus,      MSG_STATUS_SHORT,      MSG_STATUS_LONG },
    { TEXT("update"),       cmdUpdate,      MSG_UPDATE_SHORT,      MSG_UPDATE_LONG },
    { TEXT("updateni"),     cmdUpdateNI,    MSG_UPDATENI_SHORT,    MSG_UPDATENI_LONG },
    { TEXT("dp_add"),       cmdDPAdd,       MSG_DPADD_SHORT,       MSG_DPADD_LONG },
    { TEXT("dp_delete"),    cmdDPDelete,    MSG_DPDELETE_SHORT,    MSG_DPDELETE_LONG },
    { TEXT("dp_enum"),      cmdDPEnumLegacy,MSG_DPENUM_SHORT,      MSG_DPENUM_LONG },
    { TEXT("?"),            cmdHelp,        0,                     0 },
    { NULL,NULL }
};




```

`Drivers/Driver-SRC/setup/devcon/devcon.cpp`:

```cpp
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

--*/

#include "devcon.h"

struct IdEntry {
    LPCTSTR String;     // string looking for
    LPCTSTR Wild;       // first wild character if any
    BOOL    InstanceId;
};

void FormatToStream(_In_ FILE * stream, _In_ DWORD fmt,...)
/*++

Routine Description:

    Format text to stream using a particular msg-id fmt
    Used for displaying localizable messages

Arguments:

    stream              - file stream to output to, stdout or stderr
    fmt                 - message id
    ...                 - parameters %1...

Return Value:

    none

--*/
{
    va_list arglist;
    LPTSTR locbuffer = NULL;
    DWORD count;

    va_start(arglist, fmt);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          NULL,
                          fmt,
                          0,              // LANGID
                          (LPTSTR) &locbuffer,
                          0,              // minimum size of buffer
                          &arglist);

    if(locbuffer) {
        if(count) {
            // strip any trailing "\r\n"s and replace by a single "\n"
            LPTSTR p, q;
            for(p = q = locbuffer; *p != TEXT('\0'); p++) {
                if(p != q) {
                    *q = *p;
                }
                if(*p != TEXT('\r')) {
                    q++;
                }
            }
            *q = TEXT('\0');

            //
            // now write to apropriate stream
            //
            _fputts(locbuffer,stream);
        }
        LocalFree(locbuffer);
    }
}

void Padding(_In_ int pad)
/*++

Routine Description:

    Insert padding into line before text

Arguments:

    pad - number of padding tabs to insert

Return Value:

    none

--*/
{
    int c;

    for(c=0;c<pad;c++) {
        _fputts(TEXT("    "), stdout);
    }
}


void Usage(_In_ LPCTSTR BaseName)
/*++

Routine Description:

    Display simple usage text

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_USAGE,BaseName);
}

void CommandUsage(_In_ LPCTSTR BaseName, _In_ LPCTSTR Cmd)
/*++

Routine Description:

    Invalid command usage
    Display how to get help on command

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_COMMAND_USAGE,BaseName,Cmd);
}

void Failure(_In_ LPCTSTR BaseName, _In_ LPCTSTR Cmd)
/*++

Routine Description:

    Display simple error text for general failure

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_FAILURE,BaseName,Cmd);
}

BOOL Reboot()
/*++

Routine Description:

    Attempt to reboot computer

Arguments:

    none

Return Value:

    TRUE if API suceeded

--*/
{
    HANDLE Token;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // we need to "turn on" reboot privilege
    // if any of this fails, try reboot anyway
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        goto final;
    }

    if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
        CloseHandle(Token);
        goto final;
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

final:

    //
    // attempt reboot - inform system that this is planned hardware install
    //
    // warning 28159 is a warning to rearchitect to avoid rebooting.  However,
    // sometimes during device installation, a reboot is needed, so this warning
    // is being suppressed for the call to InitiateSystemShutdownEx.
    //
#pragma warning( suppress: 28159)
    return InitiateSystemShutdownEx(NULL,
                                    NULL,
                                    0,
                                    FALSE,
                                    TRUE,
                                    REASON_PLANNED_FLAG | REASON_HWINSTALL);

}

LPTSTR GetDeviceStringProperty(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Prop)
/*++

Routine Description:

    Return a string property for a device, otherwise NULL

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )
    Prop     - string property to obtain

Return Value:

    string containing description

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    DWORD szChars;

    size = 1024; // initial guess
    buffer = new TCHAR[(size/sizeof(TCHAR))+1];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+1];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    return buffer;

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

LPTSTR GetDeviceDescription(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Return a string containing a description of the device, otherwise NULL
    Always try friendly name first

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    string containing description

--*/
{
    LPTSTR desc;
    desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_FRIENDLYNAME);
    if(!desc) {
        desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_DEVICEDESC);
    }
    return desc;
}

IdEntry GetIdType(_In_ LPCTSTR Id)
/*++

Routine Description:

    Determine if this is instance id or hardware id and if there's any wildcards
    instance ID is prefixed by '@'
    wildcards are '*'


Arguments:

    Id - ptr to string to check

Return Value:

    IdEntry

--*/
{
    IdEntry Entry;

    Entry.InstanceId = FALSE;
    Entry.Wild = NULL;
    Entry.String = Id;

    if(Entry.String[0] == INSTANCEID_PREFIX_CHAR) {
        Entry.InstanceId = TRUE;
        Entry.String = CharNext(Entry.String);
    }
    if(Entry.String[0] == QUOTE_PREFIX_CHAR) {
        //
        // prefix to treat rest of string literally
        //
        Entry.String = CharNext(Entry.String);
    } else {
        //
        // see if any wild characters exist
        //
        Entry.Wild = _tcschr(Entry.String,WILD_CHAR);
    }
    return Entry;
}

__drv_allocatesMem(object)
LPTSTR * GetMultiSzIndexArray(_In_ __drv_aliasesMem LPTSTR MultiSz)
/*++

Routine Description:

    Get an index array pointing to the MultiSz passed in

Arguments:

    MultiSz - well formed multi-sz string

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR scan;
    LPTSTR * array;
    int elements;

    for(scan = MultiSz, elements = 0; scan[0] ;elements++) {
        scan += _tcslen(scan)+1;
    }
    array = new LPTSTR[elements+2];
    if(!array) {
        return NULL;
    }
    array[0] = MultiSz;
    array++;
    if(elements) {
        for(scan = MultiSz, elements = 0; scan[0]; elements++) {
            array[elements] = scan;
            scan += _tcslen(scan)+1;
        }
    }
    array[elements] = NULL;
    return array;
}

__drv_allocatesMem(object)
LPTSTR * CopyMultiSz(_In_opt_ PZPWSTR Array)
/*++

Routine Description:

    Creates a new array from old
    old array need not have been allocated by GetMultiSzIndexArray

Arguments:

    Array - array of strings, last entry is NULL

Return Value:

    MultiSz array allocated by GetMultiSzIndexArray

--*/
{
    LPTSTR multiSz = NULL;
    HRESULT hr;
    int cchMultiSz = 0;
    int c;
    if(Array) {
        for(c=0;Array[c];c++) {
            cchMultiSz+=(int)_tcslen(Array[c])+1;
        }
    }
    cchMultiSz+=1; // final Null
    multiSz = new TCHAR[cchMultiSz];
    if(!multiSz) {
        return NULL;
    }
    int len = 0;
    if(Array) {
        for(c=0;Array[c];c++) {
            hr = StringCchCopy(multiSz+len,cchMultiSz-len,Array[c]);
            if(FAILED(hr)){
                if(multiSz)
                    delete [] multiSz;
                return NULL;
            }

#pragma prefast(suppress:__WARNING_BUFFER_OVERFLOW, "ESP:732")
            len+=(int)_tcslen(multiSz+len)+1;
        }
    }

    if( len < cchMultiSz ){
        multiSz[len] = TEXT('\0');
    } else {
        // This should never happen!
        multiSz[cchMultiSz-1] = TEXT('\0');
    }

    LPTSTR * pRes = GetMultiSzIndexArray(multiSz);
    if(pRes) {
        return pRes;
    }
    delete [] multiSz;

    return NULL;
}

void DelMultiSz(_In_opt_ __drv_freesMem(object) PZPWSTR Array)
/*++

Routine Description:

    Deletes the string array allocated by GetDevMultiSz/GetRegMultiSz/GetMultiSzIndexArray

Arguments:

    Array - pointer returned by GetMultiSzIndexArray

Return Value:

    None

--*/
{
    if(Array) {
        Array--;
        if(Array[0]) {
            delete [] Array[0];
        }
        delete [] Array;
    }
}

__drv_allocatesMem(object)
LPTSTR * GetDevMultiSz(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Prop)
/*++

Routine Description:

    Get a multi-sz device property
    and return as an array of strings

Arguments:

    Devs    - HDEVINFO containing DevInfo
    DevInfo - Specific device
    Prop    - SPDRP_HARDWAREID or SPDRP_COMPATIBLEIDS

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');
    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

__drv_allocatesMem(object)
LPTSTR * GetRegMultiSz(_In_ HKEY hKey, _In_ LPCTSTR Val)
/*++

Routine Description:

    Get a multi-sz from registry
    and return as an array of strings

Arguments:

    hKey    - Registry Key
    Val     - Value to query

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;
    LONG regErr;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    reqSize = size;
    regErr = RegQueryValueEx(hKey,Val,NULL,&dataType,(PBYTE)buffer,&reqSize);
    while((regErr != NO_ERROR)) {
        if(GetLastError() != ERROR_MORE_DATA) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
	regErr = RegQueryValueEx(hKey,Val,NULL,&dataType,(PBYTE)buffer,&reqSize);
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');

    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

BOOL WildCardMatch(_In_ LPCTSTR Item, _In_ const IdEntry & MatchEntry)
/*++

Routine Description:

    Compare a single item against wildcard
    I'm sure there's better ways of implementing this
    Other than a command-line management tools
    it's a bad idea to use wildcards as it implies
    assumptions about the hardware/instance ID
    eg, it might be tempting to enumerate root\* to
    find all root devices, however there is a CfgMgr
    API to query status and determine if a device is
    root enumerated, which doesn't rely on implementation
    details.

Arguments:

    Item - item to find match for eg a\abcd\c
    MatchEntry - eg *\*bc*\*

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    LPCTSTR scanItem;
    LPCTSTR wildMark;
    LPCTSTR nextWild;
    size_t matchlen;

    //
    // before attempting anything else
    // try and compare everything up to first wild
    //
    if(!MatchEntry.Wild) {
        return _tcsicmp(Item,MatchEntry.String) ? FALSE : TRUE;
    }
    if(_tcsnicmp(Item,MatchEntry.String,MatchEntry.Wild-MatchEntry.String) != 0) {
        return FALSE;
    }
    wildMark = MatchEntry.Wild;
    scanItem = Item + (MatchEntry.Wild-MatchEntry.String);

    for(;wildMark[0];) {
        //
        // if we get here, we're either at or past a wildcard
        //
        if(wildMark[0] == WILD_CHAR) {
            //
            // so skip wild chars
            //
            wildMark = CharNext(wildMark);
            continue;
        }
        //
        // find next wild-card
        //
        nextWild = _tcschr(wildMark,WILD_CHAR);
        if(nextWild) {
            //
            // substring
            //
            matchlen = nextWild-wildMark;
        } else {
            //
            // last portion of match
            //
            size_t scanlen = _tcslen(scanItem);
            matchlen = _tcslen(wildMark);
            if(scanlen < matchlen) {
                return FALSE;
            }
            return _tcsicmp(scanItem+scanlen-matchlen,wildMark) ? FALSE : TRUE;
        }
        if(_istalpha(wildMark[0])) {
            //
            // scan for either lower or uppercase version of first character
            //

            //
            // the code suppresses the warning 28193 for the calls to _totupper
            // and _totlower.  This suppression is done because those functions
            // have a check return annotation on them.  However, they don't return
            // error codes and the check return annotation is really being used
            // to indicate that the return value of the function should be looked
            // at and/or assigned to a variable.  The check return annotation means
            // the return value should always be checked in all code paths.
            // We assign the return values to variables but the while loop does not
            // examine both values in all code paths (e.g. when scanItem[0] == 0,
            // neither u nor l will be examined) and it doesn't need to examine
            // the values in all code paths.
            //
#pragma warning( suppress: 28193)
            TCHAR u = _totupper(wildMark[0]);
#pragma warning( suppress: 28193)
            TCHAR l = _totlower(wildMark[0]);
            while(scanItem[0] && scanItem[0]!=u && scanItem[0]!=l) {
                scanItem = CharNext(scanItem);
            }
            if(!scanItem[0]) {
                //
                // ran out of string
                //
                return FALSE;
            }
        } else {
            //
            // scan for first character (no case)
            //
            scanItem = _tcschr(scanItem,wildMark[0]);
            if(!scanItem) {
                //
                // ran out of string
                //
                return FALSE;
            }
        }
        //
        // try and match the sub-string at wildMark against scanItem
        //
        if(_tcsnicmp(scanItem,wildMark,matchlen)!=0) {
            //
            // nope, try again
            //
            scanItem = CharNext(scanItem);
            continue;
        }
        //
        // substring matched
        //
        scanItem += matchlen;
        wildMark += matchlen;
    }
    return (wildMark[0] ? FALSE : TRUE);
}

BOOL WildCompareHwIds(_In_ PZPWSTR Array, _In_ const IdEntry & MatchEntry)
/*++

Routine Description:

    Compares all strings in Array against Id
    Use WildCardMatch to do real compare

Arguments:

    Array - pointer returned by GetDevMultiSz
    MatchEntry - string to compare against

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    if(Array) {
        while(Array[0]) {
            if(WildCardMatch(Array[0],MatchEntry)) {
                return TRUE;
            }
            Array++;
        }
    }
    return FALSE;
}

bool SplitCommandLine(
    _In_ int & argc,
    _In_reads_(argc) LPTSTR * & argv,
    _Out_ int & argc_right,
    _Outref_result_buffer_(argc_right) LPTSTR * & argv_right)
/*++

Routine Description:

    Splits a command line into left and right of :=
    this is used for some of the more complex commands

Arguments:

    argc/argv - in/out
                - in, specifies the existing argc/argv
                - out, specifies the argc/argv to left of :=
    arc_right/argv_right - out
                - specifies the argc/argv to right of :=

Return Value:

    true - ":=" appears in line, false otherwise

--*/
{
    int i;
    for(i = 0;i<argc;i++) {
        if(_tcsicmp(argv[i],SPLIT_COMMAND_SEP)==0) {
            argc_right = argc-(i+1);
            argv_right = argv+(i+1);
            argc = i;
            return true;
        }
    }
    argc_right = 0;
    argv_right = argv+argc;
    return false;
}

int EnumerateDevices(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PWSTR* argv, _In_ CallbackFunc Callback, _In_ LPVOID Context)
/*++

Routine Description:

    Generic enumerator for devices that will be passed the following arguments:
    <id> [<id>...]
    =<class> [<id>...]
    where <id> can either be @instance-id, or hardware-id and may contain wildcards
    <class> is a class name

Arguments:

    BaseName - name of executable
    Machine  - name of machine to enumerate
    Flags    - extra enumeration flags (eg DIGCF_PRESENT)
    argc/argv - remaining arguments on command line
    Callback - function to call for each hit
    Context  - data to pass function for each hit

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO devs = INVALID_HANDLE_VALUE;
    IdEntry * templ = NULL;
    int failcode = EXIT_FAIL;
    int retcode;
    int argIndex;
    DWORD devIndex;
    SP_DEVINFO_DATA devInfo;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    BOOL doSearch = FALSE;
    BOOL match;
    BOOL all = FALSE;
    GUID cls;
    DWORD numClass = 0;
    int skip = 0;

    UNREFERENCED_PARAMETER(BaseName);

    if(!argc) {
        return EXIT_USAGE;
    }

    templ = new IdEntry[argc];
    if(!templ) {
        goto final;
    }

    //
    // determine if a class is specified
    //
    if(argc>skip && argv[skip][0]==CLASS_PREFIX_CHAR && argv[skip][1]) {
        if(!SetupDiClassGuidsFromNameEx(argv[skip]+1,&cls,1,&numClass,Machine,NULL) &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
        if(!numClass) {
            failcode = EXIT_OK;
            goto final;
        }
        skip++;
    }
    if(argc>skip && argv[skip][0]==WILD_CHAR && !argv[skip][1]) {
        //
        // catch convinient case of specifying a single argument '*'
        //
        all = TRUE;
        skip++;
    } else if(argc<=skip) {
        //
        // at least one parameter, but no <id>'s
        //
        all = TRUE;
    }

    //
    // determine if any instance id's were specified
    //
    // note, if =<class> was specified with no id's
    // we'll mark it as not doSearch
    // but will go ahead and add them all
    //
    for(argIndex=skip;argIndex<argc;argIndex++) {
        templ[argIndex] = GetIdType(argv[argIndex]);
        if(templ[argIndex].Wild || !templ[argIndex].InstanceId) {
            //
            // anything other than simple InstanceId's require a search
            //
            doSearch = TRUE;
        }
    }
    if(doSearch || all) {
        //
        // add all id's to list
        // if there's a class, filter on specified class
        //
        devs = SetupDiGetClassDevsEx(numClass ? &cls : NULL,
                                     NULL,
                                     NULL,
                                     (numClass ? 0 : DIGCF_ALLCLASSES) | Flags,
                                     NULL,
                                     Machine,
                                     NULL);

    } else {
        //
        // blank list, we'll add instance id's by hand
        //
        devs = SetupDiCreateDeviceInfoListEx(numClass ? &cls : NULL,
                                             NULL,
                                             Machine,
                                             NULL);
    }
    if(devs == INVALID_HANDLE_VALUE) {
        goto final;
    }
    for(argIndex=skip;argIndex<argc;argIndex++) {
        //
        // add explicit instances to list (even if enumerated all,
        // this gets around DIGCF_PRESENT)
        // do this even if wildcards appear to be detected since they
        // might actually be part of the instance ID of a non-present device
        //
        if(templ[argIndex].InstanceId) {
            SetupDiOpenDeviceInfo(devs,templ[argIndex].String,NULL,0,NULL);
        }
    }

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(devs,&devInfoListDetail)) {
        goto final;
    }

    //
    // now enumerate them
    //
    if(all) {
        doSearch = FALSE;
    }

    devInfo.cbSize = sizeof(devInfo);
    for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {

        if(doSearch) {
            for(argIndex=skip,match=FALSE;(argIndex<argc) && !match;argIndex++) {
                TCHAR devID[MAX_DEVICE_ID_LEN];
                LPTSTR *hwIds = NULL;
                LPTSTR *compatIds = NULL;
                //
                // determine instance ID
                //
                if(CM_Get_Device_ID_Ex(devInfo.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) {
                    devID[0] = TEXT('\0');
                }

                if(templ[argIndex].InstanceId) {
                    //
                    // match on the instance ID
                    //
                    if(WildCardMatch(devID,templ[argIndex])) {
                        match = TRUE;
                    }
                } else {
                    //
                    // determine hardware ID's
                    // and search for matches
                    //
                    hwIds = GetDevMultiSz(devs,&devInfo,SPDRP_HARDWAREID);
                    compatIds = GetDevMultiSz(devs,&devInfo,SPDRP_COMPATIBLEIDS);

                    if(WildCompareHwIds(hwIds,templ[argIndex]) ||
                        WildCompareHwIds(compatIds,templ[argIndex])) {
                        match = TRUE;
                    }
                }
                DelMultiSz(hwIds);
                DelMultiSz(compatIds);
            }
        } else {
            match = TRUE;
        }
        if(match) {
            retcode = Callback(devs,&devInfo,devIndex,Context);
            if(retcode) {
                failcode = retcode;
                goto final;
            }
        }
    }

    failcode = EXIT_OK;

final:
    if(templ) {
        delete [] templ;
    }
    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }
    return failcode;

}

int
__cdecl
_tmain(_In_ int argc, _In_reads_(argc) PWSTR* argv)
/*++

Routine Description:

    Main entry point
    interpret -m:<machine>
    and hand off execution to command

Arguments:

    argc/argv - parameters passed to executable

Return Value:

    EXIT_xxxx

--*/
{
    LPCTSTR cmd;
    LPCTSTR baseName;
    LPCTSTR machine = NULL;
    int dispIndex;
    int firstArg = 1;
    int retval = EXIT_USAGE;
    BOOL autoReboot = FALSE;
    DWORD flags = 0;

    //
    // syntax:
    //
    // [options] [-]command [<arg> [<arg>]]
    //
    // options:
    // -m:<machine>  - remote
    // -r            - auto reboot
    // -f            - force operation
    // -u            - unicode output
    //

    baseName = _tcsrchr(argv[0],TEXT('\\'));
    if(!baseName) {
        baseName = argv[0];
    } else {
        baseName = CharNext(baseName);
    }
    while((argc > firstArg) && ((argv[firstArg][0] == TEXT('-')) || (argv[firstArg][0] == TEXT('/')))) {
        if((argv[firstArg][1]==TEXT('m')) || (argv[firstArg][1]==TEXT('M'))) {
            if((argv[firstArg][2]!=TEXT(':')) || (argv[firstArg][3]==TEXT('\0'))) {
                //
                // don't recognize this switch
                //
                break;
            }
            machine = argv[firstArg]+3;
        } else if((argv[firstArg][1]==TEXT('r')) || (argv[firstArg][1]==TEXT('R'))) {
            if((argv[firstArg][2]!=TEXT('\0')) ) {
                //
                // don't recognize this switch
                //
                break;
            } else {
                autoReboot = TRUE;
            }
        } else if((argv[firstArg][1]==TEXT('f')) || (argv[firstArg][1]==TEXT('F'))) {
            if((argv[firstArg][2]!=TEXT('\0')) ) {
                //
                // don't recognize this switch
                //
                break;
            } else {
                flags |= DEVCON_FLAG_FORCE;
            }
        } else if((argv[firstArg][1]==TEXT('u')) || (argv[firstArg][1]==TEXT('U'))) {
            if((argv[firstArg][2]!=TEXT('\0')) ) {
                //
                // don't recognize this switch
                //
                break;
            } else {
#ifdef UNICODE
                _setmode(_fileno(stdout), _O_WTEXT);
                _setmode(_fileno(stderr), _O_WTEXT);
#endif
            }
        } else {
            //
            // don't recognize this switch
            //
            break;
        }
        firstArg++;
    }

    if((argc-firstArg) < 1) {
        //
        // after switches, must at least be command
        //
        Usage(baseName);
        return EXIT_USAGE;
    }
    cmd = argv[firstArg];
    if((cmd[0]==TEXT('-')) || (cmd[0]==TEXT('/'))) {
        //
        // command may begin '-' or '/'
        // eg, people might do devcon -help
        //
        cmd = CharNext(cmd);
    }
    firstArg++;
    for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
        if ((_tcsicmp(cmd,DispatchTable[dispIndex].cmd) == 0) &&
            (argc >= firstArg)) {
            retval = DispatchTable[dispIndex].func(baseName,machine,flags,argc-firstArg,argv+firstArg);
            switch(retval) {
                case EXIT_USAGE:
                    CommandUsage(baseName,DispatchTable[dispIndex].cmd);
                    break;
                case EXIT_REBOOT:
                    if(autoReboot) {
                        Reboot();
                    }
                    break;
                case EXIT_OK:
                    break;
                default:
                    Failure(baseName,DispatchTable[dispIndex].cmd);
                    break;
            }
            return retval;
        }
    }
    Usage(baseName);
    return EXIT_USAGE;
}



```

`Drivers/Driver-SRC/setup/devcon/devcon.h`:

```h
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.h

Abstract:

    Device Console header

--*/

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <regstr.h>
#include <infstr.h>
#include <cfgmgr32.h>
#include <string.h>
#include <malloc.h>
#include <newdev.h>
#include <objbase.h>
#include <strsafe.h>
#include <io.h>
#include <fcntl.h>

#include "msg.h"
#include "rc_ids.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

typedef int (*DispatchFunc)(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_ LPTSTR argv[]);
typedef int (*CallbackFunc)(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Index, _In_ LPVOID Context);

typedef struct {
    LPCTSTR         cmd;
    DispatchFunc    func;
    DWORD           shortHelp;
    DWORD           longHelp;
} DispatchEntry;

extern DispatchEntry DispatchTable[];

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#define INSTANCEID_PREFIX_CHAR TEXT('@') // character used to prefix instance ID's
#define CLASS_PREFIX_CHAR      TEXT('=') // character used to prefix class name
#define WILD_CHAR              TEXT('*') // wild character
#define QUOTE_PREFIX_CHAR      TEXT('\'') // prefix character to ignore wild characters
#define SPLIT_COMMAND_SEP      TEXT(":=") // whole word, indicates end of id's

//
// Devcon.exe command line flags
//
#define DEVCON_FLAG_FORCE       0x00000001

void FormatToStream(_In_ FILE * stream, _In_ DWORD fmt,...);
void Padding(_In_ int pad);
bool SplitCommandLine(
    _In_ int & argc,
    _In_reads_(argc) LPTSTR * & argv,
    _Out_ int & argc_right,
    _Outref_result_buffer_(argc_right) LPTSTR * & argv_right);
int EnumerateDevices(_In_ LPCTSTR BaseName, _In_opt_ LPCTSTR Machine, _In_ DWORD Flags, _In_ int argc, _In_reads_(argc) PWSTR* argv, _In_ CallbackFunc Callback, _In_ LPVOID Context);
LPTSTR GetDeviceStringProperty(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Prop);
LPTSTR GetDeviceDescription(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
__drv_allocatesMem(object) LPTSTR * GetDevMultiSz(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ DWORD Prop);
__drv_allocatesMem(object) LPTSTR * GetRegMultiSz(_In_ HKEY hKey, _In_ LPCTSTR Val);
__drv_allocatesMem(object) LPTSTR * GetMultiSzIndexArray(_In_ __drv_aliasesMem LPTSTR MultiSz);
void DelMultiSz(_In_opt_ __drv_freesMem(object) PZPWSTR Array);
__drv_allocatesMem(object) LPTSTR * CopyMultiSz(_In_opt_ PZPWSTR Array);

BOOL DumpArray(_In_ int pad, _In_ PZPWSTR Array);
BOOL DumpDevice(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceClass(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDescr(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceStatus(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceResources(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverFiles(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverNodes(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceHwIds(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceWithInfo(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_opt_ LPCTSTR Info);
BOOL DumpDeviceStack(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo);
BOOL DumpDriverPackageData(_In_ LPCTSTR InfName);
BOOL Reboot();


//
// UpdateDriverForPlugAndPlayDevices
//
typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProto)(_In_opt_ HWND hwndParent,
                                                              _In_ LPCTSTR HardwareId,
                                                              _In_ LPCTSTR FullInfPath,
                                                              _In_ DWORD InstallFlags,
                                                              _Out_opt_ PBOOL bRebootRequired
                                                         );
typedef BOOL (WINAPI *SetupSetNonInteractiveModeProto)(_In_ BOOL NonInteractiveFlag
                                                      );
typedef BOOL (WINAPI *SetupUninstallOEMInfProto)(_In_ LPCTSTR InfFileName,
                                                 _In_ DWORD Flags,
                                                 _Reserved_ PVOID Reserved
                                                 );

#if _SETUPAPI_VER >= _WIN32_WINNT_WINXP
typedef BOOL (WINAPI *SetupVerifyInfFileProto)(_In_ LPCTSTR InfName,
                                               _In_opt_ PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,
                                               _Inout_ PSP_INF_SIGNER_INFO InfSignerInfo );
#endif

#ifdef _UNICODE
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesW"
#define SETUPUNINSTALLOEMINF "SetupUninstallOEMInfW"
#else
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesA"
#define SETUPUNINSTALLOEMINF "SetupUninstallOEMInfA"
#endif
#define SETUPSETNONINTERACTIVEMODE "SetupSetNonInteractiveMode"
#define SETUPVERIFYINFFILE "SetupVerifyInfFile"

//
// exit codes
//
#define EXIT_OK      (0)
#define EXIT_REBOOT  (1)
#define EXIT_FAIL    (2)
#define EXIT_USAGE   (3)


```

`Drivers/Driver-SRC/setup/devcon/devcon.rc`:

```rc
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <commctrl.h>
#include "rc_ids.h"

STRINGTABLE DISCARDABLE
{
    IDS_ENABLED,          "Enabled"
    IDS_ENABLED_REBOOT,   "Enabled on reboot"
    IDS_ENABLE_FAILED,    "Enable failed"
    IDS_DISABLED,         "Disabled"
    IDS_DISABLED_REBOOT,  "Disabled on reboot"
    IDS_DISABLE_FAILED,   "Disable failed"
    IDS_RESTARTED,        "Restarted"
    IDS_REQUIRES_REBOOT,  "Requires reboot"
    IDS_RESTART_FAILED,   "Restart failed"
    IDS_REMOVED,          "Removed"
    IDS_REMOVED_REBOOT,   "Removed on reboot"
    IDS_REMOVE_FAILED,    "Remove failed"
}


//
// Version resources
//
#include <ntverp.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Windows Setup API"
#define VER_INTERNALNAME_STR        "SETUPAPI.DLL"
#define VER_ORIGINALFILENAME_STR    "SETUPAPI.DLL"
#include <common.ver>

#include "msg.rc"

```

`Drivers/Driver-SRC/setup/devcon/devcon.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0
MinimumVisualStudioVersion = 12.0
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "devcon", "devcon.vcxproj", "{14EDBD07-E4CD-4BD8-82CC-F2840C160570}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|ARM64.Build.0 = Debug|ARM64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|Win32.ActiveCfg = Debug|Win32
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|Win32.Build.0 = Debug|Win32
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|x64.ActiveCfg = Debug|x64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Debug|x64.Build.0 = Debug|x64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|ARM64.ActiveCfg = Release|ARM64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|ARM64.Build.0 = Release|ARM64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|Win32.ActiveCfg = Release|Win32
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|Win32.Build.0 = Release|Win32
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|x64.ActiveCfg = Release|x64
		{14EDBD07-E4CD-4BD8-82CC-F2840C160570}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/setup/devcon/devcon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{14EDBD07-E4CD-4BD8-82CC-F2840C160570}</ProjectGuid>
    <RootNamespace>$(MSBuildProjectName)</RootNamespace>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <SampleGuid>{FDCF5960-709F-48C2-A9D0-9F3F6BE0CAC9}</SampleGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(IntDir)</OutDir>
  </PropertyGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ItemGroup Label="WrappedTaskItems" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <TargetName>devcon</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <TreatWarningAsError>true</TreatWarningAsError>
      <WarningLevel>Level4</WarningLevel>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);UNICODE;_UNICODE</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);advapi32.lib;kernel32.lib;ntdll.lib;ole32.lib;setupapi.lib;shell32.lib;user32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cmds.cpp" />
    <ClCompile Include="devcon.cpp" />
    <ClCompile Include="dump.cpp" />
    <MessageCompile Include="msg.mc" />
    <ResourceCompile Include="devcon.rc" />
  </ItemGroup>
  <ItemGroup>
    <Inf Exclude="@(Inf)" Include="*.inf" />
    <FilesToPackage Include="$(TargetPath)" Condition="'$(ConfigurationType)'=='Driver' or '$(ConfigurationType)'=='DynamicLibrary'" />
  </ItemGroup>
  <ItemGroup>
    <None Exclude="@(None)" Include="*.txt;*.htm;*.html" />
    <None Exclude="@(None)" Include="*.ico;*.cur;*.bmp;*.dlg;*.rct;*.gif;*.jpg;*.jpeg;*.wav;*.jpe;*.tiff;*.tif;*.png;*.rc2" />
    <None Exclude="@(None)" Include="*.def;*.bat;*.hpj;*.asmx" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Exclude="@(ClInclude)" Include="*.h;*.hpp;*.hxx;*.hm;*.inl;*.xsd" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`Drivers/Driver-SRC/setup/devcon/devcon.vcxproj.Filters`:

```Filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx;*</Extensions>
      <UniqueIdentifier>{FDCB0202-4D4E-4FB6-BDEC-331565697E42}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
      <UniqueIdentifier>{E7212D5A-ECFD-4775-841D-7F30A7B02793}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms;man;xml</Extensions>
      <UniqueIdentifier>{AD545432-CD18-4921-BE33-91FC936D062B}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cmds.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="devcon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dump.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="devcon.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/setup/devcon/dump.cpp`:

```cpp
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dump.cpp

Abstract:

    Device Console
    dump information out about a particular device

--*/

#include "devcon.h"

BOOL DumpDeviceWithInfo(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_opt_ LPCTSTR Info)
/*++

Routine Description:

    Write device instance & info to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    TCHAR devID[MAX_DEVICE_ID_LEN];
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        StringCchCopy(devID, ARRAYSIZE(devID), TEXT("?"));
        b = FALSE;
    }

    if(Info) {
        _tprintf(TEXT("%-60s: %s\n"),devID,Info);
    } else {
        _tprintf(TEXT("%s\n"),devID);
    }
    return b;
}

BOOL DumpDevice(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;
    BOOL b;

    desc = GetDeviceDescription(Devs,DevInfo);
    b = DumpDeviceWithInfo(Devs,DevInfo,desc);
    if(desc) {
        delete [] desc;
    }
    return b;
}

BOOL DumpDeviceDescr(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;

    desc = GetDeviceDescription(Devs,DevInfo);
    if(!desc) {
        return FALSE;
    }
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DESCRIPTION,desc);
    delete [] desc;
    return TRUE;
}

BOOL DumpDeviceClass(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device class information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR cls;
    LPTSTR guid;

    Padding(1);
    cls = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASS);
    guid = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASSGUID);
    if(!cls && !guid) {
        FormatToStream(stdout,
                        MSG_DUMP_NOSETUPCLASS
                        );
    } else {
        FormatToStream(stdout,
                        MSG_DUMP_SETUPCLASS,
                        guid ? guid : TEXT("{}"),
                        cls ? cls : TEXT("(?)")
                        );
    }

    if(cls) {
        delete [] cls;
    }
    if(guid) {
        delete [] guid;
    }

    return TRUE;
}

BOOL DumpDeviceStatus(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device status to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    BOOL hasInfo = FALSE;
    BOOL isPhantom = FALSE;
    CONFIGRET cr = CR_SUCCESS;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            ((cr = CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle))!=CR_SUCCESS)) {
        if ((cr == CR_NO_SUCH_DEVINST) || (cr == CR_NO_SUCH_VALUE)) {
            isPhantom = TRUE;
        } else {
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_STATUS_ERROR);
            return FALSE;
        }
    }
    //
    // handle off the status/problem codes
    //
    if (isPhantom) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PHANTOM);
        return TRUE;
    }
    if((status & DN_HAS_PROBLEM) && problem == CM_PROB_DISABLED) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DISABLED);
        return TRUE;
    }
    if(status & DN_HAS_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PROBLEM,problem);
    }
    if(status & DN_PRIVATE_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PRIVATE_PROBLEM);
    }
    if(status & DN_STARTED) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_STARTED);
    } else if (!hasInfo) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_NOTSTARTED);
    }
    return TRUE;
}

BOOL DumpDeviceResourcesOfType(_In_ DEVINST DevInst, _In_ HMACHINE MachineHandle, _In_ LOG_CONF Config, _In_ RESOURCEID ReqResId)
{
    RES_DES prevResDes = (RES_DES)Config;
    RES_DES resDes = 0;
    RESOURCEID resId = ReqResId;
    ULONG dataSize;
    PBYTE resDesData;
    BOOL  retval = FALSE;

    UNREFERENCED_PARAMETER(DevInst);

    while(CM_Get_Next_Res_Des_Ex(&resDes,prevResDes,ReqResId,&resId,0,MachineHandle)==CR_SUCCESS) {
        if(prevResDes != Config) {
            CM_Free_Res_Des_Handle(prevResDes);
        }
        prevResDes = resDes;
        if(CM_Get_Res_Des_Data_Size_Ex(&dataSize,resDes,0,MachineHandle)!=CR_SUCCESS) {
            continue;
        }
        resDesData = new BYTE[dataSize];
        if(!resDesData) {
            continue;
        }
        if(CM_Get_Res_Des_Data_Ex(resDes,resDesData,dataSize,0,MachineHandle)!=CR_SUCCESS) {
            delete [] resDesData;
            continue;
        }
        switch(resId) {
            case ResType_Mem: {

                PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)resDesData;
                if(pMemData->MEM_Header.MD_Alloc_End-pMemData->MEM_Header.MD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("MEM : %08I64x-%08I64x\n"),pMemData->MEM_Header.MD_Alloc_Base,pMemData->MEM_Header.MD_Alloc_End);
                    retval = TRUE;
                }
                break;
            }

            case ResType_IO: {

                PIO_RESOURCE   pIoData = (PIO_RESOURCE)resDesData;
                if(pIoData->IO_Header.IOD_Alloc_End-pIoData->IO_Header.IOD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("IO  : %04I64x-%04I64x\n"),pIoData->IO_Header.IOD_Alloc_Base,pIoData->IO_Header.IOD_Alloc_End);
                    retval = TRUE;
                }
                break;
            }

            case ResType_DMA: {

                PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)resDesData;
                Padding(2);
                _tprintf(TEXT("DMA : %u\n"),pDmaData->DMA_Header.DD_Alloc_Chan);
                retval = TRUE;
                break;
            }

            case ResType_IRQ: {

                PIRQ_RESOURCE  pIrqData = (PIRQ_RESOURCE)resDesData;

                Padding(2);
                _tprintf(TEXT("IRQ : %u\n"),pIrqData->IRQ_Header.IRQD_Alloc_Num);
                retval = TRUE;
                break;
            }
        }
        delete [] resDesData;
    }
    if(prevResDes != Config) {
        CM_Free_Res_Des_Handle(prevResDes);
    }
    return retval;
}

BOOL DumpDeviceResources(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump Resources to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    LOG_CONF config = 0;
    BOOL haveConfig = FALSE;

    //
    // see what state the device is in
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return FALSE;
    }

    //
    // see if the device is running and what resources it might be using
    //
    if(!(status & DN_HAS_PROBLEM)) {
        //
        // If this device is running, does this devinst have a ALLOC log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     ALLOC_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }
    if(!haveConfig) {
        //
        // If no config so far, does it have a FORCED log config?
        // (note that technically these resources might be used by another device
        // but is useful info to show)
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     FORCED_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }

    if(!haveConfig) {
        //
        // if there's a hardware-disabled problem, boot-config isn't valid
        // otherwise use this if we don't have anything else
        //
        if(!(status & DN_HAS_PROBLEM) || (problem != CM_PROB_HARDWARE_DISABLED)) {
            //
            // Does it have a BOOT log config?
            //
            if (CM_Get_First_Log_Conf_Ex(&config,
                                         DevInfo->DevInst,
                                         BOOT_LOG_CONF,
                                         devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
                haveConfig = TRUE;
            }
        }
    }

    if(!haveConfig) {
        //
        // if we don't have any configuration, display an apropriate message
        //
        Padding(1);
        FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_NO_RESOURCES : MSG_DUMP_NO_RESERVED_RESOURCES );
        return TRUE;
    }
    Padding(1);
    FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_RESOURCES : MSG_DUMP_RESERVED_RESOURCES );

    //
    // dump resources
    //
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_All);

    //
    // release handle
    //
    CM_Free_Log_Conf_Handle(config);

    return TRUE;
}

UINT CALLBACK DumpDeviceDriversCallback(_In_ PVOID Context, _In_ UINT Notification, _In_ UINT_PTR Param1, _In_ UINT_PTR Param2)
/*++

Routine Description:

    if Context provided, Simply count
    otherwise dump files indented 2

Arguments:

    Context      - DWORD Count
    Notification - SPFILENOTIFY_QUEUESCAN
    Param1       - scan

Return Value:

    none

--*/
{
    LPDWORD count = (LPDWORD)Context;
    LPTSTR file = (LPTSTR)Param1;

    UNREFERENCED_PARAMETER(Notification);
    UNREFERENCED_PARAMETER(Param2);

    if(count) {
        count[0]++;
    } else {
        Padding(2);
        _tprintf(TEXT("%s\n"),file);
    }

    return NO_ERROR;
}

BOOL FindCurrentDriver(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo, _In_ PSP_DRVINFO_DATA DriverInfoData)
/*++

Routine Description:

    Find the driver that is associated with the current device
    We can do this either the quick way (available in WinXP)
    or the long way that works in Win2k.

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if we managed to determine and select current driver

--*/
{
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    WCHAR SectionName[LINE_LEN];
    WCHAR DrvDescription[LINE_LEN];
    WCHAR MfgName[LINE_LEN];
    WCHAR ProviderName[LINE_LEN];
    HKEY hKey = NULL;
    DWORD RegDataLength;
    DWORD RegDataType;
    DWORD c;
    BOOL match = FALSE;
    long regerr;

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

#ifdef DI_FLAGSEX_INSTALLEDDRIVER
    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the
    // currently installed driver node in the list, and that it should allow
    // excluded drivers. This flag introduced in WinXP.
    //
    deviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        //
        // we were able to specify this flag, so proceed the easy way
        // we should get a list of no more than 1 driver
        //
        if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
            return FALSE;
        }
        if (!SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_CLASSDRIVER,
                                   0, DriverInfoData)) {
            return FALSE;
        }
        //
        // we've selected the current driver
        //
        return TRUE;
    }
    deviceInstallParams.FlagsEx &= ~(DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);
#endif
    //
    // The following method works in Win2k, but it's slow and painful.
    //
    // First, get driver key - if it doesn't exist, no driver
    //
    hKey = SetupDiOpenDevRegKey(Devs,
                                DevInfo,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                               );

    if(hKey == INVALID_HANDLE_VALUE) {
        //
        // no such value exists, so there can't be an associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain path of INF - we'll do a search on this specific INF
    //
    RegDataLength = sizeof(deviceInstallParams.DriverPath); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFPATH,
                             NULL,
                             &RegDataType,
                             (PBYTE)deviceInstallParams.DriverPath,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so no associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of Provider to fill into DriverInfoData
    //
    RegDataLength = sizeof(ProviderName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_PROVIDER_NAME,
                             NULL,
                             &RegDataType,
                             (PBYTE)ProviderName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of section - for final verification
    //
    RegDataLength = sizeof(SectionName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFSECTION,
                             NULL,
                             &RegDataType,
                             (PBYTE)SectionName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // driver description (need not be same as device description)
    // - for final verification
    //
    RegDataLength = sizeof(DrvDescription); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_DRVDESC,
                             NULL,
                             &RegDataType,
                             (PBYTE)DrvDescription,
                             &RegDataLength
                             );

    RegCloseKey(hKey);

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // Manufacturer (via SPDRP_MFG, don't access registry directly!)
    //

    if(!SetupDiGetDeviceRegistryProperty(Devs,
                                        DevInfo,
                                        SPDRP_MFG,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)MfgName,
                                        sizeof(MfgName), // bytes!!!
                                        NULL)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // now search for drivers listed in the INF
    //
    //
    deviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
        return FALSE;
    }

    //
    // find the entry in the INF that was used to install the driver for
    // this device
    //
    for(c=0;SetupDiEnumDriverInfo(Devs,DevInfo,SPDIT_CLASSDRIVER,c,DriverInfoData);c++) {
        if((_tcscmp(DriverInfoData->MfgName,MfgName)==0)
            &&(_tcscmp(DriverInfoData->ProviderName,ProviderName)==0)) {
            //
            // these two fields match, try more detailed info
            // to ensure we have the exact driver entry used
            //
            SP_DRVINFO_DETAIL_DATA detail;
            detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,DriverInfoData,&detail,sizeof(detail),NULL)
                    && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
                continue;
            }
            if((_tcscmp(detail.SectionName,SectionName)==0) &&
                (_tcscmp(detail.DrvDescription,DrvDescription)==0)) {
                match = TRUE;
                break;
            }
        }
    }
    if(!match) {
        SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);
    }
    return match;
}

BOOL DumpDeviceDriverFiles(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump information about what files were installed for driver package
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    //
    // do this by 'searching' for the current driver
    // mimmicing a copy-only install to our own file queue
    // and then parsing that file queue
    //
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD count;
    DWORD scanResult;
    BOOL success = FALSE;

    ZeroMemory(&driverInfoData,sizeof(driverInfoData));
    driverInfoData.cbSize = sizeof(driverInfoData);

    if(!FindCurrentDriver(Devs,DevInfo,&driverInfoData)) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
        return FALSE;
    }

    //
    // get useful driver information
    //
    driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        //
        // no information about driver or section
        //
        goto final;
    }
    if(!driverInfoDetail.InfFileName[0] || !driverInfoDetail.SectionName[0]) {
        goto final;
    }

    //
    // pretend to do the file-copy part of a driver install
    // to determine what files are used
    // the specified driver must be selected as the active driver
    //
    if(!SetupDiSetSelectedDriver(Devs, DevInfo, &driverInfoData)) {
        goto final;
    }

    //
    // create a file queue so we can look at this queue later
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        goto final;
    }

    //
    // modify flags to indicate we're providing our own queue
    //
    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // now fill queue with files that are to be installed
    // this involves all class/co-installers
    //
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, Devs, DevInfo) ) {
        goto final;
    }

    //
    // we now have a list of delete/rename/copy files
    // iterate the copy queue twice - 1st time to get # of files
    // 2nd time to get files
    // (WinXP has API to get # of files, but we want this to work
    // on Win2k too)
    //

    count = 0;
    scanResult = 0;
    //
    // call once to count
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,&count,&scanResult);
    Padding(1);
    FormatToStream(stdout, count ? MSG_DUMP_DRIVER_FILES : MSG_DUMP_NO_DRIVER_FILES, count, driverInfoDetail.InfFileName, driverInfoDetail.SectionName);
    //
    // call again to dump the files
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,NULL,&scanResult);

    success = TRUE;

final:

    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);

    if ( queueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue(queueHandle);
    }

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
    }

    return success;

}

BOOL DumpArray(_In_ int pad, _In_ PZPWSTR Array)
/*++

Routine Description:

    Iterate array and dump entries to screen

Arguments:

    pad   - padding
    Array - array to dump

Return Value:

    none

--*/
{
    if(!Array || !Array[0]) {
        return FALSE;
    }
    while(Array[0]) {
        Padding(pad);
        _tprintf(TEXT("%s\n"),Array[0]);
        Array++;
    }
    return TRUE;
}

BOOL DumpDeviceHwIds(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Hardware ID's
    <tab><tab>ID
    ...
    <tab>Compatible ID's
    <tab><tab>ID
    ...
    or
    <tab>No Hardware ID's for device

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    LPTSTR * hwIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_HARDWAREID);
    LPTSTR * compatIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_COMPATIBLEIDS);
    BOOL displayed = FALSE;

    if(hwIdArray && hwIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_HWIDS);
        DumpArray(2,hwIdArray);
    }
    if(compatIdArray && compatIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_COMPATIDS);
        DumpArray(2,compatIdArray);
    }
    if(!displayed) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_HWIDS);
    }

    DelMultiSz(hwIdArray);
    DelMultiSz(compatIdArray);

    return TRUE;
}

BOOL DumpDeviceDriverNodes(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    BOOL success = FALSE;
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    SP_DRVINSTALL_PARAMS driverInstallParams;
    DWORD index;
    SYSTEMTIME SystemTime;
    ULARGE_INTEGER Version;
    TCHAR Buffer[MAX_PATH];

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    ZeroMemory(&driverInfoData, sizeof(driverInfoData));

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to allow excluded drivers.
    //
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Now build a class driver list.
    //
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_COMPATDRIVER)) {
        goto final2;
    }

    //
    // Enumerate all of the drivernodes.
    //
    index = 0;
    while(SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_COMPATDRIVER,
                                index, &driverInfoData)) {

        success = TRUE;

        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_HEADER,index);

        //
        // get useful driver information
        //
        driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) ||
           GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_INF,driverInfoDetail.InfFileName);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_SECTION,driverInfoDetail.SectionName);
        }

        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DESCRIPTION,driverInfoData.Description);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_MFGNAME,driverInfoData.MfgName);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_PROVIDERNAME,driverInfoData.ProviderName);

        if (FileTimeToSystemTime(&driverInfoData.DriverDate, &SystemTime)) {
            if (GetDateFormat(LOCALE_USER_DEFAULT,
                              DATE_SHORTDATE,
                              &SystemTime,
                              NULL,
                              Buffer,
                              sizeof(Buffer)/sizeof(TCHAR)
                              ) != 0) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERDATE,Buffer);
            }
        }

        Version.QuadPart = driverInfoData.DriverVersion;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERVERSION,
                       HIWORD(Version.HighPart),
                       LOWORD(Version.HighPart),
                       HIWORD(Version.LowPart),
                       LOWORD(Version.LowPart)
                       );

        driverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if(SetupDiGetDriverInstallParams(Devs,DevInfo,&driverInfoData,&driverInstallParams)) {
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_RANK,driverInstallParams.Rank);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS,driverInstallParams.Flags);

            //
            // Interesting flags to dump
            //
            if (driverInstallParams.Flags & DNF_OLD_INET_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER);
            }
            if (driverInstallParams.Flags & DNF_BAD_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER);
            }
#if defined(DNF_INF_IS_SIGNED)
            //
            // DNF_INF_IS_SIGNED is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED);
            }
#endif
#if defined(DNF_OEM_F6_INF)
            //
            // DNF_OEM_F6_INF is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_OEM_F6_INF) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF);
            }
#endif
#if defined(DNF_BASIC_DRIVER)
            //
            // DNF_BASIC_DRIVER is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_BASIC_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER);
            }
#endif
        }

        index++;
    }


    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_COMPATDRIVER);


final2:

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVERNODES);
    }

    return success;

}

BOOL DumpDeviceStack(_In_ HDEVINFO Devs, _In_ PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write expected stack information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR * filters;
    LPTSTR service;
    HKEY hClassKey = (HKEY)INVALID_HANDLE_VALUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    //
    // we need machine information
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) {
        return FALSE;
    }

    //
    // we need device setup class, we can use the GUID in DevInfo
    // note that this GUID is a snapshot, but works fine
    // if DevInfo isn't old
    //

    //
    // class upper/lower filters are in class registry
    //
    hClassKey = SetupDiOpenClassRegKeyEx(&DevInfo->ClassGuid,
                                         KEY_READ,
                                         DIOCR_INSTALLER,
                                         devInfoListDetail.RemoteMachineName[0] ? devInfoListDetail.RemoteMachineName : NULL,
                                         NULL);

    if(hClassKey != INVALID_HANDLE_VALUE) {
        //
        // dump upper class filters if available
        //
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_UPPERFILTERS);
        if(filters) {
            if(filters[0]) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_UPPERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // dump upper device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }
    service = GetDeviceStringProperty(Devs,DevInfo,SPDRP_SERVICE);
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DEVICESTACK_SERVICE);
    if(service && service[0]) {
        //
        // dump service
        //
        Padding(2);
        _tprintf(TEXT("%s\n"),service);
    } else {
        //
        // dump the fact that there's no service
        //
        Padding(2);
        FormatToStream(stdout,MSG_DUMP_DEVICESTACK_NOSERVICE);
    }
    if(service) {
        delete [] service;
    }
    if(hClassKey != INVALID_HANDLE_VALUE) {
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_LOWERFILTERS);
        if(filters) {
            if(filters[0]) {
                //
                // lower class filters
                //
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
        RegCloseKey(hClassKey);
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_LOWERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // lower device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }

    return TRUE;
}

BOOL DumpDriverPackageData(_In_ LPCTSTR InfName)
{
    DWORD Err = NO_ERROR;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT ErrorLine;
    INFCONTEXT Context;
    TCHAR InfData[MAX_INF_STRING_LENGTH];
    GUID ClassGuid;
#if _SETUPAPI_VER >= _WIN32_WINNT_WINXP
    SetupVerifyInfFileProto SVIFFn;
#endif // _SETUPAPI_VER >= _WIN32_WINNT_WINXP
    HMODULE setupapiMod = NULL;
    
#if _SETUPAPI_VER >= _WIN32_WINNT_WINXP
    SP_INF_SIGNER_INFO InfSignerInfo;
#endif // _SETUPAPI_VER >= _WIN32_WINNT_WINXP

    hInf = SetupOpenInfFile(InfName,
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);
    if (hInf == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto failed;
    }

    //
    // Dump out the provider.
    //
    if (SetupFindFirstLine(hInf,
                           INFSTR_SECT_VERSION,
                           INFSTR_KEY_PROVIDER,
                           &Context) &&
        (SetupGetStringField(&Context,
                             1,
                             InfData,
                             ARRAYSIZE(InfData),
                             NULL))) {
        FormatToStream(stdout,MSG_DPENUM_DUMP_PROVIDER,InfData);
    } else {
        FormatToStream(stdout,MSG_DPENUM_DUMP_PROVIDER_UNKNOWN);
    }

    //
    // Dump out the class
    //
    if (SetupFindFirstLine(hInf,
                           INFSTR_SECT_VERSION,
                           INFSTR_KEY_HARDWARE_CLASSGUID,
                           &Context) &&
        (SetupGetStringField(&Context,
                             1,
                             InfData,
                             ARRAYSIZE(InfData),
                             NULL)) &&
        (SUCCEEDED(CLSIDFromString(InfData, &ClassGuid))) &&
        SetupDiGetClassDescriptionEx(&ClassGuid,InfData,ARRAYSIZE(InfData),NULL,NULL,NULL)) {
        FormatToStream(stdout,MSG_DPENUM_DUMP_CLASS,InfData);
    } else {
        FormatToStream(stdout,MSG_DPENUM_DUMP_CLASS_UNKNOWN);
    }

#if _SETUPAPI_VER >= _WIN32_WINNT_WINXP
    //
    // Dump out the digital signer
    //
    setupapiMod = LoadLibrary(TEXT("setupapi.dll"));
    if(!setupapiMod){
        goto failed;
    }
    SVIFFn = (SetupVerifyInfFileProto)GetProcAddress(setupapiMod, SETUPVERIFYINFFILE);
    if(!SVIFFn){
        goto failed;
    }
    
    ZeroMemory(&InfSignerInfo, sizeof(InfSignerInfo));
    InfSignerInfo.cbSize = sizeof(InfSignerInfo);
    if (SVIFFn(InfName, NULL, &InfSignerInfo) ||
        (GetLastError() == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
        (GetLastError() == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
        FormatToStream(stdout,MSG_DPENUM_DUMP_SIGNER,InfSignerInfo.DigitalSigner);
    } else {
        FormatToStream(stdout,MSG_DPENUM_DUMP_SIGNER_UNKNOWN);
    }
#endif // _SETUPAPI_VER >= _WIN32_WINNT_WINXP

    //
    // Dump out the version and date
    //
    if (SetupFindFirstLine(hInf,
                           INFSTR_SECT_VERSION,
                           INFSTR_DRIVERVERSION_SECTION,
                           &Context)) {
        if (SetupGetStringField(&Context,
                                1,
                                InfData,
                                ARRAYSIZE(InfData),
                                NULL)) {
            FormatToStream(stdout,MSG_DPENUM_DUMP_DATE,InfData);
        } else {
            FormatToStream(stdout,MSG_DPENUM_DUMP_DATE_UNKNOWN);
        }
    
        if (SetupGetStringField(&Context,
                                2,
                                InfData,
                                ARRAYSIZE(InfData),
                                NULL)) {
            FormatToStream(stdout,MSG_DPENUM_DUMP_VERSION,InfData);
        } else {
            FormatToStream(stdout,MSG_DPENUM_DUMP_VERSION_UNKNOWN);
        }

    } else {
        FormatToStream(stdout,MSG_DPENUM_DUMP_DATE_UNKNOWN);
        FormatToStream(stdout,MSG_DPENUM_DUMP_VERSION_UNKNOWN);
    }


failed:
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if(setupapiMod){
        FreeLibrary(setupapiMod);
    }

    return (Err == NO_ERROR);
}



```

`Drivers/Driver-SRC/setup/devcon/msg.mc`:

```mc
;//
;// Copyright (c) Microsoft Corporation.  All rights reserved.
;//

;//
;// General
;//
MessageId=60000 SymbolicName=MSG_USAGE
Language=English
%1 Usage: %1 [-r] [-m:\\<machine>] <command> [<arg>...]
For more information, type: %1 help
.
MessageId=60001 SymbolicName=MSG_FAILURE
Language=English
%1 failed.
.
MessageId=60002 SymbolicName=MSG_COMMAND_USAGE
Language=English
%1: Invalid use of %2.
For more information, type: %1 help %2
.

;//
;// HELP
;//
MessageId=60100 SymbolicName=MSG_HELP_LONG
Language=English
Device Console Help:
%1 [-r] [-m:\\<machine>] <command> [<arg>...]
-r           Reboots the system only when a restart or reboot is required.
-u           Unicode (UTF-16) output
<machine>    Specifies a remote computer.
<command>    Specifies a Devcon command (see command list below).
<arg>...     One or more arguments that modify a command.
For help with a specific command, type: %1 help <command>
.
MessageId=60101 SymbolicName=MSG_HELP_SHORT
Language=English
%1!-20s! Display Devcon help.
.
MessageId=60102 SymbolicName=MSG_HELP_OTHER
Language=English
Unknown command.
.

;//
;// CLASSES
;//
MessageId=60200 SymbolicName=MSG_CLASSES_LONG
Language=English
Devcon Classes Command
Lists all device setup classes. Valid on local and remote computers.
%1 [-m:\\<machine>] %2
<machine>    Specifies a remote computer.
Class entries have the format <name>: <descr>
where <name> is the class name and <descr> is the class description.
.
MessageId=60201 SymbolicName=MSG_CLASSES_SHORT
Language=English
%1!-20s! List all device setup classes.
.
MessageId=60202 SymbolicName=MSG_CLASSES_HEADER
Language=English
Listing %1!u! setup classes on %2.
.
MessageId=60203 SymbolicName=MSG_CLASSES_HEADER_LOCAL
Language=English
Listing %1!u! setup classes.
.

;//
;// LISTCLASS
;//
MessageId=60300 SymbolicName=MSG_LISTCLASS_LONG
Language=English
Devcon Listclass Command
Lists all devices in the specified setup classes. Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <class> [<class>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Device entries have the format <instance>: <descr>
where <instance> is a unique instance of the device and <descr> is the device description.
.
MessageId=60301 SymbolicName=MSG_LISTCLASS_SHORT
Language=English
%1!-20s! List all devices in a setup class.
.
MessageId=60302 SymbolicName=MSG_LISTCLASS_HEADER
Language=English
Listing %1!u! devices in setup class "%2" (%3) on %4.
.
MessageId=60303 SymbolicName=MSG_LISTCLASS_HEADER_LOCAL
Language=English
Listing %1!u! devices in setup class "%2" (%3).
.
MessageId=60304 SymbolicName=MSG_LISTCLASS_NOCLASS
Language=English
There is no "%1" setup class on %2.
.
MessageId=60305 SymbolicName=MSG_LISTCLASS_NOCLASS_LOCAL
Language=English
There is no "%1" setup class on the local machine.
.
MessageId=60306 SymbolicName=MSG_LISTCLASS_HEADER_NONE
Language=English
There are no devices in setup class "%1" (%2) on %3.
.
MessageId=60307 SymbolicName=MSG_LISTCLASS_HEADER_NONE_LOCAL
Language=English
There are no devices in setup class "%1" (%2).
.

;//
;// FIND
;//
MessageId=60400 SymbolicName=MSG_FIND_LONG
Language=English
Devcon Find Command
Finds devices with the specified hardware or instance ID. Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
Device entries have the format <instance>: <descr>
where <instance> is the unique instance of the device and <descr> is the device description.
.
MessageId=60401 SymbolicName=MSG_FIND_SHORT
Language=English
%1!-20s! Find devices.
.
MessageId=60402 SymbolicName=MSG_FIND_TAIL_NONE
Language=English
No matching devices found on %1.
.
MessageId=60403 SymbolicName=MSG_FIND_TAIL_NONE_LOCAL
Language=English
No matching devices found.
.
MessageId=60404 SymbolicName=MSG_FIND_TAIL
Language=English
%1!u! matching device(s) found on %2.
.
MessageId=60405 SymbolicName=MSG_FIND_TAIL_LOCAL
Language=English
%1!u! matching device(s) found.
.
MessageId=60406 SymbolicName=MSG_FINDALL_LONG
Language=English
Devcon Findall Command
Finds devices with the specified hardware or instance ID, including devices
that are not currently attached. Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
Device entries have the format <instance>: <descr>
where <instance> is the unique instance of the device and <descr> is the description.
.
MessageId=60407 SymbolicName=MSG_FINDALL_SHORT
Language=English
%1!-20s! Find devices, including those that are not currently attached.
.
MessageId=60408 SymbolicName=MSG_STATUS_LONG
Language=English
Devcon Status Command
Lists the running status of devices with the specified hardware or instance ID.
Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60409 SymbolicName=MSG_STATUS_SHORT
Language=English
%1!-20s! List running status of devices.
.
MessageId=60410 SymbolicName=MSG_DRIVERFILES_LONG
Language=English
Devcon Driverfiles Command
List installed driver files for devices with the specified hardware or
instance ID. Valid only on the local computer.
%1 %2 <id> [<id>...]
%1 %2 =<class> [<id>...]
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60411 SymbolicName=MSG_DRIVERFILES_SHORT
Language=English
%1!-20s! List installed driver files for devices.
.
MessageId=60412 SymbolicName=MSG_RESOURCES_LONG
Language=English
Devcon Resources Command
Lists hardware resources of devices with the specified hardware or instance ID.
Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60413 SymbolicName=MSG_RESOURCES_SHORT
Language=English
%1!-20s! List hardware resources for devices.
.
MessageId=60414 SymbolicName=MSG_HWIDS_LONG
Language=English
Devcon Hwids Command
Lists hardware IDs of all devices with the specified hardware or instance ID.
Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60415 SymbolicName=MSG_HWIDS_SHORT
Language=English
%1!-20s! List hardware IDs of devices.
.
MessageId=60416 SymbolicName=MSG_STACK_LONG
Language=English
Devcon Stack Command
Lists the expected driver stack of devices with the specified hardware
or instance ID. PnP calls each driver's AddDevice routine when building
the device stack. Valid on local and remote computers.
%1 [-m:\\<machine>] %2 <id> [<id>...]
%1 [-m:\\<machine>] %2 =<class> [<id>...]
<machine>    Specifies a remote computer.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60417 SymbolicName=MSG_STACK_SHORT
Language=English
%1!-20s! List expected driver stack for devices.
.
;//
;// ENABLE
;//
MessageId=60500 SymbolicName=MSG_ENABLE_LONG
Language=English
Devcon Enable Command
Enables devices with the specified hardware or instance ID. Valid only on
the local computer. (To reboot when necessary, include -r.)
%1 [-r] %2 <id> [<id>...]
%1 [-r] %2 =<class> [<id>...]
-r           Reboots the system only when a restart or reboot is required.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60501 SymbolicName=MSG_ENABLE_SHORT
Language=English
%1!-20s! Enable devices.
.
MessageId=60502 SymbolicName=MSG_ENABLE_TAIL_NONE
Language=English
No devices were enabled, either because the devices were not found,
or because the devices could not be enabled.
.
MessageId=60503 SymbolicName=MSG_ENABLE_TAIL_REBOOT
Language=English
The %1!u! device(s) are ready to be enabled. To enable the devices, restart the devices or
reboot the system .
.
MessageId=60504 SymbolicName=MSG_ENABLE_TAIL
Language=English
%1!u! device(s) are enabled.
.

;//
;// DISABLE
;//
MessageId=60600 SymbolicName=MSG_DISABLE_LONG
Language=English
Devcon Disable Command
Disables devices with the specified hardware or instance ID.
Valid only on the local computer. (To reboot when necesary, Include -r .)
%1 [-r] %2 <id> [<id>...]
%1 [-r] %2 =<class> [<id>...]
-r           Reboots the system only when a restart or reboot is required.
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60601 SymbolicName=MSG_DISABLE_SHORT
Language=English
%1!-20s! Disable devices.
.
MessageId=60602 SymbolicName=MSG_DISABLE_TAIL_NONE
Language=English
No devices were disabled, either because the devices were not found,
or because the devices could not be disabled.
.
MessageId=60603 SymbolicName=MSG_DISABLE_TAIL_REBOOT
Language=English
The %1!u! device(s) are ready to be disabled. To disable the devices, restart the
devices or reboot the system .
.
MessageId=60604 SymbolicName=MSG_DISABLE_TAIL
Language=English
%1!u! device(s) disabled.
.


;//
;// RESTART
;//
MessageId=60700 SymbolicName=MSG_RESTART_LONG
Language=English
Devcon Restart Command
Restarts devices with the specified hardware or instance ID.
Valid only on the local computer. (To reboot when necesary, Include -r .)
%1 [-r] %2 <id> [<id>...]
%1 [-r] %2 =<class> [<id>...]
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=60701 SymbolicName=MSG_RESTART_SHORT
Language=English
%1!-20s! Restart devices.
.
MessageId=60702 SymbolicName=MSG_RESTART_TAIL_NONE
Language=English
No devices were restarted, either because the devices were not found,
or because the devices could not be restarted.
.
MessageId=60703 SymbolicName=MSG_RESTART_TAIL_REBOOT
Language=English
The %1!u! device(s) are ready to be restarted. To restart the devices, reboot the system.
.
MessageId=60704 SymbolicName=MSG_RESTART_TAIL
Language=English
%1!u! device(s) restarted.
.


;//
;// REBOOT
;//
MessageId=60800 SymbolicName=MSG_REBOOT_LONG
Language=English
%1 %2
Reboots the local computer as part of a planned hardware installation.
.
MessageId=60801 SymbolicName=MSG_REBOOT_SHORT
Language=English
%1!-20s! Reboot the local computer.
.
MessageId=60802 SymbolicName=MSG_REBOOT
Language=English
Rebooting the local computer.
.

;//
;// DUMP
;//
MessageId=60904 SymbolicName=MSG_DUMP_PROBLEM
Language=English
The device has the following problem: %1!02u!
.
MessageId=60905 SymbolicName=MSG_DUMP_PRIVATE_PROBLEM
Language=English
The driver reported a problem with the device.
.
MessageId=60906 SymbolicName=MSG_DUMP_STARTED
Language=English
Driver is running.
.
MessageId=60907 SymbolicName=MSG_DUMP_DISABLED
Language=English
Device is disabled.
.
MessageId=60908 SymbolicName=MSG_DUMP_NOTSTARTED
Language=English
Device is currently stopped.
.
MessageId=60909 SymbolicName=MSG_DUMP_NO_RESOURCES
Language=English
Device is not using any resources.
.
MessageId=60910 SymbolicName=MSG_DUMP_NO_RESERVED_RESOURCES
Language=English
Device has no reserved resources.
.
MessageId=60911 SymbolicName=MSG_DUMP_RESOURCES
Language=English
Device is currently using the following resources:
.
MessageId=60912 SymbolicName=MSG_DUMP_RESERVED_RESOURCES
Language=English
Device has the following reserved resources:
.
MessageId=60913 SymbolicName=MSG_DUMP_DRIVER_FILES
Language=English
Driver installed from %2 [%3]. %1!u! file(s) used by driver:
.
MessageId=60914 SymbolicName=MSG_DUMP_NO_DRIVER_FILES
Language=English
Driver installed from %2 [%3]. The driver is not using any files.
.
MessageId=60915 SymbolicName=MSG_DUMP_NO_DRIVER
Language=English
No driver information available for the device.
.
MessageId=60916 SymbolicName=MSG_DUMP_HWIDS
Language=English
Hardware IDs:
.
MessageId=60917 SymbolicName=MSG_DUMP_COMPATIDS
Language=English
Compatible IDs:
.
MessageId=60918 SymbolicName=MSG_DUMP_NO_HWIDS
Language=English
No hardware/compatible IDs found for this device.
.
MessageId=60919 SymbolicName=MSG_DUMP_NO_DRIVERNODES
Language=English
No driver nodes found for this device.
.
MessageId=60920 SymbolicName=MSG_DUMP_DRIVERNODE_HEADER
Language=English
Driver node #%1!u!:
.
MessageId=60921 SymbolicName=MSG_DUMP_DRIVERNODE_INF
Language=English
Inf file is %1
.
MessageId=60922 SymbolicName=MSG_DUMP_DRIVERNODE_SECTION
Language=English
Inf section is %1
.
MessageId=60923 SymbolicName=MSG_DUMP_DRIVERNODE_DESCRIPTION
Language=English
Driver description is %1
.
MessageId=60924 SymbolicName=MSG_DUMP_DRIVERNODE_MFGNAME
Language=English
Manufacturer name is %1
.
MessageId=60925 SymbolicName=MSG_DUMP_DRIVERNODE_PROVIDERNAME
Language=English
Provider name is %1
.
MessageId=60926 SymbolicName=MSG_DUMP_DRIVERNODE_DRIVERDATE
Language=English
Driver date is %1
.
MessageId=60927 SymbolicName=MSG_DUMP_DRIVERNODE_DRIVERVERSION
Language=English
Driver version is %1!u!.%2!u!.%3!u!.%4!u!
.
MessageId=60928 SymbolicName=MSG_DUMP_DRIVERNODE_RANK
Language=English
Driver node rank is %1!u!
.
MessageId=60929 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS
Language=English
Driver node flags are %1!08X!
.
MessageId=60930 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER
Language=English
Inf came from the Internet
.
MessageId=60931 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER
Language=English
Driver node is marked "BAD"
.
MessageId=60932 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED
Language=English
Inf is digitally signed
.
MessageId=60933 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF
Language=English
Inf was installed by using F6 during text mode setup
.
MessageId=60934 SymbolicName=MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER
Language=English
Driver provides basic functionality when no signed driver is available.
.
MessageId=60935 SymbolicName=MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS
Language=English
Upper class filters:
.
MessageId=60936 SymbolicName=MSG_DUMP_DEVICESTACK_UPPERFILTERS
Language=English
Upper filters:
.
MessageId=60937 SymbolicName=MSG_DUMP_DEVICESTACK_SERVICE
Language=English
Controlling service:
.
MessageId=60938 SymbolicName=MSG_DUMP_DEVICESTACK_NOSERVICE
Language=English
(none)
.
MessageId=60939 SymbolicName=MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS
Language=English
Class lower filters:
.
MessageId=60940 SymbolicName=MSG_DUMP_DEVICESTACK_LOWERFILTERS
Language=English
Lower filters:
.
MessageId=60941 SymbolicName=MSG_DUMP_SETUPCLASS
Language=English
Setup Class: %1 %2
.
MessageId=60942 SymbolicName=MSG_DUMP_NOSETUPCLASS
Language=English
Device is not set up.
.
MessageId=60943 SymbolicName=MSG_DUMP_DESCRIPTION
Language=English
Name: %1
.
MessageId=60944 SymbolicName=MSG_DUMP_PHANTOM
Language=English
Device is not present.
.
MessageId=60945 SymbolicName=MSG_DUMP_STATUS_ERROR
Language=English
Error retrieving the device's status.
.

;//
;// INSTALL
;//
MessageId=61000 SymbolicName=MSG_INSTALL_LONG
Language=English
Devcon Install Command
Installs the specified device manually. Valid only on the local computer.
(To reboot when necesary, Include -r .)
%1 [-r] %2 <inf> <hwid>
<inf>        Specifies an INF file with installation information for the device.
<hwid>       Specifies a hardware ID for the device.
-r           Reboots the system only when a restart or reboot is required.
.
MessageId=61001 SymbolicName=MSG_INSTALL_SHORT
Language=English
%1!-20s! Install a device manually.
.
MessageId=61002 SymbolicName=MSG_INSTALL_UPDATE
Language=English
Device node created. Install is complete when drivers are installed...
.

;//
;// UPDATE
;//
MessageId=61100 SymbolicName=MSG_UPDATE_LONG
Language=English
Devcon Update Command
Updates drivers for all devices with the specified hardware ID (<hwid>).
Valid only on the local computer. (To reboot when necesary, Include -r .)
%1 [-r] %2 <inf> <hwid>
-r           Reboots the system only when a restart or reboot is required.
<inf>        Specifies an INF file with installation information for the devices.
<hwid>       Specifies the hardware ID of the devices.
.
MessageId=61101 SymbolicName=MSG_UPDATE_SHORT
Language=English
%1!-20s! Update a device manually.
.
MessageId=61102 SymbolicName=MSG_UPDATE_INF
Language=English
Updating drivers for %1 from %2.
.
MessageId=61103 SymbolicName=MSG_UPDATE
Language=English
Updating drivers for %1.
.
MessageId=61104 SymbolicName=MSG_UPDATENI_LONG
Language=English
%1 [-r] %2 <inf> <hwid>
Update drivers for devices (Non Interactive).
This command will only work for local machine.
Specify -r to reboot automatically if needed.
<inf> is an INF to use to install the device.
All devices that match <hwid> are updated.
Unsigned installs will fail. No UI will be
presented.
.
MessageId=61105 SymbolicName=MSG_UPDATENI_SHORT
Language=English
%1!-20s! Manually update a device (non interactive).
.
MessageId=61106 SymbolicName=MSG_UPDATE_OK
Language=English
Drivers installed successfully.
.
;//
;// Driver Package (add/remove/enum)
;//
MessageId=61107 SymbolicName=MSG_DPADD_LONG
Language=English
%1 %2 <inf>
Adds (installs) a third-party (OEM) driver package.
This command will only work on the local machine.
<inf> is a full path to the INF of the Driver
Package that will be installed on this machine.
.
MessageId=61108 SymbolicName=MSG_DPADD_SHORT
Language=English
%1!-20s! Adds (installs) a third-party (OEM) driver package.
.
MessageId=61109 SymbolicName=MSG_DPDELETE_LONG
Language=English
%1 [-f] %2 <inf>
Deletes a third-party (OEM) driver package.
This command will only work on the local machine.
[-f] will force delete the driver package, even
if it is in use by a device.
<inf> is the name of a published INF on the local
machine.  This is the value returned from dp_add
and dp_enum.
.
MessageId=61110 SymbolicName=MSG_DPDELETE_SHORT
Language=English
%1!-20s! Deletes a third-party (OEM) driver package.
.
MessageId=61111 SymbolicName=MSG_DPENUM_LONG
Language=English
%1 %2
Lists the third-party (OEM) driver packages installed on this machine.
This command will only work on the local machine.
Values returned from dp_enum can be sent to dp_delete
to be removed from the machine.
.
MessageId=61112 SymbolicName=MSG_DPENUM_SHORT
Language=English
%1!-20s! Lists the third-party (OEM) driver packages installed on this machine.
.
MessageId=61113 SymbolicName=MSG_DPADD_INVALID_INF
Language=English
The specified INF path is not valid.
.
MessageId=61114 SymbolicName=MSG_DPADD_FAILED
Language=English
Adding the specified driver package to the machine failed.
.
MessageId=61115 SymbolicName=MSG_DPADD_SUCCESS
Language=English
Driver package '%1' added.
.
MessageId=61116 SymbolicName=MSG_DPDELETE_FAILED
Language=English
Deleting the specified driver package from the machine failed.
.
MessageId=61117 SymbolicName=MSG_DPDELETE_FAILED_IN_USE
Language=English
Deleting the specified driver package from the machine failed
because it is in use by a device.
.
MessageId=61118 SymbolicName=MSG_DPDELETE_FAILED_NOT_OEM_INF
Language=English
Deleting the specified driver package from the machine failed
because it is not an third-party package.
.
MessageId=61119 SymbolicName=MSG_DPDELETE_SUCCESS
Language=English
Driver package '%1' deleted.
.
MessageId=61120 SymbolicName=MSG_DPENUM_NO_OEM_INF
Language=English
There are no third-party driver packages on this machine.
.
MessageId=61121 SymbolicName=MSG_DPENUM_LIST_HEADER
Language=English
The following third-party driver packages are installed on this computer:
.
MessageId=61122 SymbolicName=MSG_DPENUM_LIST_ENTRY
Language=English
%1
.
MessageId=61123 SymbolicName=MSG_DPENUM_DUMP_PROVIDER
Language=English
    Provider: %1
.
MessageId=61124 SymbolicName=MSG_DPENUM_DUMP_PROVIDER_UNKNOWN
Language=English
    Provider: unknown
.
MessageId=61125 SymbolicName=MSG_DPENUM_DUMP_CLASS
Language=English
    Class: %1
.
MessageId=61126 SymbolicName=MSG_DPENUM_DUMP_CLASS_UNKNOWN
Language=English
    Class: unknown
.
MessageId=61127 SymbolicName=MSG_DPENUM_DUMP_VERSION
Language=English
    Version: %1
.
MessageId=61128 SymbolicName=MSG_DPENUM_DUMP_VERSION_UNKNOWN
Language=English
    Version: unknown
.
MessageId=61129 SymbolicName=MSG_DPENUM_DUMP_DATE
Language=English
    Date: %1
.
MessageId=61130 SymbolicName=MSG_DPENUM_DUMP_DATE_UNKNOWN
Language=English
    Date: unknown
.
MessageId=61131 SymbolicName=MSG_DPENUM_DUMP_SIGNER
Language=English
    Signer: %1
.
MessageId=61132 SymbolicName=MSG_DPENUM_DUMP_SIGNER_UNKNOWN
Language=English
    Signer: unknown
.
;//
;// REMOVE
;//
MessageId=61200 SymbolicName=MSG_REMOVE_LONG
Language=English
Devcon Remove Command
Removes devices with the specified hardware or instance ID. Valid only on
the local computer. (To reboot when necesary, Include -r .)
%1 [-r] %2 <id> [<id>...]
%1 [-r] %2 =<class> [<id>...]
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=61201 SymbolicName=MSG_REMOVE_SHORT
Language=English
%1!-20s! Remove devices.
.
MessageId=61202 SymbolicName=MSG_REMOVE_TAIL_NONE
Language=English
No devices were removed.
.
MessageId=61203 SymbolicName=MSG_REMOVE_TAIL_REBOOT
Language=English
The %1!u! device(s) are ready to be removed. To remove the devices, reboot the system.
.
MessageId=61204 SymbolicName=MSG_REMOVE_TAIL
Language=English
%1!u! device(s) were removed.
.
MessageId=61205 SymbolicName=MSG_REMOVEALL_LONG
Language=English
Devcon Removeall Command
Removes devices with the specified hardware or instance ID, including devices
that are not currently attached. Valid only on the local computer.
(To reboot when necesary, Include -r .)
%1 [-r] %2 <id> [<id>...]
%1 [-r] %2 =<class> [<id>...]
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=61206 SymbolicName=MSG_REMOVEALL_SHORT
Language=English
%1!-20s! Remove devices, including those that are not currently attached.
.

;//
;// RESCAN
;//
MessageId=61300 SymbolicName=MSG_RESCAN_LONG
Language=English
Devcon Rescan Command
Directs Plug and Play to scan for new hardware. Valid on a local or remote computer.
%1 [-m:\\<machine>] %2
<machine>    Specifies a remote computer.
.
MessageId=61301 SymbolicName=MSG_RESCAN_SHORT
Language=English
%1!-20s! Scan for new hardware.
.
MessageId=61302 SymbolicName=MSG_RESCAN_LOCAL
Language=English
Scanning for new hardware.
.
MessageId=61303 SymbolicName=MSG_RESCAN
Language=English
Scanning for new hardware on %1.
.
MessageId=61304 SymbolicName=MSG_RESCAN_OK
Language=English
Scanning completed.
.

;//
;// DRIVERNODES
;//
MessageId=61400 SymbolicName=MSG_DRIVERNODES_LONG
Language=English
Devcon Drivernodes Command
Lists driver nodes for devices with the specified hardware or instance ID.
Valid only on the local computer.
%1 %2 <id> [<id>...]
%1 %2 =<class> [<id>...]
<class>      Specifies a device setup class.
Examples of <id>:
 *              - All devices
 ISAPNP\PNP0501 - Hardware ID
 *PNP*          - Hardware ID with wildcards  (* matches anything)
 @ISAPNP\*\*    - Instance ID with wildcards  (@ prefixes instance ID)
 '*PNP0501      - Hardware ID with apostrophe (' prefixes literal match - matches exactly as typed,
                                               including the asterisk.)
.
MessageId=61401 SymbolicName=MSG_DRIVERNODES_SHORT
Language=English
%1!-20s! List driver nodes of devices.
.

;//
;// CLASSFILTER
;//
MessageId=61500 SymbolicName=MSG_CLASSFILTER_LONG
Language=English
Devcon Classfilter Command

Lists, adds, deletes, and reorders upper and lower filter drivers for a device
setup class. Changes do not take effect until the affected devices are restarted
or the machine is rebooted.

%1 %2 [-r] <class> {upper | lower} [<operator><filter> [<operator><filter>...]]
<class>      Specifies a device setup class.
<operator>   Specifies an operation (listed below).
<filter>     Specifies a class filter driver.
upper        Identifies an upper filter driver.
lower        Identifies a lower filter driver.

To list the upper/lower filter drivers for a class,
type:  devcon classfilter <class> {upper | lower}

The Devcon classfilter command uses subcommands, which consist of an
operator (=, @, -, +, !) and a filter driver name.

The Devcon classfilter command uses a virtual cursor to move through
the list of filter drivers. The cursor starts at the beginning of the
list (before the first filter). Unless returned to the starting position,
the cursor always moves forward.

Operators
 =       Move the cursor to the beginning of the filter driver list (before the
         first filter driver).

 @       Position the cursor on the next instance of the specified filter.

 -       Add before. Insert the specified filter before the filter on which the cursor
         is positioned. If the cursor is not positioned on a filter, insert the
         new filter at the beginning of the list. When the subcommand completes, the
         cursor is positioned on the newly-added filter.

 +       Add after. Insert the specified filter after the filter on which the cursor
         is positioned. If the cursor is not positioned on a filter, Devcon inserts the
         new filter at the end of the list. When the subcommand completes, the cursor
         cursor is positioned on the newly-added filter.

 !       Deletes the next occurrence of the specified filter. When the subcommand
         completes, the cursor occupies the position of the deleted filter.
         Subsequent - or + subcommands insert a new filter at the cursor position.


Examples:
If the upper filters for setup class "foo" are A,B,C,B,D,B,E:
%1 %2 foo upper @D !B    - deletes the third 'B'.
%1 %2 foo upper !B !B !B - deletes all three instances of 'B'.
%1 %2 foo upper =!B =!A  - deletes the first 'B' and the first 'A'.
%1 %2 foo upper !C +CC   - replaces 'C' with 'CC'.
%1 %2 foo upper @D -CC   - inserts 'CC' before 'D'.
%1 %2 foo upper @D +CC   - inserts 'CC' after 'D'.
%1 %2 foo upper -CC      - inserts 'CC' before 'A'.
%1 %2 foo upper +CC      - inserts 'CC' after 'E'.
%1 %2 foo upper @D +X +Y - inserts 'X' after 'D' and 'Y' after 'X'.
%1 %2 foo upper @D -X -Y - inserts 'X' before 'D' and 'Y' before 'X'.
%1 %2 foo upper @D -X +Y - inserts 'X' before 'D' and 'Y' between 'X' and 'D'.
.

MessageId=61501 SymbolicName=MSG_CLASSFILTER_SHORT
Language=English
%1!-20s! Add, delete, and reorder class filters.
.
MessageId=61502 SymbolicName=MSG_CLASSFILTER_CHANGED
Language=English
Class filters changed. Restart the devices or reboot the system to make the change effective.
.
MessageId=61503 SymbolicName=MSG_CLASSFILTER_UNCHANGED
Language=English
Class filters unchanged.
.
;//
;// SETHWID
;//
MessageId=61600 SymbolicName=MSG_SETHWID_LONG
Language=English
%1 [-m:\\<machine>] %2 <id> [<id>...] := <subcmds>
%1 [-m:\\<machine>] %2 =<class> [<id>...] := <subcmds>
Modifies the hardware ID's of the listed devices. This command will only work for root-enumerated devices.
This command will work for a remote machine.
Examples of <id> are:
*                  - All devices (not recommended)
ISAPNP\PNP0601     - Hardware ID
*PNP*              - Hardware ID with wildcards (* matches anything)
@ROOT\*\*          - Instance ID with wildcards (@ prefixes instance ID)
<class> is a setup class name as obtained from the classes command.

<subcmds> consists of one or more:
=hwid              - Clear hardware ID list and set it to hwid.
+hwid              - Add or move hardware ID to head of list (better match).
-hwid              - Add or move hardware ID to end of list (worse match).
!hwid              - Remove hardware ID from list.
hwid               - each additional hardware id is inserted after the previous.
.
MessageId=61601 SymbolicName=MSG_SETHWID_SHORT
Language=English
%1!-20s! Modify Hardware ID's of listed root-enumerated devices.
.

MessageId=61602 SymbolicName=MSG_SETHWID_TAIL_NONE
Language=English
No hardware ID's modified.
.
MessageId=61603 SymbolicName=MSG_SETHWID_TAIL_SKIPPED
Language=English
Skipped %1!u! non-root device(s), modified the hardware ID on %2!u! device(s).
.
MessageId=61604 SymbolicName=MSG_SETHWID_TAIL_MODIFIED
Language=English
Modified the Hardware ID on %1!u! device(s).
.
MessageId=61605 SymbolicName=MSG_SETHWID_NOTROOT
Language=English
Skipping (Not root-enumerated).
.



```

`Drivers/Driver-SRC/setup/devcon/rc_ids.h`:

```h
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for devcon resources

--*/

#define IDS_ENABLED         3000
#define IDS_ENABLED_REBOOT  3001
#define IDS_ENABLE_FAILED   3002
#define IDS_DISABLED        3003
#define IDS_DISABLED_REBOOT 3004
#define IDS_DISABLE_FAILED  3005
#define IDS_RESTARTED       3006
#define IDS_REQUIRES_REBOOT 3007
#define IDS_RESTART_FAILED  3008
#define IDS_REMOVED         3009
#define IDS_REMOVED_REBOOT  3010
#define IDS_REMOVE_FAILED   3011



```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.421
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Kernel_shellcode", "Kernel_shellcode\Kernel_shellcode.vcxproj", "{014C9F2D-617C-4B8C-86B1-D14615739C61}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NameHasher", "NameHasher\NameHasher.vcxproj", "{AE66F72F-9D19-4613-A024-3D2ECC04371B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Kernel_shellcode_loader", "Kernel_shellcode_loader\Kernel_shellcode_loader.vcxproj", "{0789B937-AA1D-45BE-A565-4098AEC4A6AB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM.ActiveCfg = Debug|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM.Build.0 = Debug|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM.Deploy.0 = Debug|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM64.Build.0 = Debug|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x64.ActiveCfg = Debug|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x64.Build.0 = Debug|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x64.Deploy.0 = Debug|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x86.ActiveCfg = Debug|Win32
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x86.Build.0 = Debug|Win32
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Debug|x86.Deploy.0 = Debug|Win32
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM.ActiveCfg = Release|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM.Build.0 = Release|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM.Deploy.0 = Release|ARM
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM64.ActiveCfg = Release|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM64.Build.0 = Release|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|ARM64.Deploy.0 = Release|ARM64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x64.ActiveCfg = Release|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x64.Build.0 = Release|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x64.Deploy.0 = Release|x64
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x86.ActiveCfg = Release|Win32
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x86.Build.0 = Release|Win32
		{014C9F2D-617C-4B8C-86B1-D14615739C61}.Release|x86.Deploy.0 = Release|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|ARM.ActiveCfg = Debug|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|ARM64.ActiveCfg = Debug|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|x64.ActiveCfg = Debug|x64
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|x64.Build.0 = Debug|x64
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|x86.ActiveCfg = Debug|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Debug|x86.Build.0 = Debug|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|ARM.ActiveCfg = Release|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|ARM64.ActiveCfg = Release|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|x64.ActiveCfg = Release|x64
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|x64.Build.0 = Release|x64
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|x86.ActiveCfg = Release|Win32
		{AE66F72F-9D19-4613-A024-3D2ECC04371B}.Release|x86.Build.0 = Release|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM.ActiveCfg = Debug|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM.Build.0 = Debug|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM.Deploy.0 = Debug|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM64.Build.0 = Debug|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x64.ActiveCfg = Debug|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x64.Build.0 = Debug|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x64.Deploy.0 = Debug|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x86.ActiveCfg = Debug|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x86.Build.0 = Debug|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Debug|x86.Deploy.0 = Debug|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM.ActiveCfg = Release|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM.Build.0 = Release|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM.Deploy.0 = Release|ARM
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM64.ActiveCfg = Release|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM64.Build.0 = Release|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|ARM64.Deploy.0 = Release|ARM64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x64.ActiveCfg = Release|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x64.Build.0 = Release|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x64.Deploy.0 = Release|x64
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x86.ActiveCfg = Release|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x86.Build.0 = Release|Win32
		{0789B937-AA1D-45BE-A565-4098AEC4A6AB}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {491A3B02-3CA5-401B-8CF9-57A26041DD88}
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode/Kernel_shellcode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{014C9F2D-617C-4B8C-86B1-D14615739C61}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Kernel_shellcode</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>Disabled</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <ExpandAttributedSource />
      <AdditionalOptions>/J %(AdditionalOptions)</AdditionalOptions>
      <AssemblerOutput>All</AssemblerOutput>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <OmitFramePointers>true</OmitFramePointers>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AssemblerOutput>All</AssemblerOutput>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kernel_shellcode.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pe.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode/Kernel_shellcode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kernel_shellcode.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode/kernel_shellcode.c`:

```c
#include <ntddk.h>
#include <windef.h>
#include "pe.h"

#pragma section(".code", execute,read,write)
#pragma comment(linker,"/MERGE:.data=.code")
#pragma comment(linker,"/SECTION:.code,ERW")
#pragma code_seg(push, ".code")


#define IA32_SYSENTER_EIP 0x176

typedef struct _MSR
{
	DWORD loValue;
	DWORD hiValue;
} MSR, *PMSR;


void getMSR(DWORD regAddress, PMSR msr);
BOOLEAN GetLibAddressViaShellCode(DWORD* routineAddress, DWORD hash);
BOOLEAN walk_export_list(DWORD dll_base, DWORD *function_ptr, DWORD function_hash);
DWORD getHashA(char *str);
DWORD getHashW(WCHAR *str);


typedef NTSTATUS( *ZwReadFile_)(
	HANDLE,
	HANDLE,
	PIO_APC_ROUTINE,
	PVOID ,
	PIO_STATUS_BLOCK,
	PVOID,
	ULONG,
	PLARGE_INTEGER,
	PULONG
);

NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	ZwReadFile_ zwreadfile;

	DWORD ZwReadFile_hash = 0x0003AB62;

	GetLibAddressViaShellCode((DWORD*)&zwreadfile, ZwReadFile_hash);

	return STATUS_SUCCESS;
}


void getMSR(DWORD regAddress, PMSR msr)
{
	DWORD loValue;
	DWORD hiValue;

	__asm
	{
		MOV ecx, regAddress; // set on ecx register to read
		rdmsr;
		MOV hiValue, edx;
		MOV loValue, eax;
	}

	msr->loValue = loValue;
	msr->hiValue = hiValue;
}


BOOLEAN GetLibAddressViaShellCode(DWORD* routineAddress, DWORD hash)
{
	MSR msr;
	BYTE *bytePtr;
	DWORD baseAddress;

	getMSR(IA32_SYSENTER_EIP, &msr);
	KdPrint(("[GetLibAddressViaShellCode]: address nt!KiFastCallEntry() = 0x%08X\n", msr.loValue));
	bytePtr = (BYTE*)(msr.loValue & 0xFFFFF000); // get only high part of address

	//WARNING: compare more than two bytes
	while
	(
		(bytePtr[0] != 'M') ||
		(bytePtr[1] != 'Z') ||
		(bytePtr[2] != 0x90)
	)
	{
		bytePtr = (BYTE*)((DWORD)bytePtr - 0x1000);
	}

	baseAddress = (DWORD)bytePtr;
	KdPrint(("[GetLibAddressViaShellCode]: address of nt module = 0x%08X\n", baseAddress));
	return (walk_export_list(baseAddress, routineAddress, hash));	
}


BOOLEAN walk_export_list(DWORD dll_base, DWORD *function_ptr, DWORD function_hash)
{
	IMAGE_DOS_HEADER* image_dos_header = (IMAGE_DOS_HEADER*)dll_base;
	IMAGE_NT_HEADERS* image_nt_headers = (IMAGE_NT_HEADERS*)(dll_base + image_dos_header->e_lfanew);
	IMAGE_DATA_DIRECTORY* image_data_directory = &(image_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);

	DWORD descriptor_start_rva = image_data_directory->VirtualAddress;

	IMAGE_EXPORT_DIRECTORY* export_directory = (PIMAGE_EXPORT_DIRECTORY)(dll_base + descriptor_start_rva);

	DWORD* address_of_names = (DWORD*)(dll_base + export_directory->AddressOfNames);
	DWORD* address_of_functions = (DWORD*)(dll_base + export_directory->AddressOfFunctions);
	WORD* address_of_ordinals = (WORD*)(dll_base + export_directory->AddressOfNameOrdinals);

	SIZE_T index;

	for (index = 0; index < export_directory->NumberOfNames; index++)
	{
		char* name;
		DWORD name_rva;
		WORD ordinal;

		name_rva = address_of_names[index];

		if (name_rva == 0)
			continue;

		name = (char *)(dll_base + name_rva);
	
		if (getHashA(name) == function_hash)
		{
			ordinal = address_of_ordinals[index];
			(*function_ptr) = (dll_base + address_of_functions[ordinal]);
			return (TRUE);
		}
	}

	return (FALSE);
}


DWORD getHashA(char *str)
{
	DWORD hash;
	hash = 0;

	while (*str != '\0')
	{
		hash = hash + (*(unsigned char*)str | 0x60);
		hash = hash << 1;
		str = str + 1;
	}
	return (hash);
}


DWORD getHashW(WCHAR* str)
{
	DWORD hash;
	hash = 0;

	while (*str != '\0')
	{
		hash = hash + *str;
		str = str + 1;
	}

	return (hash);
}

#pragma code_seg(pop)
```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode/pe.h`:

```h
#pragma once
#ifndef PE_H
#define PE_H

#include <windef.h>

typedef unsigned __int64 ULONGLONG;

typedef struct _IMAGE_DOS_HEADER {
	WORD  e_magic;      /* 00: MZ Header signature */
	WORD  e_cblp;       /* 02: Bytes on last page of file */
	WORD  e_cp;         /* 04: Pages in file */
	WORD  e_crlc;       /* 06: Relocations */
	WORD  e_cparhdr;    /* 08: Size of header in paragraphs */
	WORD  e_minalloc;   /* 0a: Minimum extra paragraphs needed */
	WORD  e_maxalloc;   /* 0c: Maximum extra paragraphs needed */
	WORD  e_ss;         /* 0e: Initial (relative) SS value */
	WORD  e_sp;         /* 10: Initial SP value */
	WORD  e_csum;       /* 12: Checksum */
	WORD  e_ip;         /* 14: Initial IP value */
	WORD  e_cs;         /* 16: Initial (relative) CS value */
	WORD  e_lfarlc;     /* 18: File address of relocation table */
	WORD  e_ovno;       /* 1a: Overlay number */
	WORD  e_res[4];     /* 1c: Reserved words */
	WORD  e_oemid;      /* 24: OEM identifier (for e_oeminfo) */
	WORD  e_oeminfo;    /* 26: OEM information; e_oemid specific */
	WORD  e_res2[10];   /* 28: Reserved words */
	DWORD e_lfanew;     /* 3c: Offset to extended header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;


#define IMAGE_DOS_SIGNATURE    0x5A4D     /* MZ   */
#define IMAGE_OS2_SIGNATURE    0x454E     /* NE   */
#define IMAGE_OS2_SIGNATURE_LE 0x454C     /* LE   */
#define IMAGE_OS2_SIGNATURE_LX 0x584C     /* LX */
#define IMAGE_VXD_SIGNATURE    0x454C     /* LE   */
#define IMAGE_NT_SIGNATURE 0x00004550 /* PE00 */

/* Directory Entries, indices into the DataDirectory array */

#define	IMAGE_DIRECTORY_ENTRY_EXPORT		0
#define	IMAGE_DIRECTORY_ENTRY_IMPORT		1
#define	IMAGE_DIRECTORY_ENTRY_RESOURCE		2
#define	IMAGE_DIRECTORY_ENTRY_EXCEPTION		3
#define	IMAGE_DIRECTORY_ENTRY_SECURITY		4
#define	IMAGE_DIRECTORY_ENTRY_BASERELOC		5
#define	IMAGE_DIRECTORY_ENTRY_DEBUG		6
#define	IMAGE_DIRECTORY_ENTRY_COPYRIGHT		7
#define	IMAGE_DIRECTORY_ENTRY_GLOBALPTR		8   /* (MIPS GP) */
#define	IMAGE_DIRECTORY_ENTRY_TLS		9
#define	IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG	10
#define	IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT	11
#define	IMAGE_DIRECTORY_ENTRY_IAT		12  /* Import Address Table */
#define	IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT	13
#define	IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR	14

typedef struct _IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD  Magic; /* 0x20b */
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	ULONGLONG ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;


typedef struct _IMAGE_OPTIONAL_HEADER {

	/* Standard fields */

	WORD  Magic; /* 0x10b or 0x107 */	/* 0x00 */
	BYTE  MajorLinkerVersion;
	BYTE  MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;		/* 0x10 */
	DWORD BaseOfCode;
	DWORD BaseOfData;

	/* NT additional fields */

	DWORD ImageBase;
	DWORD SectionAlignment;		/* 0x20 */
	DWORD FileAlignment;
	WORD  MajorOperatingSystemVersion;
	WORD  MinorOperatingSystemVersion;
	WORD  MajorImageVersion;
	WORD  MinorImageVersion;
	WORD  MajorSubsystemVersion;		/* 0x30 */
	WORD  MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;			/* 0x40 */
	WORD  Subsystem;
	WORD  DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;		/* 0x50 */
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /* 0x60 */
	/* 0xE0 */
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_NT_HEADERS {
	DWORD Signature; /* "PE"\0\0 */	/* 0x00 */
	IMAGE_FILE_HEADER FileHeader;		/* 0x04 */
	IMAGE_OPTIONAL_HEADER32 OptionalHeader;	/* 0x18 */
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

#ifdef _WIN64
typedef IMAGE_NT_HEADERS64  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;
#else
typedef IMAGE_NT_HEADERS32  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;
typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32 PIMAGE_OPTIONAL_HEADER;
#endif

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;


#define	IMAGE_SIZEOF_SECTION_HEADER 40


typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD	Characteristics;
	DWORD	TimeDateStamp;
	WORD	MajorVersion;
	WORD	MinorVersion;
	DWORD	Name;
	DWORD	Base;
	DWORD	NumberOfFunctions;
	DWORD	NumberOfNames;
	DWORD	AddressOfFunctions;
	DWORD	AddressOfNames;
	DWORD	AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

/* Import name entry */
typedef struct _IMAGE_IMPORT_BY_NAME {
	WORD	Hint;
	BYTE	Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;


/* Import thunk */
typedef struct _IMAGE_THUNK_DATA64 {
	union {
		ULONGLONG ForwarderString;
		ULONGLONG Function;
		ULONGLONG Ordinal;
		ULONGLONG AddressOfData;
	} u1;
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;


typedef struct _IMAGE_THUNK_DATA32 {
	union {
		DWORD ForwarderString;
		DWORD Function;
		DWORD Ordinal;
		DWORD AddressOfData;
	} u1;
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
	union {
		DWORD	Characteristics; /* 0 for terminating null import descriptor  */
		DWORD	OriginalFirstThunk;	/* RVA to original unbound IAT */
	} DUMMYUNIONNAME;
	DWORD	TimeDateStamp;	/* 0 if not bound,
				 * -1 if bound, and real date\time stamp
				 *    in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT
				 * (new BIND)
				 * otherwise date/time stamp of DLL bound to
				 * (Old BIND)
				 */
	DWORD	ForwarderChain;	/* -1 if no forwarders */
	DWORD	Name;
	/* RVA to IAT (if bound this IAT has actual addresses) */
	DWORD	FirstThunk;
	} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

#define IMAGE_ORDINAL_FLAG64             (((ULONGLONG)0x80000000 << 32) | 0x00000000)
#define IMAGE_ORDINAL_FLAG32             0x80000000
#define IMAGE_SNAP_BY_ORDINAL64(ordinal) (((ordinal) & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(ordinal) (((ordinal) & IMAGE_ORDINAL_FLAG32) != 0)
#define IMAGE_ORDINAL64(ordinal)         ((ordinal) & 0xffff)
#define IMAGE_ORDINAL32(ordinal) ((ordinal) & 0xffff)


#ifdef _WIN64
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG64
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL64(Ordinal)
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL64(Ordinal)
typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;
#else
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG32
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL32(Ordinal)
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL32(Ordinal)
typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;
#endif

#endif // !PE_H



```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode_loader/Kernel_shellcode_loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0789B937-AA1D-45BE-A565-4098AEC4A6AB}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Kernel_shellcode_loader</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kernel_shellcode_loader.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode_loader/Kernel_shellcode_loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kernel_shellcode_loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/Kernel_shellcode_loader/kernel_shellcode_loader.cpp`:

```cpp
#include <ntddk.h>
#include <windef.h>

#include "../Kernel_shellcode/pe.h"

ULONG ZwGetFileSize(HANDLE hFile);
BOOLEAN getShCodeParameters(BYTE* buffer, DWORD* offset, DWORD* size);
BOOLEAN checkDosHeader(BYTE* buffer, DWORD* ntHeaderAddress);
BOOLEAN digestNTHeaders(DWORD ntHeaderAddress, DWORD* nSections, DWORD* sectionTableAddress);

#define FILE_PATH L"\\DosDevices\\C:\\ShCode.bin"
#define MEM_TAG 'BOB'
#define FILE_TAG '0000'
#define SHELL_TAG '0001'

#define EXEC_CODE(address) __asm MOV edx, address __asm call edx

extern "C"
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);


	UNICODE_STRING fileName;
	OBJECT_ATTRIBUTES fileAttributes;
	NTSTATUS ntStatus;
	HANDLE fileHandle;
	IO_STATUS_BLOCK statusBlock;
	ULONG fileSize;

	BYTE *fileBuffer, *shellBuffer;
	DWORD shellOffset, shellSize;
	SIZE_T i;

	fileName = RTL_CONSTANT_STRING(FILE_PATH);
	
	InitializeObjectAttributes
	(
		&fileAttributes,
		&fileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	);

	// open the file, copy its bytes into RAM and close the file
	ntStatus = ZwOpenFile
	(
		&fileHandle,
		SYNCHRONIZE | GENERIC_READ,
		&fileAttributes,
		&statusBlock,
		0,
		FILE_SYNCHRONOUS_IO_ALERT
	);
	if (!NT_SUCCESS(ntStatus))
	{
		KdPrint(("[DriverEntry]: Error opening file\n"));
		return ntStatus;
	}

	fileSize = ZwGetFileSize(fileHandle);

	fileBuffer = (BYTE*)ExAllocatePoolWithTag
	(
		NonPagedPool,
		fileSize,
		FILE_TAG
	);

	if (fileBuffer == nullptr)
	{
		KdPrint(("[DriverEntry]: Error allocating memory for file\n"));
		ExFreePool(fileBuffer);
		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	ntStatus = ZwReadFile
	(
		fileHandle,
		NULL,
		NULL,
		NULL,
		&statusBlock,
		(PVOID)fileBuffer,
		fileSize,
		NULL,
		NULL
	);
	if (!NT_SUCCESS(ntStatus))
	{
		KdPrint(("[DriverEntry]: Error reading file\n"));
		ExFreePool(fileBuffer);
		return ntStatus;
	}

	ntStatus = ZwClose(fileHandle);
	if (!NT_SUCCESS(ntStatus))
	{
		KdPrint(("[DriverEntry]: Error closing file\n"));
		ExFreePool(fileBuffer);
		return ntStatus;
	}


	getShCodeParameters(fileBuffer, &shellOffset, &shellSize);

	shellBuffer = (BYTE*)ExAllocatePoolWithTag
	(
		NonPagedPool,
		shellSize,
		SHELL_TAG
	);

	if (shellBuffer == nullptr)
	{
		KdPrint(("[DriverEntry]: Error allocating memory for shellcode\n"));
		ExFreePool(fileBuffer);
		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	for (i = 0; i < shellSize; i++)
	{
		shellBuffer[i] = fileBuffer[shellOffset + i];
	}

	ExFreePool(fileBuffer);


	KdPrint(("[DriverEntry]: executing buffer\n"));
	EXEC_CODE(shellBuffer);
	KdPrint(("[DriverEntry]: done executing buffer\n"));

	ExFreePool(shellBuffer);

	return STATUS_SUCCESS;
}


ULONG ZwGetFileSize(HANDLE hFile) {
	ULONG nRet = 0;
	IO_STATUS_BLOCK StatusBlock;
	FILE_STANDARD_INFORMATION Info;
	if (NT_SUCCESS(ZwQueryInformationFile(hFile,
		&StatusBlock,
		&Info,
		sizeof(Info),
		FileStandardInformation)))
	{
		return Info.EndOfFile.LowPart;
	}

	return nRet;
}

BOOLEAN getShCodeParameters(BYTE* buffer, DWORD* offset, DWORD* size)
{
	BOOL ok;
	DWORD dosHeaderAddress;
	DWORD ntHeaderAddress;
	DWORD nSections;
	DWORD secionTableAddress;
	DWORD index;
	IMAGE_SECTION_HEADER* sectionHeader;

	dosHeaderAddress = (DWORD)buffer;
	ok = checkDosHeader(buffer, &ntHeaderAddress);

	if (!ok)
	{
		KdPrint(("[getShCodeParameters]: Header check failed\n"));
		return (FALSE);
	}

	ok = digestNTHeaders(ntHeaderAddress, &nSections, &secionTableAddress);

	if (!ok)
	{
		KdPrint(("[getShCodeParameters]: NT Header check failed\n"));
		return (FALSE);
	}

	// iterate through section headers

	sectionHeader = (IMAGE_SECTION_HEADER*)secionTableAddress;
	for (index = 0; index < nSections; index++)
	{
		KdPrint(("[getShCodeParameters]: section %d\n", index));

		if
			(
				sectionHeader[index].Name[0] == '.' &&
				sectionHeader[index].Name[1] == 'c' &&
				sectionHeader[index].Name[2] == 'o' &&
				sectionHeader[index].Name[3] == 'd' &&
				sectionHeader[index].Name[4] == 'e'
				)
		{
			KdPrint(("[getShCodeParameters]: found .code\n"));
			*offset = sectionHeader[index].PointerToRawData;
			*size = sectionHeader[index].SizeOfRawData;
			KdPrint(("[getShCodeParameters]: call success\n"));
			return (TRUE);
		}
	}

	KdPrint(("[getShCodeParameters]: Couldn't find .code section\n"));
	return (FALSE);
}


BOOLEAN checkDosHeader(BYTE* buffer, DWORD* ntHeaderAddress)
{
	IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)buffer;

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		KdPrint(("[checkDosHeader]: Error magic value not correct\n"));
		*ntHeaderAddress = 0;
		return (FALSE);
	}

	*ntHeaderAddress = (DWORD)buffer + dos_header->e_lfanew;
	return (TRUE);
}


BOOLEAN digestNTHeaders(DWORD ntHeaderAddress, DWORD* nSections, DWORD* sectionTableAddress)
{
	IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)ntHeaderAddress;

	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
	{
		KdPrint(("[digestNTHeaders]: NT Signature not correct\n"));
		*nSections = 0;
		*sectionTableAddress = 0;
		return (FALSE);
	}

	*nSections = nt_headers->FileHeader.NumberOfSections;
	*sectionTableAddress = (ntHeaderAddress + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + nt_headers->FileHeader.SizeOfOptionalHeader);
	return (TRUE);
}

```

`Drivers/Driver-SRC/shellcode/NameHasher/NameHasher.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

DWORD getHashA(char *str)
{
	DWORD hash;
	hash = 0;

	while (*str != '\0')
	{
		hash = hash + (*(unsigned char*)str | 0x60);
		hash = hash << 1;
		str = str + 1;
	}
	return (hash);
}

int main(int argc, char *argv[])
{
	char name[250];
	DWORD hash;

	if (argc != 2)
	{
		printf("USAGE: %s <name_to_hash>\n", argv[0]);
		return 1;
	}

	hash = getHashA(argv[1]);

	if (strlen(argv[1]) > 100)
	{
		printf("[-] ERROR name too long\n");
		return 1;
	}
	
	snprintf(name, 249, "DWORD %s_hash = 0x%08X;", argv[1], hash);

	printf("%s\n", name);

	return 0;
}

```

`Drivers/Driver-SRC/shellcode/NameHasher/NameHasher.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{AE66F72F-9D19-4613-A024-3D2ECC04371B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NameHasher</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NameHasher.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/NameHasher/NameHasher.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Archivos de recursos">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NameHasher.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/shellcode/README.md`:

```md
## WinKernel Shellcode

This directory holds shellcode examples. And projects, third party or otherwise that employ shellcode in their driver/kernel mode projects.

```

`Drivers/Driver-SRC/wmi/wmiacpi/README.md`:

```md
---
page_type: sample
description: "Contains ACPI BIOS and WMI sample code that enables instrumentation of the ACPI BIOS from within ACPI Source Language (ASL) code."
languages:
- cpp
products:
- windows
- windows-wdk
---

# WMI ACPI Sample

The WMIACPI sample contains ACPI BIOS and Microsoft Windows Management Instrumentation (WMI) sample code that enables instrumentation of the ACPI BIOS from within ACPI Source Language (ASL) code. ASL code can expose data blocks, methods, and events through WMI by leveraging the ACPI-WMI mapping driver (Wmiacpi.sys).

## Operation

The WMIACPI sample contains files which allow an ACPI BIOS developer to add instrumentation from within ASL code. ASL code can expose data blocks, methods, and events through WMI by leveraging the Wmiacpi.sys driver. For more information about the mechanics of writing ASL to expose instrumentation, see the *Windows Instrumentation: WMI and ACPI* white paper included in this sample and available on the Windows Hardware Developer Central (WHDC) Web site.

The following table lists the files included in the sample and their function:

| File | Description |
| --- | --- |
| Device.asl | ASL code that can be included in the ACPI bios that exposes a set of packages, strings, data, methods and events. |
| Acpimof.mof | Managed object format (MOF) file that contains a description of the data blocks, methods, and events that are exposed. This description is required so that WMI can access the data blocks, methods, and events. |
| Acpimof.rc<br>Acpimof.def | Files that are required to build Acpimof.dll, which is a resource-only DLL. |
| Wmi-Acpi.htm | The *Windows Instrumentation: WMI and ACPI* white paper. |
| acpimov.vcxproj | Visual Studio project file for the sample. |
| acpimof.sln | Visual Studio solution file for the sample. |

## Installation

To add the sample code to your ACPI bios and access through WMI:

1. Include the contents of *Device.asl* to your ASL source and rebuild the DSDT. Update the operating system with the new DSDT through reflashing.

1. Build *Acpimof.dll* in the WMIACPI directory. *Acpimof.dll* is a resource-only DLL that contains the compiled MOF in a form that WMI can import into its schema.

1. Copy *Acpimof.dll* to %windir%\\system32 and add a value named "MofImagePath" under the HKEY\_LOCAL\_MACHINE\\CurrentControlSet\\Services\\WmiAcpi key. The contents of the value should be a path to the *Acpimof.dll* file.

1. Restart your computer. When Plug and Play (PnP) recognizes the new device with a pnpid of pnp0c14, it will install *Wmiacpi.sys* automatically and make the MOF resource in Acpimof.dll available to the WMI schema.

Note that you do not need an INF file because Windows supplies an INF for the ACPI-WMI mapping driver device as part of the operating system.

```

`Drivers/Driver-SRC/wmi/wmiacpi/acpimof.def`:

```def
LIBRARY acpimof.dll


```

`Drivers/Driver-SRC/wmi/wmiacpi/acpimof.mof`:

```mof
//
// Wmi internal classes


class WMIEvent : __ExtrinsicEvent
{
};


[WMI,
 Locale("MS\\0x409"),
 Description("This class contains the definition of the package used in other classes"),
 guid("{ABBC0F60-8EA1-11d1-00A0-C90629100000}")
]
class Package
{
    [WmiDataId(1),
     read, write,
     Description("16 bytes of data")
    ] uint8 Bytes[16];
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class to test Query/Set a package"),
 guid("{ABBC0F6a-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_QSPackage
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("description")
    ] Package Data;

};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class to test Query/Set a string"),
 guid("{ABBC0F6b-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_QSString
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("description")
    ] string Text;
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class to test Query/Set a ULONG"),
 guid("{ABBC0F6C-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_QULong
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("description")
    ] uint32 ULong;
};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class used to operate methods on a package"),
 guid("{ABBC0F6D-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_MPackage
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiMethodId(1),
     Implemented,
     read, write,
     Description("Return the contents of a package")
    ] void GetPackage([out, Description("Package Data")] Package Data);

    [WmiMethodId(2),
     Implemented,
     read, write,
     Description("Set the contents of a package")
    ] void SetPackage([in, Description("Package Data")] Package Data);

    [WmiMethodId(3),
     Implemented,
     read, write,
     Description("Generate an event containing package data")
    ] void FirePackage([in, Description("WMI requires a parameter")] uint32 Hack);

};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class used to operate methods on a string"),
 guid("{ABBC0F6E-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_MString
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiMethodId(1),
     Implemented,
     read, write,
     Description("Return the contents of a string")
    ] void GetString([out, Description("String Data")] string Data);

    [WmiMethodId(2),
     Implemented,
     read, write,
     Description("Set the contents of a string")
    ] void SetString([in, Description("String Data")] string Data);

    [WmiMethodId(3),
     Implemented,
     read, write,
     Description("Generate an event containing string data")
    ] void FireString([in, Description("WMI requires a parameter")] uint32 Hack);

};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class used to operate methods on a ULong"),
 guid("{ABBC0F6F-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_MULong
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiMethodId(1),
     Implemented,
     read, write,
     Description("Return the contents of a ULong")
    ] void GetULong([out, Description("Ulong Data")] uint32 Data);

    [WmiMethodId(2),
     Implemented,
     read, write,
     Description("Set the contents of a ULong")
    ] void SetULong([in, Description("Ulong Data")] uint32 Data);

    [WmiMethodId(3),
     Implemented,
     read, write,
     Description("Generate an event containing ULong data")
    ] void FireULong([in, Description("WMI requires a parameter")] uint32 Hack);

};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class containing event generated package data"),
 guid("{ABBC0F70-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_EventPackage : WmiEvent
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("Package Data")
    ] Package Data;

};

[WMI,
 Dynamic,
 Provider("WmiProv"),
 Locale("MS\\0x409"),
 Description("Class containing event generated string data"),
 guid("{ABBC0F71-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_EventString : WmiEvent
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("String Data")
    ] string Text;
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Description("Class containing event generated ULong data"),
 Locale("MS\\0x409"),
 guid("{ABBC0F72-8EA1-11d1-00A0-C90629100000}")
]
class AcpiTest_EventULong : WmiEvent
{
    [key, read]
     string InstanceName;
    [read] boolean Active;

    [WmiDataId(1),
     read, write,
     Description("ULong Data")
    ] uint32 ULong;
};


```

`Drivers/Driver-SRC/wmi/wmiacpi/acpimof.rc`:

```rc
//---------------------------------------------------------------------------
// wmicore.rc
//
// Copyright (c) Microsoft Corporation, 1996-
//---------------------------------------------------------------------------


#include <windows.h>
#include <ntverp.h>

#define VER_FILETYPE			VFT_DLL
#define VER_FILESUBTYPE			VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Resource only DLL containing MOF for ASL code"
#define VER_INTERNALNAME_STR            "acpimof"
#define VER_ORIGINALFILENAME_STR        "acpimof.DLL"

#include "common.ver"

//
// WMIACPI.SYS requires that the mof resource be named MofResource
MofResource MOFDATA acpimof.bmf

```

`Drivers/Driver-SRC/wmi/wmiacpi/acpimof.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F346FBD0-9A67-4761-B670-BA329B8BC97E}</ProjectGuid>
    <RootNamespace>$(MSBuildProjectName)</RootNamespace>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <SampleGuid>{240985EC-6170-4D04-9445-B44552D14F8F}</SampleGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <DriverType />
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(IntDir)</OutDir>
  </PropertyGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ItemGroup Label="WrappedTaskItems">
    <Wmimofck Include=".\$(IntDir)\acpimof.bmf">
      <VBScriptTestOutputFile>.\$(IntDir)\acpimof.vbs</VBScriptTestOutputFile>
    </Wmimofck>
  </ItemGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>acpimof</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>acpimof</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>acpimof</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>acpimof</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <ModuleDefinitionFile>acpimof.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <ModuleDefinitionFile>acpimof.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <ModuleDefinitionFile>acpimof.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <ModuleDefinitionFile>acpimof.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <MofComp Include="acpimof.mof" />
    <ResourceCompile Include="acpimof.rc" />
  </ItemGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
    <Link>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <Target Name="Custom Build Target 1" BeforeTargets="BeforeClCompile">
    <ItemGroup>
      <CustomBuildTarget1Input Include=".\$(IntDir)\acpimof.mof" />
    </ItemGroup>
    <Exec Command="if not exist &quot;%(CustomBuildTarget1Input.Identity)&quot; copy  &quot;.\%(CustomBuildTarget1Input.Filename)%(CustomBuildTarget1Input.Extension)&quot; &quot;%(CustomBuildTarget1Input.Identity)&quot;" WorkingDirectory="$(MSBuildProjectDirectory)" />
    <Exec Command="mofcomp -Amendment:ms_409 -MFL:$(IntDir)\MFL.MFL -MOF:$(IntDir)\MOF.MOF &quot;%(CustomBuildTarget1Input.Identity)&quot;" WorkingDirectory="$(MSBuildProjectDirectory)" />
    <Exec Command="wmimofck -y$(IntDir)\MOF.MOF -z$(IntDir)\MFL.MFL $(IntDir)\MOFMFL.MOF" WorkingDirectory="$(MSBuildProjectDirectory)" />
    <Exec Command="mofcomp -B:&quot;.\$(IntDir)\acpimof.bmf&quot; $(IntDir)\MOFMFL.MOF" WorkingDirectory="$(MSBuildProjectDirectory)" />
  </Target>
  <ItemGroup>
    <Inf Exclude="@(Inf)" Include="*.inf" />
    <FilesToPackage Include="$(TargetPath)" Condition="'$(ConfigurationType)'=='Driver' or '$(ConfigurationType)'=='DynamicLibrary'" />
  </ItemGroup>
  <ItemGroup>
    <None Exclude="@(None)" Include="*.txt;*.htm;*.html" />
    <None Exclude="@(None)" Include="*.ico;*.cur;*.bmp;*.dlg;*.rct;*.gif;*.jpg;*.jpeg;*.wav;*.jpe;*.tiff;*.tif;*.png;*.rc2" />
    <None Exclude="@(None)" Include="*.def;*.bat;*.hpj;*.asmx" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Exclude="@(ClInclude)" Include="*.h;*.hpp;*.hxx;*.hm;*.inl;*.xsd" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`Drivers/Driver-SRC/wmi/wmiacpi/acpimof.vcxproj.Filters`:

```Filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx;*</Extensions>
      <UniqueIdentifier>{FE34A204-FE18-4962-84E3-BF082BB4C857}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
      <UniqueIdentifier>{F517ED08-F4D7-4042-950C-B76D63C83AE4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms;man;xml</Extensions>
      <UniqueIdentifier>{EB06D28C-74B3-4DC0-83C1-ECDE45BE3E45}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="acpimof.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="acpimof.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/wmi/wmiacpi/device.asl`:

```asl
//
// Sample ASL code to demonstrate WMI query, set, method and event operations
//
// Insert this code at an appropriate place in the bios ASL source, rebuild
// the DSDT and replace the original DSDT via the registry or reflashing.
// NT should recognize the pnp0c14 device and by the magic of pnp install 
// wmiacpi.sys and bind it to this ASL. Note that you can have as many
// devices as needed, however each device must have a unique _UID.
//


            Device(AMW0)
                    {
                       // pnp0c14 is pnp id assigned to WMI mapper
                       Name(_HID, "*pnp0c14")
                       Name(_UID, 0x0)

//
// Description of data, events and methods supported by this ASL device.
                       Name(_WDG, Buffer() {

//
// Query - Set Guids.
//
                           // {ABBC0F6a-8EA1-11d1-00A0-C90629100000}
                           // Query - Set Package Guid
                           0x6a, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           65, 65,        // Object Id (AA)
                           4,             // Instance Count
                           0x01,          // Flags (WMIACPI_REGFLAG_EXPENSIVE)

                           // {ABBC0F6b-8EA1-11d1-00A0-C90629100000}
                           // Query - Set String Guid
                           0x6b, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           65, 66,        // Object Id (AB)
                           4,             // Instance Count
                           0x05,          // Flags (WMIACPI_REGFLAG_EXPENSIVE |
                                          //        WMIACPI_REGFLAG_STRING)

                           // Query - Set ULONG Guid
                           // {ABBC0F6c-8EA1-11d1-00A0-C90629100000}
                           0x6c, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           65, 67,        // Object Id (AC)
                           4,             // Instance Count
                           0x01,          // Flags (WMIACPI_REGFLAG_EXPENSIVE)


//
// Method Guids
//    Method Id 1 is get with no input
//    Method Id 2 is set with no output
//    Method Id 3 is fire event

                           // Package
                           // {ABBC0F6d-8EA1-11d1-00A0-C90629100000}
                           0x6d, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           66, 65,        // Object Id (BA)
                           4,             // Instance Count
                           0x02,          // Flags (WMIACPI_REGFLAG_METHOD)

                           // String
                           // {ABBC0F6e-8EA1-11d1-00A0-C90629100000}
                           0x6e, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           66, 66,        // Object Id (BB)
                           4,             // Instance Count
                           0x06,          // Flags (WMIACPI_REGFLAG_METHOD)
                                          //        WMIACPI_REGFLAG_STRING)

                           // ULONG
                           // {ABBC0F6f-8EA1-11d1-00A0-C90629100000}
                           0x6f, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           66, 67,        // Object Id (BC)
                           4,             // Instance Count
                           0x02,          // Flags (WMIACPI_REGFLAG_METHOD)



//
// Event Guids

                           // Package
                           // {ABBC0F70-8EA1-11d1-00A0-C90629100000}
                           0x70, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           0xd0, 0,       // Notification Id
                           1,             // Instance Count
                           0x08,          // Flags (WMIACPI_REGFLAG_EVENT)

                           // String
                           // {ABBC0F71-8EA1-11d1-00A0-C90629100000}
                           0x71, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           0xd1, 0,       // Notification Id
                           1,             // Instance Count
                           0x0c,          // Flags (WMIACPI_REGFLAG_EVENT)
                                          //        WMIACPI_REGFLAG_STRING)

                           // ULONG
                           // {ABBC0F72-8EA1-11d1-00A0-C90629100000}
                           0x72, 0x0f, 0xBC, 0xAB, 0xa1, 0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,
                           0xd2, 0,       // Notification Id
                           1,             // Instance Count
                           0x08           // Flags (WMIACPI_REGFLAG_EVENT)

                       })


                       // Storage for 4 instances of Package
                       Name(SAA0, Buffer(0x10)
                       {
                           1,0,0,0, 2,0,0,0, 3,0,0,0, 4,0,0,0
                       })

                       Name(SAA1, Buffer(0x10)
                       {
                           1,0,0,0, 2,0,0,0, 3,0,0,0, 4,0,0,0
                       })

                       Name(SAA2, Buffer(0x10)
                       {
                           1,0,0,0, 2,0,0,0, 3,0,0,0, 4,0,0,0
                       })

                       Name(SAA3, Buffer(0x10)
                       {
                           1,0,0,0, 2,0,0,0, 3,0,0,0, 4,0,0,0
                       })


                       // Storage for 4 instances of string
                       // Maximum length for string is 80 chars
                       Name(SAB0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()1234567890-_=+[]{}")

                       Name(SAB1, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()1234567890-_=+[]{}")

                       Name(SAB2, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()1234567890-_=+[]{}")

                       Name(SAB3, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()1234567890-_=+[]{}")

                       // Storage for 4 instances of ULONG
                       Name(SAC0, 0)
                       Name(SAC1, 1)
                       Name(SAC2, 2)
                       Name(SAC3, 3)


                       // Collection Control flags
                       Name(CCAA, 0)
                       Name(CCAB, 0)
                       Name(CCAC, 0)

                       // Event Control flags
                       Name(ECD0, 0)
                       Name(ECD1, 0)
                       Name(ECD2, 0)


                       // Collection control for AA
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WCAA, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(CCAA, Zero))
                               {
                                   // ERROR - Collection Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WCAA called, but CCAA is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 14, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(CCAA, Zero))
                               {
                                   // ERROR - Collection Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WCAA called, but CCAA is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 13, 0)
                               }
                           }
                           Store(Arg0, CCAA)
                       }

                       // Collection control for AB
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WCAB, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(CCAB, Zero))
                               {
                                   // ERROR - Collection Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WCAB called, but CCAB is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 16, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(CCAB, Zero))
                               {
                                   // ERROR - Collection Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WCAB called, but CCAB is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 15, 0)
                               }
                           }
                           Store(Arg0, CCAB)
                       }

                       // Collection control for AC
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WCAC, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(CCAC, Zero))
                               {
                                   // ERROR - Collection Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WCAC called, but CCAC is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 18, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(CCAC, Zero))
                               {
                                   // ERROR - Collection Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WCAC called, but CCAC is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 17, 0)
                               }
                           }
                           Store(Arg0, CCAC)
                       }


                       // Event control for D0
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WED0, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(ECD0, Zero))
                               {
                                   // ERROR - Event Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WED0 called, but ECD0 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 20, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(ECD0, Zero))
                               {
                                   // ERROR - Event Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WED0 called, but WED0 is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 19, 0)
                               }
                           }
                           Store(Arg0, ECD0)
                       }


                       // Event control for D1
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WED1, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(ECD1, Zero))
                               {
                                   // ERROR - Event Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WED1 called, but ECD1 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 22, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(ECD1, Zero))
                               {
                                   // ERROR - Event Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WED1 called, but WED1 is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 21, 0)
                               }
                           }
                           Store(Arg0, ECD1)
                       }

                       // Event control for D2
                       // Arg0 has 0 for disable, non 0 for enable
                       Method(WED2, 1) {

                           if (LEqual(Arg0, Zero))
                           {
                               // We are disabling
                               if (LEqual(ECD2, Zero))
                               {
                                   // ERROR - Event Control was already disabled
                                   Name(Foo, "WMIACPI: ASL: WED2 called, but ECD2 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 24, 0)
                               }
                           } else {
                               // We are enabling
                               if (LNotEqual(ECD2, Zero))
                               {
                                   // ERROR - Event Control was already enabled
                                   Name(Foo1, "WMIACPI: ASL: WED2 called, but WED2 is 1\n")
                                   Store(Foo1, Debug)
                                   Fatal(0xa0, 23, 0)
                               }
                           }
                           Store(Arg0, ECD2)
                       }

                       // Get value for package A
                       Method(GETA, 1)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Return(SAA0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Return(SAA1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Return(SAA2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Return(SAA3)
                           }

                           Name(Foo, "WMIACPI: ASL: GETA called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 2, 0)
                       }


                       // Get value for package A
                       Method(GETB, 1)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Return(SAB0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Return(SAB1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Return(SAB2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Return(SAB3)
                           }

                           Name(Foo, "WMIACPI: ASL: GETB called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 4, 0)
                       }

                       Method(GETC, 1)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Return(SAC0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Return(SAC1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Return(SAC2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Return(SAC3)
                           }

                           Name(Foo, "WMIACPI: ASL: GETC called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 6, 0)
                       }

                       //
                       // Package Query data block
                       // Arg0 has the instance being queried
                       Method(WQAA, 1) {
                           if (LEqual(CCAA, Zero))
                           {
                               // ERROR - Collection Control was not enabled
                               Name(Foo, "WMIACPI: ASL: WQAA called, but CCAA is 0\n")
                               Store(Foo, Debug)
                               Name(Foo1, "aa")
                               Store(Debug, Foo1)
                               Fatal(0xa0, 1, 0)
                           }

                           Return(GETA(Arg0))

                       }

                       //
                       // String Query data block
                       // Arg0 has the instance being queried
                       Method(WQAB, 1) {
                           if (LEqual(CCAB, Zero))
                           {
                               // ERROR - Collection Control was not enabled
                               Name(Foo, "WMIACPI: ASL: WQAB called, but CCAB is 0\n")
                               Store(Foo, Debug)
                               Fatal(0xa0, 3, 0)
                           }
                           Return(GETB(Arg0))
                       }

                       //
                       // ULONG Query data block
                       // Arg0 has the instance being queried
                       Method(WQAC, 1) {
                           if (LEqual(CCAC, Zero))
                           {
                               // ERROR - Collection Control was not enabled
                               Name(Foo, "WMIACPI: ASL: WQAC called, but CCAC is 0\n")
                               Store(Foo, Debug)
                               Fatal(0xa0, 5, 0)
                           }
                           Return(GETC(Arg0))
                       }

                       Method(SETA, 2)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Store(Arg1, SAA0)
                               Return(SAA0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Store(Arg1, SAA1)
                               Return(SAA1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Store(Arg1, SAA2)
                               Return(SAA2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Store(Arg1, SAA3)
                               Return(SAA3)
                           }

                           Name(Foo, "WMIACPI: ASL: SETA called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 8, 0)
                       }

                       Method(SETB, 2)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Store(Arg1, SAB0)
                               Return(SAB0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Store(Arg1, SAB1)
                               Return(SAB1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Store(Arg1, SAB2)
                               Return(SAB2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Store(Arg1, SAB3)
                               Return(SAB3)
                           }

                           Name(Foo, "WMIACPI: ASL: SETB called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 10, 0)
                       }

                       Method(SETC, 2)
                       {
                           //
                           // Return data corresponding to instance specified
                           if (LEqual(Arg0, Zero)) {
                               Store(Arg1, SAC0)
                               Return(SAC0)
                           }

                           if (LEqual(Arg0, 1)) {
                               Store(Arg1, SAC1)
                               Return(SAC1)
                           }

                           if (LEqual(Arg0, 2)) {
                               Store(Arg1, SAC2)
                               Return(SAC2)
                           }

                           if (LEqual(Arg0, 3)) {
                               Store(Arg1, SAC3)
                               Return(SAC3)
                           }

                           Name(Foo, "WMIACPI: ASL: SETC called with InstanceIndex = ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 12, 0)
                       }

                       //
                       // Set Data Block - Package
                       // Arg0 has the instance being queried
                       // Arg1 has the new value for the data block instance
                       Method(WSAA, 2) {
                           if (LEqual(CCAA, Zero))
                           {
                               // ERROR - Collection Control was not enabled
                               Name(Foo, "WMIACPI: ASL: WSAA called, but CCAA is 0\n")
                               Store(Foo, Debug)
                               Fatal(0xa0, 7, 0)
                           }

                           Return(SETA(Arg0, Arg1))
                       }

                       //
                       // Set Data Block - String
                       // Arg0 has the instance being queried
                       // Arg1 has the new value for the data block instance
                       Method(WSAB, 2) {
                           if (LEqual(CCAB, Zero))
                           {
                               // ERROR - Collection Control was not enabled
                               Name(Foo, "WMIACPI: ASL: WSAB called, but CCAB is 0\n")
                               Store(Foo, Debug)
                               Fatal(0xa0, 9, 0)
                           }

                           Return(SETB(Arg0, Arg1))
                       }


                       //
                       // Set Data Block - ULONG
                       // Arg0 has the instance being queried
                       // Arg1 has the new value for the data block instance
                       Method(WSAC, 2) {
                           if (LEqual(CCAC, Zero))
                           {
                               // ERROR - Collection Control was not enACled
                               Name(Foo, "WMIACPI: ASL: WSAC called, but CCAC is 0\n")
                               Store(Foo, Debug)
                               Fatal(0xa0, 11, 0)
                           }
                           Return(SETC(Arg0, Arg1))
                       }

                       //
                       // Validate that instance index is between 0 and 3
                       Method(VINS, 1)
                       {
                           if (LLess(Arg0, Zero))
                           {
                               Name(Foo, "WMIACPI: ASL: VINS called with InstanceIndex = ")
                               Store(Foo, Debug)
                               Store(Arg0, Debug)
                               Fatal(0xa0, 27, 0)
                           }

                           if (LGreater(Arg0, 3))
                           {
                               Name(Foo1, "WMIACPI: ASL: VINS called with InstanceIndex = ")
                               Store(Foo1, Debug)
                               Store(Arg0, Debug)
                               Fatal(0xa0, 28, 0)
                           }
                       }


                       //
                       // Package Method data block
                       // Arg0 has the instance being queried
                       // Arg1 has the method id
                       // Arg2 has the data passed
                       Method(WMBA, 3) {

                           // MethodId 1 - Get
                           if (LEqual(Arg1, 1))
                           {
                               Return(GETA(Arg0))
                           }


                           // MethodId 2 - Set
                           if (LEqual(Arg1, 2))
                           {
                               SETA(Arg0, Arg2)
                               Return(0)
                           }

                           // MethodId 3 - Event Generate
                           if (LEqual(Arg1, 3))
                           {
                               VINS(Arg0)
                               if (LEqual(ECD0, Zero))
                               {
                                   // ERROR - Event Control was not enabled
                                   Name(Foo, "WMIACPI: ASL: WMBA called, but ECD0 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 25, 0)
                                   
                               }
                               Notify(AMW0, 0xd0)
                               Return(0)
                           }

                           Name(Foo1, "WMIACPI: ASL: WMBA passed method id ")
                           Store(Foo1, Debug)
                           Store(Arg1, Debug)
                           Fatal(0xa0, 26, 0)

                       }

                       //
                       // String Method data block
                       // Arg0 has the instance being queried
                       // Arg1 has the method id
                       // Arg2 has the data passed
                       Method(WMBB, 3) {

                           // MethodId 1 - Get
                           if (LEqual(Arg1, 1))
                           {
                               Return(GETB(Arg0))
                           }


                           // MethodId 2 - Set
                           if (LEqual(Arg1, 2))
                           {
                               SETB(Arg0, Arg2)
                               Return(0)
                           }

                           // MethodId 3 - Event Generate
                           if (LEqual(Arg1, 3))
                           {
                               VINS(Arg0)
                               if (LEqual(ECD1, Zero))
                               {
                                   // ERROR - Event Control was not enabled
                                   Name(Foo, "WMIACPI: ASL: WMBB called, but ECD1 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 29, 0)
                                   
                               }
                               Notify(AMW0, 0xd1)
                               Return(0)
                           }

                           Name(Foo1, "WMIACPI: ASL: WMBB passed method id ")
                           Store(Foo1, Debug)
                           Store(Arg1, Debug)
                           Fatal(0xa0, 30, 0)

                       }

                       //
                       // ULONG Method data block
                       // Arg0 has the instance being queried
                       // Arg1 has the method id
                       // Arg2 has the data passed
                       Method(WMBC, 3) {

                           // MethodId 1 - Get
                           if (LEqual(Arg1, 1))
                           {
                               Return(GETC(Arg0))
                           }


                           // MethodId 2 - Set
                           if (LEqual(Arg1, 2))
                           {
                               SETC(Arg0, Arg2)
                               Return(0)
                           }

                           // MethodId 3 - Event Generate
                           if (LEqual(Arg1, 3))
                           {
                               VINS(Arg0)
                               if (LEqual(ECD2, Zero))
                               {
                                   // ERROR - Event Control was not enabled
                                   Name(Foo, "WMIACPI: ASL: WMBC called, but ECD2 is 0\n")
                                   Store(Foo, Debug)
                                   Fatal(0xa0, 31, 0)
                                   
                               }
                               Notify(AMW0, 0xd2)
                               Return(0)
                           }

                           Name(Foo1, "WMIACPI: ASL: WMBC passed method id ")
                           Store(Foo1, Debug)
                           Store(Arg1, Debug)
                           Fatal(0xa0, 32, 0)
                       }




                       //
                       // More info about an event
                       // Arg0 is the event id that was fired
                       Method(_WED, 1) 
                       {
                           if (LEqual(Arg0, 0xd0)) 
                           {
                               Return(GETA(0))
                           }

                           if (LEqual(Arg0, 0xd1)) 
                           {
                               Return(GETB(0))
                           }

                           if (LEqual(Arg0, 0xd2)) 
                           {
                               Return(GETC(0))
                           }

                           Name(Foo, "WMIACPI: ASL: _WED passed event code ")
                           Store(Foo, Debug)
                           Store(Arg0, Debug)
                           Fatal(0xa0, 33, 0)

                       }

                    }



```

`Drivers/Driver-SRC/wmi/wmiacpi/wmi-acpi.htm`:

```htm
<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>New Page 1</title>
<style>
<!--
 p.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	font-family:"Times New Roman"}
p.Tt
	{mso-style-parent:"";
	margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	page-break-after:avoid;
	font-size:9.5pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;
	}
p.Ch
	{mso-style-parent:"";
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:27.0pt;
	margin-left:0in;
	line-height:27.0pt;
	page-break-after:avoid;
	font-size:22.0pt;
	font-family:Arial;
	}
p.Tr
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	text-align:right;
	line-height:1.0pt;
	page-break-after:avoid;
	border:medium none;
	padding:0in;
	font-size:4.0pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
p.Le
	{margin-bottom:.0001pt;
	text-align:right;
	line-height:8.0pt;
	font-size:6.0pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
p.Tpf
	{margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	tab-stops:14.0pt 28.0pt;
	font-size:9.5pt;
	font-family:"Times New Roman";
	}
p.MsoToc1
	{margin-bottom:.0001pt;
	line-height:11.0pt;
	page-break-after:avoid;
	tab-stops:right dotted 6.0in;
	font-size:9.5pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
p.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:14.0pt;
	margin-bottom:.0001pt;
	line-height:11.0pt;
	tab-stops:right dotted 6.0in;
	font-size:9.5pt;
	font-family:"Times New Roman";
	}
h1
	{mso-style-parent:"";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:22.0pt;
	page-break-after:avoid;
	border:medium none;
	padding:0in;
	font-size:20.0pt;
	font-family:Arial;
	font-weight:normal}
p.MsoListBullet
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:.25in;
	text-indent:-.25in;
	tab-stops:list blank .25in;
	font-size:10.0pt;
	font-family:"Times New Roman";
	}
p.Ex
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	line-height:11.0pt;
	tab-stops:19.5pt 39.0pt 58.5pt 78.0pt 97.5pt 117.0pt 136.5pt 156.0pt 175.5pt 195.0pt 214.5pt 3.25in 253.5pt 273.0pt 292.5pt 312.0pt 331.5pt;
	font-size:8.0pt;
	font-family:"Courier New";
	margin-left:0in; margin-right:0in; margin-top:0in}
p.Thf
	{margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:11.0pt;
	page-break-after:avoid;
	font-size:9.5pt;
	font-family:"Times New Roman";
	font-weight:bold;
	}
p.Th
	{margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	line-height:11.0pt;
	page-break-after:avoid;
	font-size:9.5pt;
	font-family:"Times New Roman";
	font-weight:bold;
	}
p.Tp
	{margin-top:1.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:12.0pt;
	line-height:11.0pt;
	tab-stops:14.0pt 28.0pt;
	font-size:9.5pt;
	font-family:"Times New Roman";
	}
p.Lp1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:.25in;
	font-size:10.0pt;
	font-family:"Times New Roman";
	}
p.Term1
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	line-height:12.0pt;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Times New Roman";
	font-weight:bold;
	margin-left:0in; margin-right:0in; margin-top:0in}
p.Def1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:10.0pt;
	font-size:10.0pt;
	font-family:"Times New Roman";
	}
h2
	{margin-top:7.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:19.0pt;
	page-break-after:avoid;
	font-size:17.0pt;
	font-family:Arial;
	font-weight:normal}
-->
</style>
</head>

<body>

<div style="border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.5pt solid windowtext; padding-left: 0in; padding-right: 0in; padding-top: 0in; padding-bottom: 1.0pt">
  <p class="MsoNormal" style="border: medium none; padding: 0in"><b>
  <span style="font-size: 30.0pt; font-family: Arial Black">WinHEC 99 White 
  Paper </span></b>
</div>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse">
  <tr>
    <td width="295" valign="top" style="width: 221.4pt; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in">
    <p class="Tt">Windows<span style="font-size: 8.0pt">®</span> Hardware 
    Engineering Conference:<br>
    Advancing the Platform</td>
    <td width="304" valign="top" style="width: 228.0pt; padding-left: 5.4pt; padding-right: 5.4pt; padding-top: 0in; padding-bottom: 0in">
    <p class="MsoNormal" align="right" style="text-align: right">&nbsp;</td>
  </tr>
</table>
<p class="Ch"><a name="_Toc441982198">Windows&nbsp;2000 Instrumentation: WMI and ACPI</a></p>
<p class="Tt">Abstract</p>
<div style="mso-border-top-alt: solid windowtext .75pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding: 0in">
  <p class="Tr">&nbsp;</div>
<p class="MsoNormal">This paper describes the process that system manufacturers 
(OEMs) can use to provide instrumentation information by including ACPI objects 
in the systems they build that will be recognized by Microsoft® Windows® 
Management Instrumentation (WMI). This information applies for Windows&nbsp;2000 and 
Windows&nbsp;98 OSR 1. By including ACPI objects in the systems they build, OEMs can 
take advantage of a generic mapping driver that allows WMI to make the 
information available to the instrumentation consumers.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The ACPI subsystem contains a wealth of instrumentation 
information; OEMs are encouraged to use ACPI to add additional platform specific 
instrumentation information. However, ACPI objects are not readily accessible by 
instrumentation data consumers such as Web-Based Enterprise Management (WBEM).
</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">This paper assumes the reader is familiar with driver 
mapping under Windows operating systems and the Data Block GUID Mapping control 
method for WMI. References for background and details are cited at 
http://www.microsoft.com/hwdev/manageability/; ACPI implementation information 
is available at http://www.teleport.com/~acpi/.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><!--[if supportFields]>&nbsp;DATE \@ &quot;MMMM d, yyyy&quot; \* 
MERGEFORMAT <![endif]-->March 12, 1999<!--[if supportFields]><![endif]--></p>
<p class="Le">&nbsp;</p>
<p class="Le">&nbsp;</p>
<p class="Tt">Disclaimer and Copyright</p>
<div style="mso-border-top-alt: solid windowtext .75pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding: 0in">
  <p class="Tr">&nbsp;</div>
<p class="Tpf" style="line-height: 9.0pt"><b><span style="font-size: 8.0pt">
Microsoft Disclaimer: </span></b><span style="font-size: 7.0pt">This document is 
for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR 
IMPLIED, IN THIS DOCUMENT.</span></p>
<p class="Tpf" style="line-height: 9.0pt"><span style="font-size: 7.0pt">
Microsoft Corporation may have patents or pending patent applications, 
trademarks, copyrights, or other intellectual property rights covering subject 
matter in this document. The furnishing of this document does not give you any 
license to the patents, trademarks, copyrights, or other intellectual property 
rights except as expressly provided in any written license agreement from 
Microsoft Corporation. </span></p>
<p class="Tpf" style="line-height: 9.0pt"><span style="font-size: 7.0pt">
Microsoft does not make any representation or warranty regarding specifications 
in this document or any product or item developed based on these specifications. 
Microsoft disclaims all express and implied warranties, including but not 
limited to the implied warranties or merchantability, fitness for a particular 
purpose and freedom from infringement. Without limiting the generality of the 
foregoing, Microsoft does not make any warranty of any kind that any item 
developed based on these specifications, or any portion of a specification, will 
not infringe any copyright, patent, trade secret or other intellectual property 
right of any person or entity in any country. It is your responsibility to seek 
licenses for such intellectual property rights where appropriate. Microsoft 
shall not be liable for any damages arising out of or in connection with the use 
of these specifications, including liability for lost profit, business 
interruption, or any other damages whatsoever. Some states do not allow the 
exclusion or limitation of liability or consequential or incidental damages; the 
above limitation may not apply to you. </span></p>
<p class="Tpf" style="line-height: normal"><span style="font-size: 7.0pt">
Microsoft, DirectX, MS&#8209;DOS, Win32, Windows, and Windows&nbsp;NT are registered 
trademarks of Microsoft Corporation. Other product and company names mentioned 
herein may be the trademarks of their respective owners.</span></p>
<p class="Tpf" style="line-height: normal"><span style="font-size: 7.0pt">© 1999 
Microsoft Corporation. All rights reserved.</span></p>
<p class="Tt">&nbsp;</p>
<p class="Tt">Contents</p>
<div style="mso-border-top-alt: solid windowtext .75pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding: 0in">
  <p class="Tr">&nbsp;</div>
<p class="MsoToc1"><!--[if supportFields]>&nbsp;TOC \o &quot;1-2&quot; <![endif]-->Technology 
Overview for Windows&nbsp;2000 
Instrumentation.......................................................................................
<!--[if supportFields]>PAGEREF _Toc445868966 \h <![endif]-->3<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900360036000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1">WMI Overview for Windows&nbsp;2000 
Instrumentation...................................................................................................
<!--[if supportFields]>PAGEREF _Toc445868967 \h <![endif]-->3<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900360037000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1">ACPI-to-WMI Mapper Goals for Windows&nbsp;2000 
Instrumentation...........................................................................
<!--[if supportFields]>PAGEREF _Toc445868968 \h <![endif]-->4<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900360038000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1">ACPI Control Method Naming Conventions and Functionality for 
Windows&nbsp;2000 Instrumentation................ <!--[if supportFields]>PAGEREF 
_Toc445868969 \h <![endif]-->5<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900360039000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1">Data Block Design for Windows&nbsp;2000 
Instrumentation.............................................................................................
<!--[if supportFields]>PAGEREF _Toc445868970 \h <![endif]-->8<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370030000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1">FAQ about WMI and ACPI for Windows&nbsp;2000 
Instrumentation...........................................................................
<!--[if supportFields]>PAGEREF _Toc445868971 \h <![endif]-->11<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370031000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc1"><span style="layout-grid-mode: line">ASL Methods and Sample 
Code</span>..................................................................................................................................
<!--[if supportFields]>PAGEREF _Toc445868972 \h <![endif]-->11<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370032000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc2"><span style="layout-grid-mode: line">ASL Sample Code for an 
Event and Initiating Method</span>......................................................................................
<!--[if supportFields]>PAGEREF _Toc445868973 \h <![endif]-->12<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370033000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc2">Sample ASL Code Embedding MOD Data in ASL..............................................................................................
<!--[if supportFields]>PAGEREF _Toc445868974 \h <![endif]-->14<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370034000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="MsoToc2">Sample .Mof 
File.......................................................................................................................................................
<!--[if supportFields]>PAGEREF _Toc445868975 \h <![endif]-->17<!--[if gte mso 9]><xml>
 <w:data>08D0C9EA79F9BACE118C8200AA004BA90B02000000080000000E0000005F0054006F0063003400340035003800360038003900370035000000</w:data>
</xml><![endif]--><!--[if supportFields]><![endif]--></p>
<p class="Le"><!--[if supportFields]><![endif]-->&nbsp;</p>
<p><span style="font-size: 20.0pt; font-family: Arial">
<br clear="all" style="page-break-before: always">
&nbsp;</span></p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc440694666">Technology Overview</a> for Windows&nbsp;2000 
  Instrumentation</h1>
</div>
<p class="MsoNormal">The ACPI-to-WMI mapping functionality is achieved by means 
of two device drivers provided with the Windows&nbsp;2000 and Windows&nbsp;98 OSR1 
operating systems: </p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Acpi.sys is the regular ACPI device driver with some 
modifications. </p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Wmiacpi.sys registers with Plug and Play ID PNP0c14. </p>
<p class="Le">&nbsp;</p>
<p class="MsoNormal">OEMs can differentiate their PC system capabilities by 
writing ACPI Source Language (ASL) code and a Managed Object Format (.mof or MOF) 
file. The .mof file can be in the BIOS or on disk. For more information about 
MOF, see the “MOF Data Types” section later in this paper.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">ASL code is never executed directly by the Wmiacpi.sys 
driver. ASL code is always executed by the Acpi.sys driver (see the ASL 
information at http://www.teleport.com/~acpi/). Wmiacpi.sys will invoke Acpi.sys 
to call control methods that access the management data exposed by the mapping 
driver.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">Microsoft does not ship a .mof file that is associated with 
the Wmiacpi.sys driver. The only information surfaced through ACPI is the 
temperature zone information, which is surfaced through and associated with the 
Acpi.sys device driver. </p>
<p class="MsoNormal">&nbsp;</p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc440694667">WMI Overview</a> for Windows&nbsp;2000 Instrumentation</h1>
</div>
<p class="MsoNormal">WMI organizes individual data items (properties) into data 
blocks (structures) that contain related information. Data blocks may have one 
or more data items. Each data item has a unique index within the data block, and 
each data block is named by a globally unique 128-bit number called a globally 
unique identifier (GUID). WMI can provide notifications to the data producer as 
to when to start and stop collecting the data items that compose a data block. 
WMI has no knowledge of the data format for individual data blocks.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">WMI functionality allows for querying all instances of a 
data block or a single instance of a data block. It also allows for setting all 
data items in an instance of a data block or a single data item within a single 
instance of a data block.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">In addition to queries and sets, WMI allows WMI method 
calls, which are functionally equivalent to an I/O control (IOCTL) call to a 
device. Each WMI method call is identified by a GUID and a method index for that 
GUID. All WMI method calls use one buffer for input and output parameters. WMI 
allows notifications of significant events to be delivered to interested 
user-mode applications. Each type of event is uniquely named by a GUID. Events 
may also carry a data block with additional information about the event. WMI can 
provide notifications to the event generator about when to enable and disable an 
event type.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">WMI is an open architecture that allows OEMs to define 
their own data blocks, methods, and events. Along with the data that composes 
the custom data block, the OEM must also provide a description that generally 
represents how a data block or WMI method is mapped to a 2-character ID. This 
2&#8209;character ID is part of the names of the control methods that act upon the 
data block. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">For example, when a call is made to query about the data 
block represented by a WMI GUID, the mapper will evaluate the WQ<i>xx</i> 
control method (where <i>xx</i> is the 2-character ID mapped to that GUID). 
These mappings are defined by the ACPI code and obtained by the mapper 
evaluating the _WDG control method. For more information, see “ACPI Control 
Method Naming Conventions and Functionality” later in this paper.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The mapping process is similar for events. The _WDG control 
method provides a mapping between the WMI event GUID that represents the event 
and the notification code specified in the ASL notify instruction. For example, 
when ACPI provides a callback to the mapper that a control method executed a <b>
notify(mapper-device, 0x81)</b><i> </i>function<i>,</i> the mapper will look up 
the WMI GUID mapped to 0x81 and use this WMI GUID in building the WMI event. 
Before launching the WMI event, the mapper will evaluate _WED to retrieve any 
additional data that belongs with the event.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597061"><b>Loading the Mapping Driver</b></a><b>.
</b>The Plug and Play ID PNP0c14 is assigned as the WMI-mapping pseudo device; 
the operating system device INFs (Plug and Play ID-to-device driver lookup 
table) point this Plug and Play ID to the ACPI-to-WMI mapping driver. To cause 
the ACPI-to-WMI mapping driver to load, an ACPI system needs to define one or 
more devices with that Plug and Play ID in the ACPI device tree. Each device 
declared in the ACPI device tree would have its own operating system device 
object with its own set of mappings. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">In this way, different sets of data blocks can be organized 
in the appropriate place within the device tree. This organization allows the 
different devices and their corresponding data blocks to come and go from the 
ACPI device tree. Note that if there are multiple WMI-mapping pseudo devices in 
the ACPI device tree, each device must have a unique value for its _UID.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597062"><b>Mapping Driver Functionality</b></a><b>.
</b>Essentially the mapping driver will do the following:</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Manage all registration and unregistration with WMI and other 
interactions with the operating system. This registration of data and data 
blocks is done when the mapper gets the IRP_MN_REGINFO IRP.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>At WMI initialization time, the mapping driver will query an ACPI 
method for the list of data block, event, and method GUIDs it supports, as well 
as the mapping from the GUID to control method IDs. With this information, the 
mapping driver will register those GUIDs with WMI.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Translate data block queries, sets, and method call I/O IRPs into 
the appropriate ACPI control method call.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Receive notifications from the ACPI event handler control methods 
and relaunch them as WMI events.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Translate strings between ASCIZ and UNICODE for data blocks marked 
as wholly composed of a string.</p>
<p class="Le">&nbsp;</p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc440694668">ACPI-to-WMI Mapper Goals</a> for Windows&nbsp;2000 
  Instrumentation</h1>
</div>
<p class="MsoNormal">The following list describes the goals for the ACPI-to-WMI 
mapper:</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Expose data maintained by the hardware or firmware and accessible 
through ACPI to user-mode instrumentation data consumers, such as WBEM or DMI.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Allow specific ACPI control methods to be called from a user-mode 
instrumentation data consumer or hardware configuration application—for example, 
from a control panel applet.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Deliver specific ACPI events to all user-mode callers that request 
notification of that particular event.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Allow OEMs to include OEM-specific data blocks, user-mode–callable 
ACPI control methods, and events without requiring any changes to the 
ACPI-to-WMI mapper.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Allow general-purpose data consumer applications—those written 
without any special knowledge of the data blocks exposed by a particular 
machine—to be able to access and understand the data blocks, user-mode–callable 
ACPI control methods, and events being mapped—including those that are OEM 
specific.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Define standard data block formats, user-mode–callable ACPI 
control methods, events and their WMI GUID mappings for common data blocks, and 
callable control methods and events expected to be provided by all OEMs. This 
can include dynamic data and functions identified by the industry in the SMBIOS 
specification and other specifications.</p>
<p class="Le">&nbsp;</p>
<p class="MsoNormal">These goals are achieved by having supporting code in the 
ACPI-to-WMI mapper (Wmiacpi.sys) as well as in the core ACPI code itself (Acpi.sys).</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The following are <i>not</i> goals for the ACPI-to-WMI 
mapper:</p>
<p class="MsoListBullet" style="page-break-after: avoid">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>To have specific knowledge about any data block that passes 
through the mapper.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>To provide interfaces specifically for SMBIOS data and functions. 
The mapper is an open architecture that is not restricted to SMBIOS data and 
functionality.</p>
<p class="Le">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc440962623"><b>How SMBIOS-provided information 
is handled</b></a><b>. </b>Vendors who want to provide OEM and system-specific 
instrumentation data may choose to use SMBIOS as the mechanism. To use the 
capabilities of the WMI infrastructure to surface this SMBIOS data, they must 
conform to any SMBIOS version between 2.0 and 2.2. (Microsoft intends to support 
future revisions of SMBIOS as and when they appear. To date, we have only one 
SMBIOS 2.2 machine for testing). This allows the Microsoft Win32<span style="font-size: 8.0pt">®</span> 
provider—which is shipped with Windows&nbsp;2000 and future versions of Windows and 
is available as an update to Windows&nbsp;98—to populate almost all of the SMBIOS-provided 
information into the CIMv2 namespace. In particular, almost all of the 
information is put into Win32 classes. Some of these Win32 classes are derived 
from the CIMv2.1 physical MOF. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The one exception where SMBIOS information will not be 
automatically populated by the Win32 provider into the CIMv2 namespace is SMBIOS 
vendor-specific data. Such SMBIOS vendor-defined data will be placed in a 
“VendorBucket” class in a “Root\VendorDefined” namespace, and will not be 
available in the CIMv2 namespace by default. Any system vendor who wants to 
provide such data must write a provider that will interpret this data.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The SMBIOS data is read only once, either at boot time in 
Windows&nbsp;2000 or post boot on Windows&nbsp;98. Dynamic updates that are made to the 
SMBIOS data after it has been read will not be reflected in the namespaces in 
this implementation. Microsoft is working with the industry to define standard 
ACPI methods for dynamic updates.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The SMBIOS raw data will be available as a WMI data block 
in Windows&nbsp;2000 and as a flat file in Windows&nbsp;98. This data will be interpreted 
and populated into the namespaces by the Win32 provider.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><b>Note:</b> The Win32 provider capabilities used to read 
and populate SMBIOS data as described above will be available in Windows&nbsp;2000 
Beta 3.</p>
<p class="MsoNormal">&nbsp;</p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc409597063">ACPI Control Method Naming Conventions and 
  Functionality</a> for Windows&nbsp;2000 Instrumentation</h1>
</div>
<p class="MsoNormal">The <a name="_Toc409597064">Data Block GUID Mapping control 
method</a> named _WDG evaluates to a buffer that has the GUID mapping 
information for data blocks, events, and WMI methods. The result of the 
evaluation is a buffer containing an array of the following structure. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">typedef struct</p>
<p class="Ex" style="page-break-after: avoid">{</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp; GUID guid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 
GUID that names data block</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp; union</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHAR ObjectId[2];&nbsp; // 
2-character ACPI ID&nbsp; (Data Blocks and Methods)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct </p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -42.0pt">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UCHAR NotificationValue;&nbsp; // Byte value passed by event handler 
control method</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UCHAR Reserved[1];</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } NotifyId;</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp; USHORT InstanceCount;&nbsp; // 
Number of separate instances of data block</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp; USHORT Flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 
Flags</p>
<p class="Ex">};</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">// Set this flag if the WCxx control method should be run to 
whenever the first </p>
<p class="Ex">// data consumer is interested in collecting the data block and 
whenever the last data </p>
<p class="Ex">// consumer is no longer interested.</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">#define WMIACPI_REGFLAG_EXPENSIVE&nbsp;&nbsp; 0x1</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">// Set this flag if the GUID represents a set of WMI method calls 
and not a data block</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">#define WMIACPI_REGFLAG_METHOD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">// Set this flag if the data block is wholly composed of a string 
and should be </p>
<p class="Ex">// translated from ASCIZ to UNICODE in returning queries and from 
UNICODE to ASCIZ </p>
<p class="Ex">// when passing sets</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">#define WMIACPI_REGFLAG_STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">// Set this flag if the guid maps to an event rather than a data 
block or method</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">#define WMIACPI_REGFLAG_EVENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08</p>
<p class="Ex">&nbsp;</p>
<p class="Le">&nbsp;</p>
<p class="MsoNormal">Each element in the array describes the mapping of a WMI 
data block GUID to a 2-letter ACPI method identifier used to compose the method 
names that operate on the data block or on the notification value used in the 
ASL <b>Notify</b> operation. Each element of the array also contains the number 
of instances of the data block that exist and any flags that are set.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">This control method is required.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597067">The following table summarizes the 
information for each control method described later in this section.</a></p>
<p class="MsoNormal">&nbsp;</p>
<p class="Tt">Control Method Summary</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse">
  <tr>
    <td width="120" valign="top" style="width: 1.25in; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Control method</td>
    <td width="96" valign="top" style="width: 1.0in; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Th">Object name</td>
    <td width="103" valign="top" style="width: 77.4pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Th">Parameters</td>
    <td width="281" valign="top" style="width: 210.6pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Th">Control method required</td>
  </tr>
  <tr>
    <td width="120" valign="top" style="width: 1.25in; padding: 0in">
    <p class="Tpf">Data Block Query</td>
    <td width="96" valign="top" style="width: 1.0in; padding: 0in">
    <p class="Th"><span style="font-weight: normal">WQ<i>xx</i></span></td>
    <td width="103" valign="top" style="width: 77.4pt; padding: 0in">
    <p class="Th"><span style="font-weight: normal">ULONG</span></td>
    <td width="281" valign="top" style="width: 210.6pt; padding: 0in">
    <p class="Th"><span style="font-weight: normal">Yes.</span></td>
  </tr>
  <tr>
    <td width="120" valign="top" style="width: 1.25in; padding: 0in">
    <p class="Tpf">Data Block Set</td>
    <td width="96" valign="top" style="width: 1.0in; padding: 0in">
    <p class="Tp">WS<i>xx</i></td>
    <td width="103" valign="top" style="width: 77.4pt; padding: 0in">
    <p class="Tp">ULONG, buffer</td>
    <td width="281" valign="top" style="width: 210.6pt; padding: 0in">
    <p class="Tp">No. Not required for data blocks that are read&nbsp;only.</td>
  </tr>
  <tr>
    <td width="120" valign="top" style="width: 1.25in; padding: 0in">
    <p class="Tpf">Data Item Set</td>
    <td width="96" valign="top" style="width: 1.0in; padding: 0in">
    <p class="Tp">Not supported</td>
    <td width="103" valign="top" style="width: 77.4pt; padding: 0in">
    <p class="Tp">&nbsp;</td>
    <td width="281" valign="top" style="width: 210.6pt; padding: 0in">
    <p class="Tp">&nbsp;</td>
  </tr>
  <tr>
    <td width="120" valign="top" style="width: 1.25in; padding: 0in">
    <p class="Tpf">Method Execution</td>
    <td width="96" valign="top" style="width: 1.0in; padding: 0in">
    <p class="Tp">WM<i>xx</i></td>
    <td width="103" valign="top" style="width: 77.4pt; padding: 0in">
    <p class="Tp">ULONG, method&nbsp;ID, <br>
    buffer</td>
    <td width="281" valign="top" style="width: 210.6pt; padding: 0in">
    <p class="Tp">Yes. Required for data blocks specified in the data block GUID 
    mapping array and that have the WMIACPI_REG_METHOD flag set.</td>
  </tr>
</table>
<p class="MsoNormal">&nbsp;</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse">
  <tr>
    <td width="120" valign="top" style="width: 1.25in; padding: 0in">
    <p class="Tpf">Event Enable and Disable</td>
    <td width="96" valign="top" style="width: 1.0in; padding: 0in">
    <p class="Tp">WE<i>xx</i></td>
    <td width="103" valign="top" style="width: 77.4pt; padding: 0in">
    <p class="Tp">UCHAR</td>
    <td width="281" valign="top" style="width: 210.6pt; padding: 0in">
    <p class="Tp">No. Support only when keeping the event enabled incurs 
    significant overhead.</td>
  </tr>
  <tr>
    <td width="120" valign="top" style="width: 1.25in; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tpf">Data Collection <br>
    Enable and Disable</td>
    <td width="96" valign="top" style="width: 1.0in; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tp">WC<i>xx</i></td>
    <td width="103" valign="top" style="width: 77.4pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tp">UCHAR</td>
    <td width="281" valign="top" style="width: 210.6pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tp">No. Support only when data collecting for the data block 
    incurs significant overhead.</td>
  </tr>
</table>
<p class="Le">&nbsp;</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Data Block Query Control Method. </b>If the Data Block GUID 
Mapping control method describes a data block that does not have the 
WMIACPI_REG_METHOD flag set, there needs to be a control method that evaluates 
to the contents of an instance of the data block. </p>
<p class="Lp1">By convention, the name of the object is WQ<i>xx</i>, where <i>xx</i> 
is the 2-character ID that maps to the GUID being queried. One parameter is 
passed to the method—the index of the instance, which is of type ULONG. Data 
blocks registered with only a single instance can ignore the parameter. If the 
result of the evaluation of the WQ<i>xx</i> method is a string, then the mapper 
will convert that string to UNICODE so that it can be understood by WMI. </p>
<p class="Lp1">This control method is required.</p>
<p class="MsoListBullet"><a name="_Toc409597068">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Data Block Set Control Method</b></a><b>. </b>If the Data Block 
GUID Mapping control method describes a data block that does not have the 
WMIACPI_REG_METHOD flag set, there needs to be a control method that evaluates 
to the contents of an instance of the data block. </p>
<p class="Lp1">By convention, the name of the object is WS<i>xx</i>, where <i>xx</i> 
is the 2-character ID that maps to the GUID being set. Two parameters are passed 
to the method; one is a ULONG that is the index of the instance, and the other 
is a buffer that contains the new values for the data block. </p>
<p class="Lp1">If the GUID for the data block is registered with the 
WMIACPI_REGFLAG_STRING flag, then the mapper assumes that the data block passed 
is wholly composed of a single string and will convert that string from UNICODE 
to ASCIZ so that it can be understood by the WS<i>xx</i> control method. </p>
<p class="Lp1">This control method is not required for those data blocks that 
are read only. </p>
<p class="Lp1">Because the mapper is unaware of the format of the data block 
passed by the caller of the WMI method, it will pass the buffer as a single 
buffer parameter to the WM<i>xx</i> control method. The control method can use 
the ASL instructions <b>CreateBitField</b>, <b>CreateDWordField</b>, <b>
CreateField</b>, and <b>CreateWordField</b> to break up the buffer into its 
parts</p>
<p class="MsoListBullet"><a name="_Toc409597069">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Data Item Set Control Method</b></a><b>. </b>Setting of 
individual data items within a data block is not supported. Typically, data 
items that can be modified should be placed in their own data block or the 
entire data block should be modified.</p>
<p class="MsoListBullet"><a name="_Toc409597070">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Method Execution Control Method</b></a><b>. </b>If the Data 
Block GUID Mapping control method describes a data block that does have the 
WMIACPI_REG_METHOD flag set, there needs to be a control method that performs 
the action required of the method. </p>
<p class="Lp1">By convention, the name of the control method is WM<i>xx</i>, 
where <i>xx</i> is the 2-character ID that maps to the GUID. This method call 
has three parameters; the first is a ULONG that has the instance index being 
executed; the second contains the method ID for the method being executed; and 
the third is a buffer that contains the input for the method call. </p>
<p class="Lp1">If the GUID for the WMI method is registered with the 
WMIACPI_REGFLAG_STRING flag, then the mapper assumes that buffer passed in is a 
string. The mapper will convert the incoming string from UNICODE to ASCIZ. </p>
<p class="Lp1">If the result of the WM<i>xx</i> control method is a string, the 
mapper will convert the result string from ASCIZ to UNICODE. The return value of 
the WM<i>xx</i> method should be a buffer with the result of the method call.
</p>
<p class="Lp1">This control method is<b> </b>required for those data blocks 
specified in the Data Block GUID Mapping array that have the WMIACPI_REG_METHOD 
flag set. </p>
<p class="Lp1">Because the mapper is unaware of the format of the data block 
passed by the caller of the WMI method, it will pass the buffer as a single 
buffer parameter to the WM<i>xx</i> control method. The control method can use 
the ASL instructions <b>CreateBitField</b>, <b>CreateDWordField</b>, <b>
CreateField</b>, and <b>CreateWordField</b> to break the buffer into its parts.</p>
<p class="MsoListBullet"><a name="_Toc409597071">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Event Enable and Disable Control Method</b></a><b>. </b>For 
each event specified in the Event GUID Mapping control method that has the 
WMIACPI_REG_EXPENSIVE flag set, there needs to be a control method that is 
invoked whenever launching of the event should be enabled and disabled. </p>
<p class="Lp1">By convention, the control method is named WE<i>xx</i>, where <i>
xx</i> is the hex value of the notification code passed by the event handler 
control method. This method has one parameter, a UCHAR that has a value of 0 if 
the event is to be disabled or a nonzero value if it is to be enabled. </p>
<p class="Lp1">This method is optional and should only be supported if keeping 
the event enabled incurs significant overhead.</p>
<p class="MsoListBullet"><a name="_Toc409597072">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Data Collection Enable and Disabl</b></a><b>e Control Method.
</b>For each data block described in the Data Block GUID Mapping control method 
that has the WMIACPI_REG_EXPENSIVE flag set, there needs to be a control method 
that is invoked whenever collection of the data that composes the data block 
should be enabled and disabled </p>
<p class="Lp1">By convention, the control method is named WC<i>xx</i>, where <i>
xx</i> is the 2-character ID that maps to the GUID. This method has one 
parameter, a UCHAR that has a value of 0 if data block collection is to be 
disabled or a nonzero value if it is to be enabled. </p>
<p class="Lp1">This method is optional and should only be supported if 
collecting the data for the data block incurs significant overhead.</p>
<p class="MsoListBullet"><a name="_Toc409597073">
<span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b>Additional Event Data</b></a><b>. </b>The _WED control method 
is evaluated by the mapper in response to receiving a notification from a 
control method. The results of the evaluation are passed as part of the WMI 
event information. This mechanism allows additional data to be included with an 
event. </p>
<p class="Lp1">The control method takes one parameter, which is the notification 
code that caused the notification to occur. If the result of the _WED control 
method is a string, then the string is converted from ASCIZ to UNICODE before 
launching the WMI event.</p>
<p class="Le">&nbsp;</p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc409597075">Data Block Design </a>for Windows&nbsp;2000 
  Instrumentation </h1>
</div>
<p class="MsoNormal"><b>Design Considerations. </b>Consider the following in 
designing data blocks for instrumentation under Windows&nbsp;2000:</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Data items that are read-only and are commonly used together 
should be combined into a single data block.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Data items that are strings must be segregated into their own data 
block and registered with the WMIACPI_REGFLAG_STRING flag set so that the mapper 
can convert between ASCIZ and UNICODE.</p>
<p class="MsoListBullet"><span style="font-family: Symbol">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Data items that can be set individually should be segregated into 
their own data blocks. For example, a set of data items that must be set all at 
the same time can be combined into a single data block.</p>
<p class="Le">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597076"><b>MOF</b></a><b> Data Types. </b>
The Managed Object Format (MOF) for the data blocks implemented can be supplied 
as either a resource attached to a file or as the buffer that results from the 
evaluation of a control method. To establish the former, either bind the 
resource to the Wmiacpi.sys image or establish a REG_EXPAND_SZ registry value 
named <b>MofImagePath</b> under the WMIACPI service key. The contents of the 
value is a path to the image file that contains the resource. In either case, 
the resource must be named <b>MofResourceName</b>.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The buffer resulting from the evaluation of the WQ<i>xx</i> 
control method assigned to the binary MOF GUID describes all data blocks, WMI 
methods, and events for the device in a compressed binary format. This binary 
data is created by building a text file using the MOF language and compiling it 
with the MOF compiler.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">MOF data types are very rich. MOF supports the basic data 
types of 8-, 16-, 32-, and 64-bit signed and unsigned integers, Boolean terms, 
floating points, strings, and UTC datetimes. Embedded classes—that is, 
structures that can contain basic data types and other embedded classes—are also 
supported. In addition, fixed and variable length arrays of basic data types and 
embedded classes are supported. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The MOF language defines the data types shown in the 
following table.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="Tt">MOF Data Types</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse">
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Data types</td>
    <td width="407" valign="top" style="width: 305.4pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Data format</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">String</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Null terminated ANSI string</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">sint32</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Signed 32-bit integer </td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">uint32</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Unsigned 32-bit integer</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">sint16 </td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Signed 16-bit integer </td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">uint16 </td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Unsigned 16-bit integer </td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">sint64</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Signed 64-bit integer</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">uint64</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Unsigned 64-bit integer</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">sint8</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Signed 8-bit character </td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">uint8</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Unsigned 8-bit integer</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">Datetime</td>
    <td width="407" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">25-character string used to specify absolute dates or time 
    intervals. </td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tpf">Boolean</td>
    <td width="407" valign="top" style="width: 305.4pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tpf">Byte where 0 is FALSE, != 0 is TRUE </td>
  </tr>
</table>
<p class="Le">&nbsp;</p>
<p class="MsoNormal"><b>Important: </b>Because the MOF data types are much 
richer than those for ACPI control methods, the control method must be careful 
to pack the data blocks correctly within an ACPI buffer. The control method can 
also restrict itself to using only common data types.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">Each MOF class represents a data block and may contain one 
or more properties that represent data items within the data block. A MOF class 
would hold all information needed to parse a data block returned from the mapper. 
In addition, the MOF language allows rich meta-data to be included as qualifiers 
on properties and classes. Some qualifiers are required, but most are optional.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">Class and data item qualifiers are defined in the following 
table.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="Tt">Class and Data Item Qualifiers</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0" style="border-collapse: collapse">
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Qualifier</td>
    <td width="400" valign="top" style="width: 300.0pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Description</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Class qualifiers:</td>
    <td width="400" valign="top" style="width: 300.0pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf"><span style="font-size: 10.5pt">&nbsp;</span></td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[guid(“<i>guid-string</i>”)] </td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Declares the GUID that represents the class within WMI. This 
    qualifier is required.</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[Dynamic] </td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Required for WBEM.</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[WMI] </td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Required for WBEM.</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[Provider(“WmiProv”)] </td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Required for WBEM.</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[Description(<i>“description-text”)</i>]<i> </i></td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Specifies description text for the class or property in the 
    locale specified for the locale qualifier.</td>
    <td style="border: medium none; padding: 0in" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[WmiExpense(<i>expense-value</i>)] </td>
    <td width="400" valign="top" style="width: 300.0pt; padding: 0in">
    <p class="Tpf">Specifies the quantity of system resources required in order 
    to collect data in the data block; <i>expense-value</i> is defined to be the 
    average number of CPU cycles needed to collect the data block. If this 
    qualifier is not specified, then the <i>expense-value</i> is assumed to be 
    0.</td>
    <td style="border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext" width="7">
    <p class="MsoNormal">&nbsp;</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf">Data item qualifiers:</td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: 1.0pt solid windowtext; padding: 0in; background: #CCCCCC">
    <p class="Thf"><span style="font-size: 10.5pt">&nbsp;</span></td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[read] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Specifies that the data item may be read.</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[write] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Specifies that the data item may be written.</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[WmiDataID(<i>data-item-ID</i>)] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Specifies the data item ID for the data item. This qualifier 
    is required.</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf"><span style="layout-grid-mode: line">[WmiScale(<i>scale-factor</i>)]
    </span></td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf"><span style="layout-grid-mode: line">Specifies the scaling 
    factor to use when displaying the data. Before displaying the data returned 
    from a query of the data item, it is multiplied by 10 to the power of <i>
    scale-factor</i>. If this qualifier is not specified, then the <i>
    scale-factor</i> is assumed to be 0.</span></td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[WmiComplexity(“<i>complexity-category”</i>)] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Specifies the level of detail associated with the counter. <i>
    Complexity-category</i> can have the value of “Novice” for the information 
    that anyone can understand, “Advanced” for information that is useful for 
    advanced users, “Expert” for information that is useful to only expert 
    users, and “Wizard” for information that is useful for the data provider 
    designer. If this qualifier is not specified, then a <i>complexity-category</i> 
    of “Novice” is assumed.</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; padding: 0in">
    <p class="Tpf">[WmiVolatility(<i>validity-interval</i>)] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; padding: 0in">
    <p class="Tpf">Specifies how often this data item value is updated 
    internally. <i>Validity-interval</i> is defined in units of milliseconds, so 
    a <i>validity-interval</i> of 1000 would mean that the data item is updated 
    internally every second. Data consumers can use this measure to determine 
    how frequently it should poll for changes in a data item. If this qualifier 
    is not specified, then no assumption on the length of validity for a data 
    item can be made.</td>
  </tr>
  <tr>
    <td width="200" valign="top" style="width: 150.0pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tpf">[WmiSizeIs(“<i>property-name</i>”)] </td>
    <td width="407" colspan="2" valign="top" style="width: 305.4pt; border-left: medium none; border-right: medium none; border-top: medium none; border-bottom: 1.0pt solid windowtext; padding: 0in">
    <p class="Tpf">Specifies the property within the current class that has the 
    count of the number of array elements (not bytes) contained in a variable 
    length array.</td>
  </tr>
</table>
<p class="Le">&nbsp;</p>
<p class="MsoNormal" style="margin-right: -24.0pt">The order that the data items 
are laid out in the data block is controlled by the data item ID. Data item IDs 
must be allocated contiguously starting with data item ID 1. The data item order 
specified in the MOF is not relevant. </p>
<p class="MsoNormal" style="margin-right: -24.0pt">&nbsp;</p>
<p class="MsoNormal" style="margin-right: -24.0pt">MOF supports arrays of the 
basic types shown in the “MOF Data Types” table shown earlier. A variable sized 
array must have a <b>WmiSizeIs()</b> qualifier that specifies the property that 
has the number of elements in the array. </p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597077"><b>Data Block Format</b></a><b>.
</b>The format of the data block buffer returned from the query control method 
and passed into the set control method must be consistent with the description 
of it specified by the MOF for that data block with respect to the order and 
size of the data items within the data block<span style="layout-grid-mode: line">.</span> 
The Boolean data type is 1&nbsp;byte in length and has a value of 0 for FALSE and 
non-zero value for TRUE. The string data type is a C-style ANSI null-terminated 
string.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc409597078"><b>Standard Data Blocks, Methods, 
and Events</b></a><b>. </b>Additional data blocks, events, and methods will be 
defined in the future; they should be implemented by all OEMs in order to ensure 
a minimum of functionality on all PCs. In the future, an industry standard will 
be defined for the globally unique GUIDs to be assigned to the data blocks. The 
WMI component within Windows will contain the MOF definition for these standard 
data blocks so it does not need to be part of the result from the binary .mof 
query.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><a name="_Toc440694672"><b>Custom Data Blocks, Methods and 
Events</b></a><b>. </b>Custom or OEM-specific data blocks, events, and methods 
can be added by including them in the result of the _WDG method. The GUIDs that 
are assigned must be globally unique so they can be generated by a tool such as 
Guidgen or Uuidgen, which are provided with the WMI information in the Microsoft 
Platform SDK.</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">The MOF definition for these custom data blocks must be 
included in the results of the WQ<i>xx</i> method, where <i>xx</i> has been 
mapped to the MOF Data GUID, which is the GUID that is queried and returns MOF 
data—in order for applications to be able to access the data blocks. Or the MOF 
could be added as a resource to Wmiacpi.sys with a name of <b>MofResourceName</b> 
and a type MOFDATA. It can also be a resource in another image file with same 
name and type that is pointed to by the <b>MofImagePath </b>value in the 
registry key HKLM\CurrentControlSet\Services\WmiAcpi</p>
<p class="MsoNormal">&nbsp;</p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc440694673">FAQ about WMI and ACPI</a> for Windows&nbsp;2000 
  Instrumentation</h1>
</div>
<p class="Term1">How does WMI find ACPI/ASL code?</p>
<p class="Def1"><span style="layout-grid-mode: line">In ASL, the developer 
creates a device with an _HID of </span>PNP0c14<span style="layout-grid-mode: line">. 
The operating system enumerates the device and loads the Wmiacpi.sys driver on 
top of it.</span></p>
<p class="Term1"><span style="layout-grid-mode: line">How does the MOF 
associated with ACPI BIOS get registered?</span></p>
<p class="Def1"><span style="layout-grid-mode: line">It is either a resource 
attached to Wmiacpi.sys or another image file such as a resource-only DLL.
</span></p>
<p class="Term1"><span style="layout-grid-mode: line">How does a management 
application discover the classes and properties provided by ASL instrumentation?</span></p>
<p class="Def1"><span style="layout-grid-mode: line">By looking in the WMI 
namespace of the schema.</span></p>
<p class="Term1"><span style="layout-grid-mode: line">Is the following true? 
Because very few ACPI standards exist for instrumentation, most of the ACPI 
instrumented features will appear differently on each vendor’s product, and 
management applications will have to be “taught” to interpret the varying 
classes and methods.</span></p>
<p class="Def1"><span style="layout-grid-mode: line">Microsoft is looking at 
standardizing this. Any suggestions are appreciated.</span></p>
<p class="Term1"><span style="layout-grid-mode: line">Who provides the .mof 
files for standard ACPI features such as thermal monitoring?</span></p>
<p class="Def1"><span style="layout-grid-mode: line">Windows&nbsp;2000 has a .mof 
file for thermal zone temperature as part of the operating system and 
instruments it within Acpi.sys, outside of the mapper.</span></p>
<p class="Def1"><span style="layout-grid-mode: line">Typically, .mof files are 
compiled into .bmf files and attached to a driver as a resource. The .bmf files 
can be in the ROM or on disk. WMI determines the location of the .mof 
information by looking at the registry for the <b>MofImagePath</b> value under 
the WMIACPI service. If this does not exist, then WMI looks at the <b>ImagePath</b> 
value. If Wmiacpi.sys does not have a .mof resource, then WMI will query the 
binary .mof GUID for the .mof information.</span></p>
<p class="Def1"><span style="layout-grid-mode: line">A driver may have a static 
list of pre-built .mof files; if so, it can “dynamically” report one of them. 
The mechanism is to report the file using a predefined GUID that returns a 
binary .mof.</span></p>
<p class="Def1"><span style="layout-grid-mode: line">To dynamically build a .mof 
file, a driver would have to build a .mof file and then launch the .mof 
compiler, which is difficult. Currently, to do this on the machine running 
Wmiacpi.sys, the <b>mofcomp</b> command can be used to load the .mof file 
directly into the CIMOM database. </span></p>
<div style="mso-border-top-alt: solid windowtext .5pt; border-left: medium none; border-right: medium none; border-top: 1.0pt solid windowtext; border-bottom: medium none; padding-left: 0in; padding-right: 0in; padding-top: 1.0pt; padding-bottom: 0in">
  <h1><a name="_Toc440694675"><span style="layout-grid-mode: line">ASL Methods 
  and Sample Code</span></a></h1>
</div>
<p class="MsoNormal"><span style="layout-grid-mode: line">The following list 
represents some of the ASL methods defined by the ACPI specification. These 
methods are of particular interest for systems management. None of these methods 
have been implemented yet within the WMI/ACPI mapper to date. </span>A BIOS 
developer, for example, could use these methods to expose data using the mapper.
<span style="layout-grid-mode: line">These methods represent good opportunities 
for OEMs to differentiate their products with minimal effort:</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_ACX — Temperature threshold 
at which various degrees of active cooling are engaged</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_CRT — Critical temperature 
at which system will shut down</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_PSV — Temperature at which 
system will throttle CPU in order to cool system</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_LID — Status of the lid 
(open or closed)</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_PSR— Whether the machine 
running on AC </span></p>
<p class="Le"><span style="layout-grid-mode: line">&nbsp;</span></p>
<p class="MsoNormal"><span style="layout-grid-mode: line">The same applies for 
these method for Control Method Battery devices:</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_BIF — Battery information 
such as model, serial number, design capacity, last full charge capacity, 
technology, and battery capacity</span></p>
<p class="MsoListBullet">
<span style="font-family: Symbol; layout-grid-mode: line">·<span style="font-style: normal; font-variant: normal; font-weight: normal; font-size: 7.0pt; font-family: Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style="layout-grid-mode: line">_BST — Battery state, battery 
present rate, battery remaining capacity, and battery voltage present</span></p>
<p class="Le">&nbsp;</p>
<h2><a name="_Toc445868973"><span style="layout-grid-mode: line">ASL Sample Code 
for an Event and Initiating Method</span></a></h2>
<p class="MsoNormal"><span style="layout-grid-mode: line">The following ASL code 
implements an event and a method that can be called to initiate that event.</span></p>
<p class="Ex">Device(AMW0)</p>
<p class="Ex">{</p>
<p class="Ex">&nbsp;&nbsp; // pnp0c14 is Plug and Play ID assigned to WMI mapper</p>
<p class="Ex">&nbsp;&nbsp; Name(_HID, &quot;*pnp0c14&quot;)</p>
<p class="Ex">&nbsp;&nbsp; Name(_UID, 0x0)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp; // Description of data and events supported</p>
<p class="Ex">&nbsp;&nbsp; Name(_WDG, Buffer() {</p>
<p class="Ex" style="margin-right: -.75in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6a, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 66, 65,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID (BA)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_EXPENSIVE)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="margin-right: -.75in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6b, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 66, 66,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID (BB)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x02,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_METHOD)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="margin-right: -1.0in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6c, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xb0, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notification ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_EVENT)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Storage for the 3 instances of BA</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(STB0, Buffer(0x10) { </p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,0,0,0, 2,0,0,0, 3,0,0,0, 4,0,0,0</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(STB1, Buffer(0x10) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,1,0,0, 0,2,0,0, 0,3,0,0, 0,4,0,0</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(STB2, Buffer(0x10) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,1,0, 0,0,2,0, 0,0,3,0, 0,0,4,0</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Query data block</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Arg0 has the instance being queried</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WQBA, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 0)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(STB0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 1)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return(STB1)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 2)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(STB2)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; // Set Data Block</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; // Arg0 has the instance being 
queried</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; // Arg1 has the new value for 
the data block instance</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; Method(WSBA, 2) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (LEqual(Arg0, 0)) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Arg1, STB0)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 1)) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Arg1, STB1)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 2)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Arg1, STB2)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Storage for data block BB</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(B0ED, Buffer(0x10) { </p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,0,0,1, 0,0,0,2, 0,0,0,3, 0,0,0,4</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Method Execution</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Arg0 is instance being queried</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Arg1 is the method ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Arg2 is the method data passed</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WMBB, 3) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg1, 1))</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Arg3, B0ED)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Notify(AMW0, 0xB0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(Arg3)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(Arg1)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // More info about an event</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Arg0 is the event ID that was launched (“fired”)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(_WED, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 0xB0)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(B0ED)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">}</p>
<p class="Ex">&nbsp;</p>
<h2><a name="_Toc445868974">Sample ASL Code Embedding MOD Data in ASL</a></h2>
<p class="MsoNormal" style="page-break-after: avoid">The following&nbsp; sample ASL 
code shows another example of implementing an event mechanism using ASL code.&nbsp; 
It also provides an example of embedding MOF data into ASL.</p>
<p class="Ex" style="page-break-after: avoid">Device(AMW0)</p>
<p class="Ex" style="page-break-after: avoid">{</p>
<p class="Ex" style="page-break-after: avoid">//</p>
<p class="Ex" style="page-break-after: avoid">// pnp0c14 is the ID assigned by 
Microsoft to the WMI to ACPI mapper</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; Name(_HID, &quot;*pnp0c14&quot;)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; Name(_UID, 0x0)</p>
<p class="Ex" style="page-break-after: avoid">//</p>
<p class="Ex" style="page-break-after: avoid">// _WDG evaluates to a data 
structure that specifies the data blocks supported</p>
<p class="Ex" style="page-break-after: avoid">// by the ACPI device.</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -84.0pt">&nbsp;&nbsp; 
Name(_WDG, Buffer() {</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x5a, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65, 65,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID (AA)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags WMIACPI_REGFLAG_EXPENSIVE</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x5b, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65, 66,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID (AB)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x02,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags WMIACPI_REGFLAG_METHOD</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="margin-right: -78.0pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x5c, 0x0f, 0xBC, 0xAB, 0xa1, 
0x8e, 0xd1, 0x11, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0, 0,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xa0, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notification ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_EVENT)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">//</p>
<p class="Ex">// This <span style="layout-grid-mode: line">GUID</span> for 
returning the MOF data</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21, 0x12, 0x90, 0x05, 0x66, 
0xd5, 0xd1, 0x11, 0xb2, 0xf0, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 66, 65,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID (BA)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">//</p>
<p class="Ex">// Collection control method. If Arg0 is not zero then collection 
for the</p>
<p class="Ex">// data block is enabled. If Arg0 is zero then collection is 
disabled. If </p>
<p class="Ex">// this method does not exist then it is assumed that collection 
control is</p>
<p class="Ex">// not required. Collection control is only useful when collection 
of the </p>
<p class="Ex">// data block causes overhead.</p>
<p class="Ex">&nbsp;&nbsp; Method(WCAA, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, Zero)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Disable collection of data</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Enable collection of data</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">//</p>
<p class="Ex" style="page-break-after: avoid">// Query method for data block AA. 
Arg0 has the data block instance index</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; Method(WQAA, 1) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, Zero)) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Query is for first 
instance of data block</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0x10)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Query is for second 
instance of data block</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0x20)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">//</p>
<p class="Ex">// Set method for data block AA. If data block is read-only then 
this method</p>
<p class="Ex">// does not need to exist. Arg0 has the instance index of the data 
block,</p>
<p class="Ex">// Arg1 has the new value for the data block.</p>
<p class="Ex">&nbsp;&nbsp; Method(WSAA, 2) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, Zero)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set is for first instance of data block</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set is for second instance of data block</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">//</p>
<p class="Ex">// Event enable/disable method. If event does not need to be 
armed/disarmed</p>
<p class="Ex">// then this method is not needed. Arg0 is Zero if event is being 
disarmed or</p>
<p class="Ex">// non zero if event is being armed.</p>
<p class="Ex">&nbsp;&nbsp; Name(ACEN, 0)</p>
<p class="Ex">&nbsp;&nbsp; Method(WEA0, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Arg0, ACEN)</p>
<p class="Ex">&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">//</p>
<p class="Ex">// _WED is called in response to an event launching (“firing”) to 
gain additional </p>
<p class="Ex">// information about the event. Arg0 has the NotifyId for the 
event launched.</p>
<p class="Ex">&nbsp;&nbsp; Method(_WED, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 0xA0)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(0x100)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp; }</p>
<p class="Ex">//</p>
<p class="Ex">// Evaluation of this method causes the event 0xA0 to be fired. 
Since it is</p>
<p class="Ex">// defined by the _WDG method it is callable via WMI. Arg0 has the 
instance</p>
<p class="Ex">// index and Arg1 has any input parameters.</p>
<p class="Ex">&nbsp;&nbsp; Method(WMAB, 3) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If event was armed then launch it</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(ACEN, 1)) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Notify(AMW0, 0xa0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(Arg1)</p>
<p class="Ex">&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp; Name(WQBA, Buffer(926) {</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x46, 
0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x03, 0x00, 0x00, 0xf6, 0x0f, 
0x00, 0x00,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x44, 
0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x98, 0xdd, 0x87, 0x00, 0x01, 0x06, 
0x18, 0x42,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x10, 
0x0b, 0x10, 0x0a, 0x0b, 0x21, 0x02, 0xcb, 0x82, 0x50, 0x3c, 0x18, 0x14, 0xa0, 
0x25, 0x41,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xc8, 
0x05, 0x14, 0x55, 0x02, 0x21, 0xc3, 0x02, 0x14, 0x0b, 0x70, 0x2e, 0x40, 0xba, 
0x00, 0xe5,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x28, 
0x72, 0x0c, 0x22, 0x82, 0xfd, 0xfb, 0x07, 0xc1, 0x90, 0x02, 0x08, 0x29, 0x84, 
0x90, 0x08,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x58, 
0x2a, 0x04, 0x8d, 0x10, 0xf4, 0x2b, 0x00, 0xa1, 0x43, 0x01, 0x32, 0x05, 0x18, 
0x14, 0xe0,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x14, 
0x41, 0x04, 0x41, 0x62, 0x17, 0x2e, 0xc0, 0x34, 0x8c, 0x06, 0xd0, 0x36, 0x8a, 
0x64, 0x0b,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xb0, 
0x0c, 0x2e, 0x98, 0xa3, 0x08, 0x92, 0xa0, 0xc6, 0x09, 0xa0, 0xc4, 0x4c, 0x00, 
0xa5, 0x13,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x5c, 
0x36, 0x05, 0x58, 0xc4, 0x96, 0x50, 0x14, 0x0d, 0x22, 0x4a, 0x82, 0x13, 0xea, 
0x1b, 0x41,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x13, 
0x2a, 0x57, 0x80, 0x64, 0x78, 0x69, 0x1e, 0x81, 0xac, 0xcf, 0x41, 0x93, 0xf2, 
0x04, 0xb8,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x9a, 
0x05, 0x7a, 0x8c, 0x34, 0xff, 0x30, 0x41, 0x99, 0x14, 0x43, 0x0e, 0x20, 0x24, 
0x71, 0x98,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xa0, 
0x9d, 0x59, 0xed, 0x18, 0xd2, 0x3d, 0x07, 0x32, 0x4d, 0x60, 0x21, 0x70, 0x9e, 
0xb8, 0x19,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xa0, 
0xf0, 0x5b, 0x1d, 0x80, 0xe0, 0x2b, 0x1d, 0x15, 0xd2, 0xeb, 0x34, 0x64, 0x72, 
0x46, 0x48,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xf8, 
0xff, 0x7f, 0x02, 0x26, 0xe3, 0xb7, 0x60, 0x02, 0xa5, 0xd9, 0xb2, 0x82, 0x4b, 
0x80, 0xc1,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x68, 
0x00, 0x91, 0xa2, 0x69, 0xa3, 0xe6, 0xea, 0xf9, 0x36, 0x8f, 0xaf, 0x59, 0x7a, 
0x9e, 0x47,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x7a, 
0x34, 0x56, 0x36, 0x05, 0xd4, 0xf8, 0x3d, 0x9d, 0x93, 0xf3, 0x4c, 0x02, 0x1e, 
0x9c, 0x61,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x4e, 
0x87, 0x83, 0xf1, 0xb1, 0xb1, 0x51, 0x70, 0x74, 0x03, 0xb2, 0x31, 0x38, 0xc6, 
0xb0, 0xd1,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x73, 
0x39, 0x81, 0x47, 0x82, 0x43, 0x89, 0x7e, 0x0e, 0x6f, 0x00, 0x47, 0x17, 0xe3, 
0x04, 0xce,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x27, 
0xc1, 0x61, 0x06, 0x39, 0xe3, 0x33, 0xf4, 0x44, 0x2c, 0x68, 0xd6, 0x02, 0x0a, 
0x62, 0xa4,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x58, 
0xa7, 0xf5, 0x7c, 0x10, 0x8b, 0x41, 0x05, 0x8b, 0x11, 0xdb, 0x50, 0x87, 0x60, 
0x18, 0x8b,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x46, 
0x11, 0xc8, 0x49, 0x3c, 0x49, 0x30, 0x94, 0x40, 0x51, 0x0c, 0x12, 0xda, 0xc3, 
0x36, 0x92,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x81, 
0xcf, 0xdb, 0x20, 0xc7, 0x84, 0x51, 0x01, 0x21, 0xcf, 0xe3, 0xd0, 0x28, 0x4d, 
0xd0, 0xfd,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x29, 
0x40, 0x37, 0x8b, 0x08, 0x67, 0x54, 0xd8, 0x44, 0x64, 0x6d, 0x02, 0xb2, 0x25, 
0x40, 0x1c,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xbe, 
0x40, 0x1a, 0x43, 0x11, 0x44, 0x84, 0x98, 0x51, 0x8c, 0x19, 0x30, 0x82, 0x51, 
0x0e, 0xa6,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x39, 
0x10, 0x69, 0x13, 0x30, 0xf6, 0x20, 0xd1, 0x62, 0x31, 0x04, 0xdb, 0x9f, 0x83, 
0x30, 0x0e,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x05, 
0xa3, 0x03, 0x42, 0xe7, 0x84, 0xc3, 0x3b, 0x30, 0x9f, 0x1e, 0x4c, 0x70, 0xda, 
0xcf, 0x07,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xaf, 
0x0b, 0x21, 0x8b, 0x17, 0x20, 0x0d, 0x43, 0xf8, 0x09, 0x6a, 0x7d, 0x51, 0xe8, 
0x5a, 0xe0,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x34, 
0xe0, 0xa8, 0xeb, 0x82, 0x6f, 0x01, 0xbe, 0x01, 0x9c, 0xe0, 0xe3, 0x85, 0xf1, 
0x83, 0x1c,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xc1, 
0x01, 0x3c, 0x44, 0xbc, 0x1a, 0x78, 0x08, 0x9e, 0xc3, 0xfb, 0x05, 0x3b, 0x0f, 
0x60, 0xff,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xff, 
0x04, 0x5d, 0xe3, 0xe9, 0x92, 0x70, 0x02, 0x96, 0x83, 0x86, 0x1a, 0xac, 0x2f, 
0x00, 0x27,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xe9, 
0xc1, 0x1a, 0xae, 0xae, 0xd3, 0x06, 0x7a, 0xba, 0xa7, 0x72, 0x5a, 0xa5, 0x0a, 
0x30, 0x7b,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x94, 
0x20, 0x04, 0xcf, 0x1e, 0x6c, 0xde, 0x67, 0x73, 0xe6, 0x09, 0x9e, 0x14, 0x3c, 
0x05, 0x3e,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x2d, 
0xcf, 0xd2, 0x97, 0x0e, 0x5f, 0x09, 0x7c, 0x9f, 0x30, 0x41, 0xf4, 0x27, 0x17, 
0x36, 0x1a,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xb8, 
0xc3, 0xc6, 0x8d, 0x06, 0xce, 0xe5, 0xe0, 0xb1, 0xc3, 0x33, 0xf7, 0x5c, 0x4d, 
0x50, 0xf3,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xe5, 
0x42, 0x4e, 0x66, 0x83, 0xd2, 0x03, 0xa2, 0x01, 0x3f, 0x34, 0x60, 0xd0, 0x1f, 
0x19, 0xb8,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xc8, 
0x8b, 0x02, 0x95, 0x86, 0xac, 0xbf, 0x86, 0x45, 0x8d, 0x9b, 0x12, 0x58, 0xca, 
0xa1, 0x82,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xdc, 0x33, 0x7c, 0x9e, 0x38, 
0x8c, 0x57, 0x00, 0xcf, 0xe6, 0xa0, 0x7c, 0x73, 0x71, 0xba, 0x7b,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x05, 0x68, 0x66, 0x83, 0xbb, 
0x51, 0x80, 0x05, 0xc3, 0xd7, 0x03, 0xdf, 0x30, 0xd8, 0xf1, 0xc3,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xd7, 0x0c, 0x36, 0x24, 0x83, 
0x45, 0x89, 0x14, 0x9b, 0x4d, 0xca, 0x03, 0xc0, 0xe0, 0xbd, 0xd7,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xf8, 0x70, 0x61, 0x48, 0x9f, 
0x31, 0xe0, 0x1e, 0x05, 0xe0, 0xfd, 0xff, 0xcf, 0x09, 0xe0, 0xb8,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x6d, 0xf8, 0x2a, 0x62, 0x67, 
0xf7, 0x0b, 0x5d, 0x6f, 0xb0, 0xf7, 0x1d, 0x78, 0xf8, 0x87, 0x85,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xbb, 0x0b, 0x30, 0xb0, 0x13, 
0xc5, 0x1c, 0x78, 0x80, 0xc7, 0x64, 0x1e, 0x78, 0xc0, 0x75, 0x96,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x82, 0x3d, 0x04, 0xae, 0xfa, 
0xc0, 0x83, 0xca, 0xf1, 0x6a, 0xa0, 0x67, 0x1e, 0xc0, 0xec, 0xff,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xff, 0xcc, 0x03, 0x8c, 0xe0, 
0x9f, 0x79, 0x80, 0x6b, 0xf4, 0x6b, 0x81, 0xde, 0x57, 0x3e, 0xf3,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x00, 0x7c, 0x50, 0x79, 0x33, 
0x01, 0xcd, 0xff, 0xff, 0x66, 0x02, 0xe3, 0xe0, 0xe0, 0x83, 0x88,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xaf, 0x32, 0x3e, 0x11, 0x02, 
0x93, 0xab, 0x09, 0x70, 0x09, 0x79, 0x27, 0xa2, 0x01, 0x07, 0x41,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xaf, 0x01, 0x5c, 0x0b, 0x88, 
0x66, 0xc8, 0xa6, 0x89, 0x25, 0x98, 0xe5, 0x22, 0x40, 0xef, 0x8a,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x3e, 0x2a, 0xf1, 0x31, 0xfa, 
0xa8, 0xc4, 0x70, 0xdf, 0x85, 0x8c, 0x7b, 0x7a, 0x67, 0xf7, 0xac,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x84, 0xb9, 0x04, 0xbc, 0x8f, 
0x80, 0x65, 0xf2, 0xf8, 0xd3, 0x07, 0x47, 0xf4, 0x85, 0xc1, 0x77,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x23, 0x78, 0x04, 0xd5, 0x5f, 
0x65, 0xa8, 0xfe, 0xbd, 0x48, 0x2f, 0x0c, 0xea, 0x2a, 0x03, 0x5c,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xff, 0xff, 0x57, 0x19, 0x36, 
0xc8, 0x63, 0x05, 0xcb, 0xf9, 0x11, 0x33, 0xc7, 0xd3, 0x8c, 0xe2,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xa9, 0x78, 0xb8, 0xec, 0x62, 
0x65, 0xef, 0x53, 0x25, 0xc7, 0x17, 0x5f, 0xab, 0xf0, 0x20, 0x8f,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x31, 0xbe, 0xc3, 0x80, 0x71, 
0x04, 0xef, 0x30, 0xc0, 0x35, 0xf0, 0xcb, 0x41, 0xd7, 0x40, 0xc0,</p>
<p class="Ex" style="margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xf6, 0xff, 0xff, 0x0e, 0x03, 
0x96, 0xe0, 0x10, 0xba, 0x06, 0xe2, 0x64, 0x1c, 0x5b, 0xc8, 0x4d,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xca, 
0x53, 0x36, 0xc1, 0xa0, 0x13, 0xa6, 0x47, 0x40, 0xf0, 0xdc, 0x2b, 0x7c, 0x98, 
0x00, 0xc7,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x48, 
0x30, 0xe7, 0x08, 0x9f, 0x1f, 0x7c, 0x7d, 0x78, 0x93, 0x60, 0x37, 0x0e, 0xc3, 
0xf8, 0xca,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0x07, 
0x0f, 0xf2, 0x15, 0x8b, 0x5d, 0x26, 0xf8, 0x49, 0x0f, 0x6c, 0x17, 0x65, 0x70, 
0xdc, 0x7f,</p>
<p class="Ex" style="page-break-after: avoid; margin-right: -1.25in">&nbsp;&nbsp;&nbsp; 0xe0, 
0x5c, 0x94, 0x81, 0x11, 0xee, 0xe3, 0x0f, 0xf8, 0x0f, 0xcb, 0x70, 0xfe, 0xff</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;</p>
<h2><a name="_Toc445868975">Sample .Mof File</a></h2>
<p class="MsoNormal" style="page-break-after: avoid">This sample .mof file 
complements the previous ASL code.</p>
<p class="Ex" style="page-break-after: avoid">[abstract]</p>
<p class="Ex" style="page-break-after: avoid">class AcpiSampleBase</p>
<p class="Ex" style="page-break-after: avoid">{</p>
<p class="Ex" style="page-break-after: avoid">};</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">[abstract]</p>
<p class="Ex" style="page-break-after: avoid">class AcpiSampleEvent : WMIEvent</p>
<p class="Ex" style="page-break-after: avoid">{</p>
<p class="Ex" style="page-break-after: avoid">};</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">[Dynamic, Provider(&quot;WMIProv&quot;),</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;WMI,</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;Description(&quot;Counter for number 
of times the case has been hit&quot;),</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;<span style="layout-grid-mode: line">GUID</span>(&quot;{ABBC0f5a-8ea1-11d1-A000-c90629100000}&quot;),</p>
<p class="Ex">&nbsp;locale(&quot;MS\\0x409&quot;)]</p>
<p class="Ex">class MachineHitSensor : AcpiSampleBase</p>
<p class="Ex">{</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [key, read]</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; string InstanceName;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [read] Boolean Active;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [WmiDataId(1),</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; Description(&quot;Number of times the case sensor determined that 
the machine has been hit&quot;),</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; read</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; ] uint32 NumberTimesHit;</p>
<p class="Ex">};</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">[Dynamic, Provider(&quot;WMIProv&quot;),</p>
<p class="Ex">&nbsp;WMI,</p>
<p class="Ex">&nbsp;Description(&quot;Counter for number of times the case has been hit&quot;),</p>
<p class="Ex">&nbsp;<span style="layout-grid-mode: line">GUID</span>(&quot;{ABBC0f5b-8ea1-11d1-A000-c90629100000}&quot;),</p>
<p class="Ex">&nbsp;locale(&quot;MS\\0x409&quot;)]</p>
<p class="Ex">class MachineHitSimulate : AcpiSampleBase</p>
<p class="Ex">{</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [key, read]</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; string InstanceName;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [read] Boolean Active;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [WmiMethodId(1),</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; Description(&quot;Simulate hitting the machine&quot;)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; ] void HitMachine();</p>
<p class="Ex">};</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">[Dynamic, Provider(&quot;WMIProv&quot;),</p>
<p class="Ex">&nbsp;WMI,</p>
<p class="Ex">&nbsp;Description(&quot;Event generated when machine is hit&quot;),</p>
<p class="Ex">&nbsp;<span style="layout-grid-mode: line">GUID</span>(&quot;{ABBC0f5c-8ea1-11d1-A000-c90629100000}&quot;),</p>
<p class="Ex">&nbsp;locale(&quot;MS\\0x409&quot;)]</p>
<p class="Ex">class MachineHitEvent : AcpiSampleEvent</p>
<p class="Ex">{</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [key, read]</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; string InstanceName;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [read] Boolean Active;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; [WmiDataId(1),</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp; Description(&quot;Force with which the machine was hit&quot;)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; ] uint32 Force;</p>
<p class="Ex">};</p>
<p class="Ex">&nbsp;</p>
<p class="MsoNormal">Appendix C—ASL sample code</p>
<p class="Ex">Device(WMI1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name (_HID, EISAID(&quot;PNP0Cxx&quot;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Plug and Play ID for 
mapping driver (TBD)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; _UID(1)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Data block and Wmi method to Object ID mappings</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(_WDG, Buffer() {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object AA - {ABBC0F5A-8EA1-11d1-A53F-00A0C9062910}</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xABBC0F5A, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 
0x29, 0x10,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `A','A',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_STRING)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; </p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object AB - {ABBC0F5B-8EA1-11d1-A53F-00A0C9062910}</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xABBC0F5B, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 
0x29, 0x10,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `A','B',&nbsp;&nbsp;&nbsp; // Object ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flag (WMIACPI_REGFLAG_EXPENSIVE)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Object AC - {ABBC0F5C-8EA1-11d1-A53F-00A0C9062910}</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xABBC0F5C, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 
0x29, 0x10,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `A','C',&nbsp;&nbsp;&nbsp; // Object ID</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x06,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flag (WMIACPI_REGFLAG_METHOD | 
_STRING)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Event 0x80 - {ABBC0F5D-8EA1-11d1-A53F-00A0C9062910}</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xABBC0F5D, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 
0x29, 0x10,</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Notification value</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instance Count (Not meaningful for 
events)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;0x0D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags (WMIACPI_REGFLAG_EXPENSIVE | 
_STRING |_EVENT)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; })</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // IO ports for configuration of Object AB</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; OperationRegion(CAB0, SystemIo, 0xf8, 1)&nbsp;&nbsp; // Instance 0</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; OperationRegion(CAB1, SystemIo, 0xfc, 1)&nbsp;&nbsp; // Instance 1</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; OperationRegion(CABC, SystemIo, 0xf4, 1)&nbsp;&nbsp; // Enable/Disable 
Collection</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WQAB, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Read value from IO space for instance</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, Zero) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(CAB0, Local0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(CAB1, Local0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If any of the lower 3 bits are set then return TRUE, 
else FALSE</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (And(Local0, 7))</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return( 0x00000001 )</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return( 0x00000000 )</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Set the values for object AB</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WSAB, 2) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, Zero) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change contents of first instance of data block 
to </p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values in buffer in Arg1</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Change contents of second instance of data block 
to </p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // values in buffer in Arg1</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Collection notification for object AB</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WCAB, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(Arg0, 1)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(One, CABC)&nbsp;&nbsp;&nbsp;&nbsp; // If enable, write all 1's to 
port</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(Zero, CABC)&nbsp;&nbsp;&nbsp; // If disable, write all 0's to 
port</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Storage for maintaining values for the AA method. </p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(STAA, &quot;XYZZY&quot;)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WQAA, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Only one instance for AA so no need to check arg</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(STAA);</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Data block mapped to Object AA does not support set so it 
does not need</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // a WSAA method</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Storage for maintaining state of flag that determines 
whether to fire (launch)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // the event or not. By default firing is disabled</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Name(FIRE, 0)</p>
<p class="Ex">&nbsp;</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; // This method will reset the 
values for AA and send a notification of</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; // its occurrence</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp; Method(WMAC, 3) {</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(STAA, Local0)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(&quot;XYZZY&quot;, STAA)</p>
<p class="Ex" style="page-break-after: avoid">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LEqual(FIRE, 1))</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Notify(WMI1, 0x80)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return(Local0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Additional information about event</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(_WED) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(&quot;Fired&quot;)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">&nbsp;</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; //</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; // Event 0x80 Enable/Disable control method</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; Method(WE80, 1) {</p>
<p class="Ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Store(FIRE, Arg0)</p>
<p class="Ex">&nbsp;&nbsp;&nbsp; }</p>
<p class="Ex">)</p>
<p class="Ex">&nbsp;</p>
<p class="MsoNormal"><i>&nbsp;</i></p>
<p class="MsoNormal">&nbsp;</p>

</body>

</html>


```

`Drivers/Driver-SRC/wmi/wmiacpi/wmiacpi.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0
MinimumVisualStudioVersion = 12.0
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "acpimof", "acpimof.vcxproj", "{F346FBD0-9A67-4761-B670-BA329B8BC97E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Debug|Win32.ActiveCfg = Debug|Win32
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Debug|Win32.Build.0 = Debug|Win32
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Release|Win32.ActiveCfg = Release|Win32
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Release|Win32.Build.0 = Release|Win32
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Debug|x64.ActiveCfg = Debug|x64
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Debug|x64.Build.0 = Debug|x64
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Release|x64.ActiveCfg = Release|x64
		{F346FBD0-9A67-4761-B670-BA329B8BC97E}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Drivers/Driver-SRC/wmi/wmisamp/README.md`:

```md
---
page_type: sample
description: "Demonstrates how to register WMI providers in KMDF, create provider instances, and handle WMI queries sent to a device."
languages:
- cpp
products:
- windows
- windows-wdk
---

# Sample KMDF Driver Implementing a WMI Data Provider

WmiSamp WMI Provider is a sample KMDF driver that implements a WMI data provider.

## Universal Windows Driver Compliant

This sample builds a Universal Windows Driver. It uses only APIs and DDIs that are included in OneCoreUAP.

The sample demonstrates how to register the WMI providers and create provider instances for the Framework device object. It also illustrates how to handle the WMI queries sent to the device.

The **Firefly**, **PCIDRV**, and **Toaster** sample drivers also implement WMI data providers.

## Installation

In Visual Studio, you can press F5 to build the sample and then deploy it to a target machine. For more information, see [Deploying a Driver to a Test Computer](https://docs.microsoft.com/windows-hardware/drivers/develop/deploying-a-driver-to-a-test-computer).

> [!NOTE]
> You can obtain redistributable framework updates by downloading the *wdfcoinstaller.msi* package from [WDK 8 Redistributable Components](https://go.microsoft.com/fwlink/p/?LinkID=253170). This package performs a silent install into the directory of your Windows Driver Kit (WDK) installation. You will see no confirmation that the installation has completed. You can verify that the redistributables have been installed on top of the WDK by ensuring there is a redist\\wdf directory under the root directory of the WDK, %ProgramFiles(x86)%\\Windows Kits\\8.0.

## Testing

To test the WmiSamp driver, run the generated WmiSamp.vbs script file. This will cause WMI to query all data blocks and properties, and put the result in a .log file. For more sophisticated testing, the VBScript can be extended by hand. The WBEMTest tool (located in %windir%\\system32\\wbem\\) can also be used.

## WMI Mof Check Tool

WmiMofCk validates that the classes, properties, methods and events specified in a binary mof file (.bmf) are valid for use with WMI. It also generates useful output files needed to build and test the WMI data provider.

- If the -h parameter is specified, a C language header file is created that defines the GUIDs, data structures, and method indices specified in the MOF file.

- If the -t parameter is specified, a VBScript applet is created that will query all data blocks and properties specified in the .mof file. This can be useful for testing WMI data providers.

- If the -x parameter is specified, a text file is created that contains the text representation of the binary .mof data. This can be included in the source of the driver if the driver supports reporting the binary .mof via a WMI query rather than a resource on the driver image file.

- Usage: wmimofck -h\<C Header output file\> -x\<Hexdump output file\> -t\<VBScript test output file\> \<binary mof input file\>

> [!NOTE]
> A byproduct of compiling the .mof file is a .vbs file. This is a VBScript file that is run from the command line on the target machine running the new device driver. It will cause WMI to query all data blocks and properties, and put the results into a .log file. This can be very useful for testing WMI support in your driver. For more sophisticated testing, the VBScript can be extended by hand.

```

`Drivers/Driver-SRC/wmi/wmisamp/WmiHandler.c`:

```c
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
    EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    WmiHandler.c

Abstract:

    --

Environment:

    Kernel mode

--*/

#include "WmiSamp.h"

#define MOFRESOURCENAME L"MofResourceName"

//
// Private methods.
//

EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiClass1DataQueryInstance;
EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiClass2DataQueryInstance;
EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiClass3DataQueryInstance;
EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiClass5DataQueryInstance;
EVT_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiClass6DataQueryInstance;

EVT_WDF_WMI_INSTANCE_SET_ITEM EvtWmiClass1DataSetItem;

EVT_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiClass1DataSetInstance;
EVT_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiClass2DataSetInstance;
EVT_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiClass3DataSetInstance;
EVT_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiClass5DataSetInstance;
EVT_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiClass6DataSetInstance;

EVT_WDF_WMI_INSTANCE_EXECUTE_METHOD EvtWmiClass1ExecuteMethod;


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WmiSampWmiRegistration)

#pragma alloc_text (PAGE, EvtWmiClass1DataQueryInstance)
#pragma alloc_text (PAGE, EvtWmiClass1DataSetInstance)
#pragma alloc_text (PAGE, EvtWmiClass1DataSetItem)
#pragma alloc_text (PAGE, EvtWmiClass1ExecuteMethod)

#pragma alloc_text (PAGE, EvtWmiClass2DataQueryInstance)
#pragma alloc_text (PAGE, EvtWmiClass2DataSetInstance)

#pragma alloc_text (PAGE, EvtWmiClass3DataQueryInstance)
#pragma alloc_text (PAGE, EvtWmiClass3DataSetInstance)

#pragma alloc_text (PAGE, EvtWmiClass5DataQueryInstance)
#pragma alloc_text (PAGE, EvtWmiClass5DataSetInstance)

#pragma alloc_text (PAGE, EvtWmiClass6DataQueryInstance)
#pragma alloc_text (PAGE, EvtWmiClass6DataSetInstance)
#endif


//
// The SampleInstanceConfig defines an array of data set used for the creation
// of WMI instances.
//
WMI_SAMPLE_INSTANCE_CONFIG SampleInstanceConfig[] = {
    {
        WmiSampleClass1Guid,
        WmiSampleClass1_SIZE,
        EvtWmiClass1DataQueryInstance,
        EvtWmiClass1DataSetInstance,
        EvtWmiClass1DataSetItem,
        EvtWmiClass1ExecuteMethod
    },

    {
        WmiSampleClass2Guid,
        WmiSampleClass2_SIZE,
        EvtWmiClass2DataQueryInstance,
        EvtWmiClass2DataSetInstance,
        NULL,
        NULL
    },

    {
        WmiSampleClass5Guid,
        WmiSampleClass5_SIZE,
        EvtWmiClass5DataQueryInstance,
        EvtWmiClass5DataSetInstance,
        NULL,
        NULL
    },

    {
        WmiSampleClass6Guid,
        WmiSampleClass6_SIZE,
        EvtWmiClass6DataQueryInstance,
        EvtWmiClass6DataSetInstance,
        NULL,
        NULL
    },
};

//
// The DynamicInstanceConfig defines the data set used for the dynamic creation
// of WMI instances.
//

WMI_SAMPLE_INSTANCE_CONFIG DynamicInstanceConfig = {

        WmiSampleClass3Guid,
        WmiSampleClass3_SIZE,
        EvtWmiClass3DataQueryInstance,
        EvtWmiClass3DataSetInstance,
        NULL,
        NULL
};


NTSTATUS
WmiSampWmiRegistration(
    _In_ WDFDEVICE Device
    )

/*++

Routine Description:

    This function creates WMI provider instances for handling the WMI irps to
    the driver.

Arguments:

    Device - The Framework device object for which the WMI provider instances
        are to be created and registered. This device object will be the parent
        object of the new WMI instance objects.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status;
    ULONG i;
    WDF_WMI_PROVIDER_CONFIG providerConfig;
    WDF_WMI_INSTANCE_CONFIG instanceConfig;
    DECLARE_CONST_UNICODE_STRING(mofResourceName, MOFRESOURCENAME);

    PAGED_CODE();

    //
    // Register the MOF resource names of any customized WMI data providers
    // that are not defined in wmicore.mof.
    //
    status = WdfDeviceAssignMofResourceName(Device, &mofResourceName);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampWmiRegistration\n", status));
        return status;
    }

    //
    // Create a WMI instance object for each instance of each data block that
    // the driver supports for a device.
    //
    for (i = 0; i < ARRAYSIZE(SampleInstanceConfig); i++) {

        //
        // Initialize the config structures for the Provider and the Instance
        // and define event callback functions that support a WMI client's
        // requests to access the driver's WMI data blocks.
        //

        WDF_WMI_PROVIDER_CONFIG_INIT(&providerConfig, &SampleInstanceConfig[i].Guid);
        providerConfig.MinInstanceBufferSize = SampleInstanceConfig[i].MinSize;

        //
        // The WDFWMIPROVIDER handle is needed if multiple instances for the provider
        // has to be created or if the instances have to be created sometime after
        // the provider is created. In case below, the provider handle is not needed
        // because only one instance is needed and can be created when the provider
        // is created.
        //
        WDF_WMI_INSTANCE_CONFIG_INIT_PROVIDER_CONFIG(&instanceConfig, &providerConfig);

        //
        // Create a Provider object as part of the Instance creation call by setting
        // the Register value in the Instance Config to TRUE. This eliminates the
        // need to call WdfWmiProviderRegister.
        //
        instanceConfig.Register = TRUE;

        instanceConfig.EvtWmiInstanceQueryInstance = SampleInstanceConfig[i].EvtWmiInstanceQueryInstance;
        instanceConfig.EvtWmiInstanceSetInstance   = SampleInstanceConfig[i].EvtWmiInstanceSetInstance;
        instanceConfig.EvtWmiInstanceSetItem       = SampleInstanceConfig[i].EvtWmiInstanceSetItem;
        instanceConfig.EvtWmiInstanceExecuteMethod = SampleInstanceConfig[i].EvtWmiInstanceExecuteMethod;

        //
        // Create the WMI instance object for this data block.
        //
        status = WdfWmiInstanceCreate(Device,
                                      &instanceConfig,
                                      WDF_NO_OBJECT_ATTRIBUTES,
                                      WDF_NO_HANDLE);

        if (!NT_SUCCESS(status)) {

            DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampWmiRegistration\n", status));
            return status;
        }

    }

    return status;
}


NTSTATUS
WmiSampDynamicWmiRegistration(
    _In_ WDFDEVICE Device
    )

/*++

Routine Description:

    This function creates WMI provider instance if the dynamic instance does not
    already exist. If it does exist, this funciton deregisters and deletes the
    WMI instance. This function assumes that the mof has already been registered
    with the given Framework device object (by a previous call to WmiSampWmiRegistration).

Arguments:

    Device - The Framework device object for which a WMI provider instance
        has to be created if the instance does not exist or deleted if the
        instance exists.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;
    WDF_WMI_PROVIDER_CONFIG providerConfig;
    WDF_WMI_INSTANCE_CONFIG instanceConfig;

    wmiDeviceData = GetWmiSampleDeviceData(Device);

    //
    // If the dynamic provider already exists, then delete the dynamic provider
    // and all of its instances.
    //
    if (wmiDeviceData->DynamicInstance) {

        DebugPrint(("Delete Dynamic instance.\n"));

        //
        // Deregister the dynamic WMI Instance so that this instance does not
        // receive any more WMI query callbacks.
        //
        WdfWmiInstanceDeregister(wmiDeviceData->DynamicInstance);

        //
        // Delete the dynamic WMI Instance object.
        //
        WdfObjectDelete(wmiDeviceData->DynamicInstance);
        wmiDeviceData->DynamicInstance = NULL;

    } else {

        DebugPrint(("Create Dynamic instance.\n"));

        //
        // Initialize the config structures for the Provider and the Instance
        // and define event callback functions that support a WMI client's
        // requests to access the driver's WMI data blocks.
        //

        WDF_WMI_PROVIDER_CONFIG_INIT(&providerConfig, &DynamicInstanceConfig.Guid);
        providerConfig.MinInstanceBufferSize = DynamicInstanceConfig.MinSize;

        //
        // You would want to create a WDFWMIPROVIDER handle separately if you are
        // going to dynamically create instances on the provider. Since we are
        // statically creating one instance, there is no need to create the provider
        // handle.
        //
        WDF_WMI_INSTANCE_CONFIG_INIT_PROVIDER_CONFIG(&instanceConfig, &providerConfig);

        //
        // Create a Provider object as part of the Instance creation call by setting
        // the Register value in the Instance Config to TRUE. This eliminates the
        // need to call WdfWmiProviderRegister.
        //
        instanceConfig.Register = TRUE;

        instanceConfig.EvtWmiInstanceQueryInstance = DynamicInstanceConfig.EvtWmiInstanceQueryInstance;
        instanceConfig.EvtWmiInstanceSetInstance   = DynamicInstanceConfig.EvtWmiInstanceSetInstance;
        instanceConfig.EvtWmiInstanceSetItem       = DynamicInstanceConfig.EvtWmiInstanceSetItem;
        instanceConfig.EvtWmiInstanceExecuteMethod = DynamicInstanceConfig.EvtWmiInstanceExecuteMethod;

        //
        // Create the WMI instance object for this data block.
        //
        status = WdfWmiInstanceCreate(Device,
                                      &instanceConfig,
                                      WDF_NO_OBJECT_ATTRIBUTES,
                                      &(wmiDeviceData->DynamicInstance));

        if (!NT_SUCCESS(status)) {

            DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampDynamicWmiRegistration\n", status));
            return status;
        }

        //
        // Increment the Create count if the dynamic WMI Instance was created.
        //
        wmiDeviceData->CreateCount++;

    }

    return status;
}


NTSTATUS
EvtWmiClass1DataQueryInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG OutBufferSize,
    PVOID OutBuffer,
    PULONG BufferUsed
    )

/*++

Routine Description:

    This is the callback routine for the WMI Query irp on the Instance representing
    the sample class 1. This routine gets the current value for the data members
    of the sample class and copies it to the given output buffer. The sample class1
    is made up of the same parameters as the Embedded Class EC1.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    OutBufferSize - The size (in bytes) of the output buffer into which the
        instance data is to be copied.

    OutBuffer - Pointer to the output buffer.

    BufferUsed - Pointer to the location that receives the number of bytes that
        were copied into the output buffer.

Return Value:

    NT Status code.

--*/

{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain EC1.
    //
    *BufferUsed = WmiSampGetEc1(wmiDeviceData,
                                OutBuffer,
                                0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass1DataSetInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG InBufferSize,
    PVOID InBuffer
    )
{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    PAGED_CODE();

    //
    // InBufferSize is guaranteed to be at least WmiSampleClass1_SIZE
    // which in this case is EC1_SIZE.
    //
    UNREFERENCED_PARAMETER(InBufferSize);

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain EC1.
    //
    WmiSampSetEc1(wmiDeviceData,
                  InBuffer,
                  EC1_SIZE,
                  0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass1DataSetItem(
    WDFWMIINSTANCE WmiInstance,
    ULONG DataItemId,
    ULONG InBufferSize,
    PVOID InBuffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(WmiInstance);
    UNREFERENCED_PARAMETER(DataItemId);
    UNREFERENCED_PARAMETER(InBufferSize);
    UNREFERENCED_PARAMETER(InBuffer);

    return status;
}


NTSTATUS
EvtWmiClass1ExecuteMethod(
    WDFWMIINSTANCE WmiInstance,
    ULONG MethodId,
    ULONG InBufferSize,
    ULONG OutBufferSize,
    PVOID Buffer,
    PULONG BufferUsed
    )
{
    NTSTATUS status;
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    switch (MethodId) {
    case SetEC1:
        {
            if (InBufferSize >= EC1_SIZE) {

                WmiSampSetEc1(wmiDeviceData,
                              Buffer,
                              EC1_SIZE,
                              0);
                status = STATUS_SUCCESS;

            } else {

                status = STATUS_INVALID_PARAMETER_MIX;
                DebugPrint(("[WmiSamp] Status = 0x%08x, EvtWmiClass1ExecuteMethod\n", status));
            }
        }
        break;

    case DummyMethod:
        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_WMI_ITEMID_NOT_FOUND;
        DebugPrint(("[WmiSamp] Status = 0x%08x, EvtWmiClass1ExecuteMethod\n", status));
        break;
    }

    *BufferUsed = 0;
    return status;
}


NTSTATUS
EvtWmiClass2DataQueryInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG OutBufferSize,
    PVOID OutBuffer,
    PULONG BufferUsed
    )

/*++

Routine Description:

    This is the callback routine for the WMI Query irp on the Instance representing
    the sample class 2. This routine gets the current value for the data members
    of the sample class and copies it to the given output buffer. The sample class2
    contains an embedded class.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    OutBufferSize - The size (in bytes) of the output buffer into which the
        instance data is to be copied.

    OutBuffer - Pointer to the output buffer.

    BufferUsed - Pointer to the location that receives the number of bytes that
        were copied into the output buffer.

Return Value:

    NT Status code.

--*/

{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain (Embedded) EC1.
    //
    *BufferUsed = WmiSampGetEc1(wmiDeviceData,
                                OutBuffer,
                                0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass2DataSetInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG InBufferSize,
    PVOID InBuffer
    )
{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    PAGED_CODE();

    //
    // InBufferSize is guaranteed to be at least WmiSampleClass2_SIZE
    // which in this case is EC1_SIZE.
    //
    UNREFERENCED_PARAMETER(InBufferSize);

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain (Embedded) EC1.
    //
    WmiSampSetEc1(wmiDeviceData,
                  InBuffer,
                  EC1_SIZE,
                  0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass3DataQueryInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG OutBufferSize,
    PVOID OutBuffer,
    PULONG BufferUsed
    )

/*++

Routine Description:

    This is the callback routine for the WMI Query irp on the Instance representing
    the sample class 3. This routine gets the current value for the data members
    of the sample class and copies it to the given output buffer. The sample class3
    contains a fixed array of embedded class EC1.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    OutBufferSize - The size (in bytes) of the output buffer into which the
        instance data is to be copied.

    OutBuffer - Pointer to the output buffer.

    BufferUsed - Pointer to the location that receives the number of bytes that
        were copied into the output buffer.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status;
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;
    ULONG sizeNeeded;
    ULONG sizeUsed;
    ULONG i;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Fixed array of EC1.
    //
    sizeNeeded = 0;
    for (i = 0; i < EC1_COUNT; i++) {
        sizeNeeded += ALIGN_UP(wmiDeviceData->Ec1Length[i], PVOID);
    }

    if (OutBufferSize < sizeNeeded) {

        *BufferUsed = 0;
        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        *BufferUsed = 0;
        for (i = 0; i < EC1_COUNT; i++) {

            sizeUsed = WmiSampGetEc1(wmiDeviceData, OutBuffer, i);
            OutBuffer = Add2Ptr(OutBuffer, ALIGN_UP(sizeUsed, PVOID));
            *BufferUsed += sizeUsed;
        }
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
EvtWmiClass3DataSetInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG InBufferSize,
    PVOID InBuffer
    )

/*++

Routine Description:

    ---

Arguments:

    WmiInstance -
    InBufferSize -
    InBuffer -

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;
    ULONG i;
    PEC1 Ec1;

    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Fixed array of EC1.
    //
    Ec1 = (PEC1)InBuffer;
    for (i = 0; i < EC1_COUNT; i++) {

        if (InBufferSize >= EC1_SIZE) {

            WmiSampSetEc1(wmiDeviceData, Ec1, EC1_SIZE, i);
            InBufferSize -= EC1_SIZE;
            Ec1++;

        } else {

            status = STATUS_INVALID_PARAMETER_MIX;
            DebugPrint(("[WmiSamp] Status = 0x%08x, EvtWmiClass3DataSetInstance\n", status));
        }
    }
    return status;
}


NTSTATUS
EvtWmiClass5DataQueryInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG OutBufferSize,
    PVOID OutBuffer,
    PULONG BufferUsed
    )

/*++

Routine Description:

    This is the callback routine for the WMI Query irp on the Instance representing
    the sample class 5. This routine gets the current value for the data members
    of the sample class and copies it to the given output buffer. The sample class5
    contains an embedded class.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    OutBufferSize - The size (in bytes) of the output buffer into which the
        instance data is to be copied.

    OutBuffer - Pointer to the output buffer.

    BufferUsed - Pointer to the location that receives the number of bytes that
        were copied into the output buffer.

Return Value:

    NT Status code.

--*/

{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain (Embedded) EC2.
    //
    *BufferUsed = WmiSampGetEc2(wmiDeviceData,
                                OutBuffer,
                                0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass5DataSetInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG InBufferSize,
    PVOID InBuffer
    )
{
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    PAGED_CODE();

    //
    // InBufferSize is guaranteed to be at least WmiSampleClass5_SIZE
    // which in this case is EC2_SIZE.
    //
    UNREFERENCED_PARAMETER(InBufferSize);

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Plain (Embedded) EC2.
    //
    WmiSampSetEc2(wmiDeviceData,
                  InBuffer,
                  EC2_SIZE,
                  0);

    return STATUS_SUCCESS;
}


NTSTATUS
EvtWmiClass6DataQueryInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG OutBufferSize,
    PVOID OutBuffer,
    PULONG BufferUsed
    )

/*++

Routine Description:

    This is the callback routine for the WMI Query irp on the Instance representing
    the sample class 6. This routine gets the current value for the data members
    of the sample class and copies it to the given output buffer. The sample class6
    contains a fixed array of embedded class EC2.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    OutBufferSize - The size (in bytes) of the output buffer into which the
        instance data is to be copied.

    OutBuffer - Pointer to the output buffer.

    BufferUsed - Pointer to the location that receives the number of bytes that
        were copied into the output buffer.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status;
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;
    ULONG sizeNeeded;
    ULONG sizeUsed;
    ULONG i;

    UNREFERENCED_PARAMETER(OutBufferSize);
    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Fixed array of EC2.
    //
    sizeNeeded = 0;
    for (i = 0; i < EC2_COUNT; i++) {
        sizeNeeded += ALIGN_UP(wmiDeviceData->Ec2Length[i], PVOID);
    }

    if (OutBufferSize < sizeNeeded) {

        *BufferUsed = 0;
        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        *BufferUsed = 0;
        for (i = 0; i < EC2_COUNT; i++) {

            sizeUsed = WmiSampGetEc2(wmiDeviceData, OutBuffer, i);
            OutBuffer = Add2Ptr(OutBuffer, ALIGN_UP(sizeUsed, PVOID));
            *BufferUsed += sizeUsed;
        }
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
EvtWmiClass6DataSetInstance(
    WDFWMIINSTANCE WmiInstance,
    ULONG InBufferSize,
    PVOID InBuffer
    )

/*++

Routine Description:

    This is the callback routine for setting the WMI data provider's instance
    data supplied by a WMI client. This routine copies the data in the input
    buffer and updates the sample class6 data which contains a fixed array of
    embedded class EC2.

Arguments:

    WmiInstance - The handle to the WMI instance object.

    InBufferSize - The size (in bytes) of the input buffer from which the
        instance data is to be copied.

    InBuffer - Pointer to the input buffer.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    WDFDEVICE device;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;
    ULONG i;
    PEC2 Ec2;

    PAGED_CODE();

    device = WdfWmiInstanceGetDevice(WmiInstance);
    wmiDeviceData = GetWmiSampleDeviceData(device);

    //
    // Fixed array of EC2.
    //
    Ec2 = (PEC2)InBuffer;
    for (i = 0; i < EC2_COUNT; i++) {

        if (InBufferSize >= EC2_SIZE) {

            WmiSampSetEc2(wmiDeviceData, Ec2, EC2_SIZE, i);
            InBufferSize -= EC2_SIZE;
            Ec2++;

        } else {

            status = STATUS_INVALID_PARAMETER_MIX;
            DebugPrint(("[WmiSamp] Status = 0x%08x, EvtWmiClass6DataSetInstance\n", status));
        }
    }
    return status;
}

```

`Drivers/Driver-SRC/wmi/wmisamp/WmiSamp.rc`:

```rc
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
    EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    WmiSamp.rc

Abstract:

    --

Environment:

    Kernel mode

--*/

#include <windows.h>
#include <ntverp.h>

#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Framework Version of WMIFILT.sys"
#define VER_INTERNALNAME_STR        "wmisamp.sys"
#define VER_ORIGINALFILENAME_STR    "wmisamp.sys"

#include "common.ver"

MofResourceName MOFDATA wmisamp.bmf

```

`Drivers/Driver-SRC/wmi/wmisamp/WmiSamp.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{126FE1F4-434C-496A-A52B-400BBB74AC3B}</ProjectGuid>
    <RootNamespace>$(MSBuildProjectName)</RootNamespace>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <SampleGuid>{224F1D35-6CD5-408C-822A-A57A2BAABE53}</SampleGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>False</UseDebugLibraries>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>True</UseDebugLibraries>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <DriverType>KMDF</DriverType>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(IntDir)</OutDir>
  </PropertyGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
  </ImportGroup>
  <ItemGroup Label="WrappedTaskItems">
    <MofComp Include="wmisamp.mof">
      <WmiSyntaxCheck>true</WmiSyntaxCheck>
      <CreateBinaryMofFile>.\$(IntDir)\wmisamp.bmf</CreateBinaryMofFile>
    </MofComp>
    <Wmimofck Include=".\$(IntDir)\wmisamp.bmf">
      <GenerateStructureDefinitionsForMethodParameters>true</GenerateStructureDefinitionsForMethodParameters>
      <HeaderOutputFile>.\$(IntDir)\wmidata.h</HeaderOutputFile>
      <VBScriptTestOutputFile>.\$(IntDir)\wmisamp.vbs</VBScriptTestOutputFile>
      <HexdumpOutputFile>.\$(IntDir)\wmisamp.x</HexdumpOutputFile>
      <HtmlOutputDirectory>.\$(IntDir)\htm</HtmlOutputDirectory>
      <HtmlUIOutputDirectory>true</HtmlUIOutputDirectory>
    </Wmimofck>
  </ItemGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>WmiSamp</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>WmiSamp</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>WmiSamp</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>WmiSamp</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <ExceptionHandling>
      </ExceptionHandling>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="WmiHandler.c" />
    <ClCompile Include="WmiSamp.c" />
    <ResourceCompile Include="WmiSamp.rc" />
  </ItemGroup>
  <ItemGroup>
    <Inf Exclude="@(Inf)" Include="*.inx" />
    <FilesToPackage Include="$(TargetPath)" Condition="'$(ConfigurationType)'=='Driver' or '$(ConfigurationType)'=='DynamicLibrary'" />
  </ItemGroup>
  <ItemGroup>
    <None Exclude="@(None)" Include="*.txt;*.htm;*.html" />
    <None Exclude="@(None)" Include="*.ico;*.cur;*.bmp;*.dlg;*.rct;*.gif;*.jpg;*.jpeg;*.wav;*.jpe;*.tiff;*.tif;*.png;*.rc2" />
    <None Exclude="@(None)" Include="*.def;*.bat;*.hpj;*.asmx" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Exclude="@(ClInclude)" Include="*.h;*.hpp;*.hxx;*.hm;*.inl;*.xsd" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`Drivers/Driver-SRC/wmi/wmisamp/WmiSamp.vcxproj.Filters`:

```Filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx;*</Extensions>
      <UniqueIdentifier>{A35FAE4A-A10D-4F57-875A-870D11320AB3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
      <UniqueIdentifier>{EE71E8BF-130F-40AC-9AAF-550A55E7168B}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms;man;xml</Extensions>
      <UniqueIdentifier>{F1CEAE6E-F3C8-4CA5-A43C-133A6A38B446}</UniqueIdentifier>
    </Filter>
    <Filter Include="Driver Files">
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
      <UniqueIdentifier>{EDD02E0D-300A-45CC-A637-CC38CECCA39A}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <MofComp Include="wmisamp.mof">
      <Filter>Driver Files</Filter>
    </MofComp>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WmiHandler.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WmiSamp.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WmiSamp.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Drivers/Driver-SRC/wmi/wmisamp/wmisamp.c`:

```c
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
    EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    WmiSamp.c

Abstract:

    --

Environment:

    Kernel mode

--*/


#include "WmiSamp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, WmiSampEvtDeviceAdd)
#endif


//
// Define a tag for use by the memory allocation routines.
//
#define WMI_SAMPLE_TAG (ULONG)'SimW'


//
// Private methods.
//

NTSTATUS
PriStartNewPeriodicTimer(
    _In_ WDFDEVICE DeviceObject,
    _In_ ULONG TimeInMilliSeconds,
    _In_ PFN_WDF_TIMER CallbackFunction
    );


EVT_WDF_TIMER PriTimerCallback;


NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    WDF_DRIVER_CONFIG config;

    //
    // Initialize the Driver Config structure.
    //
    WDF_DRIVER_CONFIG_INIT(&config,
                           WmiSampEvtDeviceAdd);

    //
    // Create the Framework Driver object.
    //
    status = WdfDriverCreate(DriverObject,
                             RegistryPath,
                             WDF_NO_OBJECT_ATTRIBUTES,
                             &config,
                             WDF_NO_HANDLE);
    return status;
}


NTSTATUS
WmiSampEvtDeviceAdd(
    WDFDRIVER DriverObject,
    PWDFDEVICE_INIT DeviceInit
    )
{
    NTSTATUS status;
    WDFDEVICE deviceObject;
    WDF_OBJECT_ATTRIBUTES wdfObjAttributes;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    ULONG i;
    ULONG oneMinute = 60*1000;
    EC1 Ec1 = {0};
    EC2 Ec2 = {0};

    UNREFERENCED_PARAMETER(DriverObject);

    PAGED_CODE();

    //
    // Initialize all the properties specific to the device. Default values are
    // set for the ones that are not set explicitly here.
    //
    WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_UNKNOWN);
    WdfDeviceInitSetExclusive(DeviceInit, TRUE);

    //
    // Initialize attributes structure.
    //
    WDF_OBJECT_ATTRIBUTES_INIT(&wdfObjAttributes);

    //
    // Specify the context type for the WDF device object.
    //
    WDF_OBJECT_ATTRIBUTES_SET_CONTEXT_TYPE(&wdfObjAttributes, WMI_SAMPLE_DEVICE_DATA);

    //
    // Specify the callback function for cleaning up the WDF device object specific
    // memory allocations.
    //
    wdfObjAttributes.EvtDestroyCallback = WmiSampDeviceEvtDestroyCallback;

    //
    // Create a Framework Device object.
    //
    status = WdfDeviceCreate(&DeviceInit, &wdfObjAttributes, &deviceObject);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampEvtDeviceAdd\n", status));
        return status;
    }

    //
    // Get the Device Object context and initialize the data blocks with specific
    // data.
    //
    wmiDeviceData = GetWmiSampleDeviceData(deviceObject);
    wmiDeviceData->Ec1Count = EC1_COUNT;
    wmiDeviceData->Ec2Count = EC2_COUNT;

    //
    // Create a wdf spin lock object to protect access to the EC1 data and parent
    // the object to the device object.
    //
    WDF_OBJECT_ATTRIBUTES_INIT(&wdfObjAttributes);
    wdfObjAttributes.ParentObject = deviceObject;

    status = WdfSpinLockCreate(&wdfObjAttributes, &wmiDeviceData->Ec1Lock);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampEvtDeviceAdd\n", status));
        return status;
    }

    //
    // Create a wdf spin lock object to protect access to the EC2 data and parent
    // the object to the device object.
    //
    status = WdfSpinLockCreate(&wdfObjAttributes, &wmiDeviceData->Ec2Lock);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampEvtDeviceAdd\n", status));
        return status;
    }

    for (i = 0; i < EC1_COUNT; i++) {
        WmiSampSetEc1(wmiDeviceData,
                      &Ec1,
                      EC1_SIZE,
                      i);
    }

    for (i = 0; i < EC2_COUNT; i++) {
        WmiSampSetEc2(wmiDeviceData,
                      &Ec2,
                      EC2_SIZE,
                      i);
    }

    //
    // Register the WMI providers and create provider instances for this Framework
    // device object.
    //
    status = WmiSampWmiRegistration(deviceObject);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampEvtDeviceAdd\n", status));
        return status;
    }

    //
    // Start a periodic timer to dynamically initialize/uninitialize WMI providers
    // for this device object.
    //
    status = PriStartNewPeriodicTimer(deviceObject, oneMinute, PriTimerCallback);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, WmiSampEvtDeviceAdd\n", status));
        return status;
    }

    return status;
}


VOID
WmiSampDeviceEvtDestroyCallback(
    WDFOBJECT DeviceObject
    )

/*++

Routine Description:

    This callback function is called by the framework when the reference count
    on the WDF device object is zero and the framework is ready to release the
    resouces held by this object. All object specific resource allocations that
    were NOT made by the framework must be released here to avoid a resource
    leak.

Arguments:

    DeviceObject - The WDF device object that is about to be destroyed by the
        framework.

Return Value:

    VOID.

--*/

{
    ULONG index;
    PWMI_SAMPLE_DEVICE_DATA wmiDeviceData;

    wmiDeviceData = GetWmiSampleDeviceData((WDFDEVICE)DeviceObject);

    //
    // Release the memory allocated for EC1. The wdfspinlock Ec1Lock memory
    // will be released automatically by the framework as part of the device
    // object cleanup.
    //
    for (index = 0; index < EC1_COUNT; index++) {
        if (wmiDeviceData->Ec1[index] != NULL) {
            ExFreePool(wmiDeviceData->Ec1[index]);
            wmiDeviceData->Ec1[index] = NULL;
        }
    }

    //
    // Release the memory allocated for EC2. The wdfspinlock Ec2Lock memory
    // will be released automatically by the framework as part of the device
    // object cleanup.
    //
    for (index = 0; index < EC2_COUNT; index++) {
        if (wmiDeviceData->Ec2[index] != NULL) {
            ExFreePool(wmiDeviceData->Ec2[index]);
            wmiDeviceData->Ec2[index] = NULL;
        }
    }

    return;
}


_Success_(return > 0)
ULONG
WmiSampGetEc1(
    _In_    PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _Out_ PVOID Buffer,
    _In_    ULONG Index
    )
{
    ULONG ec1Length = 0;
    if (Index >= EC1_COUNT) {
        return ec1Length;
    }

    //
    // Acquire the lock to protect access to the EC1 data since multiple
    // threads could be trying to access the common data concurrently.
    //
    WdfSpinLockAcquire(WmiDeviceData->Ec1Lock);

    RtlCopyMemory(Buffer,
                  WmiDeviceData->Ec1[Index],
                  WmiDeviceData->Ec1Length[Index]);

    ec1Length = WmiDeviceData->Ec1Length[Index];

    //
    // Release the lock.
    //
    WdfSpinLockRelease(WmiDeviceData->Ec1Lock);

    return ec1Length;
}


VOID
WmiSampSetEc1(
    _In_ PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG Index
    )
{
    PEC1 ec1;
    ULONG ec1Length = ALIGN_UP(Length, PVOID);
    PVOID oldBuffer = NULL;

    if (Index >= EC1_COUNT) {
        return;
    }

    ec1 = ExAllocatePoolWithTag(NonPagedPoolNx, ec1Length, WMI_SAMPLE_TAG);
    if (ec1 != NULL) {

        RtlCopyMemory(ec1, Buffer, Length);

        //
        // Acquire the lock to protect access to the EC1 data since multiple
        // threads could be trying to access the common data concurrently.
        //
        WdfSpinLockAcquire(WmiDeviceData->Ec1Lock);

        oldBuffer = WmiDeviceData->Ec1[Index];
        WmiDeviceData->Ec1[Index] = ec1;
        WmiDeviceData->Ec1Length[Index] = ec1Length;
        WmiDeviceData->Ec1ActualLength[Index] = Length;

        //
        // Release the lock.
        //
        WdfSpinLockRelease(WmiDeviceData->Ec1Lock);

        if (oldBuffer != NULL) {
            ExFreePool(oldBuffer);
        }
    }

    return;
}


_Success_(return > 0)
ULONG
WmiSampGetEc2(
    _In_    PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _Out_ PVOID Buffer,
    _In_    ULONG Index
    )
{
    ULONG ec2Length = 0;
    if (Index >= EC2_COUNT) {
        return ec2Length;
    }

    //
    // Acquire the lock to protect access to the EC2 data since multiple
    // threads could be trying to access the common data concurrently.
    //
    WdfSpinLockAcquire(WmiDeviceData->Ec2Lock);

    RtlCopyMemory(Buffer,
                  WmiDeviceData->Ec2[Index],
                  WmiDeviceData->Ec2Length[Index]);

    ec2Length = WmiDeviceData->Ec2Length[Index];

    //
    // Release the lock.
    //
    WdfSpinLockRelease(WmiDeviceData->Ec2Lock);

    return ec2Length;
}


VOID
WmiSampSetEc2(
    _In_ PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG Index
    )
{
    PEC2 ec2;
    ULONG ec2Length = ALIGN_UP(Length, PVOID);
    PVOID oldBuffer = NULL;

    if (Index >= EC2_COUNT) {
        return;
    }

    ec2 = ExAllocatePoolWithTag(NonPagedPoolNx, ec2Length, WMI_SAMPLE_TAG);
    if (ec2 != NULL) {

        RtlCopyMemory(ec2, Buffer, Length);

        //
        // Acquire the lock to protect access to the EC2 data since multiple
        // threads could be trying to access the common data concurrently.
        //
        WdfSpinLockAcquire(WmiDeviceData->Ec2Lock);

        oldBuffer = WmiDeviceData->Ec2[Index];
        WmiDeviceData->Ec2[Index] = ec2;
        WmiDeviceData->Ec2Length[Index] = ec2Length;
        WmiDeviceData->Ec2ActualLength[Index] = Length;

        //
        // Release the lock.
        //
        WdfSpinLockRelease(WmiDeviceData->Ec2Lock);

        if (oldBuffer != NULL) {
            ExFreePool(oldBuffer);
        }
    }

    return;
}


NTSTATUS
PriStartNewPeriodicTimer(
    _In_ WDFDEVICE DeviceObject,
    _In_ ULONG TimeInMilliSeconds,
    _In_ PFN_WDF_TIMER CallbackFunction
    )

/*++

Routine Description:

    This function creates a new Framework timer object and sets it to fire
    periodically at that specifed time interval.

Arguments:

    DeviceObject - The Framework device object for which the new timer is to be
        created. This device object will be the parent object of the new timer
        object.

    TimeInMilliSeconds - The intervals at which the timer should fire.

    CallbackFunction - The function that needs to get invoked each time the timer
        is fired.

Return Value:

    NT Status code.

--*/

{
    NTSTATUS status;
    WDFTIMER timerObject;
    WDF_TIMER_CONFIG config;
    WDF_OBJECT_ATTRIBUTES attributes;

    //
    // Configure the timer to periodically fire.
    //
    WDF_TIMER_CONFIG_INIT_PERIODIC(&config, CallbackFunction, TimeInMilliSeconds);
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);

    //
    // Set the parent object of the timer as the given device object. This causes
    // the timer object to get cleaned up (destroyed) whenever the device object
    // gets destroyed.
    //
    attributes.ParentObject = DeviceObject;

    //
    // Create and start a new Framework timer object.
    //
    status = WdfTimerCreate(&config, &attributes, &timerObject);
    if (!NT_SUCCESS(status)) {

        DebugPrint(("[WmiSamp] Status = 0x%08x, PriStartNewPeriodicTimer\n", status));
        return status;
    }

    WdfTimerStart(timerObject, WDF_REL_TIMEOUT_IN_MS(TimeInMilliSeconds));

    return status;
}


VOID
PriTimerCallback(
    _In_ WDFTIMER Timer
    )

/*++

Routine Description:

    This is the callback function that gets invoked whenever the timer fires.
    The Dynamic WMI registration function is called from this callback function.

Arguments:

    Timer - The Framework timer object that was fired.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    WDFDEVICE deviceObject;

    //
    // Get the parent object for this timer. While creating the timer object, the
    // device object was specified as the parent object for the timer.
    //
    deviceObject = WdfTimerGetParentObject(Timer);

    //
    // Perform the dynamic WMI registration.
    //
    status = WmiSampDynamicWmiRegistration(deviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint(("[WmiSamp] Status = 0x%08x, PriTimerCallback\n", status));
    }

}

```

`Drivers/Driver-SRC/wmi/wmisamp/wmisamp.h`:

```h
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
    EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    WmiSamp.h

Abstract:

    --

Environment:

    Kernel mode

--*/

#include <ntddk.h>
#include <wdf.h>

#include <initguid.h>   // required for GUID definitions
#include <wdmguid.h>    // required for WMILIB_CONTEXT
#include <wmistr.h>
#include <wmilib.h>
#include "WmiData.h"


//
// A macro for Pointer addition.
//
#define Add2Ptr(P,I)    ((PVOID)((PUCHAR)(P) + (I)))


//
// Define DebugPrint for sending messages to the debugger in checked builds.
//
#if DBG
#define DebugPrint      KdPrint
#else
#define DebugPrint
#endif


typedef struct _WMI_SAMPLE_INSTANCE_CONFIG {

    GUID Guid;
    ULONG MinSize;
    PFN_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiInstanceQueryInstance;
    PFN_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiInstanceSetInstance;
    PFN_WDF_WMI_INSTANCE_SET_ITEM EvtWmiInstanceSetItem;
    PFN_WDF_WMI_INSTANCE_EXECUTE_METHOD EvtWmiInstanceExecuteMethod;

} WMI_SAMPLE_INSTANCE_CONFIG, *PWMI_SAMPLE_INSTANCE_CONFIG;


#define EC1_COUNT       4
#define EC2_COUNT       4

//
// Data storage for WMI data blocks.
//
typedef struct _WMI_SAMPLE_DEVICE_DATA {

    ULONG Ec1Count;
    ULONG Ec1Length[EC1_COUNT];
    ULONG Ec1ActualLength[EC1_COUNT];
    PEC1 Ec1[EC1_COUNT];
    WDFSPINLOCK Ec1Lock;

    ULONG Ec2Count;
    ULONG Ec2Length[EC2_COUNT];
    ULONG Ec2ActualLength[EC2_COUNT];
    PEC2 Ec2[EC2_COUNT];
    WDFSPINLOCK Ec2Lock;

    WDFWMIINSTANCE DynamicInstance;
    ULONG CreateCount;

} WMI_SAMPLE_DEVICE_DATA, *PWMI_SAMPLE_DEVICE_DATA;


//
// Specify an accessor method for the WMI_SAMPLE_DEVICE_DATA structure.
//
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(WMI_SAMPLE_DEVICE_DATA, GetWmiSampleDeviceData)


DRIVER_INITIALIZE DriverEntry;

EVT_WDF_DRIVER_DEVICE_ADD WmiSampEvtDeviceAdd;
EVT_WDF_DEVICE_CONTEXT_DESTROY WmiSampDeviceEvtDestroyCallback;

NTSTATUS
WmiSampWmiRegistration(
    _In_ WDFDEVICE Device
    );

NTSTATUS
WmiSampDynamicWmiRegistration(
    _In_ WDFDEVICE Device
    );

_Success_(return > 0)
ULONG
WmiSampGetEc1(
    _In_    PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _Out_ PVOID Buffer,
    _In_    ULONG Index
    );

VOID
WmiSampSetEc1(
    _In_ PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG Index
    );

_Success_(return > 0)
ULONG
WmiSampGetEc2(
    _In_    PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _Out_ PVOID Buffer,
    _In_    ULONG Index
    );

VOID
WmiSampSetEc2(
    _In_ PWMI_SAMPLE_DEVICE_DATA WmiDeviceData,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG Index
    );


```

`Drivers/Driver-SRC/wmi/wmisamp/wmisamp.inx`:

```inx
;;
;; Copyright (c) Microsoft Corporation.  All rights reserved.
;;
;;     THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
;;     EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
;;     WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
;;
;; Module Name:
;;
;;     WmiSamp.inf
;;
;; Abstract:
;;
;;     --
;;

[Version]
Signature   = "$WINDOWS NT$"
Class       = Sample
ClassGUID   = {78A1C341-4539-11D3-B88D-00C04FAD5171}
Provider    = %ProviderString%
DriverVer   = 10/29/2005,1.0.0.1
CatalogFile = KmdfSamples.cat

[DestinationDirs]
DefaultDestDir      = 12
WmiSamp_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskId1%,,,""

[SourceDisksFiles]
WmiSamp.sys = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll = 1                     ; make sure the number matches with SourceDisksNames

;;
;; Class Install section for "Sample" class.
;;

[ClassInstall32]
Addreg      = SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

;;
;; WmiSamp Install Section.
;;

[Manufacturer]
%StdMfg%    = Standard,NT$ARCH$

[Standard.NT$ARCH$]
%WmiSamp.DeviceDesc% = WmiSamp_Device, root\WmiSamp

[WmiSamp_Device.NT]
CopyFiles   = Drivers_Dir

[WmiSamp_Device.NT.HW]
AddReg      = WmiSamp_Device.NT.AddReg

[WmiSamp_Device.NT.AddReg]
HKR,,DeviceCharacteristics,0x10001,0x0100       ; Use same security checks on relative opens
HKR,,Security,,"D:P(A;;GA;;;BA)(A;;GA;;;SY)"    ; Allow generic-all access to Built-in administrators and Local system

[Drivers_Dir]
WmiSamp.sys

;;
;; Service installation.
;;

[WmiSamp_Device.NT.Services]
AddService  = WmiSamp,%SPSVCINST_ASSOCSERVICE%, WmiSamp_Service_Inst

;;
;; WmiSamp driver install sections.
;;

[WmiSamp_Service_Inst]
DisplayName    = %WmiSamp.SVCDESC%
ServiceType    = 1                              ; SERVICE_KERNEL_DRIVER
StartType      = 3                              ; SERVICE_DEMAND_START
ErrorControl   = 1                              ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\WmiSamp.sys

;;
;; WmiSamp_Device Coinstaller installation
;;

[WmiSamp_Device.NT.CoInstallers]
AddReg      = WmiSamp_Device_CoInstaller_AddReg
CopyFiles   = WmiSamp_Device_CoInstaller_CopyFiles

[WmiSamp_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[WmiSamp_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[WmiSamp_Device.NT.Wdf]
KmdfService = WmiSamp, WmiSamp_wdfsect

[WmiSamp_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE  = 0x00000002
ProviderString          = "TODO-Set-Provider"
StdMfg                  = "(Standard system devices)"
ClassName               = "Sample Device"
DiskId1                 = "WMI Sample Installation Disk #1"
WmiSamp.DeviceDesc      = "WMI Sample Driver"
WmiSamp.SVCDESC         = "WMI Sample Driver"

```

`Drivers/Driver-SRC/wmi/wmisamp/wmisamp.mof`:

```mof
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
    EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    WmiSamp.mof

Abstract:

    ---

--*/

#pragma autorecover

//
// Define EC1 and EC2 as embedded classes. Embedded classes are structures
// that are used within other classes.
//
[WMI,
 Locale("MS\\0x409"),
 HeaderName("EC1"),
 DisplayName("Embedded Class 1") : amended,
 Description("Description of embedded class 1") : amended,
 guid("{A1C15015-B069-11d1-9290-00A0C9062910}")]
class Vendor_EC1
{
    [WmiDataId(1),
     read, write,
     DisplayName("BOOLEAN") : amended,
     Description("boolean data") : amended]
    boolean Xboolean;

    [WmiDataId(2),
     read, write,
     DisplayName("UCHAR") : amended,
     Description("unsigned character data") : amended]
    uint8 Xuint8;

    [WmiDataId(3),
     read, write,
     DisplayName("USHORT") : amended,
     Description("unsigned short data") : amended]
    uint16 Xuint16;

    [WmiDataId(4),
     read, write,
     DisplayName("ULONG") : amended,
     Description("unsigned long data") : amended]
    uint32 Xuint32;

    [WmiDataId(5),
     read, write,
     WmiDisplayInHex,
     DisplayName("ULONGLONG") : amended,
     Description("unsigned long long data") : amended]
    uint64 Xuint64;

    [WmiDataId(6),
     read, write,
     DisplayName("CHAR") : amended,
     Description("signed byte data") : amended]
    sint8 Xint8;

    [WmiDataId(7),
     read, write,
     DisplayName("SHORT") : amended,
     Description("singed short data") : amended]
    sint16 Xint16;

    [WmiDataId(8),
     read, write,
     DisplayName("LONG") : amended,
     Description("singed long data") : amended]
    sint32 Xint32;

    [WmiDataId(9),
     read, write,
     WmiDisplayInHex,
     DisplayName("LONGLONG") : amended,
     Description("signed long long data") : amended]
    sint64 Xint64;
};


[WMI,
 Locale("MS\\0x409"),
 HeaderName("EC2"),
 DisplayName("Embedded Class 2"),
 Description("Description of embedeed class 2") : amended,
 guid("{A1C15016-B069-11d1-9290-00A0C9062910}")]
class Vendor_EC2
{
    [WmiDataId(1),
     read, write,
     DisplayName("Boolean Array") : amended,
     Description("Fixed length array of 8 booleans") : amended]
    boolean Xboolean[8];

    [WmiDataId(2),
     read, write,
     DisplayName("UCHAR Array") : amended,
     Description("Fixed length array of 8 unsigned characters") : amended]
    uint8 Xuint8[8];

    [WmiDataId(3),
     read, write,
     DisplayName("USHORT Array") : amended,
     Description("Fixed length array of 4 unsigned shorts") : amended]
    uint16 Xuint16[4];

    [WmiDataId(4),
     read, write,
     DisplayName("ULONG Array") : amended,
     Description("Fixed length array of 2 usingned long") : amended]
    uint32 Xuint32[2];

    [WmiDataId(5),
     read, write,
     WmiDisplayInHex,
     DisplayName("ULONGLONG Array") : amended,
     Description("Unsigned long long") : amended]
    uint64 Xuint64;

    [WmiDataId(6),
     read, write,
     DisplayName("CHAR Array") : amended,
     Description("Fixed length array of 8 signed characters") : amended]
    sint8 Xint8[8];

    [WmiDataId(7),
     read, write,
     DisplayName("SHORT Array") : amended,
     Description("Fixed length array of 4 signed short") : amended]
    sint16 Xint16[4];

    [WmiDataId(8),
     read, write,
     DisplayName("LONG Array") : amended,
     Description("Fixed length array of 2 signed long") : amended]
    sint32 Xint32[2];

    [WmiDataId(9),
     read, write,
     WmiDisplayInHex,
     DisplayName("LONGLONG Array") : amended,
     Description("Signed long long") : amended]
    sint64 Xint64;
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Description("Description of sample class 1") : amended,
 DisplayName("Sample Class 1") : amended,
 Locale("MS\\0x409"),
 guid("{15D851F1-6539-11d1-A529-00A0C9062910}")]
class WmiSampleClass1
{
    [key, read]
    string InstanceName;

    [read]
    boolean Active;

    [WmiDataId(1),
     read, write,
     DisplayName("BOOLEAN") : amended,
     Description("boolean data") : amended]
    boolean Xboolean;

    [WmiDataId(2),
     read, write,
     DisplayName("UCHAR") : amended,
     Description("unsigned character data") : amended]
    uint8 Xuint8;

    [WmiDataId(3),
     read, write,
     DisplayName("USHORT") : amended,
     Description("unsigned short data") : amended]
    uint16 Xuint16;

    [WmiDataId(4),
     read, write,
     DisplayName("ULONG") : amended,
     Description("unsigned long data") : amended]
    uint32 Xuint32;

    [WmiDataId(5),
     read, write,
     WmiDisplayInHex,
     DisplayName("ULONGLONG") : amended,
     Description("unsigned long long data") : amended]
    uint64 Xuint64;

    [WmiDataId(6),
     read, write,
     DisplayName("CHAR") : amended,
     Description("signed byte data") : amended]
    sint8 Xint8;

    [WmiDataId(7),
     read, write,
     DisplayName("SHORT") : amended,
     Description("singed short data") : amended]
    sint16 Xint16;

    [WmiDataId(8),
     read, write,
     DisplayName("LONG") : amended,
     Description("singed long data") : amended]
    sint32 Xint32;

    [WmiDataId(9),
     read, write,
     WmiDisplayInHex,
     DisplayName("LONGLONG") : amended,
     Description("signed long long data") : amended]
    sint64 Xint64;

    [Implemented,
     Description("Change the contents of EC1") : amended,
     WmiMethodId(1)]
    void SetEC1([in] boolean Xboolean,
                [in] uint8 Xuint8,
                [in] uint16 Xuint16,
                [in] uint32 Xuint32,
                [in] uint64 Xuint64,
                [in] sint8 Xint8,
                [in] sint16 Xint16,
                [in] sint32 Xint32,
                [in] sint64 Xint64);

    [Implemented,
     Description("Dummy method") : amended,
     WmiMethodId(2)]
    void DummyMethod();
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Description("Description of Sample Class 2") : amended,
 DisplayName("Sample Class 2") : amended,
 Locale("MS\\0x409"),
 guid("{15D851F2-6539-11d1-A529-00A0C9062910}")]
class WmiSampleClass2
{
    [key, read]
    string InstanceName;

    [read]
    boolean Active;

    [WmiDataId(1),
     read, write,
     DisplayName("Data") : amended,
     Description("Embedded class data") : amended]
    Vendor_EC1 EmbeddedClass1;
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Description("Description of Sample Class 3") : amended,
 DisplayName("Sample Class 3") : amended,
 Locale("MS\\0x409"),
 guid("{15D851F3-6539-11d1-A529-00A0C9062910}")]
class WmiSampleClass3
{
    [key, read]
    string InstanceName;

    [read]
    boolean Active;

    [WmiDataId(1),
     read, write,
     DisplayName("Data") : amended,
     Description("Fixed length array of 4 embedded classes") : amended]
    Vendor_EC1 EmbeddedClass1[4];
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 DisplayName("Sample Class 5") : amended,
 Description("Description of Sample Class 5") : amended,
 Locale("MS\\0x409"),
 guid("{15D851F5-6539-11d1-A529-00A0C9062910}")]
class WmiSampleClass5
{
    [key, read]
    string InstanceName;

    [read]
    boolean Active;

    [WmiDataId(1),
     read, write,
     DisplayName("Data") : amended,
     Description("Embedded class data") : amended]
    Vendor_EC2 EmbeddedClass2;
};


[WMI,
 Dynamic,
 Provider("WmiProv"),
 Description("Description of Sample Class 6") : amended,
 DisplayName("Sample Class 6") : amended,
 Locale("MS\\0x409"),
 guid("{15D851F6-6539-11d1-A529-00A0C9062910}")]
class WmiSampleClass6
{
    [key, read]
    string InstanceName;

    [read]
    boolean Active;

    [WmiDataId(1),
     read, write,
     DisplayName("Data") : amended,
     Description("Fixed length array of 4 embedded classes")]
    Vendor_EC2 EmbeddedClass2[4];
};
```

`Drivers/Driver-SRC/wmi/wmisamp/wmisamp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0
MinimumVisualStudioVersion = 12.0
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WmiSamp", "WmiSamp.vcxproj", "{126FE1F4-434C-496A-A52B-400BBB74AC3B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Debug|Win32.ActiveCfg = Debug|Win32
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Debug|Win32.Build.0 = Debug|Win32
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Release|Win32.ActiveCfg = Release|Win32
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Release|Win32.Build.0 = Release|Win32
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Debug|x64.ActiveCfg = Debug|x64
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Debug|x64.Build.0 = Debug|x64
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Release|x64.ActiveCfg = Release|x64
		{126FE1F4-434C-496A-A52B-400BBB74AC3B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Drivers/README.md`:

```md
## Windows Driver Security and Development

This directory will focus on Windows Drivers, feature those that are vulnerable. And provide samples, utilities, and resources for 
development as well as exploitation.



### Vuln Driver List  

Priveleged memory read/write vulnerabilities and more. Some PoCs are available and included.

 **ASUS**
 
```    
    EIO64.sys MmMapIoSpace/MmUnmapIoSpace
    IOMap64.sys MmMapIoSpace/MmUnmapIoSpace

    ATSZIO64.sys ZwMapViewOfSection/ZwUnmapViewOfSection/MmGetPhysicalAddress

    Device Name: ""\\.\ATSZIO"
    Map Physical IOCTL: 0x8807200C
    Unmap Physical IOCTL: 0x88072010
```
   [PoC](https://github.com/LimiQS/AsusDriversPrivEscala/blob/master/PoC-fixed.cs)
   
---------------------------------------

**ATI**

```
    atillk64.sys MmMapIoSpace/MmUnmapIoSpace/MmBuildMdlForNonPagedPool/MmMapLockedPages

    Device Name: "\\.\atillk64"
    Map/Unmap IOCTLs: 0x9C402534, 0x9C402538, 0x9C402544, 0x9C402548
    MDL IOCTLs: 0x9C40254C, 0x9C402558, 0x9C402560, 0x9C402564
```
---------------------------------------

**Avast**

```
    aswVmm.sys SSDT Hooking

    Device Name: "\\.\aswVmm"
    Hook IOCTL: 0xA000E804
```   
  [PoC](https://github.com/tanduRE/AvastHV/)
   
---------------------------------------

**Biostar**
```
    BS_Flash64.sys MmMapIoSpace/MmUnmapIoSpace/MmMapLockedPages/ExAllocatePoolWithTag/ExFreePoolWithTag

    Device Name: "\\.\BS_Flash64"
    Map/Unmap IOCTL: 0x222000
    Allocate IOCTL: 0x22203C

    BS_I2c64.sys MmMapIoSpace/MmUnmapIoSpace
    BSMEMx64.sys MmMapIoSpace/MmUnmapIoSpace/MmGetPhysicalAddress
    BSMIXP64.sys MmMapIoSpace/MmUnmapIoSpace/MmGetPhysicalAddress
```
---------------------------------------

**Capcom**
```
    Capcom.sys MmGetSystemRoutineAddress

    Device Name: "\\.\Htsysm72FB"
    Execute IOCTL: 0xAA013044
```
---------------------------------------

**CPUID**
```
    cpuz141.sys MmMapIoSpace/MmUnmapIoSpace

    Device Name: "\\.\cpuz141"
    Read Register IOCTL: 0x9C402428
    Physical Read: 0x9C402420
    Physical Write: 0x9C402430

    Notes: CVE-2017-15303
```
---------------------------------------

**CrystalMark**
```
    WinRing0x64.sys MmMapIoSpace/MmUnmapIoSpace

    Device Name: "\\.\WinRing0_1_0_1"
    Map/Unmap IOCTL: 0x9C406104
```
---------------------------------------

**Huawei**

```
    HwOs2Ec10x64.sys MmMapIoSpaceEx/KeInitializeApc/KeInsertQueueApc

    Device Name: "\\.\HwOs2EcDevX64"
    Notes: CVE-2019-5241
```
_Extra Info_

`sub_140009160`

- allocates RWX page in some target process;
- resolves CreateProcessW and CloseHandle function pointers in the address space of the target process;
- copies a code area from the driver as well as what seemed to be a parameter block to the allocated page; and
- performs User APC injection targeting that page
- More Information [here](https://www.microsoft.com/security/blog/2019/03/25/from-alert-to-driver-vulnerability-microsoft-defender-atp-investigation-unearths-privilege-escalation-flaw/)
---------------------------------------

**LG Driver**
```
    lha.sys
    Map IOCTL: 0x9C402FD8
    Unmap IOCTL: 0x9C402FDC

    Device Name: "\\.\{E8F2FF20-6AF7-4914-9398-CE2132FE170F}"
    Notes: CVE-2019-8372
```    
   [PoC](http://jackson-t.ca/lg-driver-lpe.html)
   
---------------------------------------

MSI/Microstar
```
    NTIOLib_x64.sys MmMapIoSpace/MmUnmapIoSpace

    Device Name: "\\.\NTIOLib_LiveUpdate"
    Read IOCTL: 0xC3506104
    Write IOCTL: 0xC350A108

    Notes: Packaged with MSI
    Can read/write MSR
```
   [PoC](https://github.com/rwfpl/rewolf-msi-exploit)
   
---------------------------------------

PC-Doctor
```
    pcdsrvc_x64.pkms MmMapIoSpace/MmProbeAndLockPages/

    Device Name: "\\.\PCDSRVC{3B54B31B-D06B6431-06020200}_0"
    GetPhysicalAddress IOCTL: 0x222080
    Read/Write Physical IOCTL: 0x222084, 0x222088
    Read/Write MSR IOCTL: 0x222180/0x222184

    Notes: Packaged with Dell SupportAssist
```  
   [PoC](https://github.com/SamLarenN/SpeedFan-Exploit/blob/master/SpeedFan%20Exploit/Speedfan.cpp)
   
---------------------------------------

SOKNO S.R.L.
```
    speedfan.sys MmMapIoSpace/MmMapIoSpace/MmUnmapIoSpace

    Device Name: "\\.\SpeedFan"
    Read Physical IOCTL: 0x9C402428
    Write Physical IOCTL: 0x9C40242C
    Read MSR: 0x9C402438
```
   [PoC](https://github.com/SamLarenN/SpeedFan-Exploit/blob/master/SpeedFan%20Exploit/Speedfan.cpp)
   
---------------------------------------
**Zemana**
```
    zam64.sys ZwOpenProcess

    Device name: "\\.\ZemanaAntiMalware"
    Open full access handle IOCTL: 0x80002010/0x8000204C
    Notes: CVE-2018-6606
```    
   [PoC](https://github.com/SouhailHammou/Exploits/blob/master/CVE-2018-6606%20-%20MalwareFox%20AntiMalware%20LPE/Malwarefox_privescl_1.c)

---------------------------------------

## Vulnerable Drivers List

A download link will be provided shortly courtesy of [Namazso](https://www.unknowncheats.me/forum/members/911201.html)

```
    Name                   Signer                                      Description                                    SHA256                                                          
    ----                   ------                                      -----------                                    ------                                                          
    ADV64DRV.sys           "FUJITSU LIMITED "                                                                         04A85E359525D662338CAE86C1E59B1D7AA9BD12B920E8067503723DC1E03162
    Agent64.sys            "eSupport.com, Inc."                        DriverAgent Direct I/O for 64-bit Windows      05F052C64D192CF69A462A5EC16DDA0D43CA5D0245900C9FCB9201685A2E7748
    Agent64.sys            Phoenix Technologies Ltd                    DriverAgent Direct I/O for 64-bit Windows      4045AE77859B1DBF13972451972EAAF6F3C97BEA423E9E78F1C2F14330CD47CA
    Agent64.sys            Phoenix Technologies Ltd                    DriverAgent Direct I/O for 64-bit Windows      6948480954137987A0BE626C24CF594390960242CD75F094CD6AAA5C2E7A54FA
    Agent64.sys            "eSupport.com, Inc"                         DriverAgent Direct I/O for 64-bit Windows      8CB62C5D41148DE416014F80BD1FD033FD4D2BD504CB05B90EEB6992A382D58F
    Agent64.sys            "eSupport.com, Inc."                        DriverAgent Direct I/O for 64-bit Windows      B1D96233235A62DBB21B8DBE2D1AE333199669F67664B107BFF1AD49B41D9414
    ALSysIO64.sys          Artur Liberman                              ALSysIO                                        7196187FB1EF8D108B380D37B2AF8EFDEB3CA1F6EEFD37B5DC114C609147216D
    ALSysIO64.sys          Artur Liberman                              ALSysIO                                        7F375639A0DF7FE51E5518CF87C3F513C55BC117DB47D28DA8C615642EB18BFA
    amifldrv64.sys         "American Megatrends, Inc."                                                                42579A759F3F95F20A2C51D5AC2047A2662A2675B3FB9F46C1ED7F23393A0F00
    AsIO.sys               ASUSTeK Computer Inc.                                                                      2DA330A2088409EFC351118445A824F11EDBE51CF3D653B298053785097FE40E
    AsIO.sys               ASUSTeK Computer Inc.                                                                      436CCAB6F62FA2D29827916E054ADE7ACAE485B3DE1D3E5C6C62D3DEBF1480E7
    AsIO.sys               ASUSTeK Computer Inc.                                                                      B4D47EA790920A4531E3DF5A4B4B0721B7FEA6B49A35679F0652F1E590422602
    AsIO.sys               ASUSTeK Computer Inc.                                                                      DDE6F28B3F7F2ABBEE59D4864435108791631E9CB4CDFB1F178E5AA9859956D8
    AsrAutoChkUpdDrv.sys   ASROCK Incorporation                        AsrAutoChkUpdDrv Driver                        2AA1B08F47FBB1E2BD2E4A492F5D616968E703E1359A921F62B38B8E4662F0C4
    AsrDrv10.sys           ASROCK Incorporation                        ASRock IO Driver                               ECE0A900EA089E730741499614C0917432246CEB5E11599EE3A1BB679E24FD2C
    AsrDrv101.sys          ASROCK Incorporation                        ASRock IO Driver                               F40435488389B4FB3B945CA21A8325A51E1B5F80F045AB019748D0EC66056A8B
    AsrIbDrv.sys           ASROCK Incorporation                        RW-Everything Read & Write Driver              2A652DE6B680D5AD92376AD323021850DAB2C653ABF06EDF26120F7714B8E08A
    AsrOmgDrv.sys          ASROCK Incorporation                        ASRock IO Driver                               950A4C0C772021CEE26011A92194F0E58D61588F77F2873AA0599DFF52A160C9
    AsrRapidStartDrv.sys   ASROCK Incorporation                        RW-Everything Read & Write Driver              0AAFA9F47ACF69D46C9542985994FF5321F00842A28DF2396D4A3076776A83CB
    AsrSmartConnectDrv.sys ASROCK Incorporation                        RW-Everything Read & Write Driver              47F08F7D30D824A8F4BB8A98916401A37C0FD8502DB308ABA91FE3112B892DCC
    AsUpIO.sys             ASUSTeK Computer Inc.                                                                      B9A4E40A5D80FEDD1037EAED958F9F9EFED41EB01ADA73D51B5DCD86E27E0CBF
    atillk64.sys           "ATI Technologies, Inc"                     ATI Diagnostics Hardware Abstraction Sys       5C04C274A708C9A7D993E33BE3EA9E6119DC29527A767410DBAF93996F87369A
    BS_Def64.sys           ASUSTeK Computer Inc.                       Default BIOS Flash Driver                      0040153302B88BEE27EB4F1ECA6855039E1A057370F5E8C615724FA5215BADA3
    BS_Def64.sys           ASUSTeK Computer Inc.                       Default BIOS Flash Driver                      3326E2D32BBABD69FEB6024809AFC56C7E39241EBE70A53728C77E80995422A5
    BS_Def64.sys           ASUSTeK Computer Inc.                       Default BIOS Flash Driver                      36B9E31240AB0341873C7092B63E2E0F2CAB2962EBF9B25271C3A1216B7669EB
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      29E0062A017A93B2F2F5207A608A96DF4D554C5DE976BD0276C2590A03BD3E94
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      45ABDBCD4C0916B7D9FAAF1CD08543A3A5178871074628E0126A6EDA890D26E0
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      50DB5480D0392A7DD6AB5DF98389DC24D1ED1E9C98C9C35964B19DABCD6DC67F
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      607DC4C75AC7AEF82AE0616A453866B3B358C6CF5C8F9D29E4D37F844306B97C
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      61D6E40601FA368800980801A662A5B3B36E3C23296E8AE1C85726A56EF18CC8
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      74A846C61ADC53692D3040AFF4C1916F32987AD72B07FE226E9E7DBEFF1036C4
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      76FB4DEAEE57EF30E56C382C92ABFFE2CF616D08DBECB3368C8EE6B02E59F303
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      81939E5C12BD627FF268E9887D6FB57E95E6049F28921F3437898757E7F21469
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      9790A7B9D624B2B18768BB655DDA4A05A9929633CEF0B1521E79E40D7DE0A05B
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      9A1D66036B0868BBB1B2823209FEDEA61A301D5DD245F8E7D390BD31E52D663E
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      AA9AB1195DC866270E984F1BED5E1358D6EF24C515DFDB6C2A92D1E1B94BF608
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      AF095DE15A16255CA1B2C27DAD365DFF9AC32D2A75E8E288F5A1307680781685
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      D5586DC1E61796A9AE5E5D1CED397874753056C3DF2EB963A8916287E1929A71
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      D8459F7D707C635E2C04D6D6D47B63F73BA3F6629702C7A6E0DF0462F6478AE2
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      E81230217988F3E7EC6F89A06D231EC66039BDBA340FD8EBB2BBB586506E3293
    CITMDRV_AMD64.sys      IBM Polska Sp. z o.o.                                                                      F88EBB633406A086D9CCA6BC8B66A4EA940C5476529F9033A9E0463512A23A57
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      1C8DFA14888BB58848B4792FB1D8A921976A9463BE8334CFF45CC96F1276049A
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      22418016E980E0A4A2D01CA210A17059916A4208352C1018B0079CCB19AAF86A
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      405472A8F9400A54BB29D03B436CCD58CFD6442FE686F6D2ED4F63F002854659
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      49F75746EEBE14E5DB11706B3E58ACCC62D4034D2F1C05C681ECEF5D1AD933BA
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      4A3D4DB86F580B1680D6454BAEE1C1A139E2DDE7D55E972BA7C92EC3F555DCE2
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      4AB41816ABBF14D59E75B7FAD49E2CB1C1FEB27A3CB27402297A2A4793FF9DA7
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      54841D9F89E195196E65AA881834804FE3678F1CF6B328CAB8703EDD15E3EC57
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      5EE292B605CD3751A24E5949AAE615D472A3C72688632C3040DC311055B75A92
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      76B86543CE05540048F954FED37BDDA66360C4A3DDB8328213D5AEF7A960C184
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      7F190F6E5AB0EDAFD63391506C2360230AF4C2D56C45FC8996A168A1FC12D457
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      845F1E228DE249FC1DDF8DC28C39D03E8AD328A6277B6502D3932E83B879A65A
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      84BF1D0BCDF175CFE8AEA2973E0373015793D43907410AE97E2071B2C4B8E2D4
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      8EF0AD86500094E8FA3D9E7D53163AA6FEEF67C09575C169873C494ED66F057F
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      A56C2A2425EB3A4260CC7FC5C8D7BED7A3B4CD2AF256185F24471C668853AEE8
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      AC3F613D457FC4D44FA27B2E0B1BAA62C09415705EFB5A40A4756DA39B3AC165
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      B1334A71CC73B3D0C54F62D8011BEC330DFC355A239BF94A121F6E4C86A30A2E
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      B47BE212352D407D0EF7458A7161C66B47C2AEC8391DD101DF11E65728337A6A
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      B9B3878DDC5DFB237D38F8D25067267870AFD67D12A330397A8853209C4D889C
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      DB90E554AD249C2BD888282ECF7D8DA4D1538DD364129A3327B54F8242DD5653
    CITMDRV_IA64.sys       IBM Polska Sp. z o.o.                                                                      E61A54F6D3869B43C4ECEAC3016DF73DF67CCE03878C5A6167166601C5D3F028
    cpuz_x64.sys           CPUID                                       CPUID Driver                                   3871E16758A1778907667F78589359734F7F62F9DC953EC558946DCDBE6951E3
    GLCKIO2.sys            ASUSTeK Computer Inc.                                                                      3A5EC83FE670E5E23AEF3AFA0A7241053F5B6BE5E6CA01766D6B5F9177183C25
    GLCKIO2.sys            ASUSTeK Computer Inc.                                                                      61A1BDDDD3C512E681818DEBB5BEE94DB701768FC25E674FCAD46592A3259BD0
    HOSTNT.sys             "SafeNet, Inc."                             Hostnt 64-bit driver                           07B6D69BAFCFD767F1B63A490A8843C3BB1F8E1BBEA56176109B5743C8F7D357
    HwRwDrv.sys            Shuttle Inc.                                Hardware read & write driver                   21CCDD306B5183C00ECFD0475B3152E7D94B921E858E59B68A03E925D1715F21
    inpoutx64.sys          RISINTECH INC.                              Kernel level port access driver                2D83CCB1AD9839C9F5B3F10B1F856177DF1594C66CBBC7661677D4B462EBF44D
    inpoutx64.sys          RISINTECH INC.                              Kernel level port access driver                F581DECC2888EF27EE1EA85EA23BBB5FB2FE6A554266FF5A1476ACD1D29D53AF
    inpoutx64.sys          Red Fox UK Limited                          Kernel level port access driver                F8965FDCE668692C3785AFA3559159F9A18287BC0D53ABB21902895A8ECF221B
    iomem64.sys            "DT RESEARCH, INC. TAIWAN BRANCH"           DTR Kernel mode driver                         3D23BDBAF9905259D858DF5BF991EB23D2DC9F4ECDA7F9F77839691ACEF1B8C4
    iomem64.sys            "DT RESEARCH, INC. TAIWAN BRANCH"           DTR Kernel mode driver                         DD4A1253D47DE14EF83F1BC8B40816A86CCF90D1E624C5ADF9203AE9D51D4097
    msrhook.sys            ID TECH                                                                                    6DE84CAA2CA18673E01B91AF58220C60AECD5CCCF269725EC3C7F226B2167492
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        09BEDBF7A41E0F8DABE4F41D331DB58373CE15B2E9204540873A1884F38BDDE1
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        101402D4F5D1AE413DED499C78A5FCBBC7E3BAE9B000D64C1DD64E3C48C37558
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        131D5490CEB9A5B2324D8E927FEA5BECFC633015661DE2F4C2F2375A3A3B64C6
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        1DDFE4756F5DB9FB319D6C6DA9C41C588A729D9E7817190B027B38E9C076D219
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib_X64                                    1E8B0C1966E566A523D652E00F7727D8B0663F1DFDCE3B9A09B9ADFAEF48D8EE
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib For MSISimple_OC                       2BBE65CBEC3BB069E92233924F7EE1F95FFA16173FCEB932C34F68D862781250
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        MSI ComCenService Driver                       30706F110725199E338E9CC1C940D9A644D19A14F0EB8847712CBA4CACDA67AB
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib for MSIFrequency_CC                    3124B0411B8077605DB2A9B7909D8240E0D554496600E2706E531C93C931E1B5
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        38FA0C663C8689048726666F1C5E019FEAA9DA8278F1DF6FF62DA33961891D2A
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        39CFDE7D401EFCE4F550E0A9461F5FC4D71FA07235E1336E4F0B4882BD76550E
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib For NTIOLib_ECO                        3D9E83B189FCF5C3541C62D1F54A0DA0A4E5B62C3243D2989AFC46644056C8E3
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        3F2FDA9A7A9C57B7138687BBCE49A2E156D6095DDDABB3454EA09737E02C3FA5
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        47F0CDAA2359A63AD1389EF4A635F1F6EEE1F63BDF6EF177F114BDCDADC2E005
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        50D5EAA168C077CE5B7F15B3F2C43BD2B86B07B1E926C1B332F8CB13BD2E0793
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        56A3C9AC137D862A85B4004F043D46542A1B61C6ACB438098A9640469E2D80E7
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib For MSIRatio_CC                        591BD5E92DFA0117B3DAA29750E73E2DB25BAA717C31217539D30FFB1F7F3A52
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib_X64                                    5D530E111400785D183057113D70623E17AF32931668AB7C7FC826F0FD4F91A3
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        6F1FF29E2E710F6D064DC74E8E011331D807C32CC2A622CBE507FD4B4D43F8F4
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        79E2D37632C417138970B4FEBA91B7E10C2EA251C5EFE3D1FC6FA0190F176B57
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        85866E8C25D82C1EC91D7A8076C7D073CCCF421CF57D9C83D80D63943A4EDD94
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        89B0017BC30CC026E32B758C66A1AF88BD54C6A78E11EC2908FF854E00AC46BE
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib for MSIDDR_CC                          9254F012009D55F555418FF85F7D93B184AB7CB0E37AECDFDAB62CFE94DEA96B
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        952199C28332BC90CFD74530A77EE237967ED32B3C71322559C59F7A42187DC4
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        9529EFB1837B1005E5E8F477773752078E0A46500C748BC30C9B5084D04082E6
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        984A77E5424C6D099051441005F2938AE92B31B5AD8F6521C6B001932862ADD7
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib for DebugLED                           98B734DDA78C16EBCAA4AFEB31007926542B63B2F163B2F733FA0D00DBB344D8
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        99F4994A0E5BD1BF6E3F637D3225C69FF4CD620557E23637533E7F18D7D6CBA1
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        9C10E2EC4F9EF591415F9A784B93DC9C9CDAFA7C69602C0DC860C5B62222E449
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        A961F5939088238D76757669A9A81905E33F247C9C635B908DAAC146AE063499
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        A9706E320179993DADE519A83061477ACE195DAA1B788662825484813001F526
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        B7A20B5F15E1871B392782C46EBCC897929443D82073EE4DCB3874B6A5976B5D
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        CC586254E9E89E88334ADEE44E332166119307E79C2F18F6C2AB90CE8BA7FC9B
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        CD4A249C3EF65AF285D0F8F30A8A96E83688486AAB515836318A2559757A89BB
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib for MSIClock_CC                        CF4B5FA853CE809F1924DF3A3AE3C4E191878C4EA5248D8785DC7E51807A512B
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        D0BD1AE72AEB5F3EABF1531A635F990E5EAAE7FDD560342F915F723766C80889
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        D8B58F6A89A7618558E37AFC360CD772B6731E3BA367F8D58734ECEE2244A530
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        D92EAB70BCECE4432258C9C9A914483A2267F6AB5CE2630048D3A99E8CB1B482
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        E005E8D183E853A27AD3BB56F25489F369C11B0D47E3D4095AAD9291B3343BF1
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib For MSISimple_OC                       E68D453D333854787F8470C8BAEF3E0D082F26DF5AA19C0493898BCF3401E39A
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib for MSICPU_CC                          E83908EBA2501A00EF9E74E7D1C8B4FF1279F1CD6051707FD51824F87E4378FA
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        EF86C4E5EE1DBC4F81CD864E8CD2F4A2A85EE4475B9A9AB698A4AE1CC71FBEB0
    NTIOLib.sys            "MICRO-STAR INTERNATIONAL CO., LTD."        NTIOLib                                        F088B2BA27DACD5C28F8EE428F1350DCA4BC7C6606309C287C801B2E1DA1A53D
    NTIOLib.sys            Micro-Star Int'l Co. Ltd.                   NTIOLib                                        FD8669794C67B396C12FC5F08E9C004FDF851A82FAF302846878173E4FBECB03
    OpenLibSys.sys         Noriyuki MIYAZAKI                           OpenLibSys                                     91314768DA140999E682D2A290D48B78BB25A35525EA12C1B1F9634D14602B2C
    OpenLibSys.sys         Noriyuki MIYAZAKI                           OpenLibSys                                     F0605DDA1DEF240DC7E14EFA73927D6C6D89988C01EA8647B671667B2B167008
    Se64a.sys              EnTech Taiwan                               EnTech softEngine x64 kernel-mode driver       6CB51AE871FBD5D07C5AAD6FF8EEA43D34063089528603CA9CEB8B4F52F68DDC
    smep_capcom.sys        "CAPCOM Co.,Ltd."                                                                          DB2A9247177E8CDD50FE9433D066B86FFD2A84301AA6B2EB60F361CFFF077004
    smep_namco.sys         NAMCO BANDAI Online Inc.                                                                   7EC93F34EB323823EB199FBF8D06219086D517D0E8F4B9E348D7AFD41EC9FD5D
    SysInfo.sys            Noriyuki MIYAZAKI                                                                          7049F3C939EFE76A5556C2A2C04386DB51DAF61D56B679F4868BB0983C996EBB
    VProEventMonitor.sys   Symantec Corporation                        VProEventMonitor.Sys - Event Monitoring driver 7877C1B0E7429453B750218CA491C2825DAE684AD9616642EFF7B41715C70ACA
    WCPU.sys               ASUSTeK Computer Inc.                       ASUS TDE CPU Driver                            159E7C5A12157AF92E0D14A0D3EA116F91C09E21A9831486E6DC592C93C10980
    WINIODrv.sys           "Partner Tech(Shanghai)Co.,Ltd"                                                            3243AAB18E273A9B9C4280A57AECEF278E10BFFF19ABB260D7A7820E41739099
    WINIODrv.sys           "Partner Tech(Shanghai)Co.,Ltd"                                                            7CFA5E10DFF8A99A5D544B011F676BC383991274C693E21E3AF40CF6982ADB8C
    WINIODrv.sys           "Partner Tech(Shanghai)Co.,Ltd"                                                            C9B49B52B493B53CD49C12C3FA9553E57C5394555B64E32D1208F5B96A5B8C6E
    WinRing0.sys           "TOSHIBA AMERICA INFORMATION SYSTEMS, INC." WinRing0                                       3EC5AD51E6879464DFBCCB9F4ED76C6325056A42548D5994BA869DA9C4C039A8
    WinRing0.sys           Noriyuki MIYAZAKI                           WinRing0                                       47EAEBC920CCF99E09FC9924FEB6B19B8A28589F52783327067C9B09754B5E84
    WinRing0.sys           EVGA                                        WinRing0                                       A7B000ABBCC344444A9B00CFADE7AA22AB92CE0CADEC196C30EB1851AE4FA062
```

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2021, Vector Security
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# WinKernel-Resources
A list of excellent resources for anyone trying to deepen their understanding with regards to Windows Kernel Exploitation and general low level security.


Some resources, links, books, and papers related to mostly Windows Internals and anything Windows kernel related really.

## Important Info

- [React OS Win32k](https://reactos.org/wiki/Techwiki:Win32k)
- [Geoff Chappell - Kernel-Mode Windows](https://www.geoffchappell.com/studies/windows/km/index.htm)
- [HEVD Vulnerable driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)
- [FLARE Kernel Shellcode Loader](https://github.com/fireeye/flare-kscldr)
- [Vergilius - Undocumented kernel structures](https://www.vergiliusproject.com/)
- [Windows X86-64 System Call Table](https://j00ru.vexillium.org/syscalls/nt/64/)
- [Vulnerable Driver Megathread](https://www.unknowncheats.me/forum/anti-cheat-bypass/334557-vulnerable-driver-megathread.html)

## Must watch 

- [ ⭐ Kernel Mode Threats and Practical Defenses](https://www.youtube.com/watch?v=BBJgKuXzfwc)
- [ ⭐ Morten Schenk - Taking Windows 10 Kernel Exploitation to the next level](https://youtu.be/33Jr1wkaCmQ)
- [ ⭐ The Life & Death of Kernel Object Abuse](https://youtu.be/_u7d9kLdi0c)
- [ ⭐ Windows 10 Mitigation Improvements](https://youtu.be/gCu2GQd0GSE)

## Windows Rootkits

**Talks / video recordings**

- [11 part playlist -  Rootkits: What they are, and how to find them](https://www.youtube.com/watch?v=ewNo_poX7bA&list=PLF58FB7BCB20ED11A)
- [Hooking Nirvana](https://www.youtube.com/watch?v=pHyWyH804xE)
- [Alex Ionescu - Advancing the State of UEFI Bootkits](https://www.youtube.com/watch?v=dpG97TBR3Ys)
- [BlueHat v18 || Return of the kernel rootkit malware (on windows 10)](https://youtu.be/qVIxFfXpyNc)
- [Numchecker: A System Approach for Kernel Rootkit Detection](https://www.youtube.com/watch?v=TgMsMwsfoQ0)
- [DEF CON 26  - Ring 0 Ring 2 Rootkits Bypassing Defenses](https://www.youtube.com/watch?v=7AEMxaZhdLU)
- [Black Hat Windows 2001 - Kernel Mode Rootkits](https://www.youtube.com/watch?v=99Znv6tgYS0)
- [Black Hat Windows 2004 - DKOM (Direct Kernel Object Manipulation)](https://www.youtube.com/watch?v=1Ie20b5IGgY)
- [RTFM SigSegv1 - From corrupted memory dump to rootkit detection](https://www.youtube.com/watch?v=hlhM_q3ZHfQ)

**Articles / papers**

- [Dissecting Turla Rootkit Malware Using Dynamic Analysis](https://www.lastline.com/labsblog/dissecting-turla-rootkit-malware-using-dynamic-analysis/)
- [A quick insight into the Driver Signature Enforcement](https://j00ru.vexillium.org/2010/06/insight-into-the-driver-signature-enforcement/)
- [WINDOWS DRIVER SIGNING BYPASS BY DERUSB](http://www.sekoia.fr/blog/windows-driver-signing-bypass-by-derusbi/)
- [A Basic Windows DKOM Rootkit](https://blog.landhb.dev/posts/v9eRa/a-basic-windows-dkom-rootkit-pt-1/)
- [Manipulating ActiveProcessLinks to Hide Processes in Userland](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/manipulating-activeprocesslinks-to-unlink-processes-in-userland)

## Windows kernel mitigations

**Talks / video recordings**

- [BlueHat v18 || Hardening hyper-v through offensive security research](https://www.youtube.com/watch?v=8RCH0vFxWT4)
- [BYPASS CONTROL FLOW GUARD COMPREHENSIVELY - this is cfg not kCFG](https://www.blackhat.com/docs/us-15/materials/us-15-Zhang-Bypass-Control-Flow-Guard-Comprehensively-wp.pdf)
- [BlueHat v18 || Mitigation Bypass: The Past, Present, and Future](https://www.youtube.com/watch?v=WsoFmN3oDw8)
- [Windows Offender Reverse Engineering Windows Defender's Antivirus Emulator](https://www.youtube.com/watch?v=LvW68czaEGs)
- [Windows 10 Mitigation Improvements (really good talk)](https://www.youtube.com/watch?v=gCu2GQd0GSE)
- [Overview of Windows 10 Requirements for TPM, HVCI and SecureBoot](https://www.youtube.com/watch?v=v149T7p4XLA)
- [Examining the Guardians of Windows 10 Security - Chuanda Ding](https://www.youtube.com/watch?v=a0AB76YNMlQ)
- [Analysis of the Attack Surface of Windows 10 Virtualization-Based Security](https://www.youtube.com/watch?v=_646Gmr_uo0)
- [A Dive in to Hyper-V Architecture & Vulnerabilities](https://www.youtube.com/watch?v=2bK_rC81_Eo)
- [the last kaslr leak](https://www.youtube.com/watch?v=PTnuwchEci0)
- [BlueHat v18 || A mitigation for kernel toctou vulnerabilities](https://www.youtube.com/watch?v=YGkhK55jitE)
- [REcon 2013 - I got 99 problems but a kernel pointer ain't one ](https://www.youtube.com/watch?v=5HbmpPBKVFg)
- [SMEP: What is it, and how to beat it on Windows](https://j00ru.vexillium.org/2011/06/smep-what-is-it-and-how-to-beat-it-on-windows/)
- [BlueHat IL 2020 - David Weston - Keeping Windows Secure](https://www.youtube.com/watch?v=NlfZG2wTPZU)
- [Advancing Windows Security — David Weston](https://www.youtube.com/watch?v=FJnGA4XRaq4)
- [OffensiveCon18 - The Evolution of CFI Attacks and Defenses](https://www.youtube.com/watch?v=oOqpl-2rMTw)

**Articles / papers**

**General mitigation papers**

- [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)
- [TAKING WINDOWS 10 KERNEL EXPLOITATION TO THE NEXT LEVEL](https://www.blackhat.com/docs/us-17/wednesday/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp.pdf)

**kASLR**

- [KASLR Bypass Mitigations in Windows 8.1](https://www.crowdstrike.com/blog/kaslr-bypass-mitigations-windows-81/)
- [Devlopment of a new Windows 10 KASLR bypass - in one winDBG command](https://www.offensive-security.com/vulndev/development-of-a-new-windows-10-kaslr-bypass-in-one-windbg-command/)

**SMEP**

- [Bypassing Intel SMEP on Windows 8 x64 Using Return-oriented Programming](http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html)
- [Return Oriented Programming Tutorial](https://rstforums.com/forum/topic/106553-rop-for-smep-bypass/)
- [Stack Buffer Overflow (SMEP Bypass)](https://www.abatchy.com/2018/01/kernel-exploitation-4)
- [Windows 10 x64 and Bypassing SMEP](https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/)
- [SMEP: What is it, and how to beat it on Windows](https://j00ru.vexillium.org/2011/06/smep-what-is-it-and-how-to-beat-it-on-windows/)

**CET**

- [Security Analysis of Processor Instruction Set Architecture for Enforcing Control-Flow Integrity](https://dl.acm.org/doi/pdf/10.1145/3337167.3337175)
- [A Technical Look at Intel’s Control-flow Enforcement Technology](https://software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html)
- [Control-flow Enforcement Technology Specification](https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf)
- [Intel CET Answers Call to Protect Against Common Malware Threats](https://newsroom.intel.com/editorials/intel-cet-answers-call-protect-common-malware-threats/)
- [R.I.P ROP: CET Internals in Windows 20H1](https://windows-internals.com/cet-on-windows/)

## Windows kernel shellcode

**Articles / papers**

- [Loading Kernel Shellcode](https://www.fireeye.com/blog/threat-research/2018/04/loading-kernel-shellcode.html)
- [Windows Kernel Shellcodes - a compendium](https://www.matteomalvica.com/blog/2019/07/06/windows-kernel-shellcode/)
- [Windows Kernel Shellcode on Windows 10 – Part 1](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-1)
- [Windows Kernel Shellcode on Windows 10 – Part 2](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-2)
- [Windows Kernel Shellcode on Windows 10 – Part 3](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-3)
- [Panic! At The Kernel - Token Stealing Payloads Revisited on Windows 10 x64 and Bypassing SMEP](https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/)
- [Token Abuse for Privilege Escalation in Kernel](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/how-kernel-exploits-abuse-tokens-for-privilege-escalation)
- [Introduction to Shellcode Development](https://owasp.org/www-pdf-archive/Introduction_to_shellcode_development.pdf)
- [Introduction to Windows shellcode development – Part 1](https://securitycafe.ro/2015/10/30/introduction-to-windows-shellcode-development-part1/)
- [DoublePulsar Initial SMB Backdoor Ring 0 Shellcode Analysis](https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html)
- [Exploring Injected Threads](https://ired.team/miscellaneous-reversing-forensics/get-injectedthread#injecting-shellcode)

## Windows kernel exploitation

**Talks / video recordings**

- [HITB2016AMS - Kernel Exploit Hunting And Mitigation](https://www.youtube.com/watch?v=nvI6w8aW-4Q)
- [Ilja van Sprundel: Windows drivers attack surface](https://www.youtube.com/watch?v=qk-OI8Z-1To)
- [REcon 2015 - This Time Font hunt you down in 4 bytes](https://www.youtube.com/watch?v=uvy5BF1Nlio)
- [Exploiting a Windows 10 PagedPool off-by-one overflow (WCTF 2018)](https://j00ru.vexillium.org/2018/07/exploiting-a-windows-10-pagedpool-off-by-one/)
- [Windows kernel exploitation techniques - Adrien Garin - LSE Week 2016](https://www.youtube.com/watch?v=f8hTwFpRphU)
- [Hackingz Ze Komputerz - Exploiting CAPCOM.SYS - Part 1](https://www.youtube.com/watch?v=pJZjWXxUEl4)
- [Hackingz Ze Komputerz - Exploiting CAPCOM.SYS - Part 2](https://www.youtube.com/watch?v=UGWqq5kTiso)
- [The 3 Way06 Practical Windows Kernel Exploitation](https://www.youtube.com/watch?v=hUCmV7uT29I)
- [Reverse Engineering and Bug Hunting on KMDF Drivers](https://www.youtube.com/watch?v=puNkbSTQtXY)
- [Binary Exploit Mitigation and Bypass History - not just kernel ](https://vimeo.com/379935124) 
- [Morten Schenk - Taking Windows 10 Kernel Exploitation to the next level](https://www.youtube.com/watch?v=Gu_5kkErQ6Y)
- [REcon 2015 - Reverse Engineering Windows AFD.sys](https://www.youtube.com/watch?v=2sPNUpfTJ5A)
- [Windows Kernel Graphics Driver Attack Surface](https://www.youtube.com/watch?v=uzPTyXQ1Oys)
- [Understanding TOCTTOU in the Windows Kernel Font Scaler Engine](https://www.youtube.com/watch?v=61K3kqTRbzU)
- [Black Hat USA 2013 - Smashing The Font Scaler Engine in Windows Kernel](https://www.youtube.com/watch?v=efgoislKd8Q)

**Articles / papers**

- [Kernel Exploit Sample Hunting and Mining Contents](https://d3gpjj9d20n0p3.cloudfront.net/fortiguard/research/Kernel%20Exploit%20Hunting%20and%20Mitigation-WP.pdf)
- [The entire GreyHatHacker site has great writeups](https://www.greyhathacker.net/) 
- [BlueKeep: A Journey from DoS to RCE (CVE-2019-0708)](https://www.malwaretech.com/2019/09/bluekeep-a-journey-from-dos-to-rce-cve-2019-0708.html)
- [Exploiting SMBGhost (CVE-2020-0796) for a Local Privilege Escalation](https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/)
- [Windows Drivers are True’ly Tricky](https://googleprojectzero.blogspot.com/2015/10/windows-drivers-are-truely-tricky.html)
- [Taking apart a double zero-day sample discovered in joint hunt with ESET](https://www.microsoft.com/security/blog/2018/07/02/taking-apart-a-double-zero-day-sample-discovered-in-joint-hunt-with-eset/)
- [Sharks in the Pool :: Mixed Object Exploitation in the Windows Kernel Pool](https://srcincite.io/blog/2017/09/06/sharks-in-the-pool-mixed-object-exploitation-in-the-windows-kernel-pool.html)
- [Kernel Pool Overflow Exploitation in Real World: Windows 10](https://www.gatewatcher.com/en/news/blog/kernel-pool-overflow-exploitation-in-real-world-windows-10)
- [Kernel Pool Overflow Exploitation in Real World - Windows 7](https://www.gatewatcher.com/en/news/blog/kernel-pool-overflow-exploitation-in-real-world-windows-7)
- [Kernel Pool Exploitation on Windows 7](https://www.exploit-db.com/docs/english/16032-kernel-pool-exploitation-on-windows-7.pdf)
- [Easy local Windows Kernel exploitation](https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf)
- [Exploiting CVE-2014-4113](https://labs.f-secure.com/assets/BlogFiles/mwri-lab-exploiting-cve-2014-4113.pdf)
- [Pwn2Own 2014 - AFD.sys Dangling Pointer Vulnerability](https://www.siberas.de/papers/Pwn2Own_2014_AFD.sys_privilege_escalation.pdf)
- [Symantec Endpoint protection 0day](https://www.offensive-security.com/vulndev/symantec-endpoint-protection-0day/)
- [Analysing the NULL SecurityDescriptor kernel exploitation mitigation in the latest Windows 10 v1607 Build 14393](https://labs.nettitude.com/blog/analysing-the-null-securitydescriptor-kernel-exploitation-mitigation-in-the-latest-windows-10-v1607-build-14393/)
- [nt!_SEP_TOKEN_PRIVILEGES - Single Write EoP Protect](https://www.exploit-db.com/docs/english/41924-nt!_sep_token_privileges---single-write-eop-protect.pdf)
- [Token Abuse for Privilege Escalation in Kernel](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/how-kernel-exploits-abuse-tokens-for-privilege-escalation)

## Windows kernel GDI exploitation

**Talks / video recordings**

- [Abusing GDI for ring0 exploit primitives Evolution](https://www.youtube.com/watch?v=ruuVkTuNUSc)
- [Demystifying Windows Kernel Exploitation by Abusing GDI Objects](https://www.youtube.com/watch?v=2chDv_wTymc)
- [CommSec D1 - The Life & Death of Kernel Object Abuse](https://www.youtube.com/watch?v=_u7d9kLdi0c)
- [Kernel Object Abuse by Type Isolation](https://www.youtube.com/watch?v=kOV-Y9HcJWM)

**Articles / papers**

- [Turning CVE-2017-14961 into full arbitrary read / write with PALETTE objects](https://web.archive.org/web/20191220090640/http://theevilbit.blogspot.com/2017/11/turning-cve-2017-14961-ikarus-antivirus.html)
- [Zero-day exploit (CVE-2018-8453) used in targeted attacks](https://securelist.com/cve-2018-8453-used-in-targeted-attacks/88151/)
- [The zero-day exploits of Operation WizardOpium](https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/)
- [Windows 0-day exploit CVE-2019-1458 used in Operation WizardOpium](https://securelist.com/windows-0-day-exploit-cve-2019-1458-used-in-operation-wizardopium/95432/)
- [Abusing GDI Objects for ring0 Primitives Revolution](https://sensepost.com/blog/2017/abusing-gdi-objects-for-ring0-primitives-revolution/)
- [https://www.coresecurity.com/core-labs/articles/abusing-gdi-for-ring0-exploit-primitives](https://www.coresecurity.com/core-labs/articles/abusing-gdi-for-ring0-exploit-primitives)
- [A Tale Of Bitmaps: Leaking GDI Objects Post Windows 10 Anniversary Edition](https://labs.f-secure.com/archive/a-tale-of-bitmaps/)
- [CSW2017 Peng qiu shefang zhong win32k dark_composition](https://www.slideshare.net/CanSecWest/csw2017-peng-qiushefangzhong-win32k-darkcompositionfinnalfinnalrmmark)
- [Kernel Exploitation -> GDI Bitmap Abuse (Win7-10 32/64bit)](https://www.fuzzysecurity.com/tutorials/expDev/21.html)

## Windows kernel Win32k.sys research

**Talks / video recordings**

- [BlackHat 2011 - Kernel Attacks Through User-Mode Callbacks](https://www.youtube.com/watch?v=EkGDSqpfzgg)

**Articles / papers**

- [CVE-2020-1054 Analysis](https://0xeb-bp.github.io/blog/2020/06/15/cve-2020-1054-analysis.html)
- [TFW you-get-really-excited-you-patch-diffed-a-0day-used-in-the-wild-but-then-find-out-it-is-the-wrong-vuln](https://googleprojectzero.blogspot.com/2020/04/tfw-you-get-really-excited-you-patch.html)
- [One Bit To Rule A System: Analyzing CVE-2016-7255 Exploit In The Wild](https://blog.trendmicro.com/trendlabs-security-intelligence/one-bit-rule-system-analyzing-cve-2016-7255-exploit-wild/)
- [Reverse Engineering the Win32k Type Isolation Mitigation](https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html)
- [A new exploit for zero-day vulnerability CVE-2018-8589](https://securelist.com/a-new-exploit-for-zero-day-vulnerability-cve-2018-8589/88845/)
- [Detecting and mitigating elevation-of-privilege exploit for CVE-2017-0005](https://www.microsoft.com/security/blog/2017/03/27/detecting-and-mitigating-elevation-of-privilege-exploit-for-cve-2017-0005/)
- [Exploring CVE-2015-1701 — A Win32k Elevation of Privilege Vulnerability Used in Targeted Attacks
](https://blog.trendmicro.com/trendlabs-security-intelligence/exploring-cve-2015-1701-a-win32k-elevation-of-privilege-vulnerability-used-in-targeted-attacks/)
- [Exploiting the win32k!xxxEnableWndSBArrows use-after-free](https://www.nccgroup.trust/globalassets/our-research/uk/blog-post/2015-07-07_-_exploiting_cve_2015_0057.pdf)
- [New zero-day vulnerability CVE-2019-0859 in win32k.sys](https://securelist.com/new-win32k-zero-day-cve-2019-0859/90435/)
- [Windows zero‑day CVE‑2019‑1132 exploited in targeted attacks](https://www.welivesecurity.com/2019/07/10/windows-zero-day-cve-2019-1132-exploit/)
- [Windows Kernel Local Denial-of-Service #1: win32k!NtUserThunkedMenuItemInfo](https://j00ru.vexillium.org/2017/02/windows-kernel-local-denial-of-service-1/)
- [Windows Kernel Local Denial-of-Service #2: win32k!NtDCompositionBeginFrame](https://j00ru.vexillium.org/2017/02/windows-kernel-local-denial-of-service-2/)
- [Windows Kernel Local Denial-of-Service #4: nt!NtAccessCheck and family](https://j00ru.vexillium.org/2017/04/windows-kernel-local-denial-of-service-4/)
- [Windows Kernel Local Denial-of-Service #5: win32k!NtGdiGetDIBitsInternal](https://j00ru.vexillium.org/2017/04/windows-kernel-local-denial-of-service-5/)
- [Windows win32k.sys menus and some “close, but no cigar” bugs](https://j00ru.vexillium.org/2013/09/windows-win32k-sys-menus-and-some-close-but-no-cigar-bugs/)
- [Windows Kernel Internals - Win32K.sys](http://pasotech.altervista.org/windows_internals/Win32KSYS.pdf)

## Windows Kernel logic bugs

**Talks / video recordings**

- [Get Off the Kernel if You Can't Drive - DEF CON 27 Conference](https://www.youtube.com/watch?v=tzWq5iUiKKg)

**Articles / papers**

- [A vulnerable driver: lesson almost learned](https://securelist.com/elevation-of-privileges-in-namco-driver/83707/)
- [CVE-2020-12138 - Privilege Escalation in ATI Technologies Inc. Driver atillk64.sys](https://h0mbre.github.io/atillk64_exploit/)
- [CVE-2019-18845 - Viper RGB Driver Local Privilege Escalation](https://www.activecyber.us/activelabs/viper-rgb-driver-local-privilege-escalation-cve-2019-18845)
- [CVE-2020-8808 - CORSAIR iCUE Driver Local Privilege Escalation](https://www.activecyber.us/activelabs/corsair-icue-driver-local-privilege-escalation-cve-2020-8808)
- [Logic bugs in Razer rzpnk.sys](https://www.fuzzysecurity.com/tutorials/expDev/23.html)
- [Dell SupportAssist Driver - Local Privilege Escalation](http://dronesec.pw/blog/2018/05/17/dell-supportassist-local-privilege-escalation/)
- [MSI ntiolib.sys/winio.sys local privilege escalation](http://blog.rewolf.pl/blog/?p=1630)
- [CVE-2019-8372 - Local Privilege Elevation in LG Kernel Driver](http://www.jackson-t.ca/lg-driver-lpe.html)
- [Reading Physical Memory using Carbon Black's Endpoint driver](https://billdemirkapi.me/Reading-Physical-Memory-using-Carbon-Black/)
- [ASUS UEFI Update Driver Physical Memory Read/Write](https://codeinsecurity.wordpress.com/2016/06/12/asus-uefi-update-driver-physical-memory-readwrite/)
- [Privilege escalation vulnerabilities found in over 40 Windows Drivers](https://mspoweruser.com/privilege-escalation-vulnerabilities-found-in-over-40-windows-drivers/)
- [Blackat - KERNEL MODE THREATS AND PRACTICAL DEFENSES](https://i.blackhat.com/us-18/Thu-August-9/us-18-Desimone-Kernel-Mode-Threats-and-Practical-Defenses.pdf)
- [Weaponizing vulnerable driver for privilege escalation— Gigabyte Edition!](https://medium.com/@fsx30/weaponizing-vulnerable-driver-for-privilege-escalation-gigabyte-edition-e73ee523598b)

## Windows kernel driver development

**Talks / video recordings**

- [Windows Kernel Programming - 14 part playlist](https://youtu.be/XUlbYRFFYf0)
- [Windows Driver Development - 19 part playlist](https://youtu.be/T5VtaP-wtkk)
- [Developing Kernel Drivers with Modern C++ - Pavel Yosifovich](https://www.youtube.com/watch?v=AsSMKL5vaXw)

**Articles / papers**

- [Winsock Kernel Overview Topics](https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-winsock-kernel)
- [Driver Development Part 1: Introduction to Drivers](https://www.codeproject.com/Articles/9504/Driver-Development-Part-1-Introduction-to-Drivers)
- [Driver Development Part 2: Introduction to Implementing IOCTLs](https://www.codeproject.com/Articles/9575/Driver-Development-Part-2-Introduction-to-Implemen)
- [Driver Development Part 3: Introduction to driver contexts](https://www.codeproject.com/Articles/9636/Driver-Development-Part-3-Introduction-to-driver-c)
- [Driver Development Part 4: Introduction to device stacks](https://www.codeproject.com/Articles/9766/Driver-Development-Part-4-Introduction-to-device-s)
- [Creating IOCTL Requests in Drivers](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/creating-ioctl-requests-in-drivers)
- [Windows Drivers Part 2: IOCTLs](https://cylus.org/windows-drivers-part-2-ioctls-c678526f90ae)
- [Sending Commands From Your Userland Program to Your Kernel Driver using IOCTL](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/sending-commands-from-userland-to-your-kernel-driver-using-ioctl)

## Windows Internals

**Talks / video recordings**

- [Pluralsight - Windows Internals 1](https://www.pluralsight.com/courses/windows-internals)
- [Pluralsight - Windows Internals 2](https://www.pluralsight.com/courses/windows-internals2)
- [Pluralsight - Windows Internals 3](https://www.pluralsight.com/courses/windows-internals-3)
- [Pluralsight - Windows 10 Internals: Systems and Processes](https://www.pluralsight.com/courses/windows-10-internals-threads-memory-security)
- [Pluralsight - Windows 10 Internals - Threads, Memory and Security](https://www.pluralsight.com/courses/windows-10-internals-system-processes)
- [Alex Ionescu Insection: AWEsomely Exploiting Shared Memory Objects](https://vimeo.com/133292423)
- [Windows Internals](https://www.youtube.com/watch?v=vz15OqiYYXo)
- [Windows 10 Segment Heap Internals](https://www.youtube.com/watch?v=hetZx78SQ_A)
- [Windows Kernel Vulnerability Research and Exploitation - Gilad Bakas](https://www.youtube.com/watch?v=aRZ5Wi-NWXs)
- [NIC 5th Anniversary - Windows 10 internals](https://youtu.be/ffYiIUOUAUs)
- [Black Hat USA 2012 - Windows 8 Heap Intervals](https://www.youtube.com/watch?v=XxlzK0CLFN0)

**Articles / papers**

- [Whitepaper - WINDOWS 10 SEGMENT HEAP INTERNALS](https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)
- [The Quest for the SSDTs](https://www.codeproject.com/Articles/1191465/The-Quest-for-the-SSDTs)
- [System Service Descriptor Table - SSDT](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/glimpse-into-ssdt-in-windows-x64-kernel)
- [Interrupt Descriptor Table - IDT](https://ired.team/miscellaneous-reversing-forensics/windows-kernel/interrupt-descriptor-table-idt)
- [Exploring Process Environment Block](https://ired.team/miscellaneous-reversing-forensics/exploring-process-environment-block)
- [Windows Pool Manager](https://www.osr.com/nt-insider/2014-issue1/windows-pool-manager/)
- [Parsing PE File Headers with C++](https://ired.team/miscellaneous-reversing-forensics/pe-file-header-parser-in-c++)
- [Digging Into Handles, Callbacks & ObjectTypes](https://rayanfam.com/topics/reversing-windows-internals-part1/)

## Advanced Windows debugging

**Talks / video recordings**

- [Hacking Livestream #28: Windows Kernel Debugging Part I](https://www.youtube.com/watch?v=s5gOW-N9AAo)
- [Hacking Livestream #29: Windows Kernel Debugging Part II](https://www.youtube.com/watch?v=4Xo_FAx6P0A)
- [Hacking Livestream #30: Windows Kernel Debugging Part III](https://www.youtube.com/watch?v=7zTtVYjjquA)
- [WinDbg Basics for Malware Analysis](https://www.youtube.com/watch?v=QuFJpH3My7A)
- [Windows Debugging and Troubleshooting](https://www.youtube.com/watch?v=2rGS5fYGtJ4) 
- [CNIT 126 10: Kernel Debugging with WinDbg](https://www.youtube.com/watch?v=8sVZsxoCpSc)
- [Windows Kernel Debugging Part I](https://www.youtube.com/watch?v=s5gOW-N9AAo)
- [Microsoft Patch Analysis for Exploitation](https://www.youtube.com/watch?v=xMMQnok44IY)
- [Windows Kernel Debugging Fundamentals](https://app.pluralsight.com/library/courses/windows-debugging-fundamentals)

**Articles / papers**

- [Debug Tutorial Part 1: Beginning Debugging Using CDB and NTSD](https://www.codeproject.com/Articles/6469/Debug-Tutorial-Part-1-Beginning-Debugging-Using-CD)
- [Debug Tutorial Part 2: The Stack](https://www.codeproject.com/Articles/6470/Debug-Tutorial-Part-2-The-Stack)
- [Debug Tutorial Part 3: The Heap](https://www.codeproject.com/Articles/6489/Debug-Tutorial-Part-3-The-Heap)
- [Debug Tutorial Part 4: Writing WINDBG Extensions](https://www.codeproject.com/Articles/6522/Debug-Tutorial-Part-4-Writing-WINDBG-Extensions)
- [Debug Tutorial Part 5: Handle Leaks](https://www.codeproject.com/Articles/6988/Debug-Tutorial-Part-5-Handle-Leaks)
- [Debug Tutorial Part 6: Navigating The Kernel Debugge](https://www.codeproject.com/Articles/7913/Debug-Tutorial-Part-6-Navigating-The-Kernel-Debugg)
- [Debug Tutorial Part 7: Locks and Synchronization Objects](https://www.codeproject.com/Articles/7919/Debug-Tutorial-Part-7-Locks-and-Synchronization-Ob)
- [Getting Started with WinDbg - kernelmode](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-)
- [Windows Debuggers: Part 1: A WinDbg Tutorial](https://www.codeproject.com/Articles/6084/Windows-Debuggers-Part-1-A-WinDbg-Tutorial#_Toc64133674)

## 0days - APT advanced malware research

**Talks / video recordings**

- [W32.Duqu: The Precursor to the Next Stuxnet](https://www.youtube.com/watch?v=SbkXffokmPE)
- [Kernel Mode Threats and Practical Defenses](https://www.youtube.com/watch?v=BBJgKuXzfwc)
- [Selling 0-Days to Governments and Offensive Security Companies](https://www.youtube.com/watch?v=ZDHHGZlEfsQ)


**Malware Samples**

As far as advanced malware research is concerned i thought it fitting to include a sub-catagory here dedicated to publically
available Malware. Rootkits, Bootkits and related low level security and development items to be exact, not just for windows but other platforms as well. Find the list below.

##### Rootkits

- [Spectre](https://github.com/D4stiny/spectre)
- [Windows Hijack](https://github.com/thesecretclub/window_hijack)
- [SCShell](https://github.com/Mr-Un1k0d3r/SCShell)
- [Phys-MEM R/w](https://github.com/zouxianyu/PhysicalMemoryRW)
- [KernelHiddenExecute](https://github.com/zouxianyu/KernelHiddenExecute)
- [Gina_Public](https://github.com/isoadam/gina_public)
- [driverless-basic-driver](https://github.com/GayPig/driverless-basic-driver)
- [SMB Door](https://github.com/zerosum0x0/smbdoor)
- [BypassDriverDetection](https://github.com/KIDofot/BypassDriverDetection_And_Kill360Process)
- [UTK Module](https://github.com/longmode/UTKModule)
- [cheat-driver](https://github.com/nkga/cheat-driver)
- [HWIDFaker](https://github.com/lantaoxu/HWIDFaker)
- [puppetstrings](https://github.com/zerosum0x0/puppetstrings)
- [XHunter](https://github.com/Psychotropos/xhunter1_privesc)
- [ETR-Zero](https://github.com/HoShiMin/EnjoyTheRing0)
- [WinDriver x32](https://github.com/hackedteam/driver-win32)
- [WinDriver x64](https://github.com/hackedteam/driver-win64)
- [CSurage's Rootkit](https://github.com/csurage/Rootkit)
- [Greenkit Rootkit](https://github.com/Nervous/GreenKit-Rootkit)
- [R77-Rootkit](https://github.com/bytecode-77/r77-rootkit)
- [WinReg-Rootkit](https://github.com/Cr4sh/WindowsRegistryRootkit)
- [Multiple Windows Rootkits](https://github.com/Alifcccccc/Windows-Rootkits)
- [DRV-Hide](https://github.com/Cr4sh/DrvHide-PoC)
- [FakeMBR](https://github.com/MalwareTech/FakeMBR)
- [PTBBypass](https://github.com/Cr4sh/PTBypass-PoC)
- [KungFu-Malware](https://github.com/psaneme/Kung-Fu-Malware)
- [Trojan - Cockrroach](https://github.com/MinhasKamal/TrojanCockroach)

##### Bootkits

- [umap](https://github.com/btbd/umap)
- [rk2017](https://github.com/DeviceObject/rk2017)
- [ChangeDiskSector](https://github.com/DeviceObject/ChangeDiskSector)
- [Uefi_HelloWorld](https://github.com/DeviceObject/Uefi_HelloWorld)
- [ShitDrv](https://github.com/DeviceObject/ShitDrv)
- [DarkCloud](https://github.com/DeviceObject/DarkCloud)
- [Rovnix](https://github.com/nyx0/Rovnix)
- [TinyXPB](https://github.com/MalwareTech/TinyXPB)
- [Win64-Rovnix-VBR-Bootkit](https://github.com/m0n0ph1/Win64-Rovnix-VBR-Bootkit)
- [Gozi-MBR](https://github.com/NextSecurity/Gozi-MBR-rootkit)
- [vector-edk](https://github.com/NextSecurity/vector-edk)
- [booty](https://github.com/ahixon/booty)

--------------------------------------------------------------

**Articles / papers**

- [AcidBox: Rare Malware Repurposing Turla Group Exploit Targeted Russian Organizations](https://unit42.paloaltonetworks.com/acidbox-rare-malware/)
- [The zero-day exploits of Operation WizardOpium](https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/)
- [Zero-day exploit (CVE-2018-8453) used in targeted attacks](https://securelist.com/cve-2018-8453-used-in-targeted-attacks/88151/)
- [EternalBlue – Everything There Is To Know](https://research.checkpoint.com/2017/eternalblue-everything-know/)
- [Digging Into a Windows Kernel Privilege Escalation Vulnerability: CVE-2016-7255](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/digging-windows-kernel-privilege-escalation-vulnerability-cve-2016-7255/)

## Video game cheating (kernel mode stuff sometimes)

**Talks / video recordings**

- [Unveiling the Underground World of Anti-Cheats](https://www.youtube.com/watch?v=yJHyHU5UjTg)

**Articles / papers**

- [drvmap - driver manual mapper using capcom](https://www.unknowncheats.me/forum/anti-cheat-bypass/252685-drvmap-driver-manual-mapper-using-capcom.html)
- [All methods of retrieving unique identifiers(HWIDs) on your PC](https://www.unknowncheats.me/forum/anti-cheat-bypass/333662-methods-retrieving-unique-identifiers-hwids-pc.html)
- [Driver aka Kernel Mode cheating](https://www.unknowncheats.me/forum/anti-cheat-bypass/271733-driver-aka-kernel-mode.html)

## Hyper-V and VM / sandbox escape 

**Talks / video recordings**

- [Vulnerability Exploitation In Docker Container Environments](https://www.youtube.com/watch?v=77-jaeUKH7c)
- [Modern Exploitation of the SVGA Device for Guest-to-Host Escapes](https://www.youtube.com/watch?v=Y-G2WJ2cBKE)
- [REcon 2014 - Breaking Out of VirtualBox through 3D Acceleration](https://www.youtube.com/watch?v=i29bAx6W1uI)
- [36C3 - The Great Escape of ESXi](https://www.youtube.com/watch?v=XHDwsvywX50)
- [BlueHat v18 || Straight outta VMware](https://www.youtube.com/watch?v=o36N5wi_ZFs)
- [Hardening hyper-v through offensive security research](https://www.youtube.com/watch?v=8RCH0vFxWT4)
- [A Driver in to Hyper v Architecture&Vulnerabilities](https://www.youtube.com/watch?v=p28eTnKo8sw)
- [The HyperV Architecture and its Memory Manager](https://recon.cx/media-archive/2017/mtl/recon2017-mtl-10-andrea-allievi-The-HyperV-Architecture-and-its-Memory-Manager.mp4)
- [Ring 0 to Ring -1 Exploitation with Hyper-V IPC](https://www.youtube.com/watch?v=_NaRZvrs8xY)
- [Exploiting the Hyper-V IDE Emulator to Escape the Virtual Machine](https://www.youtube.com/watch?v=50xxJEODO3M)
- [A Dive in to Hyper-V Architecture & Vulnerabilities](https://www.youtube.com/watch?v=2bK_rC81_Eo)

**Articles / papers**

- [Hyper-V memory internals. EXO partition memory access](https://hvinternals.blogspot.com/2020/06/hyper-v-memory-internals-exo-partition.html)
- [Ventures into Hyper-V - Fuzzing hypercalls](https://labs.f-secure.com/blog/ventures-into-hyper-v-part-1-fuzzing-hypercalls)
- [Fuzzing para-virtualized devices in Hyper-V](https://msrc-blog.microsoft.com/2019/01/28/fuzzing-para-virtualized-devices-in-hyper-v/)
- [First Steps in Hyper-V Research](https://msrc-blog.microsoft.com/2018/12/10/first-steps-in-hyper-v-research/)
- [Windows Sandbox Attack Surface Analysis](https://googleprojectzero.blogspot.com/2015/11/windows-sandbox-attack-surface-analysis.html)

## Fuzzing

**Talks / video recordings**

- [HITBGSEC 2016 - Fuzzing The Windows Kernel](https://www.youtube.com/watch?v=X3YlDHTL5mA)
- [Windows Kernel Vulnerability Research and Exploitation](https://www.youtube.com/watch?v=aRZ5Wi-NWXs)
- [Bugs on the Windshield: Fuzzing the Windows Kernel](https://www.youtube.com/watch?v=-BkjkimINC8)
- [Windows Kernel Fuzzing for Intermediate Learners ](https://www.youtube.com/watch?v=wnNyPcerjJo)
- [Windows Kernel Fuzzing For Beginners - Ben Nagy](https://www.youtube.com/watch?v=FY-33TUKlqY)
- [Disobey 2018 - Building Windows Kernel fuzzer ](https://www.youtube.com/watch?v=mpXQvto4Vy4)
- [For The Win: The Art Of The Windows Kernel Fuzzing ](https://www.youtube.com/watch?v=9FPuKfwucsw)
- [RECON 2019 - Vectorized Emulation Putting it all together](https://www.youtube.com/watch?v=x4LPhwbTs9E)

**Articles / papers**

- [A year of Windows kernel font fuzzing #1: the results](https://googleprojectzero.blogspot.com/2016/06/a-year-of-windows-kernel-font-fuzzing-1_27.html)
- [A year of Windows kernel font fuzzing #2: the techniques](https://googleprojectzero.blogspot.com/2016/07/a-year-of-windows-kernel-font-fuzzing-2.html)

## Windows browser exploitation

**Talks / video recordings**

- [Digging for IE11 Sandbox Escapes Part 1](https://www.youtube.com/watch?v=q9dnYno_Moc)

-------------------------------------------------------

## Interesting Books

- Windows Internals, Part 1 (Pavel Yosifovich, and some others)
- Windows 10 System Programming, Part 1 (Pavel Yosifovich)
- Windows 10 System Programming, Part 2 (Pavel Yosifovich)
- Windows Kernel Programming (Pavel Yosifovich)
- Rootkits: Subverting the Windows Kernel 
- The Rootkit Arsenal
- Intel® 64 and IA-32 Architectures Software Developer Manuals

## Related certifications and courses

**Courses**
- Advanced Windows Exploitation (AWE)
- Sans 660
- Sans 760
- Corelan "Bootcamp" training
- Corelan "Advanced" training

**Certifications**
- Offensive Security Exploitation Expert (OSEE)
- Giac GXPN 

```