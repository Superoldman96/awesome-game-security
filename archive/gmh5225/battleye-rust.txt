Project Path: arc_gmh5225_battleye-rust_ysqmktb6

Source Tree:

```txt
arc_gmh5225_battleye-rust_ysqmktb6
├── Cargo.toml
├── LICENSE
├── README.md
├── battleye-rust.iml
├── examples
│   ├── listen_to_socket.rs
│   └── read_write_to_socket.rs
└── src
    ├── lib.rs
    ├── remote_console
    │   ├── com.rs
    │   ├── hash
    │   │   ├── checksum.rs
    │   │   └── mod.rs
    │   ├── mod.rs
    │   └── packet.rs
    └── socket
        ├── action.rs
        ├── mod.rs
        └── udp.rs

```

`Cargo.toml`:

```toml
[package]
name = "battleye-rust"
version = "1.0.0"
edition = "2021"
license = "MIT"
repository = "https://github.com/steffalon/battleye-rust"
readme = "README.md"
description = """
Simplify authentication, acknowledge automation, input validation and sending commands using BattlEye
RCON UDP connection.
"""
categories = ["authentication", "network-programming"]
keywords = ["battleye", "rcon", "library"]
rust-version = "1.56"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
crc32fast = "1.3.1"

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Simon Boerrigter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
![logo](https://i.imgur.com/jPesxDd.png)

# BattlEye Remote Control Rust

It is a modest BattlEye RCON library made in rust. This support developers to perform authentication, 
acknowledging packets and sending commands via UDP socket connection. There is an example how you can 
implement/use this library.

[![MIT licensed][mit-badge]][mit-url]

[mit-badge]: https://img.shields.io/badge/license-MIT-blue.svg
[mit-url]: https://github.com/steffalon/battleye-rust/blob/main/LICENSE

---

# Features

- [x] Authentication
- [x] Dispatch commands
- [x] Observe packets
- [x] Acknowledge logic after receiving a packet from the server
- [x] CRC-32 validation on every received packet
- [x] Keep alive connection method included
- [x] Non-blocking read & write to socket (See examples)
- [x] Error handling
- [x] Build self-testing

## Cargo dependencies

- crc32fast
```

`battleye-rust.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="RUST_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/examples" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
```

`examples/listen_to_socket.rs`:

```rs
use std::net::{Ipv4Addr, UdpSocket};
use std::sync::Arc;
use std::thread;
use std::thread::sleep;
use std::time::Duration;

use battleye_rust::remote_console::BERemoteConsole;
use battleye_rust::socket::udp::UdpSocketConnection;

#[allow(unused_must_use)]
fn main() {
    let ip = "127.0.0.1".to_string();
    let port = 2306;
    let password = "password".to_string();
    let udp_socket =
        UdpSocket::bind((Ipv4Addr::UNSPECIFIED, 0)).expect("Unable to bind an IP address");
    udp_socket.connect(ip.to_string() + ":" + &port.to_string());

    let be_remote_console: Arc<BERemoteConsole> =
        Arc::new(BERemoteConsole::new(UdpSocketConnection::new(udp_socket)));

    be_remote_console.authenticate(password);

    let keep_alive_socket = be_remote_console.clone();

    thread::spawn(move || loop {
        sleep(Duration::from_secs(35)); // BE recommends sending a keep alive packet before 45 seconds.
        keep_alive_socket.keep_alive();
    });

    thread::spawn(move || loop {
        sleep(Duration::from_millis(50)); // Reduce CPU workload
        let response = be_remote_console
            .receive_data()
            .expect("Failed to receive socket data");

        if response.is_empty() {
            continue;
        }

        // println!("{:#04X?}", response);

        match response[1] {
            0x00 => {
                if response[2] == 0x01 {
                    println!("Authentication accepted");
                } else {
                    println!("Password does not match with BattlEye config file");
                }
            }
            0x01 => {
                if response[2] == 0x00 {
                    println!(
                        "{}",
                        String::from_utf8(response[3..response.len()].to_owned()).unwrap()
                    );
                }
            }
            0x02 => {
                println!(
                    "{}",
                    String::from_utf8(response[3..response.len()].to_owned()).unwrap()
                );
            }
            _ => {
                println!("Unknown packet identifier");
            }
        }
    })
    .join();
}

```

`examples/read_write_to_socket.rs`:

```rs
use std::io::stdin;
use std::net::{Ipv4Addr, UdpSocket};
use std::sync::Arc;
use std::thread;
use std::thread::sleep;
use std::time::Duration;

use battleye_rust::remote_console::BERemoteConsole;
use battleye_rust::socket::udp::UdpSocketConnection;

#[allow(unused_must_use)]
fn main() {
    let ip = "127.0.0.1".to_string();
    let port = 2306;
    let password = "password".to_string();
    let udp_socket =
        UdpSocket::bind((Ipv4Addr::UNSPECIFIED, 0)).expect("Unable to bind an IP address");
    udp_socket.connect(ip.to_string() + ":" + &port.to_string());

    let be_remote_console: Arc<BERemoteConsole> =
        Arc::new(BERemoteConsole::new(UdpSocketConnection::new(udp_socket)));

    be_remote_console.authenticate(password);

    let socket_commands = be_remote_console.clone();
    let socket_keep_alive = be_remote_console.clone();

    thread::spawn(move || loop {
        sleep(Duration::from_secs(35));
        socket_keep_alive.keep_alive();
    });

    // Thread for terminal input
    thread::spawn(move || loop {
        let mut input_string = String::new();
        stdin()
            .read_line(&mut input_string)
            .expect("Did not enter a correct string");
        socket_commands.send_command(input_string.trim());
    });

    thread::spawn(move || loop {
        let response = be_remote_console
            .receive_data()
            .expect("Failed to receive socket data");

        if response.is_empty() {
            continue;
        }

        // println!("{:#04X?}", response);

        match response[1] {
            0x00 => {
                if response[2] == 0x01 {
                    println!("Authentication accepted.");
                } else {
                    println!("Password does not match with BattlEye config file.");
                }
            }
            0x01 => {
                if response[2] == 0x00 && response.len() > 3 {
                    println!(
                        "{}",
                        String::from_utf8(response[3..response.len()].to_owned()).unwrap()
                    );
                }
            }
            0x02 => {
                println!(
                    "{}",
                    String::from_utf8(response[3..response.len()].to_owned()).unwrap()
                );
            }
            _ => {
                println!("Unknown packet identifier.");
            }
        }
    })
    .join();
}

```

`src/lib.rs`:

```rs
pub mod remote_console;
pub mod socket;

```

`src/remote_console/com.rs`:

```rs
use crate::remote_console::hash::checksum::crc32::{msg_to_checksum_le_vec, validate};
use crate::remote_console::packet::packet_types;
use crate::socket::action::SocketAction;
use crate::socket::udp::UdpSocketConnection;
use std::io::{Error, ErrorKind};

pub struct BERemoteConsole {
    udp_socket: UdpSocketConnection,
}

impl BERemoteConsole {
    const HEADER_SIZE: usize = 519;

    /// Create new BERemoteConsole including a UDP socket
    pub fn new(udp_socket: UdpSocketConnection) -> BERemoteConsole {
        Self { udp_socket }
    }

    /// Authenticate to BattlEye remote console server. Result will only throw an error if there is
    /// no established connection to the server. Incorrect authentication results an expected
    /// value and therefore will not raise an error.
    pub fn authenticate(&self, password: String) -> std::io::Result<usize> {
        self.send_to_socket(
            packet_types::MESSAGE_TYPE_PACKET_LOGIN,
            password.as_bytes().to_vec(),
        )
    }

    /// Listen to socket and if and only if there is a response from the server, then the
    /// validation can start. Unused bytes gets truncated from buffer.
    ///
    /// After server response validation, gets validation has completed,
    ///
    /// This method relies on an established connection from socket. If the socket is not connected
    /// or lost connection to host, it will fail.
    ///
    /// This method ignores [`ErrorKind::WouldBlock`] and therefore an empty [`Vec`] gets returned.
    pub fn receive_data(&self) -> Result<Vec<u8>, Error> {
        match self.get_udp_socket().listen(Self::HEADER_SIZE) {
            Ok(mut response) => {
                // Clear unused 0x00 buffers
                for i in 9..response.len() {
                    if response[i].eq(&0x00) {
                        response.truncate(i);
                        break;
                    }
                }

                // Check if CRC-32 server response is valid
                if validate(&response) {
                    let ack = self.acknowledge_msg(response[8]);
                    if ack.is_err() {
                        return Err(ack.err().unwrap());
                    }
                    return Ok(response[6..response.len()].to_vec());
                }

                Err(Error::new(ErrorKind::InvalidData, "Invalid checksum"))
            }
            Err(err) if err.kind() != ErrorKind::WouldBlock => Err(err),
            _ => Ok(vec![]),
        }
    }

    /// In order to satisfy BattlEye remote console continues session, an acknowledge must be send
    /// after receiving any BattlEye responses.
    ///
    /// To acknowledge a message from the BattlEye server, [`BERemoteConsole::send_to_socket`] is used including the
    /// corresponding packet identifier.
    ///
    /// This method relies on an established connection from socket. If the socket is not connected
    /// or lost connection to host, it will fail.
    ///
    /// Return value is relayed from [`BERemoteConsole::send_to_socket`].
    fn acknowledge_msg(&self, sequence: u8) -> std::io::Result<usize> {
        self.send_to_socket(
            packet_types::MESSAGE_TYPE_PACKET_SERVER_MESSAGE,
            [sequence].to_vec(),
        )
    }

    /// Dispatch a command to server. Command gets composed to make it identifiable to BattlEye.
    ///
    /// This method relies on an established connection from socket. If the socket is not connected
    /// or lost connection to host, it will fail.
    pub fn send_command(&self, command: &str) -> std::io::Result<usize> {
        let mut command_body: Vec<u8> = vec![0];
        command_body.append(&mut command.as_bytes().to_vec());
        self.send_to_socket(packet_types::MESSAGE_TYPE_PACKET_COMMAND, command_body)
    }

    /// Communicate to BattlEye remote console server.
    ///
    /// Packet identifier and message gets merged into single vector containing bytes. Then CRC-32 checksum
    /// gets created and will be included inside the same vector.
    ///
    /// This method relies on an established connection from socket. If the socket is not connected
    /// or lost connection to host, it will fail.
    fn send_to_socket(&self, message_type_packet: u8, msg: Vec<u8>) -> std::io::Result<usize> {
        let mut assemble_packets: Vec<u8> = vec![0xFF, message_type_packet];
        assemble_packets.extend(msg);

        let mut crc32check = msg_to_checksum_le_vec(&assemble_packets); // Apply CRC-32 on message

        let mut data = packet_types::STATIC_HEADER.to_vec(); // Start header BE
        data.append(&mut crc32check); // CRC 32 hash
        data.append(&mut assemble_packets); // Regular packet array without CRC 32

        self.get_udp_socket().send(&data)
    }

    /// Get UDP socket from BERemoteConsole
    fn get_udp_socket(&self) -> &UdpSocketConnection {
        &self.udp_socket
    }

    /// Send keep alive packet to BattlEye remote console server. This will ensure the server to
    /// keep you subscribed.
    ///
    /// This method relies on an established connection from socket. If the socket is not connected
    /// or lost connection to host, it will fail.
    pub fn keep_alive(&self) -> std::io::Result<usize> {
        self.send_to_socket(packet_types::MESSAGE_TYPE_PACKET_COMMAND, vec![0x00])
    }
}

```

`src/remote_console/hash/checksum.rs`:

```rs
pub mod crc32 {
    /// Create CRC-32 checksum from an array of bytes.
    pub fn msg_to_checksum_le_vec(msg: &[u8]) -> Vec<u8> {
        crc32fast::hash(msg)
            .to_le_bytes() // Little endian for correct byte sequence
            .to_vec()
    }

    /// Validate an array of bytes using CRC-32. If CRC-32 checksum doesn't match with the CRC-32
    /// message, it will return false.
    pub fn validate(message: &[u8]) -> bool {
        let message_socket_response = &message[6..message.len()];
        if message_socket_response[0] == 0xFF {
            return msg_to_checksum_le_vec(message_socket_response).eq(&message[2..6]);
        }
        false
    }
}

#[cfg(test)]
mod crc_32_test {
    use super::*;

    #[test]
    fn msg_to_checksum() {
        let message: Vec<u8> = vec![0xFF, 0x01, 0x61, 0x62, 0x63, 0x64];
        assert_eq!(crc32::msg_to_checksum_le_vec(&message), [0xD2, 0x31, 0xA0, 0xA4])
    }

    #[test]
    fn validate_msg() {
        let message: Vec<u8> = vec![0x42, 0x45, 0x70, 0x8D, 0x77, 0x62, 0xFF, 0x01, 0x61];
        assert!(crc32::validate(&message));
    }
}

```

`src/remote_console/hash/mod.rs`:

```rs
pub(crate) mod checksum;

```

`src/remote_console/mod.rs`:

```rs
mod packet;

mod hash;

mod com;
pub use com::BERemoteConsole;

```

`src/remote_console/packet.rs`:

```rs
pub mod packet_types {
    pub const STATIC_HEADER: [u8; 2] = [0x42, 0x45]; // Required identifier ['B','E']

    pub const MESSAGE_TYPE_PACKET_LOGIN: u8 = 0x00;
    pub const MESSAGE_TYPE_PACKET_COMMAND: u8 = 0x01;
    pub const MESSAGE_TYPE_PACKET_SERVER_MESSAGE: u8 = 0x02; // Also required for acknowledging packets from remote
}

```

`src/socket/action.rs`:

```rs
use std::io::Error;

pub trait SocketAction {
    fn disconnect(&mut self) -> Result<(), Error>;
    fn listen(&self, buffer_size: usize) -> Result<Vec<u8>, Error>;
    fn send(&self, buffer_size: &[u8]) -> std::io::Result<usize>;
}

```

`src/socket/mod.rs`:

```rs
pub(crate) mod action;

pub mod udp;

```

`src/socket/udp.rs`:

```rs
use crate::socket::action::SocketAction;
use std::io::Error;
use std::net::{Ipv4Addr, UdpSocket};

pub struct UdpSocketConnection {
    udp_socket: UdpSocket,
}

impl SocketAction for UdpSocketConnection {
    /// Disconnect socket
    fn disconnect(&mut self) -> Result<(), Error> {
        self.udp_socket = UdpSocket::bind((Ipv4Addr::UNSPECIFIED, 0))?;
        Ok(())
    }

    /// Listen to socket. It will fail if socket is not connector or disconnected.
    fn listen(&self, buffer_size: usize) -> Result<Vec<u8>, Error> {
        let mut buffer_data = vec![0; buffer_size];
        self.udp_socket.recv(&mut buffer_data)?;
        Ok(buffer_data.to_vec())
    }

    /// Send bytes to server
    fn send(&self, data: &[u8]) -> std::io::Result<usize> {
        self.udp_socket.send(data)
    }
}

impl UdpSocketConnection {
    /// Create new UdpSocketConnection
    pub fn new(udp_socket: UdpSocket) -> Self {
        Self { udp_socket }
    }
}

```