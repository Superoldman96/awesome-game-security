Project Path: arc_gmh5225_BWSR_62vyntf4

Source Tree:

```txt
arc_gmh5225_BWSR_62vyntf4
├── Entitlements.plist
├── Example.c
├── Hook
│   ├── Assembler.c
│   ├── Assembler.h
│   ├── ImmediateDecoding.h
│   ├── InlineHook.c
│   └── InlineHook.h
├── Make
│   ├── android.mk
│   ├── darwin.mk
│   └── linux.mk
├── Makefile
├── Memory
│   ├── Memory.h
│   ├── MemoryAllocator.c
│   ├── MemoryAllocator.h
│   ├── MemoryTracker.c
│   └── MemoryTracker.h
├── README.md
├── SymbolResolve
│   ├── Darwin
│   │   ├── LCStrings.h
│   │   ├── Macho.c
│   │   └── Macho.h
│   └── Linux
│       ├── Elf.c
│       └── Elf.h
├── apple
│   ├── cs_blobs.h
│   └── dyld_cache_format.h
└── utility
    ├── debug.h
    ├── error.h
    └── utility.h

```

`Entitlements.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.skip-library-validation</key>
	<true/>
	<key>run-unsigned-code</key>
	<true/>
	<key>get-task-allow</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.get-task-allow</key>
	<true/>
	<key>com.apple.security.cs.disable-library-validation</key>
	<true/>
	<key>com.apple.security.cs.allow-unsigned-executable-memory</key>
	<true/>
	<key>com.apple.security.cs.disable-executable-page-protection</key>
	<true/>
	<key>com.apple.security.cs.allow-relative-library-loads</key>
	<true/>
	<key>com.apple.private.cs.debugger</key>
	<true/>
	<key>dynamic-codesigning</key>
	<true/>
</dict>
</plist>
```

`Example.c`:

```c

//------------------------------------------------------------------------------
//  INCLUDES
//------------------------------------------------------------------------------

#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>

#ifdef __APPLE__
    #include <mach/mach.h>
    #include <AudioToolbox/AudioUnit.h>
    #include "SymbolResolve/Darwin/Macho.h"
#else
    #include <sys/mman.h>
    #include <unistd.h>
    #include "SymbolResolve/Linux/Elf.h"
#endif

#include "utility/debug.h"
#include "utility/error.h"
#include "utility/utility.h"

#include "Hook/InlineHook.h"

#include "Memory/MemoryTracker.h"

#ifndef DEBUG_MODE
    #ifdef BWSR_DEBUG
        #undef BWSR_DEBUG
    #endif

    #define BWSR_DEBUG( LEVEL, ARGS... ) fprintf( stderr, ##ARGS );
#endif

//------------------------------------------------------------------------------
//  HOOK FUNCTIONS AND HOOK TYPES
//------------------------------------------------------------------------------

#ifdef __APPLE__
typedef int32_t
    ( *AudioUnitProcess_t )
    (
        AudioUnit                       inUnit,
        AudioUnitRenderActionFlags*     __nullable ioActionFlags,
        const AudioTimeStamp*           inTimeStamp,
        UInt32                          inNumberFrames,
        AudioBufferList*                ioData
    );
#endif


int hcreat( const char * files, mode_t modes )
{
    BWSR_DEBUG( LOG_CRITICAL,
                "SUCCESS! Caught creat()!: '%s'\n",
                files );
    __UNUSED( files, modes )
    return -1;
}

int hprintf( const char* text, ... )
{
    BWSR_DEBUG( LOG_CRITICAL,
                "SUCCESS! Caught printf() with text: '%s'\n",
                text );
    __UNUSED( text )
    return -1;
}

#ifdef __APPLE__
int32_t hAudioUnitProcess
    (
        AudioUnit                       inUnit,
        AudioUnitRenderActionFlags*     __nullable ioActionFlags,
        const AudioTimeStamp*           inTimeStamp,
        UInt32                          inNumberFrames,
        AudioBufferList*                ioData
    )
{
    BWSR_DEBUG( LOG_CRITICAL, "SUCCESS! Caught AudioUnitProcess()!\n" );
    __UNUSED( inUnit,
              ioActionFlags,
              inTimeStamp,
              inNumberFrames,
              ioData )
    return -1;
}
#endif

//------------------------------------------------------------------------------
//  CODESIGN CALLBACKS
//------------------------------------------------------------------------------

void
    BeforePageWriteCallbackFn
    (
        uintptr_t       PageAddress
    )
{
    BWSR_DEBUG( LOG_CRITICAL, "PageAddress: %" PRIuPTR "\n", PageAddress );
    __UNUSED( PageAddress )
    // Uneeded for most people
}

void
    AfterPageWriteCallbackFn
    (
        uintptr_t       PageAddress
    )
{
    BWSR_DEBUG( LOG_ALERT, "PageAddress: %" PRIuPTR "\n", PageAddress );
    __UNUSED( PageAddress )
    // Rehash Code Page
    // Rehash CDHash
    // CodeDirectory stuff :)
}

//------------------------------------------------------------------------------
//  EXAMPLES
//------------------------------------------------------------------------------

static
void
    EXAMPLE_hooking_creat
    (
        void
    )
{
    BWSR_InlineHook( creat, hcreat, NULL, BeforePageWriteCallbackFn, AfterPageWriteCallbackFn );
    BWSR_DEBUG( LOG_DEBUG, "Calling creat()\n" );

    int fd = creat( "/var/mobile/creat_test_file1.txt", S_IRWXG | S_IRWXU | S_IRWXO );

    if( 0 < fd )
    {
        BWSR_DEBUG( LOG_DEBUG, "FAILURE! creat() call went through!!!\n" );
        close( fd );
    }

    BWSR_DEBUG( LOG_DEBUG, "Unhooking creat()\n" );
    BWSR_DestroyHook( creat );
}

static
void
    EXAMPLE_hooking_printf
    (
        void
    )
{
    void* oldprintf = NULL;

    BWSR_InlineHook( printf, hprintf, &oldprintf, NULL, NULL );

    printf( "Testing printf of an integer: %d", 1 );

    if( NULL != oldprintf )
    {
        BWSR_DEBUG( LOG_CRITICAL, "Calling original printf(). Console should display!\n" );

        if( EOF == ((__typeof(printf)*)oldprintf)( "Testing the original version of printf with integer: %d!\n", 1 ) )
        {
            BWSR_DEBUG( LOG_CRITICAL, "FAILURE: Original printf() did not write any bytes to console!\n" );
        }
        else {
            BWSR_DEBUG( LOG_CRITICAL, "SUCCESS: Original printf() worked!\n" );
        }
    }
    else {
        BWSR_DEBUG( LOG_CRITICAL, "FAILURE: original printf() could not be called!\n" );
    }
}

#if defined( __APPLE__ )
void
    EXAMPLE_hooking_AudioUnitProcess
    (
        void
    )
{
    uintptr_t                       aup_address = 0;
    AudioUnit                       inUnit = NULL;
    AudioUnitRenderActionFlags*     ioActionFlags = NULL;
    const AudioTimeStamp*           inTimeStamp = NULL;
    UInt32                          inNumberFrames = 0;
    AudioBufferList*                ioData = NULL;

    BWSR_ResolveSymbol( "AudioUnitProcess", NULL, &aup_address );
    BWSR_InlineHook( (void*)aup_address, hAudioUnitProcess, NULL, BeforePageWriteCallbackFn, AfterPageWriteCallbackFn );

    AudioUnitProcess( inUnit, ioActionFlags, inTimeStamp, inNumberFrames, ioData );
}
#else
void
    EXAMPLE_linux_SymbolResolve
    (
        void
    )
{
    uintptr_t open_address = 0;
    BWSR_ResolveSymbol( "open", NULL, &open_address );

    BWSR_DEBUG( LOG_CRITICAL, "open address: %p\n", open );
    BWSR_DEBUG( LOG_CRITICAL, "resolved address: 0x%lx\n", open_address );
}
#endif


int main()
{

#ifndef DEBUG_MODE
    fprintf( stderr, "Example was made without DEBUG printing. Output will be limited!\n" );
#endif

    EXAMPLE_hooking_creat();

    EXAMPLE_hooking_printf();

#if defined( __APPLE__ )

    EXAMPLE_hooking_AudioUnitProcess();

#else

    EXAMPLE_linux_SymbolResolve();

#endif

    BWSR_DEBUG( LOG_CRITICAL, "Cleaning up all hooks\n" );

    // Clean up all hooks
    BWSR_DestroyAllHooks();

#if defined( DEBUG_MODE )

    size_t leaks = MemoryTracker_CheckForMemoryLeaks();
    BWSR_DEBUG( LOG_CRITICAL,
                "%zu memory leaks found!\n",
                leaks );

#endif
}

```

`Hook/Assembler.c`:

```c

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include "Hook/Assembler.h"
#include "Memory/MemoryTracker.h"

// -----------------------------------------------------------------------------
//  DEFINITIONS
// -----------------------------------------------------------------------------

// Destination Register - Register where the result of an operation is stored or where data is moved to.
#define Rd( rd )  ( rd->RegisterId << kRdShift  )
// Result Register - Load and store operations.
#define Rt( rt )  ( rt->RegisterId << kRtShift  )
// Source Register - Register from which data is read or used as an input for an operation.
#define Rn( rn )  ( rn->RegisterId << kRnShift  )

#define ARM64_TMP_REG_NDX_0 17

#define OPERAND_IMMEDIATE( IMMEDIATE ) (operand_t)                  \
{                                                                   \
    .Immediate              = IMMEDIATE,                            \
    .Register               = (register_data_t*) &InvalidRegister,  \
    .Shift                  = NO_SHIFT,                             \
    .ShiftExtendImmediate   = 0                                     \
}

// -----------------------------------------------------------------------------
//  GLOBALS
// -----------------------------------------------------------------------------

static const register_data_t InvalidRegister =
{
    .RegisterId     = 0,
    .RegisterSize   = 0,
    .RegisterType   = kInvalid
};

static const register_data_t TMP_REG_0 =
{
    .RegisterId     = ARM64_TMP_REG_NDX_0,
    .RegisterSize   = 64,
    .RegisterType   = kRegister_64
};

// -----------------------------------------------------------------------------
//  PROTOTYPES
// -----------------------------------------------------------------------------

/**
 * \brief Writes the given `InputBuffer` into `Buffer`.
 * \param[in,out]       Buffer              Memory buffer recieving `InputBuffer`
 * \param[in]           InputBuffer         Input buffer should be an Instruction.
 * \param[in]           InputBufferSize     The size of the instruction being written.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` or `InputBuffer` is `NULL`.
 * \retval `ERROR_INVALID_ARGUMENT_VALUE` if `InputBufferSize` is not greater than `0`.
 * \retval `ERROR_MEM_ALLOC` If reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with `InputBuffer`.
 * \warning `Buffer` may be reallocated if it cannot contain `InputBuffer`
 */
static
BWSR_STATUS
    INTERNAL_Assembler_WriteInstruction
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          uint8_t*                    InputBuffer,
        IN          int                         InputBufferSize
    );

/**
 * \brief Writes the encoded instruction for LDR into the provided `Buffer`
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Op                  LDR instruction.
 * \param[in]           Register            Load and store operations Register.
 * \param[in]           Immediate           Encoded Instruction.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` or `Result` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with `Immediate`.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_LoadRegisterLiteral
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          LoadRegLiteralOp            Op,
        IN          register_data_t*            Register,
        IN          int64_t                     Immediate
    );

/**
 * \brief `LDR` (Load Register) instruction is used to load data from memory
 * into a register.
 * This instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Register            Load and store instructions Register.
 * \param[in]           Immediate           Encoded Instruction.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` If `Buffer` or `Register` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` If the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with `Immediate`.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_LDR
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          int64_t                     Immediate
    );

/**
 * \brief `AddSubImmediate` refers to a specific type of instruction that allows
 * for conditional addition or subtraction of an immediate value to or from a register.
 * This instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Destination         Register where the result of an operation is stored or where data is moved to.
 * \param[in]           Source              Register from which data is read or used as an input for an operation.
 * \param[in]           Operand             Operand holding immediate value.
 * \param[in]           Op                  `ADD` or `SUB` literal fixed immediate in `32` or `64` bit.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer`, `Destination`, `Source`, or `Operand` is `NULL`
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded Instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_AddSubImmediate
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          const register_data_t*      Destination,
        IN          const register_data_t*      Source,
        IN          const operand_t*            Operand,
        IN          AddSubImmediateOp           Op
    );

/**
 * \brief `ADD` instructions are used to perform addition operations.
 * This `ADD` instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction
 * \param[in]           Destination         Register where the result of an operation is stored or where data is moved to.
 * \param[in]           Source              Register from which data is read or used as an input for an operation.
 * \param[in]           Immediate           Encoded instruction
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer`, `Destination`, or `Source` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded Instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_ADD
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          const register_data_t*      Destination,
        IN          const register_data_t*      Source,
        IN          int64_t                     Immediate
    );

/**
 * \brief Register operation size, 32 bits or 64 bits
 * \param[in]           Register            Register
 * \return `int32_t`
 * \retval `0` if register size is `32` bits.
 * \retval `INT32_MIN` if register size is `64` bits.
 */
static
int32_t
    INTERNAL_Assembler_OpEncode_SF
    (
        IN          const register_data_t*      Register
    );

/**
 * \brief `Move Wide` instruction allows for inserting a 16-bit immediate value
 * into a register at a specified bit position. This instruction is particularly
 * useful for constructing or modifying 64-bit values in `X` registers (64-bit)
 * or 32-bit values in `W` registers (32-bit).
 * This instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction
 * \param[in]           Register            Where the result of an operation is stored or where data is moved to.
 * \param[in]           Immediate           Encoded instruction
 * \param[in]           Shift               Shift of the encoded instructions. Expected as a multiple of `16`.
 * \param[in]           Op                  Move wide immediate fixed either `MOVZ` or `MOVK`
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` or `Destination` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_MoveWide
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    Immediate,
        IN          int                         Shift,
        IN          MoveWideImmediateOp         Op
    );

/**
 * \brief Resolves and updates references to instructions in `Buffer` based on `RelocationData`.
 * \param[in]           RelocationData      X
 * \param[in,out]       Buffer              B
 * \return `void`
 */
static
void
    INTERNAL_Assembler_LinkConfusedInstructions
    (
        IN          relocation_data_t*          RelocationData,
        IN  OUT     memory_buffer_t*            Buffer
    );

/**
 * \brief brief
 * \param[in]           Assembler           A
 * \param[in]           RelocationData      R
 * \return `void`
 */
static
void
    INTERNAL_Assembler_BindRelocationData
    (
        IN          assembler_t*                Assembler,
        IN          relocation_data_t*          RelocationData
    );

/**
 * \brief brief
 * \param[in,out]       RelocationData      R
 * \param[in]           LinkType            L
 * \param[in]           PCOffset            P
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `RelocationData` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if allocation of reference instruction fails.
 * \retval `ERROR_SUCCESS` if a reference instruction was added and updated.
 */
static
BWSR_STATUS
    INTERNAL_Assembler_LinkToOffset
    (
        IN  OUT     relocation_data_t*          RelocationData,
        IN          const int                   LinkType,
        IN          const size_t                PCOffset
    );

// -----------------------------------------------------------------------------
//  IMPLEMENTATION
// -----------------------------------------------------------------------------

static
BWSR_STATUS
    INTERNAL_Assembler_WriteInstruction
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          uint8_t*                    InputBuffer,
        IN          int                         InputBufferSize
    )
{
    BWSR_STATUS     retVal      = ERROR_SUCCESS;
    uint32_t        capacity    = 0;

    __NOT_NULL( Buffer, InputBuffer );
    __GREATER_THAN_0( InputBufferSize );

    if( ( Buffer->BufferSize + InputBufferSize ) > Buffer->BufferCapacity )
    {
        capacity = Buffer->BufferCapacity * 2;

        while( capacity < ( Buffer->BufferSize + InputBufferSize ) )
        {
            capacity *= 2;
        } // while()

        if( NULL == ( Buffer->Buffer = (uint8_t*) BwsrRealloc( Buffer->Buffer, capacity ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "BwsrRealloc() Failed\n" );
            Buffer->BufferSize = 0;
            retVal = ERROR_MEM_ALLOC;
        }
        else {
            Buffer->BufferCapacity = capacity;
        } // BwsrRealloc()
    } // Buffer->BufferCapacity

    if( ERROR_SUCCESS == retVal )
    {
        memcpy( ( Buffer->Buffer + Buffer->BufferSize ),
                InputBuffer,
                InputBufferSize );

        Buffer->BufferSize += InputBufferSize;
    } // ERROR_SUCCESS == retVal

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Assembler_LoadRegisterLiteral
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          LoadRegLiteralOp            Op,
        IN          register_data_t*            Register,
        IN          int64_t                     Immediate
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    uint32_t        encoding    = 0;

    __NOT_NULL( Buffer, Register )

    encoding    = ( Op
                    | BIT_SHIFT( ( Immediate >> 2 ), 26, 5 )
                    | Rt( Register ) );

    retVal  = Assembler_Write32BitInstruction( Buffer, encoding );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Assembler_LDR
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          int64_t                     Immediate
    )
{
    BWSR_STATUS         retVal      = ERROR_FAILURE;
    LoadRegLiteralOp    op          = LiteralLoadRegisterFixed;

    __NOT_NULL( Buffer, Register )

    switch( Register->RegisterType )
    {
        case kRegister_32:
        {
            op = LDR_w_literal;
            break;
        }

        case kRegister_X:
        {
            op = LDR_x_literal;
            break;
        }

        case kSIMD_FP_Register_S:
        {
            op = LDR_s_literal;
            break;
        }

        case kSIMD_FP_Register_D:
        {
            op = LDR_d_literal;
            break;
        }

        case kSIMD_FP_Register_Q:
        {
            op = LDR_q_literal;
            break;
        }

        default:
        {
            BWSR_DEBUG( LOG_WARNING, "This code should not be reachable!\n" );
            break;
        }
    }

    retVal = INTERNAL_Assembler_LoadRegisterLiteral( Buffer,
                                                     op,
                                                     Register,
                                                     Immediate );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Assembler_AddSubImmediate
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          const register_data_t*      Destination,
        IN          const register_data_t*      Source,
        IN          const operand_t*            Operand,
        IN          AddSubImmediateOp           Op
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    uint32_t        value       = 0;

    __NOT_NULL( Buffer,
                Destination,
                Source,
                Operand )

    if( 0 != Operand->Register->RegisterId )
    {
        retVal = ERROR_SUCCESS;
    }
    else {
        value   = ( Op
                    | Rd( Destination )
                    | Rn( Source )
                    | BIT_SHIFT( Operand->Immediate, 12, 10 ) );

        retVal  = Assembler_Write32BitInstruction( Buffer, value );
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Assembler_ADD
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          const register_data_t*      Destination,
        IN          const register_data_t*      Source,
        IN          int64_t                     Immediate
    )
{
    BWSR_STATUS         retVal      = ERROR_FAILURE;
    AddSubImmediateOp   op          = ADD_w_imm;

    __NOT_NULL( Buffer,
                Destination,
                Source )

    if( ( 64 == Destination->RegisterSize ) &&
        ( 64 == Source->RegisterSize      ) )
    {
        op = ADD_x_imm;
    }

    retVal = INTERNAL_Assembler_AddSubImmediate( Buffer,
                                                 Destination,
                                                 Source,
                                                 &OPERAND_IMMEDIATE( Immediate ),
                                                 op );

    return retVal;
}

static
int32_t
    INTERNAL_Assembler_OpEncode_SF
    (
        IN          const register_data_t*      Register
    )
{
    int32_t retVal = 0;

    __NOT_NULL_RETURN_0( Register )

    if( 64 == Register->RegisterSize )
    {
        retVal = INT32_MIN;
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Assembler_MoveWide
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    Immediate,
        IN          int                         Shift,
        IN          MoveWideImmediateOp         Op
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    uint32_t        value       = 0;

    __NOT_NULL( Buffer, Register )

    if( 0 < Shift )
    {
        Shift /= 16;
    }
    else {
        Shift = 0;
    }

    value   = ( MoveWideImmediateFixed
                | Op
                | INTERNAL_Assembler_OpEncode_SF( Register )
                | BIT_SHIFT( Shift,     2,  21 )
                | BIT_SHIFT( Immediate, 16,  5 )
                | Rd( Register ) );

    retVal = Assembler_Write32BitInstruction( Buffer, value );

    return retVal;
}

static
void
    INTERNAL_Assembler_LinkConfusedInstructions
    (
        IN          relocation_data_t*          RelocationData,
        IN  OUT     memory_buffer_t*            Buffer
    )
{
    int64_t     fixupOffset     = 0;
    uint32_t    instruction     = 0;
    uint32_t    newInstruction  = 0;
    size_t      i               = 0;

    __NOT_NULL_RETURN_VOID( RelocationData, Buffer )

    for( i = 0; i < RelocationData->ReferenceInstructionCount; ++i )
    {
        fixupOffset     = RelocationData->PcOffset - RelocationData->ReferenceInstructions[ i ].Offset;
        instruction     = *(int32_t*)( Buffer->Buffer + RelocationData->ReferenceInstructions[ i ].Offset );
        newInstruction  = 0;

        if( kLabelImm19 == RelocationData->ReferenceInstructions[ i ].LinkType )
        {
            SET_BITS( instruction,
                      5,
                      23,
                      GET_BITS( ( fixupOffset >> 2 ), 0, 18 ) );

            newInstruction = instruction;
        }

        *(int32_t*)( Buffer->Buffer + RelocationData->ReferenceInstructions[ i ].Offset ) = newInstruction;
    } // for()
}

static
void
    INTERNAL_Assembler_BindRelocationData
    (
        IN          assembler_t*                Assembler,
        IN          relocation_data_t*          RelocationData
    )
{
    __NOT_NULL_RETURN_VOID( Assembler, RelocationData );

    RelocationData->PcOffset = Assembler->Buffer.BufferSize;

    if( 0 != RelocationData->ReferenceInstructionCount )
    {
        INTERNAL_Assembler_LinkConfusedInstructions( RelocationData, &Assembler->Buffer );
    }
}

static
BWSR_STATUS
    INTERNAL_Assembler_LinkToOffset
    (
        IN  OUT     relocation_data_t*          RelocationData,
        IN          const int                   LinkType,
        IN          const size_t                PCOffset
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    size_t          refSize     = 0;

    __NOT_NULL( RelocationData )

    RelocationData->ReferenceInstructionCount++;
    refSize = RelocationData->ReferenceInstructionCount * sizeof( reference_instruct_t );

    if( NULL == RelocationData->ReferenceInstructions )
    {
        RelocationData->ReferenceInstructions = (reference_instruct_t*) BwsrMalloc( refSize );
    }
    else {
        RelocationData->ReferenceInstructions = (reference_instruct_t*) BwsrRealloc( RelocationData->ReferenceInstructions, refSize );
    } // RelocationData->ReferenceInstructions

    if( NULL == RelocationData->ReferenceInstructions )
    {
        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
        RelocationData->ReferenceInstructionCount = 0;
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        RelocationData->ReferenceInstructions[ RelocationData->ReferenceInstructionCount - 1 ].LinkType = LinkType;
        RelocationData->ReferenceInstructions[ RelocationData->ReferenceInstructionCount - 1 ].Offset   = PCOffset;
        retVal = ERROR_SUCCESS;
    } // RelocationData->ReferenceInstructions

    return retVal;
}

BWSR_STATUS
    Assembler_Initialize
    (
        IN          assembler_t*                Assembler,
        IN          uintptr_t                   FixedAddress
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Assembler )

    if( NULL == ( Assembler->Buffer.Buffer = (uint8_t*) BwsrMalloc( 64 ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        Assembler->FixedAddress             = FixedAddress;
        Assembler->Buffer.BufferSize        = 0;
        Assembler->Buffer.BufferCapacity    = 64;
        Assembler->RelocationData           = NULL;
        Assembler->RelocationDataSize       = 0;
        Assembler->RelocationDataCapacity   = 0;

        retVal = ERROR_SUCCESS;
    } // BwsrMalloc()

    return retVal;
}

BWSR_STATUS
    Assembler_CreateRelocationData
    (
        IN  OUT     relocation_data_t**         Relocation,
        IN          assembler_t*                Assembler,
        IN          uint64_t                    Data
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    relocation_data_t**     relocationData      = NULL;
    size_t                  capacity            = 0;
    size_t                  refSize             = 0;

    __NOT_NULL( Relocation, Assembler )
    __GREATER_THAN_0( Data )

    if( NULL == ( *Relocation = (relocation_data_t*) BwsrMalloc( sizeof( relocation_data_t ) ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        memcpy( ( *Relocation )->Data,
                &Data,
                sizeof( uint64_t ) );

        if( Assembler->RelocationDataSize >= Assembler->RelocationDataCapacity )
        {
            capacity = ( ( Assembler->RelocationDataCapacity == 0 )
                        ? 1
                        : ( Assembler->RelocationDataCapacity * 2 ) );
            refSize  = ( capacity * sizeof( relocation_data_t* ) );

            if( NULL == Assembler->RelocationData )
            {
                relocationData = (relocation_data_t**) BwsrMalloc( refSize );
            }
            else {
                relocationData = (relocation_data_t**) BwsrRealloc( Assembler->RelocationData, refSize );
            } // NULL == Assembler->RelocationData

            if( NULL == relocationData )
            {
                BwsrFree( *Relocation );
                capacity = 0;
                retVal = ERROR_MEM_ALLOC;
            }
            else {
                retVal = ERROR_SUCCESS;
            } // NULL == relocationData

            Assembler->RelocationData           = relocationData;
            Assembler->RelocationDataCapacity   = capacity;
        } // Assembler->RelocationDataSize

        if( ERROR_SUCCESS == retVal )
        {
            ( *Relocation )->DataSize                   = (uint8_t) sizeof( uint64_t );
            ( *Relocation )->ReferenceInstructionCount  = 0;
            ( *Relocation )->PcOffset                   = 0;
            ( *Relocation )->ReferenceInstructions      = NULL;

            Assembler->RelocationData[ Assembler->RelocationDataSize++ ] = *Relocation;
        }
    } // BwsrMalloc()

    return retVal;
}

BWSR_STATUS
    Assembler_WriteRelocationDataToPageBuffer
    (
        IN          assembler_t*                Assembler
    )
{
    BWSR_STATUS     retVal      = ERROR_SUCCESS;
    size_t          i           = 0;

    __NOT_NULL( Assembler )

    for( i = 0; ( i < Assembler->RelocationDataSize ) && ( ERROR_SUCCESS == retVal ); i++ )
    {
        INTERNAL_Assembler_BindRelocationData( Assembler, Assembler->RelocationData[ i ] );

        retVal = INTERNAL_Assembler_WriteInstruction( &Assembler->Buffer,
                                                      Assembler->RelocationData[ i ]->Data,
                                                      Assembler->RelocationData[ i ]->DataSize );
    } // for()

    return retVal;
}

BWSR_STATUS
    Assembler_Write32BitInstruction
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          uint32_t                    Value
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Buffer )

    retVal = INTERNAL_Assembler_WriteInstruction( Buffer,
                                                  (uint8_t*) &Value,
                                                  sizeof( uint32_t ) );

    return retVal;
}


BWSR_STATUS
    Assembler_LoadStore
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          LoadStoreOp                 Op,
        IN          const register_data_t*      Register,
        IN          const memory_operand_t*     Addr
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    int             scale       = 0;
    uint32_t        value       = 0;

    __NOT_NULL( Buffer,
                Register,
                Addr )

    if( AddrModeOffset != Addr->AddressMode )
    {
        retVal = ERROR_SUCCESS;
    }
    else {

        if( LoadStoreUnsignedOffsetFixed == ( Op & LoadStoreUnsignedOffsetFixed ) )
        {
            scale = GET_BITS( Op, 30, 31 );
        }

        value   = ( LoadStoreUnsignedOffsetFixed
                    | Op
                    | BIT_SHIFT( (int64_t)( Addr->Offset >> scale ), 12, 10 )
                    | ( Addr->Base.RegisterId << kRnShift )
                    | Rt( Register ) );
        retVal  = Assembler_Write32BitInstruction( Buffer, value );
    } // AddrModeOffset != Addr->AddressMode

    return retVal;
}

BWSR_STATUS
    Assembler_ADRP_ADD
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    From,
        IN          uint64_t                    To
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uint64_t        from_PAGE       = ALIGN_FLOOR( From, 0x1000 );
    uint64_t        to_PAGE         = ALIGN_FLOOR( To,   0x1000 );
    uint64_t        to_PAGEOFF      = (uint64_t) ( To  % 0x1000 );
    uint32_t        value           = 0;

    __NOT_NULL( Buffer, Register )
    __GREATER_THAN_0( From, To )

    value   = ( ADRP
                | Rd( Register )
                | BIT_SHIFT( GET_BITS( ( to_PAGE - from_PAGE ) >> 12, 0, 1  ), 2,  29 )
                | BIT_SHIFT( GET_BITS( ( to_PAGE - from_PAGE ) >> 12, 2, 20 ), 19,  5 ) );

    if( ERROR_SUCCESS != ( retVal = Assembler_Write32BitInstruction( Buffer, value ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assemble_adrp() Failed\n" );
    }
    else {
        retVal = INTERNAL_Assembler_ADD( Buffer,
                                         Register,
                                         Register,
                                         to_PAGEOFF );
    } // Assemble_adrp()

    return retVal;
}

BWSR_STATUS
    Assembler_MOV
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    Immediate
    )
{
    BWSR_STATUS     retVal  = ERROR_FAILURE;

    const uint32_t  w0      = (uint32_t)( Immediate &  0xffffffff );
    const uint32_t  w1      = (uint32_t)( Immediate >> 32         );
    const uint16_t  h0      = (uint16_t)( w0        &  0xffff     );
    const uint16_t  h1      = (uint16_t)( w0        >> 16         );
    const uint16_t  h2      = (uint16_t)( w1        &  0xffff     );
    const uint16_t  h3      = (uint16_t)( w1        >> 16         );

    __NOT_NULL( Buffer, Register )
    __GREATER_THAN_0( Immediate )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_Assembler_MoveWide( Buffer,
                                                                 Register,
                                                                 h0,
                                                                 0,
                                                                 MOVZ ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_Assembler_MoveWide() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_Assembler_MoveWide( Buffer,
                                                                     Register,
                                                                     h1,
                                                                     16,
                                                                     MOVK ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_Assembler_MoveWide() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = INTERNAL_Assembler_MoveWide( Buffer,
                                                                         Register,
                                                                         h2,
                                                                         32,
                                                                         MOVK ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "INTERNAL_Assembler_MoveWide() Failed\n" );
            }
            else {
                retVal = INTERNAL_Assembler_MoveWide( Buffer,
                                                      Register,
                                                      h3,
                                                      48,
                                                      MOVK );
            } // Assemble_movk()
        } // Assemble_movk()
    } // Assemble_movz()

    return retVal;
}

BWSR_STATUS
    Assembler_WriteInstruction_LDR
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          relocation_data_t*          RelocationData
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Buffer,
                Register,
                RelocationData )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_Assembler_LinkToOffset( RelocationData,
                                                                     kLabelImm19,
                                                                     Buffer->BufferSize ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_Assembler_LinkToOffset() Failed\n" );
    }
    else {
        retVal = INTERNAL_Assembler_LDR( Buffer,
                                         Register,
                                         0 );
    } // INTERNAL_Assembler_LinkToOffset()

    return retVal;
}

BWSR_STATUS
    Assembler_LiteralLdrBranch
    (
        IN  OUT     assembler_t*                Assembler,
        IN          uint64_t                    Address
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    relocation_data_t*      relocationData      = NULL;
    uint32_t                value               = 0;

    __NOT_NULL( Assembler )
    __GREATER_THAN_0( Address )

    if( ERROR_SUCCESS != ( retVal = Assembler_CreateRelocationData( &relocationData,
                                                                    Assembler,
                                                                    Address ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_CreateRelocationData() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = Assembler_WriteInstruction_LDR( &Assembler->Buffer,
                                                                        (register_data_t*) &TMP_REG_0,
                                                                        relocationData ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Assembler_WriteInstruction_LDR() Failed\n" );
        }
        else {
            value  = ( BR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
            retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, value );
        } // Assembler_WriteInstruction_LDR()
    } // Assembler_CreateRelocationData()

    if( ERROR_SUCCESS != retVal )
    {
        if( NULL != relocationData )
        {
            BwsrFree( relocationData );
        }
    } // ERROR_SUCCESS != retVal

    return retVal;
}

BWSR_STATUS
    Assembler_Release
    (
        IN  OUT     assembler_t*                Assembler
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Assembler )

    if( Assembler->RelocationData )
    {
        while( Assembler->RelocationDataSize-- )
        {
            BwsrFree( Assembler->RelocationData[ Assembler->RelocationDataSize ]->ReferenceInstructions );
            BwsrFree( Assembler->RelocationData[ Assembler->RelocationDataSize ] );
        } // while()

        BwsrFree( Assembler->RelocationData );
        Assembler->RelocationData = NULL;
    } // Assembler->RelocationData

    if( Assembler->Buffer.Buffer )
    {
        BwsrFree( Assembler->Buffer.Buffer );
        Assembler->Buffer.Buffer = NULL;
    } // Assembler->Buffer.Buffer

    if( Assembler->FixedMemoryRange )
    {
        BwsrFree( (void*)Assembler->FixedMemoryRange );
        Assembler->FixedMemoryRange = 0;
    } // Assembler->FixedMemoryRange

    retVal = ERROR_SUCCESS;

    return retVal;
}
```

`Hook/Assembler.h`:

```h

#ifndef __ASSEMBLER_H__
#define __ASSEMBLER_H__

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include "utility/debug.h"
#include "utility/error.h"
#include "utility/utility.h"

#include <stdint.h>
#include <stdlib.h>

// -----------------------------------------------------------------------------
//  ENUMS
// -----------------------------------------------------------------------------

typedef enum InstructionFields {
    kRdShift                            = 0,
    kRnShift                            = 5,
    kRtShift                            = 0,
} InstructionFields;

typedef enum UnconditionalBranchToRegisterOp {
    UnconditionalBranchToRegisterFixed  = 0xD6000000,
    BR                                  = UnconditionalBranchToRegisterFixed | 0x001F0000,
    BLR                                 = UnconditionalBranchToRegisterFixed | 0x003F0000,
} UnconditionalBranchToRegisterOp;

typedef enum RegisterType {
    kRegister_32,
    kRegister_W                         = kRegister_32,
    kRegister_64,
    kRegister_X                         = kRegister_64,
    kRegister,

    kVRegister,
    kSIMD_FP_Register_8,
    kSIMD_FP_Register_B                 = kSIMD_FP_Register_8,
    kSIMD_FP_Register_16,
    kSIMD_FP_Register_H                 = kSIMD_FP_Register_16,
    kSIMD_FP_Register_32,
    kSIMD_FP_Register_S                 = kSIMD_FP_Register_32,
    kSIMD_FP_Register_64,
    kSIMD_FP_Register_D                 = kSIMD_FP_Register_64,
    kSIMD_FP_Register_128,
    kSIMD_FP_Register_Q                 = kSIMD_FP_Register_128,

    kInvalid
} RegisterType;

typedef enum AddSubImmediateOp {
    AddSubImmediateFixed                = 0x11000000,
    ADD_w_imm                           = AddSubImmediateFixed | ( 0b00 << 31 ) | ( 0b00 << 30 ),
    SUB_w_imm                           = AddSubImmediateFixed | ( 0b00 << 31 ) | ( 0b01 << 30 ),
    ADD_x_imm                           = AddSubImmediateFixed | ( 0b01 << 31 ) | ( 0b00 << 30 ),
    SUB_x_imm                           = AddSubImmediateFixed | ( 0b01 << 31 ) | ( 0b01 << 30 ),
} AddSubImmediateOp;

typedef enum LoadRegLiteralOp {
    LiteralLoadRegisterFixed            = 0x18000000,
    LiteralLoadRegisterFixedMask        = 0x3B000000,
    LDR_w_literal                       = LiteralLoadRegisterFixed | ( 0b00 << 30 ) | ( 0b00 << 26 ),
    LDR_x_literal                       = LiteralLoadRegisterFixed | ( 0b01 << 30 ) | ( 0b00 << 26 ),
    LDR_s_literal                       = LiteralLoadRegisterFixed | ( 0b00 << 30 ) | ( 0b01 << 26 ),
    LDR_d_literal                       = LiteralLoadRegisterFixed | ( 0b01 << 30 ) | ( 0b01 << 26 ),
    LDR_q_literal                       = LiteralLoadRegisterFixed | ( 0b10 << 30 ) | ( 0b01 << 26 ),
} LoadRegLiteralOp;

typedef enum Shift {
    NO_SHIFT                            = -1,
    LSL                                 = 0x0,
    LSR                                 = 0x1,
    ASR                                 = 0x2,
    ROR                                 = 0x3,
    MSL                                 = 0x4
} Shift;

typedef enum MoveWideImmediateOp {
    MoveWideImmediateFixed              = 0x12800000,
    MOVZ                                = 0x40000000,
    MOVK                                = 0x60000000,
} MoveWideImmediateOp;

// Load/store
typedef enum LoadStoreOp {
    STR_x                               = ( 0b11 << 30 ) | ( 0b00 << 22 ),
    LDR_x                               = ( 0b11 << 30 ) | ( 0b01 << 22 ),
} LoadStoreOp;

typedef enum AddrMode {
    AddrModeOffset,
    AddrModePreIndex,
    AddrModePostIndex
} AddrMode;

typedef enum LoadStoreUnsignedOffset {
    LoadStoreUnsignedOffsetFixed        = 0x39000000,
} LoadStoreUnsignedOffset;

typedef enum PCRelAddressingOp {
    PCRelAddressingFixed                = 0x10000000,
    PCRelAddressingFixedMask            = 0x1F000000,
    PCRelAddressingMask                 = 0x9F000000,
    ADR                                 = PCRelAddressingFixed | 0x00000000,
    ADRP                                = PCRelAddressingFixed | 0x80000000,
} PCRelAddressingOp;

typedef enum ReferenceLinkType {
    kLabelImm19
} ReferenceLinkType;

// -----------------------------------------------------------------------------
//  STRUCTURES
// -----------------------------------------------------------------------------

typedef struct memory_buffer_t {
    uint8_t*                Buffer;
    uint32_t                BufferSize;
    uint32_t                BufferCapacity;
} memory_buffer_t;

typedef struct register_data_t {
    int                     RegisterId;
    int                     RegisterSize;
    RegisterType            RegisterType;
} register_data_t;

typedef struct reference_instruct_t {
    int                     LinkType;
    size_t                  Offset;
} reference_instruct_t;

typedef struct relocation_data_t {
    size_t                  ReferenceInstructionCount;
    reference_instruct_t*   ReferenceInstructions;
    uintptr_t               PcOffset;
    uint8_t                 Data[ 8 ];
    uint8_t                 DataSize;
} relocation_data_t;

typedef struct operand_t {
    int64_t                 Immediate;
    register_data_t*        Register;
    Shift                   Shift;
    int32_t                 ShiftExtendImmediate;
} operand_t;

typedef struct assembler_t {
    uintptr_t               FixedAddress;
    uintptr_t               FixedMemoryRange;
    memory_buffer_t         Buffer;
    relocation_data_t**     RelocationData;
    size_t                  RelocationDataSize;
    size_t                  RelocationDataCapacity;
} assembler_t;

typedef struct memory_operand_t {
    register_data_t         Base;
    int64_t                 Offset;
    AddrMode                AddressMode;
} memory_operand_t;

// -----------------------------------------------------------------------------
//  EXPORTED FUNCTIONS
// -----------------------------------------------------------------------------

/**
 * \brief Initializes an Assembler and allocates it it's buffer.
 * \param[in]           Assembler           A
 * \param[in]           FixedAddress        Start of the memory range.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Assembler` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if allocation of the `Assembler`'s buffer fails.
 * \retval `ERROR_SUCCESS` if `Assembler` was initialized and a buffer was created.
 * \warning This method allocates `Assembler->Buffer.Buffer`.
 */
BWSR_STATUS
    Assembler_Initialize
    (
        IN          assembler_t*                Assembler,
        IN          uintptr_t                   FixedAddress
    );

/**
 * \brief Allocates and initializes `RelocationData` and updates it's
 * contents with `Data`. This is then appended to the
 * `Assembler->RelocationData` array.
 * \param[in,out]       RelocationData      Stores `Data`.
 * \param[in]           Assembler           A
 * \param[in]           Data                Typically an address or label.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `RelocationData` or `Assembler` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if any memory allocation fails.
 * \retval `ERROR_SUCCESS` if `RelocationData` was allocated and initialized.
 * \warning This method allocates `RelocationData` and `Assembler->RelocationData`.
 */
BWSR_STATUS
    Assembler_CreateRelocationData
    (
        IN  OUT     relocation_data_t**         RelocationData,
        IN          assembler_t*                Assembler,
        IN          uint64_t                    Data
    );

/**
 * \brief Iterates through `Assembler->RelocationData` array, fixes up each
 * instruction, and then emits the instructions into `Assembler->Buffer`.
 * \param[in]           Assembler           A
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Assembler` is `NULL`.
 * \retval `ERROR_INVALID_ARGUMENT_VALUE` if `Assembler` contains relocation data with a size not greater than 0.
 * \retval `ERROR_MEM_ALLOC` if reallocation of `Assembler`'s buffer fails.
 * \retval `ERROR_SUCCESS` if `Assembler`'s buffer was updated.
 * \warning Through the call chain, `Assembler`'s buffer may be reallocated.
 */
BWSR_STATUS
    Assembler_WriteRelocationDataToPageBuffer
    (
        IN          assembler_t*                Assembler
    );

/**
 * \brief Writes a given `Value` as an instruction to `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Value               An instruction to emit into `Buffer`.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
BWSR_STATUS
    Assembler_Write32BitInstruction
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          uint32_t                    Value
    );

/**
 * \brief `LoadStore` instructions are used to load data from memory into
 * a register (Load) or store data from a register back into memory (Store).
 * These instructions are written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Op                  Expected to be either `STR` or `LDR`.
 * \param[in]           Register            Load and store operations Register.
 * \param[in]           Addr                Address mode, offset, and register id.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer`, `Result`, or `Addr` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
BWSR_STATUS
    Assembler_LoadStore
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          LoadStoreOp                 Op,
        IN          const register_data_t*      Register,
        IN          const memory_operand_t*     Addr
    );

/**
 * \brief `ADRP` (Address of Page) and `ADD` instructions are used together
 * to calculate the address of a large memory region. The `ADRP` instruction
 * computes the address of a 4KB page aligned with a specified memory address.
 * The `ADD` instruction is used to add an additional offset to the address
 * calculated by `ADRP`.
 * These instructions are written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Register            Where the result of an operation is stored or where data is moved to.
 * \param[in]           From                Start address.
 * \param[in]           To                  End address.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` or `Destination` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
BWSR_STATUS
    Assembler_ADRP_ADD
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    From,
        IN          uint64_t                    To
    );

/**
 * \brief `MOV` instruction is used to move (or copy) a value into a register.
 * This instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Register            Where the result of an operation is stored or where data is moved to.
 * \param[in]           Immediate           Immediate of encoded instruction.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer` or `Destination` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if the reallocation of `Buffer` fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
 */
BWSR_STATUS
    Assembler_MOV
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Register,
        IN          uint64_t                    Immediate
    );

/**
 * \brief `LDR` (Load Register) instruction is used to load data from memory
 * into a register.
 * This instruction is written into the provided `Buffer`.
 * \param[in,out]       Buffer              Buffer to emit instruction.
 * \param[in]           Result              Load and store instructions Register.
 * \param[in]           Relocation          Contains branching address or location of a specific label.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Buffer`, `Result`, or `Relocation` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if any allocation fails.
 * \retval `ERROR_SUCCESS` if `Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Buffer` may be reallocated.
*/
BWSR_STATUS
    Assembler_WriteInstruction_LDR
    (
        IN  OUT     memory_buffer_t*            Buffer,
        IN          register_data_t*            Result,
        IN          relocation_data_t*          Relocation
    );

/**
 * \brief `LDR` and `BR` instructions are used together to load a literal value
 * with an immediate offset and branch to a different part of the code or to a
 * specific label.
 * These instructions are written into the provided `Assembler->Buffer`.
 * \param[in,out]       Assembler           A
 * \param[in]           Address             Branching address or location of a specific label.
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Assembler` is `NULL`.
 * \retval `ERROR_MEM_ALLOC` if any allocation fails.
 * \retval `ERROR_SUCCESS` if `Assembler->Buffer` was updated with the encoded instruction.
 * \warning Through the call chain, `Assembler->Buffer` may be reallocated.
*/
BWSR_STATUS
    Assembler_LiteralLdrBranch
    (
        IN  OUT     assembler_t*                Assembler,
        IN          uint64_t                    Address
    );

/**
 * \brief Free all allocations held by the `Assembler` and resets all
 * references and data tracking variables.
 * \param[in,out]       Assembler           A
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Assembler` is `NULL`.
 * \retval `ERROR_SUCCESS` after all allocations are released.
 */
BWSR_STATUS
    Assembler_Release
    (
        IN  OUT     assembler_t*                Assembler
    );

#endif // __ASSEMBLER_H__
```

`Hook/ImmediateDecoding.h`:

```h

#ifndef __IMEDIATE_DECODING_H__
#define __IMEDIATE_DECODING_H__

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <stdint.h>
#include <stdlib.h>
#include "utility/utility.h"

// -----------------------------------------------------------------------------
//  STRUCTURES
// -----------------------------------------------------------------------------

struct {
    // Destination register
    uint32_t    Destination     : 5;
    // Upper immediate `19` bits
    uint32_t    ImmHi           : 19;
    // Must be 10000 == 0x10
    uint32_t    Dummy_0         : 5;
    // Lower immediate `2` bits
    uint32_t    ImmLo           : 2;
    // `0` for `ADR`. `1` for `ADRP`.
    uint32_t    Op              : 1;
} InstructionDecoder;

// -----------------------------------------------------------------------------
//  IMMEDIATE DECODING
// -----------------------------------------------------------------------------

/**
 * \brief Performs a sign extension
 * \param[in]       Extension       Value by the sign extension performed.
 * \param[in]       SignBit         Bit position of the sign bit (0-indexed).
 * \return `int64_t` sign-extended value of `Extension`.
 */
static inline
int64_t
    INTERNAL_SignExtend
    (
        IN          int64_t         Extension,
        IN          int             SignBit
    )
{
    int64_t     sign_mask       = 0;
    int64_t     extend          = 0;

    sign_mask   = ( 0 - GET_BIT( Extension, ( SignBit - 1 ) ) );
    extend      = ( Extension | ( ( sign_mask >> SignBit ) << SignBit ) );

    return extend;
}

/**
 * \brief Extract and calculate a 26-bit immediate offset from the
 * given instruction.
 * \return `int64_t` the calculated 64-bit offset.
 */
static inline
int64_t
    Imm26Offset
    (
        IN          uint32_t        Instruction
    )
{
    int64_t     offset      = 0;
    int64_t     imm26       = 0;

    imm26   = GET_BITS( Instruction, 0, 25 );
    offset  = ( imm26 << 2 );
    offset  = INTERNAL_SignExtend( offset, 28 );

    return offset;
}

/**
 * \brief Extract and calculate a 19-bit immediate offset from the
 * given instruction.
 * \return `int64_t` the calculated 64-bit offset.
 */
static inline
int64_t
    Imm19Offset
    (
        IN          uint32_t        Instruction
    )
{
    int64_t     offset      = 0;
    int64_t     imm19       = 0;

    imm19   = GET_BITS( Instruction, 5, 23 );
    offset  = ( imm19 << 2 );
    offset  = INTERNAL_SignExtend( offset, 21 );

    return offset;
}

/**
 * \brief Extract and calculate a 14-bit immediate offset from the
 * given instruction.
 * \return `int64_t` the calculated 64-bit offset.
 */
static inline
int64_t
    Imm14Offset
    (
        IN          uint32_t        Instruction
    )
{
    int64_t     offset      = 0;
    int64_t     imm14       = 0;

    imm14   = GET_BITS( Instruction, 5, 18 );
    offset  = ( imm14 << 2 );
    offset  = INTERNAL_SignExtend( offset, 16 );

    return offset;
}

/**
 * \brief Extract and calculate a combined offset from separate
 * high and low immediate values in the given instruction.
 * \return `int64_t` the calculated 64-bit offset.
 */
static inline
int64_t
    ImmHiImmLoOffset
    (
        IN          uint32_t        Instruction
    )
{
    int64_t imm = 0;

    *(uint32_t*) &InstructionDecoder = Instruction;

    imm = InstructionDecoder.ImmLo + ( InstructionDecoder.ImmHi << 2 );
    imm = INTERNAL_SignExtend( imm, 21 );

    return imm;
}

/**
 * \brief Extract and calculate a combined offset and left-shift
 * it by 12 bits from separate high and low immediate values in
 * the given instruction.
 * \return `int64_t` the calculated 64-bit offset.
 */
static inline
int64_t
    ImmHiImmLoZero12Offset
    (
        IN          uint32_t        Instruction
    )
{
    int64_t imm = 0;

    imm = ImmHiImmLoOffset( Instruction );
    imm = ( imm << 12 );

    return imm;
}

#endif // __IMEDIATE_DECODING_H__
```

`Hook/InlineHook.c`:

```c

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <limits.h>

#if defined( __APPLE__ )

    #if __has_feature( ptrauth_calls )
        #include <ptrauth.h>
    #endif

    #include <mach/mach.h>
    #include <mach/vm_page_size.h>
    #include <libkern/OSCacheControl.h>

    // Set to this task `mach_task_self()`
    #define MEM_PROT_TASK           mach_task_self(),

#else

    #include <unistd.h>
    #include <sys/mman.h>

    // Not used on Android/Linux
    #define MEM_PROT_TASK
    // Used for compatibility with OSX.
    // Set to `0`.
    #define KERN_SUCCESS 0

#endif

#include "Hook/InlineHook.h"
#include "Hook/Assembler.h"
#include "Hook/ImmediateDecoding.h"

#include "utility/utility.h"
#include "utility/error.h"

#include "Memory/MemoryTracker.h"
#include "Memory/MemoryAllocator.h"

#include "SymbolResolve/Darwin/Macho.h"

// Binary Warfare & System Reconnaissance

// -----------------------------------------------------------------------------
//  DEFINITIONS
// -----------------------------------------------------------------------------

// `W` register of size `32`
#define W( RegisterID ) (register_data_t)   \
{                                           \
    .RegisterId     = RegisterID,           \
    .RegisterSize   = 32,                   \
    .RegisterType   = kRegister_32          \
}

// `X` register of size `64`
#define X( RegisterID ) (register_data_t)   \
{                                           \
    .RegisterId     = RegisterID,           \
    .RegisterSize   = 64,                   \
    .RegisterType   = kRegister_64          \
}

#define MEMOP_ADDR( ADDRESS_MODE ) (memory_operand_t)   \
{                                                       \
    .Base           = TMP_REG_0,                        \
    .Offset         = 0,                                \
    .AddressMode    = ADDRESS_MODE                      \
}

#define ARM64_TMP_REG_NDX_0 17

// -----------------------------------------------------------------------------
//  ENUMS
// -----------------------------------------------------------------------------

typedef enum UnconditionalBranchOp {
    UnconditionalBranchFixed            = 0x14000000,
    UnconditionalBranchFixedMask        = 0x7C000000,
    UnconditionalBranchMask             = 0xFC000000,
    B                                   = UnconditionalBranchFixed | 0x00000000,
    BL                                  = UnconditionalBranchFixed | 0x80000000,
} UnconditionalBranchOp;

typedef enum CompareBranchOp {
    CompareBranchFixed                  = 0x34000000,
    CompareBranchFixedMask              = 0x7E000000,
} CompareBranchOp;

typedef enum ConditionalBranchOp {
    ConditionalBranchFixed              = 0x54000000,
    ConditionalBranchFixedMask          = 0xFE000000,
    ConditionalBranchMask               = 0xFF000010,
} ConditionalBranchOp;

typedef enum TestBranchOp {
    TestBranchFixed                     = 0x36000000,
    TestBranchFixedMask                 = 0x7E000000,
} TestBranchOp;

// -----------------------------------------------------------------------------
//  STRUCTURES
// -----------------------------------------------------------------------------

typedef struct intercept_routing_t      intercept_routing_t;
typedef struct interceptor_tracker_t    interceptor_tracker_t;

typedef struct trampoline_t {
    memory_range_t              Buffer;
} trampoline_t;

typedef struct relocation_context_t {
    uintptr_t                   Cursor;
    memory_range_t*             BaseAddress;
} relocation_context_t;

typedef struct interceptor_entry_t {
    uintptr_t                   HookFunctionAddress;
    uintptr_t                   Address;
    memory_range_t              Patched;
    memory_range_t              Relocated;
    intercept_routing_t*        Routing;
    uint8_t*                    OriginalCode;
} interceptor_entry_t;

typedef struct intercept_routing_t {
    interceptor_entry_t*        InterceptEntry;
    trampoline_t*               Trampoline;
    uintptr_t                   HookFunction;

#if defined( __APPLE__ )
    __typeof( vm_protect )*     MemoryProtectFn;
#elif defined( __ANDROID__ ) || defined( __linux__ )
    __typeof( mprotect )*       MemoryProtectFn;
#endif

    CallBeforePageWrite         BeforePageWriteFn;
    CallAfterPageWrite          AfterPageWriteFn;

} intercept_routing_t;

typedef struct interceptor_tracker_t {
    interceptor_entry_t*        Entry;
    interceptor_tracker_t*      Next;
    interceptor_tracker_t*      Previous;
} interceptor_tracker_t;

// -----------------------------------------------------------------------------
//  GLOBALS
// -----------------------------------------------------------------------------

static const register_data_t    TMP_REG_0           = X( ARM64_TMP_REG_NDX_0 );

static memory_allocator_t       gMemoryAllocator    = { 0 };

static interceptor_tracker_t    gInterceptorTracker =
{
    .Entry      = NULL,
    .Next       = &gInterceptorTracker,
    .Previous   = &gInterceptorTracker
};

// -----------------------------------------------------------------------------
//  PROTOTYPES
// -----------------------------------------------------------------------------

/**
 * TODO: Add documentation
 */

static
BWSR_STATUS
    INTERNAL_ApplyCodePatch
    (
        IN          const intercept_routing_t*  Routing,
        IN          const void*                 Address,
        IN          const uint8_t*              Buffer,
        IN          const uint32_t              BufferSize
    );

static
BWSR_STATUS
    INTERNAL_BackupOriginalCode
    (
        IN  OUT     interceptor_entry_t*        Entry
    );

static
BWSR_STATUS
    INTERNAL_Trampoline_Initialize
    (
        IN  OUT     trampoline_t**              Trampoline,
        IN          const uintptr_t             From,
        IN          const uintptr_t             To
    );

static
uintptr_t
    INTERNAL_GetContextCursor
    (
        IN          const relocation_context_t* Context
    );

static
BWSR_STATUS
    INTERNAL_CodeBuilder_ApplyAssemblerPagePatch
    (
        IN          const intercept_routing_t*  Routing,
        IN  OUT     assembler_t*                Assembler,
        OUT         memory_range_t*             MemRange
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_UnconditionalBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_LiteralLoadRegisterFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADR
    (
        IN          const relocation_context_t* Context,
        OUT         assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADRP
    (
        IN          const relocation_context_t* Context,
        OUT         assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_ConditionalBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_CompareBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_TestBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    );

static
BWSR_STATUS
    INTERNAL_CodeBuilder_AssembleBuffer
    (
        IN  OUT     assembler_t*                Assembler,
        IN  OUT     relocation_context_t*       Context
    );

static
BWSR_STATUS
    INTERNAL_CodeBuilder_AssembleAndPatch
    (
        IN          const intercept_routing_t*  Routing,
        IN  OUT     memory_range_t*             BaseAddress,
        OUT         memory_range_t*             Relocated,
        IN          const bool                  Branch
    );

static
BWSR_STATUS
    INTERNAL_InterceptRouting_Initialize
    (
        OUT         intercept_routing_t**       Routing,
        IN          interceptor_entry_t*        Entry,
        IN          uintptr_t                   FakeFunction
    );

static
BWSR_STATUS
    INTERNAL_ApplyTrampolineCodePatch
    (
        IN  OUT     intercept_routing_t*        Routing
    );

static
BWSR_STATUS
    INTERNAL_GenerateRelocatedCode
    (
        IN  OUT     intercept_routing_t*        Routing
    );

static
BWSR_STATUS
    INTERNAL_GenerateTrampoline
    (
        IN  OUT     intercept_routing_t*        Routing
    );

static
BWSR_STATUS
    INTERNAL_BuildRoutingAndActivateHook
    (
        IN  OUT     intercept_routing_t*        Routing
    );

static
BWSR_STATUS
    INTERNAL_InterceptorTracker_Initialize
    (
        OUT         interceptor_tracker_t**     Tracker
    );

static
void
    INTERNAL_MemoryAllocator_CheckInterceptorRelease
    (
        void
    );

static
void
    INTERNAL_InterceptorTracker_Release
    (
        IN  OUT     interceptor_tracker_t*      Tracker
    );

static
BWSR_STATUS
    INTERNAL_InterceptorEntry_Initialize
    (
        OUT         interceptor_entry_t**       Entry
    );

static
BWSR_STATUS
    INTERNAL_SetMemoryProtectionFunction
    (
        OUT         uintptr_t*                  MemoryProtectFn
    );

// -----------------------------------------------------------------------------
//  IMPLEMENTATION
// -----------------------------------------------------------------------------

static
BWSR_STATUS
    INTERNAL_ApplyCodePatch
    (
        IN          const intercept_routing_t*  Routing,
        IN          const void*                 Address,
        IN          const uint8_t*              Buffer,
        IN          const uint32_t              BufferSize
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    uint32_t        pageBoundary        = 0;
    uint32_t        crossOverBoundary   = 0;
    uintptr_t       crossOverPage       = 0;
    int             kRet                = 0;

    __NOT_NULL( Routing, Address, Buffer );
    __GREATER_THAN_0( BufferSize );

#if defined( __APPLE__ )
    uintptr_t       patchPage           = ALIGN_FLOOR( Address, vm_page_size );
    uintptr_t       remapDestPage       = patchPage;
#elif defined( __ANDROID__ ) || defined( __linux__ )
    int             vm_page_size        = (int) sysconf( _SC_PAGESIZE );
    uintptr_t       patchPage           = ALIGN_FLOOR( Address, vm_page_size );
    void*           remapDestPage       = (void*) patchPage;
#endif

    if( ( (uintptr_t)Address + BufferSize ) > ( patchPage + vm_page_size ) )
    {
        pageBoundary = ( patchPage + vm_page_size - (uintptr_t)Address );

        if( ERROR_SUCCESS != ( retVal = INTERNAL_ApplyCodePatch( Routing,
                                                                 (void*) Address,
                                                                 Buffer,
                                                                 pageBoundary ) ) )
        {
            // Must exit at this point.
        }
        else {
            crossOverPage       = (uintptr_t)Address + pageBoundary;
            crossOverBoundary   = BufferSize - pageBoundary;

            retVal = INTERNAL_ApplyCodePatch( Routing,
                                              (void*) crossOverPage,
                                              Buffer + pageBoundary,
                                              crossOverBoundary );
        } // INTERNAL_ApplyCodePatch()
    } // Cross over boundary

    if( 0 == pageBoundary )
    {
        if( NULL != Routing->BeforePageWriteFn )
        {
            Routing->BeforePageWriteFn( (uintptr_t)remapDestPage );
        }

        if( KERN_SUCCESS != ( kRet = Routing->MemoryProtectFn( MEM_PROT_TASK
                                                               remapDestPage,
                                                               vm_page_size,
#if defined( __APPLE__ )
                                                               false,
                                                               ( VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY ) ) ) )
#elif defined( __ANDROID__ ) || defined( __linux__ )
                                                               ( PROT_READ | PROT_WRITE | PROT_EXEC ) ) ) )
#endif
        {
            BWSR_DEBUG( LOG_ERROR, "Routing->VMProtect() Failed\n" );
            retVal = ERROR_MEMORY_PERMISSION;
        }
        else {
            memcpy( (void*) ( patchPage + ( (uint64_t)Address - (uint64_t)remapDestPage ) ),
                    Buffer,
                    BufferSize );

            if( KERN_SUCCESS != ( kRet = Routing->MemoryProtectFn( MEM_PROT_TASK
                                                                   remapDestPage,
                                                                   vm_page_size,
#if defined( __APPLE__ )
                                                                   false,
                                                                   ( VM_PROT_READ | VM_PROT_EXECUTE ) ) ) )
#elif defined( __ANDROID__ ) || defined( __linux__ )
                                                                   ( PROT_READ | PROT_EXEC ) ) ) )
#endif
            {
                BWSR_DEBUG( LOG_ERROR, "Routing->VMProtect() Failed\n" );
                retVal = ERROR_MEMORY_PERMISSION;
            }
            else {

                if( NULL != Routing->AfterPageWriteFn )
                {
                    Routing->AfterPageWriteFn( (uintptr_t)remapDestPage );
                }

                retVal = ERROR_SUCCESS;
            } // Routing->MemoryProtectFn()
        } // Routing->MemoryProtectFn()
    } // pageBoundary

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_BackupOriginalCode
    (
        IN  OUT     interceptor_entry_t*        Entry
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    uint8_t*        originalCode        = NULL;
    uint32_t        trampolineSize      = 0;

    __NOT_NULL( Entry );

    originalCode   = (uint8_t*) Entry->Address;
    trampolineSize = Entry->Patched.Size;

    if( NULL == ( Entry->OriginalCode = (uint8_t*) BwsrMalloc( trampolineSize ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        memcpy( Entry->OriginalCode,
                originalCode,
                trampolineSize );

        retVal = ERROR_SUCCESS;
    } // BwsrMalloc()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_Trampoline_Initialize
    (
        IN  OUT     trampoline_t**              Trampoline,
        IN          const uintptr_t             From,
        IN          const uintptr_t             To
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    assembler_t     assembler       = { 0 };
    uint64_t        distance        = 0;
    uint64_t        adrpRange       = 0;
    uint8_t*        buffer          = NULL;
    uint32_t        value           = 0;

    __NOT_NULL( Trampoline )
    __GREATER_THAN_0( From, To )

    if( ERROR_SUCCESS != ( retVal = Assembler_Initialize( &assembler, From ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_Initialize() Failed\n" );
    }
    else {
        distance    = llabs( (int64_t) ( From - To ) );
        adrpRange   = ( UINT32_MAX - 1 );

        if( distance < adrpRange )
        {
            if( ERROR_SUCCESS != ( retVal = Assembler_ADRP_ADD( &assembler.Buffer,
                                                                (register_data_t*) &TMP_REG_0,
                                                                From,
                                                                To ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "Assembler_ADRP_ADD() Failed\n" );
            }
            else {
                value  = ( BR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
                retVal = Assembler_Write32BitInstruction( &assembler.Buffer, value );
            } // Assembler_ADRP_ADD()
        }
        else {
            retVal = Assembler_LiteralLdrBranch( &assembler, (uint64_t)To );
        } // distance < adrp_range

        if( ERROR_SUCCESS == retVal )
        {
            if( ERROR_SUCCESS != ( retVal = Assembler_WriteRelocationDataToPageBuffer( &assembler ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "Assembler_WriteRelocationDataToPageBuffer() Failed\n" );
            }
            else {
                if( NULL == ( buffer = (uint8_t*) BwsrMalloc( assembler.Buffer.BufferSize ) ) )
                {
                    BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
                    retVal = ERROR_MEM_ALLOC;
                }
                else {
                    memcpy( buffer,
                            assembler.Buffer.Buffer,
                            assembler.Buffer.BufferSize );

                    if( NULL == ( *Trampoline = (trampoline_t*) BwsrMalloc( sizeof( trampoline_t ) ) ) )
                    {
                        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
                        BwsrFree( buffer );
                        retVal = ERROR_MEM_ALLOC;
                    }
                    else {
                        ( *Trampoline )->Buffer.Start = (uintptr_t)buffer;
                        ( *Trampoline )->Buffer.Size  = assembler.Buffer.BufferSize;
                    } // BwsrMalloc()
                } // BwsrMalloc()
            } // Assembler_WriteRelocationDataToPageBuffer()
        } // SUCCESS

        (void) Assembler_Release( &assembler );
    } // Assembler_Initialize()

    return retVal;
}

static
uintptr_t
    INTERNAL_GetContextCursor
    (
        IN          const relocation_context_t* Context
    )
{
    return (uintptr_t)( Context->BaseAddress->Start + ( Context->Cursor - Context->BaseAddress->Start ) );
}

static
BWSR_STATUS
    INTERNAL_CodeBuilder_ApplyAssemblerPagePatch
    (
        IN          const intercept_routing_t*  Routing,
        IN  OUT     assembler_t*                Assembler,
        OUT         memory_range_t*             MemoryRange
    )
{
    BWSR_STATUS         retVal      = ERROR_FAILURE;
    memory_range_t*     block       = NULL;

    __NOT_NULL( Routing,
                Assembler,
                MemoryRange )

    if( Assembler->FixedAddress )
    {
        retVal = ERROR_SUCCESS;
    }
    else {
        if( ERROR_SUCCESS != ( retVal = MemoryAllocator_AllocateExecutionBlock( &block,
                                                                                &gMemoryAllocator,
                                                                                Assembler->Buffer.BufferSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "MemoryAllocator_AllocateExecutionBlock() Failed\n" );
        }
        else {
            Assembler->FixedMemoryRange = (uintptr_t)block;
            Assembler->FixedAddress     = block->Start;
        } // MemoryAllocator_AllocateExecutionBlock()
    } // fixed_addr

    if( ERROR_SUCCESS == retVal )
    {
        BWSR_DEBUG( LOG_NOTICE, "Patching hooked function call into function address...\n" );

        if( ERROR_SUCCESS != ( retVal = INTERNAL_ApplyCodePatch( Routing,
                                                                 (void*) Assembler->FixedAddress,
                                                                 Assembler->Buffer.Buffer,
                                                                 Assembler->Buffer.BufferSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_ApplyCodePatch() Failed\n" );
        }
        else {
            MemoryRange->Start = Assembler->FixedAddress;
            MemoryRange->Size  = Assembler->Buffer.BufferSize;
        } // INTERNAL_ApplyCodePatch()
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_UnconditionalBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    uintptr_t               cursorOffset        = 0;
    relocation_data_t*      relocationData      = NULL;
    uint32_t                value               = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset = INTERNAL_GetContextCursor( Context ) + Imm26Offset( Instruction );

    if( ERROR_SUCCESS != ( retVal = Assembler_CreateRelocationData( &relocationData,
                                                                    Assembler,
                                                                    cursorOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_CreateRelocationData() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = Assembler_WriteInstruction_LDR( &Assembler->Buffer,
                                                                        (register_data_t*) &TMP_REG_0,
                                                                        relocationData ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Assembler_WriteInstruction_LDR() Failed\n" );
        }
        else {
            if( BL == ( Instruction & UnconditionalBranchMask ) )
            {
                value = ( BLR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
            }
            else {
                value = ( BR  | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
            } // BLR or BL

            retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, value );
        } // Assembler_WriteInstruction_LDR()
    } // Assembler_CreateRelocationData()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_LiteralLoadRegisterFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uintptr_t       cursorOffset    = 0;
    char            opc             = 0;
    int             rt              = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset = INTERNAL_GetContextCursor( Context ) + Imm19Offset( Instruction );
    rt  = GET_BITS( Instruction, 0,  4  );
    opc = GET_BITS( Instruction, 30, 31 );

    if( ERROR_SUCCESS != ( retVal = Assembler_MOV( &Assembler->Buffer,
                                                   (register_data_t*) &TMP_REG_0,
                                                   cursorOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_MOV() Failed\n" );
    }
    else {
        /**/ if( 0b00 == opc )
        {
            retVal = Assembler_LoadStore( &Assembler->Buffer,
                                          LDR_x,
                                          &W( rt ),
                                          &MEMOP_ADDR( AddrModeOffset ) );
        }
        else if( 0b01 == opc )
        {
            retVal = Assembler_LoadStore( &Assembler->Buffer,
                                          LDR_x,
                                          &X( rt ),
                                          &MEMOP_ADDR( AddrModeOffset ) );
        }
        else {
            BWSR_DEBUG( LOG_WARNING,
                        "Unexpected opcode: %c\n",
                        opc );
            retVal = ERROR_UNIMPLEMENTED;
        } // opcode
    } // Assembler_MOV()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADR
    (
        IN          const relocation_context_t* Context,
        OUT         assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uintptr_t       cursorOffset    = 0;
    int             rd              = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset = INTERNAL_GetContextCursor( Context ) + ImmHiImmLoOffset( Instruction );
    rd = GET_BITS( Instruction, 0, 4 );

    retVal = Assembler_MOV( &Assembler->Buffer,
                            &X( rd ),
                            cursorOffset );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADRP
    (
        IN          const relocation_context_t* Context,
        OUT         assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uintptr_t       cursorOffset    = 0;
    int             rd              = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset = INTERNAL_GetContextCursor( Context ) + ImmHiImmLoZero12Offset( Instruction );
    cursorOffset = arm64_trunc_page( cursorOffset );
    rd = GET_BITS( Instruction, 0, 4 );

    retVal = Assembler_MOV( &Assembler->Buffer,
                            &X( rd ),
                            cursorOffset );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_ConditionalBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    uintptr_t               cursorOffset        = 0;
    uint32_t                instruction         = 0;
    char                    bitSetPos           = 0;
    relocation_data_t*      relocationData      = NULL;
    uint32_t                value               = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset    = INTERNAL_GetContextCursor( Context ) + Imm19Offset( Instruction );
    instruction     = Instruction;
    bitSetPos       = GET_BITS( Instruction, 0, 3 ) ^ 1;

    SET_BITS( instruction, 0, 3, bitSetPos );
    SET_BITS( instruction, 5, 23, 3 );

    if( ERROR_SUCCESS != ( retVal = Assembler_CreateRelocationData( &relocationData,
                                                                    Assembler,
                                                                    cursorOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_CreateRelocationData() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, instruction ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Assembler_Write32BitInstruction() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = Assembler_WriteInstruction_LDR( &Assembler->Buffer,
                                                                            (register_data_t*) &TMP_REG_0,
                                                                            relocationData ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "Assembler_WriteInstruction_LDR() Failed\n" );
            }
            else {
                value  = ( BR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
                retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, value );
            } // Assembler_WriteInstruction_LDR()
        } // Assembler_Write32BitInstruction()
    } // Assembler_CreateRelocationData()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_CompareBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    uintptr_t               cursorOffset        = 0;
    uint32_t                instruction         = 0;
    char                    op                  = 0;
    relocation_data_t*      relocationData      = NULL;
    uint32_t                value               = 0;

    __NOT_NULL( Context, Assembler )
    __GREATER_THAN_0( Instruction )

    cursorOffset    = INTERNAL_GetContextCursor( Context ) + Imm19Offset( Instruction );
    instruction     = Instruction;
    op              = GET_BIT( Instruction, 24 ) ^ 1;

    SET_BIT( instruction, 24, op );
    SET_BITS( instruction, 5, 23, 3 );

    if( ERROR_SUCCESS != ( retVal = Assembler_CreateRelocationData( &relocationData,
                                                                    Assembler,
                                                                    cursorOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_CreateRelocationData() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, instruction ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Assembler_Write32BitInstruction() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = Assembler_WriteInstruction_LDR( &Assembler->Buffer,
                                                                            (register_data_t*) &TMP_REG_0,
                                                                            relocationData ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "Assembler_WriteInstruction_LDR() Failed\n" );
            }
            else {
                value  = ( BR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
                retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, value );
            } // Assembler_WriteInstruction_LDR()
        } // Assembler_Write32BitInstruction()
    } // Assembler_CreateRelocationData()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_WriteToBuffer_TestBranchFixed
    (
        IN          const relocation_context_t* Context,
        IN  OUT     assembler_t*                Assembler,
        IN          const uint32_t              Instruction
    )
{
    BWSR_STATUS             retVal              = ERROR_FAILURE;
    uintptr_t               cursorOffset        = 0;
    uint32_t                instruction         = 0;
    char                    op                  = 0;
    relocation_data_t*      relocationData      = NULL;
    uint32_t                value               = 0;

    __NOT_NULL( Context, Assembler );
    __GREATER_THAN_0( Instruction );

    cursorOffset    = INTERNAL_GetContextCursor( Context ) + Imm14Offset( Instruction );
    instruction     = Instruction;
    op              = GET_BIT( Instruction, 24 ) ^ 1;

    SET_BIT( instruction, 24, op );
    SET_BITS( instruction, 5, 18, 3 );

    if( ERROR_SUCCESS != ( retVal = Assembler_CreateRelocationData( &relocationData,
                                                                    Assembler,
                                                                    cursorOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_CreateRelocationData() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, instruction ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Assembler_Write32BitInstruction() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = Assembler_WriteInstruction_LDR( &Assembler->Buffer,
                                                                            (register_data_t*) &TMP_REG_0,
                                                                            relocationData ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "Assembler_WriteInstruction_LDR() Failed\n" );
            }
            else {
                value  = ( BR | ( ARM64_TMP_REG_NDX_0 << kRnShift ) );
                retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, value );
            } // Assembler_WriteInstruction_LDR()
        } // Assembler_Write32BitInstruction()
    } // Assembler_CreateRelocationData()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_CodeBuilder_AssembleBuffer
    (
        IN  OUT     assembler_t*                Assembler,
        IN  OUT     relocation_context_t*       Context
    )
{
    BWSR_STATUS     retVal          = ERROR_SUCCESS;
    uint32_t        instruction     = 0;

    __NOT_NULL( Assembler, Context );

    while( ( ( Context->Cursor - Context->BaseAddress->Start ) < Context->BaseAddress->Size ) &&
           ( ERROR_SUCCESS == retVal ) )
    {
        instruction = *(uint32_t *)INTERNAL_GetContextCursor( Context );

        if( UnconditionalBranchFixed == ( instruction & UnconditionalBranchFixedMask ) )
        {
            retVal = INTERNAL_WriteToBuffer_UnconditionalBranchFixed( Context,
                                                                      Assembler,
                                                                      instruction );
        }
        else if( LiteralLoadRegisterFixed == ( instruction & LiteralLoadRegisterFixedMask ) )
        {
            retVal = INTERNAL_WriteToBuffer_LiteralLoadRegisterFixed( Context,
                                                                      Assembler,
                                                                      instruction );
        }
        else if( ( PCRelAddressingFixed == ( instruction & PCRelAddressingFixedMask ) ) &&
                 ( ADR                  == ( instruction & PCRelAddressingMask      ) ) )
        {
            retVal = INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADR( Context,
                                                                      Assembler,
                                                                      instruction );
        }
        else if( ( PCRelAddressingFixed == ( instruction & PCRelAddressingFixedMask ) ) &&
                 ( ADRP                 == ( instruction & PCRelAddressingMask      ) ) )
        {
            retVal = INTERNAL_WriteToBuffer_PCRelAddressingFixed_ADRP( Context,
                                                                       Assembler,
                                                                       instruction );
        }
        else if( ConditionalBranchFixed == ( instruction & ConditionalBranchFixedMask ) )
        {
            retVal = INTERNAL_WriteToBuffer_ConditionalBranchFixed( Context,
                                                                    Assembler,
                                                                    instruction );
        }
        else if( CompareBranchFixed == ( instruction & CompareBranchFixedMask ) )
        {
            retVal = INTERNAL_WriteToBuffer_CompareBranchFixed( Context,
                                                                Assembler,
                                                                instruction );
        }
        else if( TestBranchFixed == ( instruction & TestBranchFixedMask ) )
        {
            retVal = INTERNAL_WriteToBuffer_TestBranchFixed( Context,
                                                             Assembler,
                                                             instruction );
        }
        else {
            retVal = Assembler_Write32BitInstruction( &Assembler->Buffer, instruction );
        }

        Context->Cursor += sizeof( uint32_t );
    } // while()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_CodeBuilder_AssembleAndPatch
    (
        IN          const intercept_routing_t*  Routing,
        IN  OUT     memory_range_t*             BaseAddress,
        OUT         memory_range_t*             Relocated,
        IN          const bool                  Branch
    )
{
    BWSR_STATUS             retVal          = ERROR_FAILURE;
    assembler_t             assembler       = { 0 };
    relocation_context_t    context         = { 0 };

    __NOT_NULL( Routing,
                BaseAddress,
                Relocated )

    context.BaseAddress = BaseAddress;
    context.Cursor      = BaseAddress->Start;

    if( ERROR_SUCCESS != ( retVal = Assembler_Initialize( &assembler, 0 ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "Assembler_Initialize() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_CodeBuilder_AssembleBuffer( &assembler, &context ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_CodeBuilder_AssembleBuffer() Failed\n" );
        }
        else {
            BaseAddress->Size = ( context.Cursor - context.BaseAddress->Start );

            // TODO: if last instr is unlink branch, ignore it
            if( true == Branch )
            {
                retVal = Assembler_LiteralLdrBranch( &assembler, INTERNAL_GetContextCursor( &context ) );
            }

            if( ERROR_SUCCESS == retVal )
            {
                if( ERROR_SUCCESS != ( retVal = Assembler_WriteRelocationDataToPageBuffer( &assembler ) ) )
                {
                    BWSR_DEBUG( LOG_ERROR, "Assembler_WriteRelocationDataToPageBuffer() Failed\n" );
                }
                else {
                    retVal = INTERNAL_CodeBuilder_ApplyAssemblerPagePatch( Routing,
                                                                           &assembler,
                                                                           Relocated );
                } // Assembler_WriteRelocationDataToPageBuffer()
            } // Assembler_LiteralLdrBranch()
        } // INTERNAL_CodeBuilder_AssembleBuffer()

        (void) Assembler_Release( &assembler );
    } // Assembler_Initialize()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_InterceptRouting_Initialize
    (
        OUT         intercept_routing_t**       Routing,
        IN          interceptor_entry_t*        Entry,
        IN          uintptr_t                   FakeFunction
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Routing, Entry )
    __GREATER_THAN_0( FakeFunction )

    if( NULL == ( *Routing = (intercept_routing_t*) BwsrMalloc( sizeof( intercept_routing_t ) ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "malloc() Failed\n" );
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_SetMemoryProtectionFunction( (uintptr_t*) &( *Routing )->MemoryProtectFn ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_SetMemoryProtectionFunction() Failed\n" );
            BwsrFree( *Routing );
        }
        else {
            ( *Routing )->InterceptEntry     = Entry;
            ( *Routing )->Trampoline         = NULL;
            ( *Routing )->HookFunction       = FakeFunction;
        } // INTERNAL_SetMemoryProtectionFunction()
    } // BwsrMalloc()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ApplyTrampolineCodePatch
    (
        IN  OUT     intercept_routing_t*        Routing
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    size_t          trampolineSize      = 0;
    uintptr_t       bufferStart         = 0;

    __NOT_NULL( Routing );

    trampolineSize  = Routing->Trampoline->Buffer.Size;
    bufferStart     = Routing->Trampoline->Buffer.Start;

    BWSR_DEBUG( LOG_NOTICE, "Patching Trampoline into Intercept Address...\n" );

    retVal = INTERNAL_ApplyCodePatch( Routing,
                                      (void*) Routing->InterceptEntry->Address,
                                      (uint8_t*) bufferStart,
                                      trampolineSize );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_GenerateRelocatedCode
    (
        IN  OUT     intercept_routing_t*        Routing
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    size_t          trampolineSize      = 0;
    uintptr_t       bufferStart         = 0;

    __NOT_NULL( Routing );

    trampolineSize  = Routing->Trampoline->Buffer.Size;
    bufferStart     = Routing->Trampoline->Buffer.Start;

    if( bufferStart == 0 )
    {
        BWSR_DEBUG( LOG_ERROR, "Routing failed. Cannot continue\n" );
        retVal = ERROR_ROUTING_FAILURE;
    }
    else {
        Routing->InterceptEntry->Patched.Start      = Routing->InterceptEntry->Address;
        Routing->InterceptEntry->Patched.Size       = trampolineSize;
        Routing->InterceptEntry->Relocated.Start    = 0;
        Routing->InterceptEntry->Relocated.Size     = 0;

        retVal = INTERNAL_CodeBuilder_AssembleAndPatch( Routing,
                                                        &Routing->InterceptEntry->Patched,
                                                        &Routing->InterceptEntry->Relocated,
                                                        true );

        if( ( ERROR_SUCCESS == retVal                                  ) &&
            ( 0             == Routing->InterceptEntry->Relocated.Size ) )
        {
            BWSR_DEBUG( LOG_ERROR, "Routing failed. Cannot continue\n" );
            retVal = ERROR_ROUTING_FAILURE;
        }
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_GenerateTrampoline
    (
        IN  OUT     intercept_routing_t*        Routing
    )
{
    BWSR_STATUS         retVal      = ERROR_FAILURE;
    const uintptr_t     from        = Routing->InterceptEntry->Address;
    const uintptr_t     to          = Routing->HookFunction;

    __NOT_NULL( Routing );

    retVal = INTERNAL_Trampoline_Initialize( &Routing->Trampoline,
                                             from,
                                             to );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_BuildRoutingAndActivateHook
    (
        IN  OUT     intercept_routing_t*        Routing
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Routing );

    if( ERROR_SUCCESS != ( retVal = INTERNAL_GenerateTrampoline( Routing ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_GenerateTrampoline() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_GenerateRelocatedCode( Routing ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_GenerateRelocatedCode() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = INTERNAL_BackupOriginalCode( Routing->InterceptEntry ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "INTERNAL_BackupOriginalCode() Failed\n" );
            }
            else {
                if( ERROR_SUCCESS != ( retVal = INTERNAL_ApplyTrampolineCodePatch( Routing ) ) )
                {
                    BWSR_DEBUG( LOG_ERROR, "INTERNAL_ApplyTrampolineCodePatch() Failed\n" );
                    BwsrFree( Routing->InterceptEntry->OriginalCode );
                }
            } // INTERNAL_BackupOriginalCode()
        } // INTERNAL_GenerateRelocatedCode()

        if( ERROR_SUCCESS != retVal )
        {
            BwsrFree( (void*) Routing->Trampoline->Buffer.Start );
            BwsrFree( Routing->Trampoline );
        }
    } // INTERNAL_GenerateTrampoline()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_InterceptorTracker_Initialize
    (
        OUT         interceptor_tracker_t**     Tracker
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( Tracker )

    if( NULL == ( *Tracker = (interceptor_tracker_t*) BwsrMalloc( sizeof( interceptor_tracker_t ) ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        if( NULL == ( ( *Tracker )->Entry = (interceptor_entry_t*) BwsrMalloc( sizeof( interceptor_entry_t ) ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
            retVal = ERROR_MEM_ALLOC;
            BwsrFree( *Tracker );
        }
        else {
            ( *Tracker )->Next                  = &gInterceptorTracker;
            ( *Tracker )->Previous              = gInterceptorTracker.Previous;
            gInterceptorTracker.Previous->Next  = *Tracker;
            gInterceptorTracker.Previous        = *Tracker;

            retVal = ERROR_SUCCESS;
        } // BwsrMalloc( InterceptorEntry )
    } // BwsrMalloc( InterceptorTracker )

    return retVal;
}

static
void
    INTERNAL_MemoryAllocator_CheckInterceptorRelease
    (
        void
    )
{
    if( gInterceptorTracker.Next == &gInterceptorTracker )
    {
        if( NULL != gMemoryAllocator.Allocators )
        {
            BwsrFree( gMemoryAllocator.Allocators );

            gMemoryAllocator.Allocators     = NULL;
            gMemoryAllocator.AllocatorCount = 0;
        } // Allocators
    } // gInterceptorTracker
}

static
void
    INTERNAL_InterceptorTracker_Release
    (
        IN  OUT     interceptor_tracker_t*      Tracker
    )
{
    __NOT_NULL_RETURN_VOID( Tracker );

    if( NULL != Tracker->Entry )
    {
        if( NULL != Tracker->Entry->Routing )
        {
            if( NULL != Tracker->Entry->Routing->Trampoline )
            {
                if( Tracker->Entry->Routing->Trampoline->Buffer.Start )
                {
                    BwsrFree( (void*)Tracker->Entry->Routing->Trampoline->Buffer.Start );
                } // Tracker->Entry->Routing->Trampoline->Buffer.Start

                BwsrFree( Tracker->Entry->Routing->Trampoline );
                Tracker->Entry->Routing->Trampoline = NULL;
            } // NULL != Tracker->Entry->Routing->Trampoline

            BwsrFree( Tracker->Entry->Routing );
            Tracker->Entry->Routing = NULL;
        } // NULL != Tracker->Entry->Routing

        if( NULL != Tracker->Entry->OriginalCode )
        {
            BwsrFree( Tracker->Entry->OriginalCode );
            Tracker->Entry->OriginalCode = NULL;
        } // NULL != Tracker->Entry->OriginalCode

        BwsrFree( Tracker->Entry );
    } // NULL != Tracker->Entry

    Tracker->Previous->Next     = Tracker->Next;
    Tracker->Next->Previous     = Tracker->Previous;
    Tracker->Next               = NULL;
    Tracker->Previous           = NULL;

    BwsrFree( Tracker );

    INTERNAL_MemoryAllocator_CheckInterceptorRelease();
}

static
BWSR_STATUS
    INTERNAL_InterceptorEntry_Initialize
    (
        OUT         interceptor_entry_t**       Entry
    )
{
    BWSR_STATUS             retVal          = ERROR_FAILURE;
    interceptor_tracker_t*  tracker         = NULL;

    __NOT_NULL( Entry )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_InterceptorTracker_Initialize( &tracker ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_InterceptorTracker_Initialize() Failed\n" );
    }
    else {
        *Entry = tracker->Entry;
    } // INTERNAL_InterceptorTracker_Initialize()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_SetMemoryProtectionFunction
    (
        OUT         uintptr_t*      MemoryProtectFn
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

#if defined( __APPLE__ )
    if( ERROR_SUCCESS != ( retVal = BWSR_ResolveSymbol( "vm_protect",
                                                        "dyld",
                                                        MemoryProtectFn ) ) )
    {
        retVal = BWSR_ResolveSymbol( "_vm_protect",
                                     "libsystem_kernel",
                                     MemoryProtectFn );
    } // BWSR_ResolveSymbol()
#else
    *MemoryProtectFn = (uintptr_t)mprotect;
    retVal = ERROR_SUCCESS;
#endif

    return retVal;
}

BWSR_API
BWSR_STATUS
    BWSR_InlineHook
    (
        IN          void*           Address,
        IN          void*           FakeFunction,
        IN  OUT     void**          Original,
        IN          void*           BeforePageWriteFn,
        IN          void*           AfterPageWriteFn
    )
{
    BWSR_STATUS             retVal      = ERROR_FAILURE;
    interceptor_entry_t*    entry       = NULL;
    intercept_routing_t*    routing     = NULL;

    __NOT_NULL( Address, FakeFunction )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_InterceptorEntry_Initialize( &entry ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_InterceptorEntry_Initialize() Failed\n" );
    }
    else {

#if __has_feature( ptrauth_calls )
        entry->Address              = (uintptr_t) ptrauth_strip( Address, ptrauth_key_asia );
        entry->HookFunctionAddress  = (uintptr_t) ptrauth_strip( FakeFunction, ptrauth_key_asia );
#else
        entry->Address              = (uintptr_t) Address;
        entry->HookFunctionAddress  = (uintptr_t) FakeFunction;
#endif

        if( ERROR_SUCCESS != ( retVal = INTERNAL_InterceptRouting_Initialize( &routing,
                                                                              entry,
                                                                              (uintptr_t) FakeFunction ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_InterceptRouting_Initialize() Failed\n" );
        }
        else {

            routing->AfterPageWriteFn  = (CallAfterPageWrite)AfterPageWriteFn;
            routing->BeforePageWriteFn = (CallBeforePageWrite)BeforePageWriteFn;

            if( ERROR_SUCCESS != ( retVal = INTERNAL_BuildRoutingAndActivateHook( routing ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "INTERNAL_BuildRoutingAndActivateHook() Failed\n" );
                BwsrFree( routing );
            }
            else {
                entry->Routing = routing;

                if( NULL != Original )
                {
                    *Original = (void*) entry->Relocated.Start;

#if __has_feature( ptrauth_calls )
                    *Original = (void*) ptrauth_strip( *Original, ptrauth_key_asia );
                    *Original = (void*) ptrauth_sign_unauthenticated( *Original, ptrauth_key_asia, 0 );
#endif

                }

                retVal = ERROR_SUCCESS;
            } // INTERNAL_BuildRoutingAndActivateHook()
        } // INTERNAL_InterceptRouting_Initialize()

        if( ERROR_SUCCESS != retVal )
        {
            if( gInterceptorTracker.Previous != &gInterceptorTracker )
            {
                INTERNAL_InterceptorTracker_Release( gInterceptorTracker.Previous );
            } // gInterceptorTracker
        } // deinit
    } // INTERNAL_InterceptorEntry_Initialize()

    __DEBUG_RETVAL( retVal );
    return retVal;
}

BWSR_API
BWSR_STATUS
    BWSR_DestroyHook
    (
        IN          void*           Address
    )
{
    BWSR_STATUS             retVal      = ERROR_FAILURE;
    interceptor_tracker_t*  tracker     = gInterceptorTracker.Next;

    __NOT_NULL( Address )

    retVal = ERROR_NOT_FOUND;

    while( ( tracker         != &gInterceptorTracker ) &&
           ( ERROR_NOT_FOUND == retVal               ) )
    {
        if( NULL != tracker->Entry )
        {
            if( tracker->Entry->Patched.Start == (uintptr_t)Address )
            {
                retVal = INTERNAL_ApplyCodePatch( tracker->Entry->Routing,
                                                  (void*) tracker->Entry->Patched.Start,
                                                  tracker->Entry->OriginalCode,
                                                  tracker->Entry->Patched.Size );

                INTERNAL_InterceptorTracker_Release( tracker );
            }
        }

        tracker = tracker->Next;
    } // while()

    INTERNAL_MemoryAllocator_CheckInterceptorRelease();

    return retVal;
}

BWSR_API
void
    BWSR_DestroyAllHooks
    (
        void
    )
{
    interceptor_tracker_t* tracker = gInterceptorTracker.Next;

    while( tracker != &gInterceptorTracker && tracker != NULL )
    {
        if( NULL != tracker->Entry )
        {
            (void) INTERNAL_ApplyCodePatch( tracker->Entry->Routing,
                                            (void*) tracker->Entry->Patched.Start,
                                            tracker->Entry->OriginalCode,
                                            tracker->Entry->Patched.Size );

            INTERNAL_InterceptorTracker_Release( tracker );
        } // tracker->Entry

        tracker = gInterceptorTracker.Next;
    } // while()

    if( NULL != gMemoryAllocator.Allocators )
    {
        BwsrFree( gMemoryAllocator.Allocators );

        gMemoryAllocator.Allocators     = NULL;
        gMemoryAllocator.AllocatorCount = 0;
    } // gMemoryAllocator.Allocators
}
```

`Hook/InlineHook.h`:

```h

#ifdef __cplusplus
extern "C" {
#endif

typedef void
    ( *CallBeforePageWrite )
    (
        uintptr_t   AlignedPageAddress
    );

typedef void
    ( *CallAfterPageWrite )
    (
        uintptr_t   AlignedPageAddress
    );

int
    BWSR_InlineHook
    (
        void*       Address,
        void*       HookFunction,
        void**      OutOriginalFunction,
        void*       BeforePageWriteFn,
        void*       AfterPageWriteFn
    );

int
    BWSR_DestroyHook
    (
        void*       Address
    );

void
    BWSR_DestroyAllHooks
    (
        void
    );

#ifdef __cplusplus
}
#endif
```

`Make/android.mk`:

```mk

ifdef ANDROID_NDK

PLATFORM :=

ifeq ($(UNAME),Darwin)
$(eval PLATFORM := darwin)
else ifeq ($(UNAME),Linux)
$(eval PLATFORM := linux)
endif

ANDROID_TOOLCHAIN   := $(ANDROID_NDK)/toolchains/llvm/prebuilt/$(PLATFORM)-x86_64/bin/clang
ANDROID_SYSROOT     := $(ANDROID_NDK)/toolchains/llvm/prebuilt/$(PLATFORM)-x86_64/sysroot
AR_android          := $(ANDROID_NDK)/toolchains/llvm/prebuilt/$(PLATFORM)-x86_64/bin/llvm-ar

ANDROID_ARCH_FLAGS  := -target aarch64-none-linux-android30
ANDROID_ARCHS       := arm64
ANDROID_PLATFORMS   := android

ANDROID_DIRS :=                     \
    Memory                          \
    Hook                            \
    SymbolResolve/Linux

EXAMPLE_LDFLAGS_android :=          \
    -pie                            \
    -llog                           \
    -I.                             \
    $(ANDROID_ARCH_FLAGS)

ANDROID_GCCFLAGS :=                 \
    $(ANDROID_ARCH_FLAGS)           \
    -Os                             \
    -Wall                           \
    -Wextra                         \
    -Werror                         \
    --sysroot=$(ANDROID_SYSROOT)

GCCFLAGS_android_debug :=           \
    $(ANDROID_GCCFLAGS)             \
    -DDEBUG_MODE

GCCFLAGS_android_release := $(ANDROID_GCCFLAGS)

GCC_android := $(ANDROID_TOOLCHAIN)

android_example_release:                    \
    build/android/release/arm64/Example

android_example_debug:                      \
    build/android/debug/arm64/Example

android_release:                            \
    build/android/release/arm64/libBwsrHook

android_debug:                              \
    build/android/debug/arm64/libBwsrHook

else

android_example_release:
android_example_debug:
android_release:
android_debug:

endif

```

`Make/darwin.mk`:

```mk

ifeq ($(UNAME),Darwin)

GCC_BIN_ios  := $(shell xcrun --sdk iphoneos --find clang)
SDK_ios      := $(shell xcrun --sdk iphoneos --show-sdk-path)
AR_ios       := $(shell xcrun --sdk iphoneos --find ar)

GCC_BIN_mac  := $(shell xcrun --sdk macosx --find clang)
SDK_mac      := $(shell xcrun --sdk macosx --show-sdk-path)
AR_mac       := $(shell xcrun --sdk macosx --find ar)

DARWIN_ARCHS := arm64 arm64e

DARWIN_PLATFORMS := ios mac

DARWIN_DIRS :=                  \
    Memory                      \
    Hook                        \
    SymbolResolve/Darwin

DARWIN_GCCFLAGS :=              \
    -Os                         \
    -Wall                       \
    -Wextra                     \
    -Werror                     \
    -Wimplicit

GCCFLAGS_mac_debug :=           \
    $(DARWIN_GCCFLAGS)          \
    -DDEBUG_MODE

GCCFLAGS_ios_debug :=           \
    $(DARWIN_GCCFLAGS)          \
    -DDEBUG_MODE

EXAMPLE_LDFLAGS_ios :=                          \
    -F$(SDK_ios)/System/Library/Frameworks/     \
    -framework CoreFoundation                   \
    -framework AudioToolbox                     \
    -mios-version-min=14.0

EXAMPLE_LDFLAGS_mac :=                          \
    -F$(SDK_mac)/System/Library/Frameworks/     \
    -framework CoreFoundation                   \
    -framework AudioToolbox

GCCFLAGS_mac_release := $(DARWIN_GCCFLAGS)
GCCFLAGS_ios_release := $(DARWIN_GCCFLAGS)

GCC_mac := $(GCC_BIN_mac) -isysroot $(SDK_mac)
GCC_ios := $(GCC_BIN_ios) -isysroot $(SDK_ios) -mios-version-min=14.0

mac_example_release:                                \
    $(BUILD_DIR)/mac/release/arm64/Example          \
    $(BUILD_DIR)/mac/release/arm64e/Example

mac_example_debug:                                  \
    $(BUILD_DIR)/mac/debug/arm64/Example            \
    $(BUILD_DIR)/mac/debug/arm64e/Example

ios_example_release:                                \
    $(BUILD_DIR)/ios/release/arm64/Example          \
    $(BUILD_DIR)/ios/release/arm64e/Example

ios_example_debug:                                  \
    $(BUILD_DIR)/ios/debug/arm64/Example            \
    $(BUILD_DIR)/ios/debug/arm64e/Example

mac_release:                                        \
    $(BUILD_DIR)/mac/release/arm64/libBwsrHook      \
    $(BUILD_DIR)/mac/release/arm64e/libBwsrHook

mac_debug:                                          \
    $(BUILD_DIR)/mac/debug/arm64/libBwsrHook        \
    $(BUILD_DIR)/mac/debug/arm64e/libBwsrHook

ios_release:                                        \
    $(BUILD_DIR)/ios/release/arm64/libBwsrHook      \
    $(BUILD_DIR)/ios/release/arm64e/libBwsrHook

ios_debug:                                          \
    $(BUILD_DIR)/ios/debug/arm64/libBwsrHook        \
    $(BUILD_DIR)/ios/debug/arm64e/libBwsrHook

else

mac_example_release:
mac_example_debug:
ios_example_release:
ios_example_debug:
mac_release:
mac_debug:
ios_release:
ios_debug:

endif

```

`Make/linux.mk`:

```mk

CLANG_ARCH   :=
UNAME        := $(shell uname -s)

ifeq ($(UNAME),Linux)

LINUX_TOOLCHAIN := clang
AR_linux        := ar
LINUX_ARCHS     := arm64
LINUX_PLATFORMS := linux

LINUX_DIRS :=               \
	Memory                  \
	Hook					\
	SymbolResolve/Linux

LINUX_GCCFLAGS :=           \
	-Os                     \
	-Wall                   \
	-Wextra                 \
	-Werror

EXAMPLE_LDFLAGS_linux :=

GCCFLAGS_linux_debug :=     \
	$(LINUX_GCCFLAGS)       \
	-DDEBUG_MODE

GCCFLAGS_linux_release := $(LINUX_GCCFLAGS)
GCC_linux := $(LINUX_TOOLCHAIN)

$(eval CLANG_ARCH := $(shell clang -dumpmachine | cut -d '-' -f 1))

endif

ifeq ($(CLANG_ARCH),aarch64)

linux_example_release:                              \
	$(BUILD_DIR)/linux/release/arm64/Example

linux_example_debug:                                \
	$(BUILD_DIR)/linux/debug/arm64/Example

linux_release:                                      \
	$(BUILD_DIR)/linux/release/arm64/libBwsrHook

linux_debug:                                        \
	$(BUILD_DIR)/linux/debug/arm64/libBwsrHook

else

linux_example_release:
linux_example_debug:
linux_release:
linux_debug:

endif

```

`Makefile`:

```

UNAME       := $(shell uname -s)
BUILD_DIR   := build

include Make/darwin.mk
include Make/linux.mk
include Make/android.mk

DEPLOYMENTS :=  \
    debug       \
    release

define platform_rules
# Source files
SRCS_$(1) := $(foreach dir,                         \
               $(4),                                \
               $(wildcard $(dir)/*.c))

OBJS_$(1) := $$(patsubst %.c,                       \
                $$(BUILD_DIR)/$(1)/$(3)/$(2)/%.o,   \
                $$(SRCS_$(1)))

# Compiled objects
$$(BUILD_DIR)/$(1)/$(3)/$(2)/%.o: %.c | \
$$(addprefix $$(BUILD_DIR)/$(1)/$(3)/$(2)/,$$($(4)))
	@echo "Compiling for $(1) on $(2) in $(3): $$<..."
	@mkdir -p $$(dir $$@)
	@$$(GCC_$(1)) $$(GCCFLAGS_$(1)_$(3)) -arch $(2) -I. -c $$< -o $$@

# libBwsrHook
$$(BUILD_DIR)/$(1)/$(3)/$(2)/libBwsrHook: \
$$(OBJS_$(1)) | \
$$(addprefix $$(BUILD_DIR)/$(1)/$(3)/$(2)/,$$($(4)))
	@echo "Building Archive for $(1) on $(2) in $(3)..."
	@$$(AR_$(1)) rcs $(BUILD_DIR)/$(1)/$(3)/$(2)/libBwsrHook.a $$^

# Example
$$(BUILD_DIR)/$(1)/$(3)/$(2)/Example: Example.c \
$$(OBJS_$(1)) | \
$$(addprefix $$(BUILD_DIR)/$(1)/$(3)/$(2)/,$$($(4)))
	@echo "Compiling Example for $(1) on $(2) in $(3)..."
	@$$(GCC_$(1)) $$(GCCFLAGS_$(1)_$(3)) -arch $(2) $$(EXAMPLE_LDFLAGS_$(1)) -I. -o $$@ $$^
ifeq ($(1),ios)
	@codesign -s - --entitlements Entitlements.plist $$@
endif

$$(addprefix $$(BUILD_DIR)/$(1)/$(3)/$(2)/,$$($(4))):
	@mkdir -p $$@
endef

# Evaluate the platform_rules for each platform
ifeq ($(UNAME),Darwin)
$(foreach platform,$(DARWIN_PLATFORMS), \
	$(foreach arch,$(DARWIN_ARCHS), \
		$(foreach deployment,$(DEPLOYMENTS), \
			$(eval $(call platform_rules,$(platform),$(arch),$(deployment),$(DARWIN_DIRS))) \
		) \
	) \
)
endif

ifeq ($(UNAME),Linux)
$(foreach platform,$(LINUX_PLATFORMS), \
	$(foreach arch,$(LINUX_ARCHS), \
		$(foreach deployment,$(DEPLOYMENTS), \
			$(eval $(call platform_rules,$(platform),$(arch),$(deployment),$(LINUX_DIRS))) \
		) \
	) \
)
endif

ifdef ANDROID_NDK
$(foreach platform,$(ANDROID_PLATFORMS), \
	$(foreach arch,$(ANDROID_ARCHS), \
		$(foreach deployment,$(DEPLOYMENTS), \
			$(eval $(call platform_rules,$(platform),$(arch),$(deployment),$(ANDROID_DIRS))) \
		) \
	) \
)
endif

$(BUILD_DIR):
	@mkdir -p $@

clean:
	rm -rf build

collect_header:
	@cp Hook/InlineHook.h $(BUILD_DIR)

hooklib_debug:                  \
	mac_debug                   \
	ios_debug                   \
	android_debug               \
	linux_debug

hooklib_release:                \
	mac_release                 \
	ios_release                 \
	android_release             \
	linux_release

examples_debug:                 \
	mac_example_debug           \
	ios_example_debug           \
	android_example_debug       \
	linux_example_debug

examples_release:               \
	mac_example_release         \
	ios_example_release         \
	android_example_release     \
	linux_example_release

examples:                       \
	examples_release            \
	examples_debug

hooklibs:                       \
	hooklib_release             \
	hooklib_debug

debug:                          \
	hooklib_debug               \
	examples_debug

release:                        \
	hooklib_release             \
	examples_release

all: hooklibs examples collect_header

.DEFAULT_GOAL := all

.PHONY: all clean release debug

```

`Memory/Memory.h`:

```h
#ifndef __MEMORY_H__
#define __MEMORY_H__

#include "Memory/MemoryTracker.h"
#include "Memory/MemoryAllocator.h"

#endif // __MEMORY_H__
```

`Memory/MemoryAllocator.c`:

```c

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <unistd.h>
#include <sys/mman.h>

#if defined( __APPLE__ )
    #include <mach/mach.h>
#endif

#include "Memory/Memory.h"

// -----------------------------------------------------------------------------
//  STRUCTURES & DEFINITIONS
// -----------------------------------------------------------------------------

#define ALIGN_CEIL( ADDRESS, RANGE ) \
    ( ( (uintptr_t) ADDRESS + (uintptr_t) RANGE - 1 ) & ~( (uintptr_t)RANGE - 1 ) )

/**
 * \brief Enforces adherence to memory protection range.
 */
typedef enum MemoryPermission {
    kNoAccess,

    kRead               = 1,
    kWrite              = 2,
    kExecute            = 4,

    kReadWrite          = kRead | kWrite,
    kReadExecute        = kRead | kExecute,
    kReadWriteExecute   = kRead | kWrite | kExecute,
} MemoryPermission;

// -----------------------------------------------------------------------------
//  GLOBALS
// -----------------------------------------------------------------------------

#if defined(__APPLE__)
    const int kMmapFd = VM_MAKE_TAG(255);
#else
    const int kMmapFd = -1;
#endif

const int kMmapFdOffset = 0;

// -----------------------------------------------------------------------------
//  PROTOTYPES
// -----------------------------------------------------------------------------

/**
 * \brief Converts MemoryPermission to suitable access permission
 * \param[in]           Access              Access permssion to convert
 * \return int
 * \retval int of memory protections matching the ones definied by `Access`.
 */
static
int
    INTERNAL_GetPageProtection
    (
        IN          const MemoryPermission      Access
    );

/**
 * \brief Initializes an Allocator.
 * \param[in,out]       Allocator           Allocator instance to initialize.
 * \param[in]           VMPage              The Allocated virtual page
 * \param[in]           Capacity            The size of the virtual page
 * \param[in]           Alignment           The byte alignment of the page
 * \return void
 */
static
void
    INTERNAL_AllocatorInitialize
    (
        OUT         allocator_t*                Allocator,
        IN          uint8_t*                    VMPage,
        IN          uint32_t                    Capacity,
        IN          uint32_t                    Alignment
    );

/**
 * \brief Gets the next page offset in the buffer of the allocator.
 * \param[in,out]       Data                Pointer to update with the page offset
 * \param[in]           Allocator           The allocator holding page buffers
 * \param[in]           BufferSize          The size needed by `Data`
 * \param[in]           Alignment           The byte alignment of the virtual page.
 * \return BWSR_STATUS
 * \retval ERROR_MEMORY_OVERFLOW if the allocator does not have enough memory available
 * \retval ERROR_ARGUMENT_IS_NULL If `Data` or `Allocator` is `NULL`.
 * \retval ERROR_INVALID_ARGUMENT_VALUE If `BufferSize` is not greater than `0`.
 * \retval ERROR_SUCCESS if `Data` now points to a region of `Alloctor`'s buffer
 */
static
BWSR_STATUS
    INTERNAL_Allocator_GetNextOffsetInBuffer
    (
        OUT         uint8_t**                   Data,
        IN  OUT     allocator_t*                Allocator,
        IN          const uint32_t              BufferSize,
        IN          const uint32_t              Alignment
    );

/**
 * \brief Sets the protection permission on specific page buffer
 * \param[in]           Address             The address of the page buffer
 * \param[in]           PageSize            The size of the page buffer
 * \param[in]           Access              Permission to set the page buffer
 * \return BWSR_STATUS
 * \retval ERROR_ARGUMENT_IS_NULL if `Address` is `NULL`.
 * \retval ERROR_MEMORY_PERMISSION if the page permission could not be set
 * \retval ERROR_SUCCESS if the page permissions were changed
 */
static
BWSR_STATUS
    INTERNAL_SetPagePermission
    (
        IN  OUT     void*                       Address,
        IN          const size_t                PageSize,
        IN          const MemoryPermission      Access
    );

/**
 * \brief Allocates a virtual page with the given protection permissions
 * \param[in,out]       MemoryRegion        Address of mapped memory region
 * \param[in]           MappingLength       Length of the mapping
 * \param[in]           Access              Mapping options
 * \param[in]           FixedAddress        Start address of the mapping
 * \return BWSR_STATUS
 * \retval ERROR_ARGUMENT_IS_NULL if `MemoryRegion` is `NULL`.
 * \retval ERROR_INVALID_ARGUMENT_VALUE if `MappingLength` is not greater than `0`.
 * \retval ERROR_MEMORY_MAPPING if mmap fails.
 * \retval ERROR_SUCCESS if the page was allocated with the specified permissions
 */
static
BWSR_STATUS
    INTERNAL_AllocateVirtualPage
    (
        OUT         void**                      MemoryRegion,
        IN          const size_t                MappingLength,
        IN          const MemoryPermission      Access,
        IN          void*                       FixedAddress
    );

// -----------------------------------------------------------------------------
//  IMPLEMENTATION
// -----------------------------------------------------------------------------

static
int
    INTERNAL_GetPageProtection
    (
        IN          const MemoryPermission      Access
    )
{
    int prot = 0;

    if( Access & kRead )
    {
        prot |= PROT_READ;
    }
    if( Access & kWrite )
    {
        prot |= PROT_WRITE;
    }
    if( Access & kExecute )
    {
        prot |= PROT_EXEC;
    }

    return prot;
}

static
void
    INTERNAL_AllocatorInitialize
    (
        OUT         allocator_t*                Allocator,
        IN          uint8_t*                    VMPage,
        IN          uint32_t                    Capacity,
        IN          uint32_t                    Alignment
    )
{
    __NOT_NULL_RETURN_VOID( Allocator );

    Allocator->Buffer           = VMPage;
    Allocator->Capacity         = Capacity;
    Allocator->BuiltinAlignment = Alignment;
    Allocator->Size             = 0;
}

static
BWSR_STATUS
    INTERNAL_Allocator_GetNextOffsetInBuffer
    (
        OUT         uint8_t**                   Data,
        IN  OUT     allocator_t*                Allocator,
        IN          const uint32_t              BufferSize,
        IN          const uint32_t              Alignment
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uint32_t        alignment       = 0;
    uintptr_t       pageCeiling     = 0;

    __NOT_NULL( Data, Allocator );
    __GREATER_THAN_0( BufferSize );

    alignment   = ( ( Alignment != 0 )
                    ? Alignment
                    : Allocator->BuiltinAlignment );
    pageCeiling = (uintptr_t)( Allocator->Buffer + Allocator->Size );

    Allocator->Size += ( ALIGN_CEIL( pageCeiling, alignment ) - pageCeiling );

    if( ( Allocator->Size + BufferSize ) > Allocator->Capacity )
    {
        BWSR_DEBUG( LOG_WARNING, "Allocator not large enough!\n" );
        retVal = ERROR_MEMORY_OVERFLOW;
    }
    else {
        *Data = (uint8_t*)( Allocator->Buffer + Allocator->Size );
        Allocator->Size += BufferSize;

        retVal = ERROR_SUCCESS;
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_SetPagePermission
    (
        IN  OUT     void*                       Address,
        IN          const size_t                PageSize,
        IN          const MemoryPermission      Access
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    int             protection      = 0;

    __NOT_NULL( Address );
    __GREATER_THAN_0( PageSize );

    protection = INTERNAL_GetPageProtection( Access );

    if( 0 != mprotect( Address,
                       PageSize,
                       protection ) )
    {
        BWSR_DEBUG( LOG_ERROR, "mprotect() Failed\n" );
        retVal = ERROR_MEMORY_PERMISSION;
    }
    else {
        retVal = ERROR_SUCCESS;
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_AllocateVirtualPage
    (
        OUT         void**                      MemoryRegion,
        IN          const size_t                MappingLength,
        IN          const MemoryPermission      Access,
        IN          void*                       FixedAddress
    )
{
    BWSR_STATUS retVal      = ERROR_FAILURE;
    int         protection  = 0;
    int         flags       = ( MAP_PRIVATE | MAP_ANONYMOUS );

    __NOT_NULL( MemoryRegion );
    __GREATER_THAN_0( MappingLength );

    protection = INTERNAL_GetPageProtection( Access );

    if( NULL != FixedAddress )
    {
        flags |= MAP_FIXED;
    }

    if( MAP_FAILED == ( *MemoryRegion = mmap( FixedAddress,
                                              MappingLength,
                                              protection,
                                              flags,
                                              kMmapFd,
                                              kMmapFdOffset ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "mmap() Failed\n" );
        retVal = ERROR_MEMORY_MAPPING;
    }
    else {
        retVal = ERROR_SUCCESS;
    } // mmap()

    return retVal;
}

BWSR_STATUS
    MemoryAllocator_AllocateExecutionBlock
    (
        IN  OUT     memory_range_t**            MemoryRange,
        IN  OUT     memory_allocator_t*         Allocator,
        IN          size_t                      BufferSize
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    uint8_t*        result          = NULL;
    void*           page            = NULL;
    size_t          i               = 0;
    size_t          allocatorSize   = 0;
    size_t          pageSize        = 0;

    __NOT_NULL( Allocator, MemoryRange );
    __GREATER_THAN_0( BufferSize );

    pageSize = (size_t)sysconf( _SC_PAGESIZE );

    if( BufferSize > pageSize )
    {
        BWSR_DEBUG( LOG_ERROR,
                    "Requested Size is too large: %zu\n",
                    BufferSize );
        return ERROR_MEMORY_OVERFLOW;
    } // dummy check

    for( i = 0; ( i < Allocator->AllocatorCount ) && ( ERROR_SUCCESS != retVal ); i++ )
    {
        retVal = INTERNAL_Allocator_GetNextOffsetInBuffer( &result,
                                                           &Allocator->Allocators[ i ],
                                                           BufferSize,
                                                           0 );
    } // for()

    if( !result )
    {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_AllocateVirtualPage( &page,
                                                                      pageSize,
                                                                      kNoAccess,
                                                                      NULL ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_AllocateVirtualPage() Failed\n" );
        }
        else {
            if( ERROR_SUCCESS != ( retVal = INTERNAL_SetPagePermission( page,
                                                                        pageSize,
                                                                        kReadExecute ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "OSMemory_SetPermission() Failed\n" );
            }
            else {
                Allocator->AllocatorCount++;
                allocatorSize = Allocator->AllocatorCount * sizeof( allocator_t );

                if( NULL == Allocator->Allocators )
                {
                    Allocator->Allocators = (allocator_t*) BwsrMalloc( allocatorSize );
                }
                else {
                    Allocator->Allocators = (allocator_t*) BwsrRealloc( Allocator->Allocators, allocatorSize );
                }

                if( NULL == Allocator->Allocators )
                {
                    BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
                    retVal = ERROR_MEM_ALLOC;
                }
                else {
                    INTERNAL_AllocatorInitialize( &Allocator->Allocators[ Allocator->AllocatorCount - 1 ],
                                                  (uint8_t*) page,
                                                  (uint32_t) sysconf( _SC_PAGESIZE ),
                                                  8 );

                    retVal = INTERNAL_Allocator_GetNextOffsetInBuffer( &result,
                                                                       &Allocator->Allocators[ Allocator->AllocatorCount - 1 ],
                                                                       BufferSize,
                                                                       0 );
                } // BwsrMalloc()
            } // OSMemory_SetPermission()
        } // INTERNAL_AllocateVirtualPage()
    } // !result

    if( ERROR_SUCCESS == retVal )
    {
        if( NULL == ( *MemoryRange = (memory_range_t*) BwsrMalloc( sizeof( memory_range_t ) ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
            retVal = ERROR_MEM_ALLOC;
        }
        else {
            ( *MemoryRange )->Start = (uintptr_t)result;
            ( *MemoryRange )->Size  = BufferSize;
        } // BwsrMalloc()
    } // INTERNAL_Allocator_GetNextOffsetInBuffer()

    return retVal;
}
```

`Memory/MemoryAllocator.h`:

```h
#ifndef __MEMORY_ALLOCATOR_H__
#define __MEMORY_ALLOCATOR_H__

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <stdint.h>
#include <stdlib.h>

#include "utility/utility.h"
#include "utility/error.h"

// -----------------------------------------------------------------------------
//  STRUCTURES & DEFINITIONS
// -----------------------------------------------------------------------------

typedef struct memory_range_t {
    // Starting address of the memory range
    uintptr_t           Start;
    // Size of the memory range in bytes
    size_t              Size;
} memory_range_t;

typedef struct allocator_t {
    // Pointer to the allocated memory buffer
    uint8_t*            Buffer;
    // Current size of the allocated buffer in bytes
    uint32_t            Size;
    // Total capacity of the allocated buffer in bytes
    uint32_t            Capacity;
    // Page alignment requirement for allocations (typically 8 or 0)
    uint32_t            BuiltinAlignment;
} allocator_t;

typedef struct memory_allocator_t {
    // Pointer to all the allocators in use
    allocator_t*        Allocators;
    // Current amount of allocators
    size_t              AllocatorCount;
} memory_allocator_t;

// -----------------------------------------------------------------------------
//  EXPORTED FUNCTIONS
// -----------------------------------------------------------------------------

/**
 * \brief Creates a memory block of a given size with `PROT_READ` and
 * `PROT_EXEC` permission.
 * \param[in,out]       MemoryRange         Block of allocated memory
 * \param[in,out]       Allocator           Allocator used to hold the memory
 * \param[in]           BufferSize          Size required of the memory block
 * \return `BWSR_STATUS`
 * \retval `ERROR_ARGUMENT_IS_NULL` if `Allocator` or `MemoryRange` is `NULL`.
 * \retval `ERROR_INVALID_ARGUMENT_VALUE` if `BufferSize` is not greater than `0`.
 * \retval `ERROR_MEMORY_MAPPING` if `mmap` fails.
 * \retval `ERROR_MEMORY_PERMISSION` if the page permission could not be set
 * \retval `ERROR_MEM_ALLOC` on allocation failure
 * \retval `ERROR_MEMORY_OVERFLOW` if the allocator does not have enough memory available
 * \retval `ERROR_SUCCESS` if `MemoryRange` was allocated with the correct permissions
 */
BWSR_STATUS
    MemoryAllocator_AllocateExecutionBlock
    (
        IN  OUT     memory_range_t**        MemoryRange,
        IN  OUT     memory_allocator_t*     Allocator,
        IN          size_t                  BufferSize
    );

#endif // __MEMORY_ALLOCATOR_H__

```

`Memory/MemoryTracker.c`:

```c

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <limits.h>

#ifdef BWSR_SECURELY_ZERO_MEMORY

    #include <string.h>

#endif // BWSR_SECURELY_ZERO_MEMORY

#include "Memory/MemoryTracker.h"
#include "utility/debug.h"
#include "utility/error.h"

// -----------------------------------------------------------------------------
//  STRUCTURES & DEFINITIONS
// -----------------------------------------------------------------------------

#define FREE_ALLOCATION_POINTER 1
#define KEEP_ALLOCATION_POINTER 0

/**
 * \brief Tracks file name and line number of allocations
 */
typedef struct memory_tracker_t {
    // Address of the allocated memory
    void*                       Address;
    // The size, in bytes, of the allocated memory
    size_t                      AllocationSize;
    // The location of the next memory tracker instance
    struct memory_tracker_t*    Next;
    // The location of the previous memory tracker instance
    struct memory_tracker_t*    Previous;
    // The line number of the originator requesting allocation
    size_t                      LineNumber;
    // The file name of the originator requesting allocation
    char                        FileName[ 1 ];
} memory_tracker_t;

// -----------------------------------------------------------------------------
//  GLOBALS
// -----------------------------------------------------------------------------

static memory_tracker_t gMemoryTracker =
{
    .Address            = 0,
    .AllocationSize     = 0,
    .Next               = &gMemoryTracker,
    .Previous           = &gMemoryTracker
};

// -----------------------------------------------------------------------------
//  PROTOTYPES
// -----------------------------------------------------------------------------

/**
 * \brief Releases a memory tracker and removes it from the global link
 * \param[in,out]       Tracker             The Tracker of a memory allocation
 * \param[in]           ReleaseAddress      Wether not to release the allocation
 * \return void
 */
static
void
    INTERNAL_MemoryTracker_Release
    (
        IN  OUT     memory_tracker_t*       Tracker,
        IN          const uint8_t           ReleaseAddress
    );

/**
 * \brief Initializes a memory tracker and adds it to the global link
 * \param[in,out]       Tracker             Pointer to track memory allocation
 * \param[in]           AllocationSize      The requested allocation size
 * \param[in]           FileName            The file name of the originator
 * \param[in]           LineNumber          The line number of the originator
 * \return BWSR_STATUS
 * \retval ERROR_ARGUMENT_IS_NULL if `Tracker` or `FileName` is `NULL`.
 * \retval ERROR_INVALID_ARGUMENT_VALUE if `AllocationSize` or `LineNumber` is not greater than `0`.
 * \retval ERROR_MEM_ALLOC if `Tracker` could not be allocated
 * \retval ERROR_SUCCESS if `Tracker` was allocated and linked in `gMemoryTracker`.
 */
static
BWSR_STATUS
    INTERNAL_MemoryTracker_Initialize
    (
        OUT         memory_tracker_t**      Tracker,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    );

// -----------------------------------------------------------------------------
//  IMPLEMENTATION
// -----------------------------------------------------------------------------

static
void
    INTERNAL_MemoryTracker_Release
    (
        IN  OUT     memory_tracker_t*       Tracker,
        IN          const uint8_t           ReleaseAddress
    )
{
    __NOT_NULL_RETURN_VOID( Tracker );

    if( ( FREE_ALLOCATION_POINTER == ReleaseAddress   ) &&
        ( NULL                    != Tracker->Address ) )
    {

#ifdef BWSR_SECURELY_ZERO_MEMORY

        memset_s( Tracker->Address,
                  Tracker->AllocationSize,
                  0,
                  Tracker->AllocationSize );

#endif // BWSR_SECURELY_ZERO_MEMORY

        free( Tracker->Address );
        Tracker->Address = NULL;
    } // Tracking check

    Tracker->Previous->Next     = Tracker->Next;
    Tracker->Next->Previous     = Tracker->Previous;
    Tracker->Next               = NULL;
    Tracker->Previous           = NULL;
    Tracker->AllocationSize     = 0;

    free( Tracker );
}

static
BWSR_STATUS
    INTERNAL_MemoryTracker_Initialize
    (
        OUT         memory_tracker_t**      Tracker,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    size_t          lineLength      = 0;

    __NOT_NULL( Tracker, FileName );
    __GREATER_THAN_0( AllocationSize, LineNumber );

    lineLength = strnlen( FileName, PATH_MAX );

    if( NULL == ( *Tracker = malloc( sizeof( memory_tracker_t ) + lineLength + sizeof( char ) ) ) )
    {
        retVal = ERROR_MEM_ALLOC;
    }
    else {
        memcpy( ( *Tracker )->FileName,
                FileName,
                lineLength );

        *( ( *Tracker )->FileName + lineLength )    = 0x00;
        ( *Tracker )->AllocationSize                = AllocationSize;
        ( *Tracker )->LineNumber                    = LineNumber;
        ( *Tracker )->Next                          = &gMemoryTracker;
        ( *Tracker )->Previous                      = gMemoryTracker.Previous;
        gMemoryTracker.Previous->Next               = *Tracker;
        gMemoryTracker.Previous                     = *Tracker;

        retVal = ERROR_SUCCESS;
    } // malloc()

    return retVal;
}

void
    MemoryTracker_Free
    (
        IN          void*                   Pointer
    )
{
    memory_tracker_t* tracker = gMemoryTracker.Next;

    __NOT_NULL_RETURN_VOID( Pointer );

    while( ( tracker          != &gMemoryTracker ) &&
           ( tracker->Address != Pointer         ) )
    {
        tracker = tracker->Next;
    } // while()

    if( tracker == &gMemoryTracker )
    {
        BWSR_DEBUG( LOG_INFO,
                    "Not tracking address: %p. Not attempting release.\n",
                    Pointer );
    }
    else {
        INTERNAL_MemoryTracker_Release( tracker, FREE_ALLOCATION_POINTER );
    } // dummy check

    return;
}

void*
    MemoryTracker_Reallocate
    (
        IN  OUT     void*                   Reference,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    )
{
    memory_tracker_t*   tracker         = gMemoryTracker.Next;
    void*               allocation      = NULL;

    __NOT_NULL_RETURN_NULL( Reference, FileName );
    __GREATER_THAN_0_RETURN_NULL( AllocationSize, LineNumber );

    while( ( tracker          != &gMemoryTracker ) &&
           ( tracker->Address != Reference       ) )
    {
        tracker = tracker->Next;
    } // while()

    if( tracker == &gMemoryTracker )
    {
        BWSR_DEBUG( LOG_CRITICAL, "You don't know what you're doing.\n" );
    }
    else {
        INTERNAL_MemoryTracker_Release( tracker, KEEP_ALLOCATION_POINTER );

        if( ERROR_SUCCESS != INTERNAL_MemoryTracker_Initialize( &tracker,
                                                                AllocationSize,
                                                                FileName,
                                                                LineNumber ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_MemoryTracker_Initialize() Failed\n" );
        }
        else {
            if( NULL == ( allocation = realloc( Reference, AllocationSize ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "realloc() Failed\n" );
                INTERNAL_MemoryTracker_Release( tracker, KEEP_ALLOCATION_POINTER );
            }
            else {
                tracker->Address = allocation;
            } // realloc()
        } // INTERNAL_MemoryTracker_Initialize()
    } // dummy check

    return allocation;
}

void*
    MemoryTracker_Calloc
    (
        IN          const size_t            AllocationCount,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    )
{
    memory_tracker_t*   tracker         = NULL;
    void*               allocation      = NULL;

    __NOT_NULL_RETURN_NULL( FileName );
    __GREATER_THAN_0_RETURN_NULL( AllocationCount,
                                  AllocationSize,
                                  LineNumber );

    if( ERROR_SUCCESS != INTERNAL_MemoryTracker_Initialize( &tracker,
                                                            ( AllocationSize * AllocationCount ),
                                                            FileName,
                                                            LineNumber ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_MemoryTracker_Initialize() Failed\n" );
    }
    else {
        if( NULL == ( allocation = calloc( AllocationCount, AllocationSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "malloc() Failed\n" );
            INTERNAL_MemoryTracker_Release( tracker, KEEP_ALLOCATION_POINTER );
        }
        else {
            tracker->Address = allocation;
        } // malloc()
    } // INTERNAL_MemoryTracker_Initialize()

    return allocation;
}

void*
    MemoryTracker_Allocate
    (
        IN          const uint64_t          AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    )
{
    memory_tracker_t*   tracker         = NULL;
    void*               allocation      = NULL;

    __NOT_NULL_RETURN_NULL( FileName );
    __GREATER_THAN_0_RETURN_NULL( AllocationSize, LineNumber );

    if( ERROR_SUCCESS != INTERNAL_MemoryTracker_Initialize( &tracker,
                                                            AllocationSize,
                                                            FileName,
                                                            LineNumber ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_MemoryTracker_Initialize() Failed\n" );
    }
    else {
        if( NULL == ( allocation = malloc( AllocationSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "malloc() Failed\n" );
            INTERNAL_MemoryTracker_Release( tracker, KEEP_ALLOCATION_POINTER );
        }
        else {
            tracker->Address = allocation;
        } // malloc()
    } // INTERNAL_MemoryTracker_Initialize()

    return allocation;
}

size_t
    MemoryTracker_CheckForMemoryLeaks
    (
        void
    )
{
    memory_tracker_t*   tracker         = gMemoryTracker.Next;
    size_t              leakCount       = 0;

#ifdef DEBUG_MODE
    size_t              leakAmount      = 0;
#endif

    while( tracker != &gMemoryTracker )
    {
        leakCount++;

        BWSR_DEBUG( LOG_WARNING,
                    "%s[%zu]: Leaked %zu Bytes at Address: %p!",
                    tracker->FileName,
                    tracker->LineNumber,
                    tracker->AllocationSize,
                    tracker->Address );
#ifdef DEBUG_MODE
        leakAmount += tracker->AllocationSize;
#endif
        tracker = tracker->Next;
    } // while()

#ifdef DEBUG_MODE
    if( leakCount )
    {
        BWSR_DEBUG( LOG_WARNING,
                    "Totals: %zu leaks totalling %zu Bytes!",
                    leakCount,
                    leakAmount );
    }
#endif

    return leakCount;
}

```

`Memory/MemoryTracker.h`:

```h

#ifndef __MEMORY_TRACKER_H__
#define __MEMORY_TRACKER_H__

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#include "utility/utility.h"

// -----------------------------------------------------------------------------
//  DEFINITIONS
// -----------------------------------------------------------------------------

#if defined( DEBUG_MODE )

    // Memory tracked malloc
    #define BwsrMalloc( AllocationSize )                \
        MemoryTracker_Allocate( AllocationSize,         \
                                __FILE__,               \
                                __LINE__ )

    // Memory tracker realloc
    #define BwsrRealloc( Pointer, AllocationSize )      \
        MemoryTracker_Reallocate( Pointer,              \
                                  AllocationSize,       \
                                  __FILE__,             \
                                  __LINE__ )

    // Memory tracked calloc
    #define BwsrCalloc( AllocationCount, AllocationSize )   \
        MemoryTracker_Calloc( AllocationCount,              \
                              AllocationSize,               \
                              __FILE__,                     \
                              __LINE__ )

    // Memory tracked free
    #define BwsrFree( Pointer ) \
        MemoryTracker_Free( Pointer )

#else

    // Memory tracked malloc
    #define BwsrMalloc( AllocationSize ) \
        malloc( AllocationSize )

    // Memory tracker realloc
    #define BwsrRealloc( Pointer, AllocationSize ) \
        realloc( Pointer, AllocationSize )

    // Memory tracked calloc
    #define BwsrCalloc( AllocationCount, AllocationSize ) \
        calloc( AllocationCount, AllocationSize )

    // Memory tracked free
    #define BwsrFree( Pointer ) \
        if( NULL != Pointer )   \
        {                       \
            free( Pointer );    \
        }

#endif

// -----------------------------------------------------------------------------
//  EXPORTED FUNCTIONS
// -----------------------------------------------------------------------------

/**
 * \brief Releases both the tracker and the allocation at a given address
 * \param[in]           Pointer             The pointer of the allocated memory
 * \return void
 */
void
    MemoryTracker_Free
    (
        IN          void*                   Pointer
    );

/**
 * \brief Reallocates memory at the given address and updates the tracker
 * \param[in,out]       Reference           The pointer to the allcoated memory
 * \param[in]           AllocationSize      The updated allocation size
 * \param[in]           FileName            The file name of the originator
 * \param[in]           LineNumber          The line number of the originator
 * \return void*
 * \retval NULL if any allocation fails.
 * \retval NULL if `Reference` or `FileName` is `NULL`.
 * \retval NULL if `AllocationSize` or `LineNumber` is not greater than `0`.
 * \retval void* a pointer to the new allocation
 */
void*
    MemoryTracker_Reallocate
    (
        IN  OUT     void*                   Reference,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    );

/**
 * \brief Allocates memory of the specified size and initializes a tracker
 * \param[in]           AllocationCount     The number of objects
 * \param[in]           AllocationSize      The size of each object
 * \param[in]           FileName            The file name of the originator
 * \param[in]           LineNumber          The line number of the originator
 * \return void*
 * \retval NULL if any allocation fails.
 * \retval NULL if `FileName` is `NULL`.
 * \retval NULL if `AllocationCount`, `AllocationSize` or `LineNumber` is not greater than `0`.
 * \retval void* a pointer to the new allocation
 */
void*
    MemoryTracker_Calloc
    (
        IN          const size_t            AllocationCount,
        IN          const size_t            AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    );

/**
 * \brief Allocates memory of the specified size and initializes a tracker
 * \param[in]           AllocationSize      The size of the allcation
 * \param[in]           FileName            The file name of the originator
 * \param[in]           LineNumber          The line number of the originator
 * \return void*
 * \retval NULL if any allocation fails.
 * \retval NULL if `FileName` is `NULL`.
 * \retval NULL if `AllocationSize` or `LineNumber` is not greater than `0`.
 * \retval void* a pointer to the new allocation
 */
void*
    MemoryTracker_Allocate
    (
        IN          const uint64_t          AllocationSize,
        IN          const char*             FileName,
        IN          const size_t            LineNumber
    );

/**
 * \brief Iterates the memory tracker and counts the remaining allocations
 * \return size_t
 * \retval size_t A count of the remaining allocations in the memory tracker
 */
size_t
    MemoryTracker_CheckForMemoryLeaks
    (
        void
    );

#endif // __MEMORY_TRACKER_H__
```

`README.md`:

```md
# BWSR
Inline Hooking Library for Arm64 devices across multiple platforms.

Platform Support:
- iOS (arm64/arm64e).
- Android (arm64).
- Linux (arm64).
- OSX (arm64/arm64e).

BWSR is a versatile inline hooking library implemented entirely in `C`, designed to facilitate dynamic code modification and interception on `Linux`, `OSX`, `iOS`, and `Android`.

## Building
Building `iOS` and `MacOSX` requires a Mac machine with `X-Code` and `Command-Line-Tools` installed.

Building `Android` requires a recent AndroidNDK downloaded and have the `ANDROID_NDK` environmental set to the path of the NDK.

Building `Linux` requires that `build-essential` and `clang` are installed.

To make the hooking library and all the example programs simply run:
```sh
make
```

To make only the hooking library
```sh
make hooklibs
```

To make the example program
```sh
make examples
```

## Symbol Resolver (Locating the Address of a Function)

### Symbol Resolution When the Image IS Known
This will return the address of the first occurence encountered of only the mach header matching the specific image name and the specific function name.
```c
uintptr_t function_address = 0;

// iOS
retVal = BWSR_ResolveSymbol( "AudioUnitProcess", "AudioToolbox", &function_address );

// Android
retVal = BWSR_ResolveSymbol( "open", "/apex/com.android.runtime/lib64/bionic/libc.so", &function_address );
```

### Symbol Resolution When the Image Is **NOT** Known
This will return the address of the first occurence encounted in any mach header for the matching function name. This is usually fine but if the function name is common enough you may get the address of the wrong function.
```c
uintptr_t function_address = 0;

// iOS/Mac
retVal = BWSR_ResolveSymbol( "AudioUnitProcess", NULL, &function_address );

// Android/Linux
retVal = BWSR_ResolveSymbol( "open", NULL, &function_address );
```

## Inline Hooking
Hooks and code page backups are handled internally, so there is no need to worry about reverting hooks or memory leaks.

### Simple Inline Hook
The easiest and most user friendly way to hook
```c
// Function receiving the printf calls
int hook_printf( const char* text, ... ) {
    return -1;
}

// A simple hook of printf
BWSR_InlineHook( printf, hook_printf, NULL, NULL, NULL );

// Cleanup the hook
BWSR_DestroyHook( printf );
```

### Original Function Callback
It may be benefitial to have a pointer to where the original function to use inside of the hooked function for recording or altering parameters.
```c
// Pointer to the original creat()
void* original_creat = NULL;

// The version replacing creat()
int hcreat( const char * files, mode_t modes ) {
    BWSR_DEBUG( LOG_CRITICAL, "SUCCESS! Caught creat()\n" );
    if( NULL != original_creat )
        return ((__typeof(creat)*)original_creat)("/some/new/location", modes);
    return 0;
}

BWSR_InlineHook( creat, hcreat, &original_creat, NULL, NULL );
```


### Codesign Friendly
On iOS it may be benefitial to know the address of the page where the hook is employed before or after the hook is written out. In the snippet below, is an example of a callback triggered before and after the modification of the code page is done.
```c
void BeforePageWriteCallbackFn( uintptr_t PageAddress ) {
    BWSR_DEBUG( LOG_CRITICAL, "PageAddress: %" PRIuPTR "\n", PageAddress );
    /// Do something before the write occurs.
}

void AfterPageWriteCallbackFn( uintptr_t PageAddress ) {
    BWSR_DEBUG( LOG_ALERT, "PageAddress: %" PRIuPTR "\n", PageAddress );
    // Do something after the write occurs...
    // Update CDHashes, etc.
}

BWSR_InlineHook( printf, hook_printf, NULL, BeforePageWriteCallbackFn, AfterPageWriteCallbackFn );
```

### Simple Hook Cleanup
It may be benefitial to undo all hooks and release all memory associated with hooks at once. This can be done at any time through one simple call.
```c
BWSR_DestroyAllHooks();
```

## Memory Tracker
> [!IMPORTANT]
> The memory tracker is only used when `DEBUG_MODE` is defined. It is not used for release builds.

The memory tracker was built to ensure all memory leaks are resolved. In order for the memory tracker to successfully track allocations the calls BWSR allocation and free calls be used. The current allocations/leaked memory at any time with a simple call.
```c
size_t leaks = 0;

leaks = MemoryTracker_CheckForMemoryLeaks();

if( leaks > 0 )
{
    // Uh-oh!
}
```

## TODO
The list of items that needs to be done is far longer than this list, but these are these are the next important goals:
- Dynamic entitlements for iOS.

## ACKNOWLEDGMENTS
- https://github.com/kubo/plthook/
- https://github.com/jmpews/Dobby
- https://github.com/asLody/whale
```

`SymbolResolve/Darwin/LCStrings.h`:

```h

#ifndef __LCSTRINGS_H__
#define __LCSTRINGS_H__

#define LOAD_COMMAND_STRINGS( E ) \
    E( LC_SEGMENT,	                    "segment of this file to be mapped"         )   \
    E( LC_SYMTAB,	                    "link-edit stab symbol table info"          )   \
    E( LC_SYMSEG,	                    "link-edit gdb symbol table info "              \
                                        "(obsolete)"                                )   \
    E( LC_THREAD,	                    "thread"                                    )   \
    E( LC_UNIXTHREAD,	                "unix thread (includes a stack)"            )   \
    E( LC_LOADFVMLIB,	                "load a specified fixed VM shared library"  )   \
    E( LC_IDFVMLIB,	                    "fixed VM shared library identification"    )   \
    E( LC_IDENT,	                    "object identification info (obsolete)"     )   \
    E( LC_FVMFILE,	                    "fixed VM file inclusion (internal use)"    )   \
    E( LC_PREPAGE,                      "prepage command (internal use)"            )   \
    E( LC_DYSYMTAB,	                    "dynamic link-edit symbol table info"       )   \
    E( LC_LOAD_DYLIB,	                "load a dynamically linked shared library"  )   \
    E( LC_ID_DYLIB,	                    "dynamically linked shared lib ident"       )   \
    E( LC_LOAD_DYLINKER,	            "load a dynamic linker"                     )   \
    E( LC_ID_DYLINKER,	                "dynamic linker identification"             )   \
    E( LC_PREBOUND_DYLIB, 	            "modules prebound for a dynamically "           \
                                        "linked shared library"                     )   \
    E( LC_ROUTINES,		                "image routines"                            )   \
    E( LC_SUB_FRAMEWORK, 	            "sub framework"                             )   \
    E( LC_SUB_UMBRELLA, 	            "sub umbrella"                              )   \
    E( LC_SUB_CLIENT,		            "sub client"                                )   \
    E( LC_SUB_LIBRARY,  	            "sub library"                               )   \
    E( LC_TWOLEVEL_HINTS, 	            "two-level namespace lookup hints"          )   \
    E( LC_PREBIND_CKSUM,  	            "prebind checksum"                          )   \
    E( LC_LOAD_WEAK_DYLIB,              "load a dynamically linked shared library "     \
                                        "that is allowed to be missing (all "           \
                                        "symbols are weak imported)."               )   \
    E( LC_SEGMENT_64, 	                "64-bit segment of this file to be mapped"  )   \
    E( LC_ROUTINES_64,		            "64-bit image routines"                     )   \
    E( LC_UUID,			                "the uuid"                                  )   \
    E( LC_RPATH,                        "runpath additions"                         )   \
    E( LC_CODE_SIGNATURE, 	            "local of code signature"                   )   \
    E( LC_SEGMENT_SPLIT_INFO,           "local of info to split segments"           )   \
    E( LC_REEXPORT_DYLIB,               "load and re-export dylib"                  )   \
    E( LC_LAZY_LOAD_DYLIB, 	            "delay load of dylib until first use"       )   \
    E( LC_ENCRYPTION_INFO, 	            "encrypted segment information"             )   \
    E( LC_DYLD_INFO, 		            "compressed dyld information"               )   \
    E( LC_DYLD_INFO_ONLY, 	            "compressed dyld information only"          )   \
    E( LC_LOAD_UPWARD_DYLIB,            "load upward dylib"                         )   \
    E( LC_VERSION_MIN_MACOSX,           "build for MacOSX min OS version"           )   \
    E( LC_VERSION_MIN_IPHONEOS,         "build for iPhoneOS min OS version"         )   \
    E( LC_FUNCTION_STARTS,              "compressed table of function start "           \
                                        "addresses"                                 )   \
    E( LC_DYLD_ENVIRONMENT,             "string for dyld to treat like "                \
                                        "environment variable"                      )   \
    E( LC_MAIN,                         "replacement for LC_UNIXTHREAD"             )   \
    E( LC_DATA_IN_CODE,                 "table of non-instructions in __text"       )   \
    E( LC_SOURCE_VERSION,               "source version used to build binary"       )   \
    E( LC_DYLIB_CODE_SIGN_DRS,          "Code signing DRs copied from linked "          \
                                        "dylibs"                                    )   \
    E( LC_ENCRYPTION_INFO_64,           "64-bit encrypted segment information"      )   \
    E( LC_LINKER_OPTION,                "linker options in MH_OBJECT files"         )   \
    E( LC_LINKER_OPTIMIZATION_HINT,     "optimization hints in MH_OBJECT files"     )   \
    E( LC_VERSION_MIN_TVOS,             "build for AppleTV min OS version"          )   \
    E( LC_VERSION_MIN_WATCHOS,          "build for Watch min OS version"            )   \
    E( LC_NOTE,                         "arbitrary data included within a Mach-O "      \
                                        "file"                                      )   \
    E( LC_BUILD_VERSION,                "build for platform min OS version"         )   \
    E( LC_DYLD_EXPORTS_TRIE,            "used with linkedit_data_command, payload "     \
                                        "is trie"                                   )   \
    E( LC_DYLD_CHAINED_FIXUPS,          "used with linkedit_data_command"           )   \
    E( LC_FILESET_ENTRY,                "used with fileset_entry_command"           )   \
    E( LC_ATOM_INFO,                    "used with linkedit_data_command"           )

#define LOAD_COMMAND_TO_TEXT( LOAD_COMMAND, TEXT ) \
    case LOAD_COMMAND: return #LOAD_COMMAND " (" TEXT ")";

static inline const char* LoadCommandString( int LoadCommand )
{
    switch( LoadCommand )
    {
        LOAD_COMMAND_STRINGS( LOAD_COMMAND_TO_TEXT )
    }

    return "Unknown Load Command!";
}

#endif __LCSTRINGS_H__
```

`SymbolResolve/Darwin/Macho.c`:

```c

//------------------------------------------------------------------------------
//  INCLUDES
//------------------------------------------------------------------------------

#include <stdint.h>

#include <mach-o/dyld.h>
#include <mach-o/nlist.h>
#include <mach-o/dyld_images.h>

#include <sys/mman.h>
#include <sys/stat.h>
#include <inttypes.h>

#include <CoreFoundation/CoreFoundation.h>
#include <AudioToolbox/AudioUnit.h>

#include "utility/utility.h"
#include "utility/error.h"
#include "utility/debug.h"
#include "apple/dyld_cache_format.h"

//------------------------------------------------------------------------------
//  DYNAMICALLY LINKED EXTERNAL METHODS
//------------------------------------------------------------------------------

#ifdef __cplusplus
    extern "C" {
#endif

extern
const char*
    dyld_shared_cache_file_path
    (

    );

extern
int
    __shared_region_check_np
    (
        uint64_t*               StartAddress
    );

#ifdef __cplusplus
    }
#endif


//------------------------------------------------------------------------------
//  DATA STRUCTURES
//------------------------------------------------------------------------------

#if defined( __LP64__ )

    typedef struct mach_header_64                       mach_header_t;
    typedef struct segment_command_64                   segment_command_t;
    typedef struct section_64                           section_t;
    typedef struct nlist_64                             nlist_t;
    typedef struct dyld_cache_local_symbols_entry_64    dcls_entry_t;

    #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64

#else

    typedef struct mach_header                          mach_header_t;
    typedef struct segment_command                      segment_command_t;
    typedef struct section                              section_t;
    typedef struct nlist                                nlist_t;
    typedef struct dyld_cache_local_symbols_entry       dcls_entry_t;

    #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT

#endif

#define SYMBOLS_FILE_EXTENSION ".symbols"
#define MAX_SEGMENT_COUNT 64
#define OPTIONAL

typedef struct dyld_cache_header                    dyld_cache_header_t;
typedef struct dyld_cache_mapping_info              dyld_cache_mapping_info_t;
typedef struct dyld_all_image_infos                 dyld_all_image_infos_t;
typedef struct dyld_cache_local_symbols_info        dcls_info_t;
typedef struct load_command                         load_command_t;
typedef struct symtab_command                       symtab_command_t;
typedef struct dysymtab_command                     dysymtab_command_t;
typedef struct dyld_info_command                    dyld_info_command_t;
typedef struct linkedit_data_command                linkedit_data_command_t;

typedef struct
shared_cache_ctx
{
    // Dyld Caches
    dyld_cache_header_t*        RuntimeSharedCache;
    dyld_cache_header_t*        MmapSharedCache;

    // ASLR
    uintptr_t                   RuntimeSlide;

    // Symbols
    dcls_info_t*                LocalSymbolsInfo;
    dcls_entry_t*               LocalSymbolsEntries;

    // Tables
    nlist_t*                    SymbolTable;
    char*                       StringTable;
} shared_cache_ctx_t;

typedef struct
macho_ctx_t
{
    bool                        IsRuntimeMode;

    // Headers
    mach_header_t*              Header;
    mach_header_t*              CacheHeader;

    // VM Region
    uintptr_t                   LoadVmAddr;
    size_t                      VmSize;
    uintptr_t                   VmRegionStart;
    uintptr_t                   VmRegionEnd;

    // ASLR
    uintptr_t                   Slide;
    uintptr_t                   LinkedItBase;

    // Segments
    segment_command_t*          Segments[ MAX_SEGMENT_COUNT ];
    int                         SegmentsCount;
    segment_command_t*          TextSegment;
    segment_command_t*          DataSegment;
    segment_command_t*          TextExecSegment;
    segment_command_t*          DataConstSegment;
    segment_command_t*          LinkedItSegment;

    // Commands
    symtab_command_t*           SymbolTableCommand;                 // LC_SYMTAB
    dysymtab_command_t*         DySymbolTableCommand;               // LC_DYSYMTAB
    dyld_info_command_t*        DyldInfoCommand;                    // LC_DYLD_INFO or LC_DYLD_INFO_ONLY
    linkedit_data_command_t*    ExportsTrieCommand;                 // LC_DYLD_EXPORTS_TRIE
    linkedit_data_command_t*    ChainedFixupsCommand;               // LC_DYLD_CHAINED_FIXUPS
    linkedit_data_command_t*    CodeSignatureCommand;               // LC_CODE_SIGNATURE

    // Tables
    nlist_t*                    SymbolTable;
    char*                       StringTable;
    uint32_t*                   IndirectSymbolTable;
} macho_ctx_t;

//------------------------------------------------------------------------------
//  PROTOTYPES
//------------------------------------------------------------------------------

static
BWSR_STATUS
    INTERNAL_GetSharedCacheBaseAddress
    (
        OUT         dyld_cache_header_t**       LoadAddress
    );

static
BWSR_STATUS
    INTERNAL_SharedCacheContext_Initialize
    (
        IN  OUT     shared_cache_ctx_t*         Context
    );

static
BWSR_STATUS
    INTERNAL_MapFileOffsetToBuffer
    (
        IN          size_t                      MapSize,
        IN          off_t                       MapOffset,
        IN          const char*                 MapFile,
        OUT         uint8_t**                   MmapBuffer
    );

static
BWSR_STATUS
    INTERNAL_MapSharedCacheToBuffer
    (
        IN          const char*                 MapFile,
        IN  OUT     uint8_t**                   MmapBuffer
    );

static
BWSR_STATUS
    INTERNAL_LoadSymbolsFromSharedCache
    (
        IN          shared_cache_ctx_t*         Context
    );

static
BWSR_STATUS
    INTERNAL_IsAddressInSharedCache
    (
        IN          shared_cache_ctx_t*         Context,
        IN          uintptr_t                   Address
    );

static
BWSR_STATUS
    INTERNAL_LoadSymbolTableFromSharedCache
    (
        IN          shared_cache_ctx_t*         Context,
        IN          mach_header_t*              ImageHeader,
        OUT         nlist_t**                   SymbolTable,
        OUT         uint32_t*                   SymbolTableCount,
        OUT         char**                      StringTable
    );

static
BWSR_STATUS
    INTERNAL_FindSymbolAddressInSymbolTable
    (
        IN          char*               SymbolNamePattern,
        IN          nlist_t*            SymbolTable,
        IN          uint32_t            SymbolTableCount,
        IN          char*               StringTable,
        OUT         uintptr_t*          SymbolAddress
    );

static
BWSR_STATUS
    INTERNAL_UpdateContextFromLoadCommand
    (
        IN          load_command_t*         LoadCommand,
        OUT         macho_ctx_t*            Context
    );

static
BWSR_STATUS
    INTERNAL_MachoContext_Initialize
    (
        IN              mach_header_t*      MachHeader,
        IN              bool                RuntimeMode,
        IN OPTIONAL     mach_header_t*      CacheHeader,
        OUT             macho_ctx_t*        Context
    );

static
BWSR_STATUS
    INTERNAL_ResolveAddressWithSymbolTable
    (
        IN          macho_ctx_t*            Context,
        IN          const char*             SymbolNamePattern,
        IN OUT      uintptr_t*              SymbolAddress
    );

static
BWSR_STATUS
    INTERNAL_ResolveAddressForSymbol
    (
        IN  OUT     macho_ctx_t*            Context,
        IN          const char*             SymbolName,
        OUT         uintptr_t*              SymbolAddress
    );

static
BWSR_STATUS
    INTERNAL_ResolveSymbol_SharedCache
    (
        IN          const char*             SymbolName,
        IN          const mach_header_t*    MachHeader,
        IN  OUT     uintptr_t*              FunctionAddress
    );

static
BWSR_STATUS
    INTERNAL_ResolveSymbol_SymbolTable
    (
        IN          const char*             SymbolName,
        IN          const mach_header_t*    MachHeader,
        IN  OUT     uintptr_t*              FunctionAddress
    );

static
BWSR_STATUS
    INTERNAL_ResolveSymbol
    (
        IN              const char*             SymbolName,
        IN OPTIONAL     const char*             ImageName,
        OUT             uintptr_t*              Address
    );

//------------------------------------------------------------------------------
//  PRIVATE FUNCTIONS
//------------------------------------------------------------------------------

static
BWSR_STATUS
    INTERNAL_GetSharedCacheBaseAddress
    (
        OUT         dyld_cache_header_t**       BaseAddress
    )
{
    BWSR_STATUS                 retVal              = ERROR_FAILURE;
    uintptr_t                   sharedCacheBase     = 0;
    task_dyld_info_data_t       taskDyldInfo        = { 0 };
    mach_msg_type_number_t      count               = TASK_DYLD_INFO_COUNT;
    kern_return_t               taskInfoStatus      = KERN_FAILURE;
    dyld_all_image_infos_t*     allImageInfos       = NULL;

    __NOT_NULL( BaseAddress )

    if( 0 != __shared_region_check_np( (uint64_t*) &sharedCacheBase ) )
    {
        BWSR_DEBUG( LOG_WARNING, "__shared_region_check_np() Failed. Attempting task resolve.\n" );
    } // __shared_region_check_np()

    if( sharedCacheBase )
    {
        *BaseAddress    = (dyld_cache_header_t*) sharedCacheBase;
        retVal          = ERROR_SUCCESS;
    }
    else {
        if( KERN_SUCCESS != ( taskInfoStatus = task_info( mach_task_self(),
                                                          TASK_DYLD_INFO,
                                                          (task_info_t) &taskDyldInfo,
                                                          &count ) ) )
        {
            BWSR_DEBUG( LOG_ERROR,
                        "task_info() Failed. retVal: %d\n",
                        taskInfoStatus );
            retVal = ERROR_TASK_INFO;
        }
        else {
            allImageInfos   = (dyld_all_image_infos_t*) taskDyldInfo.all_image_info_addr;
            *BaseAddress    = (dyld_cache_header_t*) allImageInfos->sharedCacheBaseAddress;
            retVal          = ERROR_SUCCESS;
        } // task_info()
    } // shared_cache_base

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_SharedCacheContext_Initialize
    (
        IN  OUT     shared_cache_ctx_t*         Context
    )
{
    BWSR_STATUS                     retVal              = ERROR_FAILURE;
    dyld_cache_header_t*            rtSharedCache       = NULL;
    dyld_cache_mapping_info_t*      mappings            = NULL;
    uintptr_t                       slide               = 0;

    __NOT_NULL( Context )

    memset( Context,
            0,
            sizeof( shared_cache_ctx_t ) );

    if( ERROR_SUCCESS != ( retVal = INTERNAL_GetSharedCacheBaseAddress( &rtSharedCache ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_GetSharedCacheBaseAddress() Failed\n" );
    }
    else {
        Context->RuntimeSharedCache = rtSharedCache;

        mappings    = (dyld_cache_mapping_info_t*) ( (char*) rtSharedCache + rtSharedCache->mappingOffset );
        slide       = (uintptr_t) rtSharedCache - (uintptr_t) ( mappings[ 0 ].address );

        Context->RuntimeSlide = slide;
    } // INTERNAL_GetSharedCacheBaseAddress()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_MapFileOffsetToBuffer
    (
        IN          size_t                      MapSize,
        IN          off_t                       MapOffset,
        IN          const char*                 MapFile,
        OUT         uint8_t**                   MmapBuffer
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    int             fileDescriptor      = -1;

    __NOT_NULL( MapFile, MmapBuffer )

    if( 0 > ( fileDescriptor = open( MapFile,
                                     O_RDONLY,
                                     0 ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "open() Failed\n" );
        retVal = ERROR_FILE_IO;
    }
    else {
        if( MAP_FAILED == ( *MmapBuffer = (uint8_t *) mmap( 0,
                                                            MapSize,
                                                            PROT_READ | PROT_WRITE,
                                                            MAP_PRIVATE,
                                                            fileDescriptor,
                                                            MapOffset ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "mmap() Failed\n" );

            *MmapBuffer = NULL;
            retVal      = ERROR_MEMORY_MAPPING;
        }
        else {
            retVal = ERROR_SUCCESS;
        } // mmap()

        close( fileDescriptor );
    } // open()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_MapSharedCacheToBuffer
    (
        IN          const char*                 MapFile,
        IN  OUT     uint8_t**                   MmapBuffer
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    struct stat     fileStat        = { 0 };
    int             statCode        = 0;

    __NOT_NULL( MapFile, MmapBuffer )

    if( 0 != ( statCode = stat( MapFile, &fileStat ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "stat() Failed\n" );
        retVal = ERROR_FILE_IO;
    }
    else {
        retVal = INTERNAL_MapFileOffsetToBuffer( fileStat.st_size,
                                                 0,
                                                 MapFile,
                                                 MmapBuffer );
    } // stat()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_LoadSymbolsFromSharedCache
    (
        IN          shared_cache_ctx_t*         Context
    )
{
    BWSR_STATUS     retVal                                  = ERROR_SUCCESS;
    uint64_t        localSymbolsOffset                      = 0;
    char*           sharedCachePath                         = NULL;
    char            sharedCacheSymbolsPath[ PATH_MAX ]      = { 0 };
    uint8_t*        mmBuffer                                = NULL;

    __NOT_NULL( Context )

    if( NULL == ( sharedCachePath = (char*) dyld_shared_cache_file_path() ) )
    {
        BWSR_DEBUG( LOG_ERROR, "dyld_shared_cache_file_path() Failed\n" );
        retVal = ERROR_CACHED_LOCATION;
    }
    else {
        (void) strncat( sharedCacheSymbolsPath,
                        sharedCachePath,
                        PATH_MAX );
        (void) strncat( sharedCacheSymbolsPath,
                        SYMBOLS_FILE_EXTENSION,
                        sizeof( SYMBOLS_FILE_EXTENSION ) );

        if( ERROR_SUCCESS != ( retVal = INTERNAL_MapSharedCacheToBuffer( sharedCacheSymbolsPath, &mmBuffer ) ) )
        {
            // Probably iOS < 15.0
            if( 0 == Context->RuntimeSharedCache->localSymbolsSize )
            {
                BWSR_DEBUG( LOG_CRITICAL, "Context->RuntimeSharedCache->localSymbolsSize Invalid.\n" );
                retVal = ERROR_SYMBOL_SIZE;
            }
            else {
                if( ERROR_SUCCESS != ( retVal = INTERNAL_MapFileOffsetToBuffer( Context->RuntimeSharedCache->localSymbolsSize,
                                                                                Context->RuntimeSharedCache->localSymbolsOffset,
                                                                                sharedCachePath,
                                                                                &mmBuffer ) ) )
                {
                    BWSR_DEBUG( LOG_ERROR, "INTERNAL_MapFileOffsetToBuffer() Failed.\n" );
                }
                else {
                    Context->MmapSharedCache = (dyld_cache_header_t*)
                        ( (uintptr_t) mmBuffer - Context->RuntimeSharedCache->localSymbolsOffset );

                    localSymbolsOffset  = Context->RuntimeSharedCache->localSymbolsOffset;
                } // INTERNAL_MapFileOffsetToBuffer()
            } // Context->RuntimeSharedCache->localSymbolsSize
        }
        else {
            // iOS >= 15.0
            Context->MmapSharedCache    = (dyld_cache_header_t*)mmBuffer;
            localSymbolsOffset          = Context->MmapSharedCache->localSymbolsOffset;
        } // INTERNAL_MapSharedCacheToBuffer()

        if( ERROR_SUCCESS == retVal )
        {
            Context->LocalSymbolsInfo    = (dcls_info_t*)
                ( (char*)Context->MmapSharedCache + localSymbolsOffset );
            Context->LocalSymbolsEntries = (dcls_entry_t*)
                ( (char*)Context->LocalSymbolsInfo + Context->LocalSymbolsInfo->entriesOffset );
            Context->SymbolTable = (nlist_t*)
                ( (char*)Context->LocalSymbolsInfo + Context->LocalSymbolsInfo->nlistOffset );
            Context->StringTable = (char*)
                ( (char*)Context->LocalSymbolsInfo + Context->LocalSymbolsInfo->stringsOffset );
        } // ERROR_SUCCESS == retVal
    } // dyld_shared_cache_file_path()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_IsAddressInSharedCache
    (
        IN          shared_cache_ctx_t*         Context,
        IN          uintptr_t                   Address
    )
{
    BWSR_STATUS             retVal                  = ERROR_FAILURE;
    dyld_cache_header_t*    runtimeSharedCache      = NULL;
    uintptr_t               regionStart             = 0;
    uintptr_t               regionEnd               = 0;

    __NOT_NULL( Context )
    __GREATER_THAN_0( Address )

    if( Context )
    {
        runtimeSharedCache = Context->RuntimeSharedCache;
    }
    else
    {
        (void) INTERNAL_GetSharedCacheBaseAddress( &runtimeSharedCache );
    } // Context

    if( NULL == runtimeSharedCache )
    {
        BWSR_DEBUG( LOG_ERROR, "Failed to initialize shared cache!\n" );
        retVal = ERROR_SHARED_CACHE;
    }
    else {
        regionStart     = runtimeSharedCache->sharedRegionStart + Context->RuntimeSlide;
        regionEnd       = regionStart + runtimeSharedCache->sharedRegionSize;
        retVal          = ( ( ( Address >= regionStart ) && ( Address < regionEnd ) )
                            ? ERROR_SUCCESS
                            : ERROR_NOT_FOUND );
    } // runtimeSharedCache

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_LoadSymbolTableFromSharedCache
    (
        IN          shared_cache_ctx_t*         Context,
        IN          mach_header_t*              ImageHeader,
        OUT         nlist_t**                   SymbolTable,
        OUT         uint32_t*                   SymbolTableCount,
        OUT         char**                      StringTable
    )
{
    BWSR_STATUS     retVal              = ERROR_FAILURE;
    uint64_t        offsetInCache       = 0;
    nlist_t*        localNlists         = NULL;
    uint32_t        localNlistCount     = 0;
    uint32_t        itr                 = 0;
    uint32_t        localNlistStart     = 0;

    __NOT_NULL( Context,
                ImageHeader,
                SymbolTable,
                SymbolTableCount,
                StringTable )

    retVal        = ERROR_NOT_FOUND;
    offsetInCache = (uint64_t)ImageHeader - (uint64_t)Context->RuntimeSharedCache;

    for( itr = 0;
        itr < Context->LocalSymbolsInfo->entriesCount &&
        ERROR_NOT_FOUND == retVal;
        ++itr )
    {
        if( Context->LocalSymbolsEntries[ itr ].dylibOffset == offsetInCache )
        {
            localNlistStart = Context->LocalSymbolsEntries[ itr ].nlistStartIndex;
            localNlistCount = Context->LocalSymbolsEntries[ itr ].nlistCount;
            localNlists     = &Context->SymbolTable[ localNlistStart ];
            retVal          = ERROR_SUCCESS;
        }
    } // for()

    *SymbolTable        = localNlists;
    *SymbolTableCount   = (uint32_t) localNlistCount;
    *StringTable        = (char *) Context->StringTable;

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_FindSymbolAddressInSymbolTable
    (
        IN          char*               SymbolNamePattern,
        IN          nlist_t*            SymbolTable,
        IN          uint32_t            SymbolTableCount,
        IN          char*               StringTable,
        OUT         uintptr_t*          SymbolAddress
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    char*           symbolName      = NULL;
    uint32_t        i               = 0;

    __NOT_NULL( SymbolNamePattern,
                SymbolTable,
                StringTable,
                SymbolAddress )
    __GREATER_THAN_0( SymbolTableCount )

    *SymbolAddress  = 0;
    retVal          = ERROR_NOT_FOUND;

    for( i = 0;
        ( i <  SymbolTableCount ) &&
        ( 0 == *SymbolAddress   );
        i++ )
    {
        if( SymbolTable[ i ].n_value )
        {
            symbolName = StringTable + SymbolTable[ i ].n_un.n_strx;

            if( 0 == strcmp( SymbolNamePattern, symbolName ) )
            {
                *SymbolAddress = SymbolTable[ i ].n_value;
                retVal = ERROR_SUCCESS;
            }
            else if( ( '_' == symbolName[ 0 ] ) &&
                     ( 0   == strcmp( SymbolNamePattern, &symbolName[ 1 ] ) ) )
            {
                *SymbolAddress = SymbolTable[ i ].n_value;
                retVal = ERROR_SUCCESS;
            } // strcmp()
        } // SymbolTable[ sym_tab_itr ].n_value
    } // for()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_UpdateContextFromLoadCommand
    (
        IN          load_command_t*         LoadCommand,
        OUT         macho_ctx_t*            Context
    )
{
    BWSR_STATUS             retVal              = ERROR_SUCCESS;
    segment_command_t*      segmentCommand      = NULL;

    // BWSR_DEBUG( LOG_NOTICE,
    //             "Read LC: %s\n",
    //             LoadCommandString( LoadCommand->cmd ) );

    switch( LoadCommand->cmd )
    {
        case LC_SEGMENT_ARCH_DEPENDENT:
        {
            segmentCommand = (segment_command_t*) LoadCommand;
            Context->Segments[ Context->SegmentsCount++ ] = segmentCommand;

            if( !strcmp( segmentCommand->segname, "__LINKEDIT" ) )
            {
                Context->LinkedItSegment = segmentCommand;
            }
            else if( !strcmp( segmentCommand->segname, "__DATA" ) )
            {
                Context->DataSegment = segmentCommand;
            }
            else if( !strcmp( segmentCommand->segname, "__DATA_CONST" ) )
            {
                Context->DataConstSegment = segmentCommand;
            }
            else if( !strcmp( segmentCommand->segname, "__TEXT" ) )
            {
                Context->TextSegment = segmentCommand;
            }
            else if( !strcmp( segmentCommand->segname, "__TEXT_EXEC" ) )
            {
                Context->TextExecSegment = segmentCommand;
            }
            else {
                // BWSR_DEBUG( LOG_WARNING,
                //             "Unhandled segment: %s\n",
                //             segmentCommand->segname );
            } // strcmp()
            break;
        }

        case LC_SYMTAB:
        {
            Context->SymbolTableCommand = (symtab_command_t*) LoadCommand;
            break;
        }

        case LC_DYSYMTAB:
        {
            Context->DySymbolTableCommand = (dysymtab_command_t*) LoadCommand;
            break;
        }

        case LC_DYLD_INFO:
        case LC_DYLD_INFO_ONLY:
        {
            Context->DyldInfoCommand = (dyld_info_command_t*) LoadCommand;
            break;
        }

        case LC_DYLD_EXPORTS_TRIE:
        {
            Context->ExportsTrieCommand = (linkedit_data_command_t*) LoadCommand;
            break;
        }

        case LC_DYLD_CHAINED_FIXUPS:
        {
            Context->ChainedFixupsCommand = (linkedit_data_command_t*) LoadCommand;
            break;
        }

        case LC_CODE_SIGNATURE:
        {
            Context->CodeSignatureCommand = (linkedit_data_command_t*) LoadCommand;
            break;
        }

        default:
        {
            retVal = ERROR_UNHANDLED_DATA_TYPE;
            // BWSR_DEBUG( LOG_WARNING,
            //         "Unhandle Load Command: 0x%" PRIx8 "\n",
            //         LoadCommand->cmd );
            break;
        }
    } // switch()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_MachoContext_Initialize
    (
        IN              mach_header_t*      MachHeader,
        IN              bool                RuntimeMode,
        IN OPTIONAL     mach_header_t*      CacheHeader,
        OUT             macho_ctx_t*        Context
    )
{
    BWSR_STATUS         retVal          = ERROR_SUCCESS;
    load_command_t*     curr_cmd        = NULL;
    segment_command_t*  seg_cmd         = NULL;
    uint32_t            i               = 0;

    __NOT_NULL( MachHeader, Context )

    Context->Header         = MachHeader;
    Context->IsRuntimeMode  = RuntimeMode;
    Context->CacheHeader    = CacheHeader;

    curr_cmd = (load_command_t*)( (uintptr_t)MachHeader + sizeof( mach_header_t ) );

    for( i = 0; i < MachHeader->ncmds; i++ )
    {
        (void)INTERNAL_UpdateContextFromLoadCommand( curr_cmd, Context );
        curr_cmd = (load_command_t*)( (uintptr_t)curr_cmd + curr_cmd->cmdsize );
    } // for()

    Context->Slide          = (uintptr_t)MachHeader
                            - (uintptr_t)Context->TextSegment->vmaddr;
    Context->LinkedItBase   = (uintptr_t)Context->Slide
                            + Context->LinkedItSegment->vmaddr
                            - Context->LinkedItSegment->fileoff;

    if( !RuntimeMode )
    {
        Context->LinkedItBase = (uintptr_t)( CacheHeader ? CacheHeader : MachHeader );
    }

    Context->VmRegionStart  = (uintptr_t)-1;
    Context->VmRegionEnd    = 0;

    for( i = 0; i < (uint32_t)Context->SegmentsCount; i++ )
    {
        seg_cmd = Context->Segments[ i ];

        if( !strcmp( seg_cmd->segname, "__PAGEZERO" ) )
        {
            continue;
        }
        if( !strcmp( seg_cmd->segname, "__TEXT" ) )
        {
            Context->LoadVmAddr = seg_cmd->vmaddr;
        }

        if( Context->VmRegionStart > seg_cmd->vmaddr )
        {
            Context->VmRegionStart = seg_cmd->vmaddr;
        }
        if( Context->VmRegionEnd < ( seg_cmd->vmaddr + seg_cmd->vmsize ) )
        {
            Context->VmRegionEnd    = seg_cmd->vmaddr + seg_cmd->vmsize;
        }
    } // for()

    Context->VmSize = Context->VmRegionEnd - Context->VmRegionStart;

    if( Context->SymbolTableCommand )
    {
        Context->SymbolTable = (nlist_t*)( Context->LinkedItBase + Context->SymbolTableCommand->symoff );
        Context->StringTable = (char*)( Context->LinkedItBase + Context->SymbolTableCommand->stroff );
    }

    if( Context->DySymbolTableCommand )
    {
        Context->IndirectSymbolTable = (uint32_t*)( Context->LinkedItBase + Context->DySymbolTableCommand->indirectsymoff );
    }

    // BWSR_DEBUG( LOG_INFO,
    //             "Header: %p: region: %" PRIuPTR
    //             " - %" PRIuPTR
    //             ", load_vmaddr: %" PRIuPTR
    //             ", vmsize: %zu, slide: %" PRIuPTR "\n",
    //             Context->Header,
    //             Context->VmRegionStart,
    //             Context->VmRegionEnd,
    //             Context->LoadVmAddr,
    //             Context->VmSize,
    //             Context->Slide );

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ResolveAddressWithSymbolTable
    (
        IN          macho_ctx_t*            Context,
        IN          const char*             SymbolNamePattern,
        IN OUT      uintptr_t*              SymbolAddress
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    char*           symbolName      = NULL;
    uint32_t        i               = 0;

    __NOT_NULL( Context,
                SymbolNamePattern,
                SymbolAddress )

    *SymbolAddress  = 0;
    retVal          = ERROR_NOT_FOUND;

    for( i = 0;
        ( i < Context->SymbolTableCommand->nsyms ) &&
        ( ERROR_NOT_FOUND == retVal );
        i++ )
    {
        if( Context->SymbolTable[ i ].n_value )
        {
            symbolName = Context->StringTable + Context->SymbolTable[ i ].n_un.n_strx;

            if( 0 == strcmp( SymbolNamePattern, symbolName ) )
            {
                *SymbolAddress = Context->SymbolTable[ i ].n_value;
                retVal = ERROR_SUCCESS;
            }
            else if( ( '_' == symbolName[ 0 ]                               ) &&
                     ( 0   == strcmp( SymbolNamePattern, &symbolName[ 1 ] ) ) )
            {
                *SymbolAddress = Context->SymbolTable[ i ].n_value;
                retVal = ERROR_SUCCESS;
            } // strcmp()
        } // Context->symtab[ symbol_itr ].n_value
    } // for()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ResolveAddressForSymbol
    (
        IN  OUT     macho_ctx_t*            Context,
        IN          const char*             SymbolName,
        OUT         uintptr_t*              SymbolAddress
    )
{
    BWSR_STATUS  retVal = ERROR_FAILURE;

    __NOT_NULL( Context,
                SymbolName,
                SymbolAddress )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_ResolveAddressWithSymbolTable( Context,
                                                                            SymbolName,
                                                                            SymbolAddress ) ) )
    {
        /**
         * NOTE: This can be noisy if no image name was given. Since each
         * image needs to be check individually. In this case failures
         * are normal until a proper match is found.
         */
        // BWSR_DEBUG( LOG_ERROR, "INTERNAL_ResolveAddressWithSymbolTable() Failed\n" );
    }
    else {
        *SymbolAddress = *SymbolAddress + ( Context->IsRuntimeMode ? Context->Slide : 0 );
    } // INTERNAL_ResolveAddressWithSymbolTable()

    return retVal;
}


static
BWSR_STATUS
    INTERNAL_ResolveSymbol_SharedCache
    (
        IN          const char*             SymbolName,
        IN          const mach_header_t*    MachHeader,
        IN  OUT     uintptr_t*              FunctionAddress
    )
{
    BWSR_STATUS         retVal              = ERROR_FAILURE;
    nlist_t*            symbolTable         = NULL;
    uint32_t            symbolTableCount    = 0;
    char*               stringTable         = NULL;
    shared_cache_ctx_t  context             = { 0 };

    __NOT_NULL( SymbolName,
                MachHeader,
                FunctionAddress )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_SharedCacheContext_Initialize( &context ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_SharedCacheContext_Initialize() Failed\n" );
    }
    else {
        if( ERROR_SUCCESS != ( retVal = INTERNAL_LoadSymbolsFromSharedCache( &context ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "INTERNAL_LoadSymbolsFromSharedCache() Failed\n" );
        }
        else {
            if( NULL != context.MmapSharedCache )
            {
                if( ERROR_SUCCESS != ( retVal = INTERNAL_IsAddressInSharedCache( &context, (uintptr_t)MachHeader ) ) )
                {
                    BWSR_DEBUG( LOG_ERROR, "INTERNAL_IsAddressInSharedCache() Failed\n" );
                }
                else {
                    retVal = INTERNAL_LoadSymbolTableFromSharedCache( &context,
                                                                      (mach_header_t*)MachHeader,
                                                                      &symbolTable,
                                                                      &symbolTableCount,
                                                                      &stringTable );
                } // INTERNAL_IsAddressInSharedCache()
            } // shared_cache_ctx.MmapSharedCache

            if( ( NULL != symbolTable ) &&
                ( NULL != stringTable ) )
            {
                if( ERROR_SUCCESS != ( retVal = INTERNAL_FindSymbolAddressInSymbolTable( (char*)SymbolName,
                                                                                         symbolTable,
                                                                                         symbolTableCount,
                                                                                         stringTable,
                                                                                         FunctionAddress ) ) )
                {
                    /**
                     * NOTE: This can be noisy if no image name was given. Since each
                     * image needs to be check individually. In this case failures
                     * are normal until a proper match is found.
                     */
                    // BWSR_DEBUG( LOG_ERROR, "INTERNAL_FindSymbolAddressInSymbolTable() Failed\n" );
                }
                else {
                    BWSR_DEBUG( LOG_INFO,
                                "Address: %" PRIuPTR ", Slide: %" PRIuPTR "\n",
                                *FunctionAddress,
                                context.RuntimeSlide );

                    *FunctionAddress = *FunctionAddress + context.RuntimeSlide;
                } // INTERNAL_FindSymbolAddressInSymbolTable()
            } // symbolTable && stringTable
        } // INTERNAL_LoadSymbolsFromSharedCache()
    } // INTERNAL_SharedCacheContext_Initialize()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ResolveSymbol_SymbolTable
    (
        IN          const char*             SymbolName,
        IN          const mach_header_t*    MachHeader,
        IN  OUT     uintptr_t*              FunctionAddress
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    macho_ctx_t     machoContext    = { 0 };

    __NOT_NULL( SymbolName,
                MachHeader,
                FunctionAddress )

    if( ERROR_SUCCESS != ( retVal = INTERNAL_MachoContext_Initialize( (mach_header_t*)MachHeader,
                                                                      true,
                                                                      NULL,
                                                                      &machoContext ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "INTERNAL_MachoContext_Initialize() Failed\n" );
    }
    else {
        retVal = INTERNAL_ResolveAddressForSymbol( &machoContext,
                                                   SymbolName,
                                                   FunctionAddress );
    } // INTERNAL_MachoContext_Initialize()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ResolveSymbol
    (
        IN              const char*             SymbolName,
        IN OPTIONAL     const char*             ImageName,
        OUT             uintptr_t*              Address
    )
{
    BWSR_STATUS         retVal          = ERROR_FAILURE;
    uint32_t            count           = 0;
    uint32_t            i               = 0;
    char*               imageName       = NULL;
    mach_header_t*      machHeader      = NULL;

    __NOT_NULL( SymbolName, Address )

    count           = _dyld_image_count();
    retVal          = ERROR_NOT_FOUND;

    for( i = 0; ( i < count ) && ( ERROR_NOT_FOUND == retVal ); i++ )
    {

        if( NULL == ( imageName = (char*) _dyld_get_image_name( i ) ) )
        {
            continue;
        } // _dyld_get_image_name

        if( ( NULL != ImageName           ) &&
            ( NULL == strnstr( imageName,
                               ImageName,
                               PATH_MAX ) ) )
        {
            continue;
        } // strnstr()

        if( NULL == ( machHeader = (mach_header_t*) _dyld_get_image_header( i ) ) )
        {
            continue;
        } // _dyld_get_image_header()

        if( ERROR_SUCCESS != ( retVal = INTERNAL_ResolveSymbol_SharedCache( SymbolName,
                                                                            machHeader,
                                                                            Address ) ) )
        {
            retVal = INTERNAL_ResolveSymbol_SymbolTable( SymbolName,
                                                         machHeader,
                                                         Address );
        } // INTERNAL_ResolveSymbol_SharedCache()
    } // for()

    return retVal;
}

BWSR_API
BWSR_STATUS
    BWSR_ResolveSymbol
    (
        IN              const char*             SymbolName,
        IN OPTIONAL     const char*             ImageName,
        OUT             uintptr_t*              Address
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( SymbolName, Address )

    retVal = INTERNAL_ResolveSymbol( SymbolName,
                                     ImageName,
                                     Address );

    __DEBUG_RETVAL( retVal )
    return retVal;
}

```

`SymbolResolve/Darwin/Macho.h`:

```h

#ifndef __MACHO_H__
#define __MACHO_H__

int
    BWSR_ResolveSymbol
    (
        const char*             SymbolName,
        const char*             ImageName,
        uintptr_t*              Address
    );

#endif // __MACHO_H__

```

`SymbolResolve/Linux/Elf.c`:

```c

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <elf.h>

#include <dlfcn.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#include <limits.h>

#include "utility/debug.h"
#include "utility/error.h"
#include "utility/utility.h"

#include "Memory/Memory.h"

// -----------------------------------------------------------------------------
//  STRUCTURES & DEFINITIONS
// -----------------------------------------------------------------------------

#ifndef LINE_MAX
    #define LINE_MAX                ( 1024 )
#endif

#define EXTENSION_LENGTH            ( 7 )
#define MODULE_BASE_CAPACITY        ( 16 )

#if defined(__LP64__)

    typedef Elf64_Shdr  elf_shdr_t;
    typedef Elf64_Sym   elf_sym_t;
    typedef Elf64_Addr  elf_addr_t;
    typedef Elf64_Dyn   elf_dyn_t;
    typedef Elf64_Phdr  elf_phdr_t;
    typedef Elf64_Ehdr  elf_ehdr_t;

#else

    typedef Elf32_Shdr  elf_shdr_t;
    typedef Elf32_Sym   elf_sym_t;
    typedef Elf32_Addr  elf_addr_t;
    typedef Elf32_Dyn   elf_dyn_t;
    typedef Elf32_Phdr  elf_phdr_t;
    typedef Elf32_Ehdr  elf_ehdr_t;

#endif

typedef struct elf_ctx {
    void*           Header;

    uintptr_t       LoadBias;

    elf_shdr_t*     SymbolSh;
    elf_shdr_t*     DynamicSymbolSh;

    const char*     StringTable;
    elf_sym_t*      SymbolTable;

    const char*     DynamicStringTable;
    elf_sym_t*      DynamicSymbolTable;
} elf_ctx_t;

typedef struct runtime_module_t {
    void*     Base;
    char      Path[ 1024 ];
} runtime_module_t;

// -----------------------------------------------------------------------------
//  GLOBALS
// -----------------------------------------------------------------------------

static struct {
    runtime_module_t*   Data;
    size_t              Size;
    size_t              Capacity;
} modules = {
    NULL,
    0,
    0
};

// -----------------------------------------------------------------------------
//  IMPLEMENTATION
// -----------------------------------------------------------------------------

static
BWSR_STATUS
    INTERNAL_AppendRuntimeModule
    (
        IN          runtime_module_t        Module
    )
{
    BWSR_STATUS         retVal          = ERROR_FAILURE;
    runtime_module_t*   runtimeModule   = NULL;
    size_t              allocationSize  = 0;

    if( NULL == modules.Data )
    {
        modules.Capacity    = MODULE_BASE_CAPACITY;
        allocationSize      = modules.Capacity * sizeof( runtime_module_t );

        if( NULL == ( modules.Data = BwsrMalloc( allocationSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "BwsrMalloc() Failed\n" );
            retVal = ERROR_MEM_ALLOC;
        }
        else {
            retVal = ERROR_SUCCESS;
        } // BwsrMalloc()
    }
    else if( modules.Size >= modules.Capacity )
    {
        modules.Capacity    *= 2;
        allocationSize      = modules.Capacity * sizeof( runtime_module_t );

        if( NULL == ( runtimeModule = BwsrRealloc( modules.Data, allocationSize ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "BwsrRealloc() Failed\n" );
            retVal = ERROR_MEM_ALLOC;
        }
        else {
            modules.Data = runtimeModule;
            retVal = ERROR_SUCCESS;
        } // BwsrRealloc()
    }
    else {
        retVal = ERROR_SUCCESS;
    } // Module Capacity

    if( ERROR_SUCCESS == retVal )
    {
        modules.Data[ modules.Size++ ] = Module;
    }

    return retVal;
}

static
void
    INTERNAL_ReleaseRuntimeModules
    (
        void
    )
{
    BwsrFree( modules.Data );
    modules.Data      = NULL;
    modules.Size      = 0;
    modules.Capacity  = 0;
}

static
BWSR_STATUS
    INTERNAL_GetProcessMap_ProcSelfMaps
    (
        void
    )
{
    BWSR_STATUS     retVal                          = ERROR_FAILURE;
    FILE*           fp                              = NULL;
    char            line_buffer[ LINE_MAX + 1 ]     = { 0 };
    uintptr_t       region_start                    = 0;
    uintptr_t       region_end                      = 0;
    uintptr_t       region_offset                   = 0;
    char            permissions[ 5 ]                = { 0 };
    uint8_t         dev_major                       = 0;
    uint8_t         dev_minor                       = 0;
    long            inode                           = 0;
    int             path_index                      = 0;
    char*           path_buffer                     = NULL;

    if( NULL == ( fp = fopen( "/proc/self/maps", "r" ) ) )
    {
        BWSR_DEBUG( LOG_ERROR, "fopen() Failed\n" );
        retVal = ERROR_PROC_SELF_MAPS;
    }
    else {
        retVal = ERROR_SUCCESS;

        while( !feof( fp ) && ERROR_SUCCESS == retVal )
        {
            memset( line_buffer, 0, sizeof( line_buffer ) );

            if( NULL == fgets( line_buffer,
                                sizeof( line_buffer ),
                                fp ) )
            {
                break;
            }

            if( ( LINE_MAX == strnlen( line_buffer, LINE_MAX ) ) &&
                ( '\n'     != line_buffer[ LINE_MAX ]          ) )
            {
                int c = 0;

                do
                {
                    c = getc( fp );
                } while( ( EOF != c ) && ( '\n' != c ) );

                if( EOF == c )
                {
                    break;
                }
            }

            if( 7 > sscanf( line_buffer,
                            "%lx-%lx %4c %lx %hhx:%hhx %ld %n",
                            &region_start,
                            &region_end,
                            permissions,
                            &region_offset,
                            &dev_major,
                            &dev_minor,
                            &inode,
                            &path_index ) )
            {
                BWSR_DEBUG( LOG_ERROR, "sscanf() Failed\n" );
                INTERNAL_ReleaseRuntimeModules( );
                retVal = ERROR_UNEXPECTED_FORMAT;
            }
            else {
                if( ( 0 != strcmp( permissions, "r--p" ) ) &&
                    ( 0 != strcmp( permissions, "r-xp" ) ) )
                {
                    continue;
                }

                if( 0 != memcmp( ( (Elf64_Ehdr*) region_start )->e_ident,
                                ELFMAG,
                                SELFMAG ) )
                {
                    continue;
                }

                path_buffer = line_buffer + path_index;

                if( ( 0    == *path_buffer ) ||
                    ( '\n' == *path_buffer ) ||
                    ( '['  == *path_buffer ) )
                {
                    continue;
                }

                if( '\n' == path_buffer[ strlen( path_buffer ) - 1 ] )
                {
                    path_buffer[ strlen( path_buffer ) - 1 ] = 0x00;
                }

                runtime_module_t module;

                strncpy( module.Path,
                        path_buffer,
                        sizeof( module.Path ) - 1 );

                module.Base = (void*) region_start;

                retVal = INTERNAL_AppendRuntimeModule( module );
            } // sscanf()
        } // while()

        fclose( fp );
    } // fopen()

    return retVal;
}

static
void
    INTERNAL_ElfContext_Initialize
    (
        OUT         elf_ctx_t*          Context,
        IN          const void*         Header
    )
{
    size_t          i               = 0;
    elf_phdr_t*     phdr            = NULL;
    elf_shdr_t*     shstr_sh        = NULL;
    char*           shstrtab        = NULL;
    elf_shdr_t*     shdr            = NULL;
    elf_ehdr_t*     ehdr            = NULL;
    elf_addr_t      ehdr_addr       = 0;

    __NOT_NULL_RETURN_VOID( Context, Header );

    ehdr            = (elf_ehdr_t*) Header;
    ehdr_addr       = (elf_addr_t) ehdr;
    Context->Header = ehdr;

    // Dynamic Segment
    {
        phdr = (elf_phdr_t*) ( ehdr_addr + ehdr->e_phoff );

        for( i = 0; i < ehdr->e_phnum; i++ )
        {
            if( ( PT_LOAD == phdr[ i ].p_type  ) &&
                ( 0       == Context->LoadBias ) )
            {
                Context->LoadBias = ehdr_addr - ( phdr[ i ].p_vaddr - phdr[ i ].p_offset );
            }
            else if( PT_PHDR == phdr[ i ].p_type )
            {
                Context->LoadBias = (elf_addr_t) phdr - phdr[ i ].p_vaddr;
            } // P Type
        } // for()
    } // Dynamic Segment

    // Section
    {
        shdr     = (elf_shdr_t*) ( ehdr_addr + ehdr->e_shoff );
        shstr_sh = &shdr[ ehdr->e_shstrndx ];
        shstrtab = (char*) ( (uintptr_t) ehdr_addr + shstr_sh->sh_offset );

        for( i = 0; i < ehdr->e_shnum; i++ )
        {
            if( SHT_SYMTAB == shdr[ i ].sh_type )
            {
                Context->SymbolSh = &shdr[ i ];
                Context->SymbolTable = (elf_sym_t*) ( ehdr_addr + shdr[ i ].sh_offset );
            }
            else if( ( SHT_STRTAB == shdr[ i ].sh_type ) &&
                     ( 0          == strncmp( ( shstrtab + shdr[ i ].sh_name ),
                                              ".strtab",
                                              EXTENSION_LENGTH ) ) )
            {
                Context->StringTable = (const char*) ( ehdr_addr + shdr[ i ].sh_offset );
            }
            else if( SHT_DYNSYM == shdr[ i ].sh_type )
            {
                Context->DynamicSymbolSh = &shdr[ i ];
                Context->DynamicSymbolTable = (elf_sym_t*) ( ehdr_addr + shdr[ i ].sh_offset );
            }
            else if( ( SHT_STRTAB == shdr[ i ].sh_type ) &&
                     ( 0          == strncmp( ( shstrtab + shdr[ i ].sh_name ),
                                              ".dynstr",
                                              EXTENSION_LENGTH ) ) )
            {
                Context->DynamicStringTable = (const char*) ( ehdr_addr + shdr[ i ].sh_offset );
            } // SH Type
        } // for()
    } // Section
}

static
BWSR_STATUS
    INTERNAL_MMapModulePath
    (
        OUT         uint8_t**           MMapBuffer,
        OUT         size_t*             MMapBufferSize,
        IN          const uint8_t*      ModulePath
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    size_t          file_size       = 0;
    struct stat     s               = { 0 };
    int             fd              = 0;

    __NOT_NULL( MMapBuffer, ModulePath )

    if( 0 != stat( (const char*) ModulePath, &s ) )
    {
        BWSR_DEBUG( LOG_ERROR, "stat() Failed\n" );
        retVal = ERROR_FILE_IO;
    }
    else {
        file_size = s.st_size;

        if( 0 > ( fd = open( (const char*) ModulePath,
                             O_RDONLY,
                             0 ) ) )
        {
            BWSR_DEBUG( LOG_ERROR, "open() Failed\n" );
            retVal = ERROR_FILE_IO;
        }
        else {
            if( MAP_FAILED == ( *MMapBuffer = (uint8_t*) mmap( 0,
                                                               file_size,
                                                               ( PROT_READ | PROT_WRITE ),
                                                               MAP_PRIVATE,
                                                               fd,
                                                               0 ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "mmap() Failed\n" );
                retVal = ERROR_MEMORY_MAPPING;
            }
            else {
                if( NULL != MMapBufferSize )
                {
                    *MMapBufferSize = file_size;
                } // mmap_buffer_size

                retVal = ERROR_SUCCESS;
            } // mmap()

            close(fd);
        } // open()
    } // stat()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_GetValueFromSymbolTable
    (
        IN          const char*         SymbolName,
        IN          elf_sym_t*          SymbolTable,
        IN          const char*         StringTable,
        IN          size_t              Count,
        OUT         void**              Value
    )
{
    BWSR_STATUS     retVal          = ERROR_FAILURE;
    size_t          i               = 0;
    elf_sym_t*      sym             = NULL;
    char*           symbol_name     = NULL;

    __NOT_NULL( SymbolName,
                SymbolTable,
                StringTable,
                Value )
    __GREATER_THAN_0( Count )

    retVal  = ERROR_NOT_FOUND;
    *Value  = NULL;

    for( i = 0; ( i < Count ) && ( ERROR_NOT_FOUND == retVal ); ++i )
    {
        sym         = SymbolTable + i;
        symbol_name = (char*) StringTable + sym->st_name;

        if( 0 == strcmp( (const char*) symbol_name, SymbolName ) )
        {
            retVal  = ERROR_SUCCESS;
            *Value  = (void*) sym->st_value;
        } // strcmp()
    } // for()

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ElfContext_GetValueFromSymbolTable
    (
        IN          elf_ctx_t*          Context,
        IN          const char*         SymbolName,
        OUT         void**              Result
    )
{
    BWSR_STATUS     retVal      = ERROR_FAILURE;
    size_t          count       = 0;

    __NOT_NULL( Context,
                SymbolName,
                Result )

    if( ( NULL != Context->SymbolTable ) &&
        ( NULL != Context->StringTable ) )
    {
        count   = Context->SymbolSh->sh_size / sizeof( elf_sym_t );

        retVal  = INTERNAL_GetValueFromSymbolTable( SymbolName,
                                                    Context->SymbolTable,
                                                    Context->StringTable,
                                                    count,
                                                    Result );
    }

    if( ERROR_SUCCESS != retVal )
    {
        if( ( NULL != Context->DynamicSymbolTable ) &&
            ( NULL != Context->DynamicStringTable ) )
        {
            count   = Context->DynamicSymbolSh->sh_size / sizeof( elf_sym_t );

            retVal  = INTERNAL_GetValueFromSymbolTable( SymbolName,
                                                        Context->DynamicSymbolTable,
                                                        Context->DynamicStringTable,
                                                        count,
                                                        Result );
        }
    }

    return retVal;
}

static
BWSR_STATUS
    INTERNAL_ResolveSymbol
    (
        IN          const char*         LibraryName,
        IN          const char*         SymbolName,
        OUT         uintptr_t*          Address
    )
{
    BWSR_STATUS         retVal      = ERROR_FAILURE;
    uint8_t*            file_mem    = NULL;
    size_t              i           = 0;
    runtime_module_t*   module      = NULL;
    elf_ctx_t           context     = { 0 };

    __NOT_NULL( SymbolName, Address )

    *Address = 0;

    for( i = 0; ( i < modules.Size ) && ( 0 == *Address ); i++ )
    {
        module = &modules.Data[ i ];

        if( ( NULL != LibraryName ) &&
            ( 0    != strncmp( LibraryName,
                               modules.Data[ i ].Path,
                               PATH_MAX ) ) )
        {
            continue;
        } // strncmp()

        if( module->Base )
        {
            if( ERROR_SUCCESS != ( retVal = INTERNAL_MMapModulePath( &file_mem,
                                                                     NULL,
                                                                     (const uint8_t*) module->Path ) ) )
            {
                BWSR_DEBUG( LOG_ERROR, "INTERNAL_MMapModulePath() Failed\n" );
            }
            else {
                memset( &context,
                        0,
                        sizeof( elf_ctx_t ) );

                INTERNAL_ElfContext_Initialize( &context, file_mem );

                if( ERROR_SUCCESS != ( retVal = INTERNAL_ElfContext_GetValueFromSymbolTable( &context,
                                                                                             SymbolName,
                                                                                             (void**) Address ) ) )
                {
                    BWSR_DEBUG( LOG_WARNING, "INTERNAL_ElfContext_GetValueFromSymbolTable() Failed. Retrying.\n" );
                }
                else {
                    if( *Address )
                    {
                        *Address = ( (uintptr_t) *Address
                                    + (uintptr_t) module->Base
                                    - ( (uintptr_t) file_mem - (uintptr_t) context.LoadBias ) );
                        retVal  = ERROR_SUCCESS;
                    } // Address
                } // INTERNAL_ElfContext_GetValueFromSymbolTable()
            } // INTERNAL_MMapModulePath()
        } // module->Base
    } // for()

    if( 0 == *Address )
    {
        retVal = ERROR_NOT_FOUND;
    } // Address

    return retVal;
}

BWSR_API
BWSR_STATUS
    BWSR_ResolveSymbol
    (
        IN              const char*             SymbolName,
        IN OPTIONAL     const char*             ImageName,
        OUT             uintptr_t*              Address
    )
{
    BWSR_STATUS retVal = ERROR_FAILURE;

    __NOT_NULL( SymbolName, Address )

    INTERNAL_GetProcessMap_ProcSelfMaps();

    retVal = INTERNAL_ResolveSymbol( ImageName,
                                     SymbolName,
                                     Address );

    INTERNAL_ReleaseRuntimeModules();

    __DEBUG_RETVAL( retVal )
    return retVal;
}

```

`SymbolResolve/Linux/Elf.h`:

```h
#ifndef __ELF_H__
#define __ELF_H__

int
    BWSR_ResolveSymbol
    (
        const char*             SymbolName,
        const char*             ImageName,
        uintptr_t*              Address
    );

#endif // __MACHO_H__
```

`apple/cs_blobs.h`:

```h
/*
 * Copyright (c) 2017 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_CODESIGN_H_
#define _KERN_CODESIGN_H_

#include <stdint.h>
#include <string.h>

/* code signing attributes of a process */
#define CS_VALID                    0x00000001  /* dynamically valid */
#define CS_ADHOC                    0x00000002  /* ad hoc signed */
#define CS_GET_TASK_ALLOW           0x00000004  /* has get-task-allow entitlement */
#define CS_INSTALLER                0x00000008  /* has installer entitlement */

#define CS_FORCED_LV                0x00000010  /* Library Validation required by Hardened System Policy */
#define CS_INVALID_ALLOWED          0x00000020  /* (macOS Only) Page invalidation allowed by task port policy */

#define CS_HARD                     0x00000100  /* don't load invalid pages */
#define CS_KILL                     0x00000200  /* kill process if it becomes invalid */
#define CS_CHECK_EXPIRATION         0x00000400  /* force expiration checking */
#define CS_RESTRICT                 0x00000800  /* tell dyld to treat restricted */

#define CS_ENFORCEMENT              0x00001000  /* require enforcement */
#define CS_REQUIRE_LV               0x00002000  /* require library validation */
#define CS_ENTITLEMENTS_VALIDATED   0x00004000  /* code signature permits restricted entitlements */
#define CS_NVRAM_UNRESTRICTED       0x00008000  /* has com.apple.rootless.restricted-nvram-variables.heritable entitlement */

#define CS_RUNTIME                  0x00010000  /* Apply hardened runtime policies */
#define CS_LINKER_SIGNED            0x00020000  /* Automatically signed by the linker */

#define CS_ALLOWED_MACHO            (CS_ADHOC | CS_HARD | CS_KILL | CS_CHECK_EXPIRATION | \
	                             CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV | CS_RUNTIME | CS_LINKER_SIGNED)

#define CS_EXEC_SET_HARD            0x00100000  /* set CS_HARD on any exec'ed process */
#define CS_EXEC_SET_KILL            0x00200000  /* set CS_KILL on any exec'ed process */
#define CS_EXEC_SET_ENFORCEMENT     0x00400000  /* set CS_ENFORCEMENT on any exec'ed process */
#define CS_EXEC_INHERIT_SIP         0x00800000  /* set CS_INSTALLER on any exec'ed process */

#define CS_KILLED                   0x01000000  /* was killed by kernel for invalidity */
#define CS_NO_UNTRUSTED_HELPERS     0x02000000  /* kernel did not load a non-platform-binary dyld or Rosetta runtime */
#define CS_DYLD_PLATFORM            CS_NO_UNTRUSTED_HELPERS /* old name */
#define CS_PLATFORM_BINARY          0x04000000  /* this is a platform binary */
#define CS_PLATFORM_PATH            0x08000000  /* platform binary by the fact of path (osx only) */

#define CS_DEBUGGED                 0x10000000  /* process is currently or has previously been debugged and allowed to run with invalid pages */
#define CS_SIGNED                   0x20000000  /* process has a signature (may have gone invalid) */
#define CS_DEV_CODE                 0x40000000  /* code is dev signed, cannot be loaded into prod signed code (will go away with rdar://problem/28322552) */
#define CS_DATAVAULT_CONTROLLER     0x80000000  /* has Data Vault controller entitlement */

#define CS_ENTITLEMENT_FLAGS        (CS_GET_TASK_ALLOW | CS_INSTALLER | CS_DATAVAULT_CONTROLLER | CS_NVRAM_UNRESTRICTED)

/* executable segment flags */

#define CS_EXECSEG_MAIN_BINARY          0x1             /* executable segment denotes main binary */
#define CS_EXECSEG_ALLOW_UNSIGNED       0x10            /* allow unsigned pages (for debugging) */
#define CS_EXECSEG_DEBUGGER             0x20            /* main binary is debugger */
#define CS_EXECSEG_JIT                  0x40            /* JIT enabled */
#define CS_EXECSEG_SKIP_LV              0x80            /* OBSOLETE: skip library validation */
#define CS_EXECSEG_CAN_LOAD_CDHASH      0x100           /* can bless cdhash for execution */
#define CS_EXECSEG_CAN_EXEC_CDHASH      0x200           /* can execute blessed cdhash */

/*
 * Magic numbers used by Code Signing
 */
enum {
	CSMAGIC_REQUIREMENT = 0xfade0c00,               /* single Requirement blob */
	CSMAGIC_REQUIREMENTS = 0xfade0c01,              /* Requirements vector (internal requirements) */
	CSMAGIC_CODEDIRECTORY = 0xfade0c02,             /* CodeDirectory blob */
	CSMAGIC_EMBEDDED_SIGNATURE = 0xfade0cc0, /* embedded form of signature data */
	CSMAGIC_EMBEDDED_SIGNATURE_OLD = 0xfade0b02,    /* XXX */
	CSMAGIC_EMBEDDED_ENTITLEMENTS = 0xfade7171,     /* embedded entitlements */
	CSMAGIC_EMBEDDED_DER_ENTITLEMENTS = 0xfade7172, /* embedded DER encoded entitlements */
	CSMAGIC_DETACHED_SIGNATURE = 0xfade0cc1, /* multi-arch collection of embedded signatures */
	CSMAGIC_BLOBWRAPPER = 0xfade0b01,       /* CMS Signature, among other things */
	CSMAGIC_EMBEDDED_LAUNCH_CONSTRAINT = 0xfade8181, /* Light weight code requirement */

	CS_SUPPORTSSCATTER = 0x20100,
	CS_SUPPORTSTEAMID = 0x20200,
	CS_SUPPORTSCODELIMIT64 = 0x20300,
	CS_SUPPORTSEXECSEG = 0x20400,
	CS_SUPPORTSRUNTIME = 0x20500,
	CS_SUPPORTSLINKAGE = 0x20600,

	CSSLOT_CODEDIRECTORY = 0,                               /* slot index for CodeDirectory */
	CSSLOT_INFOSLOT = 1,
	CSSLOT_REQUIREMENTS = 2,
	CSSLOT_RESOURCEDIR = 3,
	CSSLOT_APPLICATION = 4,
	CSSLOT_ENTITLEMENTS = 5,
	CSSLOT_DER_ENTITLEMENTS = 7,
	CSSLOT_LAUNCH_CONSTRAINT_SELF = 8,
	CSSLOT_LAUNCH_CONSTRAINT_PARENT = 9,
	CSSLOT_LAUNCH_CONSTRAINT_RESPONSIBLE = 10,
	CSSLOT_LIBRARY_CONSTRAINT = 11,

	CSSLOT_ALTERNATE_CODEDIRECTORIES = 0x1000, /* first alternate CodeDirectory, if any */
	CSSLOT_ALTERNATE_CODEDIRECTORY_MAX = 5,         /* max number of alternate CD slots */
	CSSLOT_ALTERNATE_CODEDIRECTORY_LIMIT = CSSLOT_ALTERNATE_CODEDIRECTORIES + CSSLOT_ALTERNATE_CODEDIRECTORY_MAX, /* one past the last */

	CSSLOT_SIGNATURESLOT = 0x10000,                 /* CMS Signature */
	CSSLOT_IDENTIFICATIONSLOT = 0x10001,
	CSSLOT_TICKETSLOT = 0x10002,

	CSTYPE_INDEX_REQUIREMENTS = 0x00000002,         /* compat with amfi */
	CSTYPE_INDEX_ENTITLEMENTS = 0x00000005,         /* compat with amfi */

	CS_HASHTYPE_SHA1 = 1,
	CS_HASHTYPE_SHA256 = 2,
	CS_HASHTYPE_SHA256_TRUNCATED = 3,
	CS_HASHTYPE_SHA384 = 4,

	CS_SHA1_LEN = 20,
	CS_SHA256_LEN = 32,
	CS_SHA256_TRUNCATED_LEN = 20,

	CS_CDHASH_LEN = 20,                                             /* always - larger hashes are truncated */
	CS_HASH_MAX_SIZE = 48, /* max size of the hash we'll support */

/*
 * Currently only to support Legacy VPN plugins, and Mac App Store
 * but intended to replace all the various platform code, dev code etc. bits.
 */
	CS_SIGNER_TYPE_UNKNOWN = 0,
	CS_SIGNER_TYPE_LEGACYVPN = 5,
	CS_SIGNER_TYPE_MAC_APP_STORE = 6,

	CS_SUPPL_SIGNER_TYPE_UNKNOWN = 0,
	CS_SUPPL_SIGNER_TYPE_TRUSTCACHE = 7,
	CS_SUPPL_SIGNER_TYPE_LOCAL = 8,

	CS_SIGNER_TYPE_OOPJIT = 9,

	/* Validation categories used for trusted launch environment */
	CS_VALIDATION_CATEGORY_INVALID = 0,
	CS_VALIDATION_CATEGORY_PLATFORM = 1,
	CS_VALIDATION_CATEGORY_TESTFLIGHT = 2,
	CS_VALIDATION_CATEGORY_DEVELOPMENT = 3,
	CS_VALIDATION_CATEGORY_APP_STORE = 4,
	CS_VALIDATION_CATEGORY_ENTERPRISE = 5,
	CS_VALIDATION_CATEGORY_DEVELOPER_ID = 6,
	CS_VALIDATION_CATEGORY_LOCAL_SIGNING = 7,
	CS_VALIDATION_CATEGORY_ROSETTA = 8,
	CS_VALIDATION_CATEGORY_OOPJIT = 9,
	CS_VALIDATION_CATEGORY_NONE = 10,
};

/* The set of application types we support for linkage signatures */
enum {
	CS_LINKAGE_APPLICATION_INVALID = 0,
	CS_LINKAGE_APPLICATION_ROSETTA = 1,

	/* XOJIT has been renamed to OOP-JIT */
	CS_LINKAGE_APPLICATION_XOJIT = 2,
	CS_LINKAGE_APPLICATION_OOPJIT = 2,
};

/* The set of application sub-types we support for linkage signatures */
enum {
	/*
	 * For backwards compatibility with older signatures, the AOT sub-type is kept
	 * as 0.
	 */
	CS_LINKAGE_APPLICATION_ROSETTA_AOT = 0,

	/* OOP-JIT sub-types -- XOJIT type kept for external dependencies */
	CS_LINKAGE_APPLICATION_XOJIT_PREVIEWS = 1,
	CS_LINKAGE_APPLICATION_OOPJIT_INVALID = 0,
	CS_LINKAGE_APPLICATION_OOPJIT_PREVIEWS = 1,
	CS_LINKAGE_APPLICATION_OOPJIT_MLCOMPILER = 2,
	CS_LINKAGE_APPLICATION_OOPJIT_TOTAL,
};

/* Integer to string conversion of OOP-JIT types */
static const char *oop_jit_conversion[CS_LINKAGE_APPLICATION_OOPJIT_TOTAL] = {
	[CS_LINKAGE_APPLICATION_OOPJIT_INVALID] = NULL,
	[CS_LINKAGE_APPLICATION_OOPJIT_PREVIEWS] = "previews",
	[CS_LINKAGE_APPLICATION_OOPJIT_MLCOMPILER] = "ml-compiler",
};

#define KERNEL_HAVE_CS_CODEDIRECTORY 1
#define KERNEL_CS_CODEDIRECTORY_HAVE_PLATFORM 1

/*
 * C form of a CodeDirectory.
 */
typedef struct __CodeDirectory {
	uint32_t magic;                                 /* magic number (CSMAGIC_CODEDIRECTORY) */
	uint32_t length;                                /* total length of CodeDirectory blob */
	uint32_t version;                               /* compatibility version */
	uint32_t flags;                                 /* setup and mode flags */
	uint32_t hashOffset;                    /* offset of hash slot element at index zero */
	uint32_t identOffset;                   /* offset of identifier string */
	uint32_t nSpecialSlots;                 /* number of special hash slots */
	uint32_t nCodeSlots;                    /* number of ordinary (code) hash slots */
	uint32_t codeLimit;                             /* limit to main image signature range */
	uint8_t hashSize;                               /* size of each hash in bytes */
	uint8_t hashType;                               /* type of hash (cdHashType* constants) */
	uint8_t platform;                               /* platform identifier; zero if not platform binary */
	uint8_t pageSize;                               /* log2(page size in bytes); 0 => infinite */
	uint32_t spare2;                                /* unused (must be zero) */

	char end_earliest[0];

	/* Version 0x20100 */
	uint32_t scatterOffset;                 /* offset of optional scatter vector */
	char end_withScatter[0];

	/* Version 0x20200 */
	uint32_t teamOffset;                    /* offset of optional team identifier */
	char end_withTeam[0];

	/* Version 0x20300 */
	uint32_t spare3;                                /* unused (must be zero) */
	uint64_t codeLimit64;                   /* limit to main image signature range, 64 bits */
	char end_withCodeLimit64[0];

	/* Version 0x20400 */
	uint64_t execSegBase;                   /* offset of executable segment */
	uint64_t execSegLimit;                  /* limit of executable segment */
	uint64_t execSegFlags;                  /* executable segment flags */
	char end_withExecSeg[0];

	/* Version 0x20500 */
	uint32_t runtime;
	uint32_t preEncryptOffset;
	char end_withPreEncryptOffset[0];

	/* Version 0x20600 */
	uint8_t linkageHashType;
	uint8_t linkageApplicationType;
	uint16_t linkageApplicationSubType;
	uint32_t linkageOffset;
	uint32_t linkageSize;
	char end_withLinkage[0];

	/* followed by dynamic content as located by offset fields above */
} CS_CodeDirectory
__attribute__ ((aligned(1)));

/*
 * Structure of an embedded-signature SuperBlob
 */

typedef struct __BlobIndex {
	uint32_t type;                                  /* type of entry */
	uint32_t offset;                                /* offset of entry */
} CS_BlobIndex
__attribute__ ((aligned(1)));

typedef struct __SC_SuperBlob {
	uint32_t magic;                                 /* magic number */
	uint32_t length;                                /* total length of SuperBlob */
	uint32_t count;                                 /* number of index entries following */
	CS_BlobIndex index[];                   /* (count) entries */
	/* followed by Blobs in no particular order as indicated by offsets in index */
} CS_SuperBlob
__attribute__ ((aligned(1)));

#define KERNEL_HAVE_CS_GENERICBLOB 1
typedef struct __SC_GenericBlob {
	uint32_t magic;                                 /* magic number */
	uint32_t length;                                /* total length of blob */
	char data[];
} CS_GenericBlob
__attribute__ ((aligned(1)));

typedef struct __SC_Scatter {
	uint32_t count;                                 // number of pages; zero for sentinel (only)
	uint32_t base;                                  // first page number
	uint64_t targetOffset;                  // offset in target
	uint64_t spare;                                 // reserved
} SC_Scatter
__attribute__ ((aligned(1)));


/*
 * Defined launch types
 */
__enum_decl(cs_launch_type_t, uint8_t, {
	CS_LAUNCH_TYPE_NONE = 0,
	CS_LAUNCH_TYPE_SYSTEM_SERVICE = 1,
	CS_LAUNCH_TYPE_SYSDIAGNOSE = 2,
	CS_LAUNCH_TYPE_APPLICATION = 3,
});

struct launch_constraint_data {
	cs_launch_type_t launch_type;
};
typedef struct launch_constraint_data* launch_constraint_data_t;

#endif /* _KERN_CODESIGN_H */

```

`apple/dyld_cache_format.h`:

```h
/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
 *
 * Copyright (c) 2006-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __DYLD_CACHE_FORMAT__
#define __DYLD_CACHE_FORMAT__

#include <stdint.h>
#include <uuid/uuid.h>
#include <TargetConditionals.h>


struct dyld_cache_header
{
    char        magic[16];              // e.g. "dyld_v0    i386"
    uint32_t    mappingOffset;          // file offset to first dyld_cache_mapping_info
    uint32_t    mappingCount;           // number of dyld_cache_mapping_info entries
    uint32_t    imagesOffsetOld;        // UNUSED: moved to imagesOffset to prevent older dsc_extarctors from crashing
    uint32_t    imagesCountOld;         // UNUSED: moved to imagesCount to prevent older dsc_extarctors from crashing
    uint64_t    dyldBaseAddress;        // base address of dyld when cache was built
    uint64_t    codeSignatureOffset;    // file offset of code signature blob
    uint64_t    codeSignatureSize;      // size of code signature blob (zero means to end of file)
    uint64_t    slideInfoOffsetUnused;  // unused.  Used to be file offset of kernel slid info
    uint64_t    slideInfoSizeUnused;    // unused.  Used to be size of kernel slid info
    uint64_t    localSymbolsOffset;     // file offset of where local symbols are stored
    uint64_t    localSymbolsSize;       // size of local symbols information
    uint8_t     uuid[16];               // unique value for each shared cache file
    uint64_t    cacheType;              // 0 for development, 1 for production, 2 for multi-cache
    uint32_t    branchPoolsOffset;      // file offset to table of uint64_t pool addresses
    uint32_t    branchPoolsCount;       // number of uint64_t entries
    uint64_t    dyldInCacheMH;          // (unslid) address of mach_header of dyld in cache
    uint64_t    dyldInCacheEntry;       // (unslid) address of entry point (_dyld_start) of dyld in cache
    uint64_t    imagesTextOffset;       // file offset to first dyld_cache_image_text_info
    uint64_t    imagesTextCount;        // number of dyld_cache_image_text_info entries
    uint64_t    patchInfoAddr;          // (unslid) address of dyld_cache_patch_info
    uint64_t    patchInfoSize;          // Size of all of the patch information pointed to via the dyld_cache_patch_info
    uint64_t    otherImageGroupAddrUnused;    // unused
    uint64_t    otherImageGroupSizeUnused;    // unused
    uint64_t    progClosuresAddr;       // (unslid) address of list of program launch closures
    uint64_t    progClosuresSize;       // size of list of program launch closures
    uint64_t    progClosuresTrieAddr;   // (unslid) address of trie of indexes into program launch closures
    uint64_t    progClosuresTrieSize;   // size of trie of indexes into program launch closures
    uint32_t    platform;               // platform number (macOS=1, etc)
    uint32_t    formatVersion          : 8,  // dyld3::closure::kFormatVersion
                dylibsExpectedOnDisk   : 1,  // dyld should expect the dylib exists on disk and to compare inode/mtime to see if cache is valid
                simulator              : 1,  // for simulator of specified platform
                locallyBuiltCache      : 1,  // 0 for B&I built cache, 1 for locally built cache
                builtFromChainedFixups : 1,  // some dylib in cache was built using chained fixups, so patch tables must be used for overrides
                padding                : 20; // TBD
    uint64_t    sharedRegionStart;      // base load address of cache if not slid
    uint64_t    sharedRegionSize;       // overall size required to map the cache and all subCaches, if any
    uint64_t    maxSlide;               // runtime slide of cache can be between zero and this value
    uint64_t    dylibsImageArrayAddr;   // (unslid) address of ImageArray for dylibs in this cache
    uint64_t    dylibsImageArraySize;   // size of ImageArray for dylibs in this cache
    uint64_t    dylibsTrieAddr;         // (unslid) address of trie of indexes of all cached dylibs
    uint64_t    dylibsTrieSize;         // size of trie of cached dylib paths
    uint64_t    otherImageArrayAddr;    // (unslid) address of ImageArray for dylibs and bundles with dlopen closures
    uint64_t    otherImageArraySize;    // size of ImageArray for dylibs and bundles with dlopen closures
    uint64_t    otherTrieAddr;          // (unslid) address of trie of indexes of all dylibs and bundles with dlopen closures
    uint64_t    otherTrieSize;          // size of trie of dylibs and bundles with dlopen closures
    uint32_t    mappingWithSlideOffset; // file offset to first dyld_cache_mapping_and_slide_info
    uint32_t    mappingWithSlideCount;  // number of dyld_cache_mapping_and_slide_info entries
    uint64_t    dylibsPBLStateArrayAddrUnused;    // unused
    uint64_t    dylibsPBLSetAddr;           // (unslid) address of PrebuiltLoaderSet of all cached dylibs
    uint64_t    programsPBLSetPoolAddr;     // (unslid) address of pool of PrebuiltLoaderSet for each program
    uint64_t    programsPBLSetPoolSize;     // size of pool of PrebuiltLoaderSet for each program
    uint64_t    programTrieAddr;            // (unslid) address of trie mapping program path to PrebuiltLoaderSet
    uint32_t    programTrieSize;
    uint32_t    osVersion;                  // OS Version of dylibs in this cache for the main platform
    uint32_t    altPlatform;                // e.g. iOSMac on macOS
    uint32_t    altOsVersion;               // e.g. 14.0 for iOSMac
    uint64_t    swiftOptsOffset;        // VM offset from cache_header* to Swift optimizations header
    uint64_t    swiftOptsSize;          // size of Swift optimizations header
    uint32_t    subCacheArrayOffset;    // file offset to first dyld_subcache_entry
    uint32_t    subCacheArrayCount;     // number of subCache entries
    uint8_t     symbolFileUUID[16];     // unique value for the shared cache file containing unmapped local symbols
    uint64_t    rosettaReadOnlyAddr;    // (unslid) address of the start of where Rosetta can add read-only/executable data
    uint64_t    rosettaReadOnlySize;    // maximum size of the Rosetta read-only/executable region
    uint64_t    rosettaReadWriteAddr;   // (unslid) address of the start of where Rosetta can add read-write data
    uint64_t    rosettaReadWriteSize;   // maximum size of the Rosetta read-write region
    uint32_t    imagesOffset;           // file offset to first dyld_cache_image_info
    uint32_t    imagesCount;            // number of dyld_cache_image_info entries
    uint32_t    cacheSubType;           // 0 for development, 1 for production, when cacheType is multi-cache(2)
    uint64_t    objcOptsOffset;         // VM offset from cache_header* to ObjC optimizations header
    uint64_t    objcOptsSize;           // size of ObjC optimizations header
    uint64_t    cacheAtlasOffset;       // VM offset from cache_header* to embedded cache atlas for process introspection
    uint64_t    cacheAtlasSize;         // size of embedded cache atlas
    uint64_t    dynamicDataOffset;      // VM offset from cache_header* to the location of dyld_cache_dynamic_data_header
    uint64_t    dynamicDataMaxSize;     // maximum size of space reserved from dynamic data
};

// Uncomment this and check the build errors for the current mapping offset to check against when adding new fields.
// template<size_t size> class A { int x[-size]; }; A<sizeof(dyld_cache_header)> a;


struct dyld_cache_mapping_info {
    uint64_t    address;
    uint64_t    size;
    uint64_t    fileOffset;
    uint32_t    maxProt;
    uint32_t    initProt;
};

// Contains the flags for the dyld_cache_mapping_and_slide_info flgs field
enum {
    DYLD_CACHE_MAPPING_AUTH_DATA            = 1 << 0U,
    DYLD_CACHE_MAPPING_DIRTY_DATA           = 1 << 1U,
    DYLD_CACHE_MAPPING_CONST_DATA           = 1 << 2U,
    DYLD_CACHE_MAPPING_TEXT_STUBS           = 1 << 3U,
    DYLD_CACHE_DYNAMIC_CONFIG_DATA          = 1 << 4U,
};

struct dyld_cache_mapping_and_slide_info {
    uint64_t    address;
    uint64_t    size;
    uint64_t    fileOffset;
    uint64_t    slideInfoFileOffset;
    uint64_t    slideInfoFileSize;
    uint64_t    flags;
    uint32_t    maxProt;
    uint32_t    initProt;
};

struct dyld_cache_image_info
{
    uint64_t    address;
    uint64_t    modTime;
    uint64_t    inode;
    uint32_t    pathFileOffset;
    uint32_t    pad;
};

struct dyld_cache_image_info_extra
{
    uint64_t    exportsTrieAddr;        // address of trie in unslid cache
    uint64_t    weakBindingsAddr;
    uint32_t    exportsTrieSize;
    uint32_t    weakBindingsSize;
    uint32_t    dependentsStartArrayIndex;
    uint32_t    reExportsStartArrayIndex;
};


struct dyld_cache_accelerator_info
{
    uint32_t    version;                // currently 1
    uint32_t    imageExtrasCount;       // does not include aliases
    uint32_t    imagesExtrasOffset;     // offset into this chunk of first dyld_cache_image_info_extra
    uint32_t    bottomUpListOffset;     // offset into this chunk to start of 16-bit array of sorted image indexes
    uint32_t    dylibTrieOffset;        // offset into this chunk to start of trie containing all dylib paths
    uint32_t    dylibTrieSize;          // size of trie containing all dylib paths
    uint32_t    initializersOffset;     // offset into this chunk to start of initializers list
    uint32_t    initializersCount;      // size of initializers list
    uint32_t    dofSectionsOffset;      // offset into this chunk to start of DOF sections list
    uint32_t    dofSectionsCount;       // size of initializers list
    uint32_t    reExportListOffset;     // offset into this chunk to start of 16-bit array of re-exports
    uint32_t    reExportCount;          // size of re-exports
    uint32_t    depListOffset;          // offset into this chunk to start of 16-bit array of dependencies (0x8000 bit set if upward)
    uint32_t    depListCount;           // size of dependencies
    uint32_t    rangeTableOffset;       // offset into this chunk to start of ss
    uint32_t    rangeTableCount;        // size of dependencies
    uint64_t    dyldSectionAddr;        // address of libdyld's __dyld section in unslid cache
};

struct dyld_cache_accelerator_initializer
{
    uint32_t    functionOffset;         // address offset from start of cache mapping
    uint32_t    imageIndex;
};

struct dyld_cache_range_entry
{
    uint64_t    startAddress;           // unslid address of start of region
    uint32_t    size;
    uint32_t    imageIndex;
};

struct dyld_cache_accelerator_dof
{
    uint64_t    sectionAddress;         // unslid address of start of region
    uint32_t    sectionSize;
    uint32_t    imageIndex;
};

struct dyld_cache_image_text_info
{
    uuid_t      uuid;
    uint64_t    loadAddress;            // unslid address of start of __TEXT
    uint32_t    textSegmentSize;
    uint32_t    pathOffset;             // offset from start of cache file
};


// The rebasing info is to allow the kernel to lazily rebase DATA pages of the
// dyld shared cache.  Rebasing is adding the slide to interior pointers.
struct dyld_cache_slide_info
{
    uint32_t    version;        // currently 1
    uint32_t    toc_offset;
    uint32_t    toc_count;
    uint32_t    entries_offset;
    uint32_t    entries_count;
    uint32_t    entries_size;  // currently 128
    // uint16_t toc[toc_count];
    // entrybitmap entries[entries_count];
};

struct dyld_cache_slide_info_entry {
    uint8_t  bits[4096/(8*4)]; // 128-byte bitmap
};


// The version 2 of the slide info uses a different compression scheme. Since
// only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers and thus know there are
// unused bits in each pointer.  We use those bits to form a linked list of
// locations needing rebasing in each page.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//  pageExtras[] = info + info->page_extras_offset
//  valueMask = ~(info->delta_mask)
//  deltaShift = __builtin_ctzll(info->delta_mask) - 2
//
// There are three cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) (pageStarts[pageIndex] & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA) == 0
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex] * 4.
//
// 3) pageStarts[pageIndex] & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA
//      Multiple linked lists are needed for all rebase locations in a page.
//    The pagesExtras array contains 2 or more entries each of which is the
//    start of a new linked list in the page. The first is at:
//       extrasStartIndex = (pageStarts[pageIndex] & 0x3FFF)
//      The next is at extrasStartIndex+1.  The last is denoted by
//    having the high bit (DYLD_CACHE_SLIDE_PAGE_ATTR_END) of the pageExtras[]
//    set.
//
// For 64-bit architectures, there is always enough free bits to encode all
// possible deltas.  The info->delta_mask field shows where the delta is located
// in the pointer.  That value must be masked off (valueMask) before the slide
// is added to the pointer.
//
// For 32-bit architectures, there are only three bits free (the three most
// significant bits). To extract the delta, you must first subtract value_add
// from the pointer value, then AND with delta_mask, then shift by deltaShift.
// That still leaves a maximum delta to the next rebase location of 28 bytes.
// To reduce the number or chains needed, an optimization was added.  Turns
// out zero is common in the DATA region.  A zero can be turned into a
// non-rebasing entry in the linked list.  The can be done because nothing
// in the shared cache should point out of its dylib to the start of the shared
// cache.
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = 1;
//    while ( delta != 0 ) {
//        uint8_t* loc = pageStart + pageOffset;
//        uintptr_t rawValue = *((uintptr_t*)loc);
//        delta = ((rawValue & deltaMask) >> deltaShift);
//        uintptr_t newValue = (rawValue & valueMask);
//        if ( newValue != 0 ) {
//            newValue += valueAdd;
//            newValue += slideAmount;
//        }
//        *((uintptr_t*)loc) = newValue;
//        pageOffset += delta;
//    }
//
//
struct dyld_cache_slide_info2
{
    uint32_t    version;            // currently 2
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_offset;
    uint32_t    page_starts_count;
    uint32_t    page_extras_offset;
    uint32_t    page_extras_count;
    uint64_t    delta_mask;         // which (contiguous) set of bits contains the delta to the next rebase location
    uint64_t    value_add;
    //uint16_t    page_starts[page_starts_count];
    //uint16_t    page_extras[page_extras_count];
};
#define DYLD_CACHE_SLIDE_PAGE_ATTRS                0xC000  // high bits of uint16_t are flags
#define DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA           0x8000  // index is into extras array (not starts array)
#define DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE       0x4000  // page has no rebasing
#define DYLD_CACHE_SLIDE_PAGE_ATTR_END             0x8000  // last chain entry for page



// The version 3 of the slide info uses a different compression scheme. Since
// only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers and thus know there are
// unused bits in each pointer.  We use those bits to form a linked list of
// locations needing rebasing in each page.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//
// There are two cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) otherwise...
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex].
//
// A pointer is one of of the variants in dyld_cache_slide_pointer3
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = pageStarts[pageIndex];
//    dyld_cache_slide_pointer3* loc = pageStart;
//    do {
//        loc += delta;
//        delta = loc->offsetToNextPointer;
//        if ( loc->auth.authenticated ) {
//            newValue = loc->offsetFromSharedCacheBase  + results->slide + auth_value_add;
//            newValue = sign_using_the_various_bits(newValue);
//        }
//        else {
//            uint64_t value51      = loc->pointerValue;
//            uint64_t top8Bits     = value51 & 0x0007F80000000000ULL;
//            uint64_t bottom43Bits = value51 & 0x000007FFFFFFFFFFULL;
//            uint64_t targetValue  = ( top8Bits << 13 ) | bottom43Bits;
//            newValue = targetValue + results->slide;
//        }
//        loc->raw = newValue;
//    } while (delta != 0);
//
//
struct dyld_cache_slide_info3
{
    uint32_t    version;            // currently 3
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_count;
    uint64_t    auth_value_add;
    uint16_t    page_starts[/* page_starts_count */];
};

#define DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE    0xFFFF    // page has no rebasing

union dyld_cache_slide_pointer3
{
    uint64_t  raw;
    struct {
        uint64_t    pointerValue        : 51,
                    offsetToNextPointer : 11,
                    unused              :  2;
    }         plain;

    struct {
        uint64_t    offsetFromSharedCacheBase : 32,
                    diversityData             : 16,
                    hasAddressDiversity       :  1,
                    key                       :  2,
                    offsetToNextPointer       : 11,
                    unused                    :  1,
                    authenticated             :  1; // = 1;
    }         auth;
};



// The version 4 of the slide info is optimized for 32-bit caches up to 1GB.
// Since only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers takes 30 bits.  That
// gives us two bits to use to chain to the next rebase.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//  pageExtras[] = info + info->page_extras_offset
//  valueMask = ~(info->delta_mask)
//  deltaShift = __builtin_ctzll(info->delta_mask) - 2
//
// There are three cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE4_PAGE_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) (pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA) == 0
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex] * 4.
//
// 3) pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA
//    Multiple chains are needed for all rebase locations in a page.
//    The pagesExtras array contains 2 or more entries each of which is the
//    start of a new chain in the page. The first is at:
//       extrasStartIndex = (pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_INDEX)
//    The next is at extrasStartIndex+1.  The last is denoted by
//    having the high bit (DYLD_CACHE_SLIDE4_PAGE_EXTRA_END) of the pageExtras[].
//
// For 32-bit architectures, there are only two bits free (the two most
// significant bits). To extract the delta, you must first subtract value_add
// from the pointer value, then AND with delta_mask, then shift by deltaShift.
// That still leaves a maximum delta to the next rebase location of 12 bytes.
// To reduce the number or chains needed, an optimization was added.  Turns
// most of the non-rebased data are small values and can be co-opt'ed into
// being used in the chain. The can be done because nothing
// in the shared cache should point to the first 64KB which are in the shared
// cache header information. So if the resulting pointer points to the
// start of the cache +/-32KB, then it is actually a small number that should
// not be rebased, but just reconstituted.
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = 1;
//    while ( delta != 0 ) {
//        uint8_t* loc = pageStart + pageOffset;
//        uint32_t rawValue = *((uint32_t*)loc);
//        delta = ((rawValue & deltaMask) >> deltaShift);
//        uintptr_t newValue = (rawValue & valueMask);
//        if ( (newValue & 0xFFFF8000) == 0 ) {
//           // small positive non-pointer, use as-is
//        }
//        else if ( (newValue & 0x3FFF8000) == 0x3FFF8000 ) {
//           // small negative non-pointer
//           newValue |= 0xC0000000;
//        }
//        else  {
//            // pointer that needs rebasing
//            newValue += valueAdd;
//            newValue += slideAmount;
//        }
//        *((uint32_t*)loc) = newValue;
//        pageOffset += delta;
//    }
//
//
struct dyld_cache_slide_info4
{
    uint32_t    version;            // currently 4
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_offset;
    uint32_t    page_starts_count;
    uint32_t    page_extras_offset;
    uint32_t    page_extras_count;
    uint64_t    delta_mask;         // which (contiguous) set of bits contains the delta to the next rebase location (0xC0000000)
    uint64_t    value_add;          // base address of cache
    //uint16_t    page_starts[page_starts_count];
    //uint16_t    page_extras[page_extras_count];
};
#define DYLD_CACHE_SLIDE4_PAGE_NO_REBASE           0xFFFF  // page has no rebasing
#define DYLD_CACHE_SLIDE4_PAGE_INDEX               0x7FFF  // mask of page_starts[] values
#define DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA           0x8000  // index is into extras array (not a chain start offset)
#define DYLD_CACHE_SLIDE4_PAGE_EXTRA_END           0x8000  // last chain entry for page


struct dyld_cache_local_symbols_info
{
    uint32_t    nlistOffset;        // offset into this chunk of nlist entries
    uint32_t    nlistCount;         // count of nlist entries
    uint32_t    stringsOffset;      // offset into this chunk of string pool
    uint32_t    stringsSize;        // byte count of string pool
    uint32_t    entriesOffset;      // offset into this chunk of array of dyld_cache_local_symbols_entry
    uint32_t    entriesCount;       // number of elements in dyld_cache_local_symbols_entry array
};

struct dyld_cache_local_symbols_entry
{
    uint32_t    dylibOffset;        // offset in cache file of start of dylib
    uint32_t    nlistStartIndex;    // start index of locals for this dylib
    uint32_t    nlistCount;         // number of local symbols for this dylib
};

struct dyld_cache_local_symbols_entry_64
{
    uint64_t    dylibOffset;        // offset in cache buffer of start of dylib
    uint32_t    nlistStartIndex;    // start index of locals for this dylib
    uint32_t    nlistCount;         // number of local symbols for this dylib
};

struct dyld_subcache_entry_v1
{
    uint8_t     uuid[16];           // The UUID of the subCache file
    uint64_t    cacheVMOffset;      // The offset of this subcache from the main cache base address
};

struct dyld_subcache_entry
{
    uint8_t     uuid[16];           // The UUID of the subCache file
    uint64_t    cacheVMOffset;      // The offset of this subcache from the main cache base address
    char        fileSuffix[32];     // The file name suffix of the subCache file e.g. ".25.data", ".03.development"
};

// This struct is a small piece of dynamic data that can be included in the shared region, and contains configuration
// data about the shared cache in use by the process. It is located
struct dyld_cache_dynamic_data_header
{
    char        magic[16];              // e.g. "dyld_data    v0"
    uint64_t    fsId;                   // The fsid_t of the shared cache being used by a process
    uint64_t    fsObjId;                // The fs_obj_id_t of the shared cache being used by a process
};

// This is the  location of the macOS shared cache on macOS 11.0 and later
#define MACOSX_MRM_DYLD_SHARED_CACHE_DIR   "/System/Library/dyld/"

// This is old define for the old location of the dyld cache
#define MACOSX_DYLD_SHARED_CACHE_DIR       MACOSX_MRM_DYLD_SHARED_CACHE_DIR

#define IPHONE_DYLD_SHARED_CACHE_DIR       "/System/Library/Caches/com.apple.dyld/"

#define DRIVERKIT_DYLD_SHARED_CACHE_DIR   "/System/DriverKit/System/Library/dyld/"

#if !TARGET_OS_SIMULATOR
  #define DYLD_SHARED_CACHE_BASE_NAME        "dyld_shared_cache_"
#else
  #define DYLD_SHARED_CACHE_BASE_NAME        "dyld_sim_shared_cache_"
#endif
#define DYLD_SHARED_CACHE_DEVELOPMENT_EXT  ".development"

#define DYLD_SHARED_CACHE_DYNAMIC_DATA_MAGIC    "dyld_data    v0"

static const char* cryptexPrefixes[] = {
    "/System/Volumes/Preboot/Cryptexes/OS/",
    "/private/preboot/Cryptexes/OS/",
    "/System/Cryptexes/OS"
};

static const uint64_t kDyldSharedCacheTypeDevelopment = 0;
static const uint64_t kDyldSharedCacheTypeProduction = 1;
static const uint64_t kDyldSharedCacheTypeUniversal = 2;





#endif // __DYLD_CACHE_FORMAT__



```

`utility/debug.h`:

```h

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <syslog.h>
#include <inttypes.h>
#include "utility/error.h"

// system is unusable
#define LOG_EMERGENCY     LOG_EMERG
// critical logging level
#define LOG_CRITICAL      LOG_CRIT
// Error logging level
#define LOG_ERROR         LOG_ERR

#define LOG_DEFAULTS            ( LOG_CONS | LOG_PERROR | LOG_ODELAY | LOG_NDELAY | LOG_USER | LOG_PID )
// #define LOG_DEFAULTS            ( LOG_CONS | LOG_PID | LOG_NDELAY, LOG_USER )
#define LOG_NAME                "No_Name"
#define RET_CODE_8X             "0x%08" PRIX8

#if defined( DEBUG_MODE )

    #define BWSR_DEBUG( LOG_LEVEL,                  \
                        FORMAT,                     \
                        ARGUMENTS... )              \
        do                                          \
        {                                           \
            openlog( LOG_NAME,                      \
                    LOG_DEFAULTS,                   \
                    LOG_USER );                     \
            syslog( LOG_LEVEL,                      \
                    "%s[%d] -> %s(): " FORMAT,      \
                    __FILE__,                       \
                    __LINE__,                       \
                    __FUNCTION__,                   \
                    ##ARGUMENTS );                  \
            closelog();                             \
        }                                           \
        while( 0 );

    #define DEBUG( ... )                            \
        BWSR_DEBUG( LOG_DEBUG, __VA_ARGS__ );

    #define __DEBUG_ENTER                           \
        BWSR_DEBUG( LOG_DEBUG, "enter\n" );

    #define __DEBUG_EXIT                            \
        BWSR_DEBUG( LOG_DEBUG, "exit\n" );

    #define __DEBUG_RETVAL( RETURN_CODE )               \
        BWSR_DEBUG( LOG_DEBUG,                          \
                    "retVal: " RET_CODE_8X " %s\n",     \
                    RETURN_CODE,                        \
                    ErrorString( RETURN_CODE ) );

#else

    #define BWSR_DEBUG( LOG_LEVEL, FORMAT, ARGUMENTS... )
    #define DEBUG( ... )
    #define __DEBUG_ENTER
    #define __DEBUG_EXIT
    #define __DEBUG_RETVAL( RETURN_CODE )

#endif // DEBUG_MODE

#endif
```

`utility/error.h`:

```h
#ifndef __ERROR_H__
#define __ERROR_H__

// -----------------------------------------------------------------------------
//  BASE ERRORS
// -----------------------------------------------------------------------------

#define ERROR_SUCCESS                       ( 0x00000000 )
#define ERROR_FAILURE                       ( 0xFFFFFFFF )

// -----------------------------------------------------------------------------
//  GENERIC ERRORS
// -----------------------------------------------------------------------------

#define ERROR_ARGUMENT_IS_NULL              ( 0x00000010 )
#define ERROR_INVALID_ARGUMENT_VALUE        ( 0x00000011 )
#define ERROR_NOT_FOUND                     ( 0x00000012 )
#define ERROR_UNHANDLED_DATA_TYPE           ( 0x00000013 )
#define ERROR_UNIMPLEMENTED                 ( 0x00000014 )
#define ERROR_UNEXPECTED_FORMAT             ( 0x00000015 )

// -----------------------------------------------------------------------------
//  MEMORY ERRORS
// -----------------------------------------------------------------------------

#define ERROR_MEM_ALLOC                     ( 0x00000100 )
#define ERROR_MEMORY_MAPPING                ( 0x00000101 )
#define ERROR_MEMORY_PERMISSION             ( 0x00000102 )
#define ERROR_MEMORY_OVERFLOW               ( 0x00000103 )

// -----------------------------------------------------------------------------
//  I/O ERRROS
// -----------------------------------------------------------------------------

#define ERROR_FILE_IO                       ( 0x00001000 )
#define ERROR_CACHED_LOCATION               ( 0x00001001 )
#define ERROR_SHARED_CACHE                  ( 0x00001002 )
#define ERROR_PROC_SELF_MAPS                ( 0x00001003 )

// -----------------------------------------------------------------------------
//  OS ERRORS
// -----------------------------------------------------------------------------

#define ERROR_SYMBOL_SIZE                   ( 0x00010000 )
#define ERROR_TASK_INFO                     ( 0x00010001 )
#define ERROR_ROUTING_FAILURE               ( 0x00010002 )

// -----------------------------------------------------------------------------
//  ERROR STRING CONVERSION
// -----------------------------------------------------------------------------

#define ERROR_STRINGS( E )                                                          \
    E( ERROR_SUCCESS,                   "Success"                               )   \
    E( ERROR_FAILURE,                   "Generic Error"                         )   \
    /* --- GENERICS --- */                                                          \
    E( ERROR_ARGUMENT_IS_NULL,          "An argument is NULL"                   )   \
    E( ERROR_INVALID_ARGUMENT_VALUE,    "An argument has a bad value"           )   \
    E( ERROR_NOT_FOUND,                 "Element not found"                     )   \
    E( ERROR_UNHANDLED_DATA_TYPE,       "Unexpected data type"                  )   \
    E( ERROR_UNIMPLEMENTED,             "No implementation for this data type"  )   \
    E( ERROR_UNEXPECTED_FORMAT,         "Data format did match expectation"     )   \
    /* --- MEMORY --- */                                                            \
    E( ERROR_MEM_ALLOC,                 "Out of memory"                         )   \
    E( ERROR_MEMORY_MAPPING,            "Faied to map memory region"            )   \
    E( ERROR_MEMORY_PERMISSION,         "Failed to change memory permissions"   )   \
    E( ERROR_MEMORY_OVERFLOW,           "Allocated memory not large enough"     )   \
    /* --- I/O --- */                                                               \
    E( ERROR_FILE_IO,                   "File I/O"                              )   \
    E( ERROR_CACHED_LOCATION,           "Invalid cache location"                )   \
    E( ERROR_SHARED_CACHE,              "Failed to initialize shared cache"     )   \
    E( ERROR_PROC_SELF_MAPS,            "Failed to open proc/self/maps"         )   \
    /* --- OS --- */                                                                \
    E( ERROR_SYMBOL_SIZE,               "Invalid symbol size"                   )   \
    E( ERROR_TASK_INFO,                 "Need to summarize"                     )   \
    E( ERROR_ROUTING_FAILURE,           "Failed to setup VirtualPage routing"   )

#define ERROR_TEXT( ERROR_CODE, TEXT ) \
    case ERROR_CODE: return #ERROR_CODE " (" TEXT ")";

typedef int BWSR_STATUS;

static inline const char* ErrorString( int ErrorCode )
{
    switch( ErrorCode )
    {
        ERROR_STRINGS( ERROR_TEXT )
    } // switch()

    return "Unknown Error code!";
}

#endif
```

`utility/utility.h`:

```h

#ifndef __UTILITY_H__
#define __UTILITY_H__

// -----------------------------------------------------------------------------
//  INCLUDES
// -----------------------------------------------------------------------------

#include "utility/debug.h"
#include "utility/error.h"

// -----------------------------------------------------------------------------
//  BASE
// -----------------------------------------------------------------------------

#define IN
#define OUT
#define OPTIONAL

#define BWSR_API __attribute__( ( visibility( "default" ) ) )

#define ARRAY_LENGTH( ARRAY ) ( sizeof( ARRAY ) / sizeof( ARRAY[ 0 ] ) )

// -----------------------------------------------------------------------------
//  BIT MANIPULATION
// -----------------------------------------------------------------------------

// Truncate address to nearest lower multiple of page size `0x1000`.
#define arm64_trunc_page( x ) \
    ( ( x ) & ( ~( 0x1000 - 1 ) ) )

// Align page to boundary
#define ALIGN_FLOOR( ADDRESS, RANGE ) \
    ( (uintptr_t) ADDRESS & ~( (uintptr_t) RANGE - 1 ) )

// Left shift `Bits` after masking with `BitMaskShift` least significant bits,
// then shift left by `BitShift` positions.
#define BIT_SHIFT( Bits, BitMaskShift, BitShift ) \
    ( ( ( Bits ) & ( ( 1 << ( BitMaskShift ) ) - 1 ) ) << ( BitShift ) )

// Generate a bitmask with `BitShift` bits set to `1`.
#define GENERATE_BIT_MASK( BitShift ) \
    ( ( 1L << ( ( BitShift ) + 1 ) ) - 1 )

// Extract bits from `Bits` starting at position `StartBit` to `EndBit`.
#define GET_BITS( Bits, StartBit, EndBit ) \
    ( ( ( Bits ) >> ( StartBit ) ) & GENERATE_BIT_MASK( ( EndBit ) - ( StartBit ) ) )

// Extract a single bit from `Bits` at position `BitPos`.
#define GET_BIT( Bits, BitPos ) \
    ( ( ( Bits ) >> ( BitPos ) ) & 1 )

// Set a specific bit in `Bits` at position `BitPos` to `Bit` (0 or 1).
#define SET_BIT( Bits, BitPos, Bit ) \
    ( Bits = ( ( ( ~( 1 << ( BitPos ) ) ) & ( Bits ) ) | ( ( Bit ) << ( BitPos ) ) ) )

// Set bits in `Bits` from position `StartBit` to `EndBit` with bits
// from `ReplacementBits`.
#define SET_BITS( Bits, StartBit, EndBit, ReplacementBits ) \
    ( Bits = ( ( ( ~( GENERATE_BIT_MASK( ( EndBit ) - ( StartBit ) ) << ( StartBit ) ) ) & ( Bits ) ) \
                | ( ( ReplacementBits ) << ( StartBit ) ) ) )

// -----------------------------------------------------------------------------
//  MACRO EXPANSIONS && BASE CONDITIONS
// -----------------------------------------------------------------------------

// Bypass compiler warnings about unused parameters.
#define UNUSED_PARAMETER( Parameter ) (void) Parameter;

// Avoids return value by forcing `return;`
#define VOID_RETURN


// Checks if `Parameter` is `NULL`.
// If so, it returns `RETURN_VALUE`.
#define IF_PARAMETER_NULL_RETURN( RETURN_VALUE, Parameter )         \
    if( NULL == Parameter )                                         \
    {                                                               \
        BWSR_DEBUG( LOG_ERROR, #Parameter " is NULL\n" );           \
        return RETURN_VALUE;                                        \
    }

// Wraps `IF_PARAMETER_NULL_RETURN`
// Returns `ERROR_INVALID_ARGUMENT` if `Parameter` is `NULL`
#define IF_PARAMETER_NULL_RETURN_BWSR( Parameter ) \
    IF_PARAMETER_NULL_RETURN( ERROR_ARGUMENT_IS_NULL, Parameter )

// Wraps `IF_PARAMETER_NULL_RETURN`
// Returns `NULL` if `Parameter` is `NULL`
#define IF_PARAMETER_NULL_RETURN_NULL( Parameter ) \
    IF_PARAMETER_NULL_RETURN( NULL, Parameter )

// Wraps `IF_PARAMETER_NULL_RETURN`
// Returns `VOID` if `Parameter` is `NULL`
#define IF_PARAMETER_NULL_RETURN_VOID( Parameter ) \
    IF_PARAMETER_NULL_RETURN( VOID_RETURN, Parameter )

// Wraps `IF_PARAMETER_NULL_RETURN`
// Returns `0` if `Parameter` is `NULL`
#define IF_PARAMETER_NULL_RETURN_0( Parameter ) \
    IF_PARAMETER_NULL_RETURN( 0, Parameter )



// Checks if `Parameter` is less than or equal to 0.
// If so, it returns `RETURN_VALUE`.
#define IF_PARAMATER_NOT_GREATER_THAN_0_RETURN( RETURN_VALUE, Parameter )   \
    if( 0 >= Parameter )                                                    \
    {                                                                       \
        BWSR_DEBUG( LOG_ERROR, #Parameter " is less than 0!\n" );           \
        return RETURN_VALUE;                                                \
    }

// Wraps `IF_PARAMATER_NOT_GREATER_THAN_0_RETURN`
// Returns `ERROR_INVALID_ARGUMENT` if `Parameter` is less than or equal to 0.
#define IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_BWSR( Parameter ) \
    IF_PARAMATER_NOT_GREATER_THAN_0_RETURN( ERROR_INVALID_ARGUMENT_VALUE, Parameter )

// Wraps `IF_PARAMATER_NOT_GREATER_THAN_0_RETURN`
// Returns `NULL` if `Parameter` is less than or equal to 0.
#define IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_NULL( Parameter ) \
    IF_PARAMATER_NOT_GREATER_THAN_0_RETURN( NULL, Parameter )

// Wraps `IF_PARAMATER_NOT_GREATER_THAN_0_RETURN`
// Returns `VOID` if `Parameter` is less than or equal to 0.
#define IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_VOID( Parameter ) \
    IF_PARAMATER_NOT_GREATER_THAN_0_RETURN( VOID_RETURN, Parameter )



// Should be an impossible case
#define MACRO_EXPAND__0__

// Should be an impossible case
#define MACRO_EXPAND__1__( Parameter )

#define MACRO_EXPAND__2__( MACRO_EXPANSION, Parameter )         \
    MACRO_EXPANSION( Parameter )

#define MACRO_EXPAND__3__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__2__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__4__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__3__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__5__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__4__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__6__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__5__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__7__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__6__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__8__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__7__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__9__( MACRO_EXPANSION, Parameter, ... )    \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__8__( MACRO_EXPANSION, __VA_ARGS__ )

#define MACRO_EXPAND__10__( MACRO_EXPANSION, Parameter, ... )   \
    MACRO_EXPANSION( Parameter )                                \
    MACRO_EXPAND__9__( MACRO_EXPANSION, __VA_ARGS__ )

#define N_ARGS( ... )               \
    N_ARGS_HELPER1( __VA_ARGS__,    \
                    __10__,         \
                    __9__,          \
                    __8__,          \
                    __7__,          \
                    __6__,          \
                    __5__,          \
                    __4__,          \
                    __3__,          \
                    __2__,          \
                    __1__,          \
                    __0__ )

#define N_ARGS_HELPER1( ... )       \
    N_ARGS_HELPER2( __VA_ARGS__ )

#define N_ARGS_HELPER2( x1,         \
                        x2,         \
                        x3,         \
                        x4,         \
                        x5,         \
                        x6,         \
                        x7,         \
                        x8,         \
                        x9,         \
                        x10,        \
                        n,          \
                        ... ) n

#define CREATE_MACRO_EXPANSION( PREFIX, POSTFIX ) \
    PREFIX ## POSTFIX

#define BUILD_MACRO( PREFIX, POSTFIX ) \
    CREATE_MACRO_EXPANSION( PREFIX, POSTFIX )

// If a parameter is `NULL` returns `ERROR_ARGUMENT_IS_NULL`
#define __NOT_NULL( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NULL_RETURN_BWSR, __VA_ARGS__ );

// If a parameter is `NULL` returns `NULL`
#define __NOT_NULL_RETURN_NULL( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NULL_RETURN_NULL, __VA_ARGS__ );

// If a parameter is `NULL` returns
#define __NOT_NULL_RETURN_VOID( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NULL_RETURN_VOID, __VA_ARGS__ );

// If a parameter is `NULL` returns `0`
#define __NOT_NULL_RETURN_0( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NULL_RETURN_0, __VA_ARGS__ );

// If a parameter is not greater than `0` returns `ERROR_INVALID_ARGUMENT_VALUE`
#define __GREATER_THAN_0( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_BWSR, __VA_ARGS__ );

// If a parameter is not greater than `0` returns `NULL`
#define __GREATER_THAN_0_RETURN_NULL( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_NULL, __VA_ARGS__ );

// If a parameter is not greater than `0` returns
#define __GREATER_THAN_0_RETURN_VOID( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( IF_PARAMETER_NOT_GREATER_THAN_0_RETURN_VOID, __VA_ARGS__ );

// Avoids unused parameter warning by casting parameters to void
#define __UNUSED( ... ) \
    BUILD_MACRO( MACRO_EXPAND, N_ARGS( 0, __VA_ARGS__ ) )( UNUSED_PARAMETER, __VA_ARGS__ )

#endif
```