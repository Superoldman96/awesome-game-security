Project Path: arc_gmh5225_VALORANT-FNamePool__7d8hize

Source Tree:

```txt
arc_gmh5225_VALORANT-FNamePool__7d8hize
├── Misc
│   ├── AllignmentTemplates.h
│   ├── ImSorryForTheQualityOfThis.h
│   └── Types.h
├── README.md
├── VALORANT
│   ├── FNamePool.h
│   └── VALORANT.h
├── VALORANT.sln
├── VALORANT.vcxproj
├── VALORANT.vcxproj.filters
├── VALORANT.vcxproj.user
└── dllmain.cpp

```

`Misc/AllignmentTemplates.h`:

```h
#pragma once

template <typename T>
FORCEINLINE constexpr T Align(T Val, uint64 Alignment)
{
	return (T)(((uint64)Val + Alignment - 1) & ~(Alignment - 1));
}

```

`Misc/ImSorryForTheQualityOfThis.h`:

```h
#pragma once
#include <stdio.h>
#include <fstream>
#include <filesystem>

class ImSorryForTheQualityOfThis {
public:
	ImSorryForTheQualityOfThis(std::string FileName, bool Append = false)
	{
		std::filesystem::path Path = std::filesystem::current_path();
		Path += FileName;
		LogFile.open(Path, Append ? std::fstream::out : std::fstream::out | std::fstream::app);
	}

	inline void CloseLog() 
	{
		LogFile.close();
	}

	void LogToFile(std::string ToLog) 
	{
		LogFile << ToLog << std::endl;
	}

	void LogToFile(std::string ToLog, void* Pointer)
	{
		LogFile << ToLog << "0x" << std::hex << Pointer << std::endl;
	}

	void LogToFile(std::string ToLog, uint64 Pointer)
	{
		LogFile << ToLog << "0x" << std::hex << reinterpret_cast<void*>(Pointer) << std::endl;
	}

private:
	std::ofstream LogFile;
};



```

`Misc/Types.h`:

```h
#pragma once

//~ Unsigned base types

// 8-bit unsigned integer
typedef unsigned char 		uint8;

// 16-bit unsigned integer
typedef unsigned short int	uint16;

// 32-bit unsigned integer
typedef unsigned int		uint32;

// 64-bit unsigned integer
typedef unsigned long long	uint64;

//~ Signed base types.

// 8-bit signed integer
typedef	signed char			int8;

// 16-bit signed integer
typedef signed short int	int16;

// 32-bit signed integer
typedef signed int	 		int32;

// 64-bit signed integer
typedef signed long long	int64;


//~ Character types

// An ANSI character. 8-bit fixed-width representation of 7-bit characters.
typedef char				ANSICHAR;

// A wide character. In-memory only. ?-bit fixed-width representation of the platform's natural wide character set. Could be different sizes on different platforms.
typedef wchar_t				WIDECHAR;

// An 8-bit character type. In-memory only. 8-bit representation. Should really be char8_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint8				CHAR8;

// A 16-bit character type. In-memory only.  16-bit representation. Should really be char16_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint16				CHAR16;

// A 32-bit character type. In-memory only. 32-bit representation. Should really be char32_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint32				CHAR32;

// A switchable character. In-memory only. Either ANSICHAR or WIDECHAR, depending on a licensee's requirements.
typedef WIDECHAR			TCHAR;

```

`README.md`:

```md
# VALORANT

Iterate And Decrypt FNamePool->Entries To A Log On VALORANT

The output text will be located in the games directory

```

`VALORANT.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32616.157
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VALORANT", "VALORANT.vcxproj", "{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Debug|x64.ActiveCfg = Debug|x64
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Debug|x64.Build.0 = Debug|x64
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Debug|x86.ActiveCfg = Debug|Win32
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Debug|x86.Build.0 = Debug|Win32
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Release|x64.ActiveCfg = Release|x64
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Release|x64.Build.0 = Release|x64
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Release|x86.ActiveCfg = Release|Win32
		{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ECE949B5-DEBC-404E-BD21-FB63B5C1604E}
	EndGlobalSection
EndGlobal

```

`VALORANT.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ValorantFNamePool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>VALORANT</ProjectName>
    <ProjectGuid>{0DF87F4D-16D8-4835-B552-9F5C4A0D2044}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)\Output</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Misc\AllignmentTemplates.h" />
    <ClInclude Include="VALORANT\FNamePool.h" />
    <ClInclude Include="Misc\ImSorryForTheQualityOfThis.h" />
    <ClInclude Include="Misc\Types.h" />
    <ClInclude Include="VALORANT\VALORANT.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VALORANT.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="VALORANT">
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Misc">
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Misc\ImSorryForTheQualityOfThis.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Misc\AllignmentTemplates.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="VALORANT\FNamePool.h">
      <Filter>VALORANT</Filter>
    </ClInclude>
    <ClInclude Include="Misc\Types.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="VALORANT\VALORANT.h">
      <Filter>VALORANT</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
</Project>
```

`VALORANT.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`VALORANT/FNamePool.h`:

```h
#pragma once

static constexpr uint32 FNameMaxBlockBits = 13;
static constexpr uint32 FNameBlockOffsetBits = 16;
static constexpr uint32 FNameMaxBlocks = 1 << FNameMaxBlockBits;
static constexpr uint32 FNameBlockOffsets = 1 << FNameBlockOffsetBits;

struct FNameEntryId
{
	FNameEntryId() : Value(0) {}

	FNameEntryId(uint32 Id) : Value(Id) {}

	explicit operator bool() const { return Value != 0; }

	FORCEINLINE bool operator==(FNameEntryId Other) const
	{
		return Value == Other.Value;
	}

	FORCEINLINE static FNameEntryId FromUnstableInt(uint32 UnstableInt)
	{
		FNameEntryId Id;
		Id.Value = UnstableInt;
		return Id;
	}

	FORCEINLINE uint32 ToUnstableInt() const {
		return Value;
	}

	uint32 Value;
};

struct FNameEntryHandle
{
	uint32 Block = 0;
	uint32 Offset = 0;

	FNameEntryHandle(uint32 InBlock, uint32 InOffset)
		: Block(InBlock)
		, Offset(InOffset)
	{}

	FNameEntryHandle(FNameEntryId Id)
		: Block(Id.ToUnstableInt() >> FNameBlockOffsetBits)
		, Offset(Id.ToUnstableInt()& (FNameBlockOffsets - 1))
	{}

	operator FNameEntryId() const
	{
		return FNameEntryId::FromUnstableInt(Block << FNameBlockOffsetBits | Offset);
	}

	explicit operator bool() const { return Block | Offset; }
};

struct FNameEntryHeader
{
	uint16 bIsWide : 1;
	uint16 Len : 15;
};

struct FNameEntry {
	enum { NAME_SIZE = 1024 };
public:
	FORCEINLINE bool IsWide() const
	{
		return Header.bIsWide;
	}

	FORCEINLINE int32 GetNameLength() const
	{
		return Header.Len;
	}

	FORCEINLINE FNameEntryHeader GetEntryHeader() const
	{
		return Header;
	}

	static int32 GetSize(int32 Length, bool bIsPureAnsi);

	char* DecryptNonWide();

	wchar_t* DecryptWide();

	FORCEINLINE void CopyUnterminatedName(ANSICHAR* Out) 
	{
		memcpy(Out, DecryptNonWide(), sizeof(ANSICHAR) * Header.Len);
	}

	FORCEINLINE void CopyUnterminatedName(WIDECHAR* Out)
	{
		memcpy(Out, DecryptWide(), sizeof(WIDECHAR) * Header.Len);
	}

	FORCEINLINE static int32 GetDataOffset()
	{
		return offsetof(FNameEntry, AnsiName);
	}

	void GetAnsiName(ANSICHAR(&Out)[NAME_SIZE]);

	void GetWideName(WIDECHAR(&Out)[NAME_SIZE]);

	std::string String();

	FNameEntryId ComparisonId;

	FNameEntryHeader Header;

	union
	{
		ANSICHAR	AnsiName[NAME_SIZE];
		WIDECHAR	WideName[NAME_SIZE];
	};

};

void FNameEntry::GetAnsiName(ANSICHAR(&Out)[NAME_SIZE])
{
	if (!IsWide()) 
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

void FNameEntry::GetWideName(WIDECHAR(&Out)[NAME_SIZE])
{
	if (IsWide()) 
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

class FNameEntryAllocator
{
public:
	enum { Stride = alignof(FNameEntry) };
	enum { BlockSizeBytes = Stride * FNameBlockOffsets };

	void* FRWLock;
	uint32 CurrentBlock = 0;
	uint32 CurrentByteCursor = 0;
	uint8* Blocks[FNameMaxBlocks] = {};

	FORCEINLINE uint32 NumBlocks() const
	{
		return CurrentBlock + 1;
	}

	FORCEINLINE FNameEntry& Resolve(FNameEntryHandle Handle) const
	{
		if (Handle.Offset < 0 && Handle.Block > NumBlocks() && Handle.Offset * Stride < FNameBlockOffsets)
			return *reinterpret_cast<FNameEntry*>(Blocks[0] + Stride * 0);
		
		return *reinterpret_cast<FNameEntry*>(Blocks[Handle.Block] + Stride * Handle.Offset);
	}

	void LogBlock(uint8* It, uint32 BlockSize, ImSorryForTheQualityOfThis& LOG);

	void Log(ImSorryForTheQualityOfThis& LOG);
};

wchar_t* FNameEntry::DecryptWide() 
{
	
	auto _DecryptWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, wchar_t* Buffer))(BaseAddress + DecryptWideOffset);

	wchar_t Buffer[1024];

	__int64 Result = _DecryptWideEntry(this, Buffer);

	return Buffer;
}

char* FNameEntry::DecryptNonWide() 
{
	auto _DecryptNonWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, char* Buffer))(BaseAddress + DecryptNonWideOffset);

	char Buffer[1024];

	__int64 Result = _DecryptNonWideEntry(this, Buffer);

	return Buffer;
}

std::string FNameEntry::String()
{
	if (IsWide()) {
		WCHAR* DecryptedName = DecryptWide();
		std::wstring Wide(DecryptedName, Header.Len);
		return std::string(Wide.begin(), Wide.end());
	}

	char* DecryptedName = DecryptNonWide();
	return std::string(DecryptedName, Header.Len);
}

int32 FNameEntry::GetSize(int32 Length, bool bIsPureAnsi)
{
	int32 Bytes = GetDataOffset() + Length * (bIsPureAnsi ? sizeof(ANSICHAR) : sizeof(WIDECHAR));
	return Align(Bytes, alignof(FNameEntry));
}

void FNameEntryAllocator::LogBlock(uint8* It, uint32 BlockSize, ImSorryForTheQualityOfThis& LOG)
{
	uint8* End = It + BlockSize - FNameEntry::GetDataOffset();
	while (It < End)
	{
		FNameEntry* Entry = reinterpret_cast<FNameEntry*>(It);

		if (uint32 Len = Entry->GetEntryHeader().Len)
		{
			LOG.LogToFile("[" + std::to_string(Entry->ComparisonId.Value) + "] " + Entry->String());
			It += FNameEntry::GetSize(Len, !Entry->IsWide());
		}
		else
		{
			break;
		}
	}
}

void FNameEntryAllocator::Log(ImSorryForTheQualityOfThis& LOG)
{
	LOG.LogToFile("Logging FNamePool->Entries...\n");

	for (uint32 BlockIdx = 0; BlockIdx < CurrentBlock; ++BlockIdx)
	{
		LogBlock(Blocks[BlockIdx], BlockSizeBytes, LOG);
	}

	LogBlock(Blocks[CurrentBlock], CurrentByteCursor, LOG);

	LOG.LogToFile("\nFNamePool->Entries log has completed.");

	LOG.CloseLog();
}

class FNamePool
{
public:
	enum { MaxENames = 512 };
	FNameEntryAllocator Entries;
	/*
	* Not interested in other members.
	*/
};

struct FName {
	FNameEntryId	ComparisonIndex;

	FNameEntryId	DisplayIndex;

	uint32			Number;

	FORCEINLINE FNameEntryId GetComparisonIndex() const
	{
		return ComparisonIndex;
	}

	FORCEINLINE FNameEntryId GetDisplayIndex() const
	{
		return DisplayIndex;
	}

	FORCEINLINE bool operator==(FName Other) const
	{
		return (ComparisonIndex == Other.ComparisonIndex) && (GetNumber() == Other.GetNumber());
	}

	FORCEINLINE bool operator!=(FName Other) const
	{
		return !(*this == Other);
	}

	FORCEINLINE int32 GetNumber() const
	{
		return Number;
	}

	FName() :
		ComparisonIndex(FNameEntryId()),
		Number(0)
	{ }

	FName(int32 i, int32 n = 0) :
		ComparisonIndex(FNameEntryId(i)),
		Number(n)
	{ }

	const FNameEntry* GetDisplayNameEntry() const;

	std::string GetName();
};

const FNameEntry* FName::GetDisplayNameEntry() const
{
	return &NamePoolData->Entries.Resolve(GetDisplayIndex());
}

std::string FName::GetName()
{
	FNameEntry Entry = NamePoolData->Entries.Resolve(GetDisplayIndex());

	std::string Name = Entry.String();

	if (Number > 0) Name += '_' + std::to_string(Number);

	std::size_t Pos = Name.rfind('/');

	if (Pos != std::string::npos) Name = Name.substr(Pos + 1);

	return Name;
}
```

`VALORANT/VALORANT.h`:

```h
#pragma once

#include <Windows.h>
#include <string>
#include <Misc/Types.h>
#include <Misc/AllignmentTemplates.h>
#include <Misc/ImSorryForTheQualityOfThis.h>

uint64 BaseAddress = NULL;
class FNamePool* NamePoolData = nullptr;

#define FileName "\\FNamePool_Entries_Log.txt"

#define DecryptWideOffset 0x3127D20
#define DecryptNonWideOffset 0x3127CB0 
#define NamePoolDataOffset 0x8EC8540

#include <VALORANT/FNamePool.h>

```

`dllmain.cpp`:

```cpp
#include <VALORANT/VALORANT.h>

/*

this art only showing up properly on vs not on github lol im too lazy to fix fuck off

									 '."""""""""""""""""`.
									   `.       ...       `.
										 `.    /   `.       `.
										  .'"":_    :"""""".'|
										.'//)/) `  (/)/)).'  |
									  .'/)_/""   __ ""\.'    |
									  |"""(((""""((("""|     |
		 ||							  |    ""     ""   |     |
		 ||							  |			       |     '
		_||							  |   BANANAESSZ   |   .'			ME :D <-----------------------------> VALORANT E-GIRLS <3
	   /__3							  |                | .'			       
	  / /||		YOU					  |                |'		       _______________                        |*\_/*|________
	 / / // .--.					  """""""""""""""""			      |  ___________  |     .-.     .-.      ||_/-\_|______  |
	 \ \// / (OO)													  | | C:\>_     | |    .****. .****.     | |           | |
	  \//  |( _ )													  | |   0   0   | |    .*****.*****.     | |   0   0   | |
	  // \__/`-'\__		 Hopefully some monkey finds this useful.	  | |     -     | |     .*********.      | |     -     | |
	 // \__      _ \												  | |   \___/   | |      .*******.       | |   \___/   | |
 _.-'/    | ._._.|\ \	 I'm so sleepy. 							  | |___     ___| |       .*****.        | |___________| |
(_.-'     |      \ \ \												  |_____|\_/|_____|        .***.         |_______________|
   .-._   /    o ) / /	 I go to sleep now, goodnight.				    _|__|/ \|_|_.............*.............._|________|_
  /_ \ \ /   \__/ / /												   / ********** \                          / ********** \
	\ \_/   / /  |_/												 /  ************  \                      /  ************  \
	 \     / /														--------------------                    --------------------
	  `-._/-' 

*/


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    if (ul_reason_for_call != DLL_PROCESS_ATTACH) return FALSE;

	BaseAddress = reinterpret_cast<uintptr_t>(GetModuleHandleA(NULL));
	if (!BaseAddress) return FALSE;

	NamePoolData = reinterpret_cast<FNamePool*>(BaseAddress + NamePoolDataOffset);

	FName NoneFName(0); 
	
	std::string None = NoneFName.GetName();

	if (None != "None") return FALSE;

	ImSorryForTheQualityOfThis LOG(FileName);

	FNameEntryAllocator Entries = NamePoolData->Entries;

	LOG.LogToFile("[ (*^-^*) Kinda Sorta Some Information ]\n");

	LOG.LogToFile("Base Address ", BaseAddress);
	LOG.LogToFile("FNamePool* NamePoolData ", NamePoolData);
	LOG.LogToFile("Entries.CurrentBlock " + std::to_string(Entries.CurrentBlock));
	LOG.LogToFile("Entries.CurrentByteCursor " + std::to_string(Entries.CurrentByteCursor));
	LOG.LogToFile("Entries.Blocks ", Entries.Blocks);

	LOG.LogToFile("\n[ End Of Kinda Sorta Some Information `(°.°)`  ]\n");
	
	NamePoolData->Entries.Log(LOG);

    return TRUE;
}

```